package Model.APPS.CCU4_SLICE_CONFIG.v4_0_16.Templates;

import Model.APPS.CCU4_SLICE_CONFIG.v4_0_16.CCU4_SLICE_CONFIG

out.print("""
/**
 * @file ccu4_slice_config_conf.c
 * @date 2017-11-10
 *
 * NOTE:
 * This file is generated by DAVE-4. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 *
 * Copyright (c) 2015-2016, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-08-30:
 *     - Initial version<br>
 *
 * 2016-04-18:
 *     - Missing code generation for external event configuration is fixed.<br>
 * 
 * 2016-06-21:
 *     - First productive version
 *
 * 2017-04-05:
 *     - Add initial timer value
 *
 * 2017-04-11:
 *     - Generate initialization of input event independently of whether they are used for any timer function
 *
 * 2017-11-10:
 *     - Fix C++ compilation issues
 * @endcond
 *
 */

/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include "ccu4_slice_config.h"

""");

String    appInst                    = null;
List      MappedUri0                 = null;
String    module                     = null;
String    slice                      = null;
String    module_ptr                 = null;
String    slice_ptr                  = null;

for (CCU4_SLICE_CONFIG appIns : appInstancesList  ) 
{

	appInst = appIns.getInstanceLabel()
	MappedUri0 = appIns.hwres_ccu4_cc4_slice.getSolverUri()
		
	String series = (appIns.daveEnv.project.selectedDevice.deviceId.family + appIns.daveEnv.project.selectedDevice.deviceId.series)

	if (MappedUri0 != null) 
	{
		module = MappedUri0[4]
		slice  = MappedUri0[6]
		module_ptr = "CCU4" + module
		slice_ptr = "CCU4" + module + "_CC4" + slice

		out.print("""
static CCU4_SLICE_CONFIG_STATUS_t ${appInst}_lInit(void);
        """)
			
						out.print("""
const CCU4_SLICE_CONFIG_t ${appInst} =
{
  .init = ${appInst}_lInit,
  .global = &${appIns.app_global_ccu4.getInstanceLabel()},
  .slice_ptr = ${slice_ptr},
  .slice_num = (uint8_t)${slice}
};
        """)
			
		if(appIns.gcombo_operation_mode.value == "Compare Mode")
		{				
			out.print("""
const XMC_CCU4_SLICE_COMPARE_CONFIG_t ${appInst}_compare_config     =
{
  .timer_mode            = (uint32_t)XMC_CCU4_SLICE_TIMER_COUNT_MODE_${(appIns.gcombo_compare_counting_mode.value == "Edge Aligned") ? "EA" : "CA"},
  .monoshot              = (uint32_t)XMC_CCU4_SLICE_TIMER_REPEAT_MODE_${appIns.gcheck_single_shot_mode.value ? "SINGLE" : "REPEAT"},
  .shadow_xfer_clear     = ${appIns.gcheck_enable_shadow_transfer_on_clear.value ? "true" : "false"},
  .dither_timer_period   = ${((appIns.gcombo_dither_mode.value == "Period is increased by 1 cycle") || 
                              (appIns.gcombo_dither_mode.value == "Period is increased by 1 cycle and compare match is delayed by 1 cycle")) ? "true" : "false"},
  .dither_duty_cycle     = ${((appIns.gcombo_dither_mode.value == "Compare match is delayed by 1 cycle") || 
                              (appIns.gcombo_dither_mode.value == "Period is increased by 1 cycle and compare match is delayed by 1 cycle")) ? "true" : "false"},
  .prescaler_mode        = (uint32_t)XMC_CCU4_SLICE_PRESCALER_MODE_${(appIns.gcombo_prescaler_mode.value == "Normal Mode") ? "NORMAL" : "FLOAT"},  
  .mcm_enable            = ${appIns.gcheck_enable_multichannel_control.value ? "true" : "false"},        
  .prescaler_initval     = XMC_CCU4_SLICE_PRESCALER_${appIns.gcombo_prescaler_initial.value},
  .float_limit           = XMC_CCU4_SLICE_PRESCALER_${appIns.gcombo_floating_prescaler_maximum.value},
  .dither_limit          = ${appIns.ginteger_dither_compare_value.value},
  .passive_level         = XMC_CCU4_SLICE_OUTPUT_PASSIVE_LEVEL_${(appIns.gcombo_output_passive_level.value == "Low") ? "LOW" : "HIGH"},  
  .timer_concatenation   = ${appIns.hwres_ccu4_cc4_slice.getRegValue("cmc", "cmc_tce") ? "true" : "false"}
};
            """)
		} // Compare mode
	    else
		{
			out.print("""
const XMC_CCU4_SLICE_CAPTURE_CONFIG_t  ${appInst}_capture_config     =
{ 
  .fifo_enable           = ${appIns.gcheck_enable_extended_capture_mode.value ? "true" : "false"},
  .timer_clear_mode      = XMC_CCU4_SLICE_TIMER_CLEAR_MODE_${
                             def result
                             switch(appIns.gcombo_timer_clear_control.value)
                             {
                               case "Never cleared":
                                 result = "NEVER"
                                 break
                               case "Cleared on capture into reg 2 and 3 (trigger 1)":
                                 result = "CAP_HIGH"
                                 break
                               case "Cleared on capture into reg 0 and 1 (trigger 0)":
                                 result = "CAP_LOW"
                                 break
                               case "Always in a capture event":
                                 result = "ALWAYS"
                                 break
                             }
                             result
                           },
  .same_event			 = ${appIns.gcheck_enable_same_capture_event.value ? "true" : "false"},
  .ignore_full_flag      = ${appIns.gcheck_ignore_full_flag_rules.value ? "true" : "false"},
  .prescaler_mode        = XMC_CCU4_SLICE_PRESCALER_MODE_${(appIns.gcombo_prescaler_mode.value == "Normal Mode") ? "NORMAL" : "FLOAT"},  
  .prescaler_initval     = XMC_CCU4_SLICE_PRESCALER_${appIns.gcombo_prescaler_initial.value},
  .float_limit           = XMC_CCU4_SLICE_PRESCALER_${appIns.gcombo_floating_prescaler_maximum.value},
  .timer_concatenation   = ${appIns.hwres_ccu4_cc4_slice.getRegValue("cmc", "cmc_tce") ? "true" : "false"}
};
            """)
	    } // Capture mode	
			
		// Events
		for (int event = 0; event < 3; event++)
		{
            def mapped_input
			def event_is
			event_is = "ins_ev"+event+"is"
			
			if (series != 'XMC14')
			{
			  mapped_input = "XMC_CCU4_SLICE_INPUT_${(char)(appIns.hwres_ccu4_cc4_slice.getRegValue("ins", event_is) + 65)}"
			}
			else
			{
			  mapped_input = "XMC_CCU4_SLICE_INPUT_${(char)(((appIns.hwres_ccu4_cc4_slice.getRegValue("ins", event_is) as int) / 26) + 65)}${(char)(((appIns.hwres_ccu4_cc4_slice.getRegValue("ins", event_is) as int) % 26) + 65)}"				
			}

			out.print("""
const XMC_CCU4_SLICE_EVENT_CONFIG_t ${appInst}_event${event}_config = 
{
  .mapped_input        = ${mapped_input},
  .edge                = XMC_CCU4_SLICE_EVENT_EDGE_SENSITIVITY_${
                             def result
                             switch(appIns.rArraygindexgroup_input_event_configuration[event].gcombo_event_edge_selection.value)
                             {
                               case "No action":
                                 result = "NONE"
                                 break
                               case "Signal active on rising edge":
                                 result = "RISING_EDGE"
                                 break
                               case "Signal active on falling edge":
                                 result = "FALLING_EDGE"
                                 break
                               case "Signal active on both edges":
                                 result = "DUAL_EDGE"
                                 break
                             }
                           },
  .level               = XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_${
                             def result
                             switch(appIns.rArraygindexgroup_input_event_configuration[event].gcombo_event_level_selection.value)
                             {
                               case "Active on high level":
                                 result = "ACTIVE_HIGH"
                                 break
                               case "Active on low level":
                                 result = "ACTIVE_LOW"
                                 break
                             } 
                             result
                           },
  .duration            = XMC_CCU4_SLICE_EVENT_FILTER_${
                             def result
                             switch(appIns.rArraygindexgroup_input_event_configuration[event].gcombo_event_lpf_configuration.value)
                             {
                               case "LPF is disabled":
                                 result = "DISABLED"
                                 break
                               case "3 clock cycles of fCCU4":
                                 result = "3_CYCLES"
                                 break
                               case "5 clock cycles of fCCU4":
                                 result = "5_CYCLES"
                                 break
                               case "7 clock cycles of fCCU4":
                                 result = "7_CYCLES"
                                 break
                             } 
                             result
                           }                               
 };
            """)
	    }
	}
	else 
	{
		out.print("""
  /*CCU40 resource is not mapped for CCU4_SLICE_CONFIG app instant: ${appInst} */
        """);
	}
	
	out.print("""
/* Channel initialization function */
CCU4_SLICE_CONFIG_STATUS_t ${appInst}_lInit(void)
{
 	
  GLOBAL_CCU4_Init(&${appIns.app_global_ccu4.getInstanceLabel()});

  ${
    def result
    if(appIns.gcombo_operation_mode.value == "Compare Mode")
    {
      result = """
  /* Configure CCU4x_CC4y slice as timer unit */
  XMC_CCU4_SLICE_CompareInit(${slice_ptr}, &${appInst}_compare_config);
  /* Set initial value of timer */
  XMC_CCU4_SLICE_SetTimerValue(${slice_ptr}, (uint16_t)${appIns.ginteger_timer_initial_value.value}U);
  /* Set timer compare register value */
  XMC_CCU4_SLICE_SetTimerCompareMatch(${slice_ptr}, (uint16_t)${appIns.ginteger_timer_compare_value.value}U);
  /* Set timer period register value */
  XMC_CCU4_SLICE_SetTimerPeriodMatch(${slice_ptr}, (uint16_t)${appIns.ginteger_timer_period_value.value}U);	
	  """
    }
    else
    {
      result = """
  /* Configure CCU4x_CC4y slice as capture unit */		  
  XMC_CCU4_SLICE_CaptureInit(${slice_ptr}, &${appInst}_capture_config);
	  """
      if(appIns.ginteger_max_count_value.enabled)
      {
        result += """
  XMC_CCU4_SLICE_SetTimerPeriodMatch(${slice_ptr}, (uint16_t)${appIns.ginteger_max_count_value.value}U);
		"""
      }      
    }
    result
  }
  
  /* Register value update settings */
  ${
    def result = ""
    if (appIns.gcheck_enable_mcss_input.value)
    {
      result = """
  XMC_CCU4_SetMultiChannelShadowTransferMode(${module_ptr}, (uint32_t)XMC_CCU4_MULTI_CHANNEL_SHADOW_TRANSFER_SW_MCSS_SLICE${slice});
	  """
    }
    else
    {
      result = """
  XMC_CCU4_SetMultiChannelShadowTransferMode(${module_ptr}, (uint32_t)XMC_CCU4_MULTI_CHANNEL_SHADOW_TRANSFER_SW_SLICE${slice});
	  """
    }
    result
  }

  ${
    def result = ""
    if (series == 'XMC14')
    {
      if (appIns.gcheck_enable_cascade_shadow_transfer.value)
      {
        result = """
  XMC_CCU4_SLICE_EnableCascadedShadowTransfer(${slice_ptr});
		"""
      }
      else
      {
        result = """
  XMC_CCU4_SLICE_DisableCascadedShadowTransfer(${slice_ptr});
		"""
      }
    }
    result
  }

  ${
    def result = ""
    if (series == 'XMC14')
    {
      if (appIns.gcombo_compare_counting_mode.value == "Center Aligned")
      {
        result = """
  XMC_CCU4_SLICE_SetShadowTransferMode(${slice_ptr}, XMC_CCU4_SLICE_SHADOW_TRANSFER_MODE_${appIns.gcombo_shadow_transfer_mode.value.toUpperCase().replaceAll(' ', '_')});
	    """
      }
    }
	 result
  }

  ${
    def result = ""
    if (series == 'XMC14')
    {
      def mask = []
      if (appIns.gcheck_enable_period_immediate_update.value)
      {
        mask += "XMC_CCU4_SLICE_WRITE_INTO_PERIOD_CONFIGURATION"
      }
      if (appIns.gcheck_enable_compare_immediate_update.value)
      {
        mask += "XMC_CCU4_SLICE_WRITE_INTO_COMPARE_CONFIGURATION"
      }
      if (appIns.gcheck_enable_psl_immediate_update.value)
      {
        mask += "XMC_CCU4_SLICE_WRITE_INTO_PASSIVE_LEVEL_CONFIGURATION"
      }
      if (appIns.gcheck_enable_dither_immediate_update.value)
      {
        mask += "XMC_CCU4_SLICE_WRITE_INTO_DITHER_VALUE_CONFIGURATION"
      }
      if (appIns.gcheck_enable_prescaler_immediate_update.value)
      {
        mask += "XMC_CCU4_SLICE_WRITE_INTO_FLOATING_PRESCALER_VALUE_CONFIGURATION"
      }
      if (mask.size() > 0)
      {
        result += """
  XMC_CCU4_SLICE_WriteImmediateAfterShadowTransfer(${slice_ptr}, ${mask.join(" | ")});
	              """
      }
    }
    result  
  }

  ${
    result = ""
    if (series == 'XMC14')
    {
      def mask = []
      if (appIns.gcheck_automatic_shadow_transfer_request_on_period_write.value)
      {
        mask += "XMC_CCU4_SLICE_AUTOMAIC_SHADOW_TRANSFER_WRITE_INTO_PERIOD_SHADOW"
      }
      if (appIns.gcheck_automatic_shadow_transfer_request_on_compare_write.value)
      {
        mask += "XMC_CCU4_SLICE_AUTOMAIC_SHADOW_TRANSFER_WRITE_INTO_COMPARE1_SHADOW"
      }
      if (appIns.gcheck_automatic_shadow_transfer_request_on_psl_write.value)
      {
        mask += "XMC_CCU4_SLICE_AUTOMAIC_SHADOW_TRANSFER_WRITE_INTO_PASSIVE_LEVEL"
      }
      if (appIns.gcheck_automatic_shadow_transfer_request_on_dither_write.value)
      {
        mask += "XMC_CCU4_SLICE_AUTOMAIC_SHADOW_TRANSFER_WRITE_INTO_DITHER_SHADOW"
      }
      if (appIns.gcheck_automatic_shadow_transfer_request_on_prescaler_write.value)
      {
        mask += "XMC_CCU4_SLICE_AUTOMAIC_SHADOW_TRANSFER_WRITE_INTO_FLOATING_PRESCALER_SHADOW"
      }
      if (mask.size() > 0)
      {
        result = """
  XMC_CCU4_SLICE_EnableAutomaticShadowTransferRequest(${slice_ptr}, ${mask.join(" | ")});
	             """
      }
    }
    result
  }

  /* Transfer value from shadow registers to actual timer registers */
  XMC_CCU4_EnableShadowTransfer(${module_ptr}, (uint32_t)XMC_CCU4_SHADOW_TRANSFER_SLICE_${slice} |
                                               (uint32_t)XMC_CCU4_SHADOW_TRANSFER_DITHER_SLICE_${slice} |
                                               (uint32_t)XMC_CCU4_SHADOW_TRANSFER_PRESCALER_SLICE_${slice});

  /* Events and function settings */
  ${
    def result = ""
    for (int event = 0; event < 3; event++)
    {
        result += """
  XMC_CCU4_SLICE_ConfigureEvent(${slice_ptr}, XMC_CCU4_SLICE_EVENT_${event}, &${appInst}_event${event}_config);
        """
    }
    result
  }

  ${
    def result = ""
    if(appIns.gcombo_start_function.value != "Disabled")
    {
      def event = "XMC_CCU4_SLICE_EVENT_" + appIns.gcombo_start_function.value[-1]
      def mode = "XMC_CCU4_SLICE_START_MODE_TIMER_"
      switch(appIns.gcombo_start_function_mode.value)
      {
        case "Start timer":
          mode += "START"
          break
        case "Clear and Start timer":
          mode += "START_CLEAR"
          break
      }
      result = """
  XMC_CCU4_SLICE_StartConfig(${slice_ptr}, ${event}, ${mode});
	  """
    }
    result
  }

  ${
    def result = ""
    if(appIns.gcombo_stop_function.value != "Disabled")
    {
      def event = "XMC_CCU4_SLICE_EVENT_" + appIns.gcombo_stop_function.value[-1]
      def mode = "XMC_CCU4_SLICE_END_MODE_TIMER_"
      switch(appIns.gcombo_stop_function_mode.value)
      {
        case "Stop timer":
          mode += "STOP"
          break
        case "Clear timer":
          mode += "CLEAR"
          break
        case "Clear and Stop timer":
          mode += "STOP_CLEAR"
          break
      }
      result = """
  XMC_CCU4_SLICE_StopConfig(${slice_ptr}, ${event}, ${mode});
      """
    }
    result
  }

  ${
    def result = ""
    if(appIns.gcombo_count_function.value != "Disabled")
    {
      def event = "XMC_CCU4_SLICE_EVENT_" + appIns.gcombo_count_function.value[-1]
      result = """
  XMC_CCU4_SLICE_CountConfig(${slice_ptr}, ${event});
      """
    }
    result
  }

  ${
    def result = ""
    if(appIns.gcombo_direction_function.value != "Disabled")
    {
      def event = "XMC_CCU4_SLICE_EVENT_" + appIns.gcombo_direction_function.value[-1]
      result = """
  XMC_CCU4_SLICE_DirectionConfig(${slice_ptr}, ${event});
      """
    }
    result
  }

  ${
    def result = ""
    if(appIns.gcombo_capture0_function.value != "Disabled")
    {
      def event = "XMC_CCU4_SLICE_EVENT_" + appIns.gcombo_capture0_function.value[-1]
      result = """
  XMC_CCU4_SLICE_Capture0Config(${slice_ptr}, ${event});
      """
    }
    result
  }

  ${
    def result = ""
    if(appIns.gcombo_capture1_function.value != "Disabled")
    {
      def event = "XMC_CCU4_SLICE_EVENT_" + appIns.gcombo_capture1_function.value[-1]
      result = """
  XMC_CCU4_SLICE_Capture1Config(${slice_ptr}, ${event});
      """
    }
    result
  }

  ${
    def result = ""
    if(appIns.gcombo_gate_function.value != "Disabled")
    {
      def event = "XMC_CCU4_SLICE_EVENT_" + appIns.gcombo_gate_function.value[-1]
      result = """
  XMC_CCU4_SLICE_GateConfig(${slice_ptr}, ${event});
      """
    }
    result
  }

  ${
    def result = ""
    if(appIns.gcombo_load_function.value != "Disabled")
    {
      def event = "XMC_CCU4_SLICE_EVENT_" + appIns.gcombo_load_function.value[-1]
      result = """
  XMC_CCU4_SLICE_LoadConfig(${slice_ptr}, ${event});
      """
    }
    result
  }

  ${
    def result = ""
    if(appIns.gcombo_trap_function.value != "Disabled")
    {
      def args
      switch(appIns.gcombo_exit_trap_state_mode.value)
      {
        case "Automatic":
          args = "XMC_CCU4_SLICE_TRAP_EXIT_MODE_AUTOMATIC, false"
          break
        case "Automatic synchronous with PWM":
          args = "XMC_CCU4_SLICE_TRAP_EXIT_MODE_AUTOMATIC, true"
          break
        case "Software":
          args = "XMC_CCU4_SLICE_TRAP_EXIT_MODE_SW, false"
          break
        case "Software synchronous with PWM ":
          args = "XMC_CCU4_SLICE_TRAP_EXIT_MODE_SW, true"
          break

      }
      def event = "XMC_CCU4_SLICE_EVENT_" + appIns.gcombo_trap_function.value[-1]
      result = """
  XMC_CCU4_SLICE_TrapConfig(${slice_ptr}, ${args});	  
      """
    }
    result
  }

  ${
    def result = ""
    if(appIns.gcombo_modulation_function.value != "Disabled")
    {
      def event = "XMC_CCU4_SLICE_EVENT_" + appIns.gcombo_modulation_function.value[-1]

      def args
      switch(appIns.gcombo_modulation_function_mode.value)
      {
        case "Clear ST and OUT signals":
          args = "XMC_CCU4_SLICE_MODULATION_MODE_CLEAR_ST_OUT"
          break
        case "Clear only the OUT signal":
          args = "XMC_CCU4_SLICE_MODULATION_MODE_CLEAR_OUT"
          break
      }

      if (appIns.gcheck_enable_modulation_sync_with_pwm.value)
      {
        args += ", true"
      }
      else
      {
        args += ", false"
      }

      result = """
  XMC_CCU4_SLICE_ModulationConfig(${slice_ptr}, ${event}, ${args});	  
      """
    }
    result
  }
  
  ${
    def result = ""
    if(appIns.gcombo_override_trigger_function.value != "Disabled" && appIns.gcombo_override_value_function.value != "Disabled")
    {
      result = """
  XMC_CCU4_SLICE_StatusBitOverrideConfig(${slice_ptr});	       
		       """
    }
    result
  }

  ${
    def mask = []
    def result = ""
    if(appIns.gcheck_enable_period_match_event.value) 
    {
      mask.add("XMC_CCU4_SLICE_MULTI_IRQ_ID_PERIOD_MATCH")
      result += """
  XMC_CCU4_SLICE_SetInterruptNode(${slice_ptr}, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH, XMC_CCU4_SLICE_SR_ID_${appIns.hwres_ccu4_cc4_slice.getRegValue("srs", "srs_posr")});
      """
    }

    if(appIns.gcheck_enable_one_match_event.value) 
    {
      mask.add("XMC_CCU4_SLICE_MULTI_IRQ_ID_ONE_MATCH")
      result += """
  XMC_CCU4_SLICE_SetInterruptNode(${slice_ptr}, XMC_CCU4_SLICE_IRQ_ID_ONE_MATCH, XMC_CCU4_SLICE_SR_ID_${appIns.hwres_ccu4_cc4_slice.getRegValue("srs", "srs_posr")});
      """
    }

    if(appIns.gcheck_enable_compare_up_event.value) 
    {
      mask.add("XMC_CCU4_SLICE_MULTI_IRQ_ID_COMPARE_MATCH_UP")
      result += """
  XMC_CCU4_SLICE_SetInterruptNode(${slice_ptr}, XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP, XMC_CCU4_SLICE_SR_ID_${appIns.hwres_ccu4_cc4_slice.getRegValue("srs", "srs_cmsr")});
      """
    }

    if(appIns.gcheck_enable_compare_down_event.value) 
    {
      mask.add("XMC_CCU4_SLICE_MULTI_IRQ_ID_COMPARE_MATCH_DOWN")
      result += """
  XMC_CCU4_SLICE_SetInterruptNode(${slice_ptr}, XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_DOWN, XMC_CCU4_SLICE_SR_ID_${appIns.hwres_ccu4_cc4_slice.getRegValue("srs", "srs_cmsr")});
      """
    }

    if(appIns.gcheck_enable_external_event0.value) 
    {
      mask.add("XMC_CCU4_SLICE_MULTI_IRQ_ID_EVENT0")
      result += """
  XMC_CCU4_SLICE_SetInterruptNode(${slice_ptr}, XMC_CCU4_SLICE_IRQ_ID_EVENT0, XMC_CCU4_SLICE_SR_ID_${appIns.hwres_ccu4_cc4_slice.getRegValue("srs", "srs_e0sr")});
      """
    }

    if(appIns.gcheck_enable_external_event1.value) 
    {
      mask.add("XMC_CCU4_SLICE_MULTI_IRQ_ID_EVENT1")
      result += """
  XMC_CCU4_SLICE_SetInterruptNode(${slice_ptr}, XMC_CCU4_SLICE_IRQ_ID_EVENT1, XMC_CCU4_SLICE_SR_ID_${appIns.hwres_ccu4_cc4_slice.getRegValue("srs", "srs_e1sr")});
      """
    }

    if(appIns.gcheck_enable_external_event2.value) 
    {
      mask.add("XMC_CCU4_SLICE_MULTI_IRQ_ID_EVENT2")
      result += """
  XMC_CCU4_SLICE_SetInterruptNode(${slice_ptr}, XMC_CCU4_SLICE_IRQ_ID_EVENT2, XMC_CCU4_SLICE_SR_ID_${appIns.hwres_ccu4_cc4_slice.getRegValue("srs", "srs_e2sr")});
      """
    }
   if (mask.size() > 0)
   {
     result += """
  XMC_CCU4_SLICE_EnableMultipleEvents(${slice_ptr}, ${mask.join(" | ")});
     """
   }
   result
  }
			
  /* clear IDLE mode for the slice*/
  XMC_CCU4_EnableClock(${module_ptr}, (uint8_t)${slice});	
	
  ${
    def result = ""
    if(appIns.gcheck_enable_trap_during_initialization.value && (appIns.gcombo_trap_function.value != "Disabled")) 
    {
      result = """ 
  /* Enable trap */
  XMC_CCU4_SLICE_EnableTrap(${slice_ptr});
	  """
    }
    result
  }

  ${
    def result = ""
    if(appIns.gcheck_init_start.value) 
    {
      result = """ 
  /* Start the timer */
  XMC_CCU4_SLICE_StartTimer(${slice_ptr});
	  """
    }
    result
  }

  return CCU4_SLICE_CONFIG_STATUS_SUCCESS;
}
	""".replaceAll("(?m)^[ \t]*\r?\n", ""))
} // for
