
P2G_FW.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        0000029c  08000000  0c000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000b278  08020000  0c020000  00010000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .ARM.exidx    00000008  0802b278  0c02b278  0001b278  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 Stack         00000800  1ffe8000  1ffe8000  00028000  2**0
                  ALLOC
  4 .data         000003e0  1ffe8800  0c02b280  00020800  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          00012384  1ffe8be0  0c02b660  00020be0  2**3
                  ALLOC
  6 USB_RAM       00000e00  20000000  20000000  00028000  2**2
                  ALLOC
  7 .no_init      00000014  2003ffc0  2003ffc0  00027fc0  2**2
                  ALLOC
  8 .debug_aranges 00001f50  00000000  00000000  00020be0  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   000860e8  00000000  00000000  00022b30  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 0000e9d3  00000000  00000000  000a8c18  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   0001be6a  00000000  00000000  000b75eb  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00005410  00000000  00000000  000d3458  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00017e58  00000000  00000000  000d8868  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    0001e536  00000000  00000000  000f06c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00005810  00000000  00000000  0010ebf6  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .build_attributes 0000165c  00000000  00000000  00114406  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

08020000 <ds_algo_get_settings>:
//============================================================================

algo_settings_t *ds_algo_get_settings(void)
{
  return &ds_algo_settings;
}
 8020000:	4800      	ldr	r0, [pc, #0]	; (8020004 <ds_algo_get_settings+0x4>)
 8020002:	4770      	bx	lr
 8020004:	1ffe8be0 	.word	0x1ffe8be0

08020008 <ds_device_get_settings>:
//============================================================================

device_settings_t *ds_device_get_settings(void)
{
  return &ds_device_settings;
}
 8020008:	4800      	ldr	r0, [pc, #0]	; (802000c <ds_device_get_settings+0x4>)
 802000a:	4770      	bx	lr
 802000c:	1ffe8c70 	.word	0x1ffe8c70

08020010 <ds_device_get_shadow_settings>:
//============================================================================

device_settings_t *ds_device_get_shadow_settings(void)
{
  return &ds_shadow_device_settings;
}
 8020010:	4800      	ldr	r0, [pc, #0]	; (8020014 <ds_device_get_shadow_settings+0x4>)
 8020012:	4770      	bx	lr
 8020014:	1ffe8c2c 	.word	0x1ffe8c2c

08020018 <ds_is_device_settings_updated>:

//============================================================================

/* Handling for staged setting */
uint32_t ds_is_device_settings_updated(void)
{
 8020018:	b508      	push	{r3, lr}
  int32_t retValue = 0;
  
  /* If both structs are identical, retValue is 0, otherwise != 0 */
  retValue = memcmp(&ds_shadow_device_settings,&ds_device_settings, sizeof(ds_shadow_device_settings));
 802001a:	4904      	ldr	r1, [pc, #16]	; (802002c <ds_is_device_settings_updated+0x14>)
 802001c:	4804      	ldr	r0, [pc, #16]	; (8020030 <ds_is_device_settings_updated+0x18>)
 802001e:	2244      	movs	r2, #68	; 0x44
 8020020:	f00a fd6e 	bl	802ab00 <memcmp>
  
  /* Result of memcmp could be negative! */
  return (retValue == 0) ? 0U : 1U;
}
 8020024:	3000      	adds	r0, #0
 8020026:	bf18      	it	ne
 8020028:	2001      	movne	r0, #1
 802002a:	bd08      	pop	{r3, pc}
 802002c:	1ffe8c70 	.word	0x1ffe8c70
 8020030:	1ffe8c2c 	.word	0x1ffe8c2c

08020034 <ds_device_settings_copy_to_shadow>:

//============================================================================

void ds_device_settings_copy_to_shadow(void)
{
 8020034:	b508      	push	{r3, lr}
  memcpy(&ds_shadow_device_settings, &ds_device_settings, sizeof(ds_shadow_device_settings));
 8020036:	4903      	ldr	r1, [pc, #12]	; (8020044 <ds_device_settings_copy_to_shadow+0x10>)
 8020038:	4803      	ldr	r0, [pc, #12]	; (8020048 <ds_device_settings_copy_to_shadow+0x14>)
 802003a:	2244      	movs	r2, #68	; 0x44
 802003c:	f00a fd70 	bl	802ab20 <memcpy>
 8020040:	bd08      	pop	{r3, pc}
 8020042:	bf00      	nop
 8020044:	1ffe8c70 	.word	0x1ffe8c70
 8020048:	1ffe8c2c 	.word	0x1ffe8c2c

0802004c <ds_init>:

/* This function could be used to pre-init the settings store
 *  e.g. with persistent value, that are stored in some persistent memory region.
 */
uint32_t ds_init(void)
{
 802004c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t retValue = 0;
  
  ds_algo_settings = ds_default_algo_settings;
 8020050:	4c1c      	ldr	r4, [pc, #112]	; (80200c4 <ds_init+0x78>)
  
  ds_device_settings = ds_default_device_settings;
 8020052:	4e1d      	ldr	r6, [pc, #116]	; (80200c8 <ds_init+0x7c>)
 */
uint32_t ds_init(void)
{
  uint32_t retValue = 0;
  
  ds_algo_settings = ds_default_algo_settings;
 8020054:	4620      	mov	r0, r4
 8020056:	2100      	movs	r1, #0
 8020058:	224c      	movs	r2, #76	; 0x4c
 802005a:	f00a fd6c 	bl	802ab36 <memset>
  
  ds_device_settings = ds_default_device_settings;
 802005e:	2544      	movs	r5, #68	; 0x44
 */
uint32_t ds_init(void)
{
  uint32_t retValue = 0;
  
  ds_algo_settings = ds_default_algo_settings;
 8020060:	4b1a      	ldr	r3, [pc, #104]	; (80200cc <ds_init+0x80>)
 8020062:	f8df e074 	ldr.w	lr, [pc, #116]	; 80200d8 <ds_init+0x8c>
 8020066:	6463      	str	r3, [r4, #68]	; 0x44
 8020068:	f04f 0c04 	mov.w	ip, #4
 802006c:	2305      	movs	r3, #5
 802006e:	2764      	movs	r7, #100	; 0x64
  
  ds_device_settings = ds_default_device_settings;
 8020070:	462a      	mov	r2, r5
 8020072:	4917      	ldr	r1, [pc, #92]	; (80200d0 <ds_init+0x84>)
 */
uint32_t ds_init(void)
{
  uint32_t retValue = 0;
  
  ds_algo_settings = ds_default_algo_settings;
 8020074:	6063      	str	r3, [r4, #4]
 8020076:	f04f 0b02 	mov.w	fp, #2
 802007a:	f04f 0a5a 	mov.w	sl, #90	; 0x5a
 802007e:	f44f 797a 	mov.w	r9, #1000	; 0x3e8
 8020082:	f04f 0832 	mov.w	r8, #50	; 0x32
  
  ds_device_settings = ds_default_device_settings;
 8020086:	4630      	mov	r0, r6
 */
uint32_t ds_init(void)
{
  uint32_t retValue = 0;
  
  ds_algo_settings = ds_default_algo_settings;
 8020088:	60a3      	str	r3, [r4, #8]
 802008a:	6123      	str	r3, [r4, #16]
 802008c:	61a3      	str	r3, [r4, #24]
 802008e:	f8c4 c040 	str.w	ip, [r4, #64]	; 0x40
 8020092:	f8c4 e048 	str.w	lr, [r4, #72]	; 0x48
 8020096:	f8c4 b014 	str.w	fp, [r4, #20]
 802009a:	f8c4 a02c 	str.w	sl, [r4, #44]	; 0x2c
 802009e:	f8c4 9030 	str.w	r9, [r4, #48]	; 0x30
 80200a2:	f8c4 8038 	str.w	r8, [r4, #56]	; 0x38
 80200a6:	61e7      	str	r7, [r4, #28]
 80200a8:	6367      	str	r7, [r4, #52]	; 0x34
  
  ds_device_settings = ds_default_device_settings;
 80200aa:	f00a fd39 	bl	802ab20 <memcpy>

//============================================================================

void ds_device_settings_copy_to_shadow(void)
{
  memcpy(&ds_shadow_device_settings, &ds_device_settings, sizeof(ds_shadow_device_settings));
 80200ae:	4631      	mov	r1, r6
 80200b0:	462a      	mov	r2, r5
 80200b2:	4808      	ldr	r0, [pc, #32]	; (80200d4 <ds_init+0x88>)
 80200b4:	f00a fd34 	bl	802ab20 <memcpy>
  {
    retValue += 8192;
  }
  if(retValue == 0)
  {
    ptr->isChecked = 1;
 80200b8:	2301      	movs	r3, #1
 80200ba:	7063      	strb	r3, [r4, #1]
  ds_device_settings_copy_to_shadow();
  
  retValue += ds_algo_check_settings(&ds_algo_settings);
  
  return retValue;
}
 80200bc:	2000      	movs	r0, #0
 80200be:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80200c2:	bf00      	nop
 80200c4:	1ffe8be0 	.word	0x1ffe8be0
 80200c8:	1ffe8c70 	.word	0x1ffe8c70
 80200cc:	3fff2d46 	.word	0x3fff2d46
 80200d0:	0802ab48 	.word	0x0802ab48
 80200d4:	1ffe8c2c 	.word	0x1ffe8c2c
 80200d8:	42480000 	.word	0x42480000

080200dc <ds_get_active_acq_buf>:
//============================================================================

acq_buf_obj *ds_get_active_acq_buf(void)
{
  return &s_acq_buf;
}
 80200dc:	4800      	ldr	r0, [pc, #0]	; (80200e0 <ds_get_active_acq_buf+0x4>)
 80200de:	4770      	bx	lr
 80200e0:	1ffe8800 	.word	0x1ffe8800

080200e4 <ds_set_active_acq_buf>:

//============================================================================

void ds_set_active_acq_buf(const acq_buf_obj acq_buf)
{
 80200e4:	b084      	sub	sp, #16
 80200e6:	b538      	push	{r3, r4, r5, lr}
  if(s_acq_buf.p_acq_buf != NULL)
 80200e8:	4c0b      	ldr	r4, [pc, #44]	; (8020118 <ds_set_active_acq_buf+0x34>)
 80200ea:	6aa5      	ldr	r5, [r4, #40]	; 0x28
}

//============================================================================

void ds_set_active_acq_buf(const acq_buf_obj acq_buf)
{
 80200ec:	f10d 0e10 	add.w	lr, sp, #16
 80200f0:	e88e 000f 	stmia.w	lr, {r0, r1, r2, r3}
  if(s_acq_buf.p_acq_buf != NULL)
 80200f4:	b115      	cbz	r5, 80200fc <ds_set_active_acq_buf+0x18>
  {
    delete_acq_buffer_obj(&s_acq_buf);
 80200f6:	4620      	mov	r0, r4
 80200f8:	f000 f984 	bl	8020404 <delete_acq_buffer_obj>
  }
  
  memcpy(&s_acq_buf, &acq_buf, sizeof(acq_buf_obj));
 80200fc:	ad04      	add	r5, sp, #16
 80200fe:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020100:	4c05      	ldr	r4, [pc, #20]	; (8020118 <ds_set_active_acq_buf+0x34>)
 8020102:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8020104:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020106:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8020108:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 802010c:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
}
 8020110:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8020114:	b004      	add	sp, #16
 8020116:	4770      	bx	lr
 8020118:	1ffe8800 	.word	0x1ffe8800

0802011c <ds_ep_fetch_adc_config>:
   3. EXPORTED FUNCTIONS
==============================================================================
 */

void ds_ep_fetch_adc_config(Adc_Configuration_t *ptr)
{
 802011c:	b510      	push	{r4, lr}
 802011e:	4604      	mov	r4, r0
	device_settings_t *p_dev   = ds_device_get_settings();
 8020120:	f7ff ff72 	bl	8020008 <ds_device_get_settings>
	ptr->samplerate_Hz 		   = p_dev->adc_sampling_freq_Hz;
 8020124:	69c3      	ldr	r3, [r0, #28]
 8020126:	6023      	str	r3, [r4, #0]
	ptr->resolution    		   = p_dev->adc_resolution;
 8020128:	f890 3020 	ldrb.w	r3, [r0, #32]
 802012c:	7123      	strb	r3, [r4, #4]
	ptr->use_post_calibration  = p_dev->adc_use_post_calibration;
 802012e:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 8020132:	7163      	strb	r3, [r4, #5]
 8020134:	bd10      	pop	{r4, pc}
 8020136:	bf00      	nop

08020138 <ds_ep_store_adc_config>:

uint16_t ds_ep_store_adc_config(const Adc_Configuration_t *p_config)
{
  uint16_t status = RADAR_ERR_BUSY;

  if(p_config != NULL)
 8020138:	b168      	cbz	r0, 8020156 <ds_ep_store_adc_config+0x1e>
}

//============================================================================

uint16_t ds_ep_store_adc_config(const Adc_Configuration_t *p_config)
{
 802013a:	b510      	push	{r4, lr}
 802013c:	4604      	mov	r4, r0
  uint16_t status = RADAR_ERR_BUSY;

  if(p_config != NULL)
  {
	  device_settings_t *p_dev		   = ds_device_get_settings();
 802013e:	f7ff ff63 	bl	8020008 <ds_device_get_settings>
	  p_dev->adc_sampling_freq_Hz 	   = p_config->samplerate_Hz;
 8020142:	6823      	ldr	r3, [r4, #0]
 8020144:	61c3      	str	r3, [r0, #28]
	  p_dev->adc_resolution    		   = p_config->resolution;
 8020146:	7923      	ldrb	r3, [r4, #4]
 8020148:	f880 3020 	strb.w	r3, [r0, #32]
	  p_dev->adc_use_post_calibration  = p_config->use_post_calibration;
 802014c:	7963      	ldrb	r3, [r4, #5]
 802014e:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21

	  status = RADAR_ERR_OK;
 8020152:	2000      	movs	r0, #0
 8020154:	bd10      	pop	{r4, pc}

//============================================================================

uint16_t ds_ep_store_adc_config(const Adc_Configuration_t *p_config)
{
  uint16_t status = RADAR_ERR_BUSY;
 8020156:	2002      	movs	r0, #2
 8020158:	4770      	bx	lr
 802015a:	bf00      	nop

0802015c <ds_ep_fetch_fmcw_config>:
}

//============================================================================

void ds_ep_fetch_fmcw_config(Fmcw_Configuration_t *config)
{
 802015c:	b510      	push	{r4, lr}
 802015e:	4604      	mov	r4, r0
  device_settings_t *p_dev	   		= ds_device_get_settings();
 8020160:	f7ff ff52 	bl	8020008 <ds_device_get_settings>
  config->lower_frequency_kHz  		= p_dev->pll_lower_frequency_kHz;
 8020164:	ed90 7a02 	vldr	s14, [r0, #8]
  config->upper_frequency_kHz  		= p_dev->pll_upper_frequency_kHz;
 8020168:	edd0 7a03 	vldr	s15, [r0, #12]
  config->direction 		   		= RADAR_DIR_UPCHIRP_ONLY;
  config->tx_power 			   		= p_dev->bgt_tx_power_level;
  config->up_chirp_duration_nsec 	= p_dev->pll_chirp_time_usec * 1000U;
  config->down_chirp_duration_nsec  = (PLL_RAMP_DOWM_TIME_USEC) * 1000U;
 802016c:	4a0b      	ldr	r2, [pc, #44]	; (802019c <ds_ep_fetch_fmcw_config+0x40>)
//============================================================================

void ds_ep_fetch_fmcw_config(Fmcw_Configuration_t *config)
{
  device_settings_t *p_dev	   		= ds_device_get_settings();
  config->lower_frequency_kHz  		= p_dev->pll_lower_frequency_kHz;
 802016e:	eebc 7ac7 	vcvt.u32.f32	s14, s14
  config->upper_frequency_kHz  		= p_dev->pll_upper_frequency_kHz;
 8020172:	eefc 7ae7 	vcvt.u32.f32	s15, s15
  config->direction 		   		= RADAR_DIR_UPCHIRP_ONLY;
 8020176:	2300      	movs	r3, #0
//============================================================================

void ds_ep_fetch_fmcw_config(Fmcw_Configuration_t *config)
{
  device_settings_t *p_dev	   		= ds_device_get_settings();
  config->lower_frequency_kHz  		= p_dev->pll_lower_frequency_kHz;
 8020178:	ed84 7a00 	vstr	s14, [r4]
  config->upper_frequency_kHz  		= p_dev->pll_upper_frequency_kHz;
 802017c:	edc4 7a01 	vstr	s15, [r4, #4]
  config->direction 		   		= RADAR_DIR_UPCHIRP_ONLY;
 8020180:	7223      	strb	r3, [r4, #8]
  config->tx_power 			   		= p_dev->bgt_tx_power_level;
 8020182:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
 8020186:	7263      	strb	r3, [r4, #9]
  config->up_chirp_duration_nsec 	= p_dev->pll_chirp_time_usec * 1000U;
 8020188:	6801      	ldr	r1, [r0, #0]
  config->down_chirp_duration_nsec  = (PLL_RAMP_DOWM_TIME_USEC) * 1000U;
 802018a:	6122      	str	r2, [r4, #16]
  device_settings_t *p_dev	   		= ds_device_get_settings();
  config->lower_frequency_kHz  		= p_dev->pll_lower_frequency_kHz;
  config->upper_frequency_kHz  		= p_dev->pll_upper_frequency_kHz;
  config->direction 		   		= RADAR_DIR_UPCHIRP_ONLY;
  config->tx_power 			   		= p_dev->bgt_tx_power_level;
  config->up_chirp_duration_nsec 	= p_dev->pll_chirp_time_usec * 1000U;
 802018c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8020190:	fb03 f301 	mul.w	r3, r3, r1
 8020194:	60e3      	str	r3, [r4, #12]
  config->down_chirp_duration_nsec  = (PLL_RAMP_DOWM_TIME_USEC) * 1000U;
  config->chirp_to_chirp_delay_nsec = (PLL_STEADY_STATE_USEC)* 1000U;
 8020196:	6162      	str	r2, [r4, #20]
 8020198:	bd10      	pop	{r4, pc}
 802019a:	bf00      	nop
 802019c:	000186a0 	.word	0x000186a0

080201a0 <ds_ep_store_fmcw_config>:

uint16_t ds_ep_store_fmcw_config(const Fmcw_Configuration_t *config)
{
  uint16_t status = RADAR_ERR_BUSY;

  if(config != NULL)
 80201a0:	b120      	cbz	r0, 80201ac <ds_ep_store_fmcw_config+0xc>
}

//============================================================================

uint16_t ds_ep_store_fmcw_config(const Fmcw_Configuration_t *config)
{
 80201a2:	b538      	push	{r3, r4, r5, lr}
  uint16_t status = RADAR_ERR_BUSY;

  if(config != NULL)
  {
	  if(config->direction != RADAR_DIR_UPCHIRP_ONLY)
 80201a4:	7a04      	ldrb	r4, [r0, #8]
 80201a6:	b11c      	cbz	r4, 80201b0 <ds_ep_store_fmcw_config+0x10>
	  {
		  status = RADAR_ERR_UNSUPPORTED_DIRECTION;
 80201a8:	2020      	movs	r0, #32

		  status = RADAR_ERR_OK;
	  }
  }
  return (status);
}
 80201aa:	bd38      	pop	{r3, r4, r5, pc}

//============================================================================

uint16_t ds_ep_store_fmcw_config(const Fmcw_Configuration_t *config)
{
  uint16_t status = RADAR_ERR_BUSY;
 80201ac:	2002      	movs	r0, #2

		  status = RADAR_ERR_OK;
	  }
  }
  return (status);
}
 80201ae:	4770      	bx	lr
 80201b0:	4605      	mov	r5, r0
	  {
		  status = RADAR_ERR_UNSUPPORTED_DIRECTION;
	  }
	  else
	  {
		  device_settings_t *p_dev		  = ds_device_get_settings();
 80201b2:	f7ff ff29 	bl	8020008 <ds_device_get_settings>
		  p_dev->pll_lower_frequency_kHz  = config->lower_frequency_kHz;
 80201b6:	edd5 7a00 	vldr	s15, [r5]
 80201ba:	eeb8 7a67 	vcvt.f32.u32	s14, s15
		  p_dev->pll_upper_frequency_kHz  = config->upper_frequency_kHz;
 80201be:	edd5 7a01 	vldr	s15, [r5, #4]
		  status = RADAR_ERR_UNSUPPORTED_DIRECTION;
	  }
	  else
	  {
		  device_settings_t *p_dev		  = ds_device_get_settings();
		  p_dev->pll_lower_frequency_kHz  = config->lower_frequency_kHz;
 80201c2:	ed80 7a02 	vstr	s14, [r0, #8]
		  p_dev->pll_upper_frequency_kHz  = config->upper_frequency_kHz;
 80201c6:	eef8 7a67 	vcvt.f32.u32	s15, s15
	  {
		  status = RADAR_ERR_UNSUPPORTED_DIRECTION;
	  }
	  else
	  {
		  device_settings_t *p_dev		  = ds_device_get_settings();
 80201ca:	4603      	mov	r3, r0
		  p_dev->pll_lower_frequency_kHz  = config->lower_frequency_kHz;
		  p_dev->pll_upper_frequency_kHz  = config->upper_frequency_kHz;
 80201cc:	edc0 7a03 	vstr	s15, [r0, #12]
		  p_dev->bgt_tx_power_level 	  = config->tx_power;
 80201d0:	7a6a      	ldrb	r2, [r5, #9]
 80201d2:	f880 2025 	strb.w	r2, [r0, #37]	; 0x25
		  p_dev->isUpdated_fmcw_config 	  = 1;
 80201d6:	2201      	movs	r2, #1

		  status = RADAR_ERR_OK;
 80201d8:	4620      	mov	r0, r4
	  {
		  device_settings_t *p_dev		  = ds_device_get_settings();
		  p_dev->pll_lower_frequency_kHz  = config->lower_frequency_kHz;
		  p_dev->pll_upper_frequency_kHz  = config->upper_frequency_kHz;
		  p_dev->bgt_tx_power_level 	  = config->tx_power;
		  p_dev->isUpdated_fmcw_config 	  = 1;
 80201da:	63da      	str	r2, [r3, #60]	; 0x3c
 80201dc:	bd38      	pop	{r3, r4, r5, pc}
 80201de:	bf00      	nop

080201e0 <ds_ep_get_device_info>:
//============================================================================

const Device_Info_t *ds_ep_get_device_info(void)
{
  return (&cg_device_info_struct);
}
 80201e0:	4800      	ldr	r0, [pc, #0]	; (80201e4 <ds_ep_get_device_info+0x4>)
 80201e2:	4770      	bx	lr
 80201e4:	0802abb4 	.word	0x0802abb4

080201e8 <ds_ep_fetch_frame_format>:

//============================================================================

void ds_ep_fetch_frame_format(Frame_Format_t *p_frame_format)
{
 80201e8:	b510      	push	{r4, lr}
 80201ea:	4604      	mov	r4, r0
	device_settings_t *p_dev			  = ds_device_get_settings();
 80201ec:	f7ff ff0c 	bl	8020008 <ds_device_get_settings>
	p_frame_format->num_samples_per_chirp = p_dev->num_samples_per_chirp;
	p_frame_format->num_chirps_per_frame  = p_dev->pll_num_of_chirps_per_frame;
 80201f0:	6942      	ldr	r2, [r0, #20]
//============================================================================

void ds_ep_fetch_frame_format(Frame_Format_t *p_frame_format)
{
	device_settings_t *p_dev			  = ds_device_get_settings();
	p_frame_format->num_samples_per_chirp = p_dev->num_samples_per_chirp;
 80201f2:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
	p_frame_format->num_chirps_per_frame  = p_dev->pll_num_of_chirps_per_frame;
 80201f4:	e884 0006 	stmia.w	r4, {r1, r2}
	p_frame_format->rx_mask 		      = p_dev->rx_antenna_mask;
 80201f8:	f890 2030 	ldrb.w	r2, [r0, #48]	; 0x30
 80201fc:	7222      	strb	r2, [r4, #8]
	p_frame_format->signal_part 	      = RADAR_SIGNAL_I_AND_Q;
 80201fe:	2302      	movs	r3, #2
 8020200:	7263      	strb	r3, [r4, #9]
 8020202:	bd10      	pop	{r4, pc}

08020204 <ds_ep_store_frame_format>:

uint16_t ds_ep_store_frame_format(const Frame_Format_t *p_new_frame_format)
{
  uint16_t status = RADAR_ERR_BUSY;

  if(p_new_frame_format != NULL)
 8020204:	b120      	cbz	r0, 8020210 <ds_ep_store_frame_format+0xc>
  {
	  if(p_new_frame_format->signal_part != RADAR_SIGNAL_I_AND_Q)
 8020206:	7a43      	ldrb	r3, [r0, #9]
 8020208:	2b02      	cmp	r3, #2
 802020a:	d003      	beq.n	8020214 <ds_ep_store_frame_format+0x10>
	  {
		  status = RADAR_ERR_UNAVAILABLE_SIGNAL_PART;
 802020c:	200b      	movs	r0, #11
 802020e:	4770      	bx	lr

//============================================================================

uint16_t ds_ep_store_frame_format(const Frame_Format_t *p_new_frame_format)
{
  uint16_t status = RADAR_ERR_BUSY;
 8020210:	2002      	movs	r0, #2
 8020212:	4770      	bx	lr
}

//============================================================================

uint16_t ds_ep_store_frame_format(const Frame_Format_t *p_new_frame_format)
{
 8020214:	b510      	push	{r4, lr}
 8020216:	4604      	mov	r4, r0
	  {
		  status = RADAR_ERR_UNAVAILABLE_SIGNAL_PART;
	  }
	  else
	  {
		  device_settings_t *p_dev				= ds_device_get_settings();
 8020218:	f7ff fef6 	bl	8020008 <ds_device_get_settings>
		  p_dev->num_samples_per_chirp 	        = p_new_frame_format->num_samples_per_chirp;
		  p_dev->pll_num_of_chirps_per_frame 	= p_new_frame_format->num_chirps_per_frame;
 802021c:	e894 000c 	ldmia.w	r4, {r2, r3}
		  status = RADAR_ERR_UNAVAILABLE_SIGNAL_PART;
	  }
	  else
	  {
		  device_settings_t *p_dev				= ds_device_get_settings();
		  p_dev->num_samples_per_chirp 	        = p_new_frame_format->num_samples_per_chirp;
 8020220:	62c2      	str	r2, [r0, #44]	; 0x2c
		  p_dev->pll_num_of_chirps_per_frame 	= p_new_frame_format->num_chirps_per_frame;
 8020222:	6143      	str	r3, [r0, #20]
		  p_dev->rx_antenna_mask	            = p_new_frame_format->rx_mask;
 8020224:	7a23      	ldrb	r3, [r4, #8]
 8020226:	f880 3030 	strb.w	r3, [r0, #48]	; 0x30

		  status = RADAR_ERR_OK;
 802022a:	2000      	movs	r0, #0
 802022c:	bd10      	pop	{r4, pc}
 802022e:	bf00      	nop

08020230 <ds_ep_fetch_fft_config>:

  *threshold = temp;
}

void ds_ep_fetch_fft_config(FFT_configuration_t *p_fft_config)
{
 8020230:	b410      	push	{r4}
	p_fft_config->fft_window_size 	= RANGE_FFT_SIZE;
	p_fft_config->mean_removed 		= 0;
 8020232:	2100      	movs	r1, #0
  *threshold = temp;
}

void ds_ep_fetch_fft_config(FFT_configuration_t *p_fft_config)
{
	p_fft_config->fft_window_size 	= RANGE_FFT_SIZE;
 8020234:	f44f 7480 	mov.w	r4, #256	; 0x100
	p_fft_config->mean_removed 		= 0;
	p_fft_config->window_type 		= WINDOW_BLACKMANHARRIS;
 8020238:	2202      	movs	r2, #2
	p_fft_config->scaling_factor	= 1.0F;
 802023a:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
  *threshold = temp;
}

void ds_ep_fetch_fft_config(FFT_configuration_t *p_fft_config)
{
	p_fft_config->fft_window_size 	= RANGE_FFT_SIZE;
 802023e:	6004      	str	r4, [r0, #0]
	p_fft_config->mean_removed 		= 0;
 8020240:	7141      	strb	r1, [r0, #5]
	p_fft_config->window_type 		= WINDOW_BLACKMANHARRIS;
 8020242:	7102      	strb	r2, [r0, #4]
	p_fft_config->scaling_factor	= 1.0F;
 8020244:	6083      	str	r3, [r0, #8]
}
 8020246:	f85d 4b04 	ldr.w	r4, [sp], #4
 802024a:	4770      	bx	lr

0802024c <SystemCoreClockUpdate>:
  uint32_t pdiv;
  uint32_t ndiv;
  uint32_t kdiv;
  uint32_t temp;

  if (SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSSEL_Msk)
 802024c:	4b1c      	ldr	r3, [pc, #112]	; (80202c0 <SystemCoreClockUpdate+0x74>)
 802024e:	68db      	ldr	r3, [r3, #12]
 8020250:	03d9      	lsls	r1, r3, #15

  SystemCoreClockUpdate();
}

__WEAK void SystemCoreClockUpdate(void)
{
 8020252:	b510      	push	{r4, lr}
  uint32_t pdiv;
  uint32_t ndiv;
  uint32_t kdiv;
  uint32_t temp;

  if (SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSSEL_Msk)
 8020254:	d51d      	bpl.n	8020292 <SystemCoreClockUpdate+0x46>
  {
    /* fPLL is clock source for fSYS */
    if(SCU_PLL->PLLCON2 & SCU_PLL_PLLCON2_PINSEL_Msk)
 8020256:	4b1b      	ldr	r3, [pc, #108]	; (80202c4 <SystemCoreClockUpdate+0x78>)
 8020258:	68db      	ldr	r3, [r3, #12]
 802025a:	07da      	lsls	r2, r3, #31
 802025c:	d52c      	bpl.n	80202b8 <SystemCoreClockUpdate+0x6c>
    {
      /* PLL input clock is the backup clock (fOFI) */
      temp = OFI_FREQUENCY;
 802025e:	481a      	ldr	r0, [pc, #104]	; (80202c8 <SystemCoreClockUpdate+0x7c>)
      /* PLL input clock is the high performance osicllator (fOSCHP) */
      temp = OSCHP_GetFrequency();
    }

    /* check if PLL is locked */
    if (SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk)
 8020260:	4a18      	ldr	r2, [pc, #96]	; (80202c4 <SystemCoreClockUpdate+0x78>)
 8020262:	6813      	ldr	r3, [r2, #0]
 8020264:	075b      	lsls	r3, r3, #29
 8020266:	d416      	bmi.n	8020296 <SystemCoreClockUpdate+0x4a>
    }
    else
    {
      /* PLL prescalar mode */
      /* read back divider settings */
      kdiv  = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_K1DIV_Msk) >> SCU_PLL_PLLCON1_K1DIV_Pos) + 1;
 8020268:	6893      	ldr	r3, [r2, #8]
 802026a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 802026e:	3301      	adds	r3, #1
      
      temp = (temp / kdiv);
 8020270:	fbb0 f3f3 	udiv	r3, r0, r3
  {
    /* fOFI is clock source for fSYS */    
    temp = OFI_FREQUENCY;
  }

  temp = temp / ((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk) + 1);
 8020274:	4a12      	ldr	r2, [pc, #72]	; (80202c0 <SystemCoreClockUpdate+0x74>)
  temp = temp / ((SCU_CLK->CPUCLKCR & SCU_CLK_CPUCLKCR_CPUDIV_Msk) + 1);

  SystemCoreClock = temp;
 8020276:	4915      	ldr	r1, [pc, #84]	; (80202cc <SystemCoreClockUpdate+0x80>)
  {
    /* fOFI is clock source for fSYS */    
    temp = OFI_FREQUENCY;
  }

  temp = temp / ((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk) + 1);
 8020278:	68d0      	ldr	r0, [r2, #12]
  temp = temp / ((SCU_CLK->CPUCLKCR & SCU_CLK_CPUCLKCR_CPUDIV_Msk) + 1);
 802027a:	6912      	ldr	r2, [r2, #16]
  {
    /* fOFI is clock source for fSYS */    
    temp = OFI_FREQUENCY;
  }

  temp = temp / ((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk) + 1);
 802027c:	b2c0      	uxtb	r0, r0
  temp = temp / ((SCU_CLK->CPUCLKCR & SCU_CLK_CPUCLKCR_CPUDIV_Msk) + 1);
 802027e:	f002 0201 	and.w	r2, r2, #1
  {
    /* fOFI is clock source for fSYS */    
    temp = OFI_FREQUENCY;
  }

  temp = temp / ((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk) + 1);
 8020282:	3001      	adds	r0, #1
  temp = temp / ((SCU_CLK->CPUCLKCR & SCU_CLK_CPUCLKCR_CPUDIV_Msk) + 1);
 8020284:	3201      	adds	r2, #1
  {
    /* fOFI is clock source for fSYS */    
    temp = OFI_FREQUENCY;
  }

  temp = temp / ((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk) + 1);
 8020286:	fbb3 f0f0 	udiv	r0, r3, r0
  temp = temp / ((SCU_CLK->CPUCLKCR & SCU_CLK_CPUCLKCR_CPUDIV_Msk) + 1);
 802028a:	fbb0 f0f2 	udiv	r0, r0, r2

  SystemCoreClock = temp;
 802028e:	6008      	str	r0, [r1, #0]
 8020290:	bd10      	pop	{r4, pc}
    }
  }
  else
  {
    /* fOFI is clock source for fSYS */    
    temp = OFI_FREQUENCY;
 8020292:	4b0d      	ldr	r3, [pc, #52]	; (80202c8 <SystemCoreClockUpdate+0x7c>)
 8020294:	e7ee      	b.n	8020274 <SystemCoreClockUpdate+0x28>
    /* check if PLL is locked */
    if (SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk)
    {
      /* PLL normal mode */
      /* read back divider settings */
      pdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_PDIV_Msk) >> SCU_PLL_PLLCON1_PDIV_Pos) + 1;
 8020296:	6891      	ldr	r1, [r2, #8]
      ndiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_NDIV_Msk) >> SCU_PLL_PLLCON1_NDIV_Pos) + 1;
 8020298:	6893      	ldr	r3, [r2, #8]
      kdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_K2DIV_Msk) >> SCU_PLL_PLLCON1_K2DIV_Pos) + 1;
 802029a:	6894      	ldr	r4, [r2, #8]
    /* check if PLL is locked */
    if (SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk)
    {
      /* PLL normal mode */
      /* read back divider settings */
      pdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_PDIV_Msk) >> SCU_PLL_PLLCON1_PDIV_Pos) + 1;
 802029c:	f3c1 6203 	ubfx	r2, r1, #24, #4
 80202a0:	3201      	adds	r2, #1
      ndiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_NDIV_Msk) >> SCU_PLL_PLLCON1_NDIV_Pos) + 1;
      kdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_K2DIV_Msk) >> SCU_PLL_PLLCON1_K2DIV_Pos) + 1;
 80202a2:	f3c4 4106 	ubfx	r1, r4, #16, #7
    if (SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk)
    {
      /* PLL normal mode */
      /* read back divider settings */
      pdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_PDIV_Msk) >> SCU_PLL_PLLCON1_PDIV_Pos) + 1;
      ndiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_NDIV_Msk) >> SCU_PLL_PLLCON1_NDIV_Pos) + 1;
 80202a6:	f3c3 2306 	ubfx	r3, r3, #8, #7
      kdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_K2DIV_Msk) >> SCU_PLL_PLLCON1_K2DIV_Pos) + 1;

      temp = (temp / (pdiv * kdiv)) * ndiv;
 80202aa:	fb01 2202 	mla	r2, r1, r2, r2
 80202ae:	fbb0 f0f2 	udiv	r0, r0, r2
 80202b2:	fb03 0300 	mla	r3, r3, r0, r0
 80202b6:	e7dd      	b.n	8020274 <SystemCoreClockUpdate+0x28>
      temp = OFI_FREQUENCY;
    }
    else
    {
      /* PLL input clock is the high performance osicllator (fOSCHP) */
      temp = OSCHP_GetFrequency();
 80202b8:	f006 ff2a 	bl	8027110 <OSCHP_GetFrequency>
 80202bc:	e7d0      	b.n	8020260 <SystemCoreClockUpdate+0x14>
 80202be:	bf00      	nop
 80202c0:	50004600 	.word	0x50004600
 80202c4:	50004710 	.word	0x50004710
 80202c8:	016e3600 	.word	0x016e3600
 80202cc:	2003ffc0 	.word	0x2003ffc0

080202d0 <SystemInit>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

__WEAK void SystemInit(void)
{
 80202d0:	b510      	push	{r4, lr}
  memcpy(g_chipid, CHIPID_LOC, 16);
 80202d2:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 80202d6:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 80202d8:	4c03      	ldr	r4, [pc, #12]	; (80202e8 <SystemInit+0x18>)
 80202da:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
  
  SystemCoreSetup();
 80202de:	f006 fed9 	bl	8027094 <SystemCoreSetup>
  SystemCoreClockSetup(); 
 80202e2:	f006 ff19 	bl	8027118 <SystemCoreClockSetup>
 80202e6:	bd10      	pop	{r4, pc}
 80202e8:	2003ffc4 	.word	0x2003ffc4

080202ec <get_buffer_address_by_chirp>:

uint8_t *get_buffer_address_by_chirp(acq_buf_obj *p_obj, uint32_t channel_index, uint32_t chirpCnt)
{
  size_t offset = 0;
  
  if(p_obj->p_acq_buf == NULL)
 80202ec:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80202ee:	b15b      	cbz	r3, 8020308 <get_buffer_address_by_chirp+0x1c>
   2. EXPORTED FUNCTIONS
==============================================================================
 */

uint8_t *get_buffer_address_by_chirp(acq_buf_obj *p_obj, uint32_t channel_index, uint32_t chirpCnt)
{
 80202f0:	b410      	push	{r4}
  
  if(p_obj->p_acq_buf == NULL)
    return NULL;
  
  // Since the chirps are interleaved, we calculate the buffer base address for a new chirp and the related channel here:
  offset = (p_obj->internals.chirp_inc * chirpCnt) + (p_obj->internals.channel_inc * channel_index);
 80202f2:	6944      	ldr	r4, [r0, #20]
 80202f4:	6900      	ldr	r0, [r0, #16]
 80202f6:	fb04 f101 	mul.w	r1, r4, r1
 80202fa:	fb00 1202 	mla	r2, r0, r2, r1
  
  return &p_obj->p_acq_buf[offset];
 80202fe:	4413      	add	r3, r2
}
 8020300:	4618      	mov	r0, r3
 8020302:	f85d 4b04 	ldr.w	r4, [sp], #4
 8020306:	4770      	bx	lr
 8020308:	4618      	mov	r0, r3
 802030a:	4770      	bx	lr

0802030c <create_acq_data_buffer_obj>:

//============================================================================

acq_buf_obj create_acq_data_buffer_obj(uint8_t *p_allocated_buffer, size_t allocated_buffer_size,
                                       uint16_t max_num_of_chirps_per_frame, uint16_t max_num_of_samples_per_chirp, uint16_t max_num_of_I_values, uint16_t max_num_of_Q_values, uint16_t adc_resolution) 
{
 802030c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8020310:	f8bd e024 	ldrh.w	lr, [sp, #36]	; 0x24
 8020314:	f8bd 701c 	ldrh.w	r7, [sp, #28]
 8020318:	f8bd 6020 	ldrh.w	r6, [sp, #32]
 802031c:	f8bd 5018 	ldrh.w	r5, [sp, #24]
  obj.status = allocation_ok;
  obj.access_lock = 0;
  obj.acq_timestime = 0;
  obj.internals.is_dynamic_allocated = 0;
  
  obj.params.num_of_chirps_per_frame = max_num_of_chirps_per_frame;
 8020320:	8083      	strh	r3, [r0, #4]
acq_buf_obj create_acq_data_buffer_obj(uint8_t *p_allocated_buffer, size_t allocated_buffer_size,
                                       uint16_t max_num_of_chirps_per_frame, uint16_t max_num_of_samples_per_chirp, uint16_t max_num_of_I_values, uint16_t max_num_of_Q_values, uint16_t adc_resolution) 
{
  acq_buf_obj obj;
  size_t required_size = 0;
  size_t value_size = ((adc_resolution - 1) / 8 ) + 1;
 8020322:	f1be 0401 	subs.w	r4, lr, #1
 8020326:	bf48      	it	mi
 8020328:	f10e 0406 	addmi.w	r4, lr, #6
 802032c:	10e4      	asrs	r4, r4, #3
 802032e:	3401      	adds	r4, #1
  obj.acq_timestime = 0;
  obj.internals.is_dynamic_allocated = 0;
  
  obj.params.num_of_chirps_per_frame = max_num_of_chirps_per_frame;
  obj.params.num_of_samples_per_chirp = max_num_of_samples_per_chirp;
  obj.params.num_of_rx_values = (max_num_of_I_values + max_num_of_Q_values);
 8020330:	eb07 0e06 	add.w	lr, r7, r6
  acq_buf_obj obj;
  size_t required_size = 0;
  size_t value_size = ((adc_resolution - 1) / 8 ) + 1;
  
  obj.status = allocation_ok;
  obj.access_lock = 0;
 8020334:	f04f 0c00 	mov.w	ip, #0
  obj.acq_timestime = 0;
  obj.internals.is_dynamic_allocated = 0;
  
  obj.params.num_of_chirps_per_frame = max_num_of_chirps_per_frame;
  obj.params.num_of_samples_per_chirp = max_num_of_samples_per_chirp;
  obj.params.num_of_rx_values = (max_num_of_I_values + max_num_of_Q_values);
 8020338:	fa1f fe8e 	uxth.w	lr, lr
{
  acq_buf_obj obj;
  size_t required_size = 0;
  size_t value_size = ((adc_resolution - 1) / 8 ) + 1;
  
  obj.status = allocation_ok;
 802033c:	f04f 0801 	mov.w	r8, #1
  obj.params.num_of_rx_values = (max_num_of_I_values + max_num_of_Q_values);
  obj.params.size_of_value_in_bytes = value_size;
  
  obj.data_type = data_type_unknown;
  // derive format type from parameters:
  if ((value_size == 2) && (max_num_of_I_values == max_num_of_Q_values) && max_num_of_I_values == 2)
 8020340:	2c02      	cmp	r4, #2
  obj.internals.is_dynamic_allocated = 0;
  
  obj.params.num_of_chirps_per_frame = max_num_of_chirps_per_frame;
  obj.params.num_of_samples_per_chirp = max_num_of_samples_per_chirp;
  obj.params.num_of_rx_values = (max_num_of_I_values + max_num_of_Q_values);
  obj.params.size_of_value_in_bytes = value_size;
 8020342:	8104      	strh	r4, [r0, #8]
  obj.access_lock = 0;
  obj.acq_timestime = 0;
  obj.internals.is_dynamic_allocated = 0;
  
  obj.params.num_of_chirps_per_frame = max_num_of_chirps_per_frame;
  obj.params.num_of_samples_per_chirp = max_num_of_samples_per_chirp;
 8020344:	8045      	strh	r5, [r0, #2]
  obj.params.num_of_rx_values = (max_num_of_I_values + max_num_of_Q_values);
 8020346:	f8a0 e006 	strh.w	lr, [r0, #6]
{
  acq_buf_obj obj;
  size_t required_size = 0;
  size_t value_size = ((adc_resolution - 1) / 8 ) + 1;
  
  obj.status = allocation_ok;
 802034a:	f880 802c 	strb.w	r8, [r0, #44]	; 0x2c
  obj.access_lock = 0;
 802034e:	f8c0 c024 	str.w	ip, [r0, #36]	; 0x24
  obj.acq_timestime = 0;
 8020352:	f8c0 c020 	str.w	ip, [r0, #32]
  obj.internals.is_dynamic_allocated = 0;
 8020356:	f8c0 c018 	str.w	ip, [r0, #24]
  obj.params.num_of_chirps_per_frame = max_num_of_chirps_per_frame;
  obj.params.num_of_samples_per_chirp = max_num_of_samples_per_chirp;
  obj.params.num_of_rx_values = (max_num_of_I_values + max_num_of_Q_values);
  obj.params.size_of_value_in_bytes = value_size;
  
  obj.data_type = data_type_unknown;
 802035a:	f880 c000 	strb.w	ip, [r0]
  // derive format type from parameters:
  if ((value_size == 2) && (max_num_of_I_values == max_num_of_Q_values) && max_num_of_I_values == 2)
 802035e:	d02b      	beq.n	80203b8 <create_acq_data_buffer_obj+0xac>
    obj.data_type = uint16_1x_IandQ;
  }
  
  // calculate the size of allocation buffer
  // consider that an internal acquisition buffer needs to be uint32_t bit aligned on ARM!
  required_size = obj.params.num_of_chirps_per_frame * obj.params.num_of_samples_per_chirp * obj.params.num_of_rx_values * obj.params.size_of_value_in_bytes;
 8020360:	fb05 f303 	mul.w	r3, r5, r3
 8020364:	fb0e f303 	mul.w	r3, lr, r3
 8020368:	fb03 f304 	mul.w	r3, r3, r4
  
  obj.p_acq_buf = p_allocated_buffer;
  obj.internals.size_of_acq_buffer = allocated_buffer_size;
  obj.used_size_of_acq_buffer = required_size;
  
  if ((max_num_of_I_values > MAX_SUPPORTED_RX_SIGNALS_INT) || (max_num_of_Q_values > MAX_SUPPORTED_RX_SIGNALS_INT))
 802036c:	2f02      	cmp	r7, #2
  // consider that an internal acquisition buffer needs to be uint32_t bit aligned on ARM!
  required_size = obj.params.num_of_chirps_per_frame * obj.params.num_of_samples_per_chirp * obj.params.num_of_rx_values * obj.params.size_of_value_in_bytes;
  
  obj.p_acq_buf = p_allocated_buffer;
  obj.internals.size_of_acq_buffer = allocated_buffer_size;
  obj.used_size_of_acq_buffer = required_size;
 802036e:	61c3      	str	r3, [r0, #28]
  
  // calculate the size of allocation buffer
  // consider that an internal acquisition buffer needs to be uint32_t bit aligned on ARM!
  required_size = obj.params.num_of_chirps_per_frame * obj.params.num_of_samples_per_chirp * obj.params.num_of_rx_values * obj.params.size_of_value_in_bytes;
  
  obj.p_acq_buf = p_allocated_buffer;
 8020370:	6281      	str	r1, [r0, #40]	; 0x28
  obj.internals.size_of_acq_buffer = allocated_buffer_size;
 8020372:	60c2      	str	r2, [r0, #12]
  obj.used_size_of_acq_buffer = required_size;
  
  if ((max_num_of_I_values > MAX_SUPPORTED_RX_SIGNALS_INT) || (max_num_of_Q_values > MAX_SUPPORTED_RX_SIGNALS_INT))
 8020374:	d817      	bhi.n	80203a6 <create_acq_data_buffer_obj+0x9a>
 8020376:	2e02      	cmp	r6, #2
 8020378:	d815      	bhi.n	80203a6 <create_acq_data_buffer_obj+0x9a>
    obj.internals.size_of_acq_buffer = 0;
    obj.used_size_of_acq_buffer = 0;
    return obj;
  }
  
  if (p_allocated_buffer != NULL && allocated_buffer_size == 0)
 802037a:	2900      	cmp	r1, #0
 802037c:	d036      	beq.n	80203ec <create_acq_data_buffer_obj+0xe0>
 802037e:	b35a      	cbz	r2, 80203d8 <create_acq_data_buffer_obj+0xcc>
    obj.internals.size_of_acq_buffer = 0;
    obj.used_size_of_acq_buffer = 0;
    return obj;
  }
  
  if (((obj.p_acq_buf != NULL) && (obj.internals.size_of_acq_buffer != 0)) && obj.internals.size_of_acq_buffer < required_size)
 8020380:	429a      	cmp	r2, r3
 8020382:	d331      	bcc.n	80203e8 <create_acq_data_buffer_obj+0xdc>
  obj.internals.channel_inc = obj.params.num_of_samples_per_chirp*obj.params.size_of_value_in_bytes;
  obj.internals.chirp_inc   = obj.internals.channel_inc * obj.params.num_of_rx_values;
  
  if(obj.p_acq_buf != NULL)
  {
    memset(obj.p_acq_buf, 0, sizeof(obj.used_size_of_acq_buffer));
 8020384:	460b      	mov	r3, r1
 8020386:	2200      	movs	r2, #0
 8020388:	f803 2b01 	strb.w	r2, [r3], #1
 802038c:	3301      	adds	r3, #1
 802038e:	704a      	strb	r2, [r1, #1]
 8020390:	f803 2b01 	strb.w	r2, [r3], #1
    }
  }
#endif
  
  // calculated internal buffer offsets
  obj.internals.channel_inc = obj.params.num_of_samples_per_chirp*obj.params.size_of_value_in_bytes;
 8020394:	fb05 f404 	mul.w	r4, r5, r4
  obj.internals.chirp_inc   = obj.internals.channel_inc * obj.params.num_of_rx_values;
 8020398:	fb0e f104 	mul.w	r1, lr, r4
  
  if(obj.p_acq_buf != NULL)
  {
    memset(obj.p_acq_buf, 0, sizeof(obj.used_size_of_acq_buffer));
 802039c:	701a      	strb	r2, [r3, #0]
  }
#endif
  
  // calculated internal buffer offsets
  obj.internals.channel_inc = obj.params.num_of_samples_per_chirp*obj.params.size_of_value_in_bytes;
  obj.internals.chirp_inc   = obj.internals.channel_inc * obj.params.num_of_rx_values;
 802039e:	6101      	str	r1, [r0, #16]
    }
  }
#endif
  
  // calculated internal buffer offsets
  obj.internals.channel_inc = obj.params.num_of_samples_per_chirp*obj.params.size_of_value_in_bytes;
 80203a0:	6144      	str	r4, [r0, #20]
 80203a2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  obj.internals.size_of_acq_buffer = allocated_buffer_size;
  obj.used_size_of_acq_buffer = required_size;
  
  if ((max_num_of_I_values > MAX_SUPPORTED_RX_SIGNALS_INT) || (max_num_of_Q_values > MAX_SUPPORTED_RX_SIGNALS_INT))
  {
    obj.status = num_of_RX_not_supported;
 80203a6:	2205      	movs	r2, #5
  }
  
  if (((obj.p_acq_buf != NULL) && (obj.internals.size_of_acq_buffer != 0)) && obj.internals.size_of_acq_buffer < required_size)
  {
    obj.status = allocation_buffer_too_small;
    obj.p_acq_buf = NULL;
 80203a8:	2300      	movs	r3, #0
    return obj;
  }
  
  if (((obj.p_acq_buf != NULL) && (obj.internals.size_of_acq_buffer != 0)) && obj.internals.size_of_acq_buffer < required_size)
  {
    obj.status = allocation_buffer_too_small;
 80203aa:	f880 202c 	strb.w	r2, [r0, #44]	; 0x2c
    obj.p_acq_buf = NULL;
 80203ae:	6283      	str	r3, [r0, #40]	; 0x28
    obj.internals.size_of_acq_buffer = 0;
 80203b0:	60c3      	str	r3, [r0, #12]
    obj.used_size_of_acq_buffer = 0;
 80203b2:	61c3      	str	r3, [r0, #28]
    return obj;
 80203b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  obj.params.num_of_rx_values = (max_num_of_I_values + max_num_of_Q_values);
  obj.params.size_of_value_in_bytes = value_size;
  
  obj.data_type = data_type_unknown;
  // derive format type from parameters:
  if ((value_size == 2) && (max_num_of_I_values == max_num_of_Q_values) && max_num_of_I_values == 2)
 80203b8:	42b7      	cmp	r7, r6
 80203ba:	d1d1      	bne.n	8020360 <create_acq_data_buffer_obj+0x54>
 80203bc:	2e02      	cmp	r6, #2
 80203be:	d01d      	beq.n	80203fc <create_acq_data_buffer_obj+0xf0>
  {
    obj.data_type = uint16_2x_IandQ;
  }
  else if ((value_size == 2) && (max_num_of_I_values == max_num_of_Q_values) && max_num_of_I_values == 1)
 80203c0:	2e01      	cmp	r6, #1
 80203c2:	d1cd      	bne.n	8020360 <create_acq_data_buffer_obj+0x54>
  {
    obj.data_type = uint16_1x_IandQ;
 80203c4:	7004      	strb	r4, [r0, #0]
  }
  
  // calculate the size of allocation buffer
  // consider that an internal acquisition buffer needs to be uint32_t bit aligned on ARM!
  required_size = obj.params.num_of_chirps_per_frame * obj.params.num_of_samples_per_chirp * obj.params.num_of_rx_values * obj.params.size_of_value_in_bytes;
 80203c6:	fb05 f303 	mul.w	r3, r5, r3
 80203ca:	fb0e f303 	mul.w	r3, lr, r3
 80203ce:	005b      	lsls	r3, r3, #1
  
  obj.p_acq_buf = p_allocated_buffer;
  obj.internals.size_of_acq_buffer = allocated_buffer_size;
  obj.used_size_of_acq_buffer = required_size;
 80203d0:	61c3      	str	r3, [r0, #28]
  
  // calculate the size of allocation buffer
  // consider that an internal acquisition buffer needs to be uint32_t bit aligned on ARM!
  required_size = obj.params.num_of_chirps_per_frame * obj.params.num_of_samples_per_chirp * obj.params.num_of_rx_values * obj.params.size_of_value_in_bytes;
  
  obj.p_acq_buf = p_allocated_buffer;
 80203d2:	6281      	str	r1, [r0, #40]	; 0x28
  obj.internals.size_of_acq_buffer = allocated_buffer_size;
 80203d4:	60c2      	str	r2, [r0, #12]
 80203d6:	e7ce      	b.n	8020376 <create_acq_data_buffer_obj+0x6a>
    return obj;
  }
  
  if (p_allocated_buffer != NULL && allocated_buffer_size == 0)
  {
    obj.status = allocation_size_is_zero;
 80203d8:	2304      	movs	r3, #4
    obj.p_acq_buf = NULL;
 80203da:	6282      	str	r2, [r0, #40]	; 0x28
    obj.internals.size_of_acq_buffer = 0;
 80203dc:	60c2      	str	r2, [r0, #12]
    obj.used_size_of_acq_buffer = 0;
 80203de:	61c2      	str	r2, [r0, #28]
    return obj;
  }
  
  if (p_allocated_buffer != NULL && allocated_buffer_size == 0)
  {
    obj.status = allocation_size_is_zero;
 80203e0:	f880 302c 	strb.w	r3, [r0, #44]	; 0x2c
    obj.p_acq_buf = NULL;
    obj.internals.size_of_acq_buffer = 0;
    obj.used_size_of_acq_buffer = 0;
    return obj;
 80203e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  
  if (((obj.p_acq_buf != NULL) && (obj.internals.size_of_acq_buffer != 0)) && obj.internals.size_of_acq_buffer < required_size)
  {
    obj.status = allocation_buffer_too_small;
 80203e8:	2203      	movs	r2, #3
 80203ea:	e7dd      	b.n	80203a8 <create_acq_data_buffer_obj+0x9c>
    }
  }
#endif
  
  // calculated internal buffer offsets
  obj.internals.channel_inc = obj.params.num_of_samples_per_chirp*obj.params.size_of_value_in_bytes;
 80203ec:	fb05 f404 	mul.w	r4, r5, r4
  obj.internals.chirp_inc   = obj.internals.channel_inc * obj.params.num_of_rx_values;
 80203f0:	fb0e f304 	mul.w	r3, lr, r4
 80203f4:	6103      	str	r3, [r0, #16]
    }
  }
#endif
  
  // calculated internal buffer offsets
  obj.internals.channel_inc = obj.params.num_of_samples_per_chirp*obj.params.size_of_value_in_bytes;
 80203f6:	6144      	str	r4, [r0, #20]
 80203f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  
  obj.data_type = data_type_unknown;
  // derive format type from parameters:
  if ((value_size == 2) && (max_num_of_I_values == max_num_of_Q_values) && max_num_of_I_values == 2)
  {
    obj.data_type = uint16_2x_IandQ;
 80203fc:	2704      	movs	r7, #4
 80203fe:	7007      	strb	r7, [r0, #0]
 8020400:	e7e1      	b.n	80203c6 <create_acq_data_buffer_obj+0xba>
 8020402:	bf00      	nop

08020404 <delete_acq_buffer_obj>:

//============================================================================

void delete_acq_buffer_obj(acq_buf_obj *p_obj) 
{ 
  p_obj->status = allocation_is_freed;
 8020404:	2206      	movs	r2, #6
  p_obj->used_size_of_acq_buffer = 0;
 8020406:	2300      	movs	r3, #0

//============================================================================

void delete_acq_buffer_obj(acq_buf_obj *p_obj) 
{ 
  p_obj->status = allocation_is_freed;
 8020408:	f880 202c 	strb.w	r2, [r0, #44]	; 0x2c
  p_obj->used_size_of_acq_buffer = 0;
 802040c:	61c3      	str	r3, [r0, #28]
 802040e:	4770      	bx	lr

08020410 <radar_set_adc_configuration>:
   2. EXPORTED FUNCTIONS
==============================================================================
 */

uint16_t radar_set_adc_configuration(Radar_Handle_t device, const Adc_Configuration_t* configuration)
{
 8020410:	b570      	push	{r4, r5, r6, lr}
 8020412:	4606      	mov	r6, r0
 8020414:	460d      	mov	r5, r1
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  uint32_t chirp_time_usec;
  
  /* Configuration change is only allowed while automatic trigger is not working */
  if (radar_get_data_acq_mode() != RADAR_MANUAL_TRIGGER)
 8020416:	f000 fe71 	bl	80210fc <radar_get_data_acq_mode>
 802041a:	4604      	mov	r4, r0
 802041c:	b108      	cbz	r0, 8020422 <radar_set_adc_configuration+0x12>
  {
    return (RADAR_ERR_BUSY);
 802041e:	2002      	movs	r0, #2
 8020420:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  /* Check if configuration is valid */
  /* ------------------------------- */
  if ((configuration->samplerate_Hz == 0) || (configuration->samplerate_Hz > BSP_MAX_ADC_FREQ_HZ))
 8020422:	682b      	ldr	r3, [r5, #0]
 8020424:	4a1f      	ldr	r2, [pc, #124]	; (80204a4 <radar_set_adc_configuration+0x94>)
 8020426:	3b01      	subs	r3, #1
 8020428:	4293      	cmp	r3, r2
 802042a:	d901      	bls.n	8020430 <radar_set_adc_configuration+0x20>
  {
    return (RADAR_ERR_SAMPLERATE_OUT_OF_RANGE);
 802042c:	2050      	movs	r0, #80	; 0x50
 802042e:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if (configuration->resolution != BSP_ADC_RESOLUTION)
 8020430:	792b      	ldrb	r3, [r5, #4]
 8020432:	2b0c      	cmp	r3, #12
 8020434:	d001      	beq.n	802043a <radar_set_adc_configuration+0x2a>
  {
    return (RADAR_ERR_UNSUPPORTED_RESOLUTION);
 8020436:	2051      	movs	r0, #81	; 0x51
  /* ---------------------------------------------------------- */
  /* Copy the new adc configuration to the data store*/
  ds_ep_store_adc_config(configuration);
  
  return (RADAR_ERR_OK);
}
 8020438:	bd70      	pop	{r4, r5, r6, pc}
  
  /* Apply ADC configuration */
  /* ----------------------- */
  //sample_rate_divider = ((REFERENCE_OSC_FREQ_HZ << 1) / configuration->samplerate_Hz + 1) >> 1;
  
  if (ds_device_get_settings()->pll_modulation_mode == MODULATION_FMCW)
 802043a:	f7ff fde5 	bl	8020008 <ds_device_get_settings>
 802043e:	6983      	ldr	r3, [r0, #24]
 8020440:	2b01      	cmp	r3, #1
 8020442:	d013      	beq.n	802046c <radar_set_adc_configuration+0x5c>
  }
  else
  {
    /* Apply ADC configuration */
    /* ----------------------- */
    if (radar_set_sampling_freq(device, MODULATION_DOPPLER, ds_device_get_settings()->adc_sampling_freq_Hz) != RADAR_ERR_OK)
 8020444:	f7ff fde0 	bl	8020008 <ds_device_get_settings>
 8020448:	69c2      	ldr	r2, [r0, #28]
 802044a:	ee07 2a90 	vmov	s15, r2
 802044e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8020452:	4621      	mov	r1, r4
 8020454:	ee17 2a90 	vmov	r2, s15
 8020458:	4630      	mov	r0, r6
 802045a:	f000 fdcd 	bl	8020ff8 <radar_set_sampling_freq>
 802045e:	2800      	cmp	r0, #0
 8020460:	d1e4      	bne.n	802042c <radar_set_adc_configuration+0x1c>
  }
  
  /* Remember configuration (adjust frequency to rounded value) */
  /* ---------------------------------------------------------- */
  /* Copy the new adc configuration to the data store*/
  ds_ep_store_adc_config(configuration);
 8020462:	4628      	mov	r0, r5
 8020464:	f7ff fe68 	bl	8020138 <ds_ep_store_adc_config>
  
  return (RADAR_ERR_OK);
 8020468:	2000      	movs	r0, #0
 802046a:	bd70      	pop	{r4, r5, r6, pc}
  /* ----------------------- */
  //sample_rate_divider = ((REFERENCE_OSC_FREQ_HZ << 1) / configuration->samplerate_Hz + 1) >> 1;
  
  if (ds_device_get_settings()->pll_modulation_mode == MODULATION_FMCW)
  {
    chirp_time_usec = (uint32_t) (((float)ds_device_get_settings()->num_samples_per_chirp * 1000.0f ) / configuration->samplerate_Hz * 1000.0f);
 802046c:	f7ff fdcc 	bl	8020008 <ds_device_get_settings>
 8020470:	ed90 7a0b 	vldr	s14, [r0, #44]	; 0x2c
 8020474:	eddf 6a0c 	vldr	s13, [pc, #48]	; 80204a8 <radar_set_adc_configuration+0x98>
 8020478:	edd5 7a00 	vldr	s15, [r5]
 802047c:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 8020480:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8020484:	ee27 7a26 	vmul.f32	s14, s14, s13
    
    if (radar_set_chirp_time(device, chirp_time_usec) != RADAR_ERR_OK)
 8020488:	4630      	mov	r0, r6
  /* ----------------------- */
  //sample_rate_divider = ((REFERENCE_OSC_FREQ_HZ << 1) / configuration->samplerate_Hz + 1) >> 1;
  
  if (ds_device_get_settings()->pll_modulation_mode == MODULATION_FMCW)
  {
    chirp_time_usec = (uint32_t) (((float)ds_device_get_settings()->num_samples_per_chirp * 1000.0f ) / configuration->samplerate_Hz * 1000.0f);
 802048a:	eec7 7a27 	vdiv.f32	s15, s14, s15
 802048e:	ee67 7aa6 	vmul.f32	s15, s15, s13
    
    if (radar_set_chirp_time(device, chirp_time_usec) != RADAR_ERR_OK)
 8020492:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8020496:	ee17 1a90 	vmov	r1, s15
 802049a:	f000 fd53 	bl	8020f44 <radar_set_chirp_time>
 802049e:	2800      	cmp	r0, #0
 80204a0:	d1c4      	bne.n	802042c <radar_set_adc_configuration+0x1c>
 80204a2:	e7de      	b.n	8020462 <radar_set_adc_configuration+0x52>
 80204a4:	0016e35f 	.word	0x0016e35f
 80204a8:	447a0000 	.word	0x447a0000

080204ac <radar_get_adc_configuration>:

uint16_t radar_get_adc_configuration(Radar_Handle_t device, Adc_Configuration_t* configuration)
{
  XMC_UNUSED_ARG(device);  /* Suppress compiler warnings of unused variable */
  
  if(configuration != NULL)
 80204ac:	b129      	cbz	r1, 80204ba <radar_get_adc_configuration+0xe>
}

//============================================================================

uint16_t radar_get_adc_configuration(Radar_Handle_t device, Adc_Configuration_t* configuration)
{
 80204ae:	b508      	push	{r3, lr}
 80204b0:	4608      	mov	r0, r1
  XMC_UNUSED_ARG(device);  /* Suppress compiler warnings of unused variable */
  
  if(configuration != NULL)
  {
    ds_ep_fetch_adc_config(configuration);
 80204b2:	f7ff fe33 	bl	802011c <ds_ep_fetch_adc_config>
    return (RADAR_ERR_OK);
 80204b6:	2000      	movs	r0, #0
 80204b8:	bd08      	pop	{r3, pc}
  }
  return (RADAR_ERR_FEATURE_UNAVAILABLE);
 80204ba:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 80204be:	4770      	bx	lr

080204c0 <radar_get_driver_version>:
 */

const Driver_Version_t* radar_get_driver_version(void)
{
  return (&driver_version_s);
}
 80204c0:	4800      	ldr	r0, [pc, #0]	; (80204c4 <radar_get_driver_version+0x4>)
 80204c2:	4770      	bx	lr
 80204c4:	0802abc8 	.word	0x0802abc8

080204c8 <radar_open_device>:
}

//============================================================================

uint16_t radar_open_device(int32_t device_number, Radar_Handle_t* device)
{
 80204c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80204cc:	b09a      	sub	sp, #104	; 0x68
  
  Frame_Format_t frame_format;
  uint16_t retValue = RADAR_ERR_OK;
  int32_t status = 0;
  uint16_t num_of_bytes;
  void* calibration_data_ptr = NULL;
 80204ce:	2400      	movs	r4, #0
 80204d0:	ae1a      	add	r6, sp, #104	; 0x68
  acq_buf_obj acq_buf = { .status = not_initialized } ;
    
  /* Initialize the driver instance with NULL, until it was successfully initialized */
  *device = NULL;
 80204d2:	600c      	str	r4, [r1, #0]
}

//============================================================================

uint16_t radar_open_device(int32_t device_number, Radar_Handle_t* device)
{
 80204d4:	460f      	mov	r7, r1
  
  Frame_Format_t frame_format;
  uint16_t retValue = RADAR_ERR_OK;
  int32_t status = 0;
  uint16_t num_of_bytes;
  void* calibration_data_ptr = NULL;
 80204d6:	f846 4d40 	str.w	r4, [r6, #-64]!
  /* Initialize the driver instance with NULL, until it was successfully initialized */
  *device = NULL;
  
  /* Initialize driver data structure */
  /* -------------------------------- */
  status = ds_init();
 80204da:	f7ff fdb7 	bl	802004c <ds_init>
  status |= radar_read_calibration(device, CALIBRATION_TARGET_FLASH, CALIBRATION_DATA_ADC, &calibration_data_ptr, &num_of_bytes);
 80204de:	f10d 0e26 	add.w	lr, sp, #38	; 0x26
  /* Initialize the driver instance with NULL, until it was successfully initialized */
  *device = NULL;
  
  /* Initialize driver data structure */
  /* -------------------------------- */
  status = ds_init();
 80204e2:	4605      	mov	r5, r0
  status |= radar_read_calibration(device, CALIBRATION_TARGET_FLASH, CALIBRATION_DATA_ADC, &calibration_data_ptr, &num_of_bytes);
 80204e4:	4633      	mov	r3, r6
 80204e6:	4638      	mov	r0, r7
 80204e8:	4621      	mov	r1, r4
 80204ea:	4622      	mov	r2, r4
 80204ec:	f8cd e000 	str.w	lr, [sp]
 80204f0:	f000 fac2 	bl	8020a78 <radar_read_calibration>
 80204f4:	4328      	orrs	r0, r5
  if(status > 0)
 80204f6:	42a0      	cmp	r0, r4
 80204f8:	dd03      	ble.n	8020502 <radar_open_device+0x3a>
  {
    return (RADAR_ERR_UNSUPPORTED_FRAME_FORMAT);
 80204fa:	2008      	movs	r0, #8
  retValue = radar_init(device);
  
  g_adc_sampling_completed = false;
  
  return (retValue);
}
 80204fc:	b01a      	add	sp, #104	; 0x68
 80204fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  
  //========================================================================
  //------------------------- Frame Format configurations ------------------
  //========================================================================
  ds_ep_fetch_frame_format(&frame_format);
 8020502:	a80b      	add	r0, sp, #44	; 0x2c
 8020504:	f7ff fe70 	bl	80201e8 <ds_ep_fetch_frame_format>
  
  //=========================================================================
  //------------------------- General configurations ------------------------
  //=========================================================================
  radar_set_data_acq_mode(RADAR_MANUAL_TRIGGER);
 8020508:	4620      	mov	r0, r4
 802050a:	f000 fdfd 	bl	8021108 <radar_set_data_acq_mode>
  
  /* If the frame format contains a 0, this makes no sense. */
  if ((frame_format.rx_mask == 0) ||
 802050e:	f89d 3034 	ldrb.w	r3, [sp, #52]	; 0x34
 8020512:	2b00      	cmp	r3, #0
 8020514:	d0f1      	beq.n	80204fa <radar_open_device+0x32>
      (frame_format.num_chirps_per_frame  == 0) ||
 8020516:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  //------------------------- General configurations ------------------------
  //=========================================================================
  radar_set_data_acq_mode(RADAR_MANUAL_TRIGGER);
  
  /* If the frame format contains a 0, this makes no sense. */
  if ((frame_format.rx_mask == 0) ||
 8020518:	2b00      	cmp	r3, #0
 802051a:	d0ee      	beq.n	80204fa <radar_open_device+0x32>
      (frame_format.num_chirps_per_frame  == 0) ||
        (frame_format.num_samples_per_chirp == 0) ||
 802051c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  //=========================================================================
  radar_set_data_acq_mode(RADAR_MANUAL_TRIGGER);
  
  /* If the frame format contains a 0, this makes no sense. */
  if ((frame_format.rx_mask == 0) ||
      (frame_format.num_chirps_per_frame  == 0) ||
 802051e:	1e51      	subs	r1, r2, #1
 8020520:	29ff      	cmp	r1, #255	; 0xff
 8020522:	d8ea      	bhi.n	80204fa <radar_open_device+0x32>
        (frame_format.num_samples_per_chirp == 0) ||
 8020524:	2b40      	cmp	r3, #64	; 0x40
 8020526:	d8e8      	bhi.n	80204fa <radar_open_device+0x32>
    return (RADAR_ERR_UNSUPPORTED_FRAME_FORMAT);
  }
  
  /* Check frame memory limits */
  /* ------------------------- */
  frame_size = frame_format.num_chirps_per_frame * frame_format.num_samples_per_chirp *
 8020528:	fb02 f503 	mul.w	r5, r2, r3
    ds_ep_get_device_info()->num_rx_antennas * 2U * sizeof(uint16_t); // complex IQ samples per antenna
 802052c:	f7ff fe58 	bl	80201e0 <ds_ep_get_device_info>
    return (RADAR_ERR_UNSUPPORTED_FRAME_FORMAT);
  }
  
  /* Check frame memory limits */
  /* ------------------------- */
  frame_size = frame_format.num_chirps_per_frame * frame_format.num_samples_per_chirp *
 8020530:	7b42      	ldrb	r2, [r0, #13]
 8020532:	491e      	ldr	r1, [pc, #120]	; (80205ac <radar_open_device+0xe4>)
 8020534:	00ab      	lsls	r3, r5, #2
    ds_ep_get_device_info()->num_rx_antennas * 2U * sizeof(uint16_t); // complex IQ samples per antenna
 8020536:	fb02 f303 	mul.w	r3, r2, r3
  
  if (frame_size > BSP_MAX_ADC_BUFFER_SIZE_BYTES)
 802053a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    return (RADAR_ERR_UNSUPPORTED_FRAME_FORMAT);
  }
  
  /* Check frame memory limits */
  /* ------------------------- */
  frame_size = frame_format.num_chirps_per_frame * frame_format.num_samples_per_chirp *
 802053e:	600b      	str	r3, [r1, #0]
    ds_ep_get_device_info()->num_rx_antennas * 2U * sizeof(uint16_t); // complex IQ samples per antenna
  
  if (frame_size > BSP_MAX_ADC_BUFFER_SIZE_BYTES)
 8020540:	d8db      	bhi.n	80204fa <radar_open_device+0x32>
    return (RADAR_ERR_UNSUPPORTED_FRAME_FORMAT);
  }
  
  /* Initialize sensor hardware */
  /* -------------------------- */
  acq_buf = create_acq_data_buffer_obj((uint8_t*) data_fifo, BSP_MAX_ADC_BUFFER_SIZE_BYTES,
 8020542:	f8bd 202c 	ldrh.w	r2, [sp, #44]	; 0x2c
 8020546:	9200      	str	r2, [sp, #0]
 8020548:	f10d 0838 	add.w	r8, sp, #56	; 0x38
 802054c:	2202      	movs	r2, #2
 802054e:	210c      	movs	r1, #12
 8020550:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
 8020554:	9201      	str	r2, [sp, #4]
 8020556:	4640      	mov	r0, r8
 8020558:	9202      	str	r2, [sp, #8]
 802055a:	9103      	str	r1, [sp, #12]
 802055c:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8020560:	4913      	ldr	r1, [pc, #76]	; (80205b0 <radar_open_device+0xe8>)
                                       frame_format.num_chirps_per_frame,
                                       frame_format.num_samples_per_chirp, 2, 2, 12);
  
  ds_set_active_acq_buf(acq_buf);
 8020562:	ae12      	add	r6, sp, #72	; 0x48
    return (RADAR_ERR_UNSUPPORTED_FRAME_FORMAT);
  }
  
  /* Initialize sensor hardware */
  /* -------------------------- */
  acq_buf = create_acq_data_buffer_obj((uint8_t*) data_fifo, BSP_MAX_ADC_BUFFER_SIZE_BYTES,
 8020564:	f7ff fed2 	bl	802030c <create_acq_data_buffer_obj>
                                       frame_format.num_chirps_per_frame,
                                       frame_format.num_samples_per_chirp, 2, 2, 12);
  
  ds_set_active_acq_buf(acq_buf);
 8020568:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 802056a:	466d      	mov	r5, sp
 802056c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 802056e:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
 8020572:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
 8020576:	e898 000f 	ldmia.w	r8, {r0, r1, r2, r3}
 802057a:	f7ff fdb3 	bl	80200e4 <ds_set_active_acq_buf>
  
  ds_device_get_settings()->num_samples_per_chirp = frame_format.num_samples_per_chirp;
 802057e:	f7ff fd43 	bl	8020008 <ds_device_get_settings>
 8020582:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8020584:	62c3      	str	r3, [r0, #44]	; 0x2c
  
  /* Set the number of samples to captured during each chirp
  This value will be used in BSP to configure the DMA block size and destination address */
  bsp_set_num_samples_per_dma_transfer(ds_device_get_settings()->num_samples_per_chirp);
 8020586:	f7ff fd3f 	bl	8020008 <ds_device_get_settings>
 802058a:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 802058c:	f007 ff2c 	bl	80283e8 <bsp_set_num_samples_per_dma_transfer>
  
  ds_device_get_settings()->pll_num_of_chirps_per_frame = frame_format.num_chirps_per_frame;
 8020590:	f7ff fd3a 	bl	8020008 <ds_device_get_settings>
 8020594:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8020596:	6143      	str	r3, [r0, #20]
  
  /* Set the number of chirps count per frame */
  bsp_set_num_chirps_per_frame(frame_format.num_chirps_per_frame);
 8020598:	4618      	mov	r0, r3
 802059a:	f007 ff2b 	bl	80283f4 <bsp_set_num_chirps_per_frame>
  
  /* BGT, PLL, DMA, Timers & Calibration initialization */
  /* -------------------------------------------------- */
  retValue = radar_init(device);
 802059e:	4638      	mov	r0, r7
 80205a0:	f000 fc0a 	bl	8020db8 <radar_init>
  
  g_adc_sampling_completed = false;
 80205a4:	4b03      	ldr	r3, [pc, #12]	; (80205b4 <radar_open_device+0xec>)
 80205a6:	601c      	str	r4, [r3, #0]
  
  return (retValue);
 80205a8:	e7a8      	b.n	80204fc <radar_open_device+0x34>
 80205aa:	bf00      	nop
 80205ac:	1ffe8cb4 	.word	0x1ffe8cb4
 80205b0:	1fff2034 	.word	0x1fff2034
 80205b4:	1ffe8cc0 	.word	0x1ffe8cc0

080205b8 <radar_get_device_info>:
}

//============================================================================

uint16_t radar_get_device_info(Radar_Handle_t device, Device_Info_t* device_info)
{
 80205b8:	b538      	push	{r3, r4, r5, lr}
 80205ba:	460c      	mov	r4, r1
      - Sensor description
      - Hardware Version information
      - Sensor features
      - Data format
  */
  *device_info = *ds_ep_get_device_info();
 80205bc:	f7ff fe10 	bl	80201e0 <ds_ep_get_device_info>
 80205c0:	4605      	mov	r5, r0
 80205c2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80205c4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80205c6:	682b      	ldr	r3, [r5, #0]
 80205c8:	6023      	str	r3, [r4, #0]
   
  return (RADAR_ERR_OK);
}
 80205ca:	2000      	movs	r0, #0
 80205cc:	bd38      	pop	{r3, r4, r5, pc}
 80205ce:	bf00      	nop

080205d0 <radar_get_temperature>:
uint16_t radar_get_temperature(Radar_Handle_t device, uint8_t temp_sensor, int32_t* temperature_001C)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  /* Check temperature sensor, only single sensor supported */
  if (temp_sensor == 0)
 80205d0:	b109      	cbz	r1, 80205d6 <radar_get_temperature+0x6>
    
    return (RADAR_ERR_OK);
  }
  else
  {
    return (RADAR_ERR_SENSOR_DOES_NOT_EXIST);
 80205d2:	2007      	movs	r0, #7
 80205d4:	4770      	bx	lr
}

//============================================================================

uint16_t radar_get_temperature(Radar_Handle_t device, uint8_t temp_sensor, int32_t* temperature_001C)
{
 80205d6:	b538      	push	{r3, r4, r5, lr}
 80205d8:	460c      	mov	r4, r1
 80205da:	4615      	mov	r5, r2
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  /* Check temperature sensor, only single sensor supported */
  if (temp_sensor == 0)
  {
    *temperature_001C = (int32_t) (bsp_bgt_get_temp_value() * 1000.0f);	// (expected value is actual temperature in C° x 1000)
 80205dc:	f007 fef8 	bl	80283d0 <bsp_bgt_get_temp_value>
 80205e0:	eddf 7a05 	vldr	s15, [pc, #20]	; 80205f8 <radar_get_temperature+0x28>
 80205e4:	ee07 0a10 	vmov	s14, r0
 80205e8:	ee67 7a27 	vmul.f32	s15, s14, s15
    
    return (RADAR_ERR_OK);
 80205ec:	4620      	mov	r0, r4
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  /* Check temperature sensor, only single sensor supported */
  if (temp_sensor == 0)
  {
    *temperature_001C = (int32_t) (bsp_bgt_get_temp_value() * 1000.0f);	// (expected value is actual temperature in C° x 1000)
 80205ee:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80205f2:	edc5 7a00 	vstr	s15, [r5]
    
    return (RADAR_ERR_OK);
 80205f6:	bd38      	pop	{r3, r4, r5, pc}
 80205f8:	447a0000 	.word	0x447a0000

080205fc <radar_get_tx_power>:
uint16_t radar_get_tx_power(Radar_Handle_t device, uint8_t tx_antenna, int32_t* tx_power_001dBm)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  /* Check number of TX antenna */
  if (tx_antenna == 0)
 80205fc:	b109      	cbz	r1, 8020602 <radar_get_tx_power+0x6>
    *tx_power_001dBm = (int32_t)(bsp_bgt_get_txpower_value() * 1000.0f); // return TX power
    
    return (RADAR_ERR_OK);
  }
  
  return (RADAR_ERR_ANTENNA_DOES_NOT_EXIST);
 80205fe:	2006      	movs	r0, #6
 8020600:	4770      	bx	lr
}

//============================================================================

uint16_t radar_get_tx_power(Radar_Handle_t device, uint8_t tx_antenna, int32_t* tx_power_001dBm)
{
 8020602:	b538      	push	{r3, r4, r5, lr}
 8020604:	460c      	mov	r4, r1
 8020606:	4615      	mov	r5, r2
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  /* Check number of TX antenna */
  if (tx_antenna == 0)
  {
    *tx_power_001dBm = (int32_t)(bsp_bgt_get_txpower_value() * 1000.0f); // return TX power
 8020608:	f007 fee8 	bl	80283dc <bsp_bgt_get_txpower_value>
 802060c:	eddf 7a05 	vldr	s15, [pc, #20]	; 8020624 <radar_get_tx_power+0x28>
 8020610:	ee07 0a10 	vmov	s14, r0
 8020614:	ee67 7a27 	vmul.f32	s15, s14, s15
    
    return (RADAR_ERR_OK);
 8020618:	4620      	mov	r0, r4
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  /* Check number of TX antenna */
  if (tx_antenna == 0)
  {
    *tx_power_001dBm = (int32_t)(bsp_bgt_get_txpower_value() * 1000.0f); // return TX power
 802061a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 802061e:	edc5 7a00 	vstr	s15, [r5]
    
    return (RADAR_ERR_OK);
 8020622:	bd38      	pop	{r3, r4, r5, pc}
 8020624:	447a0000 	.word	0x447a0000

08020628 <radar_get_chirp_duration>:
}

//============================================================================

uint16_t radar_get_chirp_duration(Radar_Handle_t device, uint32_t* chirp_duration_nsec)
{
 8020628:	b510      	push	{r4, lr}
 802062a:	460c      	mov	r4, r1
  
  /* Calculate chirp timing from current settings */
  /* -------------------------------------------- */
  /* Unit is ns. (factor 10^9 is distributed to denominator and denominator for fixed point precision) */
  
  *chirp_duration_nsec = (ds_device_get_settings()->pll_chirp_time_usec * 1000U);
 802062c:	f7ff fcec 	bl	8020008 <ds_device_get_settings>
 8020630:	6802      	ldr	r2, [r0, #0]
 8020632:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8020636:	fb03 f302 	mul.w	r3, r3, r2
 802063a:	6023      	str	r3, [r4, #0]
  
  return (RADAR_ERR_OK);
}
 802063c:	2000      	movs	r0, #0
 802063e:	bd10      	pop	{r4, pc}

08020640 <radar_get_min_frame_interval>:

//============================================================================

uint16_t radar_get_min_frame_interval(Radar_Handle_t device, uint32_t* min_frame_interval_usec)
{
 8020640:	b570      	push	{r4, r5, r6, lr}
 8020642:	460c      	mov	r4, r1
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  uint32_t bgt_duty_cycle_delay_usec;
  
  if(ds_device_get_settings()->power_duty_cycle_enable_flag == true)
 8020644:	f7ff fce0 	bl	8020008 <ds_device_get_settings>
 8020648:	f890 2024 	ldrb.w	r2, [r0, #36]	; 0x24
  {
    bgt_duty_cycle_delay_usec = 3000U; /* approximate value calculated from bgt power up sequence 100 + 400 + 100 + update configuration time + PLL_LOCK_TIME_us + BGT_VCO_LOCK_TIME_us */
  }
  else
  {
    bgt_duty_cycle_delay_usec = 1000U; /* approximate delay to accommodate processing time */
 802064c:	f640 33b8 	movw	r3, #3000	; 0xbb8
uint16_t radar_get_min_frame_interval(Radar_Handle_t device, uint32_t* min_frame_interval_usec)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  uint32_t bgt_duty_cycle_delay_usec;
  
  if(ds_device_get_settings()->power_duty_cycle_enable_flag == true)
 8020650:	2a01      	cmp	r2, #1
  {
    bgt_duty_cycle_delay_usec = 3000U; /* approximate value calculated from bgt power up sequence 100 + 400 + 100 + update configuration time + PLL_LOCK_TIME_us + BGT_VCO_LOCK_TIME_us */
  }
  else
  {
    bgt_duty_cycle_delay_usec = 1000U; /* approximate delay to accommodate processing time */
 8020652:	bf0c      	ite	eq
 8020654:	461d      	moveq	r5, r3
 8020656:	f44f 757a 	movne.w	r5, #1000	; 0x3e8
#elif defined (DOPPLER_SUPPORTED)
  *min_frame_interval_usec = ds_device_get_settings()->pll_num_of_chirps_per_frame * ((ds_device_get_settings()->num_samples_per_chirp * 1000U * 1000U) / DOPPLER_SAMPLING_FREQ_HZ) + bgt_duty_cycle_delay_usec + ALGO_PROCESS_TIME_USEC; // units in us
  
#else
  
  if(ds_device_get_settings()->pll_modulation_mode == MODULATION_FMCW)
 802065a:	f7ff fcd5 	bl	8020008 <ds_device_get_settings>
 802065e:	6983      	ldr	r3, [r0, #24]
 8020660:	2b01      	cmp	r3, #1
 8020662:	d011      	beq.n	8020688 <radar_get_min_frame_interval+0x48>
  }
  else /* Doppler modulation */
  {
    /* min_frame_interval_usec = Sampling period x No. of chirps x No. of samples per chirp x 1000000 (for microseconds)
    Sampling period =  1 / DOPPLER_SAMPLING_FREQ_Hz */
    *min_frame_interval_usec = ds_device_get_settings()->pll_num_of_chirps_per_frame * ((ds_device_get_settings()->num_samples_per_chirp * 1000U * 1000U) / DOPPLER_SAMPLING_FREQ_HZ) + bgt_duty_cycle_delay_usec; // units in us
 8020664:	f7ff fcd0 	bl	8020008 <ds_device_get_settings>
 8020668:	6946      	ldr	r6, [r0, #20]
 802066a:	f7ff fccd 	bl	8020008 <ds_device_get_settings>
 802066e:	4b0c      	ldr	r3, [pc, #48]	; (80206a0 <radar_get_min_frame_interval+0x60>)
 8020670:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8020672:	490c      	ldr	r1, [pc, #48]	; (80206a4 <radar_get_min_frame_interval+0x64>)
 8020674:	fb03 f202 	mul.w	r2, r3, r2
 8020678:	fba1 2302 	umull	r2, r3, r1, r2
 802067c:	0b9b      	lsrs	r3, r3, #14
 802067e:	fb06 5303 	mla	r3, r6, r3, r5
 8020682:	6023      	str	r3, [r4, #0]
  }
  
#endif
  
  return (RADAR_ERR_OK);
}
 8020684:	2000      	movs	r0, #0
 8020686:	bd70      	pop	{r4, r5, r6, pc}
  
#else
  
  if(ds_device_get_settings()->pll_modulation_mode == MODULATION_FMCW)
  {
    *min_frame_interval_usec = ds_device_get_settings()->pll_num_of_chirps_per_frame * (ds_device_get_settings()->pll_chirp_time_usec + PLL_RAMP_DOWM_TIME_USEC + PLL_STEADY_STATE_USEC) + bgt_duty_cycle_delay_usec; // units in us
 8020688:	f7ff fcbe 	bl	8020008 <ds_device_get_settings>
 802068c:	6946      	ldr	r6, [r0, #20]
 802068e:	f7ff fcbb 	bl	8020008 <ds_device_get_settings>
 8020692:	6803      	ldr	r3, [r0, #0]
 8020694:	33c8      	adds	r3, #200	; 0xc8
 8020696:	fb06 5303 	mla	r3, r6, r3, r5
 802069a:	6023      	str	r3, [r4, #0]
  }
  
#endif
  
  return (RADAR_ERR_OK);
}
 802069c:	2000      	movs	r0, #0
 802069e:	bd70      	pop	{r4, r5, r6, pc}
 80206a0:	000f4240 	.word	0x000f4240
 80206a4:	d1b71759 	.word	0xd1b71759

080206a8 <radar_set_frame_format>:

//============================================================================

uint16_t radar_set_frame_format(Radar_Handle_t device, const Frame_Format_t* frame_format)
{
 80206a8:	b570      	push	{r4, r5, r6, lr}
 80206aa:	4605      	mov	r5, r0
 80206ac:	460c      	mov	r4, r1
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  /* Configuration change is only allowed while automatic trigger is not working */
  if (radar_get_data_acq_mode() != RADAR_MANUAL_TRIGGER)
 80206ae:	f000 fd25 	bl	80210fc <radar_get_data_acq_mode>
 80206b2:	b108      	cbz	r0, 80206b8 <radar_set_frame_format+0x10>
  {
    return (RADAR_ERR_BUSY);
 80206b4:	2002      	movs	r0, #2
 80206b6:	bd70      	pop	{r4, r5, r6, pc}
  
  /* Check if configuration is valid */
  /* ------------------------------- */
  
  /* This sensor can only acquire real signal data */
  if (frame_format->signal_part != RADAR_SIGNAL_I_AND_Q)
 80206b8:	7a63      	ldrb	r3, [r4, #9]
 80206ba:	2b02      	cmp	r3, #2
 80206bc:	d001      	beq.n	80206c2 <radar_set_frame_format+0x1a>
  {
    return (RADAR_ERR_UNAVAILABLE_SIGNAL_PART);
 80206be:	200b      	movs	r0, #11
 80206c0:	bd70      	pop	{r4, r5, r6, pc}
  }
  /* This sensor support RX1, RX2 and both at the same time antennas enabled */
  if (frame_format->rx_mask > BSP_RX_ANTENNA_MASK )
 80206c2:	7a23      	ldrb	r3, [r4, #8]
 80206c4:	2b03      	cmp	r3, #3
 80206c6:	d901      	bls.n	80206cc <radar_set_frame_format+0x24>
  {
    return (RADAR_ERR_ANTENNA_DOES_NOT_EXIST);
 80206c8:	2006      	movs	r0, #6
 80206ca:	bd70      	pop	{r4, r5, r6, pc}
  }
  /* LMX2491 supports only a limited number of ramps before auto turn off. */
  if ((frame_format->num_chirps_per_frame == 0) || (frame_format->num_chirps_per_frame > BSP_MAX_NUM_CHIRPS_PER_FRAME))
 80206cc:	6863      	ldr	r3, [r4, #4]
 80206ce:	1e5a      	subs	r2, r3, #1
 80206d0:	2a3f      	cmp	r2, #63	; 0x3f
 80206d2:	d901      	bls.n	80206d8 <radar_set_frame_format+0x30>
  {
    return (RADAR_ERR_UNSUPPORTED_FRAME_FORMAT);
 80206d4:	2008      	movs	r0, #8
 80206d6:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  /* BGT can store only a limited number of samples per chirp */
  if ((frame_format->num_samples_per_chirp == 0) || (frame_format->num_samples_per_chirp > BSP_MAX_NUM_SAMPLES_PER_CHIRP))
 80206d8:	6826      	ldr	r6, [r4, #0]
 80206da:	1e72      	subs	r2, r6, #1
 80206dc:	2aff      	cmp	r2, #255	; 0xff
 80206de:	d8f9      	bhi.n	80206d4 <radar_set_frame_format+0x2c>
  {
    return (RADAR_ERR_UNSUPPORTED_FRAME_FORMAT);
  }
  
  /* For Doppler modulation mode the number of chirp must be 1 */
  if ((frame_format->num_chirps_per_frame != 1) && (ds_device_get_settings()->pll_modulation_mode == MODULATION_DOPPLER))
 80206e0:	2b01      	cmp	r3, #1
 80206e2:	d005      	beq.n	80206f0 <radar_set_frame_format+0x48>
 80206e4:	f7ff fc90 	bl	8020008 <ds_device_get_settings>
 80206e8:	6983      	ldr	r3, [r0, #24]
 80206ea:	2b00      	cmp	r3, #0
 80206ec:	d0f2      	beq.n	80206d4 <radar_set_frame_format+0x2c>
 80206ee:	6826      	ldr	r6, [r4, #0]
  {
    return (RADAR_ERR_UNSUPPORTED_FRAME_FORMAT);
  }
  
  /* Check if samples per chirp are in [32,64,128,256] range */
  if ((frame_format->num_samples_per_chirp != 256U) &&
 80206f0:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
 80206f4:	d007      	beq.n	8020706 <radar_set_frame_format+0x5e>
 80206f6:	2e80      	cmp	r6, #128	; 0x80
 80206f8:	d005      	beq.n	8020706 <radar_set_frame_format+0x5e>
      (frame_format->num_samples_per_chirp != 128U) &&
 80206fa:	2e40      	cmp	r6, #64	; 0x40
 80206fc:	d003      	beq.n	8020706 <radar_set_frame_format+0x5e>
        (frame_format->num_samples_per_chirp != 64U)  &&
 80206fe:	2e20      	cmp	r6, #32
 8020700:	d001      	beq.n	8020706 <radar_set_frame_format+0x5e>
          (frame_format->num_samples_per_chirp != 32U))
  {
    return (RADAR_ERR_SAMPLERATE_OUT_OF_RANGE);
 8020702:	2050      	movs	r0, #80	; 0x50
  ds_ep_store_frame_format(frame_format);
  
  g_adc_sampling_completed = false;
  
  return (RADAR_ERR_OK);
}
 8020704:	bd70      	pop	{r4, r5, r6, pc}
          (frame_format->num_samples_per_chirp != 32U))
  {
    return (RADAR_ERR_SAMPLERATE_OUT_OF_RANGE);
  }
  
  uint32_t temp_samplerate_Hz = (uint32_t) (((float)frame_format->num_samples_per_chirp * 1000000.0f ) / ds_device_get_settings()->pll_chirp_time_usec );
 8020706:	f7ff fc7f 	bl	8020008 <ds_device_get_settings>
 802070a:	ee07 6a90 	vmov	s15, r6
 802070e:	ed9f 6a16 	vldr	s12, [pc, #88]	; 8020768 <radar_set_frame_format+0xc0>
 8020712:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 8020716:	edd0 7a00 	vldr	s15, [r0]
 802071a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 802071e:	ee67 7a06 	vmul.f32	s15, s14, s12
  radar_set_sampling_freq(device, MODULATION_FMCW, temp_samplerate_Hz);
 8020722:	2101      	movs	r1, #1
          (frame_format->num_samples_per_chirp != 32U))
  {
    return (RADAR_ERR_SAMPLERATE_OUT_OF_RANGE);
  }
  
  uint32_t temp_samplerate_Hz = (uint32_t) (((float)frame_format->num_samples_per_chirp * 1000000.0f ) / ds_device_get_settings()->pll_chirp_time_usec );
 8020724:	eec7 7aa6 	vdiv.f32	s15, s15, s13
  radar_set_sampling_freq(device, MODULATION_FMCW, temp_samplerate_Hz);
 8020728:	4628      	mov	r0, r5
          (frame_format->num_samples_per_chirp != 32U))
  {
    return (RADAR_ERR_SAMPLERATE_OUT_OF_RANGE);
  }
  
  uint32_t temp_samplerate_Hz = (uint32_t) (((float)frame_format->num_samples_per_chirp * 1000000.0f ) / ds_device_get_settings()->pll_chirp_time_usec );
 802072a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
  radar_set_sampling_freq(device, MODULATION_FMCW, temp_samplerate_Hz);
 802072e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8020732:	ee17 2a90 	vmov	r2, s15
 8020736:	f000 fc5f 	bl	8020ff8 <radar_set_sampling_freq>

  /* Check frame memory limits */
  /* ------------------------- */
  frame_size = frame_format->num_chirps_per_frame * frame_format->num_samples_per_chirp * 2U *
 802073a:	e894 0028 	ldmia.w	r4, {r3, r5}
 802073e:	fb03 f505 	mul.w	r5, r3, r5
    ds_ep_get_device_info()->num_rx_antennas * sizeof(uint16_t); // complex IQ samples per antenna
 8020742:	f7ff fd4d 	bl	80201e0 <ds_ep_get_device_info>
  uint32_t temp_samplerate_Hz = (uint32_t) (((float)frame_format->num_samples_per_chirp * 1000000.0f ) / ds_device_get_settings()->pll_chirp_time_usec );
  radar_set_sampling_freq(device, MODULATION_FMCW, temp_samplerate_Hz);

  /* Check frame memory limits */
  /* ------------------------- */
  frame_size = frame_format->num_chirps_per_frame * frame_format->num_samples_per_chirp * 2U *
 8020746:	7b42      	ldrb	r2, [r0, #13]
 8020748:	4908      	ldr	r1, [pc, #32]	; (802076c <radar_set_frame_format+0xc4>)
 802074a:	00ab      	lsls	r3, r5, #2
    ds_ep_get_device_info()->num_rx_antennas * sizeof(uint16_t); // complex IQ samples per antenna
 802074c:	fb02 f303 	mul.w	r3, r2, r3
  
  if (frame_size > BSP_MAX_ADC_BUFFER_SIZE_BYTES)
 8020750:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
  uint32_t temp_samplerate_Hz = (uint32_t) (((float)frame_format->num_samples_per_chirp * 1000000.0f ) / ds_device_get_settings()->pll_chirp_time_usec );
  radar_set_sampling_freq(device, MODULATION_FMCW, temp_samplerate_Hz);

  /* Check frame memory limits */
  /* ------------------------- */
  frame_size = frame_format->num_chirps_per_frame * frame_format->num_samples_per_chirp * 2U *
 8020754:	600b      	str	r3, [r1, #0]
    ds_ep_get_device_info()->num_rx_antennas * sizeof(uint16_t); // complex IQ samples per antenna
  
  if (frame_size > BSP_MAX_ADC_BUFFER_SIZE_BYTES)
 8020756:	d8bd      	bhi.n	80206d4 <radar_set_frame_format+0x2c>
  {
    return (RADAR_ERR_UNSUPPORTED_FRAME_FORMAT);
  }
  
  /* Store new frame format in store */
  ds_ep_store_frame_format(frame_format);
 8020758:	4620      	mov	r0, r4
 802075a:	f7ff fd53 	bl	8020204 <ds_ep_store_frame_format>
  
  g_adc_sampling_completed = false;
 802075e:	4b04      	ldr	r3, [pc, #16]	; (8020770 <radar_set_frame_format+0xc8>)
 8020760:	2000      	movs	r0, #0
 8020762:	6018      	str	r0, [r3, #0]
  
  return (RADAR_ERR_OK);
 8020764:	bd70      	pop	{r4, r5, r6, pc}
 8020766:	bf00      	nop
 8020768:	49742400 	.word	0x49742400
 802076c:	1ffe8cb4 	.word	0x1ffe8cb4
 8020770:	1ffe8cc0 	.word	0x1ffe8cc0

08020774 <radar_get_frame_format>:
}

//============================================================================

uint16_t radar_get_frame_format(Radar_Handle_t device, Frame_Format_t* p_frame_format)
{
 8020774:	b508      	push	{r3, lr}
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  /* Return current frame format of driver object */
  ds_ep_fetch_frame_format(p_frame_format);
 8020776:	4608      	mov	r0, r1
 8020778:	f7ff fd36 	bl	80201e8 <ds_ep_fetch_frame_format>
  
  return (RADAR_ERR_OK);
}
 802077c:	2000      	movs	r0, #0
 802077e:	bd08      	pop	{r3, pc}

08020780 <radar_get_frame>:

//============================================================================

uint16_t radar_get_frame(Radar_Handle_t device, Frame_Info_t* frame_info, uint8_t wait_for_data)
{
 8020780:	b570      	push	{r4, r5, r6, lr}
 8020782:	b084      	sub	sp, #16
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  Frame_Format_t frame_format;
  
  ds_ep_fetch_frame_format(&frame_format);
 8020784:	a801      	add	r0, sp, #4
}

//============================================================================

uint16_t radar_get_frame(Radar_Handle_t device, Frame_Info_t* frame_info, uint8_t wait_for_data)
{
 8020786:	460d      	mov	r5, r1
 8020788:	4614      	mov	r4, r2
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  Frame_Format_t frame_format;
  
  ds_ep_fetch_frame_format(&frame_format);
 802078a:	f7ff fd2d 	bl	80201e8 <ds_ep_fetch_frame_format>
  
  acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 802078e:	f7ff fca5 	bl	80200dc <ds_get_active_acq_buf>
 8020792:	4606      	mov	r6, r0
  
  if (radar_get_data_acq_mode() != RADAR_AUTO_TRIGGER)	// without automaticFrameTrigger
 8020794:	f000 fcb2 	bl	80210fc <radar_get_data_acq_mode>
 8020798:	2801      	cmp	r0, #1
 802079a:	d02f      	beq.n	80207fc <radar_get_frame+0x7c>
  {
    bsp_trigger_new_frame();
 802079c:	f007 fbf0 	bl	8027f80 <bsp_trigger_new_frame>
 80207a0:	4a1b      	ldr	r2, [pc, #108]	; (8020810 <radar_get_frame+0x90>)
    {
      return (RADAR_ERR_TIMEOUT);
    }
  }
  
  while (g_adc_sampling_completed == false); // block GetFrame if data is not ready
 80207a2:	6813      	ldr	r3, [r2, #0]
 80207a4:	4c1a      	ldr	r4, [pc, #104]	; (8020810 <radar_get_frame+0x90>)
 80207a6:	2b00      	cmp	r3, #0
 80207a8:	d0fb      	beq.n	80207a2 <radar_get_frame+0x22>
  
  /* Data acquired */
  /* ------------- */
  //memcpy(transport_buffer, p_acq_buf->p_acq_buf, frame_size);	// copy ADC buffer to be send to avoid data corruption by Automatic trigger
  
  frame_info->sample_data           = p_acq_buf->p_acq_buf;
 80207aa:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 80207ac:	602b      	str	r3, [r5, #0]
  frame_info->num_rx_antennas       = ds_ep_get_device_info()->num_rx_antennas;
 80207ae:	f7ff fd17 	bl	80201e0 <ds_ep_get_device_info>
  frame_info->num_chirps            = frame_format.num_chirps_per_frame;
 80207b2:	9a02      	ldr	r2, [sp, #8]
  /* Data acquired */
  /* ------------- */
  //memcpy(transport_buffer, p_acq_buf->p_acq_buf, frame_size);	// copy ADC buffer to be send to avoid data corruption by Automatic trigger
  
  frame_info->sample_data           = p_acq_buf->p_acq_buf;
  frame_info->num_rx_antennas       = ds_ep_get_device_info()->num_rx_antennas;
 80207b4:	7b41      	ldrb	r1, [r0, #13]
  frame_info->num_chirps            = frame_format.num_chirps_per_frame;
  frame_info->rx_mask               = frame_format.rx_mask;
 80207b6:	f89d 300c 	ldrb.w	r3, [sp, #12]
  /* Data acquired */
  /* ------------- */
  //memcpy(transport_buffer, p_acq_buf->p_acq_buf, frame_size);	// copy ADC buffer to be send to avoid data corruption by Automatic trigger
  
  frame_info->sample_data           = p_acq_buf->p_acq_buf;
  frame_info->num_rx_antennas       = ds_ep_get_device_info()->num_rx_antennas;
 80207ba:	7329      	strb	r1, [r5, #12]
  frame_info->num_chirps            = frame_format.num_chirps_per_frame;
 80207bc:	60aa      	str	r2, [r5, #8]
  frame_info->rx_mask               = frame_format.rx_mask;
 80207be:	762b      	strb	r3, [r5, #24]
  frame_info->adc_resolution        = ds_device_get_settings()->adc_resolution;
 80207c0:	f7ff fc22 	bl	8020008 <ds_device_get_settings>
  frame_info->interleaved_rx        = 0;
 80207c4:	2600      	movs	r6, #0
  
  frame_info->sample_data           = p_acq_buf->p_acq_buf;
  frame_info->num_rx_antennas       = ds_ep_get_device_info()->num_rx_antennas;
  frame_info->num_chirps            = frame_format.num_chirps_per_frame;
  frame_info->rx_mask               = frame_format.rx_mask;
  frame_info->adc_resolution        = ds_device_get_settings()->adc_resolution;
 80207c6:	f890 3020 	ldrb.w	r3, [r0, #32]
 80207ca:	766b      	strb	r3, [r5, #25]
  frame_info->interleaved_rx        = 0;
 80207cc:	76ae      	strb	r6, [r5, #26]
  frame_info->frame_number          = bsp_get_frame_counter();
 80207ce:	f007 fe13 	bl	80283f8 <bsp_get_frame_counter>
  frame_info->data_format           = RADAR_RX_DATA_COMPLEX;
 80207d2:	2301      	movs	r3, #1
 80207d4:	76eb      	strb	r3, [r5, #27]
  frame_info->num_rx_antennas       = ds_ep_get_device_info()->num_rx_antennas;
  frame_info->num_chirps            = frame_format.num_chirps_per_frame;
  frame_info->rx_mask               = frame_format.rx_mask;
  frame_info->adc_resolution        = ds_device_get_settings()->adc_resolution;
  frame_info->interleaved_rx        = 0;
  frame_info->frame_number          = bsp_get_frame_counter();
 80207d6:	6068      	str	r0, [r5, #4]
  frame_info->data_format           = RADAR_RX_DATA_COMPLEX;
  frame_info->temperature_001C      = (int32_t) (bsp_bgt_get_temp_value() * 1000);	// (expected value is actual temperature in C° x 1000)
 80207d8:	f007 fdfa 	bl	80283d0 <bsp_bgt_get_temp_value>
 80207dc:	eddf 7a0d 	vldr	s15, [pc, #52]	; 8020814 <radar_get_frame+0x94>
  frame_info->num_samples_per_chirp = frame_format.num_samples_per_chirp;
 80207e0:	9b01      	ldr	r3, [sp, #4]

  g_adc_sampling_completed          = false;
 80207e2:	6026      	str	r6, [r4, #0]
  frame_info->rx_mask               = frame_format.rx_mask;
  frame_info->adc_resolution        = ds_device_get_settings()->adc_resolution;
  frame_info->interleaved_rx        = 0;
  frame_info->frame_number          = bsp_get_frame_counter();
  frame_info->data_format           = RADAR_RX_DATA_COMPLEX;
  frame_info->temperature_001C      = (int32_t) (bsp_bgt_get_temp_value() * 1000);	// (expected value is actual temperature in C° x 1000)
 80207e4:	ee07 0a10 	vmov	s14, r0
 80207e8:	ee67 7a27 	vmul.f32	s15, s14, s15
  frame_info->num_samples_per_chirp = frame_format.num_samples_per_chirp;

  g_adc_sampling_completed          = false;
  
  return (RADAR_ERR_OK);
 80207ec:	4630      	mov	r0, r6
  frame_info->rx_mask               = frame_format.rx_mask;
  frame_info->adc_resolution        = ds_device_get_settings()->adc_resolution;
  frame_info->interleaved_rx        = 0;
  frame_info->frame_number          = bsp_get_frame_counter();
  frame_info->data_format           = RADAR_RX_DATA_COMPLEX;
  frame_info->temperature_001C      = (int32_t) (bsp_bgt_get_temp_value() * 1000);	// (expected value is actual temperature in C° x 1000)
 80207ee:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  frame_info->num_samples_per_chirp = frame_format.num_samples_per_chirp;
 80207f2:	612b      	str	r3, [r5, #16]
  frame_info->rx_mask               = frame_format.rx_mask;
  frame_info->adc_resolution        = ds_device_get_settings()->adc_resolution;
  frame_info->interleaved_rx        = 0;
  frame_info->frame_number          = bsp_get_frame_counter();
  frame_info->data_format           = RADAR_RX_DATA_COMPLEX;
  frame_info->temperature_001C      = (int32_t) (bsp_bgt_get_temp_value() * 1000);	// (expected value is actual temperature in C° x 1000)
 80207f4:	edc5 7a05 	vstr	s15, [r5, #20]
  frame_info->num_samples_per_chirp = frame_format.num_samples_per_chirp;

  g_adc_sampling_completed          = false;
  
  return (RADAR_ERR_OK);
}
 80207f8:	b004      	add	sp, #16
 80207fa:	bd70      	pop	{r4, r5, r6, pc}
  {
    bsp_trigger_new_frame();
  }
  else // with automaticFrameTrigger
  {
    if ((!wait_for_data) && (!g_adc_sampling_completed))
 80207fc:	4a04      	ldr	r2, [pc, #16]	; (8020810 <radar_get_frame+0x90>)
 80207fe:	2c00      	cmp	r4, #0
 8020800:	d1cf      	bne.n	80207a2 <radar_get_frame+0x22>
 8020802:	6813      	ldr	r3, [r2, #0]
 8020804:	2b00      	cmp	r3, #0
 8020806:	d1cc      	bne.n	80207a2 <radar_get_frame+0x22>
    {
      return (RADAR_ERR_TIMEOUT);
 8020808:	2004      	movs	r0, #4
  frame_info->num_samples_per_chirp = frame_format.num_samples_per_chirp;

  g_adc_sampling_completed          = false;
  
  return (RADAR_ERR_OK);
}
 802080a:	b004      	add	sp, #16
 802080c:	bd70      	pop	{r4, r5, r6, pc}
 802080e:	bf00      	nop
 8020810:	1ffe8cc0 	.word	0x1ffe8cc0
 8020814:	447a0000 	.word	0x447a0000

08020818 <radar_set_automatic_frame_trigger>:

//============================================================================

uint16_t radar_set_automatic_frame_trigger(Radar_Handle_t device, uint32_t frame_interval_usec)
{
 8020818:	b570      	push	{r4, r5, r6, lr}
  /* Stop trigger timer first  */
  /* ------------------------- */
  bsp_timer_stop_clear(&TIMER_FRAME_TRIG);
 802081a:	4827      	ldr	r0, [pc, #156]	; (80208b8 <radar_set_automatic_frame_trigger+0xa0>)
}

//============================================================================

uint16_t radar_set_automatic_frame_trigger(Radar_Handle_t device, uint32_t frame_interval_usec)
{
 802081c:	460c      	mov	r4, r1
  /* Stop trigger timer first  */
  /* ------------------------- */
  bsp_timer_stop_clear(&TIMER_FRAME_TRIG);
 802081e:	f007 fb45 	bl	8027eac <bsp_timer_stop_clear>
  
  radar_set_data_acq_mode(RADAR_MANUAL_TRIGGER);
 8020822:	2000      	movs	r0, #0
 8020824:	f000 fc70 	bl	8021108 <radar_set_data_acq_mode>
  
  /* Restart trigger timer */
  /* --------------------- */
  if (frame_interval_usec > 0)
 8020828:	b90c      	cbnz	r4, 802082e <radar_set_automatic_frame_trigger+0x16>
    radar_set_data_acq_mode(RADAR_AUTO_TRIGGER);
    
    bsp_timer_start(&TIMER_FRAME_TRIG);
  }
  
  return (RADAR_ERR_OK);
 802082a:	4620      	mov	r0, r4
}
 802082c:	bd70      	pop	{r4, r5, r6, pc}
uint16_t radar_get_min_frame_interval(Radar_Handle_t device, uint32_t* min_frame_interval_usec)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  uint32_t bgt_duty_cycle_delay_usec;
  
  if(ds_device_get_settings()->power_duty_cycle_enable_flag == true)
 802082e:	f7ff fbeb 	bl	8020008 <ds_device_get_settings>
 8020832:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
  {
    bgt_duty_cycle_delay_usec = 3000U; /* approximate value calculated from bgt power up sequence 100 + 400 + 100 + update configuration time + PLL_LOCK_TIME_us + BGT_VCO_LOCK_TIME_us */
  }
  else
  {
    bgt_duty_cycle_delay_usec = 1000U; /* approximate delay to accommodate processing time */
 8020836:	2b01      	cmp	r3, #1
 8020838:	f640 35b8 	movw	r5, #3000	; 0xbb8
 802083c:	bf18      	it	ne
 802083e:	f44f 757a 	movne.w	r5, #1000	; 0x3e8
#elif defined (DOPPLER_SUPPORTED)
  *min_frame_interval_usec = ds_device_get_settings()->pll_num_of_chirps_per_frame * ((ds_device_get_settings()->num_samples_per_chirp * 1000U * 1000U) / DOPPLER_SAMPLING_FREQ_HZ) + bgt_duty_cycle_delay_usec + ALGO_PROCESS_TIME_USEC; // units in us
  
#else
  
  if(ds_device_get_settings()->pll_modulation_mode == MODULATION_FMCW)
 8020842:	f7ff fbe1 	bl	8020008 <ds_device_get_settings>
 8020846:	6983      	ldr	r3, [r0, #24]
 8020848:	2b01      	cmp	r3, #1
 802084a:	d012      	beq.n	8020872 <radar_set_automatic_frame_trigger+0x5a>
  }
  else /* Doppler modulation */
  {
    /* min_frame_interval_usec = Sampling period x No. of chirps x No. of samples per chirp x 1000000 (for microseconds)
    Sampling period =  1 / DOPPLER_SAMPLING_FREQ_Hz */
    *min_frame_interval_usec = ds_device_get_settings()->pll_num_of_chirps_per_frame * ((ds_device_get_settings()->num_samples_per_chirp * 1000U * 1000U) / DOPPLER_SAMPLING_FREQ_HZ) + bgt_duty_cycle_delay_usec; // units in us
 802084c:	f7ff fbdc 	bl	8020008 <ds_device_get_settings>
 8020850:	6946      	ldr	r6, [r0, #20]
 8020852:	f7ff fbd9 	bl	8020008 <ds_device_get_settings>
 8020856:	4b19      	ldr	r3, [pc, #100]	; (80208bc <radar_set_automatic_frame_trigger+0xa4>)
 8020858:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 802085a:	4a19      	ldr	r2, [pc, #100]	; (80208c0 <radar_set_automatic_frame_trigger+0xa8>)
 802085c:	fb03 f301 	mul.w	r3, r3, r1
 8020860:	fba2 2303 	umull	r2, r3, r2, r3
 8020864:	0b9b      	lsrs	r3, r3, #14
 8020866:	fb06 5303 	mla	r3, r6, r3, r5
  {
    uint32_t min_frame_interval_usec;
    
    radar_get_min_frame_interval(device, &min_frame_interval_usec);
    
    if (frame_interval_usec < min_frame_interval_usec)
 802086a:	429c      	cmp	r4, r3
 802086c:	d20b      	bcs.n	8020886 <radar_set_automatic_frame_trigger+0x6e>
  {
    bgt_duty_cycle_delay_usec = 3000U; /* approximate value calculated from bgt power up sequence 100 + 400 + 100 + update configuration time + PLL_LOCK_TIME_us + BGT_VCO_LOCK_TIME_us */
  }
  else
  {
    bgt_duty_cycle_delay_usec = 1000U; /* approximate delay to accommodate processing time */
 802086e:	2005      	movs	r0, #5
 8020870:	bd70      	pop	{r4, r5, r6, pc}
  
#else
  
  if(ds_device_get_settings()->pll_modulation_mode == MODULATION_FMCW)
  {
    *min_frame_interval_usec = ds_device_get_settings()->pll_num_of_chirps_per_frame * (ds_device_get_settings()->pll_chirp_time_usec + PLL_RAMP_DOWM_TIME_USEC + PLL_STEADY_STATE_USEC) + bgt_duty_cycle_delay_usec; // units in us
 8020872:	f7ff fbc9 	bl	8020008 <ds_device_get_settings>
 8020876:	6946      	ldr	r6, [r0, #20]
 8020878:	f7ff fbc6 	bl	8020008 <ds_device_get_settings>
 802087c:	6803      	ldr	r3, [r0, #0]
 802087e:	33c8      	adds	r3, #200	; 0xc8
 8020880:	fb06 5303 	mla	r3, r6, r3, r5
 8020884:	e7f1      	b.n	802086a <radar_set_automatic_frame_trigger+0x52>
    {
      return (RADAR_ERR_UNSUPPORTED_FRAME_INTERVAL);
    }
    
    /* Update time period of Automatic Trigger */
    if (TIMER_SetTimeInterval(&TIMER_FRAME_TRIG, frame_interval_usec * 100U) != TIMER_STATUS_SUCCESS)
 8020886:	2164      	movs	r1, #100	; 0x64
 8020888:	fb01 f104 	mul.w	r1, r1, r4
 802088c:	480a      	ldr	r0, [pc, #40]	; (80208b8 <radar_set_automatic_frame_trigger+0xa0>)
 802088e:	f005 fd5f 	bl	8026350 <TIMER_SetTimeInterval>
 8020892:	4605      	mov	r5, r0
 8020894:	2800      	cmp	r0, #0
 8020896:	d1ea      	bne.n	802086e <radar_set_automatic_frame_trigger+0x56>
    {
      return (RADAR_ERR_UNSUPPORTED_FRAME_INTERVAL);
    }
    
    ds_device_get_settings()->frame_period_usec = frame_interval_usec;
 8020898:	f7ff fbb6 	bl	8020008 <ds_device_get_settings>
 802089c:	6284      	str	r4, [r0, #40]	; 0x28
    
    /* Reset the current frame counter */
    bsp_reset_frame_counter();
 802089e:	f007 fdb1 	bl	8028404 <bsp_reset_frame_counter>
    
    g_adc_sampling_completed = false;
 80208a2:	4b08      	ldr	r3, [pc, #32]	; (80208c4 <radar_set_automatic_frame_trigger+0xac>)
    
    radar_set_data_acq_mode(RADAR_AUTO_TRIGGER);
 80208a4:	2001      	movs	r0, #1
    ds_device_get_settings()->frame_period_usec = frame_interval_usec;
    
    /* Reset the current frame counter */
    bsp_reset_frame_counter();
    
    g_adc_sampling_completed = false;
 80208a6:	601d      	str	r5, [r3, #0]
    
    radar_set_data_acq_mode(RADAR_AUTO_TRIGGER);
 80208a8:	f000 fc2e 	bl	8021108 <radar_set_data_acq_mode>
    
    bsp_timer_start(&TIMER_FRAME_TRIG);
 80208ac:	4802      	ldr	r0, [pc, #8]	; (80208b8 <radar_set_automatic_frame_trigger+0xa0>)
 80208ae:	f007 fb09 	bl	8027ec4 <bsp_timer_start>
  }
  
  return (RADAR_ERR_OK);
 80208b2:	4628      	mov	r0, r5
 80208b4:	bd70      	pop	{r4, r5, r6, pc}
 80208b6:	bf00      	nop
 80208b8:	1ffe890c 	.word	0x1ffe890c
 80208bc:	000f4240 	.word	0x000f4240
 80208c0:	d1b71759 	.word	0xd1b71759
 80208c4:	1ffe8cc0 	.word	0x1ffe8cc0

080208c8 <radar_test_antennas>:
  XMC_UNUSED_ARG(rx_antenna_mask);
  XMC_UNUSED_ARG(frequency_kHz);
  XMC_UNUSED_ARG(tx_power);
  
  return (RADAR_ERR_FEATURE_UNAVAILABLE);
}
 80208c8:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 80208cc:	4770      	bx	lr
 80208ce:	bf00      	nop

080208d0 <radar_get_fft_configuration>:

void radar_get_fft_configuration(Radar_Handle_t device, FFT_configuration_t *p_fft_config)
{
	XMC_UNUSED_ARG(device);

	ds_ep_fetch_fft_config(p_fft_config);
 80208d0:	4608      	mov	r0, r1
 80208d2:	f7ff bcad 	b.w	8020230 <ds_ep_fetch_fft_config>
 80208d6:	bf00      	nop

080208d8 <radar_init_calibration>:

void radar_init_calibration(Radar_Handle_t device)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */

  memset(adc_i1_calibration, DEFAULT_CALIBRATION_VALUE, ADC_CALIB_LEN_BYTES);
 80208d8:	4802      	ldr	r0, [pc, #8]	; (80208e4 <radar_init_calibration+0xc>)
 80208da:	2100      	movs	r1, #0
 80208dc:	f44f 6200 	mov.w	r2, #2048	; 0x800
 80208e0:	f00a b929 	b.w	802ab36 <memset>
 80208e4:	1fffa034 	.word	0x1fffa034

080208e8 <radar_save_calibration>:
}

//============================================================================

uint16_t radar_save_calibration(Radar_Handle_t device, Calibration_Target_t target, Calibration_Data_t calib_data_type, const void* calibration_data_ptr)
{
 80208e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80208ec:	b08d      	sub	sp, #52	; 0x34
 80208ee:	9103      	str	r1, [sp, #12]
  if (calib_data_type == CALIBRATION_DATA_ADC)
 80208f0:	2a00      	cmp	r2, #0
 80208f2:	f040 8083 	bne.w	80209fc <radar_save_calibration+0x114>
  {
    uint16_t status  = 1;
    Frame_Info_t frame_info;
    
    g_do_processing = false;
 80208f6:	4b5a      	ldr	r3, [pc, #360]	; (8020a60 <radar_save_calibration+0x178>)
 80208f8:	4604      	mov	r4, r0
 80208fa:	601a      	str	r2, [r3, #0]
    
    while(status)
    {
      status = radar_get_frame(device, &frame_info, true);
 80208fc:	4620      	mov	r0, r4
 80208fe:	a905      	add	r1, sp, #20
 8020900:	2201      	movs	r2, #1
 8020902:	f7ff ff3d 	bl	8020780 <radar_get_frame>
    uint16_t status  = 1;
    Frame_Info_t frame_info;
    
    g_do_processing = false;
    
    while(status)
 8020906:	2800      	cmp	r0, #0
 8020908:	d1f8      	bne.n	80208fc <radar_save_calibration+0x14>
 802090a:	4607      	mov	r7, r0
 */

static void save_adc_calibration(Calibration_Target_t target)
{
  uint32_t cal_idx = 0;
  uint32_t interp_factor = MAX_CALIB_SAMPLES_PER_CHANNEL / ds_device_get_settings()->num_samples_per_chirp;	// interpolation factor
 802090c:	f7ff fb7c 	bl	8020008 <ds_device_get_settings>
 8020910:	f44f 7280 	mov.w	r2, #256	; 0x100
 8020914:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8020916:	fbb2 f3f3 	udiv	r3, r2, r3
 802091a:	9300      	str	r3, [sp, #0]

  acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 802091c:	f7ff fbde 	bl	80200dc <ds_get_active_acq_buf>
  
  uint16_t *adc_temp[4];
  adc_temp[0] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 0, 0);
 8020920:	4639      	mov	r1, r7
 8020922:	463a      	mov	r2, r7
static void save_adc_calibration(Calibration_Target_t target)
{
  uint32_t cal_idx = 0;
  uint32_t interp_factor = MAX_CALIB_SAMPLES_PER_CHANNEL / ds_device_get_settings()->num_samples_per_chirp;	// interpolation factor

  acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 8020924:	4680      	mov	r8, r0
  
  uint16_t *adc_temp[4];
  adc_temp[0] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 0, 0);
 8020926:	f7ff fce1 	bl	80202ec <get_buffer_address_by_chirp>
  adc_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 1, 0);
 802092a:	463a      	mov	r2, r7
  uint32_t interp_factor = MAX_CALIB_SAMPLES_PER_CHANNEL / ds_device_get_settings()->num_samples_per_chirp;	// interpolation factor

  acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
  
  uint16_t *adc_temp[4];
  adc_temp[0] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 0, 0);
 802092c:	4606      	mov	r6, r0
  adc_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 1, 0);
 802092e:	2101      	movs	r1, #1
 8020930:	4640      	mov	r0, r8
 8020932:	f7ff fcdb 	bl	80202ec <get_buffer_address_by_chirp>
  adc_temp[2] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 2, 0);
 8020936:	463a      	mov	r2, r7

  acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
  
  uint16_t *adc_temp[4];
  adc_temp[0] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 0, 0);
  adc_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 1, 0);
 8020938:	4605      	mov	r5, r0
  adc_temp[2] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 2, 0);
 802093a:	2102      	movs	r1, #2
 802093c:	4640      	mov	r0, r8
 802093e:	f7ff fcd5 	bl	80202ec <get_buffer_address_by_chirp>
  adc_temp[3] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, 0);
 8020942:	463a      	mov	r2, r7
  acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
  
  uint16_t *adc_temp[4];
  adc_temp[0] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 0, 0);
  adc_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 1, 0);
  adc_temp[2] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 2, 0);
 8020944:	4604      	mov	r4, r0
  adc_temp[3] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, 0);
 8020946:	2103      	movs	r1, #3
 8020948:	4640      	mov	r0, r8
 802094a:	f7ff fccf 	bl	80202ec <get_buffer_address_by_chirp>
 802094e:	9b00      	ldr	r3, [sp, #0]
 8020950:	4944      	ldr	r1, [pc, #272]	; (8020a64 <radar_save_calibration+0x17c>)

  /* Fill the calibration buffer with raw ADC data */
  for (uint32_t i = 0; i < ds_device_get_settings()->num_samples_per_chirp; i++)
  {
    adc_i1_calibration[cal_idx] = (adc_temp[0])[i];
    adc_q1_calibration[cal_idx] = (adc_temp[1])[i];
 8020952:	f8df b11c 	ldr.w	fp, [pc, #284]	; 8020a70 <radar_save_calibration+0x188>
    adc_i2_calibration[cal_idx] = (adc_temp[2])[i];
 8020956:	f8df a11c 	ldr.w	sl, [pc, #284]	; 8020a74 <radar_save_calibration+0x18c>
 802095a:	ea4f 0843 	mov.w	r8, r3, lsl #1
 802095e:	f1c8 0200 	rsb	r2, r8, #0
  
  uint16_t *adc_temp[4];
  adc_temp[0] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 0, 0);
  adc_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 1, 0);
  adc_temp[2] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 2, 0);
  adc_temp[3] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, 0);
 8020962:	46b9      	mov	r9, r7
 8020964:	188b      	adds	r3, r1, r2
 8020966:	f8cd 8000 	str.w	r8, [sp]
 802096a:	9201      	str	r2, [sp, #4]
 802096c:	3e02      	subs	r6, #2
 802096e:	3d02      	subs	r5, #2
 8020970:	3c02      	subs	r4, #2
 8020972:	1e87      	subs	r7, r0, #2
 8020974:	9302      	str	r3, [sp, #8]

  /* Fill the calibration buffer with raw ADC data */
  for (uint32_t i = 0; i < ds_device_get_settings()->num_samples_per_chirp; i++)
 8020976:	46c8      	mov	r8, r9
 8020978:	e018      	b.n	80209ac <radar_save_calibration+0xc4>
  {
    adc_i1_calibration[cal_idx] = (adc_temp[0])[i];
 802097a:	9b02      	ldr	r3, [sp, #8]
 802097c:	f836 0f02 	ldrh.w	r0, [r6, #2]!
 8020980:	f823 0009 	strh.w	r0, [r3, r9]
    adc_q1_calibration[cal_idx] = (adc_temp[1])[i];
 8020984:	f8db 0000 	ldr.w	r0, [fp]
 8020988:	f835 ef02 	ldrh.w	lr, [r5, #2]!
 802098c:	f820 e002 	strh.w	lr, [r0, r2]
    adc_i2_calibration[cal_idx] = (adc_temp[2])[i];
 8020990:	f8da 0000 	ldr.w	r0, [sl]
 8020994:	f834 ef02 	ldrh.w	lr, [r4, #2]!
    adc_q2_calibration[cal_idx] = (adc_temp[3])[i];
 8020998:	4b33      	ldr	r3, [pc, #204]	; (8020a68 <radar_save_calibration+0x180>)
  /* Fill the calibration buffer with raw ADC data */
  for (uint32_t i = 0; i < ds_device_get_settings()->num_samples_per_chirp; i++)
  {
    adc_i1_calibration[cal_idx] = (adc_temp[0])[i];
    adc_q1_calibration[cal_idx] = (adc_temp[1])[i];
    adc_i2_calibration[cal_idx] = (adc_temp[2])[i];
 802099a:	f820 e002 	strh.w	lr, [r0, r2]
    adc_q2_calibration[cal_idx] = (adc_temp[3])[i];
 802099e:	6818      	ldr	r0, [r3, #0]
 80209a0:	f837 ef02 	ldrh.w	lr, [r7, #2]!
 80209a4:	f820 e002 	strh.w	lr, [r0, r2]
  adc_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 1, 0);
  adc_temp[2] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 2, 0);
  adc_temp[3] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, 0);

  /* Fill the calibration buffer with raw ADC data */
  for (uint32_t i = 0; i < ds_device_get_settings()->num_samples_per_chirp; i++)
 80209a8:	f108 0801 	add.w	r8, r8, #1
 80209ac:	f7ff fb2c 	bl	8020008 <ds_device_get_settings>
 80209b0:	9b00      	ldr	r3, [sp, #0]
 80209b2:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 80209b4:	4499      	add	r9, r3
 80209b6:	9b01      	ldr	r3, [sp, #4]
 80209b8:	4580      	cmp	r8, r0
 80209ba:	eb09 0203 	add.w	r2, r9, r3
 80209be:	d3dc      	bcc.n	802097a <radar_save_calibration+0x92>
    
    cal_idx += interp_factor;
  }
  
  /* Permanently write the calibration data in to the Flash */
  if (target == CALIBRATION_TARGET_FLASH)
 80209c0:	9b03      	ldr	r3, [sp, #12]
 80209c2:	b133      	cbz	r3, 80209d2 <radar_save_calibration+0xea>
    {
      status = radar_get_frame(device, &frame_info, true);
    }
    
    save_adc_calibration(target);
    g_do_processing = true;
 80209c4:	4a26      	ldr	r2, [pc, #152]	; (8020a60 <radar_save_calibration+0x178>)
 80209c6:	2301      	movs	r3, #1
 80209c8:	6013      	str	r3, [r2, #0]
    
    save_algo_calibration(target, (const Algo_Calibrations_t*)calibration_data_ptr);
  }
  
  return (RADAR_ERR_OK);
}
 80209ca:	2000      	movs	r0, #0
 80209cc:	b00d      	add	sp, #52	; 0x34
 80209ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  
  /* Permanently write the calibration data in to the Flash */
  if (target == CALIBRATION_TARGET_FLASH)
  {
    /* Read the flashed algorithm parameters */
    bsp_flash_read_data(ADC_CALIB_LEN_BYTES, (uint8_t*)&algo_calibration_s, sizeof(algo_calibration_s));
 80209d2:	f44f 6000 	mov.w	r0, #2048	; 0x800
 80209d6:	4925      	ldr	r1, [pc, #148]	; (8020a6c <radar_save_calibration+0x184>)
 80209d8:	2204      	movs	r2, #4
 80209da:	f007 fa61 	bl	8027ea0 <bsp_flash_read_data>

//============================================================================

static void write_calibration_flash_data(void)
{
	bsp_flash_write_data(0U, (uint8_t*)adc_i1_calibration, ADC_CALIB_LEN_BYTES);
 80209de:	9803      	ldr	r0, [sp, #12]
 80209e0:	4920      	ldr	r1, [pc, #128]	; (8020a64 <radar_save_calibration+0x17c>)
 80209e2:	f44f 6200 	mov.w	r2, #2048	; 0x800
 80209e6:	f007 fa59 	bl	8027e9c <bsp_flash_write_data>

	bsp_flash_write_data(ADC_CALIB_LEN_BYTES, (uint8_t*)&algo_calibration_s, sizeof(algo_calibration_s));
 80209ea:	f44f 6000 	mov.w	r0, #2048	; 0x800
 80209ee:	491f      	ldr	r1, [pc, #124]	; (8020a6c <radar_save_calibration+0x184>)
 80209f0:	2204      	movs	r2, #4
 80209f2:	f007 fa53 	bl	8027e9c <bsp_flash_write_data>

	bsp_flash_flush_data();
 80209f6:	f007 fa55 	bl	8027ea4 <bsp_flash_flush_data>
 80209fa:	e7e3      	b.n	80209c4 <radar_save_calibration+0xdc>

//============================================================================

static void save_algo_calibration(Calibration_Target_t target, const Algo_Calibrations_t*  algo_calibration_ptr)
{
	algo_calibration_s = *algo_calibration_ptr;
 80209fc:	6818      	ldr	r0, [r3, #0]
 80209fe:	4c1b      	ldr	r4, [pc, #108]	; (8020a6c <radar_save_calibration+0x184>)

	if (target == CALIBRATION_TARGET_FLASH)
 8020a00:	9b03      	ldr	r3, [sp, #12]

//============================================================================

static void save_algo_calibration(Calibration_Target_t target, const Algo_Calibrations_t*  algo_calibration_ptr)
{
	algo_calibration_s = *algo_calibration_ptr;
 8020a02:	6020      	str	r0, [r4, #0]

	if (target == CALIBRATION_TARGET_FLASH)
 8020a04:	b16b      	cbz	r3, 8020a22 <radar_save_calibration+0x13a>
		read_adc_calibration(CALIBRATION_TARGET_FLASH);

		write_calibration_flash_data();
	}

	set_angle_offset(algo_calibration_s.angle_offset_deg);
 8020a06:	8865      	ldrh	r5, [r4, #2]

static void set_angle_offset(int16_t offset)
{
	if ((offset > BSP_MIN_ANGLE_OFFSET_DEG) || (offset < BSP_MAX_ANGLE_OFFSET_DEG))
	{
		ds_algo_get_settings()->angle_offset_deg = offset;
 8020a08:	f7ff fafa 	bl	8020000 <ds_algo_get_settings>

		write_calibration_flash_data();
	}

	set_angle_offset(algo_calibration_s.angle_offset_deg);
	set_range_offset(algo_calibration_s.distance_offset_cm);
 8020a0c:	8824      	ldrh	r4, [r4, #0]

static void set_angle_offset(int16_t offset)
{
	if ((offset > BSP_MIN_ANGLE_OFFSET_DEG) || (offset < BSP_MAX_ANGLE_OFFSET_DEG))
	{
		ds_algo_get_settings()->angle_offset_deg = offset;
 8020a0e:	8505      	strh	r5, [r0, #40]	; 0x28

//============================================================================

static void set_range_offset(uint16_t offset)
{
	if (offset < BSP_MAX_RANGE_OFFSET_CM)
 8020a10:	2c63      	cmp	r4, #99	; 0x63
 8020a12:	d8da      	bhi.n	80209ca <radar_save_calibration+0xe2>
	{
		ds_algo_get_settings()->range_offset_cm = offset;
 8020a14:	f7ff faf4 	bl	8020000 <ds_algo_get_settings>
 8020a18:	6244      	str	r4, [r0, #36]	; 0x24
    
    save_algo_calibration(target, (const Algo_Calibrations_t*)calibration_data_ptr);
  }
  
  return (RADAR_ERR_OK);
}
 8020a1a:	2000      	movs	r0, #0
 8020a1c:	b00d      	add	sp, #52	; 0x34
 8020a1e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
{
	Radar_Handle_t device = NULL;

	if (target == CALIBRATION_TARGET_FLASH)
	{
		if (bsp_flash_is_empty())
 8020a22:	f007 fa41 	bl	8027ea8 <bsp_flash_is_empty>
 8020a26:	b998      	cbnz	r0, 8020a50 <radar_save_calibration+0x168>
			radar_init_calibration(device);
		}
		else
		{
			/* Read calibration stored in flash */
			bsp_flash_read_data(0U, (uint8_t*)adc_i1_calibration, ADC_CALIB_LEN_BYTES);
 8020a28:	490e      	ldr	r1, [pc, #56]	; (8020a64 <radar_save_calibration+0x17c>)
 8020a2a:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8020a2e:	f007 fa37 	bl	8027ea0 <bsp_flash_read_data>

//============================================================================

static void write_calibration_flash_data(void)
{
	bsp_flash_write_data(0U, (uint8_t*)adc_i1_calibration, ADC_CALIB_LEN_BYTES);
 8020a32:	2000      	movs	r0, #0
 8020a34:	490b      	ldr	r1, [pc, #44]	; (8020a64 <radar_save_calibration+0x17c>)
 8020a36:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8020a3a:	f007 fa2f 	bl	8027e9c <bsp_flash_write_data>

	bsp_flash_write_data(ADC_CALIB_LEN_BYTES, (uint8_t*)&algo_calibration_s, sizeof(algo_calibration_s));
 8020a3e:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8020a42:	490a      	ldr	r1, [pc, #40]	; (8020a6c <radar_save_calibration+0x184>)
 8020a44:	2204      	movs	r2, #4
 8020a46:	f007 fa29 	bl	8027e9c <bsp_flash_write_data>

	bsp_flash_flush_data();
 8020a4a:	f007 fa2b 	bl	8027ea4 <bsp_flash_flush_data>
 8020a4e:	e7da      	b.n	8020a06 <radar_save_calibration+0x11e>

void radar_init_calibration(Radar_Handle_t device)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */

  memset(adc_i1_calibration, DEFAULT_CALIBRATION_VALUE, ADC_CALIB_LEN_BYTES);
 8020a50:	9903      	ldr	r1, [sp, #12]
 8020a52:	4804      	ldr	r0, [pc, #16]	; (8020a64 <radar_save_calibration+0x17c>)
 8020a54:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8020a58:	f00a f86d 	bl	802ab36 <memset>
 8020a5c:	e7e9      	b.n	8020a32 <radar_save_calibration+0x14a>
 8020a5e:	bf00      	nop
 8020a60:	1ffe883c 	.word	0x1ffe883c
 8020a64:	1fffa034 	.word	0x1fffa034
 8020a68:	1ffe8838 	.word	0x1ffe8838
 8020a6c:	1ffe8cb8 	.word	0x1ffe8cb8
 8020a70:	1ffe8830 	.word	0x1ffe8830
 8020a74:	1ffe8834 	.word	0x1ffe8834

08020a78 <radar_read_calibration>:
}

//============================================================================

uint16_t radar_read_calibration(Radar_Handle_t device, Calibration_Target_t target, Calibration_Data_t calib_data_type, void** data_ptr, uint16_t* num_of_bytes)
{
 8020a78:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8020a7c:	9f06      	ldr	r7, [sp, #24]
 8020a7e:	460d      	mov	r5, r1
 8020a80:	461e      	mov	r6, r3
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  if (calib_data_type == CALIBRATION_DATA_ADC)
 8020a82:	b19a      	cbz	r2, 8020aac <radar_read_calibration+0x34>

static uint32_t read_algo_calibration(Calibration_Target_t target)
{
	size_t algo_size = sizeof(algo_calibration_s);

	if (target == CALIBRATION_TARGET_FLASH)
 8020a84:	b1d9      	cbz	r1, 8020abe <radar_read_calibration+0x46>
 8020a86:	4c1e      	ldr	r4, [pc, #120]	; (8020b00 <radar_read_calibration+0x88>)
 8020a88:	f8b4 8002 	ldrh.w	r8, [r4, #2]

static void set_angle_offset(int16_t offset)
{
	if ((offset > BSP_MIN_ANGLE_OFFSET_DEG) || (offset < BSP_MAX_ANGLE_OFFSET_DEG))
	{
		ds_algo_get_settings()->angle_offset_deg = offset;
 8020a8c:	f7ff fab8 	bl	8020000 <ds_algo_get_settings>
			bsp_flash_read_data(ADC_CALIB_LEN_BYTES, (uint8_t*)&algo_calibration_s, algo_size);
		}
	}

	set_angle_offset(algo_calibration_s.angle_offset_deg);
	set_range_offset(algo_calibration_s.distance_offset_cm);
 8020a90:	8825      	ldrh	r5, [r4, #0]

static void set_angle_offset(int16_t offset)
{
	if ((offset > BSP_MIN_ANGLE_OFFSET_DEG) || (offset < BSP_MAX_ANGLE_OFFSET_DEG))
	{
		ds_algo_get_settings()->angle_offset_deg = offset;
 8020a92:	f8a0 8028 	strh.w	r8, [r0, #40]	; 0x28

//============================================================================

static void set_range_offset(uint16_t offset)
{
	if (offset < BSP_MAX_RANGE_OFFSET_CM)
 8020a96:	2d63      	cmp	r5, #99	; 0x63
 8020a98:	d802      	bhi.n	8020aa0 <radar_read_calibration+0x28>
	{
		ds_algo_get_settings()->range_offset_cm = offset;
 8020a9a:	f7ff fab1 	bl	8020000 <ds_algo_get_settings>
 8020a9e:	6245      	str	r5, [r0, #36]	; 0x24
    *num_of_bytes = read_adc_calibration(target);
    *data_ptr = adc_i1_calibration;
  }
  else
  {
    *num_of_bytes = read_algo_calibration(target);
 8020aa0:	2304      	movs	r3, #4
 8020aa2:	803b      	strh	r3, [r7, #0]
    *data_ptr = &algo_calibration_s;
  }
  
  return (RADAR_ERR_OK);
}
 8020aa4:	2000      	movs	r0, #0
    *data_ptr = adc_i1_calibration;
  }
  else
  {
    *num_of_bytes = read_algo_calibration(target);
    *data_ptr = &algo_calibration_s;
 8020aa6:	6034      	str	r4, [r6, #0]
  }
  
  return (RADAR_ERR_OK);
}
 8020aa8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

static uint32_t read_adc_calibration(Calibration_Target_t target)
{
	Radar_Handle_t device = NULL;

	if (target == CALIBRATION_TARGET_FLASH)
 8020aac:	b171      	cbz	r1, 8020acc <radar_read_calibration+0x54>
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  if (calib_data_type == CALIBRATION_DATA_ADC)
  {
    *num_of_bytes = read_adc_calibration(target);
 8020aae:	f44f 6200 	mov.w	r2, #2048	; 0x800
    *data_ptr = adc_i1_calibration;
 8020ab2:	4b14      	ldr	r3, [pc, #80]	; (8020b04 <radar_read_calibration+0x8c>)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  if (calib_data_type == CALIBRATION_DATA_ADC)
  {
    *num_of_bytes = read_adc_calibration(target);
 8020ab4:	803a      	strh	r2, [r7, #0]
    *num_of_bytes = read_algo_calibration(target);
    *data_ptr = &algo_calibration_s;
  }
  
  return (RADAR_ERR_OK);
}
 8020ab6:	2000      	movs	r0, #0
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  if (calib_data_type == CALIBRATION_DATA_ADC)
  {
    *num_of_bytes = read_adc_calibration(target);
    *data_ptr = adc_i1_calibration;
 8020ab8:	6033      	str	r3, [r6, #0]
    *num_of_bytes = read_algo_calibration(target);
    *data_ptr = &algo_calibration_s;
  }
  
  return (RADAR_ERR_OK);
}
 8020aba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
{
	size_t algo_size = sizeof(algo_calibration_s);

	if (target == CALIBRATION_TARGET_FLASH)
	{
		if (bsp_flash_is_empty())
 8020abe:	f007 f9f3 	bl	8027ea8 <bsp_flash_is_empty>
		{
			memset(&algo_calibration_s, DEFAULT_CALIBRATION_VALUE, algo_size);
 8020ac2:	4c0f      	ldr	r4, [pc, #60]	; (8020b00 <radar_read_calibration+0x88>)
{
	size_t algo_size = sizeof(algo_calibration_s);

	if (target == CALIBRATION_TARGET_FLASH)
	{
		if (bsp_flash_is_empty())
 8020ac4:	b158      	cbz	r0, 8020ade <radar_read_calibration+0x66>
		{
			memset(&algo_calibration_s, DEFAULT_CALIBRATION_VALUE, algo_size);
 8020ac6:	46a8      	mov	r8, r5
 8020ac8:	6025      	str	r5, [r4, #0]
 8020aca:	e7df      	b.n	8020a8c <radar_read_calibration+0x14>
{
	Radar_Handle_t device = NULL;

	if (target == CALIBRATION_TARGET_FLASH)
	{
		if (bsp_flash_is_empty())
 8020acc:	f007 f9ec 	bl	8027ea8 <bsp_flash_is_empty>
 8020ad0:	b970      	cbnz	r0, 8020af0 <radar_read_calibration+0x78>
			radar_init_calibration(device);
		}
		else
		{
			/* Read calibration stored in flash */
			bsp_flash_read_data(0U, (uint8_t*)adc_i1_calibration, ADC_CALIB_LEN_BYTES);
 8020ad2:	490c      	ldr	r1, [pc, #48]	; (8020b04 <radar_read_calibration+0x8c>)
 8020ad4:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8020ad8:	f007 f9e2 	bl	8027ea0 <bsp_flash_read_data>
 8020adc:	e7e7      	b.n	8020aae <radar_read_calibration+0x36>
		{
			memset(&algo_calibration_s, DEFAULT_CALIBRATION_VALUE, algo_size);
		}
		else
		{
			bsp_flash_read_data(ADC_CALIB_LEN_BYTES, (uint8_t*)&algo_calibration_s, algo_size);
 8020ade:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8020ae2:	4621      	mov	r1, r4
 8020ae4:	2204      	movs	r2, #4
 8020ae6:	f007 f9db 	bl	8027ea0 <bsp_flash_read_data>
 8020aea:	f8b4 8002 	ldrh.w	r8, [r4, #2]
 8020aee:	e7cd      	b.n	8020a8c <radar_read_calibration+0x14>

void radar_init_calibration(Radar_Handle_t device)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */

  memset(adc_i1_calibration, DEFAULT_CALIBRATION_VALUE, ADC_CALIB_LEN_BYTES);
 8020af0:	4629      	mov	r1, r5
 8020af2:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8020af6:	4803      	ldr	r0, [pc, #12]	; (8020b04 <radar_read_calibration+0x8c>)
 8020af8:	f00a f81d 	bl	802ab36 <memset>
 8020afc:	e7d7      	b.n	8020aae <radar_read_calibration+0x36>
 8020afe:	bf00      	nop
 8020b00:	1ffe8cb8 	.word	0x1ffe8cb8
 8020b04:	1fffa034 	.word	0x1fffa034

08020b08 <radar_clear_calibration>:
}

//============================================================================

uint16_t radar_clear_calibration(Radar_Handle_t device, Calibration_Target_t target, Calibration_Data_t calib_data_type)
{
 8020b08:	b538      	push	{r3, r4, r5, lr}
 8020b0a:	460c      	mov	r4, r1
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  if (calib_data_type == CALIBRATION_DATA_ADC)
 8020b0c:	b17a      	cbz	r2, 8020b2e <radar_clear_calibration+0x26>

//============================================================================

static void clear_algo_calibration(Calibration_Target_t target)
{
	memset(&algo_calibration_s, 0, sizeof(algo_calibration_s));
 8020b0e:	4d26      	ldr	r5, [pc, #152]	; (8020ba8 <radar_clear_calibration+0xa0>)
 8020b10:	2300      	movs	r3, #0
 8020b12:	602b      	str	r3, [r5, #0]

	if (target == CALIBRATION_TARGET_FLASH)
 8020b14:	b349      	cbz	r1, 8020b6a <radar_clear_calibration+0x62>
 8020b16:	461c      	mov	r4, r3

static void set_angle_offset(int16_t offset)
{
	if ((offset > BSP_MIN_ANGLE_OFFSET_DEG) || (offset < BSP_MAX_ANGLE_OFFSET_DEG))
	{
		ds_algo_get_settings()->angle_offset_deg = offset;
 8020b18:	f7ff fa72 	bl	8020000 <ds_algo_get_settings>

		write_calibration_flash_data();
	}

	set_angle_offset(algo_calibration_s.angle_offset_deg);
	set_range_offset(algo_calibration_s.distance_offset_cm);
 8020b1c:	882d      	ldrh	r5, [r5, #0]

static void set_angle_offset(int16_t offset)
{
	if ((offset > BSP_MIN_ANGLE_OFFSET_DEG) || (offset < BSP_MAX_ANGLE_OFFSET_DEG))
	{
		ds_algo_get_settings()->angle_offset_deg = offset;
 8020b1e:	8504      	strh	r4, [r0, #40]	; 0x28

//============================================================================

static void set_range_offset(uint16_t offset)
{
	if (offset < BSP_MAX_RANGE_OFFSET_CM)
 8020b20:	2d63      	cmp	r5, #99	; 0x63
 8020b22:	d802      	bhi.n	8020b2a <radar_clear_calibration+0x22>
	{
		ds_algo_get_settings()->range_offset_cm = offset;
 8020b24:	f7ff fa6c 	bl	8020000 <ds_algo_get_settings>
 8020b28:	6245      	str	r5, [r0, #36]	; 0x24
  {
    clear_algo_calibration(target);
  }
  
  return (RADAR_ERR_OK);
}
 8020b2a:	2000      	movs	r0, #0
 8020b2c:	bd38      	pop	{r3, r4, r5, pc}

void radar_init_calibration(Radar_Handle_t device)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */

  memset(adc_i1_calibration, DEFAULT_CALIBRATION_VALUE, ADC_CALIB_LEN_BYTES);
 8020b2e:	4611      	mov	r1, r2
 8020b30:	481e      	ldr	r0, [pc, #120]	; (8020bac <radar_clear_calibration+0xa4>)
 8020b32:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8020b36:	f009 fffe 	bl	802ab36 <memset>
  Radar_Handle_t device = NULL;
  
  /* Reset SRAM buffer to a default value */
  radar_init_calibration(device);
  
  if (target == CALIBRATION_TARGET_FLASH)
 8020b3a:	2c00      	cmp	r4, #0
 8020b3c:	d1f5      	bne.n	8020b2a <radar_clear_calibration+0x22>
  {
    bsp_flash_read_data(ADC_CALIB_LEN_BYTES, (uint8_t*)&algo_calibration_s, sizeof(algo_calibration_s));
 8020b3e:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8020b42:	4919      	ldr	r1, [pc, #100]	; (8020ba8 <radar_clear_calibration+0xa0>)
 8020b44:	2204      	movs	r2, #4
 8020b46:	f007 f9ab 	bl	8027ea0 <bsp_flash_read_data>

//============================================================================

static void write_calibration_flash_data(void)
{
	bsp_flash_write_data(0U, (uint8_t*)adc_i1_calibration, ADC_CALIB_LEN_BYTES);
 8020b4a:	4620      	mov	r0, r4
 8020b4c:	4917      	ldr	r1, [pc, #92]	; (8020bac <radar_clear_calibration+0xa4>)
 8020b4e:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8020b52:	f007 f9a3 	bl	8027e9c <bsp_flash_write_data>

	bsp_flash_write_data(ADC_CALIB_LEN_BYTES, (uint8_t*)&algo_calibration_s, sizeof(algo_calibration_s));
 8020b56:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8020b5a:	4913      	ldr	r1, [pc, #76]	; (8020ba8 <radar_clear_calibration+0xa0>)
 8020b5c:	2204      	movs	r2, #4
 8020b5e:	f007 f99d 	bl	8027e9c <bsp_flash_write_data>

	bsp_flash_flush_data();
 8020b62:	f007 f99f 	bl	8027ea4 <bsp_flash_flush_data>
  {
    clear_algo_calibration(target);
  }
  
  return (RADAR_ERR_OK);
}
 8020b66:	2000      	movs	r0, #0
 8020b68:	bd38      	pop	{r3, r4, r5, pc}
{
	Radar_Handle_t device = NULL;

	if (target == CALIBRATION_TARGET_FLASH)
	{
		if (bsp_flash_is_empty())
 8020b6a:	f007 f99d 	bl	8027ea8 <bsp_flash_is_empty>
 8020b6e:	b9a0      	cbnz	r0, 8020b9a <radar_clear_calibration+0x92>
			radar_init_calibration(device);
		}
		else
		{
			/* Read calibration stored in flash */
			bsp_flash_read_data(0U, (uint8_t*)adc_i1_calibration, ADC_CALIB_LEN_BYTES);
 8020b70:	490e      	ldr	r1, [pc, #56]	; (8020bac <radar_clear_calibration+0xa4>)
 8020b72:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8020b76:	f007 f993 	bl	8027ea0 <bsp_flash_read_data>

//============================================================================

static void write_calibration_flash_data(void)
{
	bsp_flash_write_data(0U, (uint8_t*)adc_i1_calibration, ADC_CALIB_LEN_BYTES);
 8020b7a:	2000      	movs	r0, #0
 8020b7c:	490b      	ldr	r1, [pc, #44]	; (8020bac <radar_clear_calibration+0xa4>)
 8020b7e:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8020b82:	f007 f98b 	bl	8027e9c <bsp_flash_write_data>

	bsp_flash_write_data(ADC_CALIB_LEN_BYTES, (uint8_t*)&algo_calibration_s, sizeof(algo_calibration_s));
 8020b86:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8020b8a:	4907      	ldr	r1, [pc, #28]	; (8020ba8 <radar_clear_calibration+0xa0>)
 8020b8c:	2204      	movs	r2, #4
 8020b8e:	f007 f985 	bl	8027e9c <bsp_flash_write_data>

	bsp_flash_flush_data();
 8020b92:	f007 f987 	bl	8027ea4 <bsp_flash_flush_data>
 8020b96:	886c      	ldrh	r4, [r5, #2]
 8020b98:	e7be      	b.n	8020b18 <radar_clear_calibration+0x10>

void radar_init_calibration(Radar_Handle_t device)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */

  memset(adc_i1_calibration, DEFAULT_CALIBRATION_VALUE, ADC_CALIB_LEN_BYTES);
 8020b9a:	4621      	mov	r1, r4
 8020b9c:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8020ba0:	4802      	ldr	r0, [pc, #8]	; (8020bac <radar_clear_calibration+0xa4>)
 8020ba2:	f009 ffc8 	bl	802ab36 <memset>
 8020ba6:	e7e8      	b.n	8020b7a <radar_clear_calibration+0x72>
 8020ba8:	1ffe8cb8 	.word	0x1ffe8cb8
 8020bac:	1fffa034 	.word	0x1fffa034

08020bb0 <radar_apply_new_hw_setting.isra.1>:
  return (status);
}

//============================================================================

static uint32_t radar_apply_new_hw_setting(Radar_Handle_t device, device_settings_t *p_new)
 8020bb0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8020bb2:	ed2d 8b04 	vpush	{d8-d9}
 8020bb6:	4604      	mov	r4, r0
 8020bb8:	b095      	sub	sp, #84	; 0x54
{
  bsp_components_power_down();
 8020bba:	f007 f947 	bl	8027e4c <bsp_components_power_down>
  
  device_settings_t *p_curr = ds_device_get_shadow_settings();
 8020bbe:	f7ff fa27 	bl	8020010 <ds_device_get_shadow_settings>
  
  /* Set BGT RX LNA gain */
  if (p_new->bgt_rx_lna_gain_enable_flag == true)
 8020bc2:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
 8020bc6:	2b01      	cmp	r3, #1

static uint32_t radar_apply_new_hw_setting(Radar_Handle_t device, device_settings_t *p_new)
{
  bsp_components_power_down();
  
  device_settings_t *p_curr = ds_device_get_shadow_settings();
 8020bc8:	4605      	mov	r5, r0
  
  /* Set BGT RX LNA gain */
  if (p_new->bgt_rx_lna_gain_enable_flag == true)
 8020bca:	d059      	beq.n	8020c80 <radar_apply_new_hw_setting.isra.1+0xd0>
  {
    bgt_lna_gain_enable();
  }
  else
  {
    bgt_lna_gain_disable();
 8020bcc:	f006 ff0a 	bl	80279e4 <bgt_lna_gain_disable>
  }
  
  if (p_curr->pll_chirp_time_usec != p_new->pll_chirp_time_usec || (p_curr->num_samples_per_chirp != p_new->num_samples_per_chirp))
 8020bd0:	682a      	ldr	r2, [r5, #0]
 8020bd2:	6823      	ldr	r3, [r4, #0]
 8020bd4:	429a      	cmp	r2, r3
 8020bd6:	d04a      	beq.n	8020c6e <radar_apply_new_hw_setting.isra.1+0xbe>
  {
    if (ds_device_get_settings()->pll_modulation_mode == MODULATION_FMCW)
 8020bd8:	f7ff fa16 	bl	8020008 <ds_device_get_settings>
 8020bdc:	6986      	ldr	r6, [r0, #24]
 8020bde:	2e01      	cmp	r6, #1
 8020be0:	f000 80b5 	beq.w	8020d4e <radar_apply_new_hw_setting.isra.1+0x19e>
        return (RADAR_ERR_PARAMETER_OUT_OF_RANGE);
      }
	}
  }
  
  if (p_curr->pll_num_of_chirps_per_frame != p_new->pll_num_of_chirps_per_frame)
 8020be4:	6960      	ldr	r0, [r4, #20]
 8020be6:	696b      	ldr	r3, [r5, #20]
 8020be8:	4283      	cmp	r3, r0
 8020bea:	d004      	beq.n	8020bf6 <radar_apply_new_hw_setting.isra.1+0x46>
  {
    /* Update the number of chirps count per frame */
    bsp_set_num_chirps_per_frame(p_new->pll_num_of_chirps_per_frame);
 8020bec:	f007 fc02 	bl	80283f4 <bsp_set_num_chirps_per_frame>
    pll_set_update_config_flag(true);
 8020bf0:	2001      	movs	r0, #1
 8020bf2:	f007 fded 	bl	80287d0 <pll_set_update_config_flag>
  }
  
  if (p_curr->num_samples_per_chirp != p_new->num_samples_per_chirp)
 8020bf6:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8020bf8:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8020bfa:	4283      	cmp	r3, r0
 8020bfc:	d001      	beq.n	8020c02 <radar_apply_new_hw_setting.isra.1+0x52>
  {
    bsp_set_num_samples_per_dma_transfer(p_new->num_samples_per_chirp);
 8020bfe:	f007 fbf3 	bl	80283e8 <bsp_set_num_samples_per_dma_transfer>
  }
  
  if (p_new->isUpdated_doppler_config)
 8020c02:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8020c04:	2b00      	cmp	r3, #0
 8020c06:	f040 8083 	bne.w	8020d10 <radar_apply_new_hw_setting.isra.1+0x160>
    }
    
    p_new->isUpdated_doppler_config = 0;
  }
  
  if(p_new->isUpdated_fmcw_config)
 8020c0a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8020c0c:	2b00      	cmp	r3, #0
 8020c0e:	d13a      	bne.n	8020c86 <radar_apply_new_hw_setting.isra.1+0xd6>
    
    p_new->isUpdated_fmcw_config = 0;
  }

  /* Set the Radar duty cycle */
  if(p_new->is_duty_cycle_enable_updated)
 8020c10:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8020c12:	2b00      	cmp	r3, #0
 8020c14:	d175      	bne.n	8020d02 <radar_apply_new_hw_setting.isra.1+0x152>
  {
    bsp_set_duty_cycle_enable_flag(p_new->power_duty_cycle_enable_flag);
    p_new->is_duty_cycle_enable_updated = 0;
  }

  if ((p_curr->pll_num_of_chirps_per_frame != p_new->pll_num_of_chirps_per_frame) || (p_curr->num_samples_per_chirp != p_new->num_samples_per_chirp))
 8020c16:	696a      	ldr	r2, [r5, #20]
 8020c18:	6963      	ldr	r3, [r4, #20]
 8020c1a:	429a      	cmp	r2, r3
 8020c1c:	d022      	beq.n	8020c64 <radar_apply_new_hw_setting.isra.1+0xb4>
  {
    /* Recreate acq-buffer object! */
    /* The buffer is statically allocated to the max supported buffer size, so it is save to re-use it!
     * checks should have been applied earlier! */
    acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 8020c1e:	f7ff fa5d 	bl	80200dc <ds_get_active_acq_buf>
    
    uint8_t *p_temp_buf = p_acq_buf->p_acq_buf;
    uint32_t reserved_size = p_acq_buf->internals.size_of_acq_buffer;

    acq_buf_obj acq_buf = create_acq_data_buffer_obj(p_temp_buf, reserved_size,
 8020c22:	ae08      	add	r6, sp, #32
 8020c24:	8aa3      	ldrh	r3, [r4, #20]
 8020c26:	6a81      	ldr	r1, [r0, #40]	; 0x28
 8020c28:	68c2      	ldr	r2, [r0, #12]
 8020c2a:	8da0      	ldrh	r0, [r4, #44]	; 0x2c
 8020c2c:	9000      	str	r0, [sp, #0]
 8020c2e:	2402      	movs	r4, #2
 8020c30:	250c      	movs	r5, #12
 8020c32:	4630      	mov	r0, r6
 8020c34:	9401      	str	r4, [sp, #4]
 8020c36:	9402      	str	r4, [sp, #8]
 8020c38:	9503      	str	r5, [sp, #12]
                                                     p_new->pll_num_of_chirps_per_frame,
                                                     p_new->num_samples_per_chirp, 2, 2, 12);  // 2 --> 2 I channels and two Q-channels, from two RX-antennas, 12-bit ADC resolution
    
    ds_set_active_acq_buf(acq_buf);
 8020c3a:	ad0c      	add	r5, sp, #48	; 0x30
    acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
    
    uint8_t *p_temp_buf = p_acq_buf->p_acq_buf;
    uint32_t reserved_size = p_acq_buf->internals.size_of_acq_buffer;

    acq_buf_obj acq_buf = create_acq_data_buffer_obj(p_temp_buf, reserved_size,
 8020c3c:	f7ff fb66 	bl	802030c <create_acq_data_buffer_obj>
                                                     p_new->pll_num_of_chirps_per_frame,
                                                     p_new->num_samples_per_chirp, 2, 2, 12);  // 2 --> 2 I channels and two Q-channels, from two RX-antennas, 12-bit ADC resolution
    
    ds_set_active_acq_buf(acq_buf);
 8020c40:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020c42:	466c      	mov	r4, sp
 8020c44:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8020c46:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8020c4a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 8020c4e:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
 8020c52:	f7ff fa47 	bl	80200e4 <ds_set_active_acq_buf>
  }
  
  bsp_components_power_up();
 8020c56:	f007 f84b 	bl	8027cf0 <bsp_components_power_up>
  
  return 0; // confirm that everything was o.k.
 8020c5a:	2000      	movs	r0, #0
}
 8020c5c:	b015      	add	sp, #84	; 0x54
 8020c5e:	ecbd 8b04 	vpop	{d8-d9}
 8020c62:	bdf0      	pop	{r4, r5, r6, r7, pc}
  {
    bsp_set_duty_cycle_enable_flag(p_new->power_duty_cycle_enable_flag);
    p_new->is_duty_cycle_enable_updated = 0;
  }

  if ((p_curr->pll_num_of_chirps_per_frame != p_new->pll_num_of_chirps_per_frame) || (p_curr->num_samples_per_chirp != p_new->num_samples_per_chirp))
 8020c64:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8020c66:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8020c68:	429a      	cmp	r2, r3
 8020c6a:	d1d8      	bne.n	8020c1e <radar_apply_new_hw_setting.isra.1+0x6e>
 8020c6c:	e7f3      	b.n	8020c56 <radar_apply_new_hw_setting.isra.1+0xa6>
  else
  {
    bgt_lna_gain_disable();
  }
  
  if (p_curr->pll_chirp_time_usec != p_new->pll_chirp_time_usec || (p_curr->num_samples_per_chirp != p_new->num_samples_per_chirp))
 8020c6e:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8020c70:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8020c72:	429a      	cmp	r2, r3
 8020c74:	d1b0      	bne.n	8020bd8 <radar_apply_new_hw_setting.isra.1+0x28>
        return (RADAR_ERR_PARAMETER_OUT_OF_RANGE);
      }
	}
  }
  
  if (p_curr->pll_num_of_chirps_per_frame != p_new->pll_num_of_chirps_per_frame)
 8020c76:	6960      	ldr	r0, [r4, #20]
 8020c78:	696b      	ldr	r3, [r5, #20]
 8020c7a:	4283      	cmp	r3, r0
 8020c7c:	d1b6      	bne.n	8020bec <radar_apply_new_hw_setting.isra.1+0x3c>
 8020c7e:	e7c0      	b.n	8020c02 <radar_apply_new_hw_setting.isra.1+0x52>
  device_settings_t *p_curr = ds_device_get_shadow_settings();
  
  /* Set BGT RX LNA gain */
  if (p_new->bgt_rx_lna_gain_enable_flag == true)
  {
    bgt_lna_gain_enable();
 8020c80:	f006 feae 	bl	80279e0 <bgt_lna_gain_enable>
 8020c84:	e7a4      	b.n	8020bd0 <radar_apply_new_hw_setting.isra.1+0x20>
    float bandwidth_mhz;
    float pll_base_frequency_mhz;

    /* Apply RF configuration */
    /* ---------------------- */
    bandwidth_mhz = ((float)(p_new->pll_upper_frequency_kHz - p_new->pll_lower_frequency_kHz)) / 1000.0f;
 8020c86:	ed94 9a03 	vldr	s18, [r4, #12]
 8020c8a:	ed94 8a02 	vldr	s16, [r4, #8]
 8020c8e:	eddf 8a45 	vldr	s17, [pc, #276]	; 8020da4 <radar_apply_new_hw_setting.isra.1+0x1f4>
 8020c92:	ee39 8a48 	vsub.f32	s16, s18, s16
    
    pll_base_frequency_mhz = (float)(p_new->pll_upper_frequency_kHz) / 1000.0f;
    
    // This is redundant, but we leave it for now, needs to be tested!
    ds_device_get_settings()->pll_bandwidth_MHz = bandwidth_mhz;
 8020c96:	f7ff f9b7 	bl	8020008 <ds_device_get_settings>
    float bandwidth_mhz;
    float pll_base_frequency_mhz;

    /* Apply RF configuration */
    /* ---------------------- */
    bandwidth_mhz = ((float)(p_new->pll_upper_frequency_kHz - p_new->pll_lower_frequency_kHz)) / 1000.0f;
 8020c9a:	ee88 8a28 	vdiv.f32	s16, s16, s17
    pll_base_frequency_mhz = (float)(p_new->pll_upper_frequency_kHz) / 1000.0f;
    
    // This is redundant, but we leave it for now, needs to be tested!
    ds_device_get_settings()->pll_bandwidth_MHz = bandwidth_mhz;
    
    pll_set_frequency(pll_base_frequency_mhz);
 8020c9e:	eec9 7a28 	vdiv.f32	s15, s18, s17
    bandwidth_mhz = ((float)(p_new->pll_upper_frequency_kHz - p_new->pll_lower_frequency_kHz)) / 1000.0f;
    
    pll_base_frequency_mhz = (float)(p_new->pll_upper_frequency_kHz) / 1000.0f;
    
    // This is redundant, but we leave it for now, needs to be tested!
    ds_device_get_settings()->pll_bandwidth_MHz = bandwidth_mhz;
 8020ca2:	ed80 8a04 	vstr	s16, [r0, #16]
    
    pll_set_frequency(pll_base_frequency_mhz);
 8020ca6:	ee17 0a90 	vmov	r0, s15
 8020caa:	f009 f86f 	bl	8029d8c <__aeabi_f2d>
 8020cae:	f007 fd9f 	bl	80287f0 <pll_set_frequency>
    pll_set_bandwidth(bandwidth_mhz);
 8020cb2:	ee18 0a10 	vmov	r0, s16
 8020cb6:	f007 fe09 	bl	80288cc <pll_set_bandwidth>
    pll_set_upper_lower_frequency(p_new->pll_lower_frequency_kHz / 1000.0f, p_new->pll_upper_frequency_kHz / 1000.0f);
 8020cba:	edd4 7a02 	vldr	s15, [r4, #8]
 8020cbe:	eec7 7aa8 	vdiv.f32	s15, s15, s17
 8020cc2:	ee17 0a90 	vmov	r0, s15
 8020cc6:	f009 f861 	bl	8029d8c <__aeabi_f2d>
 8020cca:	edd4 7a03 	vldr	s15, [r4, #12]
 8020cce:	eec7 7aa8 	vdiv.f32	s15, s15, s17
 8020cd2:	4606      	mov	r6, r0
 8020cd4:	460f      	mov	r7, r1
 8020cd6:	ee17 0a90 	vmov	r0, s15
 8020cda:	f009 f857 	bl	8029d8c <__aeabi_f2d>
 8020cde:	460b      	mov	r3, r1
 8020ce0:	4602      	mov	r2, r0
 8020ce2:	4639      	mov	r1, r7
 8020ce4:	4630      	mov	r0, r6
 8020ce6:	f007 fdb3 	bl	8028850 <pll_set_upper_lower_frequency>
    pll_set_update_config_flag(true);
 8020cea:	2001      	movs	r0, #1
 8020cec:	f007 fd70 	bl	80287d0 <pll_set_update_config_flag>
    
    bgt_set_tx_power(p_new->bgt_tx_power_level);
 8020cf0:	f894 0025 	ldrb.w	r0, [r4, #37]	; 0x25
 8020cf4:	f006 fe72 	bl	80279dc <bgt_set_tx_power>
    
    p_new->isUpdated_fmcw_config = 0;
 8020cf8:	2300      	movs	r3, #0
 8020cfa:	63e3      	str	r3, [r4, #60]	; 0x3c
  }

  /* Set the Radar duty cycle */
  if(p_new->is_duty_cycle_enable_updated)
 8020cfc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8020cfe:	2b00      	cmp	r3, #0
 8020d00:	d089      	beq.n	8020c16 <radar_apply_new_hw_setting.isra.1+0x66>
  {
    bsp_set_duty_cycle_enable_flag(p_new->power_duty_cycle_enable_flag);
 8020d02:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
 8020d06:	f007 fb83 	bl	8028410 <bsp_set_duty_cycle_enable_flag>
    p_new->is_duty_cycle_enable_updated = 0;
 8020d0a:	2300      	movs	r3, #0
 8020d0c:	63a3      	str	r3, [r4, #56]	; 0x38
 8020d0e:	e782      	b.n	8020c16 <radar_apply_new_hw_setting.isra.1+0x66>
  {
    float freq_MHz;
    
    /* Apply RF configuration */
    /* ---------------------- */
    bgt_set_tx_power(p_new->bgt_tx_power_level);
 8020d10:	f894 0025 	ldrb.w	r0, [r4, #37]	; 0x25
 8020d14:	f006 fe62 	bl	80279dc <bgt_set_tx_power>
    
    freq_MHz = (float)(p_new->pll_frequency_kHz / 1000.0f); // to bring into the MHz
 8020d18:	ed94 8a01 	vldr	s16, [r4, #4]
    
    if (ds_device_get_settings()->pll_modulation_mode == MODULATION_DOPPLER)
 8020d1c:	f7ff f974 	bl	8020008 <ds_device_get_settings>
 8020d20:	6983      	ldr	r3, [r0, #24]
 8020d22:	b98b      	cbnz	r3, 8020d48 <radar_apply_new_hw_setting.isra.1+0x198>
    
    /* Apply RF configuration */
    /* ---------------------- */
    bgt_set_tx_power(p_new->bgt_tx_power_level);
    
    freq_MHz = (float)(p_new->pll_frequency_kHz / 1000.0f); // to bring into the MHz
 8020d24:	ed9f 7a1f 	vldr	s14, [pc, #124]	; 8020da4 <radar_apply_new_hw_setting.isra.1+0x1f4>
//============================================================================
uint16_t radar_set_pll_frequency(Radar_Handle_t device, float freq_MHz)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  if ((freq_MHz >= BSP_MIN_RF_FREQUENCY_KHZ/1000.0f) && (freq_MHz <= BSP_MAX_RF_FREQUENCY_KHZ/1000.0f))
 8020d28:	eddf 7a1f 	vldr	s15, [pc, #124]	; 8020da8 <radar_apply_new_hw_setting.isra.1+0x1f8>
    
    /* Apply RF configuration */
    /* ---------------------- */
    bgt_set_tx_power(p_new->bgt_tx_power_level);
    
    freq_MHz = (float)(p_new->pll_frequency_kHz / 1000.0f); // to bring into the MHz
 8020d2c:	ee88 8a07 	vdiv.f32	s16, s16, s14
//============================================================================
uint16_t radar_set_pll_frequency(Radar_Handle_t device, float freq_MHz)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  if ((freq_MHz >= BSP_MIN_RF_FREQUENCY_KHZ/1000.0f) && (freq_MHz <= BSP_MAX_RF_FREQUENCY_KHZ/1000.0f))
 8020d30:	eeb4 8ae7 	vcmpe.f32	s16, s15
 8020d34:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020d38:	db06      	blt.n	8020d48 <radar_apply_new_hw_setting.isra.1+0x198>
 8020d3a:	eddf 7a1c 	vldr	s15, [pc, #112]	; 8020dac <radar_apply_new_hw_setting.isra.1+0x1fc>
 8020d3e:	eeb4 8ae7 	vcmpe.f32	s16, s15
 8020d42:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020d46:	d922      	bls.n	8020d8e <radar_apply_new_hw_setting.isra.1+0x1de>
    if (ds_device_get_settings()->pll_modulation_mode == MODULATION_DOPPLER)
    {
      radar_set_pll_frequency(device, freq_MHz);
    }
    
    p_new->isUpdated_doppler_config = 0;
 8020d48:	2300      	movs	r3, #0
 8020d4a:	6423      	str	r3, [r4, #64]	; 0x40
 8020d4c:	e75d      	b.n	8020c0a <radar_apply_new_hw_setting.isra.1+0x5a>
  
  if (p_curr->pll_chirp_time_usec != p_new->pll_chirp_time_usec || (p_curr->num_samples_per_chirp != p_new->num_samples_per_chirp))
  {
    if (ds_device_get_settings()->pll_modulation_mode == MODULATION_FMCW)
	{
      pll_set_chirp_time(p_new->pll_chirp_time_usec);
 8020d4e:	6820      	ldr	r0, [r4, #0]
 8020d50:	f007 fdc2 	bl	80288d8 <pll_set_chirp_time>
      pll_set_update_config_flag(true);
 8020d54:	4630      	mov	r0, r6
 8020d56:	f007 fd3b 	bl	80287d0 <pll_set_update_config_flag>
    
      uint32_t sampling_period_usec = (uint32_t)(((float) p_new->pll_chirp_time_usec * 100.0f) / (float)p_new->num_samples_per_chirp);
 8020d5a:	ed94 7a00 	vldr	s14, [r4]
 8020d5e:	eddf 7a14 	vldr	s15, [pc, #80]	; 8020db0 <radar_apply_new_hw_setting.isra.1+0x200>
 8020d62:	edd4 6a0b 	vldr	s13, [r4, #44]	; 0x2c

      if (TIMER_SetTimeInterval(&TIMER_ADC_TRIG, sampling_period_usec) != TIMER_STATUS_SUCCESS)
 8020d66:	4813      	ldr	r0, [pc, #76]	; (8020db4 <radar_apply_new_hw_setting.isra.1+0x204>)
    if (ds_device_get_settings()->pll_modulation_mode == MODULATION_FMCW)
	{
      pll_set_chirp_time(p_new->pll_chirp_time_usec);
      pll_set_update_config_flag(true);
    
      uint32_t sampling_period_usec = (uint32_t)(((float) p_new->pll_chirp_time_usec * 100.0f) / (float)p_new->num_samples_per_chirp);
 8020d68:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 8020d6c:	eef8 6a66 	vcvt.f32.u32	s13, s13
 8020d70:	ee67 7a27 	vmul.f32	s15, s14, s15
 8020d74:	eec7 7aa6 	vdiv.f32	s15, s15, s13

      if (TIMER_SetTimeInterval(&TIMER_ADC_TRIG, sampling_period_usec) != TIMER_STATUS_SUCCESS)
 8020d78:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8020d7c:	ee17 1a90 	vmov	r1, s15
 8020d80:	f005 fae6 	bl	8026350 <TIMER_SetTimeInterval>
 8020d84:	2800      	cmp	r0, #0
 8020d86:	f43f af2d 	beq.w	8020be4 <radar_apply_new_hw_setting.isra.1+0x34>
      {
        return (RADAR_ERR_PARAMETER_OUT_OF_RANGE);
 8020d8a:	200c      	movs	r0, #12
 8020d8c:	e766      	b.n	8020c5c <radar_apply_new_hw_setting.isra.1+0xac>
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  if ((freq_MHz >= BSP_MIN_RF_FREQUENCY_KHZ/1000.0f) && (freq_MHz <= BSP_MAX_RF_FREQUENCY_KHZ/1000.0f))
  {
    pll_set_frequency(freq_MHz);
 8020d8e:	ee18 0a10 	vmov	r0, s16
 8020d92:	f008 fffb 	bl	8029d8c <__aeabi_f2d>
 8020d96:	f007 fd2b 	bl	80287f0 <pll_set_frequency>
    pll_set_update_config_flag(true);
 8020d9a:	2001      	movs	r0, #1
 8020d9c:	f007 fd18 	bl	80287d0 <pll_set_update_config_flag>
 8020da0:	e7d2      	b.n	8020d48 <radar_apply_new_hw_setting.isra.1+0x198>
 8020da2:	bf00      	nop
 8020da4:	447a0000 	.word	0x447a0000
 8020da8:	46bbb200 	.word	0x46bbb200
 8020dac:	46bd4200 	.word	0x46bd4200
 8020db0:	42c80000 	.word	0x42c80000
 8020db4:	1ffe8b18 	.word	0x1ffe8b18

08020db8 <radar_init>:
    3. EXPORTED FUNCTIONS
==============================================================================
 */

uint16_t radar_init(Radar_Handle_t device)
{
 8020db8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8020dbc:	ed2d 8b02 	vpush	{d8}
 8020dc0:	b085      	sub	sp, #20
  uint16_t status = RADAR_ERR_BUSY;
  uint16_t num_of_bytes;
  void* calibration_data_ptr = NULL;
 8020dc2:	2400      	movs	r4, #0
    3. EXPORTED FUNCTIONS
==============================================================================
 */

uint16_t radar_init(Radar_Handle_t device)
{
 8020dc4:	4606      	mov	r6, r0
  uint16_t status = RADAR_ERR_BUSY;
  uint16_t num_of_bytes;
  void* calibration_data_ptr = NULL;
 8020dc6:	9403      	str	r4, [sp, #12]
  
  /* PLL parameters setup */
  /* -------------------- */
  float temp_pll_lower_freq_MHz = ds_device_get_settings()->pll_lower_frequency_kHz / 1000.0f;
 8020dc8:	f7ff f91e 	bl	8020008 <ds_device_get_settings>
 8020dcc:	edd0 8a02 	vldr	s17, [r0, #8]
 8020dd0:	ed9f 8a4d 	vldr	s16, [pc, #308]	; 8020f08 <radar_init+0x150>
  float temp_pll_upper_freq_MHz = ds_device_get_settings()->pll_upper_frequency_kHz / 1000.0f;
 8020dd4:	f7ff f918 	bl	8020008 <ds_device_get_settings>
 8020dd8:	edd0 7a03 	vldr	s15, [r0, #12]
  uint16_t num_of_bytes;
  void* calibration_data_ptr = NULL;
  
  /* PLL parameters setup */
  /* -------------------- */
  float temp_pll_lower_freq_MHz = ds_device_get_settings()->pll_lower_frequency_kHz / 1000.0f;
 8020ddc:	eec8 8a88 	vdiv.f32	s17, s17, s16
  /* Set PLL upper and lower frequencies for FMCW modulation */
  pll_set_upper_lower_frequency(temp_pll_lower_freq_MHz, temp_pll_upper_freq_MHz);
  
#if FW_MODULATION_TYPE == 1U
  
  ds_device_get_settings()->pll_modulation_mode = MODULATION_FMCW;
 8020de0:	2501      	movs	r5, #1
  void* calibration_data_ptr = NULL;
  
  /* PLL parameters setup */
  /* -------------------- */
  float temp_pll_lower_freq_MHz = ds_device_get_settings()->pll_lower_frequency_kHz / 1000.0f;
  float temp_pll_upper_freq_MHz = ds_device_get_settings()->pll_upper_frequency_kHz / 1000.0f;
 8020de2:	ee87 8a88 	vdiv.f32	s16, s15, s16
  
  /* Set PLL upper and lower frequencies for FMCW modulation */
  pll_set_upper_lower_frequency(temp_pll_lower_freq_MHz, temp_pll_upper_freq_MHz);
 8020de6:	ee18 0a10 	vmov	r0, s16
 8020dea:	f008 ffcf 	bl	8029d8c <__aeabi_f2d>
 8020dee:	4680      	mov	r8, r0
 8020df0:	4689      	mov	r9, r1
 8020df2:	ee18 0a90 	vmov	r0, s17
 8020df6:	f008 ffc9 	bl	8029d8c <__aeabi_f2d>
 8020dfa:	4642      	mov	r2, r8
 8020dfc:	464b      	mov	r3, r9
 8020dfe:	f007 fd27 	bl	8028850 <pll_set_upper_lower_frequency>
  
#if FW_MODULATION_TYPE == 1U
  
  ds_device_get_settings()->pll_modulation_mode = MODULATION_FMCW;
 8020e02:	f7ff f901 	bl	8020008 <ds_device_get_settings>
//============================================================================
uint16_t radar_set_pll_frequency(Radar_Handle_t device, float freq_MHz)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  if ((freq_MHz >= BSP_MIN_RF_FREQUENCY_KHZ/1000.0f) && (freq_MHz <= BSP_MAX_RF_FREQUENCY_KHZ/1000.0f))
 8020e06:	eddf 7a41 	vldr	s15, [pc, #260]	; 8020f0c <radar_init+0x154>
  /* Set PLL upper and lower frequencies for FMCW modulation */
  pll_set_upper_lower_frequency(temp_pll_lower_freq_MHz, temp_pll_upper_freq_MHz);
  
#if FW_MODULATION_TYPE == 1U
  
  ds_device_get_settings()->pll_modulation_mode = MODULATION_FMCW;
 8020e0a:	6185      	str	r5, [r0, #24]
//============================================================================
uint16_t radar_set_pll_frequency(Radar_Handle_t device, float freq_MHz)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  if ((freq_MHz >= BSP_MIN_RF_FREQUENCY_KHZ/1000.0f) && (freq_MHz <= BSP_MAX_RF_FREQUENCY_KHZ/1000.0f))
 8020e0c:	eeb4 8ae7 	vcmpe.f32	s16, s15
 8020e10:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020e14:	db06      	blt.n	8020e24 <radar_init+0x6c>
 8020e16:	eddf 7a3e 	vldr	s15, [pc, #248]	; 8020f10 <radar_init+0x158>
 8020e1a:	eeb4 8ae7 	vcmpe.f32	s16, s15
 8020e1e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020e22:	d954      	bls.n	8020ece <radar_init+0x116>
    
    return (RADAR_ERR_OK);
  }
  else
  {
    return (RADAR_ERR_PARAMETER_OUT_OF_RANGE);
 8020e24:	240c      	movs	r4, #12
#endif
  
  /* BGT, PLL, PGA, USB and DMA Setup */
  /* -------------------------------- */
  
  acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 8020e26:	f7ff f959 	bl	80200dc <ds_get_active_acq_buf>
  
  bsp_dma_set_destination_addr_from_acq_buf_obj(p_acq_buf, 0);
 8020e2a:	2100      	movs	r1, #0
 8020e2c:	f007 f84c 	bl	8027ec8 <bsp_dma_set_destination_addr_from_acq_buf_obj>
  
  status |= (uint16_t) bsp_init();
 8020e30:	f006 fdf0 	bl	8027a14 <bsp_init>
 8020e34:	4605      	mov	r5, r0
  
  /* Load calibration data & Timers setup */
  /* ------------------------------------ */
  radar_init_calibration(device);
 8020e36:	4630      	mov	r0, r6
 8020e38:	f7ff fd4e 	bl	80208d8 <radar_init_calibration>
  
  /* Read ADC calibration data */
  status |= radar_read_calibration(device, CALIBRATION_TARGET_FLASH, CALIBRATION_DATA_ADC, &calibration_data_ptr, &num_of_bytes);
 8020e3c:	f10d 070a 	add.w	r7, sp, #10
 8020e40:	2100      	movs	r1, #0
 8020e42:	460a      	mov	r2, r1
 8020e44:	ab03      	add	r3, sp, #12
 8020e46:	9700      	str	r7, [sp, #0]
 8020e48:	4630      	mov	r0, r6
 8020e4a:	f7ff fe15 	bl	8020a78 <radar_read_calibration>
  
  /* Read algorithm calibration data */
  status |= radar_read_calibration(device, CALIBRATION_TARGET_FLASH, CALIBRATION_DATA_ALGO, &calibration_data_ptr, &num_of_bytes);
 8020e4e:	ab03      	add	r3, sp, #12
 8020e50:	2201      	movs	r2, #1
 8020e52:	2100      	movs	r1, #0
 8020e54:	4304      	orrs	r4, r0
 8020e56:	9700      	str	r7, [sp, #0]
 8020e58:	4630      	mov	r0, r6
 8020e5a:	f7ff fe0d 	bl	8020a78 <radar_read_calibration>
 8020e5e:	b2a4      	uxth	r4, r4
 8020e60:	4320      	orrs	r0, r4
 8020e62:	ea40 0405 	orr.w	r4, r0, r5
  
  status |= radar_set_sampling_freq(device, ds_device_get_settings()->pll_modulation_mode, ds_device_get_settings()->adc_sampling_freq_Hz);
 8020e66:	f7ff f8cf 	bl	8020008 <ds_device_get_settings>
 8020e6a:	6985      	ldr	r5, [r0, #24]
 8020e6c:	f7ff f8cc 	bl	8020008 <ds_device_get_settings>
 8020e70:	ed90 8a07 	vldr	s16, [r0, #28]
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  TIMER_STATUS_t status = TIMER_STATUS_FAILURE;
  uint32_t sampling_period_usec = 0;
  
  if (((uint32_t)freq_Hz <= 0) || ((uint32_t)freq_Hz > BSP_MAX_ADC_FREQ_HZ))
 8020e74:	4a27      	ldr	r2, [pc, #156]	; (8020f14 <radar_init+0x15c>)
  status |= radar_read_calibration(device, CALIBRATION_TARGET_FLASH, CALIBRATION_DATA_ADC, &calibration_data_ptr, &num_of_bytes);
  
  /* Read algorithm calibration data */
  status |= radar_read_calibration(device, CALIBRATION_TARGET_FLASH, CALIBRATION_DATA_ALGO, &calibration_data_ptr, &num_of_bytes);
  
  status |= radar_set_sampling_freq(device, ds_device_get_settings()->pll_modulation_mode, ds_device_get_settings()->adc_sampling_freq_Hz);
 8020e76:	eeb8 8a48 	vcvt.f32.u32	s16, s16
  
  /* Read ADC calibration data */
  status |= radar_read_calibration(device, CALIBRATION_TARGET_FLASH, CALIBRATION_DATA_ADC, &calibration_data_ptr, &num_of_bytes);
  
  /* Read algorithm calibration data */
  status |= radar_read_calibration(device, CALIBRATION_TARGET_FLASH, CALIBRATION_DATA_ALGO, &calibration_data_ptr, &num_of_bytes);
 8020e7a:	b2a4      	uxth	r4, r4
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  TIMER_STATUS_t status = TIMER_STATUS_FAILURE;
  uint32_t sampling_period_usec = 0;
  
  if (((uint32_t)freq_Hz <= 0) || ((uint32_t)freq_Hz > BSP_MAX_ADC_FREQ_HZ))
 8020e7c:	eefc 7ac8 	vcvt.u32.f32	s15, s16
 8020e80:	ee17 3a90 	vmov	r3, s15
 8020e84:	3b01      	subs	r3, #1
 8020e86:	4293      	cmp	r3, r2
 8020e88:	d906      	bls.n	8020e98 <radar_init+0xe0>
  {
    return (RADAR_ERR_BUSY);
 8020e8a:	2002      	movs	r0, #2
  status |= radar_read_calibration(device, CALIBRATION_TARGET_FLASH, CALIBRATION_DATA_ALGO, &calibration_data_ptr, &num_of_bytes);
  
  status |= radar_set_sampling_freq(device, ds_device_get_settings()->pll_modulation_mode, ds_device_get_settings()->adc_sampling_freq_Hz);
  
  return (status);
}
 8020e8c:	4320      	orrs	r0, r4
 8020e8e:	b005      	add	sp, #20
 8020e90:	ecbd 8b02 	vpop	{d8}
 8020e94:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if (((uint32_t)freq_Hz <= 0) || ((uint32_t)freq_Hz > BSP_MAX_ADC_FREQ_HZ))
  {
    return (RADAR_ERR_BUSY);
  }
  
  bsp_timer_stop_clear(&TIMER_ADC_TRIG);
 8020e98:	481f      	ldr	r0, [pc, #124]	; (8020f18 <radar_init+0x160>)
  
  if (modulation_type == MODULATION_FMCW)
 8020e9a:	b2ed      	uxtb	r5, r5
  if (((uint32_t)freq_Hz <= 0) || ((uint32_t)freq_Hz > BSP_MAX_ADC_FREQ_HZ))
  {
    return (RADAR_ERR_BUSY);
  }
  
  bsp_timer_stop_clear(&TIMER_ADC_TRIG);
 8020e9c:	f007 f806 	bl	8027eac <bsp_timer_stop_clear>
  
  if (modulation_type == MODULATION_FMCW)
 8020ea0:	2d01      	cmp	r5, #1
 8020ea2:	d01c      	beq.n	8020ede <radar_init+0x126>
  {
    sampling_period_usec = (uint32_t)(((float) ds_device_get_settings()->pll_chirp_time_usec * 100.0f) / (float)ds_device_get_settings()->num_samples_per_chirp);
  }
  else
  {
    sampling_period_usec = (uint32_t)(1000.0f * 1000.0f * 100.0f / freq_Hz);
 8020ea4:	eddf 7a1d 	vldr	s15, [pc, #116]	; 8020f1c <radar_init+0x164>
 8020ea8:	ee87 8a88 	vdiv.f32	s16, s15, s16
 8020eac:	eebc 8ac8 	vcvt.u32.f32	s16, s16
  }
  
  status = TIMER_SetTimeInterval(&TIMER_ADC_TRIG, sampling_period_usec);
 8020eb0:	ee18 1a10 	vmov	r1, s16
 8020eb4:	4818      	ldr	r0, [pc, #96]	; (8020f18 <radar_init+0x160>)
 8020eb6:	f005 fa4b 	bl	8026350 <TIMER_SetTimeInterval>
  {
    return (RADAR_ERR_OK);
  }
  else
  {
    return (RADAR_ERR_BUSY);
 8020eba:	2800      	cmp	r0, #0
 8020ebc:	bf0c      	ite	eq
 8020ebe:	2000      	moveq	r0, #0
 8020ec0:	2002      	movne	r0, #2
  status |= radar_read_calibration(device, CALIBRATION_TARGET_FLASH, CALIBRATION_DATA_ALGO, &calibration_data_ptr, &num_of_bytes);
  
  status |= radar_set_sampling_freq(device, ds_device_get_settings()->pll_modulation_mode, ds_device_get_settings()->adc_sampling_freq_Hz);
  
  return (status);
}
 8020ec2:	4320      	orrs	r0, r4
 8020ec4:	b005      	add	sp, #20
 8020ec6:	ecbd 8b02 	vpop	{d8}
 8020eca:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  if ((freq_MHz >= BSP_MIN_RF_FREQUENCY_KHZ/1000.0f) && (freq_MHz <= BSP_MAX_RF_FREQUENCY_KHZ/1000.0f))
  {
    pll_set_frequency(freq_MHz);
 8020ece:	4640      	mov	r0, r8
 8020ed0:	4649      	mov	r1, r9
 8020ed2:	f007 fc8d 	bl	80287f0 <pll_set_frequency>
    pll_set_update_config_flag(true);
 8020ed6:	4628      	mov	r0, r5
 8020ed8:	f007 fc7a 	bl	80287d0 <pll_set_update_config_flag>
 8020edc:	e7a3      	b.n	8020e26 <radar_init+0x6e>
  
  bsp_timer_stop_clear(&TIMER_ADC_TRIG);
  
  if (modulation_type == MODULATION_FMCW)
  {
    sampling_period_usec = (uint32_t)(((float) ds_device_get_settings()->pll_chirp_time_usec * 100.0f) / (float)ds_device_get_settings()->num_samples_per_chirp);
 8020ede:	f7ff f893 	bl	8020008 <ds_device_get_settings>
 8020ee2:	edd0 8a00 	vldr	s17, [r0]
 8020ee6:	ed9f 8a0e 	vldr	s16, [pc, #56]	; 8020f20 <radar_init+0x168>
 8020eea:	eef8 7a68 	vcvt.f32.u32	s15, s17
 8020eee:	ee67 8a88 	vmul.f32	s17, s15, s16
 8020ef2:	f7ff f889 	bl	8020008 <ds_device_get_settings>
 8020ef6:	ed90 8a0b 	vldr	s16, [r0, #44]	; 0x2c
 8020efa:	eeb8 8a48 	vcvt.f32.u32	s16, s16
 8020efe:	ee88 8a88 	vdiv.f32	s16, s17, s16
 8020f02:	eebc 8ac8 	vcvt.u32.f32	s16, s16
 8020f06:	e7d3      	b.n	8020eb0 <radar_init+0xf8>
 8020f08:	447a0000 	.word	0x447a0000
 8020f0c:	46bbb200 	.word	0x46bbb200
 8020f10:	46bd4200 	.word	0x46bd4200
 8020f14:	0016e35f 	.word	0x0016e35f
 8020f18:	1ffe8b18 	.word	0x1ffe8b18
 8020f1c:	4cbebc20 	.word	0x4cbebc20
 8020f20:	42c80000 	.word	0x42c80000

08020f24 <radar_start_acquisition>:
}

//============================================================================

uint16_t radar_start_acquisition(Radar_Handle_t device)
{
 8020f24:	b510      	push	{r4, lr}
 8020f26:	4604      	mov	r4, r0

  uint16_t status = RADAR_ERR_BUSY;
  
  if (ds_device_get_settings()->frame_period_usec > 0)
 8020f28:	f7ff f86e 	bl	8020008 <ds_device_get_settings>
 8020f2c:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8020f2e:	b90b      	cbnz	r3, 8020f34 <radar_start_acquisition+0x10>
  {
    status = radar_set_automatic_frame_trigger(device, ds_device_get_settings()->frame_period_usec);
  }
  
  return (status);
}
 8020f30:	2002      	movs	r0, #2
 8020f32:	bd10      	pop	{r4, pc}

  uint16_t status = RADAR_ERR_BUSY;
  
  if (ds_device_get_settings()->frame_period_usec > 0)
  {
    status = radar_set_automatic_frame_trigger(device, ds_device_get_settings()->frame_period_usec);
 8020f34:	f7ff f868 	bl	8020008 <ds_device_get_settings>
 8020f38:	6a81      	ldr	r1, [r0, #40]	; 0x28
 8020f3a:	4620      	mov	r0, r4
  }
  
  return (status);
}
 8020f3c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  uint16_t status = RADAR_ERR_BUSY;
  
  if (ds_device_get_settings()->frame_period_usec > 0)
  {
    status = radar_set_automatic_frame_trigger(device, ds_device_get_settings()->frame_period_usec);
 8020f40:	f7ff bc6a 	b.w	8020818 <radar_set_automatic_frame_trigger>

08020f44 <radar_set_chirp_time>:
}

//============================================================================

uint16_t radar_set_chirp_time(Radar_Handle_t device, const uint32_t chirp_time_usec)
{
 8020f44:	b510      	push	{r4, lr}
 8020f46:	ed2d 8b02 	vpush	{d8}
 8020f4a:	460c      	mov	r4, r1

//============================================================================

static uint16_t radar_check_chirp_time(const uint32_t chirp_time_usec)
{
  if ((ds_device_get_settings()->pll_modulation_mode == MODULATION_FMCW) &&
 8020f4c:	f7ff f85c 	bl	8020008 <ds_device_get_settings>
 8020f50:	6983      	ldr	r3, [r0, #24]
 8020f52:	2b01      	cmp	r3, #1
 8020f54:	d029      	beq.n	8020faa <radar_set_chirp_time+0x66>
  {
    return retValue;
  }
  
  /* ---- chirp time was verified being o.k. */
  ds_device_get_settings()->pll_chirp_time_usec = chirp_time_usec;
 8020f56:	f7ff f857 	bl	8020008 <ds_device_get_settings>
 8020f5a:	6004      	str	r4, [r0, #0]
  
  /* Set the current PLL chirp-time, in units of usec */
  pll_set_chirp_time(ds_device_get_settings()->pll_chirp_time_usec);
 8020f5c:	f7ff f854 	bl	8020008 <ds_device_get_settings>
 8020f60:	6800      	ldr	r0, [r0, #0]
 8020f62:	f007 fcb9 	bl	80288d8 <pll_set_chirp_time>
   
  bsp_timer_stop_clear(&TIMER_ADC_TRIG);
 8020f66:	4822      	ldr	r0, [pc, #136]	; (8020ff0 <radar_set_chirp_time+0xac>)
 8020f68:	f006 ffa0 	bl	8027eac <bsp_timer_stop_clear>
  
  uint32_t sampling_period_usec = (uint32_t)(((float)ds_device_get_settings()->pll_chirp_time_usec * 100.0f) / (float)ds_device_get_settings()->num_samples_per_chirp);
 8020f6c:	f7ff f84c 	bl	8020008 <ds_device_get_settings>
 8020f70:	ed90 8a00 	vldr	s16, [r0]
 8020f74:	eddf 7a1f 	vldr	s15, [pc, #124]	; 8020ff4 <radar_set_chirp_time+0xb0>
 8020f78:	eeb8 8a48 	vcvt.f32.u32	s16, s16
 8020f7c:	ee28 8a27 	vmul.f32	s16, s16, s15
 8020f80:	f7ff f842 	bl	8020008 <ds_device_get_settings>
 8020f84:	edd0 7a0b 	vldr	s15, [r0, #44]	; 0x2c
  
  if (TIMER_SetTimeInterval(&TIMER_ADC_TRIG, sampling_period_usec) != TIMER_STATUS_SUCCESS)
 8020f88:	4819      	ldr	r0, [pc, #100]	; (8020ff0 <radar_set_chirp_time+0xac>)
  /* Set the current PLL chirp-time, in units of usec */
  pll_set_chirp_time(ds_device_get_settings()->pll_chirp_time_usec);
   
  bsp_timer_stop_clear(&TIMER_ADC_TRIG);
  
  uint32_t sampling_period_usec = (uint32_t)(((float)ds_device_get_settings()->pll_chirp_time_usec * 100.0f) / (float)ds_device_get_settings()->num_samples_per_chirp);
 8020f8a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8020f8e:	ee88 8a27 	vdiv.f32	s16, s16, s15
  
  if (TIMER_SetTimeInterval(&TIMER_ADC_TRIG, sampling_period_usec) != TIMER_STATUS_SUCCESS)
 8020f92:	eefc 7ac8 	vcvt.u32.f32	s15, s16
 8020f96:	ee17 1a90 	vmov	r1, s15
 8020f9a:	f005 f9d9 	bl	8026350 <TIMER_SetTimeInterval>
 8020f9e:	4604      	mov	r4, r0
 8020fa0:	b308      	cbz	r0, 8020fe6 <radar_set_chirp_time+0xa2>
}

//============================================================================

uint16_t radar_set_chirp_time(Radar_Handle_t device, const uint32_t chirp_time_usec)
{
 8020fa2:	200c      	movs	r0, #12
  
  /* Update the PLL Configuration */
  pll_set_update_config_flag(true);
  
  return (RADAR_ERR_OK);
}
 8020fa4:	ecbd 8b02 	vpop	{d8}
 8020fa8:	bd10      	pop	{r4, pc}

//============================================================================

static uint16_t radar_check_chirp_time(const uint32_t chirp_time_usec)
{
  if ((ds_device_get_settings()->pll_modulation_mode == MODULATION_FMCW) &&
 8020faa:	f1a4 0232 	sub.w	r2, r4, #50	; 0x32
 8020fae:	f640 3386 	movw	r3, #2950	; 0xb86
 8020fb2:	429a      	cmp	r2, r3
 8020fb4:	d8cf      	bhi.n	8020f56 <radar_set_chirp_time+0x12>
      (chirp_time_usec >= BSP_MIN_CHIRP_TIME_USEC) && (chirp_time_usec <= BSP_MAX_CHIRP_TIME_USEC))
  {
    if ((chirp_time_usec < 300 && ds_device_get_settings()->num_samples_per_chirp > 256) ||
 8020fb6:	f5b4 7f96 	cmp.w	r4, #300	; 0x12c
 8020fba:	d2cc      	bcs.n	8020f56 <radar_set_chirp_time+0x12>
 8020fbc:	f7ff f824 	bl	8020008 <ds_device_get_settings>
 8020fc0:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8020fc2:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8020fc6:	d8ec      	bhi.n	8020fa2 <radar_set_chirp_time+0x5e>
 8020fc8:	2c95      	cmp	r4, #149	; 0x95
 8020fca:	d8c4      	bhi.n	8020f56 <radar_set_chirp_time+0x12>
        (chirp_time_usec < 150 && ds_device_get_settings()->num_samples_per_chirp > 128) ||
 8020fcc:	f7ff f81c 	bl	8020008 <ds_device_get_settings>
 8020fd0:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8020fd2:	2b80      	cmp	r3, #128	; 0x80
 8020fd4:	d8e5      	bhi.n	8020fa2 <radar_set_chirp_time+0x5e>
 8020fd6:	2c4a      	cmp	r4, #74	; 0x4a
 8020fd8:	d8bd      	bhi.n	8020f56 <radar_set_chirp_time+0x12>
        (chirp_time_usec < 75  && ds_device_get_settings()->num_samples_per_chirp > 64))
 8020fda:	f7ff f815 	bl	8020008 <ds_device_get_settings>
 8020fde:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8020fe0:	2b40      	cmp	r3, #64	; 0x40
 8020fe2:	d8de      	bhi.n	8020fa2 <radar_set_chirp_time+0x5e>
 8020fe4:	e7b7      	b.n	8020f56 <radar_set_chirp_time+0x12>
  {
    return (RADAR_ERR_PARAMETER_OUT_OF_RANGE);
  }
  
  /* Update the PLL Configuration */
  pll_set_update_config_flag(true);
 8020fe6:	2001      	movs	r0, #1
 8020fe8:	f007 fbf2 	bl	80287d0 <pll_set_update_config_flag>
  
  return (RADAR_ERR_OK);
 8020fec:	4620      	mov	r0, r4
 8020fee:	e7d9      	b.n	8020fa4 <radar_set_chirp_time+0x60>
 8020ff0:	1ffe8b18 	.word	0x1ffe8b18
 8020ff4:	42c80000 	.word	0x42c80000

08020ff8 <radar_set_sampling_freq>:
}

//============================================================================

uint16_t radar_set_sampling_freq(Radar_Handle_t device, Modulation_Type_t modulation_type, const float freq_Hz)
{
 8020ff8:	ee07 2a90 	vmov	s15, r2
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  TIMER_STATUS_t status = TIMER_STATUS_FAILURE;
  uint32_t sampling_period_usec = 0;
  
  if (((uint32_t)freq_Hz <= 0) || ((uint32_t)freq_Hz > BSP_MAX_ADC_FREQ_HZ))
 8020ffc:	eebc 7ae7 	vcvt.u32.f32	s14, s15
}

//============================================================================

uint16_t radar_set_sampling_freq(Radar_Handle_t device, Modulation_Type_t modulation_type, const float freq_Hz)
{
 8021000:	b538      	push	{r3, r4, r5, lr}
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  TIMER_STATUS_t status = TIMER_STATUS_FAILURE;
  uint32_t sampling_period_usec = 0;
  
  if (((uint32_t)freq_Hz <= 0) || ((uint32_t)freq_Hz > BSP_MAX_ADC_FREQ_HZ))
 8021002:	ee17 3a10 	vmov	r3, s14
 8021006:	4a1d      	ldr	r2, [pc, #116]	; (802107c <radar_set_sampling_freq+0x84>)
 8021008:	3b01      	subs	r3, #1
 802100a:	4293      	cmp	r3, r2
}

//============================================================================

uint16_t radar_set_sampling_freq(Radar_Handle_t device, Modulation_Type_t modulation_type, const float freq_Hz)
{
 802100c:	ed2d 8b02 	vpush	{d8}
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  TIMER_STATUS_t status = TIMER_STATUS_FAILURE;
  uint32_t sampling_period_usec = 0;
  
  if (((uint32_t)freq_Hz <= 0) || ((uint32_t)freq_Hz > BSP_MAX_ADC_FREQ_HZ))
 8021010:	d903      	bls.n	802101a <radar_set_sampling_freq+0x22>
  }
  else
  {
    return (RADAR_ERR_BUSY);
  }
}
 8021012:	ecbd 8b02 	vpop	{d8}
  TIMER_STATUS_t status = TIMER_STATUS_FAILURE;
  uint32_t sampling_period_usec = 0;
  
  if (((uint32_t)freq_Hz <= 0) || ((uint32_t)freq_Hz > BSP_MAX_ADC_FREQ_HZ))
  {
    return (RADAR_ERR_BUSY);
 8021016:	2002      	movs	r0, #2
  }
  else
  {
    return (RADAR_ERR_BUSY);
  }
}
 8021018:	bd38      	pop	{r3, r4, r5, pc}
 802101a:	460d      	mov	r5, r1
  if (((uint32_t)freq_Hz <= 0) || ((uint32_t)freq_Hz > BSP_MAX_ADC_FREQ_HZ))
  {
    return (RADAR_ERR_BUSY);
  }
  
  bsp_timer_stop_clear(&TIMER_ADC_TRIG);
 802101c:	4818      	ldr	r0, [pc, #96]	; (8021080 <radar_set_sampling_freq+0x88>)
 802101e:	ee17 4a90 	vmov	r4, s15
 8021022:	f006 ff43 	bl	8027eac <bsp_timer_stop_clear>
  
  if (modulation_type == MODULATION_FMCW)
 8021026:	2d01      	cmp	r5, #1
 8021028:	d013      	beq.n	8021052 <radar_set_sampling_freq+0x5a>
  {
    sampling_period_usec = (uint32_t)(((float) ds_device_get_settings()->pll_chirp_time_usec * 100.0f) / (float)ds_device_get_settings()->num_samples_per_chirp);
  }
  else
  {
    sampling_period_usec = (uint32_t)(1000.0f * 1000.0f * 100.0f / freq_Hz);
 802102a:	eddf 7a16 	vldr	s15, [pc, #88]	; 8021084 <radar_set_sampling_freq+0x8c>
 802102e:	ee07 4a10 	vmov	s14, r4
 8021032:	eec7 7a87 	vdiv.f32	s15, s15, s14
 8021036:	eefc 7ae7 	vcvt.u32.f32	s15, s15
  }
  
  status = TIMER_SetTimeInterval(&TIMER_ADC_TRIG, sampling_period_usec);
 802103a:	4811      	ldr	r0, [pc, #68]	; (8021080 <radar_set_sampling_freq+0x88>)
 802103c:	ee17 1a90 	vmov	r1, s15
 8021040:	f005 f986 	bl	8026350 <TIMER_SetTimeInterval>
  }
  else
  {
    return (RADAR_ERR_BUSY);
  }
}
 8021044:	ecbd 8b02 	vpop	{d8}
    sampling_period_usec = (uint32_t)(1000.0f * 1000.0f * 100.0f / freq_Hz);
  }
  
  status = TIMER_SetTimeInterval(&TIMER_ADC_TRIG, sampling_period_usec);
  
  if (status == TIMER_STATUS_SUCCESS)
 8021048:	2800      	cmp	r0, #0
  {
    return (RADAR_ERR_OK);
  }
  else
  {
    return (RADAR_ERR_BUSY);
 802104a:	bf0c      	ite	eq
 802104c:	2000      	moveq	r0, #0
 802104e:	2002      	movne	r0, #2
  }
}
 8021050:	bd38      	pop	{r3, r4, r5, pc}
  
  bsp_timer_stop_clear(&TIMER_ADC_TRIG);
  
  if (modulation_type == MODULATION_FMCW)
  {
    sampling_period_usec = (uint32_t)(((float) ds_device_get_settings()->pll_chirp_time_usec * 100.0f) / (float)ds_device_get_settings()->num_samples_per_chirp);
 8021052:	f7fe ffd9 	bl	8020008 <ds_device_get_settings>
 8021056:	ed90 8a00 	vldr	s16, [r0]
 802105a:	ed9f 7a0b 	vldr	s14, [pc, #44]	; 8021088 <radar_set_sampling_freq+0x90>
 802105e:	eef8 7a48 	vcvt.f32.u32	s15, s16
 8021062:	ee27 8a87 	vmul.f32	s16, s15, s14
 8021066:	f7fe ffcf 	bl	8020008 <ds_device_get_settings>
 802106a:	edd0 7a0b 	vldr	s15, [r0, #44]	; 0x2c
 802106e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8021072:	eec8 7a27 	vdiv.f32	s15, s16, s15
 8021076:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 802107a:	e7de      	b.n	802103a <radar_set_sampling_freq+0x42>
 802107c:	0016e35f 	.word	0x0016e35f
 8021080:	1ffe8b18 	.word	0x1ffe8b18
 8021084:	4cbebc20 	.word	0x4cbebc20
 8021088:	42c80000 	.word	0x42c80000

0802108c <radar_register_callback>:
uint16_t radar_register_callback(Radar_Callback_ID_t cb_id, void (*pcallback)(void *parameter))
{
  uint16_t status = RADAR_ERR_OK;
  
  /* Check if the callback function is valid */
  if(pcallback == NULL)
 802108c:	b151      	cbz	r1, 80210a4 <radar_register_callback+0x18>
  {
    return(RADAR_ERR_BUSY);
  }
  
  /* Register user callback function based on callback ID */
  switch (cb_id)
 802108e:	2801      	cmp	r0, #1
}

//============================================================================

uint16_t radar_register_callback(Radar_Callback_ID_t cb_id, void (*pcallback)(void *parameter))
{
 8021090:	b508      	push	{r3, lr}
  {
    return(RADAR_ERR_BUSY);
  }
  
  /* Register user callback function based on callback ID */
  switch (cb_id)
 8021092:	d003      	beq.n	802109c <radar_register_callback+0x10>
 8021094:	2802      	cmp	r0, #2
 8021096:	d001      	beq.n	802109c <radar_register_callback+0x10>
    bsp_register_callback(BSP_ACQUISITION_DONE_CB_ID, pcallback);
    break;
    
  default:
    /* Return error status */
    status =  RADAR_ERR_BUSY;
 8021098:	2002      	movs	r0, #2
    break;
  }
  
  return (status);
}
 802109a:	bd08      	pop	{r3, pc}
    bsp_register_callback(BSP_ACQUISITION_STARTED_CB_ID, pcallback);
    break;
    
  case RADAR_ACQUISITION_DONE_CB_ID:
    /* Callback executed by BSP layer at the end of data acquisition process */
    bsp_register_callback(BSP_ACQUISITION_DONE_CB_ID, pcallback);
 802109c:	f007 f9be 	bl	802841c <bsp_register_callback>

//============================================================================

uint16_t radar_register_callback(Radar_Callback_ID_t cb_id, void (*pcallback)(void *parameter))
{
  uint16_t status = RADAR_ERR_OK;
 80210a0:	2000      	movs	r0, #0
    break;
    
  case RADAR_ACQUISITION_DONE_CB_ID:
    /* Callback executed by BSP layer at the end of data acquisition process */
    bsp_register_callback(BSP_ACQUISITION_DONE_CB_ID, pcallback);
    break;
 80210a2:	bd08      	pop	{r3, pc}
  uint16_t status = RADAR_ERR_OK;
  
  /* Check if the callback function is valid */
  if(pcallback == NULL)
  {
    return(RADAR_ERR_BUSY);
 80210a4:	2002      	movs	r0, #2
    status =  RADAR_ERR_BUSY;
    break;
  }
  
  return (status);
}
 80210a6:	4770      	bx	lr

080210a8 <radar_apply_hw_settings>:
}

//============================================================================

uint32_t radar_apply_hw_settings(Radar_Handle_t device, hw_state_setting_t state, device_settings_t *p_hw_settings)
{
 80210a8:	b510      	push	{r4, lr}
 80210aa:	4614      	mov	r4, r2
  uint32_t retValue = RADAR_ERR_OK;
  
  switch(state)
 80210ac:	2905      	cmp	r1, #5
 80210ae:	d80e      	bhi.n	80210ce <radar_apply_hw_settings+0x26>
 80210b0:	e8df f001 	tbb	[pc, r1]
 80210b4:	1b0d0d16 	.word	0x1b0d0d16
 80210b8:	030f      	.short	0x030f
    }
    break;
    
  case START_MANUAL_ACQ:
    {
      acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 80210ba:	f7ff f80f 	bl	80200dc <ds_get_active_acq_buf>
      
      bsp_dma_set_destination_addr_from_acq_buf_obj(p_acq_buf, 0);
 80210be:	2100      	movs	r1, #0
 80210c0:	f006 ff02 	bl	8027ec8 <bsp_dma_set_destination_addr_from_acq_buf_obj>
      
      bsp_reset_frame_counter();
 80210c4:	f007 f99e 	bl	8028404 <bsp_reset_frame_counter>
      
      g_adc_sampling_completed = false;
 80210c8:	4b0a      	ldr	r3, [pc, #40]	; (80210f4 <radar_apply_hw_settings+0x4c>)
 80210ca:	2200      	movs	r2, #0
 80210cc:	601a      	str	r2, [r3, #0]
  default:
    break;
  }
  
  return retValue;
}
 80210ce:	2000      	movs	r0, #0
 80210d0:	bd10      	pop	{r4, pc}
  case POWER_DOWN:
    bgt_stop_tx();
    break;
    
  case UPDATE:
    if(ds_is_device_settings_updated())
 80210d2:	f7fe ffa1 	bl	8020018 <ds_is_device_settings_updated>
 80210d6:	2800      	cmp	r0, #0
 80210d8:	d0f9      	beq.n	80210ce <radar_apply_hw_settings+0x26>
    {
      /* stop the timer for ADC acquisition, while updating the values! */
      bsp_timer_stop_clear(&TIMER_ADC_TRIG);
 80210da:	4807      	ldr	r0, [pc, #28]	; (80210f8 <radar_apply_hw_settings+0x50>)
 80210dc:	f006 fee6 	bl	8027eac <bsp_timer_stop_clear>
      
      retValue = radar_apply_new_hw_setting(device, p_hw_settings);
 80210e0:	4620      	mov	r0, r4
  default:
    break;
  }
  
  return retValue;
}
 80210e2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    if(ds_is_device_settings_updated())
    {
      /* stop the timer for ADC acquisition, while updating the values! */
      bsp_timer_stop_clear(&TIMER_ADC_TRIG);
      
      retValue = radar_apply_new_hw_setting(device, p_hw_settings);
 80210e6:	f7ff bd63 	b.w	8020bb0 <radar_apply_new_hw_setting.isra.1>
    
  case LEAVE_POWERSAVING:
    break;
    
  case POWER_DOWN:
    bgt_stop_tx();
 80210ea:	f006 fc45 	bl	8027978 <bgt_stop_tx>
  default:
    break;
  }
  
  return retValue;
}
 80210ee:	2000      	movs	r0, #0
 80210f0:	bd10      	pop	{r4, pc}
 80210f2:	bf00      	nop
 80210f4:	1ffe8cc0 	.word	0x1ffe8cc0
 80210f8:	1ffe8b18 	.word	0x1ffe8b18

080210fc <radar_get_data_acq_mode>:

//============================================================================

Radar_Data_Acq_Mode_t radar_get_data_acq_mode(void)
{
  return s_data_acq_mode;
 80210fc:	4b01      	ldr	r3, [pc, #4]	; (8021104 <radar_get_data_acq_mode+0x8>)
}
 80210fe:	7818      	ldrb	r0, [r3, #0]
 8021100:	4770      	bx	lr
 8021102:	bf00      	nop
 8021104:	1ffe8cbc 	.word	0x1ffe8cbc

08021108 <radar_set_data_acq_mode>:

//============================================================================

void radar_set_data_acq_mode(Radar_Data_Acq_Mode_t new_mode)
{
  s_data_acq_mode = new_mode;
 8021108:	4b01      	ldr	r3, [pc, #4]	; (8021110 <radar_set_data_acq_mode+0x8>)
 802110a:	7018      	strb	r0, [r3, #0]
 802110c:	4770      	bx	lr
 802110e:	bf00      	nop
 8021110:	1ffe8cbc 	.word	0x1ffe8cbc

08021114 <radar_set_fmcw_configuration>:
==============================================================================
 */

uint16_t radar_set_fmcw_configuration(Radar_Handle_t device, 
                                      const Fmcw_Configuration_t* configuration)
{
 8021114:	b538      	push	{r3, r4, r5, lr}
 8021116:	460d      	mov	r5, r1
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  float tmp_bandwidth_mhz;
  
  /* Configuration change is only allowed while automatic trigger is not working */
  if (radar_get_data_acq_mode() != RADAR_MANUAL_TRIGGER)
 8021118:	f7ff fff0 	bl	80210fc <radar_get_data_acq_mode>
 802111c:	b108      	cbz	r0, 8021122 <radar_set_fmcw_configuration+0xe>
  {
    return (RADAR_ERR_BUSY);
 802111e:	2002      	movs	r0, #2
 8021120:	bd38      	pop	{r3, r4, r5, pc}
  }
  
  /* Check if configuration is valid */
  /* ------------------------------- */
  if ((configuration->lower_frequency_kHz < BSP_MIN_RF_FREQUENCY_KHZ) ||
 8021122:	6829      	ldr	r1, [r5, #0]
 8021124:	4b19      	ldr	r3, [pc, #100]	; (802118c <radar_set_fmcw_configuration+0x78>)
 8021126:	4a1a      	ldr	r2, [pc, #104]	; (8021190 <radar_set_fmcw_configuration+0x7c>)
 8021128:	440b      	add	r3, r1
 802112a:	4293      	cmp	r3, r2
 802112c:	d901      	bls.n	8021132 <radar_set_fmcw_configuration+0x1e>
      (configuration->lower_frequency_kHz > BSP_MAX_RF_FREQUENCY_KHZ) ||
        (configuration->upper_frequency_kHz < BSP_MIN_RF_FREQUENCY_KHZ) ||
          (configuration->upper_frequency_kHz > BSP_MAX_RF_FREQUENCY_KHZ) ||
            (configuration->lower_frequency_kHz > configuration->upper_frequency_kHz))
  {
    return (RADAR_ERR_FREQUENCY_OUT_OF_RANGE);
 802112e:	2009      	movs	r0, #9
 8021130:	bd38      	pop	{r3, r4, r5, pc}
  
  /* Check if configuration is valid */
  /* ------------------------------- */
  if ((configuration->lower_frequency_kHz < BSP_MIN_RF_FREQUENCY_KHZ) ||
      (configuration->lower_frequency_kHz > BSP_MAX_RF_FREQUENCY_KHZ) ||
        (configuration->upper_frequency_kHz < BSP_MIN_RF_FREQUENCY_KHZ) ||
 8021132:	6868      	ldr	r0, [r5, #4]
  }
  
  /* Check if configuration is valid */
  /* ------------------------------- */
  if ((configuration->lower_frequency_kHz < BSP_MIN_RF_FREQUENCY_KHZ) ||
      (configuration->lower_frequency_kHz > BSP_MAX_RF_FREQUENCY_KHZ) ||
 8021134:	4b15      	ldr	r3, [pc, #84]	; (802118c <radar_set_fmcw_configuration+0x78>)
 8021136:	4403      	add	r3, r0
 8021138:	4293      	cmp	r3, r2
 802113a:	d8f8      	bhi.n	802112e <radar_set_fmcw_configuration+0x1a>
        (configuration->upper_frequency_kHz < BSP_MIN_RF_FREQUENCY_KHZ) ||
          (configuration->upper_frequency_kHz > BSP_MAX_RF_FREQUENCY_KHZ) ||
 802113c:	4281      	cmp	r1, r0
 802113e:	d8f6      	bhi.n	802112e <radar_set_fmcw_configuration+0x1a>
            (configuration->lower_frequency_kHz > configuration->upper_frequency_kHz))
  {
    return (RADAR_ERR_FREQUENCY_OUT_OF_RANGE);
  }
  
  tmp_bandwidth_mhz = ((float)(configuration->upper_frequency_kHz - configuration->lower_frequency_kHz)) / 1000.0f;
 8021140:	1a43      	subs	r3, r0, r1
 8021142:	ee07 3a90 	vmov	s15, r3
 8021146:	ed9f 7a13 	vldr	s14, [pc, #76]	; 8021194 <radar_set_fmcw_configuration+0x80>
 802114a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 802114e:	eec7 7a87 	vdiv.f32	s15, s15, s14
  
  if ((tmp_bandwidth_mhz < BSP_MIN_BANDWIDTH_MHZ) || (tmp_bandwidth_mhz > BSP_MAX_BANDWIDTH_MHZ))
 8021152:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8021156:	eef4 7ac7 	vcmpe.f32	s15, s14
 802115a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802115e:	d4e6      	bmi.n	802112e <radar_set_fmcw_configuration+0x1a>
 8021160:	ed9f 7a0d 	vldr	s14, [pc, #52]	; 8021198 <radar_set_fmcw_configuration+0x84>
 8021164:	eef4 7ac7 	vcmpe.f32	s15, s14
 8021168:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802116c:	dcdf      	bgt.n	802112e <radar_set_fmcw_configuration+0x1a>
  {
    return (RADAR_ERR_FREQUENCY_OUT_OF_RANGE);
  }
  
  if (configuration->direction != RADAR_DIR_UPCHIRP_ONLY)
 802116e:	7a2c      	ldrb	r4, [r5, #8]
 8021170:	b10c      	cbz	r4, 8021176 <radar_set_fmcw_configuration+0x62>
  {
    return (RADAR_ERR_UNSUPPORTED_DIRECTION);
 8021172:	2020      	movs	r0, #32
 8021174:	bd38      	pop	{r3, r4, r5, pc}
  }
  
  if (configuration->tx_power > BSP_MAX_TX_POWER_LEVEL)
 8021176:	7a6b      	ldrb	r3, [r5, #9]
 8021178:	2b07      	cmp	r3, #7
 802117a:	d901      	bls.n	8021180 <radar_set_fmcw_configuration+0x6c>
  {
    return (RADAR_ERR_POWER_OUT_OF_RANGE);
 802117c:	200a      	movs	r0, #10
  }
  
  ds_ep_store_fmcw_config(configuration);
  
  return (RADAR_ERR_OK);
}
 802117e:	bd38      	pop	{r3, r4, r5, pc}
  if (configuration->tx_power > BSP_MAX_TX_POWER_LEVEL)
  {
    return (RADAR_ERR_POWER_OUT_OF_RANGE);
  }
  
  ds_ep_store_fmcw_config(configuration);
 8021180:	4628      	mov	r0, r5
 8021182:	f7ff f80d 	bl	80201a0 <ds_ep_store_fmcw_config>
  
  return (RADAR_ERR_OK);
 8021186:	4620      	mov	r0, r4
 8021188:	bd38      	pop	{r3, r4, r5, pc}
 802118a:	bf00      	nop
 802118c:	fe916858 	.word	0xfe916858
 8021190:	00030d40 	.word	0x00030d40
 8021194:	447a0000 	.word	0x447a0000
 8021198:	43480000 	.word	0x43480000

0802119c <radar_get_fmcw_configuration>:

//============================================================================

uint16_t radar_get_fmcw_configuration(Radar_Handle_t device, 
                                      Fmcw_Configuration_t* configuration)
{
 802119c:	b508      	push	{r3, lr}
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  /* Get the current FMCW configuration from data store */
  ds_ep_fetch_fmcw_config(configuration);
 802119e:	4608      	mov	r0, r1
 80211a0:	f7fe ffdc 	bl	802015c <ds_ep_fetch_fmcw_config>
  return (RADAR_ERR_OK);
}
 80211a4:	2000      	movs	r0, #0
 80211a6:	bd08      	pop	{r3, pc}

080211a8 <radar_get_bandwidth_per_second>:

//============================================================================

uint16_t radar_get_bandwidth_per_second(Radar_Handle_t device, 
                                        uint32_t* bandwidth_per_second_MHz_s)
{
 80211a8:	b570      	push	{r4, r5, r6, lr}
 80211aa:	ed2d 8b02 	vpush	{d8}
 80211ae:	b084      	sub	sp, #16
  uint32_t remainder;
  uint32_t divisor;
  Frame_Format_t frame_format;
  
  /* Get the current FMCW configuration from data store */
  ds_ep_fetch_frame_format(&frame_format);
 80211b0:	a801      	add	r0, sp, #4

//============================================================================

uint16_t radar_get_bandwidth_per_second(Radar_Handle_t device, 
                                        uint32_t* bandwidth_per_second_MHz_s)
{
 80211b2:	460e      	mov	r6, r1
  uint32_t remainder;
  uint32_t divisor;
  Frame_Format_t frame_format;
  
  /* Get the current FMCW configuration from data store */
  ds_ep_fetch_frame_format(&frame_format);
 80211b4:	f7ff f818 	bl	80201e8 <ds_ep_fetch_frame_format>
  /* Unit is MHz/s. */
  /*
  * Actual calculation "uBandwidthPerSecond = (uUpperFMCWFrequency - uLowerFMCWFrequency) * 1000000 / chirp_duration"
  * is split up to avoid overflow of 32 bit words
  */
  remainder = (uint32_t)((ds_device_get_settings()->pll_upper_frequency_kHz - ds_device_get_settings()->pll_lower_frequency_kHz) *
 80211b8:	f7fe ff26 	bl	8020008 <ds_device_get_settings>
 80211bc:	ed90 8a03 	vldr	s16, [r0, #12]
 80211c0:	f7fe ff22 	bl	8020008 <ds_device_get_settings>
 80211c4:	ed90 7a02 	vldr	s14, [r0, #8]
 80211c8:	eddf 7a12 	vldr	s15, [pc, #72]	; 8021214 <radar_get_bandwidth_per_second+0x6c>
 80211cc:	ee38 8a47 	vsub.f32	s16, s16, s14
  
  remainder -= *bandwidth_per_second_MHz_s * divisor;
  
  *bandwidth_per_second_MHz_s *= 1000;
  
  *bandwidth_per_second_MHz_s += (remainder * 1000) / divisor;
 80211d0:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
  /* Unit is MHz/s. */
  /*
  * Actual calculation "uBandwidthPerSecond = (uUpperFMCWFrequency - uLowerFMCWFrequency) * 1000000 / chirp_duration"
  * is split up to avoid overflow of 32 bit words
  */
  remainder = (uint32_t)((ds_device_get_settings()->pll_upper_frequency_kHz - ds_device_get_settings()->pll_lower_frequency_kHz) *
 80211d4:	ee28 8a27 	vmul.f32	s16, s16, s15
 80211d8:	eefc 7ac8 	vcvt.u32.f32	s15, s16
 80211dc:	ee17 4a90 	vmov	r4, s15
              (BSP_REFERENCE_OSC_FREQ_HZ / 1000000));
  
  uint32_t sample_rate_divider = BSP_REFERENCE_OSC_FREQ_HZ / ds_device_get_settings()->adc_sampling_freq_Hz;
 80211e0:	f7fe ff12 	bl	8020008 <ds_device_get_settings>
  
  divisor = frame_format.num_samples_per_chirp * sample_rate_divider;
 80211e4:	9b01      	ldr	r3, [sp, #4]
  * is split up to avoid overflow of 32 bit words
  */
  remainder = (uint32_t)((ds_device_get_settings()->pll_upper_frequency_kHz - ds_device_get_settings()->pll_lower_frequency_kHz) *
              (BSP_REFERENCE_OSC_FREQ_HZ / 1000000));
  
  uint32_t sample_rate_divider = BSP_REFERENCE_OSC_FREQ_HZ / ds_device_get_settings()->adc_sampling_freq_Hz;
 80211e6:	69c1      	ldr	r1, [r0, #28]
 80211e8:	4a0b      	ldr	r2, [pc, #44]	; (8021218 <radar_get_bandwidth_per_second+0x70>)
 80211ea:	fbb2 f2f1 	udiv	r2, r2, r1
  
  divisor = frame_format.num_samples_per_chirp * sample_rate_divider;
 80211ee:	fb03 f202 	mul.w	r2, r3, r2
  
  *bandwidth_per_second_MHz_s = remainder / divisor;
 80211f2:	fbb4 f0f2 	udiv	r0, r4, r2
  
  remainder -= *bandwidth_per_second_MHz_s * divisor;
 80211f6:	fb02 4310 	mls	r3, r2, r0, r4
  
  *bandwidth_per_second_MHz_s *= 1000;
  
  *bandwidth_per_second_MHz_s += (remainder * 1000) / divisor;
 80211fa:	fb05 f303 	mul.w	r3, r5, r3
 80211fe:	fbb3 f4f2 	udiv	r4, r3, r2
 8021202:	fb05 4400 	mla	r4, r5, r0, r4
  
  return (RADAR_ERR_OK);
}
 8021206:	2000      	movs	r0, #0
  
  remainder -= *bandwidth_per_second_MHz_s * divisor;
  
  *bandwidth_per_second_MHz_s *= 1000;
  
  *bandwidth_per_second_MHz_s += (remainder * 1000) / divisor;
 8021208:	6034      	str	r4, [r6, #0]
  
  return (RADAR_ERR_OK);
}
 802120a:	b004      	add	sp, #16
 802120c:	ecbd 8b02 	vpop	{d8}
 8021210:	bd70      	pop	{r4, r5, r6, pc}
 8021212:	bf00      	nop
 8021214:	42200000 	.word	0x42200000
 8021218:	02625a00 	.word	0x02625a00

0802121c <radar_set_duty_cycle>:
   2. EXPORTED FUNCTIONS
==============================================================================
 */

uint16_t radar_set_duty_cycle(Radar_Handle_t device, const uint8_t flag)
{
 802121c:	b510      	push	{r4, lr}
 802121e:	460c      	mov	r4, r1
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  if (flag != ds_device_get_settings()->power_duty_cycle_enable_flag)
 8021220:	f7fe fef2 	bl	8020008 <ds_device_get_settings>
 8021224:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
 8021228:	42a3      	cmp	r3, r4
 802122a:	d007      	beq.n	802123c <radar_set_duty_cycle+0x20>
  {
    ds_device_get_settings()->is_duty_cycle_enable_updated = 1;
 802122c:	f7fe feec 	bl	8020008 <ds_device_get_settings>
 8021230:	2301      	movs	r3, #1
 8021232:	6383      	str	r3, [r0, #56]	; 0x38
    ds_device_get_settings()->power_duty_cycle_enable_flag = flag;
 8021234:	f7fe fee8 	bl	8020008 <ds_device_get_settings>
 8021238:	f880 4024 	strb.w	r4, [r0, #36]	; 0x24
  }
  
  return (RADAR_ERR_OK);
}
 802123c:	2000      	movs	r0, #0
 802123e:	bd10      	pop	{r4, pc}

08021240 <radar_get_duty_cycle>:

//============================================================================

void radar_get_duty_cycle(Radar_Handle_t device, uint8_t* flag)
{
 8021240:	b510      	push	{r4, lr}
 8021242:	460c      	mov	r4, r1
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  *flag = ds_device_get_settings()->power_duty_cycle_enable_flag;
 8021244:	f7fe fee0 	bl	8020008 <ds_device_get_settings>
 8021248:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
 802124c:	7023      	strb	r3, [r4, #0]
 802124e:	bd10      	pop	{r4, pc}

08021250 <radar_disable_lna_gain>:
}

//============================================================================

void radar_disable_lna_gain(Radar_Handle_t device)
{
 8021250:	b508      	push	{r3, lr}
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  ds_device_get_settings()->bgt_rx_lna_gain_enable_flag = false;
 8021252:	f7fe fed9 	bl	8020008 <ds_device_get_settings>
 8021256:	2300      	movs	r3, #0
 8021258:	f880 3026 	strb.w	r3, [r0, #38]	; 0x26
 802125c:	bd08      	pop	{r3, pc}
 802125e:	bf00      	nop

08021260 <radar_enable_lna_gain>:
}

//============================================================================

void radar_enable_lna_gain(Radar_Handle_t device)
{
 8021260:	b508      	push	{r3, lr}
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  ds_device_get_settings()->bgt_rx_lna_gain_enable_flag = true;
 8021262:	f7fe fed1 	bl	8020008 <ds_device_get_settings>
 8021266:	2301      	movs	r3, #1
 8021268:	f880 3026 	strb.w	r3, [r0, #38]	; 0x26
 802126c:	bd08      	pop	{r3, pc}
 802126e:	bf00      	nop

08021270 <radar_get_lna_gain_enable_status>:
}

//============================================================================

uint8_t radar_get_lna_gain_enable_status(Radar_Handle_t device)
{
 8021270:	b508      	push	{r3, lr}
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  return (ds_device_get_settings()->bgt_rx_lna_gain_enable_flag);
 8021272:	f7fe fec9 	bl	8020008 <ds_device_get_settings>
}
 8021276:	f890 0026 	ldrb.w	r0, [r0, #38]	; 0x26
 802127a:	bd08      	pop	{r3, pc}

0802127c <radar_set_gain_level>:

uint16_t radar_set_gain_level(Radar_Handle_t device, uint16_t gain_level)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  if (gain_level > MAX_PGA_GAIN_LEVEL)
 802127c:	2907      	cmp	r1, #7
 802127e:	d901      	bls.n	8021284 <radar_set_gain_level+0x8>
  {
    return (RADAR_ERR_UNSUPPORTED_PGA_GAIN);
 8021280:	2052      	movs	r0, #82	; 0x52
 8021282:	4770      	bx	lr
   2. EXPORTED FUNCTIONS
==============================================================================
 */

uint16_t radar_set_gain_level(Radar_Handle_t device, uint16_t gain_level)
{
 8021284:	b500      	push	{lr}
 8021286:	b083      	sub	sp, #12
 8021288:	9101      	str	r1, [sp, #4]
  {
    return (RADAR_ERR_UNSUPPORTED_PGA_GAIN);
  }
  
  /* Update the PGA Gain level */
  ds_device_get_settings()->pga_rx_gain_level = gain_level;
 802128a:	f7fe febd 	bl	8020008 <ds_device_get_settings>
 802128e:	9901      	ldr	r1, [sp, #4]
 8021290:	8441      	strh	r1, [r0, #34]	; 0x22
  ds_device_get_settings()->isGainlevelUpdated = 1;
 8021292:	f7fe feb9 	bl	8020008 <ds_device_get_settings>
 8021296:	2301      	movs	r3, #1
 8021298:	6343      	str	r3, [r0, #52]	; 0x34
  
  return (RADAR_ERR_OK);
 802129a:	2000      	movs	r0, #0
}
 802129c:	b003      	add	sp, #12
 802129e:	f85d fb04 	ldr.w	pc, [sp], #4
 80212a2:	bf00      	nop

080212a4 <radar_get_gain_level>:

//============================================================================

uint16_t radar_get_gain_level(Radar_Handle_t device, uint16_t* gain_level)
{
 80212a4:	b510      	push	{r4, lr}
 80212a6:	460c      	mov	r4, r1
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  /* Get current PGA Gain level from driver */
  *gain_level = ds_device_get_settings()->pga_rx_gain_level;
 80212a8:	f7fe feae 	bl	8020008 <ds_device_get_settings>
 80212ac:	8c43      	ldrh	r3, [r0, #34]	; 0x22
 80212ae:	8023      	strh	r3, [r4, #0]
  
  return (RADAR_ERR_OK);
}
 80212b0:	2000      	movs	r0, #0
 80212b2:	bd10      	pop	{r4, pc}

080212b4 <XMC_ERU_Enable>:
/*********************************************************************************************************************
 * API IMPLEMENTATION
 ********************************************************************************************************************/
/* Enable the clock and De-assert the ERU module from the reset state. */
void XMC_ERU_Enable(XMC_ERU_t *const eru)
{
 80212b4:	b508      	push	{r3, lr}
#if defined(XMC_ERU1)
  if (eru == XMC_ERU1)
 80212b6:	4b07      	ldr	r3, [pc, #28]	; (80212d4 <XMC_ERU_Enable+0x20>)
 80212b8:	4298      	cmp	r0, r3
 80212ba:	d000      	beq.n	80212be <XMC_ERU_Enable+0xa>
 80212bc:	bd08      	pop	{r3, pc}
  {
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_ERU1);
 80212be:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 80212c2:	f000 f925 	bl	8021510 <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_ERU1);
 80212c6:	f44f 3080 	mov.w	r0, #65536	; 0x10000
  }
#else
  XMC_UNUSED_ARG(eru);
  #endif
}
 80212ca:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  if (eru == XMC_ERU1)
  {
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_ERU1);
#endif
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_ERU1);
 80212ce:	f000 b8af 	b.w	8021430 <XMC_SCU_RESET_DeassertPeripheralReset>
 80212d2:	bf00      	nop
 80212d4:	40044000 	.word	0x40044000

080212d8 <XMC_FLASH_ClearStatus>:
void XMC_FLASH_lClearStatusCommand(void)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xf5U;
 80212d8:	4b01      	ldr	r3, [pc, #4]	; (80212e0 <XMC_FLASH_ClearStatus+0x8>)
 80212da:	22f5      	movs	r2, #245	; 0xf5
 80212dc:	601a      	str	r2, [r3, #0]
 80212de:	4770      	bx	lr
 80212e0:	0c005554 	.word	0x0c005554

080212e4 <XMC_FLASH_GetStatus>:
/*
 * This API returns the FSR register value
 */
uint32_t XMC_FLASH_GetStatus(void)
{
  return FLASH0->FSR;
 80212e4:	4a02      	ldr	r2, [pc, #8]	; (80212f0 <XMC_FLASH_GetStatus+0xc>)
 80212e6:	f241 0310 	movw	r3, #4112	; 0x1010
 80212ea:	58d0      	ldr	r0, [r2, r3]
}
 80212ec:	4770      	bx	lr
 80212ee:	bf00      	nop
 80212f0:	58001000 	.word	0x58001000

080212f4 <XMC_FLASH_ProgramPage>:
void XMC_FLASH_lClearStatusCommand(void)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xf5U;
 80212f4:	4b0f      	ldr	r3, [pc, #60]	; (8021334 <XMC_FLASH_ProgramPage+0x40>)

/*
 * This API write the PFLASH page
 */
void XMC_FLASH_ProgramPage(uint32_t *address, const uint32_t *data)
{
 80212f6:	b470      	push	{r4, r5, r6}
void XMC_FLASH_lEnterPageModeCommand(void)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = (uint32_t)0x50U;
 80212f8:	2250      	movs	r2, #80	; 0x50
void XMC_FLASH_lClearStatusCommand(void)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xf5U;
 80212fa:	24f5      	movs	r4, #245	; 0xf5
void XMC_FLASH_lLoadPageCommand(uint32_t low_word, uint32_t high_word)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x55f0U);
  *address = low_word;
 80212fc:	4e0e      	ldr	r6, [pc, #56]	; (8021338 <XMC_FLASH_ProgramPage+0x44>)
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x55f4U);
  *address = high_word;
 80212fe:	4d0f      	ldr	r5, [pc, #60]	; (802133c <XMC_FLASH_ProgramPage+0x48>)
void XMC_FLASH_lClearStatusCommand(void)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xf5U;
 8021300:	601c      	str	r4, [r3, #0]
 8021302:	f501 7480 	add.w	r4, r1, #256	; 0x100
void XMC_FLASH_lEnterPageModeCommand(void)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = (uint32_t)0x50U;
 8021306:	601a      	str	r2, [r3, #0]
  XMC_FLASH_lClearStatusCommand();  
  XMC_FLASH_lEnterPageModeCommand();

  for (idx = 0U; idx < XMC_FLASH_WORDS_PER_PAGE; idx += 2U)
  {
    XMC_FLASH_lLoadPageCommand(data[idx], data[idx + 1U]);
 8021308:	e891 000c 	ldmia.w	r1, {r2, r3}
 802130c:	3108      	adds	r1, #8
  uint32_t idx;

  XMC_FLASH_lClearStatusCommand();  
  XMC_FLASH_lEnterPageModeCommand();

  for (idx = 0U; idx < XMC_FLASH_WORDS_PER_PAGE; idx += 2U)
 802130e:	42a1      	cmp	r1, r4
void XMC_FLASH_lLoadPageCommand(uint32_t low_word, uint32_t high_word)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x55f0U);
  *address = low_word;
 8021310:	6032      	str	r2, [r6, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x55f4U);
  *address = high_word;
 8021312:	602b      	str	r3, [r5, #0]
  uint32_t idx;

  XMC_FLASH_lClearStatusCommand();  
  XMC_FLASH_lEnterPageModeCommand();

  for (idx = 0U; idx < XMC_FLASH_WORDS_PER_PAGE; idx += 2U)
 8021314:	d1f8      	bne.n	8021308 <XMC_FLASH_ProgramPage+0x14>
void XMC_FLASH_lWritePageCommand(uint32_t *page_start_address)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xaaU;
 8021316:	4907      	ldr	r1, [pc, #28]	; (8021334 <XMC_FLASH_ProgramPage+0x40>)
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0xaaa8U);
  *address = 0x55U;
 8021318:	4d09      	ldr	r5, [pc, #36]	; (8021340 <XMC_FLASH_ProgramPage+0x4c>)
  }

  XMC_FLASH_lWritePageCommand(address);    

  /* wait until the operation is completed */
  while ((FLASH0->FSR & (uint32_t)FLASH_FSR_PBUSY_Msk) != 0U){}
 802131a:	4a0a      	ldr	r2, [pc, #40]	; (8021344 <XMC_FLASH_ProgramPage+0x50>)
void XMC_FLASH_lWritePageCommand(uint32_t *page_start_address)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xaaU;
 802131c:	23aa      	movs	r3, #170	; 0xaa
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0xaaa8U);
  *address = 0x55U;
 802131e:	2655      	movs	r6, #85	; 0x55
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xa0U;
 8021320:	24a0      	movs	r4, #160	; 0xa0
void XMC_FLASH_lWritePageCommand(uint32_t *page_start_address)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xaaU;
 8021322:	600b      	str	r3, [r1, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0xaaa8U);
  *address = 0x55U;
 8021324:	602e      	str	r6, [r5, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xa0U;
 8021326:	600c      	str	r4, [r1, #0]
  address = page_start_address;
  *address = 0xaaU;
 8021328:	6003      	str	r3, [r0, #0]
  }

  XMC_FLASH_lWritePageCommand(address);    

  /* wait until the operation is completed */
  while ((FLASH0->FSR & (uint32_t)FLASH_FSR_PBUSY_Msk) != 0U){}
 802132a:	6813      	ldr	r3, [r2, #0]
 802132c:	07db      	lsls	r3, r3, #31
 802132e:	d4fc      	bmi.n	802132a <XMC_FLASH_ProgramPage+0x36>
}
 8021330:	bc70      	pop	{r4, r5, r6}
 8021332:	4770      	bx	lr
 8021334:	0c005554 	.word	0x0c005554
 8021338:	0c0055f0 	.word	0x0c0055f0
 802133c:	0c0055f4 	.word	0x0c0055f4
 8021340:	0c00aaa8 	.word	0x0c00aaa8
 8021344:	58002010 	.word	0x58002010

08021348 <XMC_FLASH_EraseSector>:
void XMC_FLASH_lClearStatusCommand(void)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xf5U;
 8021348:	4b0a      	ldr	r3, [pc, #40]	; (8021374 <XMC_FLASH_EraseSector+0x2c>)
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xaaU;
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0xaaa8U);
  *address = 0x55U;
 802134a:	490b      	ldr	r1, [pc, #44]	; (8021378 <XMC_FLASH_EraseSector+0x30>)
{
  XMC_FLASH_lClearStatusCommand();
  XMC_FLASH_lEraseSectorCommand(address);

  /* wait until the operation is completed */
  while ((FLASH0->FSR & (uint32_t)FLASH_FSR_PBUSY_Msk) != 0U){}
 802134c:	4a0b      	ldr	r2, [pc, #44]	; (802137c <XMC_FLASH_EraseSector+0x34>)

/*
 * This API erase the logical sector
 */
void XMC_FLASH_EraseSector(uint32_t *address)
{
 802134e:	b5f0      	push	{r4, r5, r6, r7, lr}
void XMC_FLASH_lEraseSectorCommand(uint32_t *sector_start_address)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xaaU;
 8021350:	25aa      	movs	r5, #170	; 0xaa
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0xaaa8U);
  *address = 0x55U;
 8021352:	2455      	movs	r4, #85	; 0x55
void XMC_FLASH_lClearStatusCommand(void)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xf5U;
 8021354:	f04f 0ef5 	mov.w	lr, #245	; 0xf5
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xaaU;
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0xaaa8U);
  *address = 0x55U;
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0x80U;
 8021358:	2780      	movs	r7, #128	; 0x80
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xaaU;
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0xaaa8U);
  *address = 0x55U;
  address = sector_start_address;
  *address = 0x30U;
 802135a:	2630      	movs	r6, #48	; 0x30
void XMC_FLASH_lClearStatusCommand(void)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xf5U;
 802135c:	f8c3 e000 	str.w	lr, [r3]
void XMC_FLASH_lEraseSectorCommand(uint32_t *sector_start_address)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xaaU;
 8021360:	601d      	str	r5, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0xaaa8U);
  *address = 0x55U;
 8021362:	600c      	str	r4, [r1, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0x80U;
 8021364:	601f      	str	r7, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xaaU;
 8021366:	601d      	str	r5, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0xaaa8U);
  *address = 0x55U;
 8021368:	600c      	str	r4, [r1, #0]
  address = sector_start_address;
  *address = 0x30U;
 802136a:	6006      	str	r6, [r0, #0]
{
  XMC_FLASH_lClearStatusCommand();
  XMC_FLASH_lEraseSectorCommand(address);

  /* wait until the operation is completed */
  while ((FLASH0->FSR & (uint32_t)FLASH_FSR_PBUSY_Msk) != 0U){}
 802136c:	6813      	ldr	r3, [r2, #0]
 802136e:	07db      	lsls	r3, r3, #31
 8021370:	d4fc      	bmi.n	802136c <XMC_FLASH_EraseSector+0x24>
}
 8021372:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8021374:	0c005554 	.word	0x0c005554
 8021378:	0c00aaa8 	.word	0x0c00aaa8
 802137c:	58002010 	.word	0x58002010

08021380 <XMC_GPIO_Init>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_GPIO_Init(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_CONFIG_t *const config)
{
 8021380:	f001 03fc 	and.w	r3, r1, #252	; 0xfc
 8021384:	4403      	add	r3, r0
 8021386:	b5f0      	push	{r4, r5, r6, r7, lr}
  XMC_ASSERT("XMC_GPIO_Init: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_Init: Invalid mode", XMC_GPIO_IsModeValid(config->mode));
 
  /* Switch to input */
  port->IOCR[pin >> 2U] &= (uint32_t)~(PORT_IOCR_PC_Msk << (PORT_IOCR_PC_Size * (pin & 0x3U)));
 8021388:	f001 0503 	and.w	r5, r1, #3
 802138c:	691e      	ldr	r6, [r3, #16]
  /* HW port control is disabled */
  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));


  /* Enable digital input */
  if (XMC_GPIO_CHECK_ANALOG_PORT(port))
 802138e:	4f1c      	ldr	r7, [pc, #112]	; (8021400 <XMC_GPIO_Init+0x80>)
{
  XMC_ASSERT("XMC_GPIO_Init: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_Init: Invalid mode", XMC_GPIO_IsModeValid(config->mode));
 
  /* Switch to input */
  port->IOCR[pin >> 2U] &= (uint32_t)~(PORT_IOCR_PC_Msk << (PORT_IOCR_PC_Size * (pin & 0x3U)));
 8021390:	00ed      	lsls	r5, r5, #3
 8021392:	24f8      	movs	r4, #248	; 0xf8
 8021394:	40ac      	lsls	r4, r5
 8021396:	ea26 0404 	bic.w	r4, r6, r4
 802139a:	611c      	str	r4, [r3, #16]

  /* HW port control is disabled */
  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
 802139c:	6f46      	ldr	r6, [r0, #116]	; 0x74
 802139e:	ea4f 0e41 	mov.w	lr, r1, lsl #1
 80213a2:	2403      	movs	r4, #3
 80213a4:	fa04 f40e 	lsl.w	r4, r4, lr
 80213a8:	ea26 0404 	bic.w	r4, r6, r4


  /* Enable digital input */
  if (XMC_GPIO_CHECK_ANALOG_PORT(port))
 80213ac:	42b8      	cmp	r0, r7
 
  /* Switch to input */
  port->IOCR[pin >> 2U] &= (uint32_t)~(PORT_IOCR_PC_Msk << (PORT_IOCR_PC_Size * (pin & 0x3U)));

  /* HW port control is disabled */
  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
 80213ae:	6744      	str	r4, [r0, #116]	; 0x74


  /* Enable digital input */
  if (XMC_GPIO_CHECK_ANALOG_PORT(port))
 80213b0:	d01d      	beq.n	80213ee <XMC_GPIO_Init+0x6e>
 80213b2:	4c14      	ldr	r4, [pc, #80]	; (8021404 <XMC_GPIO_Init+0x84>)
 80213b4:	42a0      	cmp	r0, r4
 80213b6:	d01a      	beq.n	80213ee <XMC_GPIO_Init+0x6e>
    port->PDISC &= ~(uint32_t)((uint32_t)0x1U << pin);
  }
  else
  {
    /* Set output level */
    port->OMR = (uint32_t)config->output_level << pin;
 80213b8:	6857      	ldr	r7, [r2, #4]

    /* Set output driver strength */
    port->PDR[pin >> 3U] &= (uint32_t)~(PORT_PDR_Msk << ((uint32_t)PORT_PDR_Size * ((uint32_t)pin & 0x7U)));
    port->PDR[pin >> 3U] |= (uint32_t)config->output_strength << ((uint32_t)PORT_PDR_Size * ((uint32_t)pin & 0x7U));
 80213ba:	7a16      	ldrb	r6, [r2, #8]
 80213bc:	08cc      	lsrs	r4, r1, #3
 80213be:	eb00 0484 	add.w	r4, r0, r4, lsl #2
    port->PDISC &= ~(uint32_t)((uint32_t)0x1U << pin);
  }
  else
  {
    /* Set output level */
    port->OMR = (uint32_t)config->output_level << pin;
 80213c2:	408f      	lsls	r7, r1
 80213c4:	6047      	str	r7, [r0, #4]

    /* Set output driver strength */
    port->PDR[pin >> 3U] &= (uint32_t)~(PORT_PDR_Msk << ((uint32_t)PORT_PDR_Size * ((uint32_t)pin & 0x7U)));
 80213c6:	f001 0107 	and.w	r1, r1, #7
 80213ca:	6c27      	ldr	r7, [r4, #64]	; 0x40
 80213cc:	0089      	lsls	r1, r1, #2
 80213ce:	2007      	movs	r0, #7
 80213d0:	4088      	lsls	r0, r1
 80213d2:	ea27 0000 	bic.w	r0, r7, r0
 80213d6:	6420      	str	r0, [r4, #64]	; 0x40
    port->PDR[pin >> 3U] |= (uint32_t)config->output_strength << ((uint32_t)PORT_PDR_Size * ((uint32_t)pin & 0x7U));
 80213d8:	6c20      	ldr	r0, [r4, #64]	; 0x40
 80213da:	fa06 f101 	lsl.w	r1, r6, r1
 80213de:	4301      	orrs	r1, r0
 80213e0:	6421      	str	r1, [r4, #64]	; 0x40
  }

  /* Set mode */
  port->IOCR[pin >> 2U] |= (uint32_t)config->mode << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U));
 80213e2:	7812      	ldrb	r2, [r2, #0]
 80213e4:	6919      	ldr	r1, [r3, #16]
 80213e6:	40aa      	lsls	r2, r5
 80213e8:	430a      	orrs	r2, r1
 80213ea:	611a      	str	r2, [r3, #16]
 80213ec:	bdf0      	pop	{r4, r5, r6, r7, pc}


  /* Enable digital input */
  if (XMC_GPIO_CHECK_ANALOG_PORT(port))
  {
    port->PDISC &= ~(uint32_t)((uint32_t)0x1U << pin);
 80213ee:	6e04      	ldr	r4, [r0, #96]	; 0x60
 80213f0:	2601      	movs	r6, #1
 80213f2:	fa06 f101 	lsl.w	r1, r6, r1
 80213f6:	ea24 0101 	bic.w	r1, r4, r1
 80213fa:	6601      	str	r1, [r0, #96]	; 0x60
 80213fc:	e7f1      	b.n	80213e2 <XMC_GPIO_Init+0x62>
 80213fe:	bf00      	nop
 8021400:	48028e00 	.word	0x48028e00
 8021404:	48028f00 	.word	0x48028f00

08021408 <XMC_SCU_INTERRUPT_EnableNmiRequest>:
}

/* Enables a NMI source */
void XMC_SCU_INTERRUPT_EnableNmiRequest(const uint32_t request)
{
  SCU_INTERRUPT->NMIREQEN |= (uint32_t)request;
 8021408:	4a02      	ldr	r2, [pc, #8]	; (8021414 <XMC_SCU_INTERRUPT_EnableNmiRequest+0xc>)
 802140a:	6953      	ldr	r3, [r2, #20]
 802140c:	4318      	orrs	r0, r3
 802140e:	6150      	str	r0, [r2, #20]
 8021410:	4770      	bx	lr
 8021412:	bf00      	nop
 8021414:	50004074 	.word	0x50004074

08021418 <XMC_SCU_RESET_AssertPeripheralReset>:
}

/* API to manually assert a reset request */
void XMC_SCU_RESET_AssertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
 8021418:	0f03      	lsrs	r3, r0, #28
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));

  *(uint32_t *)(&(SCU_RESET->PRSET0) + (index * 3U)) = (uint32_t)mask;
 802141a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 802141e:	4a03      	ldr	r2, [pc, #12]	; (802142c <XMC_SCU_RESET_AssertPeripheralReset+0x14>)

/* API to manually assert a reset request */
void XMC_SCU_RESET_AssertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));
 8021420:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000

  *(uint32_t *)(&(SCU_RESET->PRSET0) + (index * 3U)) = (uint32_t)mask;
 8021424:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
 8021428:	4770      	bx	lr
 802142a:	bf00      	nop
 802142c:	50004410 	.word	0x50004410

08021430 <XMC_SCU_RESET_DeassertPeripheralReset>:
}

/* API to manually de-assert a reset request */
void XMC_SCU_RESET_DeassertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
 8021430:	0f03      	lsrs	r3, r0, #28
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));

  *(uint32_t *)(&(SCU_RESET->PRCLR0) + (index * 3U)) = (uint32_t)mask;
 8021432:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8021436:	4a03      	ldr	r2, [pc, #12]	; (8021444 <XMC_SCU_RESET_DeassertPeripheralReset+0x14>)

/* API to manually de-assert a reset request */
void XMC_SCU_RESET_DeassertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));
 8021438:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000

  *(uint32_t *)(&(SCU_RESET->PRCLR0) + (index * 3U)) = (uint32_t)mask;
 802143c:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
 8021440:	4770      	bx	lr
 8021442:	bf00      	nop
 8021444:	50004414 	.word	0x50004414

08021448 <XMC_SCU_RESET_IsPeripheralResetAsserted>:
}

/* Find out if the peripheral reset is asserted */
bool XMC_SCU_RESET_IsPeripheralResetAsserted(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
 8021448:	0f03      	lsrs	r3, r0, #28
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));

  return ((*(uint32_t *)(&(SCU_RESET->PRSTAT0) + (index * 3U)) & mask) != 0U);
 802144a:	4a06      	ldr	r2, [pc, #24]	; (8021464 <XMC_SCU_RESET_IsPeripheralResetAsserted+0x1c>)
 802144c:	eb03 0343 	add.w	r3, r3, r3, lsl #1

/* Find out if the peripheral reset is asserted */
bool XMC_SCU_RESET_IsPeripheralResetAsserted(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));
 8021450:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000

  return ((*(uint32_t *)(&(SCU_RESET->PRSTAT0) + (index * 3U)) & mask) != 0U);
 8021454:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8021458:	4218      	tst	r0, r3
}
 802145a:	bf14      	ite	ne
 802145c:	2001      	movne	r0, #1
 802145e:	2000      	moveq	r0, #0
 8021460:	4770      	bx	lr
 8021462:	bf00      	nop
 8021464:	5000440c 	.word	0x5000440c

08021468 <XMC_SCU_CLOCK_SetUsbClockSource>:
}

/* API to select fUSB */
void XMC_SCU_CLOCK_SetUsbClockSource(const XMC_SCU_CLOCK_USBCLKSRC_t source)
{
  SCU_CLK->USBCLKCR = (SCU_CLK->USBCLKCR & ((uint32_t)~SCU_CLK_USBCLKCR_USBSEL_Msk)) |
 8021468:	4a03      	ldr	r2, [pc, #12]	; (8021478 <XMC_SCU_CLOCK_SetUsbClockSource+0x10>)
 802146a:	6993      	ldr	r3, [r2, #24]
 802146c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8021470:	4318      	orrs	r0, r3
 8021472:	6190      	str	r0, [r2, #24]
 8021474:	4770      	bx	lr
 8021476:	bf00      	nop
 8021478:	50004600 	.word	0x50004600

0802147c <XMC_SCU_CLOCK_SetWdtClockSource>:
}

/* API to select fWDT */
void XMC_SCU_CLOCK_SetWdtClockSource(const XMC_SCU_CLOCK_WDTCLKSRC_t source)
{
  SCU_CLK->WDTCLKCR = (SCU_CLK->WDTCLKCR & ((uint32_t)~SCU_CLK_WDTCLKCR_WDTSEL_Msk)) |
 802147c:	4a03      	ldr	r2, [pc, #12]	; (802148c <XMC_SCU_CLOCK_SetWdtClockSource+0x10>)
 802147e:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8021480:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 8021484:	4318      	orrs	r0, r3
 8021486:	6250      	str	r0, [r2, #36]	; 0x24
 8021488:	4770      	bx	lr
 802148a:	bf00      	nop
 802148c:	50004600 	.word	0x50004600

08021490 <XMC_SCU_HIB_SetRtcClockSource>:

/* API to select fRTC */
void XMC_SCU_HIB_SetRtcClockSource(const XMC_SCU_HIB_RTCCLKSRC_t source)
{ 
  /* Wait until the update of HDCR register in hibernate domain is completed */
  while((SCU_GENERAL->MIRRSTS) & SCU_GENERAL_MIRRSTS_HDCR_Msk)
 8021490:	4a05      	ldr	r2, [pc, #20]	; (80214a8 <XMC_SCU_HIB_SetRtcClockSource+0x18>)
 8021492:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
 8021496:	071b      	lsls	r3, r3, #28
 8021498:	d4fb      	bmi.n	8021492 <XMC_SCU_HIB_SetRtcClockSource+0x2>
  {
  }

  SCU_HIBERNATE->HDCR = (SCU_HIBERNATE->HDCR & ((uint32_t)~SCU_HIBERNATE_HDCR_RCS_Msk)) |
 802149a:	4a04      	ldr	r2, [pc, #16]	; (80214ac <XMC_SCU_HIB_SetRtcClockSource+0x1c>)
 802149c:	68d3      	ldr	r3, [r2, #12]
 802149e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80214a2:	4318      	orrs	r0, r3
 80214a4:	60d0      	str	r0, [r2, #12]
 80214a6:	4770      	bx	lr
 80214a8:	50004000 	.word	0x50004000
 80214ac:	50004300 	.word	0x50004300

080214b0 <XMC_SCU_CLOCK_SetUsbClockDivider>:
void XMC_SCU_CLOCK_SetUsbClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetSdmmcClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_USBCLKCR_USBDIV_Msk + 1UL)) );

  SCU_CLK->USBCLKCR = (SCU_CLK->USBCLKCR & ((uint32_t)~SCU_CLK_USBCLKCR_USBDIV_Msk)) |
 80214b0:	4a03      	ldr	r2, [pc, #12]	; (80214c0 <XMC_SCU_CLOCK_SetUsbClockDivider+0x10>)
 80214b2:	6993      	ldr	r3, [r2, #24]
                      (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_USBCLKCR_USBDIV_Pos); 
 80214b4:	3801      	subs	r0, #1
void XMC_SCU_CLOCK_SetUsbClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetSdmmcClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_USBCLKCR_USBDIV_Msk + 1UL)) );

  SCU_CLK->USBCLKCR = (SCU_CLK->USBCLKCR & ((uint32_t)~SCU_CLK_USBCLKCR_USBDIV_Msk)) |
 80214b6:	f023 0307 	bic.w	r3, r3, #7
 80214ba:	4303      	orrs	r3, r0
 80214bc:	6193      	str	r3, [r2, #24]
 80214be:	4770      	bx	lr
 80214c0:	50004600 	.word	0x50004600

080214c4 <XMC_SCU_CLOCK_SetEbuClockDivider>:
void XMC_SCU_CLOCK_SetEbuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetEbuClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_EBUCLKCR_EBUDIV_Msk + 1UL) ) );

  SCU_CLK->EBUCLKCR = (SCU_CLK->EBUCLKCR & ((uint32_t)~SCU_CLK_EBUCLKCR_EBUDIV_Msk)) |
 80214c4:	4a03      	ldr	r2, [pc, #12]	; (80214d4 <XMC_SCU_CLOCK_SetEbuClockDivider+0x10>)
 80214c6:	69d3      	ldr	r3, [r2, #28]
                      (uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_EBUCLKCR_EBUDIV_Pos);
 80214c8:	3801      	subs	r0, #1
void XMC_SCU_CLOCK_SetEbuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetEbuClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_EBUCLKCR_EBUDIV_Msk + 1UL) ) );

  SCU_CLK->EBUCLKCR = (SCU_CLK->EBUCLKCR & ((uint32_t)~SCU_CLK_EBUCLKCR_EBUDIV_Msk)) |
 80214ca:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 80214ce:	4303      	orrs	r3, r0
 80214d0:	61d3      	str	r3, [r2, #28]
 80214d2:	4770      	bx	lr
 80214d4:	50004600 	.word	0x50004600

080214d8 <XMC_SCU_CLOCK_SetWdtClockDivider>:
void XMC_SCU_CLOCK_SetWdtClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetWdtClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_WDTCLKCR_WDTDIV_Msk + 1UL) ) );

  SCU_CLK->WDTCLKCR = (SCU_CLK->WDTCLKCR & ((uint32_t)~SCU_CLK_WDTCLKCR_WDTDIV_Msk)) |
 80214d8:	4a03      	ldr	r2, [pc, #12]	; (80214e8 <XMC_SCU_CLOCK_SetWdtClockDivider+0x10>)
 80214da:	6a53      	ldr	r3, [r2, #36]	; 0x24
                      (uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_WDTCLKCR_WDTDIV_Pos);
 80214dc:	3801      	subs	r0, #1
void XMC_SCU_CLOCK_SetWdtClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetWdtClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_WDTCLKCR_WDTDIV_Msk + 1UL) ) );

  SCU_CLK->WDTCLKCR = (SCU_CLK->WDTCLKCR & ((uint32_t)~SCU_CLK_WDTCLKCR_WDTDIV_Msk)) |
 80214de:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 80214e2:	4303      	orrs	r3, r0
 80214e4:	6253      	str	r3, [r2, #36]	; 0x24
 80214e6:	4770      	bx	lr
 80214e8:	50004600 	.word	0x50004600

080214ec <XMC_SCU_CLOCK_EnableClock>:
#endif

/* API to enable a given module clock */
void XMC_SCU_CLOCK_EnableClock(const XMC_SCU_CLOCK_t clock)
{
  SCU_CLK->CLKSET = ((uint32_t)clock);
 80214ec:	4b01      	ldr	r3, [pc, #4]	; (80214f4 <XMC_SCU_CLOCK_EnableClock+0x8>)
 80214ee:	6058      	str	r0, [r3, #4]
 80214f0:	4770      	bx	lr
 80214f2:	bf00      	nop
 80214f4:	50004600 	.word	0x50004600

080214f8 <XMC_SCU_CLOCK_GatePeripheralClock>:

#if defined(CLOCK_GATING_SUPPORTED)
/* API to gate a given module clock */
void XMC_SCU_CLOCK_GatePeripheralClock(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
  uint32_t index = (peripheral & 0xf0000000UL) >> 28UL;
 80214f8:	0f03      	lsrs	r3, r0, #28
  uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);

  *(uint32_t *)((&(SCU_CLK->CGATSET0)) + (index * 3U)) = (uint32_t)mask;
 80214fa:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80214fe:	4a03      	ldr	r2, [pc, #12]	; (802150c <XMC_SCU_CLOCK_GatePeripheralClock+0x14>)
#if defined(CLOCK_GATING_SUPPORTED)
/* API to gate a given module clock */
void XMC_SCU_CLOCK_GatePeripheralClock(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
  uint32_t index = (peripheral & 0xf0000000UL) >> 28UL;
  uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);
 8021500:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000

  *(uint32_t *)((&(SCU_CLK->CGATSET0)) + (index * 3U)) = (uint32_t)mask;
 8021504:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
 8021508:	4770      	bx	lr
 802150a:	bf00      	nop
 802150c:	50004644 	.word	0x50004644

08021510 <XMC_SCU_CLOCK_UngatePeripheralClock>:
}

/* API to ungate a given module clock */
void XMC_SCU_CLOCK_UngatePeripheralClock(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
  uint32_t index = (uint32_t)((peripheral & 0xf0000000UL) >> 28UL);
 8021510:	0f03      	lsrs	r3, r0, #28
  uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);

  *(uint32_t *)(&(SCU_CLK->CGATCLR0) + (index * 3U)) = (uint32_t)mask;
 8021512:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8021516:	4a03      	ldr	r2, [pc, #12]	; (8021524 <XMC_SCU_CLOCK_UngatePeripheralClock+0x14>)

/* API to ungate a given module clock */
void XMC_SCU_CLOCK_UngatePeripheralClock(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
  uint32_t index = (uint32_t)((peripheral & 0xf0000000UL) >> 28UL);
  uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);
 8021518:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000

  *(uint32_t *)(&(SCU_CLK->CGATCLR0) + (index * 3U)) = (uint32_t)mask;
 802151c:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
 8021520:	4770      	bx	lr
 8021522:	bf00      	nop
 8021524:	50004648 	.word	0x50004648

08021528 <XMC_SCU_CLOCK_IsPeripheralClockGated>:
}

/* API to ungate a given module clock */
bool XMC_SCU_CLOCK_IsPeripheralClockGated(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
  uint32_t index = ((peripheral & 0xf0000000UL) >> 28UL);
 8021528:	0f03      	lsrs	r3, r0, #28
  uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);

  return ((*(uint32_t *)(&(SCU_CLK->CGATSTAT0) + (index * 3U)) & mask) != 0U);
 802152a:	4a06      	ldr	r2, [pc, #24]	; (8021544 <XMC_SCU_CLOCK_IsPeripheralClockGated+0x1c>)
 802152c:	eb03 0343 	add.w	r3, r3, r3, lsl #1

/* API to ungate a given module clock */
bool XMC_SCU_CLOCK_IsPeripheralClockGated(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
  uint32_t index = ((peripheral & 0xf0000000UL) >> 28UL);
  uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);
 8021530:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000

  return ((*(uint32_t *)(&(SCU_CLK->CGATSTAT0) + (index * 3U)) & mask) != 0U);
 8021534:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8021538:	4218      	tst	r0, r3
}
 802153a:	bf14      	ite	ne
 802153c:	2001      	movne	r0, #1
 802153e:	2000      	moveq	r0, #0
 8021540:	4770      	bx	lr
 8021542:	bf00      	nop
 8021544:	50004640 	.word	0x50004640

08021548 <XMC_SCU_CLOCK_StartUsbPll>:

/* API to configure USB PLL */
void XMC_SCU_CLOCK_StartUsbPll(uint32_t pdiv, uint32_t ndiv)
{
  /* Go to bypass the USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_VCOBYP_Msk;
 8021548:	4b0f      	ldr	r3, [pc, #60]	; (8021588 <XMC_SCU_CLOCK_StartUsbPll+0x40>)
 802154a:	695a      	ldr	r2, [r3, #20]
 802154c:	f042 0201 	orr.w	r2, r2, #1
 8021550:	615a      	str	r2, [r3, #20]

  /* disconnect Oscillator from USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_FINDIS_Msk;
 8021552:	695a      	ldr	r2, [r3, #20]

  /* Setup Divider settings for USB PLL */
  SCU_PLL->USBPLLCON = (uint32_t)((uint32_t)((ndiv -1U) << SCU_PLL_USBPLLCON_NDIV_Pos) |
                       (uint32_t)((pdiv - 1U) << SCU_PLL_USBPLLCON_PDIV_Pos));
 8021554:	3801      	subs	r0, #1
 8021556:	0600      	lsls	r0, r0, #24

  /* disconnect Oscillator from USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_FINDIS_Msk;

  /* Setup Divider settings for USB PLL */
  SCU_PLL->USBPLLCON = (uint32_t)((uint32_t)((ndiv -1U) << SCU_PLL_USBPLLCON_NDIV_Pos) |
 8021558:	3901      	subs	r1, #1
{
  /* Go to bypass the USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_VCOBYP_Msk;

  /* disconnect Oscillator from USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_FINDIS_Msk;
 802155a:	f042 0210 	orr.w	r2, r2, #16

  /* Setup Divider settings for USB PLL */
  SCU_PLL->USBPLLCON = (uint32_t)((uint32_t)((ndiv -1U) << SCU_PLL_USBPLLCON_NDIV_Pos) |
 802155e:	ea40 2001 	orr.w	r0, r0, r1, lsl #8
{
  /* Go to bypass the USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_VCOBYP_Msk;

  /* disconnect Oscillator from USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_FINDIS_Msk;
 8021562:	615a      	str	r2, [r3, #20]

  /* Setup Divider settings for USB PLL */
  SCU_PLL->USBPLLCON = (uint32_t)((uint32_t)((ndiv -1U) << SCU_PLL_USBPLLCON_NDIV_Pos) |
 8021564:	6158      	str	r0, [r3, #20]
                       (uint32_t)((pdiv - 1U) << SCU_PLL_USBPLLCON_PDIV_Pos));

  /* Set OSCDISCDIS */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_OSCDISCDIS_Msk;
 8021566:	695a      	ldr	r2, [r3, #20]
 8021568:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 802156c:	615a      	str	r2, [r3, #20]

  /* connect Oscillator to USB PLL */
  SCU_PLL->USBPLLCON &= (uint32_t)~SCU_PLL_USBPLLCON_FINDIS_Msk;
 802156e:	695a      	ldr	r2, [r3, #20]
 8021570:	f022 0210 	bic.w	r2, r2, #16
 8021574:	615a      	str	r2, [r3, #20]

  /* restart PLL Lock detection */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_RESLD_Msk;
 8021576:	695a      	ldr	r2, [r3, #20]
 8021578:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 802157c:	615a      	str	r2, [r3, #20]

  while ((SCU_PLL->USBPLLSTAT & SCU_PLL_USBPLLSTAT_VCOLOCK_Msk) == 0U)
 802157e:	691a      	ldr	r2, [r3, #16]
 8021580:	0752      	lsls	r2, r2, #29
 8021582:	d5fc      	bpl.n	802157e <XMC_SCU_CLOCK_StartUsbPll+0x36>
  {
    /* wait for PLL Lock */
  }

}
 8021584:	4770      	bx	lr
 8021586:	bf00      	nop
 8021588:	50004710 	.word	0x50004710

0802158c <XMC_SCU_POWER_EnableUsb>:

/* API to enable USB Phy and comparator */
void XMC_SCU_POWER_EnableUsb(void)
{
#if defined(USB_OTG_SUPPORTED)
  SCU_POWER->PWRSET = (uint32_t)(SCU_POWER_PWRSET_USBOTGEN_Msk | SCU_POWER_PWRSET_USBPHYPDQ_Msk);
 802158c:	4b02      	ldr	r3, [pc, #8]	; (8021598 <XMC_SCU_POWER_EnableUsb+0xc>)
 802158e:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 8021592:	605a      	str	r2, [r3, #4]
 8021594:	4770      	bx	lr
 8021596:	bf00      	nop
 8021598:	50004200 	.word	0x50004200

0802159c <XMC_SCU_POWER_DisableUsb>:

/* API to power down USB Phy and comparator */
void XMC_SCU_POWER_DisableUsb(void)
{
#if defined(USB_OTG_SUPPORTED)
  SCU_POWER->PWRCLR = (uint32_t)(SCU_POWER_PWRCLR_USBOTGEN_Msk | SCU_POWER_PWRSET_USBPHYPDQ_Msk);
 802159c:	4b02      	ldr	r3, [pc, #8]	; (80215a8 <XMC_SCU_POWER_DisableUsb+0xc>)
 802159e:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 80215a2:	609a      	str	r2, [r3, #8]
 80215a4:	4770      	bx	lr
 80215a6:	bf00      	nop
 80215a8:	50004200 	.word	0x50004200

080215ac <XMC_SCU_CLOCK_StartSystemPll>:
void XMC_SCU_CLOCK_StartSystemPll(XMC_SCU_CLOCK_SYSPLLCLKSRC_t source,
                                  XMC_SCU_CLOCK_SYSPLL_MODE_t mode,
                                  uint32_t pdiv,
                                  uint32_t ndiv,
                                  uint32_t kdiv)
{
 80215ac:	b5f0      	push	{r4, r5, r6, r7, lr}
 80215ae:	b083      	sub	sp, #12
void XMC_SCU_CLOCK_SetSystemPllClockSource(const XMC_SCU_CLOCK_SYSPLLCLKSRC_t source)
{
  /* Check input clock */
  if (source == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP) /* Select PLLClockSource */
  {
    SCU_PLL->PLLCON2 &= (uint32_t)~(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
 80215b0:	4c64      	ldr	r4, [pc, #400]	; (8021744 <XMC_SCU_CLOCK_StartSystemPll+0x198>)
void XMC_SCU_CLOCK_StartSystemPll(XMC_SCU_CLOCK_SYSPLLCLKSRC_t source,
                                  XMC_SCU_CLOCK_SYSPLL_MODE_t mode,
                                  uint32_t pdiv,
                                  uint32_t ndiv,
                                  uint32_t kdiv)
{
 80215b2:	9e08      	ldr	r6, [sp, #32]

/* API to select fPLL */
void XMC_SCU_CLOCK_SetSystemPllClockSource(const XMC_SCU_CLOCK_SYSPLLCLKSRC_t source)
{
  /* Check input clock */
  if (source == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP) /* Select PLLClockSource */
 80215b4:	b1c0      	cbz	r0, 80215e8 <XMC_SCU_CLOCK_StartSystemPll+0x3c>
  {
    SCU_PLL->PLLCON2 &= (uint32_t)~(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
  }
  else
  {
    SCU_PLL->PLLCON2 |= (uint32_t)(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
 80215b6:	68e0      	ldr	r0, [r4, #12]
 80215b8:	f440 7080 	orr.w	r0, r0, #256	; 0x100
 80215bc:	f040 0001 	orr.w	r0, r0, #1
  uint32_t vco_frequency; /* Q10.22, max VCO frequency = 520MHz */
  uint32_t kdiv_temp;

  XMC_SCU_CLOCK_SetSystemPllClockSource(source);

  if (mode == XMC_SCU_CLOCK_SYSPLL_MODE_NORMAL)
 80215c0:	2901      	cmp	r1, #1
  {
    SCU_PLL->PLLCON2 &= (uint32_t)~(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
  }
  else
  {
    SCU_PLL->PLLCON2 |= (uint32_t)(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
 80215c2:	60e0      	str	r0, [r4, #12]
  uint32_t vco_frequency; /* Q10.22, max VCO frequency = 520MHz */
  uint32_t kdiv_temp;

  XMC_SCU_CLOCK_SetSystemPllClockSource(source);

  if (mode == XMC_SCU_CLOCK_SYSPLL_MODE_NORMAL)
 80215c4:	f000 8086 	beq.w	80216d4 <XMC_SCU_CLOCK_StartSystemPll+0x128>

    XMC_SCU_CLOCK_StepSystemPllFrequency(kdiv);
  }
  else
  {
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K1DIV_Msk) |
 80215c8:	4a5e      	ldr	r2, [pc, #376]	; (8021744 <XMC_SCU_CLOCK_StartSystemPll+0x198>)
 80215ca:	6893      	ldr	r3, [r2, #8]
                       ((kdiv -1UL) << SCU_PLL_PLLCON1_K1DIV_Pos));
 80215cc:	3e01      	subs	r6, #1

    XMC_SCU_CLOCK_StepSystemPllFrequency(kdiv);
  }
  else
  {
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K1DIV_Msk) |
 80215ce:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80215d2:	431e      	orrs	r6, r3
 80215d4:	6096      	str	r6, [r2, #8]
                       ((kdiv -1UL) << SCU_PLL_PLLCON1_K1DIV_Pos));

    /* Switch to prescaler mode */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_VCOBYP_Msk;
 80215d6:	6853      	ldr	r3, [r2, #4]
 80215d8:	f043 0301 	orr.w	r3, r3, #1
 80215dc:	6053      	str	r3, [r2, #4]

    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOBYST_Msk) == 0U)
 80215de:	6813      	ldr	r3, [r2, #0]
 80215e0:	07db      	lsls	r3, r3, #31
 80215e2:	d5fc      	bpl.n	80215de <XMC_SCU_CLOCK_StartSystemPll+0x32>
    {
      /* wait for prescaler mode */
    }
  }
}
 80215e4:	b003      	add	sp, #12
 80215e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
void XMC_SCU_CLOCK_SetSystemPllClockSource(const XMC_SCU_CLOCK_SYSPLLCLKSRC_t source)
{
  /* Check input clock */
  if (source == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP) /* Select PLLClockSource */
  {
    SCU_PLL->PLLCON2 &= (uint32_t)~(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
 80215e8:	68e0      	ldr	r0, [r4, #12]
 80215ea:	f420 7080 	bic.w	r0, r0, #256	; 0x100
 80215ee:	f020 0001 	bic.w	r0, r0, #1
  uint32_t vco_frequency; /* Q10.22, max VCO frequency = 520MHz */
  uint32_t kdiv_temp;

  XMC_SCU_CLOCK_SetSystemPllClockSource(source);

  if (mode == XMC_SCU_CLOCK_SYSPLL_MODE_NORMAL)
 80215f2:	2901      	cmp	r1, #1
void XMC_SCU_CLOCK_SetSystemPllClockSource(const XMC_SCU_CLOCK_SYSPLLCLKSRC_t source)
{
  /* Check input clock */
  if (source == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP) /* Select PLLClockSource */
  {
    SCU_PLL->PLLCON2 &= (uint32_t)~(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
 80215f4:	60e0      	str	r0, [r4, #12]
  uint32_t vco_frequency; /* Q10.22, max VCO frequency = 520MHz */
  uint32_t kdiv_temp;

  XMC_SCU_CLOCK_SetSystemPllClockSource(source);

  if (mode == XMC_SCU_CLOCK_SYSPLL_MODE_NORMAL)
 80215f6:	d1e7      	bne.n	80215c8 <XMC_SCU_CLOCK_StartSystemPll+0x1c>
 80215f8:	e88d 000c 	stmia.w	sp, {r2, r3}
  {
    /* Calculate initial step to be close to fOFI */
    if (source == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP)
    {
      vco_frequency = (OSCHP_GetFrequency() / 1000000U) << 22;
 80215fc:	f005 fd88 	bl	8027110 <OSCHP_GetFrequency>
 8021600:	4d51      	ldr	r5, [pc, #324]	; (8021748 <XMC_SCU_CLOCK_StartSystemPll+0x19c>)
 8021602:	fba5 3500 	umull	r3, r5, r5, r0
 8021606:	e89d 000c 	ldmia.w	sp, {r2, r3}
 802160a:	0cad      	lsrs	r5, r5, #18
 802160c:	05ad      	lsls	r5, r5, #22
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
    kdiv_temp = (vco_frequency / (OFI_FREQUENCY / 1000000U)) >> 22;

    /* Switch to prescaler mode */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_VCOBYP_Msk;
 802160e:	494d      	ldr	r1, [pc, #308]	; (8021744 <XMC_SCU_CLOCK_StartSystemPll+0x198>)
    else
    {
      vco_frequency = (OFI_FREQUENCY / 1000000U) << 22;
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
    kdiv_temp = (vco_frequency / (OFI_FREQUENCY / 1000000U)) >> 22;
 8021610:	4c4e      	ldr	r4, [pc, #312]	; (802174c <XMC_SCU_CLOCK_StartSystemPll+0x1a0>)

    /* Switch to prescaler mode */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_VCOBYP_Msk;
 8021612:	684f      	ldr	r7, [r1, #4]

    /* disconnect Oscillator from PLL */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
 8021614:	484e      	ldr	r0, [pc, #312]	; (8021750 <XMC_SCU_CLOCK_StartSystemPll+0x1a4>)
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
    kdiv_temp = (vco_frequency / (OFI_FREQUENCY / 1000000U)) >> 22;

    /* Switch to prescaler mode */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_VCOBYP_Msk;
 8021616:	f047 0701 	orr.w	r7, r7, #1
 802161a:	604f      	str	r7, [r1, #4]

    /* disconnect Oscillator from PLL */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;
 802161c:	684f      	ldr	r7, [r1, #4]
 802161e:	f047 0710 	orr.w	r7, r7, #16
 8021622:	604f      	str	r7, [r1, #4]

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
 8021624:	f8d1 e008 	ldr.w	lr, [r1, #8]
    }
    else
    {
      vco_frequency = (OFI_FREQUENCY / 1000000U) << 22;
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
 8021628:	fb03 f505 	mul.w	r5, r3, r5

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
                                   SCU_PLL_PLLCON1_PDIV_Msk)) | ((ndiv - 1UL) << SCU_PLL_PLLCON1_NDIV_Pos) |
                                   ((kdiv_temp - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos) |
                                   ((pdiv - 1UL)<< SCU_PLL_PLLCON1_PDIV_Pos));
 802162c:	1e57      	subs	r7, r2, #1
    }
    else
    {
      vco_frequency = (OFI_FREQUENCY / 1000000U) << 22;
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
 802162e:	fbb5 f5f2 	udiv	r5, r5, r2

    /* disconnect Oscillator from PLL */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
 8021632:	ea0e 0000 	and.w	r0, lr, r0
    else
    {
      vco_frequency = (OFI_FREQUENCY / 1000000U) << 22;
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
    kdiv_temp = (vco_frequency / (OFI_FREQUENCY / 1000000U)) >> 22;
 8021636:	fba4 4205 	umull	r4, r2, r4, r5
 802163a:	ea40 6007 	orr.w	r0, r0, r7, lsl #24
    /* disconnect Oscillator from PLL */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
                                   SCU_PLL_PLLCON1_PDIV_Msk)) | ((ndiv - 1UL) << SCU_PLL_PLLCON1_NDIV_Pos) |
 802163e:	1e5c      	subs	r4, r3, #1
    else
    {
      vco_frequency = (OFI_FREQUENCY / 1000000U) << 22;
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
    kdiv_temp = (vco_frequency / (OFI_FREQUENCY / 1000000U)) >> 22;
 8021640:	0e93      	lsrs	r3, r2, #26
 8021642:	ea40 2004 	orr.w	r0, r0, r4, lsl #8
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
                                   SCU_PLL_PLLCON1_PDIV_Msk)) | ((ndiv - 1UL) << SCU_PLL_PLLCON1_NDIV_Pos) |
                                   ((kdiv_temp - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos) |
 8021646:	3b01      	subs	r3, #1

    /* disconnect Oscillator from PLL */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
 8021648:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
 802164c:	608b      	str	r3, [r1, #8]
                                   SCU_PLL_PLLCON1_PDIV_Msk)) | ((ndiv - 1UL) << SCU_PLL_PLLCON1_NDIV_Pos) |
                                   ((kdiv_temp - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos) |
                                   ((pdiv - 1UL)<< SCU_PLL_PLLCON1_PDIV_Pos));

    /* Set OSCDISCDIS, OSC clock remains connected to the VCO in case of loss of lock */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_OSCDISCDIS_Msk;
 802164e:	684b      	ldr	r3, [r1, #4]
 8021650:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8021654:	604b      	str	r3, [r1, #4]

    /* connect Oscillator to PLL */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_FINDIS_Msk;
 8021656:	684b      	ldr	r3, [r1, #4]
 8021658:	f023 0310 	bic.w	r3, r3, #16
 802165c:	604b      	str	r3, [r1, #4]

    /* restart PLL Lock detection */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_RESLD_Msk;
 802165e:	684b      	ldr	r3, [r1, #4]
 8021660:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8021664:	604b      	str	r3, [r1, #4]
    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk) == 0U)
 8021666:	6808      	ldr	r0, [r1, #0]
 8021668:	4b36      	ldr	r3, [pc, #216]	; (8021744 <XMC_SCU_CLOCK_StartSystemPll+0x198>)
 802166a:	0742      	lsls	r2, r0, #29
 802166c:	d5fb      	bpl.n	8021666 <XMC_SCU_CLOCK_StartSystemPll+0xba>
    {
      /* wait for PLL Lock */
    }

    /* Switch to normal mode */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_VCOBYP_Msk;
 802166e:	685a      	ldr	r2, [r3, #4]
 8021670:	f022 0201 	bic.w	r2, r2, #1
 8021674:	605a      	str	r2, [r3, #4]
    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOBYST_Msk) != 0U)
 8021676:	4619      	mov	r1, r3
 8021678:	680b      	ldr	r3, [r1, #0]
 802167a:	4a32      	ldr	r2, [pc, #200]	; (8021744 <XMC_SCU_CLOCK_StartSystemPll+0x198>)
 802167c:	f013 0401 	ands.w	r4, r3, #1
 8021680:	d1fa      	bne.n	8021678 <XMC_SCU_CLOCK_StartSystemPll+0xcc>
    {
      /* wait for normal mode */
    }

    /* Ramp up PLL frequency in steps */
    kdiv_temp = (vco_frequency / 60UL) >> 22;
 8021682:	4b34      	ldr	r3, [pc, #208]	; (8021754 <XMC_SCU_CLOCK_StartSystemPll+0x1a8>)
 8021684:	fba3 1305 	umull	r1, r3, r3, r5
 8021688:	0edb      	lsrs	r3, r3, #27
    if (kdiv < kdiv_temp)
 802168a:	429e      	cmp	r6, r3
 802168c:	d33f      	bcc.n	802170e <XMC_SCU_CLOCK_StartSystemPll+0x162>
 802168e:	4f32      	ldr	r7, [pc, #200]	; (8021758 <XMC_SCU_CLOCK_StartSystemPll+0x1ac>)
    {
      XMC_SCU_CLOCK_StepSystemPllFrequency(kdiv_temp);
    }

    kdiv_temp = (vco_frequency / 90UL) >> 22;
 8021690:	4b32      	ldr	r3, [pc, #200]	; (802175c <XMC_SCU_CLOCK_StartSystemPll+0x1b0>)
 8021692:	086d      	lsrs	r5, r5, #1
 8021694:	fba3 2305 	umull	r2, r3, r3, r5
 8021698:	0edb      	lsrs	r3, r3, #27
    if (kdiv < kdiv_temp)
 802169a:	429e      	cmp	r6, r3
 802169c:	d31d      	bcc.n	80216da <XMC_SCU_CLOCK_StartSystemPll+0x12e>
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 802169e:	4a29      	ldr	r2, [pc, #164]	; (8021744 <XMC_SCU_CLOCK_StartSystemPll+0x198>)
 80216a0:	6893      	ldr	r3, [r2, #8]
                     ((kdiv - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos));
 80216a2:	3e01      	subs	r6, #1
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 80216a4:	f423 03fe 	bic.w	r3, r3, #8323072	; 0x7f0000
 80216a8:	ea43 4606 	orr.w	r6, r3, r6, lsl #16
 80216ac:	6096      	str	r6, [r2, #8]
/* This is a local function used to generate the delay until register get updated with new configured value.  */
void XMC_SCU_lDelay(uint32_t delay)
{
  uint32_t i;

  SystemCoreClockUpdate();
 80216ae:	f7fe fdcd 	bl	802024c <SystemCoreClockUpdate>
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 80216b2:	683b      	ldr	r3, [r7, #0]
 80216b4:	4a24      	ldr	r2, [pc, #144]	; (8021748 <XMC_SCU_CLOCK_StartSystemPll+0x19c>)
 80216b6:	fba2 3203 	umull	r3, r2, r2, r3
 80216ba:	0c92      	lsrs	r2, r2, #18
 80216bc:	2332      	movs	r3, #50	; 0x32
 80216be:	fb03 f202 	mul.w	r2, r3, r2

  for (i = 0U; i < delay; ++i)
 80216c2:	2300      	movs	r3, #0
 80216c4:	2a00      	cmp	r2, #0
 80216c6:	d08d      	beq.n	80215e4 <XMC_SCU_CLOCK_StartSystemPll+0x38>
  {
    __NOP();
 80216c8:	bf00      	nop
  uint32_t i;

  SystemCoreClockUpdate();
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);

  for (i = 0U; i < delay; ++i)
 80216ca:	3301      	adds	r3, #1
 80216cc:	4293      	cmp	r3, r2
 80216ce:	d1fb      	bne.n	80216c8 <XMC_SCU_CLOCK_StartSystemPll+0x11c>
    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOBYST_Msk) == 0U)
    {
      /* wait for prescaler mode */
    }
  }
}
 80216d0:	b003      	add	sp, #12
 80216d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    {
      vco_frequency = (OSCHP_GetFrequency() / 1000000U) << 22;
    }
    else
    {
      vco_frequency = (OFI_FREQUENCY / 1000000U) << 22;
 80216d4:	f04f 65c0 	mov.w	r5, #100663296	; 0x6000000
 80216d8:	e799      	b.n	802160e <XMC_SCU_CLOCK_StartSystemPll+0x62>
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 80216da:	491a      	ldr	r1, [pc, #104]	; (8021744 <XMC_SCU_CLOCK_StartSystemPll+0x198>)
 80216dc:	688a      	ldr	r2, [r1, #8]
                     ((kdiv - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos));
 80216de:	3b01      	subs	r3, #1
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 80216e0:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 80216e4:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
 80216e8:	608b      	str	r3, [r1, #8]
/* This is a local function used to generate the delay until register get updated with new configured value.  */
void XMC_SCU_lDelay(uint32_t delay)
{
  uint32_t i;

  SystemCoreClockUpdate();
 80216ea:	f7fe fdaf 	bl	802024c <SystemCoreClockUpdate>
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 80216ee:	683b      	ldr	r3, [r7, #0]
 80216f0:	4a15      	ldr	r2, [pc, #84]	; (8021748 <XMC_SCU_CLOCK_StartSystemPll+0x19c>)
 80216f2:	fba2 3203 	umull	r3, r2, r2, r3
 80216f6:	0c92      	lsrs	r2, r2, #18
 80216f8:	2332      	movs	r3, #50	; 0x32
 80216fa:	fb03 f202 	mul.w	r2, r3, r2

  for (i = 0U; i < delay; ++i)
 80216fe:	2a00      	cmp	r2, #0
 8021700:	d0cd      	beq.n	802169e <XMC_SCU_CLOCK_StartSystemPll+0xf2>
 8021702:	2300      	movs	r3, #0
  {
    __NOP();
 8021704:	bf00      	nop
  uint32_t i;

  SystemCoreClockUpdate();
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);

  for (i = 0U; i < delay; ++i)
 8021706:	3301      	adds	r3, #1
 8021708:	4293      	cmp	r3, r2
 802170a:	d1fb      	bne.n	8021704 <XMC_SCU_CLOCK_StartSystemPll+0x158>
 802170c:	e7c7      	b.n	802169e <XMC_SCU_CLOCK_StartSystemPll+0xf2>
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 802170e:	6891      	ldr	r1, [r2, #8]
void XMC_SCU_lDelay(uint32_t delay)
{
  uint32_t i;

  SystemCoreClockUpdate();
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 8021710:	4f11      	ldr	r7, [pc, #68]	; (8021758 <XMC_SCU_CLOCK_StartSystemPll+0x1ac>)
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 8021712:	f421 01fe 	bic.w	r1, r1, #8323072	; 0x7f0000
                     ((kdiv - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos));
 8021716:	3b01      	subs	r3, #1
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 8021718:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 802171c:	6093      	str	r3, [r2, #8]
/* This is a local function used to generate the delay until register get updated with new configured value.  */
void XMC_SCU_lDelay(uint32_t delay)
{
  uint32_t i;

  SystemCoreClockUpdate();
 802171e:	f7fe fd95 	bl	802024c <SystemCoreClockUpdate>
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 8021722:	683b      	ldr	r3, [r7, #0]
 8021724:	4a08      	ldr	r2, [pc, #32]	; (8021748 <XMC_SCU_CLOCK_StartSystemPll+0x19c>)
 8021726:	fba2 3203 	umull	r3, r2, r2, r3
 802172a:	0c92      	lsrs	r2, r2, #18
 802172c:	2332      	movs	r3, #50	; 0x32
 802172e:	fb03 f202 	mul.w	r2, r3, r2

  for (i = 0U; i < delay; ++i)
 8021732:	2a00      	cmp	r2, #0
 8021734:	d0ac      	beq.n	8021690 <XMC_SCU_CLOCK_StartSystemPll+0xe4>
 8021736:	4623      	mov	r3, r4
  {
    __NOP();
 8021738:	bf00      	nop
  uint32_t i;

  SystemCoreClockUpdate();
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);

  for (i = 0U; i < delay; ++i)
 802173a:	3301      	adds	r3, #1
 802173c:	4293      	cmp	r3, r2
 802173e:	d1fb      	bne.n	8021738 <XMC_SCU_CLOCK_StartSystemPll+0x18c>
 8021740:	e7a6      	b.n	8021690 <XMC_SCU_CLOCK_StartSystemPll+0xe4>
 8021742:	bf00      	nop
 8021744:	50004710 	.word	0x50004710
 8021748:	431bde83 	.word	0x431bde83
 802174c:	aaaaaaab 	.word	0xaaaaaaab
 8021750:	f08080ff 	.word	0xf08080ff
 8021754:	88888889 	.word	0x88888889
 8021758:	2003ffc0 	.word	0x2003ffc0
 802175c:	b60b60b7 	.word	0xb60b60b7

08021760 <XMC_SCU_CLOCK_Init>:
}

/* API to select fSYS */
void XMC_SCU_CLOCK_SetSystemClockSource(const XMC_SCU_CLOCK_SYSCLKSRC_t source)
{
  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSSEL_Msk)) |
 8021760:	4977      	ldr	r1, [pc, #476]	; (8021940 <XMC_SCU_CLOCK_Init+0x1e0>)

/* API to power up the hibernation domain */
void XMC_SCU_HIB_EnableHibernateDomain(void)
{
  /* Power up HIB domain if and only if it is currently powered down */
  if((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 8021762:	4a78      	ldr	r2, [pc, #480]	; (8021944 <XMC_SCU_CLOCK_Init+0x1e4>)
}

/* API to select fSYS */
void XMC_SCU_CLOCK_SetSystemClockSource(const XMC_SCU_CLOCK_SYSCLKSRC_t source)
{
  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSSEL_Msk)) |
 8021764:	68cb      	ldr	r3, [r1, #12]
  return (SCU_GENERAL->RMDATA);
}

/* API to initialize the clock tree */
void XMC_SCU_CLOCK_Init(const XMC_SCU_CLOCK_CONFIG_t *const config)
{
 8021766:	b5f0      	push	{r4, r5, r6, r7, lr}
}

/* API to select fSYS */
void XMC_SCU_CLOCK_SetSystemClockSource(const XMC_SCU_CLOCK_SYSCLKSRC_t source)
{
  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSSEL_Msk)) |
 8021768:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 802176c:	60cb      	str	r3, [r1, #12]

/* API to power up the hibernation domain */
void XMC_SCU_HIB_EnableHibernateDomain(void)
{
  /* Power up HIB domain if and only if it is currently powered down */
  if((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 802176e:	6813      	ldr	r3, [r2, #0]
  return (SCU_GENERAL->RMDATA);
}

/* API to initialize the clock tree */
void XMC_SCU_CLOCK_Init(const XMC_SCU_CLOCK_CONFIG_t *const config)
{
 8021770:	4605      	mov	r5, r0

/* API to power up the hibernation domain */
void XMC_SCU_HIB_EnableHibernateDomain(void)
{
  /* Power up HIB domain if and only if it is currently powered down */
  if((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 8021772:	07d8      	lsls	r0, r3, #31
  return (SCU_GENERAL->RMDATA);
}

/* API to initialize the clock tree */
void XMC_SCU_CLOCK_Init(const XMC_SCU_CLOCK_CONFIG_t *const config)
{
 8021774:	b083      	sub	sp, #12

/* API to power up the hibernation domain */
void XMC_SCU_HIB_EnableHibernateDomain(void)
{
  /* Power up HIB domain if and only if it is currently powered down */
  if((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 8021776:	d404      	bmi.n	8021782 <XMC_SCU_CLOCK_Init+0x22>
  {
    SCU_POWER->PWRSET = (uint32_t)SCU_POWER_PWRSET_HIB_Msk;
 8021778:	2301      	movs	r3, #1
 802177a:	6053      	str	r3, [r2, #4]
    
    while((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 802177c:	6813      	ldr	r3, [r2, #0]
 802177e:	07db      	lsls	r3, r3, #31
 8021780:	d5fc      	bpl.n	802177c <XMC_SCU_CLOCK_Init+0x1c>
      /* wait until HIB domain is enabled */
    }    
  }
  
  /* Remove the reset only if HIB domain were in a state of reset */
  if((SCU_RESET->RSTSTAT) & SCU_RESET_RSTSTAT_HIBRS_Msk)
 8021782:	4a71      	ldr	r2, [pc, #452]	; (8021948 <XMC_SCU_CLOCK_Init+0x1e8>)
 8021784:	6813      	ldr	r3, [r2, #0]
 8021786:	0599      	lsls	r1, r3, #22
 8021788:	d505      	bpl.n	8021796 <XMC_SCU_CLOCK_Init+0x36>
  {
    SCU_RESET->RSTCLR = (uint32_t)SCU_RESET_RSTCLR_HIBRS_Msk;
 802178a:	f44f 7300 	mov.w	r3, #512	; 0x200
 802178e:	6093      	str	r3, [r2, #8]
    while((SCU_RESET->RSTSTAT & SCU_RESET_RSTSTAT_HIBRS_Msk) != 0UL)
 8021790:	6813      	ldr	r3, [r2, #0]
 8021792:	059f      	lsls	r7, r3, #22
 8021794:	d4fc      	bmi.n	8021790 <XMC_SCU_CLOCK_Init+0x30>

  XMC_SCU_CLOCK_SetSystemClockSource(XMC_SCU_CLOCK_SYSCLKSRC_OFI);

  XMC_SCU_HIB_EnableHibernateDomain();

  if (config->enable_osculp == true)
 8021796:	79eb      	ldrb	r3, [r5, #7]
 8021798:	2b00      	cmp	r3, #0
 802179a:	f040 8091 	bne.w	80218c0 <XMC_SCU_CLOCK_Init+0x160>
  {
    XMC_SCU_CLOCK_EnableLowPowerOscillator();
    while (XMC_SCU_CLOCK_IsLowPowerOscillatorStable() == false);
  }
  
  XMC_SCU_HIB_SetStandbyClockSource(config->fstdby_clksrc);  
 802179e:	7a68      	ldrb	r0, [r5, #9]
}

/* API to select fSTDBY */
void XMC_SCU_HIB_SetStandbyClockSource(const XMC_SCU_HIB_STDBYCLKSRC_t source)
{
  while((SCU_GENERAL->MIRRSTS) & SCU_GENERAL_MIRRSTS_HDCR_Msk)
 80217a0:	4a6a      	ldr	r2, [pc, #424]	; (802194c <XMC_SCU_CLOCK_Init+0x1ec>)
 80217a2:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
 80217a6:	071b      	lsls	r3, r3, #28
 80217a8:	d4fb      	bmi.n	80217a2 <XMC_SCU_CLOCK_Init+0x42>
  {
    /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
  }
  SCU_HIBERNATE->HDCR = (SCU_HIBERNATE->HDCR & ((uint32_t)~SCU_HIBERNATE_HDCR_STDBYSEL_Msk)) |
 80217aa:	4969      	ldr	r1, [pc, #420]	; (8021950 <XMC_SCU_CLOCK_Init+0x1f0>)
 * is busy with executing the previous operation.\n
 * Note: There is no hibernate domain in XMC1x devices. This register is retained for legacy purpose.
 */
__STATIC_INLINE uint32_t XMC_SCU_GetMirrorStatus(void)
{
  return(SCU_GENERAL->MIRRSTS);
 80217ac:	4b67      	ldr	r3, [pc, #412]	; (802194c <XMC_SCU_CLOCK_Init+0x1ec>)
 80217ae:	68ca      	ldr	r2, [r1, #12]
 80217b0:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 80217b4:	4302      	orrs	r2, r0
 80217b6:	60ca      	str	r2, [r1, #12]
 80217b8:	f8d3 40c4 	ldr.w	r4, [r3, #196]	; 0xc4
    XMC_SCU_CLOCK_EnableLowPowerOscillator();
    while (XMC_SCU_CLOCK_IsLowPowerOscillatorStable() == false);
  }
  
  XMC_SCU_HIB_SetStandbyClockSource(config->fstdby_clksrc);  
  while (XMC_SCU_GetMirrorStatus() != 0)
 80217bc:	2c00      	cmp	r4, #0
 80217be:	d1fb      	bne.n	80217b8 <XMC_SCU_CLOCK_Init+0x58>

/* API to onfigure the calibration mode for internal oscillator */
void XMC_SCU_CLOCK_SetBackupClockCalibrationMode(XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_t mode)
{
  /* Enable factory calibration based trimming */
  SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FOTR_Msk;
 80217c0:	4a64      	ldr	r2, [pc, #400]	; (8021954 <XMC_SCU_CLOCK_Init+0x1f4>)
  while (XMC_SCU_GetMirrorStatus() != 0)
  {
    /* Wait until update of the stanby clock source is done in the HIB domain */    
  }

  XMC_SCU_CLOCK_SetBackupClockCalibrationMode(config->calibration_mode);
 80217c2:	7a29      	ldrb	r1, [r5, #8]

/* API to onfigure the calibration mode for internal oscillator */
void XMC_SCU_CLOCK_SetBackupClockCalibrationMode(XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_t mode)
{
  /* Enable factory calibration based trimming */
  SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FOTR_Msk;
 80217c4:	6853      	ldr	r3, [r2, #4]

  if (mode == XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_AUTOMATIC)
 80217c6:	2901      	cmp	r1, #1

/* API to onfigure the calibration mode for internal oscillator */
void XMC_SCU_CLOCK_SetBackupClockCalibrationMode(XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_t mode)
{
  /* Enable factory calibration based trimming */
  SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FOTR_Msk;
 80217c8:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80217cc:	6053      	str	r3, [r2, #4]

  if (mode == XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_AUTOMATIC)
 80217ce:	f000 809d 	beq.w	802190c <XMC_SCU_CLOCK_Init+0x1ac>
 80217d2:	4e61      	ldr	r6, [pc, #388]	; (8021958 <XMC_SCU_CLOCK_Init+0x1f8>)
/* This is a local function used to generate the delay until register get updated with new configured value.  */
void XMC_SCU_lDelay(uint32_t delay)
{
  uint32_t i;

  SystemCoreClockUpdate();
 80217d4:	f7fe fd3a 	bl	802024c <SystemCoreClockUpdate>
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 80217d8:	6833      	ldr	r3, [r6, #0]
 80217da:	4a60      	ldr	r2, [pc, #384]	; (802195c <XMC_SCU_CLOCK_Init+0x1fc>)
 80217dc:	fba2 3203 	umull	r3, r2, r2, r3
 80217e0:	0c92      	lsrs	r2, r2, #18
 80217e2:	2364      	movs	r3, #100	; 0x64
 80217e4:	fb03 f202 	mul.w	r2, r3, r2

  for (i = 0U; i < delay; ++i)
 80217e8:	b122      	cbz	r2, 80217f4 <XMC_SCU_CLOCK_Init+0x94>
 80217ea:	2300      	movs	r3, #0
  {
    __NOP();
 80217ec:	bf00      	nop
  uint32_t i;

  SystemCoreClockUpdate();
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);

  for (i = 0U; i < delay; ++i)
 80217ee:	3301      	adds	r3, #1
 80217f0:	4293      	cmp	r3, r2
 80217f2:	d1fb      	bne.n	80217ec <XMC_SCU_CLOCK_Init+0x8c>
void XMC_SCU_CLOCK_SetSystemClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetSystemClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_SYSCLKCR_SYSDIV_Msk + 1UL)) );

  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSDIV_Msk)) |
 80217f4:	4b52      	ldr	r3, [pc, #328]	; (8021940 <XMC_SCU_CLOCK_Init+0x1e0>)
    /* Wait until update of the stanby clock source is done in the HIB domain */    
  }

  XMC_SCU_CLOCK_SetBackupClockCalibrationMode(config->calibration_mode);

  XMC_SCU_CLOCK_SetSystemClockDivider((uint32_t)config->fsys_clkdiv);
 80217f6:	7c2c      	ldrb	r4, [r5, #16]
void XMC_SCU_CLOCK_SetSystemClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetSystemClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_SYSCLKCR_SYSDIV_Msk + 1UL)) );

  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSDIV_Msk)) |
 80217f8:	68da      	ldr	r2, [r3, #12]
  XMC_SCU_CLOCK_SetSystemClockDivider((uint32_t)config->fsys_clkdiv);
  XMC_SCU_CLOCK_SetCpuClockDivider((uint32_t)config->fcpu_clkdiv);
  XMC_SCU_CLOCK_SetCcuClockDivider((uint32_t)config->fccu_clkdiv);
  XMC_SCU_CLOCK_SetPeripheralClockDivider((uint32_t)config->fperipheral_clkdiv);

  if (config->enable_oschp == true)
 80217fa:	79a8      	ldrb	r0, [r5, #6]
void XMC_SCU_CLOCK_SetSystemClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetSystemClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_SYSCLKCR_SYSDIV_Msk + 1UL)) );

  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSDIV_Msk)) |
 80217fc:	f022 01ff 	bic.w	r1, r2, #255	; 0xff
                      ((uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_SYSCLKCR_SYSDIV_Pos));
 8021800:	1e62      	subs	r2, r4, #1
void XMC_SCU_CLOCK_SetSystemClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetSystemClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_SYSCLKCR_SYSDIV_Msk + 1UL)) );

  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSDIV_Msk)) |
 8021802:	430a      	orrs	r2, r1
 8021804:	60da      	str	r2, [r3, #12]
/* API to program the divider placed between fcpu and its parent */
void XMC_SCU_CLOCK_SetCpuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetCpuClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CPUCLKCR = (SCU_CLK->CPUCLKCR & ((uint32_t)~SCU_CLK_CPUCLKCR_CPUDIV_Msk)) |
 8021806:	691a      	ldr	r2, [r3, #16]
  }

  XMC_SCU_CLOCK_SetBackupClockCalibrationMode(config->calibration_mode);

  XMC_SCU_CLOCK_SetSystemClockDivider((uint32_t)config->fsys_clkdiv);
  XMC_SCU_CLOCK_SetCpuClockDivider((uint32_t)config->fcpu_clkdiv);
 8021808:	7c6c      	ldrb	r4, [r5, #17]
/* API to program the divider placed between fcpu and its parent */
void XMC_SCU_CLOCK_SetCpuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetCpuClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CPUCLKCR = (SCU_CLK->CPUCLKCR & ((uint32_t)~SCU_CLK_CPUCLKCR_CPUDIV_Msk)) |
 802180a:	f022 0101 	bic.w	r1, r2, #1
                      (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_CPUCLKCR_CPUDIV_Pos);
 802180e:	1e62      	subs	r2, r4, #1
/* API to program the divider placed between fcpu and its parent */
void XMC_SCU_CLOCK_SetCpuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetCpuClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CPUCLKCR = (SCU_CLK->CPUCLKCR & ((uint32_t)~SCU_CLK_CPUCLKCR_CPUDIV_Msk)) |
 8021810:	430a      	orrs	r2, r1
 8021812:	611a      	str	r2, [r3, #16]
/* API to program the divider placed between fccu and its parent */
void XMC_SCU_CLOCK_SetCcuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetCapcomClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CCUCLKCR = (SCU_CLK->CCUCLKCR & ((uint32_t)~SCU_CLK_CCUCLKCR_CCUDIV_Msk)) |
 8021814:	6a1a      	ldr	r2, [r3, #32]

  XMC_SCU_CLOCK_SetBackupClockCalibrationMode(config->calibration_mode);

  XMC_SCU_CLOCK_SetSystemClockDivider((uint32_t)config->fsys_clkdiv);
  XMC_SCU_CLOCK_SetCpuClockDivider((uint32_t)config->fcpu_clkdiv);
  XMC_SCU_CLOCK_SetCcuClockDivider((uint32_t)config->fccu_clkdiv);
 8021816:	7cac      	ldrb	r4, [r5, #18]
/* API to program the divider placed between fccu and its parent */
void XMC_SCU_CLOCK_SetCcuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetCapcomClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CCUCLKCR = (SCU_CLK->CCUCLKCR & ((uint32_t)~SCU_CLK_CCUCLKCR_CCUDIV_Msk)) |
 8021818:	f022 0101 	bic.w	r1, r2, #1
                      (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_CCUCLKCR_CCUDIV_Pos);
 802181c:	1e62      	subs	r2, r4, #1
/* API to program the divider placed between fccu and its parent */
void XMC_SCU_CLOCK_SetCcuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetCapcomClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CCUCLKCR = (SCU_CLK->CCUCLKCR & ((uint32_t)~SCU_CLK_CCUCLKCR_CCUDIV_Msk)) |
 802181e:	430a      	orrs	r2, r1
 8021820:	621a      	str	r2, [r3, #32]
/* API to program the divider placed between fperiph and its parent */
void XMC_SCU_CLOCK_SetPeripheralClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetPeripheralClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->PBCLKCR = (SCU_CLK->PBCLKCR & ((uint32_t)~SCU_CLK_PBCLKCR_PBDIV_Msk)) |
 8021822:	695a      	ldr	r2, [r3, #20]
  XMC_SCU_CLOCK_SetBackupClockCalibrationMode(config->calibration_mode);

  XMC_SCU_CLOCK_SetSystemClockDivider((uint32_t)config->fsys_clkdiv);
  XMC_SCU_CLOCK_SetCpuClockDivider((uint32_t)config->fcpu_clkdiv);
  XMC_SCU_CLOCK_SetCcuClockDivider((uint32_t)config->fccu_clkdiv);
  XMC_SCU_CLOCK_SetPeripheralClockDivider((uint32_t)config->fperipheral_clkdiv);
 8021824:	7cec      	ldrb	r4, [r5, #19]
/* API to program the divider placed between fperiph and its parent */
void XMC_SCU_CLOCK_SetPeripheralClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetPeripheralClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->PBCLKCR = (SCU_CLK->PBCLKCR & ((uint32_t)~SCU_CLK_PBCLKCR_PBDIV_Msk)) |
 8021826:	f022 0101 	bic.w	r1, r2, #1
                     ((uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_PBCLKCR_PBDIV_Pos));
 802182a:	1e62      	subs	r2, r4, #1
/* API to program the divider placed between fperiph and its parent */
void XMC_SCU_CLOCK_SetPeripheralClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetPeripheralClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->PBCLKCR = (SCU_CLK->PBCLKCR & ((uint32_t)~SCU_CLK_PBCLKCR_PBDIV_Msk)) |
 802182c:	430a      	orrs	r2, r1
 802182e:	615a      	str	r2, [r3, #20]
  XMC_SCU_CLOCK_SetSystemClockDivider((uint32_t)config->fsys_clkdiv);
  XMC_SCU_CLOCK_SetCpuClockDivider((uint32_t)config->fcpu_clkdiv);
  XMC_SCU_CLOCK_SetCcuClockDivider((uint32_t)config->fccu_clkdiv);
  XMC_SCU_CLOCK_SetPeripheralClockDivider((uint32_t)config->fperipheral_clkdiv);

  if (config->enable_oschp == true)
 8021830:	bb28      	cbnz	r0, 802187e <XMC_SCU_CLOCK_Init+0x11e>
  {
    XMC_SCU_CLOCK_EnableHighPerformanceOscillator();
    while(XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable() == false);
  }

  if (config->syspll_config.mode == XMC_SCU_CLOCK_SYSPLL_MODE_DISABLED)
 8021832:	78e9      	ldrb	r1, [r5, #3]
 8021834:	b9a1      	cbnz	r1, 8021860 <XMC_SCU_CLOCK_Init+0x100>
}

/* API to disable main PLL */
void XMC_SCU_CLOCK_DisableSystemPll(void)
{
  SCU_PLL->PLLCON0 |= (uint32_t)(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk);
 8021836:	4a47      	ldr	r2, [pc, #284]	; (8021954 <XMC_SCU_CLOCK_Init+0x1f4>)
 8021838:	6853      	ldr	r3, [r2, #4]
 802183a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 802183e:	f043 0302 	orr.w	r3, r3, #2
 8021842:	6053      	str	r3, [r2, #4]
                                 (uint32_t)config->syspll_config.n_div,
                                 (uint32_t)config->syspll_config.k_div);
  }

  /* use SYSPLL? */
  if (config->fsys_clksrc == XMC_SCU_CLOCK_SYSCLKSRC_PLL)
 8021844:	68eb      	ldr	r3, [r5, #12]
 8021846:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 802184a:	d104      	bne.n	8021856 <XMC_SCU_CLOCK_Init+0xf6>
}

/* API to select fSYS */
void XMC_SCU_CLOCK_SetSystemClockSource(const XMC_SCU_CLOCK_SYSCLKSRC_t source)
{
  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSSEL_Msk)) |
 802184c:	4a3c      	ldr	r2, [pc, #240]	; (8021940 <XMC_SCU_CLOCK_Init+0x1e0>)
 802184e:	68d3      	ldr	r3, [r2, #12]
 8021850:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8021854:	60d3      	str	r3, [r2, #12]
  if (config->fsys_clksrc == XMC_SCU_CLOCK_SYSCLKSRC_PLL)
  {
    XMC_SCU_CLOCK_SetSystemClockSource(XMC_SCU_CLOCK_SYSCLKSRC_PLL);    
  }
  SystemCoreClockUpdate();
}
 8021856:	b003      	add	sp, #12
 8021858:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  /* use SYSPLL? */
  if (config->fsys_clksrc == XMC_SCU_CLOCK_SYSCLKSRC_PLL)
  {
    XMC_SCU_CLOCK_SetSystemClockSource(XMC_SCU_CLOCK_SYSCLKSRC_PLL);    
  }
  SystemCoreClockUpdate();
 802185c:	f7fe bcf6 	b.w	802024c <SystemCoreClockUpdate>
}

/* API to enable main PLL */
void XMC_SCU_CLOCK_EnableSystemPll(void)
{
  SCU_PLL->PLLCON0 &= (uint32_t)~(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk);
 8021860:	4a3c      	ldr	r2, [pc, #240]	; (8021954 <XMC_SCU_CLOCK_Init+0x1f4>)
  }
  else
  {

    XMC_SCU_CLOCK_EnableSystemPll();
    XMC_SCU_CLOCK_StartSystemPll(config->syspll_config.clksrc,
 8021862:	88a8      	ldrh	r0, [r5, #4]
}

/* API to enable main PLL */
void XMC_SCU_CLOCK_EnableSystemPll(void)
{
  SCU_PLL->PLLCON0 &= (uint32_t)~(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk);
 8021864:	6853      	ldr	r3, [r2, #4]
 8021866:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 802186a:	f023 0302 	bic.w	r3, r3, #2
 802186e:	6053      	str	r3, [r2, #4]
  }
  else
  {

    XMC_SCU_CLOCK_EnableSystemPll();
    XMC_SCU_CLOCK_StartSystemPll(config->syspll_config.clksrc,
 8021870:	78ac      	ldrb	r4, [r5, #2]
 8021872:	786a      	ldrb	r2, [r5, #1]
 8021874:	782b      	ldrb	r3, [r5, #0]
 8021876:	9400      	str	r4, [sp, #0]
 8021878:	f7ff fe98 	bl	80215ac <XMC_SCU_CLOCK_StartSystemPll>
 802187c:	e7e2      	b.n	8021844 <XMC_SCU_CLOCK_Init+0xe4>
}

/* API to enable High Precision High Speed oscillator */
void XMC_SCU_CLOCK_EnableHighPerformanceOscillator(void)
{
  SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_PLLPWD_Msk;
 802187e:	4c35      	ldr	r4, [pc, #212]	; (8021954 <XMC_SCU_CLOCK_Init+0x1f4>)

  SCU_OSC->OSCHPCTRL = (uint32_t)((SCU_OSC->OSCHPCTRL & ~(SCU_OSC_OSCHPCTRL_MODE_Msk | SCU_OSC_OSCHPCTRL_OSCVAL_Msk)) |
 8021880:	4f37      	ldr	r7, [pc, #220]	; (8021960 <XMC_SCU_CLOCK_Init+0x200>)
}

/* API to enable High Precision High Speed oscillator */
void XMC_SCU_CLOCK_EnableHighPerformanceOscillator(void)
{
  SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_PLLPWD_Msk;
 8021882:	6863      	ldr	r3, [r4, #4]
 8021884:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8021888:	6063      	str	r3, [r4, #4]

  SCU_OSC->OSCHPCTRL = (uint32_t)((SCU_OSC->OSCHPCTRL & ~(SCU_OSC_OSCHPCTRL_MODE_Msk | SCU_OSC_OSCHPCTRL_OSCVAL_Msk)) |
 802188a:	687e      	ldr	r6, [r7, #4]
                                  (((OSCHP_GetFrequency() / FOSCREF) - 1UL) << SCU_OSC_OSCHPCTRL_OSCVAL_Pos));
 802188c:	f005 fc40 	bl	8027110 <OSCHP_GetFrequency>
 8021890:	4a34      	ldr	r2, [pc, #208]	; (8021964 <XMC_SCU_CLOCK_Init+0x204>)
 8021892:	fba2 3200 	umull	r3, r2, r2, r0
 8021896:	0d12      	lsrs	r2, r2, #20
/* API to enable High Precision High Speed oscillator */
void XMC_SCU_CLOCK_EnableHighPerformanceOscillator(void)
{
  SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_PLLPWD_Msk;

  SCU_OSC->OSCHPCTRL = (uint32_t)((SCU_OSC->OSCHPCTRL & ~(SCU_OSC_OSCHPCTRL_MODE_Msk | SCU_OSC_OSCHPCTRL_OSCVAL_Msk)) |
 8021898:	f426 2370 	bic.w	r3, r6, #983040	; 0xf0000
                                  (((OSCHP_GetFrequency() / FOSCREF) - 1UL) << SCU_OSC_OSCHPCTRL_OSCVAL_Pos));
 802189c:	3a01      	subs	r2, #1
/* API to enable High Precision High Speed oscillator */
void XMC_SCU_CLOCK_EnableHighPerformanceOscillator(void)
{
  SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_PLLPWD_Msk;

  SCU_OSC->OSCHPCTRL = (uint32_t)((SCU_OSC->OSCHPCTRL & ~(SCU_OSC_OSCHPCTRL_MODE_Msk | SCU_OSC_OSCHPCTRL_OSCVAL_Msk)) |
 802189e:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 80218a2:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80218a6:	607b      	str	r3, [r7, #4]
                                  (((OSCHP_GetFrequency() / FOSCREF) - 1UL) << SCU_OSC_OSCHPCTRL_OSCVAL_Pos));

  /* restart OSC Watchdog */
  SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_OSCRES_Msk;
 80218a8:	6863      	ldr	r3, [r4, #4]
 80218aa:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 80218ae:	6063      	str	r3, [r4, #4]
}

bool XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable(void)
{
  return ((SCU_PLL->PLLSTAT & XMC_SCU_PLL_PLLSTAT_OSC_USABLE) == XMC_SCU_PLL_PLLSTAT_OSC_USABLE);
 80218b0:	4622      	mov	r2, r4
 80218b2:	6813      	ldr	r3, [r2, #0]
 80218b4:	f403 7360 	and.w	r3, r3, #896	; 0x380
  XMC_SCU_CLOCK_SetPeripheralClockDivider((uint32_t)config->fperipheral_clkdiv);

  if (config->enable_oschp == true)
  {
    XMC_SCU_CLOCK_EnableHighPerformanceOscillator();
    while(XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable() == false);
 80218b8:	f5b3 7f60 	cmp.w	r3, #896	; 0x380
 80218bc:	d1f9      	bne.n	80218b2 <XMC_SCU_CLOCK_Init+0x152>
 80218be:	e7b8      	b.n	8021832 <XMC_SCU_CLOCK_Init+0xd2>

/* API to configure the 32khz Ultra Low Power oscillator */
void XMC_SCU_CLOCK_EnableLowPowerOscillator(void)
{
  /* Enable OSC_ULP */
  while((SCU_GENERAL->MIRRSTS) & SCU_GENERAL_MIRRSTS_OSCULCTRL_Msk)
 80218c0:	4a22      	ldr	r2, [pc, #136]	; (802194c <XMC_SCU_CLOCK_Init+0x1ec>)
 80218c2:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
 80218c6:	061e      	lsls	r6, r3, #24
 80218c8:	d4fb      	bmi.n	80218c2 <XMC_SCU_CLOCK_Init+0x162>
  {
    /* Wait until no pending update to OSCULCTRL register in hibernate domain */
  }
  SCU_HIBERNATE->OSCULCTRL &= ~SCU_HIBERNATE_OSCULCTRL_MODE_Msk;
 80218ca:	4921      	ldr	r1, [pc, #132]	; (8021950 <XMC_SCU_CLOCK_Init+0x1f0>)

  /* Enable OSC_ULP Oscillator Watchdog*/
  while (SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_HDCR_Msk)
 80218cc:	4a1f      	ldr	r2, [pc, #124]	; (802194c <XMC_SCU_CLOCK_Init+0x1ec>)
  /* Enable OSC_ULP */
  while((SCU_GENERAL->MIRRSTS) & SCU_GENERAL_MIRRSTS_OSCULCTRL_Msk)
  {
    /* Wait until no pending update to OSCULCTRL register in hibernate domain */
  }
  SCU_HIBERNATE->OSCULCTRL &= ~SCU_HIBERNATE_OSCULCTRL_MODE_Msk;
 80218ce:	69cb      	ldr	r3, [r1, #28]
 80218d0:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 80218d4:	61cb      	str	r3, [r1, #28]

  /* Enable OSC_ULP Oscillator Watchdog*/
  while (SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_HDCR_Msk)
 80218d6:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
 80218da:	071c      	lsls	r4, r3, #28
 80218dc:	d4fb      	bmi.n	80218d6 <XMC_SCU_CLOCK_Init+0x176>
  {
    /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
  }
  SCU_HIBERNATE->HDCR |= (uint32_t)SCU_HIBERNATE_HDCR_ULPWDGEN_Msk;
 80218de:	491c      	ldr	r1, [pc, #112]	; (8021950 <XMC_SCU_CLOCK_Init+0x1f0>)

  /* Enable OSC_ULP Oscillator Watchdog*/
  while (SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_HDSET_Msk)
 80218e0:	4a1a      	ldr	r2, [pc, #104]	; (802194c <XMC_SCU_CLOCK_Init+0x1ec>)
  /* Enable OSC_ULP Oscillator Watchdog*/
  while (SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_HDCR_Msk)
  {
    /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
  }
  SCU_HIBERNATE->HDCR |= (uint32_t)SCU_HIBERNATE_HDCR_ULPWDGEN_Msk;
 80218e2:	68cb      	ldr	r3, [r1, #12]
 80218e4:	f043 0308 	orr.w	r3, r3, #8
 80218e8:	60cb      	str	r3, [r1, #12]

  /* Enable OSC_ULP Oscillator Watchdog*/
  while (SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_HDSET_Msk)
 80218ea:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
 80218ee:	0758      	lsls	r0, r3, #29
 80218f0:	d4fb      	bmi.n	80218ea <XMC_SCU_CLOCK_Init+0x18a>
  {
    /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
  }
  SCU_HIBERNATE->HDSET = (uint32_t)SCU_HIBERNATE_HDSET_ULPWDG_Msk;
 80218f2:	4b17      	ldr	r3, [pc, #92]	; (8021950 <XMC_SCU_CLOCK_Init+0x1f0>)
 80218f4:	4a15      	ldr	r2, [pc, #84]	; (802194c <XMC_SCU_CLOCK_Init+0x1ec>)
 80218f6:	2108      	movs	r1, #8
 80218f8:	6099      	str	r1, [r3, #8]
 80218fa:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4

  while (XMC_SCU_GetMirrorStatus() != 0)
 80218fe:	2b00      	cmp	r3, #0
 8021900:	d1fb      	bne.n	80218fa <XMC_SCU_CLOCK_Init+0x19a>

#endif

bool XMC_SCU_CLOCK_IsLowPowerOscillatorStable(void)
{
  return ((SCU_HIBERNATE->HDSTAT & SCU_HIBERNATE_HDSTAT_ULPWDG_Msk) == 0UL);
 8021902:	4a13      	ldr	r2, [pc, #76]	; (8021950 <XMC_SCU_CLOCK_Init+0x1f0>)
 8021904:	6813      	ldr	r3, [r2, #0]
  XMC_SCU_HIB_EnableHibernateDomain();

  if (config->enable_osculp == true)
  {
    XMC_SCU_CLOCK_EnableLowPowerOscillator();
    while (XMC_SCU_CLOCK_IsLowPowerOscillatorStable() == false);
 8021906:	0719      	lsls	r1, r3, #28
 8021908:	d4fc      	bmi.n	8021904 <XMC_SCU_CLOCK_Init+0x1a4>
 802190a:	e748      	b.n	802179e <XMC_SCU_CLOCK_Init+0x3e>
  SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FOTR_Msk;

  if (mode == XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_AUTOMATIC)
  {
    /* Disable factory calibration based trimming */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_FOTR_Msk;
 802190c:	6853      	ldr	r3, [r2, #4]
void XMC_SCU_lDelay(uint32_t delay)
{
  uint32_t i;

  SystemCoreClockUpdate();
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 802190e:	4e12      	ldr	r6, [pc, #72]	; (8021958 <XMC_SCU_CLOCK_Init+0x1f8>)
  SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FOTR_Msk;

  if (mode == XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_AUTOMATIC)
  {
    /* Disable factory calibration based trimming */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_FOTR_Msk;
 8021910:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 8021914:	6053      	str	r3, [r2, #4]
/* This is a local function used to generate the delay until register get updated with new configured value.  */
void XMC_SCU_lDelay(uint32_t delay)
{
  uint32_t i;

  SystemCoreClockUpdate();
 8021916:	f7fe fc99 	bl	802024c <SystemCoreClockUpdate>
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 802191a:	4a10      	ldr	r2, [pc, #64]	; (802195c <XMC_SCU_CLOCK_Init+0x1fc>)
 802191c:	6833      	ldr	r3, [r6, #0]
 802191e:	fba2 2303 	umull	r2, r3, r2, r3
 8021922:	0c9a      	lsrs	r2, r3, #18
 8021924:	2364      	movs	r3, #100	; 0x64
 8021926:	fb03 f302 	mul.w	r3, r3, r2

  for (i = 0U; i < delay; ++i)
 802192a:	b11b      	cbz	r3, 8021934 <XMC_SCU_CLOCK_Init+0x1d4>
  {
    __NOP();
 802192c:	bf00      	nop
  uint32_t i;

  SystemCoreClockUpdate();
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);

  for (i = 0U; i < delay; ++i)
 802192e:	3401      	adds	r4, #1
 8021930:	429c      	cmp	r4, r3
 8021932:	d1fb      	bne.n	802192c <XMC_SCU_CLOCK_Init+0x1cc>
    /* Disable factory calibration based trimming */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_FOTR_Msk;
    XMC_SCU_lDelay(100UL);

    /* Enable automatic calibration */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_AOTREN_Msk;
 8021934:	4a07      	ldr	r2, [pc, #28]	; (8021954 <XMC_SCU_CLOCK_Init+0x1f4>)
 8021936:	6853      	ldr	r3, [r2, #4]
 8021938:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 802193c:	6053      	str	r3, [r2, #4]
 802193e:	e749      	b.n	80217d4 <XMC_SCU_CLOCK_Init+0x74>
 8021940:	50004600 	.word	0x50004600
 8021944:	50004200 	.word	0x50004200
 8021948:	50004400 	.word	0x50004400
 802194c:	50004000 	.word	0x50004000
 8021950:	50004300 	.word	0x50004300
 8021954:	50004710 	.word	0x50004710
 8021958:	2003ffc0 	.word	0x2003ffc0
 802195c:	431bde83 	.word	0x431bde83
 8021960:	50004700 	.word	0x50004700
 8021964:	6b5fca6b 	.word	0x6b5fca6b

08021968 <XMC_CCU4_Init>:
#endif
}

/* API to initialize CCU4 global resources  */
void XMC_CCU4_Init(XMC_CCU4_MODULE_t *const module, const XMC_CCU4_SLICE_MCMS_ACTION_t mcs_action)
{
 8021968:	b538      	push	{r3, r4, r5, lr}
 802196a:	4604      	mov	r4, r0
{
  XMC_ASSERT("XMC_CCU4_EnableModule:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));

#if UC_FAMILY == XMC4
  /* Enable CCU4 module clock */
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_CCU);
 802196c:	2010      	movs	r0, #16
#endif
}

/* API to initialize CCU4 global resources  */
void XMC_CCU4_Init(XMC_CCU4_MODULE_t *const module, const XMC_CCU4_SLICE_MCMS_ACTION_t mcs_action)
{
 802196e:	460d      	mov	r5, r1
{
  XMC_ASSERT("XMC_CCU4_EnableModule:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));

#if UC_FAMILY == XMC4
  /* Enable CCU4 module clock */
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_CCU);
 8021970:	f7ff fdbc 	bl	80214ec <XMC_SCU_CLOCK_EnableClock>
  }
}

__STATIC_INLINE void XMC_CCU4_lUngateClock(const XMC_CCU4_MODULE_t *const module)
{
  if (module == CCU40)
 8021974:	4b19      	ldr	r3, [pc, #100]	; (80219dc <XMC_CCU4_Init+0x74>)
 8021976:	429c      	cmp	r4, r3
 8021978:	d01a      	beq.n	80219b0 <XMC_CCU4_Init+0x48>
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU40);
  }
#if defined(CCU41)
  else if (module == CCU41)
 802197a:	4b19      	ldr	r3, [pc, #100]	; (80219e0 <XMC_CCU4_Init+0x78>)
 802197c:	429c      	cmp	r4, r3
 802197e:	d01e      	beq.n	80219be <XMC_CCU4_Init+0x56>
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU41);
  }
#endif
#if defined(CCU42)
  else if (module == CCU42)
 8021980:	4b18      	ldr	r3, [pc, #96]	; (80219e4 <XMC_CCU4_Init+0x7c>)
 8021982:	429c      	cmp	r4, r3
 8021984:	d022      	beq.n	80219cc <XMC_CCU4_Init+0x64>
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU42);
  }
#endif
#if defined(CCU43)
  else if (module == CCU43)
 8021986:	4b18      	ldr	r3, [pc, #96]	; (80219e8 <XMC_CCU4_Init+0x80>)
 8021988:	429c      	cmp	r4, r3
 802198a:	d00a      	beq.n	80219a2 <XMC_CCU4_Init+0x3a>
 * XMC_CCU4_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU4_StartPrescaler(XMC_CCU4_MODULE_t *const module)
{
  XMC_ASSERT("XMC_CCU4_StartPrescaler:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  module->GIDLC |= (uint32_t) CCU4_GIDLC_SPRB_Msk;
 802198c:	68e3      	ldr	r3, [r4, #12]
 802198e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8021992:	60e3      	str	r3, [r4, #12]
  /* Enable CCU4 module */
  XMC_CCU4_EnableModule(module);
  /* Start the prescaler */
  XMC_CCU4_StartPrescaler(module);
  
  gctrl = module->GCTRL;
 8021994:	6821      	ldr	r1, [r4, #0]
  gctrl &= ~((uint32_t) CCU4_GCTRL_MSDE_Msk);
 8021996:	f421 4140 	bic.w	r1, r1, #49152	; 0xc000
  gctrl |= ((uint32_t) mcs_action) << CCU4_GCTRL_MSDE_Pos;
 802199a:	ea41 3185 	orr.w	r1, r1, r5, lsl #14
  
  module->GCTRL = gctrl;
 802199e:	6021      	str	r1, [r4, #0]
 80219a0:	bd38      	pop	{r3, r4, r5, pc}
  }
#endif
#if defined(CCU43)
  else if (module == CCU43)
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU43);
 80219a2:	4812      	ldr	r0, [pc, #72]	; (80219ec <XMC_CCU4_Init+0x84>)
 80219a4:	f7ff fdb4 	bl	8021510 <XMC_SCU_CLOCK_UngatePeripheralClock>
  }
#endif
#if defined(CCU43)
  else if (module == CCU43)
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU43);
 80219a8:	4810      	ldr	r0, [pc, #64]	; (80219ec <XMC_CCU4_Init+0x84>)
 80219aa:	f7ff fd41 	bl	8021430 <XMC_SCU_RESET_DeassertPeripheralReset>
 80219ae:	e7ed      	b.n	802198c <XMC_CCU4_Init+0x24>

__STATIC_INLINE void XMC_CCU4_lUngateClock(const XMC_CCU4_MODULE_t *const module)
{
  if (module == CCU40)
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU40);
 80219b0:	2004      	movs	r0, #4
 80219b2:	f7ff fdad 	bl	8021510 <XMC_SCU_CLOCK_UngatePeripheralClock>

__STATIC_INLINE void XMC_CCU4_lDeassertReset(const XMC_CCU4_MODULE_t *const module)
{
  if (module == CCU40)
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU40);
 80219b6:	2004      	movs	r0, #4
 80219b8:	f7ff fd3a 	bl	8021430 <XMC_SCU_RESET_DeassertPeripheralReset>
 80219bc:	e7e6      	b.n	802198c <XMC_CCU4_Init+0x24>
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU40);
  }
#if defined(CCU41)
  else if (module == CCU41)
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU41);
 80219be:	2008      	movs	r0, #8
 80219c0:	f7ff fda6 	bl	8021510 <XMC_SCU_CLOCK_UngatePeripheralClock>
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU40);
  }
#if defined(CCU41)
  else if (module == CCU41)
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU41);
 80219c4:	2008      	movs	r0, #8
 80219c6:	f7ff fd33 	bl	8021430 <XMC_SCU_RESET_DeassertPeripheralReset>
 80219ca:	e7df      	b.n	802198c <XMC_CCU4_Init+0x24>
  }
#endif
#if defined(CCU42)
  else if (module == CCU42)
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU42);
 80219cc:	2010      	movs	r0, #16
 80219ce:	f7ff fd9f 	bl	8021510 <XMC_SCU_CLOCK_UngatePeripheralClock>
  }
#endif
#if defined(CCU42)
  else if (module == CCU42)
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU42);
 80219d2:	2010      	movs	r0, #16
 80219d4:	f7ff fd2c 	bl	8021430 <XMC_SCU_RESET_DeassertPeripheralReset>
 80219d8:	e7d8      	b.n	802198c <XMC_CCU4_Init+0x24>
 80219da:	bf00      	nop
 80219dc:	4000c000 	.word	0x4000c000
 80219e0:	40010000 	.word	0x40010000
 80219e4:	40014000 	.word	0x40014000
 80219e8:	48004000 	.word	0x48004000
 80219ec:	10000001 	.word	0x10000001

080219f0 <XMC_CCU4_SetMultiChannelShadowTransferMode>:
{
  uint32_t gctrl;

  XMC_ASSERT("XMC_CCU4_SetMultiChannelShadowTransferMode:Invalid module Pointer", XMC_CCU4_IsValidModule(module));
  
  gctrl = module->GCTRL;
 80219f0:	6802      	ldr	r2, [r0, #0]
  gctrl &= ~((uint32_t)slice_mode_msk >> 16U);
  gctrl |= ((uint32_t)slice_mode_msk & 0xFFFFU);
 80219f2:	b28b      	uxth	r3, r1
  uint32_t gctrl;

  XMC_ASSERT("XMC_CCU4_SetMultiChannelShadowTransferMode:Invalid module Pointer", XMC_CCU4_IsValidModule(module));
  
  gctrl = module->GCTRL;
  gctrl &= ~((uint32_t)slice_mode_msk >> 16U);
 80219f4:	ea22 4111 	bic.w	r1, r2, r1, lsr #16
  gctrl |= ((uint32_t)slice_mode_msk & 0xFFFFU);
 80219f8:	4319      	orrs	r1, r3
  module->GCTRL = gctrl;
 80219fa:	6001      	str	r1, [r0, #0]
 80219fc:	4770      	bx	lr
 80219fe:	bf00      	nop

08021a00 <XMC_CCU4_SLICE_CompareInit>:
}

/* API to configure CC4 Slice as Timer */
void XMC_CCU4_SLICE_CompareInit(XMC_CCU4_SLICE_t *const slice,
                                const XMC_CCU4_SLICE_COMPARE_CONFIG_t *const compare_init)
{
 8021a00:	b470      	push	{r4, r5, r6}
             (XMC_CCU4_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);

  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t) compare_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
 8021a02:	794b      	ldrb	r3, [r1, #5]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 8021a04:	790e      	ldrb	r6, [r1, #4]
  XMC_ASSERT("XMC_CCU4_SLICE_CompareInit:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_CompareInit:Compare Init Pointer is NULL",
             (XMC_CCU4_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);

  /* Program the timer mode */
  slice->TC = compare_init->tc;
 8021a06:	6809      	ldr	r1, [r1, #0]
 8021a08:	6141      	str	r1, [r0, #20]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
 8021a0a:	461c      	mov	r4, r3
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t) compare_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 8021a0c:	461d      	mov	r5, r3
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 8021a0e:	4632      	mov	r2, r6
             (XMC_CCU4_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);

  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t) compare_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
 8021a10:	f3c3 1340 	ubfx	r3, r3, #5, #1
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 8021a14:	f006 060f 	and.w	r6, r6, #15
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 8021a18:	f005 050f 	and.w	r5, r5, #15
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
 8021a1c:	f3c4 1100 	ubfx	r1, r4, #4, #1
             (XMC_CCU4_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);

  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t) compare_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
 8021a20:	051b      	lsls	r3, r3, #20
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 8021a22:	0912      	lsrs	r2, r2, #4
             (XMC_CCU4_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);

  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t) compare_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
 8021a24:	6043      	str	r3, [r0, #4]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 8021a26:	6246      	str	r6, [r0, #36]	; 0x24
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 8021a28:	6205      	str	r5, [r0, #32]
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
 8021a2a:	6181      	str	r1, [r0, #24]
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
}
 8021a2c:	bc70      	pop	{r4, r5, r6}
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 8021a2e:	62c2      	str	r2, [r0, #44]	; 0x2c
}
 8021a30:	4770      	bx	lr
 8021a32:	bf00      	nop

08021a34 <XMC_CCU4_SLICE_StartConfig>:
  XMC_ASSERT("XMC_CCU4_SLICE_StartConfig:Invalid Event ID", XMC_CCU4_SLICE_CHECK_EVENT_ID(event));
  XMC_ASSERT("XMC_CCU4_SLICE_StartConfig:Invalid Start Mode", 
             ((start_mode == XMC_CCU4_SLICE_START_MODE_TIMER_START_CLEAR) ||\
              (start_mode == XMC_CCU4_SLICE_START_MODE_TIMER_START)));
  /* First, Bind the event with the stop function */
  cmc = slice->CMC;
 8021a34:	6843      	ldr	r3, [r0, #4]
  cmc &= ~((uint32_t) CCU4_CC4_CMC_STRTS_Msk);
 8021a36:	f023 0303 	bic.w	r3, r3, #3
  cmc |= ((uint32_t) event) << CCU4_CC4_CMC_STRTS_Pos;
 8021a3a:	4319      	orrs	r1, r3

  slice->CMC = cmc;
 8021a3c:	6041      	str	r1, [r0, #4]
  
  tc  = slice->TC;
 8021a3e:	6943      	ldr	r3, [r0, #20]
  /* Next, Configure the start mode */
  if (start_mode == XMC_CCU4_SLICE_START_MODE_TIMER_START_CLEAR)
 8021a40:	2a01      	cmp	r2, #1
  {
    tc |= (uint32_t)CCU4_CC4_TC_STRM_Msk;
 8021a42:	bf0c      	ite	eq
 8021a44:	f443 6380 	orreq.w	r3, r3, #1024	; 0x400
  }
  else
  {
    tc &= ~((uint32_t)CCU4_CC4_TC_STRM_Msk);
 8021a48:	f423 6380 	bicne.w	r3, r3, #1024	; 0x400
  }
  
  slice->TC = tc;
 8021a4c:	6143      	str	r3, [r0, #20]
 8021a4e:	4770      	bx	lr

08021a50 <XMC_CCU4_SLICE_StopConfig>:
  XMC_ASSERT("XMC_CCU4_SLICE_StopConfig:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_StopConfig:Invalid Event ID", XMC_CCU4_SLICE_CHECK_EVENT_ID(event));
  XMC_ASSERT("XMC_CCU4_SLICE_StopConfig:Invalid Start Mode", XMC_CCU4_CHECK_END_MODE(end_mode));
  
  /* First, Bind the event with the stop function */
  cmc = slice->CMC;
 8021a50:	6843      	ldr	r3, [r0, #4]
  cmc &= ~((uint32_t) CCU4_CC4_CMC_ENDS_Msk);
 8021a52:	f023 030c 	bic.w	r3, r3, #12
  cmc |= ((uint32_t) event) << CCU4_CC4_CMC_ENDS_Pos;
 8021a56:	ea43 0181 	orr.w	r1, r3, r1, lsl #2

  slice->CMC = cmc;
 8021a5a:	6041      	str	r1, [r0, #4]
  
  /* Next, Configure the stop mode */
  tc = slice->TC;
 8021a5c:	6943      	ldr	r3, [r0, #20]
  tc &= ~((uint32_t) CCU4_CC4_TC_ENDM_Msk);
 8021a5e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  tc |= ((uint32_t) end_mode) << CCU4_CC4_TC_ENDM_Pos;
 8021a62:	ea43 2202 	orr.w	r2, r3, r2, lsl #8

  slice->TC = tc;
 8021a66:	6142      	str	r2, [r0, #20]
 8021a68:	4770      	bx	lr
 8021a6a:	bf00      	nop

08021a6c <XMC_CCU4_SLICE_ConfigureEvent>:
             ((config->level == XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_HIGH) ||\
              (config->level == XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_LOW)));
  XMC_ASSERT("XMC_CCU4_SLICE_ConfigureEvent:Invalid Debounce Period", 
             XMC_CCU4_SLICE_CHECK_EVENT_FILTER(config->duration));
  /* Calculate offset with reference to event */
  offset = ((uint8_t) event) - 1U;
 8021a6c:	1e4b      	subs	r3, r1, #1

/* API to configure a slice trigger event */
void XMC_CCU4_SLICE_ConfigureEvent(XMC_CCU4_SLICE_t *const slice,
                                   const XMC_CCU4_SLICE_EVENT_t event,
                                   const XMC_CCU4_SLICE_EVENT_CONFIG_t *const config)
{
 8021a6e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
             ((config->level == XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_HIGH) ||\
              (config->level == XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_LOW)));
  XMC_ASSERT("XMC_CCU4_SLICE_ConfigureEvent:Invalid Debounce Period", 
             XMC_CCU4_SLICE_CHECK_EVENT_FILTER(config->duration));
  /* Calculate offset with reference to event */
  offset = ((uint8_t) event) - 1U;
 8021a72:	b2db      	uxtb	r3, r3

#else
  ins = slice->INS;
  
  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU4_CC4_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
 8021a74:	ea4f 0843 	mov.w	r8, r3, lsl #1
 8021a78:	fa5f f888 	uxtb.w	r8, r8
 8021a7c:	f108 0910 	add.w	r9, r8, #16
  ins |= ((uint32_t) config->mapped_input) << pos;

  slice->INS1 = ins;

#else
  ins = slice->INS;
 8021a80:	6807      	ldr	r7, [r0, #0]
  
  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU4_CC4_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->edge) << pos;
 8021a82:	f892 c001 	ldrb.w	ip, [r2, #1]
  
  /* Next, the level */
  pos = ((uint8_t) CCU4_CC4_INS_EV0LM_Pos) + offset;
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->level) << pos;
 8021a86:	7896      	ldrb	r6, [r2, #2]
  
  /* Next, the debounce filter */
  pos = ((uint8_t) CCU4_CC4_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->duration) << pos;
 8021a88:	78d4      	ldrb	r4, [r2, #3]

  /* Finally the input */
  pos = ((uint8_t) CCU4_CC4_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_INPUT_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->mapped_input) << pos;
 8021a8a:	f892 e000 	ldrb.w	lr, [r2]
#else
  ins = slice->INS;
  
  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU4_CC4_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
 8021a8e:	fa5f f989 	uxtb.w	r9, r9
 8021a92:	2503      	movs	r5, #3
 8021a94:	fa05 f209 	lsl.w	r2, r5, r9
  ins |= ((uint32_t) config->edge) << pos;
  
  /* Next, the level */
  pos = ((uint8_t) CCU4_CC4_INS_EV0LM_Pos) + offset;
 8021a98:	3115      	adds	r1, #21
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
 8021a9a:	b2c9      	uxtb	r1, r1
#else
  ins = slice->INS;
  
  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU4_CC4_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
 8021a9c:	ea27 0202 	bic.w	r2, r7, r2
  ins |= ((uint32_t) config->edge) << pos;
 8021aa0:	fa0c fc09 	lsl.w	ip, ip, r9
  
  /* Next, the level */
  pos = ((uint8_t) CCU4_CC4_INS_EV0LM_Pos) + offset;
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
 8021aa4:	2701      	movs	r7, #1
  ins = slice->INS;
  
  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU4_CC4_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->edge) << pos;
 8021aa6:	ea42 0c0c 	orr.w	ip, r2, ip
  
  /* Next, the level */
  pos = ((uint8_t) CCU4_CC4_INS_EV0LM_Pos) + offset;
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
 8021aaa:	408f      	lsls	r7, r1
  ins |= ((uint32_t) config->level) << pos;
  
  /* Next, the debounce filter */
  pos = ((uint8_t) CCU4_CC4_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
 8021aac:	f108 0819 	add.w	r8, r8, #25
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
 8021ab0:	fa5f f288 	uxtb.w	r2, r8
  ins |= ((uint32_t) config->edge) << pos;
  
  /* Next, the level */
  pos = ((uint8_t) CCU4_CC4_INS_EV0LM_Pos) + offset;
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->level) << pos;
 8021ab4:	408e      	lsls	r6, r1
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->edge) << pos;
  
  /* Next, the level */
  pos = ((uint8_t) CCU4_CC4_INS_EV0LM_Pos) + offset;
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
 8021ab6:	ea2c 0707 	bic.w	r7, ip, r7
  pos = ((uint8_t) CCU4_CC4_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->duration) << pos;

  /* Finally the input */
  pos = ((uint8_t) CCU4_CC4_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
 8021aba:	0099      	lsls	r1, r3, #2
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->level) << pos;
  
  /* Next, the debounce filter */
  pos = ((uint8_t) CCU4_CC4_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
 8021abc:	4095      	lsls	r5, r2
  ins |= ((uint32_t) config->edge) << pos;
  
  /* Next, the level */
  pos = ((uint8_t) CCU4_CC4_INS_EV0LM_Pos) + offset;
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->level) << pos;
 8021abe:	433e      	orrs	r6, r7
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->duration) << pos;

  /* Finally the input */
  pos = ((uint8_t) CCU4_CC4_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_INPUT_CONFIG_MASK) << pos);
 8021ac0:	b2c9      	uxtb	r1, r1
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->level) << pos;
  
  /* Next, the debounce filter */
  pos = ((uint8_t) CCU4_CC4_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
 8021ac2:	ea26 0505 	bic.w	r5, r6, r5
  ins |= ((uint32_t) config->duration) << pos;
 8021ac6:	fa04 f202 	lsl.w	r2, r4, r2

  /* Finally the input */
  pos = ((uint8_t) CCU4_CC4_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_INPUT_CONFIG_MASK) << pos);
 8021aca:	230f      	movs	r3, #15
  ins |= ((uint32_t) config->level) << pos;
  
  /* Next, the debounce filter */
  pos = ((uint8_t) CCU4_CC4_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->duration) << pos;
 8021acc:	432a      	orrs	r2, r5

  /* Finally the input */
  pos = ((uint8_t) CCU4_CC4_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_INPUT_CONFIG_MASK) << pos);
 8021ace:	408b      	lsls	r3, r1
  ins |= ((uint32_t) config->mapped_input) << pos;
 8021ad0:	fa0e fe01 	lsl.w	lr, lr, r1
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->duration) << pos;

  /* Finally the input */
  pos = ((uint8_t) CCU4_CC4_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_INPUT_CONFIG_MASK) << pos);
 8021ad4:	ea22 0303 	bic.w	r3, r2, r3
  ins |= ((uint32_t) config->mapped_input) << pos;
 8021ad8:	ea43 030e 	orr.w	r3, r3, lr

  slice->INS = ins;
 8021adc:	6003      	str	r3, [r0, #0]
 8021ade:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8021ae2:	bf00      	nop

08021ae4 <XMC_CCU4_SLICE_SetPrescaler>:
{
  uint32_t fpc;
  
  XMC_ASSERT("XMC_CCU4_SLICE_SetPrescaler:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));

  fpc = slice->FPC;
 8021ae4:	6a83      	ldr	r3, [r0, #40]	; 0x28
  fpc &= ~((uint32_t) CCU4_CC4_FPC_PVAL_Msk);
 8021ae6:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
  fpc |= ((uint32_t) div_val) << CCU4_CC4_FPC_PVAL_Pos;
 8021aea:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  slice->FPC = fpc;
 8021aee:	6283      	str	r3, [r0, #40]	; 0x28
  /* 
   * In any case, update the initial value of the divider which is to be loaded once the prescaler increments to the 
   * compare value.
   */
  slice->PSC = (uint32_t) div_val;
 8021af0:	6241      	str	r1, [r0, #36]	; 0x24
 8021af2:	4770      	bx	lr

08021af4 <XMC_CCU4_SLICE_SetInterruptNode>:

/* Binds a capcom event to an NVIC node  */
void XMC_CCU4_SLICE_SetInterruptNode(XMC_CCU4_SLICE_t *const slice,
                                     const XMC_CCU4_SLICE_IRQ_ID_t event,
                                     const XMC_CCU4_SLICE_SR_ID_t sr)
{
 8021af4:	2909      	cmp	r1, #9
 8021af6:	b430      	push	{r4, r5}

  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid SR ID ", XMC_CCU4_SLICE_CHECK_SR_ID(sr));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  
  srs = slice->SRS;
 8021af8:	f8d0 40a8 	ldr.w	r4, [r0, #168]	; 0xa8
 8021afc:	d80d      	bhi.n	8021b1a <XMC_CCU4_SLICE_SetInterruptNode+0x26>
 8021afe:	4b09      	ldr	r3, [pc, #36]	; (8021b24 <XMC_CCU4_SLICE_SetInterruptNode+0x30>)
 8021b00:	4d09      	ldr	r5, [pc, #36]	; (8021b28 <XMC_CCU4_SLICE_SetInterruptNode+0x34>)
 8021b02:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8021b06:	f855 1021 	ldr.w	r1, [r5, r1, lsl #2]
 8021b0a:	43db      	mvns	r3, r3
      mask = ((uint32_t) CCU4_CC4_SRS_E2SR_Msk);
      pos  = CCU4_CC4_SRS_E2SR_Pos;
      break;
  }
  
  srs &= ~mask; 
 8021b0c:	4023      	ands	r3, r4
  srs |= (uint32_t)sr << pos;
 8021b0e:	408a      	lsls	r2, r1
 8021b10:	431a      	orrs	r2, r3
  slice->SRS = srs;
 8021b12:	f8c0 20a8 	str.w	r2, [r0, #168]	; 0xa8
}
 8021b16:	bc30      	pop	{r4, r5}
 8021b18:	4770      	bx	lr

  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid SR ID ", XMC_CCU4_SLICE_CHECK_SR_ID(sr));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  
  srs = slice->SRS;
 8021b1a:	210c      	movs	r1, #12
 8021b1c:	f46f 5340 	mvn.w	r3, #12288	; 0x3000
 8021b20:	e7f4      	b.n	8021b0c <XMC_CCU4_SLICE_SetInterruptNode+0x18>
 8021b22:	bf00      	nop
 8021b24:	0802abf4 	.word	0x0802abf4
 8021b28:	0802abcc 	.word	0x0802abcc

08021b2c <XMC_CCU8_Init>:
#endif
}

/* API to initialize CCU8 global resources  */
void XMC_CCU8_Init(XMC_CCU8_MODULE_t *const module, const XMC_CCU8_SLICE_MCMS_ACTION_t mcs_action)
{
 8021b2c:	b538      	push	{r3, r4, r5, lr}
 8021b2e:	4604      	mov	r4, r0
{
  XMC_ASSERT("XMC_CCU8_EnableModule:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));

#if (UC_FAMILY == XMC4)
  /* Enable CCU8 module clock */
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_CCU);
 8021b30:	2010      	movs	r0, #16
#endif
}

/* API to initialize CCU8 global resources  */
void XMC_CCU8_Init(XMC_CCU8_MODULE_t *const module, const XMC_CCU8_SLICE_MCMS_ACTION_t mcs_action)
{
 8021b32:	460d      	mov	r5, r1
{
  XMC_ASSERT("XMC_CCU8_EnableModule:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));

#if (UC_FAMILY == XMC4)
  /* Enable CCU8 module clock */
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_CCU);
 8021b34:	f7ff fcda 	bl	80214ec <XMC_SCU_CLOCK_EnableClock>
  }
}

__STATIC_INLINE void XMC_CCU8_lUngateClock(XMC_CCU8_MODULE_t *const module)
{
  if (module == CCU80)
 8021b38:	4b10      	ldr	r3, [pc, #64]	; (8021b7c <XMC_CCU8_Init+0x50>)
 8021b3a:	429c      	cmp	r4, r3
 8021b3c:	d016      	beq.n	8021b6c <XMC_CCU8_Init+0x40>
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU80);
  }
#if defined(CCU81)
  else if (module == CCU81)
 8021b3e:	4b10      	ldr	r3, [pc, #64]	; (8021b80 <XMC_CCU8_Init+0x54>)
 8021b40:	429c      	cmp	r4, r3
 8021b42:	d00a      	beq.n	8021b5a <XMC_CCU8_Init+0x2e>
 *  XMC_CCU8_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU8_StartPrescaler(XMC_CCU8_MODULE_t *const module)
{
  XMC_ASSERT("XMC_CCU8_StartPrescaler:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));
  module->GIDLC |= (uint32_t) CCU8_GIDLC_SPRB_Msk;
 8021b44:	68e3      	ldr	r3, [r4, #12]
 8021b46:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8021b4a:	60e3      	str	r3, [r4, #12]
  /* Enable CCU8 module */
  XMC_CCU8_EnableModule(module);
  /* Start the prescaler */
  XMC_CCU8_StartPrescaler(module);
  
  gctrl = module->GCTRL;
 8021b4c:	6823      	ldr	r3, [r4, #0]
  gctrl &= ~((uint32_t) CCU8_GCTRL_MSDE_Msk);
 8021b4e:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
  gctrl |= (uint32_t)mcs_action << CCU8_GCTRL_MSDE_Pos;
 8021b52:	ea43 3185 	orr.w	r1, r3, r5, lsl #14
  
  module->GCTRL = gctrl;
 8021b56:	6021      	str	r1, [r4, #0]
 8021b58:	bd38      	pop	{r3, r4, r5, pc}
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU80);
  }
#if defined(CCU81)
  else if (module == CCU81)
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU81);
 8021b5a:	f44f 7080 	mov.w	r0, #256	; 0x100
 8021b5e:	f7ff fcd7 	bl	8021510 <XMC_SCU_CLOCK_UngatePeripheralClock>
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU80);
  }
#if defined(CCU81)
  else if (module == CCU81)
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU81);
 8021b62:	f44f 7080 	mov.w	r0, #256	; 0x100
 8021b66:	f7ff fc63 	bl	8021430 <XMC_SCU_RESET_DeassertPeripheralReset>
 8021b6a:	e7eb      	b.n	8021b44 <XMC_CCU8_Init+0x18>

__STATIC_INLINE void XMC_CCU8_lUngateClock(XMC_CCU8_MODULE_t *const module)
{
  if (module == CCU80)
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU80);
 8021b6c:	2080      	movs	r0, #128	; 0x80
 8021b6e:	f7ff fccf 	bl	8021510 <XMC_SCU_CLOCK_UngatePeripheralClock>

__STATIC_INLINE void XMC_CCU8_lDeassertReset(const XMC_CCU8_MODULE_t *const module)
{
  if (module == CCU80)
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU80);
 8021b72:	2080      	movs	r0, #128	; 0x80
 8021b74:	f7ff fc5c 	bl	8021430 <XMC_SCU_RESET_DeassertPeripheralReset>
 8021b78:	e7e4      	b.n	8021b44 <XMC_CCU8_Init+0x18>
 8021b7a:	bf00      	nop
 8021b7c:	40020000 	.word	0x40020000
 8021b80:	40024000 	.word	0x40024000

08021b84 <XMC_CCU8_SLICE_CompareInit>:
  /* Stops the timer */
  XMC_CCU8_SLICE_StopTimer(slice);
  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC =  (uint32_t)compare_init->timer_concatenation << CCU8_CC8_CMC_TCE_Pos;
 8021b84:	7b4b      	ldrb	r3, [r1, #13]
}

/* API to configure CC8 Slice in Compare mode */
void XMC_CCU8_SLICE_CompareInit(XMC_CCU8_SLICE_t *const slice,
                                const XMC_CCU8_SLICE_COMPARE_CONFIG_t *const compare_init)
{
 8021b86:	b470      	push	{r4, r5, r6}
  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC =  (uint32_t)compare_init->timer_concatenation << CCU8_CC8_CMC_TCE_Pos;
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 8021b88:	7b0d      	ldrb	r5, [r1, #12]
 *  XMC_CCU8_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_StopTimer(XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_StopTimer:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU8_CC8_TCCLR_TRBC_Msk;
 8021b8a:	2601      	movs	r6, #1
 8021b8c:	6106      	str	r6, [r0, #16]
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 8021b8e:	462c      	mov	r4, r5
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 8021b90:	461a      	mov	r2, r3
  /* Stops the timer */
  XMC_CCU8_SLICE_StopTimer(slice);
  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC =  (uint32_t)compare_init->timer_concatenation << CCU8_CC8_CMC_TCE_Pos;
 8021b92:	f3c3 1300 	ubfx	r3, r3, #4, #1
  XMC_ASSERT("XMC_CCU8_SLICE_CompareInit:Timer Init Pointer is NULL",
             (XMC_CCU8_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);
  /* Stops the timer */
  XMC_CCU8_SLICE_StopTimer(slice);
  /* Program the timer mode */
  slice->TC = compare_init->tc;
 8021b96:	680e      	ldr	r6, [r1, #0]
 8021b98:	6146      	str	r6, [r0, #20]
  /* Enable the timer concatenation */
  slice->CMC =  (uint32_t)compare_init->timer_concatenation << CCU8_CC8_CMC_TCE_Pos;
 8021b9a:	051b      	lsls	r3, r3, #20
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 8021b9c:	f005 050f 	and.w	r5, r5, #15
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 8021ba0:	0924      	lsrs	r4, r4, #4
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 8021ba2:	f002 020f 	and.w	r2, r2, #15
  /* Stops the timer */
  XMC_CCU8_SLICE_StopTimer(slice);
  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC =  (uint32_t)compare_init->timer_concatenation << CCU8_CC8_CMC_TCE_Pos;
 8021ba6:	6043      	str	r3, [r0, #4]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 8021ba8:	6245      	str	r5, [r0, #36]	; 0x24
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 8021baa:	62c4      	str	r4, [r0, #44]	; 0x2c
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 8021bac:	6202      	str	r2, [r0, #32]
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->psl;
 8021bae:	684b      	ldr	r3, [r1, #4]
 8021bb0:	6183      	str	r3, [r0, #24]
  /* Asymmetric PWM and Slice output routing configuration */
#if defined(CCU8V3) /* Defined for XMC1400 devices only */
  slice->CHC = (uint32_t) compare_init->chc;
#else
  slice->CHC = (uint32_t)((uint32_t)compare_init->chc ^ XMC_CCU8_SLICE_CHC_CONFIG_MASK);
 8021bb2:	688b      	ldr	r3, [r1, #8]
 8021bb4:	f083 0314 	eor.w	r3, r3, #20
 8021bb8:	6483      	str	r3, [r0, #72]	; 0x48
#endif
}
 8021bba:	bc70      	pop	{r4, r5, r6}
 8021bbc:	4770      	bx	lr
 8021bbe:	bf00      	nop

08021bc0 <XMC_CCU8_SLICE_SetTimerPeriodMatch>:

/* Programs period match value of the timer  */
void XMC_CCU8_SLICE_SetTimerPeriodMatch(XMC_CCU8_SLICE_t *const slice, const uint16_t period_val)
{
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->PRS = (uint32_t) period_val;
 8021bc0:	6341      	str	r1, [r0, #52]	; 0x34
 8021bc2:	4770      	bx	lr

08021bc4 <XMC_CCU8_SLICE_SetPrescaler>:
  uint32_t fpc;

  XMC_ASSERT("XMC_CCU8_SLICE_SetPrescaler:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));

  /* If the prescaler is not running, update directly the divider*/
  fpc = slice->FPC;
 8021bc4:	6a83      	ldr	r3, [r0, #40]	; 0x28
  fpc &= ~((uint32_t) CCU8_CC8_FPC_PVAL_Msk);
 8021bc6:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
  fpc |= ((uint32_t) div_val) << CCU8_CC8_FPC_PVAL_Pos;
 8021bca:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  slice->FPC = fpc;
 8021bce:	6283      	str	r3, [r0, #40]	; 0x28

  /*
   * In any case, update the initial value of the divider which is to be loaded once the prescaler increments to the
   * compare value.
   */
  slice->PSC = (uint32_t) div_val;
 8021bd0:	6241      	str	r1, [r0, #36]	; 0x24
 8021bd2:	4770      	bx	lr

08021bd4 <XMC_CCU8_SLICE_SetTimerCompareMatch>:
                                         const uint16_t compare_val)
{
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatch:Invalid channel", XMC_CCU8_SLICE_CHECK_COMP_CHANNEL(channel));

  if (XMC_CCU8_SLICE_COMPARE_CHANNEL_1 == channel)
 8021bd4:	b109      	cbz	r1, 8021bda <XMC_CCU8_SLICE_SetTimerCompareMatch+0x6>
  {
    slice->CR1S = (uint32_t) compare_val;
  }
  else
  {
    slice->CR2S = (uint32_t) compare_val;
 8021bd6:	6442      	str	r2, [r0, #68]	; 0x44
 8021bd8:	4770      	bx	lr
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatch:Invalid channel", XMC_CCU8_SLICE_CHECK_COMP_CHANNEL(channel));

  if (XMC_CCU8_SLICE_COMPARE_CHANNEL_1 == channel)
  {
    slice->CR1S = (uint32_t) compare_val;
 8021bda:	63c2      	str	r2, [r0, #60]	; 0x3c
 8021bdc:	4770      	bx	lr
 8021bde:	bf00      	nop

08021be0 <XMC_CCU8_SLICE_SetInterruptNode>:

/* Binds a capcom event to an NVIC node  */
void XMC_CCU8_SLICE_SetInterruptNode(XMC_CCU8_SLICE_t *const slice,
                                     const XMC_CCU8_SLICE_IRQ_ID_t event,
                                     const XMC_CCU8_SLICE_SR_ID_t sr)
{
 8021be0:	2909      	cmp	r1, #9
 8021be2:	b430      	push	{r4, r5}

  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid SR ID ", XMC_CCU8_SLICE_CHECK_SR_ID(sr));
  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid event", XMC_CCU8_SLICE_CHECK_INTERRUPT(event));

  srs = slice->SRS;
 8021be4:	f8d0 40a8 	ldr.w	r4, [r0, #168]	; 0xa8
 8021be8:	d80d      	bhi.n	8021c06 <XMC_CCU8_SLICE_SetInterruptNode+0x26>
 8021bea:	4b09      	ldr	r3, [pc, #36]	; (8021c10 <XMC_CCU8_SLICE_SetInterruptNode+0x30>)
 8021bec:	4d09      	ldr	r5, [pc, #36]	; (8021c14 <XMC_CCU8_SLICE_SetInterruptNode+0x34>)
 8021bee:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8021bf2:	f855 1021 	ldr.w	r1, [r5, r1, lsl #2]
 8021bf6:	43db      	mvns	r3, r3
      mask = ((uint32_t) CCU8_CC8_SRS_E2SR_Msk);
      pos  = CCU8_CC8_SRS_E2SR_Pos;
      break;
  }
  
  srs &= ~mask;
 8021bf8:	4023      	ands	r3, r4
  srs |= (uint32_t)sr << pos;
 8021bfa:	408a      	lsls	r2, r1
 8021bfc:	431a      	orrs	r2, r3
  
  slice->SRS = srs;
 8021bfe:	f8c0 20a8 	str.w	r2, [r0, #168]	; 0xa8
}
 8021c02:	bc30      	pop	{r4, r5}
 8021c04:	4770      	bx	lr

  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid SR ID ", XMC_CCU8_SLICE_CHECK_SR_ID(sr));
  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid event", XMC_CCU8_SLICE_CHECK_INTERRUPT(event));

  srs = slice->SRS;
 8021c06:	210c      	movs	r1, #12
 8021c08:	f46f 5340 	mvn.w	r3, #12288	; 0x3000
 8021c0c:	e7f4      	b.n	8021bf8 <XMC_CCU8_SLICE_SetInterruptNode+0x18>
 8021c0e:	bf00      	nop
 8021c10:	0802ac1c 	.word	0x0802ac1c
 8021c14:	0802ac44 	.word	0x0802ac44

08021c18 <XMC_DMA_Init>:

/* Enable GPDMA module */
void XMC_DMA_Enable(XMC_DMA_t *const dma)
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8021c18:	4b0c      	ldr	r3, [pc, #48]	; (8021c4c <XMC_DMA_Init+0x34>)
 8021c1a:	4298      	cmp	r0, r3
 * API IMPLEMENTATION
 *******************************************************************************/

/* Initialize GPDMA */
void XMC_DMA_Init(XMC_DMA_t *const dma)
{
 8021c1c:	b510      	push	{r4, lr}
 8021c1e:	4604      	mov	r4, r0

/* Enable GPDMA module */
void XMC_DMA_Enable(XMC_DMA_t *const dma)
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8021c20:	d009      	beq.n	8021c36 <XMC_DMA_Init+0x1e>
#if defined(GPDMA1)
  }
  else
  {
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_GPDMA1);
 8021c22:	480b      	ldr	r0, [pc, #44]	; (8021c50 <XMC_DMA_Init+0x38>)
 8021c24:	f7ff fc74 	bl	8021510 <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_GPDMA1);
 8021c28:	4809      	ldr	r0, [pc, #36]	; (8021c50 <XMC_DMA_Init+0x38>)
 8021c2a:	f7ff fc01 	bl	8021430 <XMC_SCU_RESET_DeassertPeripheralReset>
  }
#endif

  dma->DMACFGREG = 0x1U;
 8021c2e:	2301      	movs	r3, #1
 8021c30:	f8c4 3398 	str.w	r3, [r4, #920]	; 0x398
 8021c34:	bd10      	pop	{r4, pc}
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_GPDMA0);
 8021c36:	4807      	ldr	r0, [pc, #28]	; (8021c54 <XMC_DMA_Init+0x3c>)
 8021c38:	f7ff fc6a 	bl	8021510 <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_GPDMA0);
 8021c3c:	4805      	ldr	r0, [pc, #20]	; (8021c54 <XMC_DMA_Init+0x3c>)
 8021c3e:	f7ff fbf7 	bl	8021430 <XMC_SCU_RESET_DeassertPeripheralReset>
#endif
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_GPDMA1);
  }
#endif

  dma->DMACFGREG = 0x1U;
 8021c42:	2301      	movs	r3, #1
 8021c44:	f8c4 3398 	str.w	r3, [r4, #920]	; 0x398
 8021c48:	bd10      	pop	{r4, pc}
 8021c4a:	bf00      	nop
 8021c4c:	50014000 	.word	0x50014000
 8021c50:	20000020 	.word	0x20000020
 8021c54:	20000010 	.word	0x20000010

08021c58 <XMC_DMA_CH_Disable>:
}

/* Disable DMA channel */
void XMC_DMA_CH_Disable(XMC_DMA_t *const dma, const uint8_t channel)
{
  dma->CHENREG = (uint32_t)(0x100UL << channel);
 8021c58:	f44f 7380 	mov.w	r3, #256	; 0x100
 8021c5c:	408b      	lsls	r3, r1
 8021c5e:	2201      	movs	r2, #1
 8021c60:	f8c0 33a0 	str.w	r3, [r0, #928]	; 0x3a0
 8021c64:	408a      	lsls	r2, r1
  while((dma->CHENREG & (uint32_t)(0x1UL << channel)) != 0U)
 8021c66:	f8d0 33a0 	ldr.w	r3, [r0, #928]	; 0x3a0
 8021c6a:	421a      	tst	r2, r3
 8021c6c:	d1fb      	bne.n	8021c66 <XMC_DMA_CH_Disable+0xe>
  {
    /* wait until channel is disabled */
  }
}
 8021c6e:	4770      	bx	lr

08021c70 <XMC_DMA_CH_Init>:
  return (bool)(dma->CHENREG & ((uint32_t)1U << channel));
}

/* Initialize DMA channel */
XMC_DMA_CH_STATUS_t XMC_DMA_CH_Init(XMC_DMA_t *const dma, const uint8_t channel, const XMC_DMA_CH_CONFIG_t *const config)
{
 8021c70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
bool XMC_DMA_IsEnabled(const XMC_DMA_t *const dma)
{
  bool status;

#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8021c72:	4ba1      	ldr	r3, [pc, #644]	; (8021ef8 <XMC_DMA_CH_Init+0x288>)
 8021c74:	4298      	cmp	r0, r3
  return (bool)(dma->CHENREG & ((uint32_t)1U << channel));
}

/* Initialize DMA channel */
XMC_DMA_CH_STATUS_t XMC_DMA_CH_Init(XMC_DMA_t *const dma, const uint8_t channel, const XMC_DMA_CH_CONFIG_t *const config)
{
 8021c76:	4604      	mov	r4, r0
 8021c78:	460e      	mov	r6, r1
 8021c7a:	4615      	mov	r5, r2
bool XMC_DMA_IsEnabled(const XMC_DMA_t *const dma)
{
  bool status;

#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8021c7c:	d053      	beq.n	8021d26 <XMC_DMA_CH_Init+0xb6>
#endif
#if defined(GPDMA1)
  }
  else
  {
    status = !XMC_SCU_RESET_IsPeripheralResetAsserted(XMC_SCU_PERIPHERAL_RESET_GPDMA1);
 8021c7e:	489f      	ldr	r0, [pc, #636]	; (8021efc <XMC_DMA_CH_Init+0x28c>)
 8021c80:	f7ff fbe2 	bl	8021448 <XMC_SCU_RESET_IsPeripheralResetAsserted>
#if defined(CLOCK_GATING_SUPPORTED)
    status = status && !XMC_SCU_CLOCK_IsPeripheralClockGated(XMC_SCU_PERIPHERAL_CLOCK_GPDMA1);
 8021c84:	b108      	cbz	r0, 8021c8a <XMC_DMA_CH_Init+0x1a>
      status = XMC_DMA_CH_STATUS_BUSY;
    }
  }
  else 
  {
    status = XMC_DMA_CH_STATUS_ERROR;
 8021c86:	2001      	movs	r0, #1
 8021c88:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  }
  else
  {
    status = !XMC_SCU_RESET_IsPeripheralResetAsserted(XMC_SCU_PERIPHERAL_RESET_GPDMA1);
#if defined(CLOCK_GATING_SUPPORTED)
    status = status && !XMC_SCU_CLOCK_IsPeripheralClockGated(XMC_SCU_PERIPHERAL_CLOCK_GPDMA1);
 8021c8a:	489c      	ldr	r0, [pc, #624]	; (8021efc <XMC_DMA_CH_Init+0x28c>)
 8021c8c:	f7ff fc4c 	bl	8021528 <XMC_SCU_CLOCK_IsPeripheralClockGated>
 8021c90:	f080 0001 	eor.w	r0, r0, #1
 8021c94:	b2c0      	uxtb	r0, r0
#endif
  }
#endif

  /* DMA reset is not asserted and peripheral clock is not gated */
  if (status == true)
 8021c96:	2800      	cmp	r0, #0
 8021c98:	d0f5      	beq.n	8021c86 <XMC_DMA_CH_Init+0x16>
  {
    status = status && (dma->DMACFGREG != 0U);
 8021c9a:	f8d4 3398 	ldr.w	r3, [r4, #920]	; 0x398
{
  XMC_DMA_CH_STATUS_t status;
  uint8_t line;
  uint8_t peripheral;

  if (XMC_DMA_IsEnabled(dma) == true)
 8021c9e:	2b00      	cmp	r3, #0
 8021ca0:	d0f1      	beq.n	8021c86 <XMC_DMA_CH_Init+0x16>
}

/* Check if a DMA channel is enabled */
bool XMC_DMA_CH_IsEnabled(XMC_DMA_t *const dma, const uint8_t channel)
{
  return (bool)(dma->CHENREG & ((uint32_t)1U << channel));
 8021ca2:	f8d4 33a0 	ldr.w	r3, [r4, #928]	; 0x3a0
 8021ca6:	40f3      	lsrs	r3, r6
  uint8_t line;
  uint8_t peripheral;

  if (XMC_DMA_IsEnabled(dma) == true)
  {
    if (XMC_DMA_CH_IsEnabled(dma, channel) == false)
 8021ca8:	07db      	lsls	r3, r3, #31
 8021caa:	d501      	bpl.n	8021cb0 <XMC_DMA_CH_Init+0x40>
      status = XMC_DMA_CH_STATUS_OK;

    }
    else
    {
      status = XMC_DMA_CH_STATUS_BUSY;
 8021cac:	2002      	movs	r0, #2
 8021cae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  if (XMC_DMA_IsEnabled(dma) == true)
  {
    if (XMC_DMA_CH_IsEnabled(dma, channel) == false)
    {
      dma->CH[channel].SAR = config->src_addr;
 8021cb0:	2258      	movs	r2, #88	; 0x58
 8021cb2:	fb02 f206 	mul.w	r2, r2, r6
 8021cb6:	6869      	ldr	r1, [r5, #4]
 8021cb8:	50a1      	str	r1, [r4, r2]
 8021cba:	18a3      	adds	r3, r4, r2
      dma->CH[channel].DAR = config->dst_addr;
 8021cbc:	68a9      	ldr	r1, [r5, #8]
      dma->CH[channel].LLP = (uint32_t)config->linked_list_pointer;
      dma->CH[channel].CTLH = (uint32_t)config->block_size;
      dma->CH[channel].CTLL = config->control;

      dma->CH[channel].CFGL = (uint32_t)((uint32_t)config->priority |
 8021cbe:	7eea      	ldrb	r2, [r5, #27]
  {
    if (XMC_DMA_CH_IsEnabled(dma, channel) == false)
    {
      dma->CH[channel].SAR = config->src_addr;
      dma->CH[channel].DAR = config->dst_addr;
      dma->CH[channel].LLP = (uint32_t)config->linked_list_pointer;
 8021cc0:	f8d5 e00c 	ldr.w	lr, [r5, #12]
      dma->CH[channel].CTLH = (uint32_t)config->block_size;
 8021cc4:	8b2f      	ldrh	r7, [r5, #24]
  if (XMC_DMA_IsEnabled(dma) == true)
  {
    if (XMC_DMA_CH_IsEnabled(dma, channel) == false)
    {
      dma->CH[channel].SAR = config->src_addr;
      dma->CH[channel].DAR = config->dst_addr;
 8021cc6:	6099      	str	r1, [r3, #8]

      dma->CH[channel].CFGL = (uint32_t)((uint32_t)config->priority |
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_SRC_Msk |
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_DST_Msk);

      if ((dma == XMC_DMA0) && (channel < (uint8_t)2))
 8021cc8:	498b      	ldr	r1, [pc, #556]	; (8021ef8 <XMC_DMA_CH_Init+0x288>)
  {
    if (XMC_DMA_CH_IsEnabled(dma, channel) == false)
    {
      dma->CH[channel].SAR = config->src_addr;
      dma->CH[channel].DAR = config->dst_addr;
      dma->CH[channel].LLP = (uint32_t)config->linked_list_pointer;
 8021cca:	f8c3 e010 	str.w	lr, [r3, #16]
      dma->CH[channel].CTLH = (uint32_t)config->block_size;
 8021cce:	61df      	str	r7, [r3, #28]
      dma->CH[channel].CTLL = config->control;
 8021cd0:	6828      	ldr	r0, [r5, #0]
 8021cd2:	6198      	str	r0, [r3, #24]

      dma->CH[channel].CFGL = (uint32_t)((uint32_t)config->priority |
 8021cd4:	f442 6240 	orr.w	r2, r2, #3072	; 0xc00
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_SRC_Msk |
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_DST_Msk);

      if ((dma == XMC_DMA0) && (channel < (uint8_t)2))
 8021cd8:	428c      	cmp	r4, r1
      dma->CH[channel].DAR = config->dst_addr;
      dma->CH[channel].LLP = (uint32_t)config->linked_list_pointer;
      dma->CH[channel].CTLH = (uint32_t)config->block_size;
      dma->CH[channel].CTLL = config->control;

      dma->CH[channel].CFGL = (uint32_t)((uint32_t)config->priority |
 8021cda:	641a      	str	r2, [r3, #64]	; 0x40
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_SRC_Msk |
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_DST_Msk);

      if ((dma == XMC_DMA0) && (channel < (uint8_t)2))
 8021cdc:	d02f      	beq.n	8021d3e <XMC_DMA_CH_Init+0xce>
        /* Configure scatter and gather */
        dma->CH[channel].SGR = config->src_gather_control;
        dma->CH[channel].DSR = config->dst_scatter_control;
      }

      if (config->dst_handshaking == XMC_DMA_CH_DST_HANDSHAKING_HARDWARE)
 8021cde:	8c2b      	ldrh	r3, [r5, #32]
 8021ce0:	b923      	cbnz	r3, 8021cec <XMC_DMA_CH_Init+0x7c>
      {
        /* Hardware handshaking interface configuration */
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_M2P_DMA) ||
 8021ce2:	78ab      	ldrb	r3, [r5, #2]
 8021ce4:	f003 0350 	and.w	r3, r3, #80	; 0x50
 8021ce8:	2b10      	cmp	r3, #16
 8021cea:	d02f      	beq.n	8021d4c <XMC_DMA_CH_Init+0xdc>
          dma->CH[channel].CFGL &= (uint32_t)~GPDMA0_CH_CFGL_HS_SEL_DST_Msk;
        }
      }


      if (config->src_handshaking == XMC_DMA_CH_SRC_HANDSHAKING_HARDWARE)
 8021cec:	8bab      	ldrh	r3, [r5, #28]
 8021cee:	b923      	cbnz	r3, 8021cfa <XMC_DMA_CH_Init+0x8a>
      {
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2M_DMA) ||
 8021cf0:	78ab      	ldrb	r3, [r5, #2]
 8021cf2:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8021cf6:	2b20      	cmp	r3, #32
 8021cf8:	d053      	beq.n	8021da2 <XMC_DMA_CH_Init+0x132>
                                                           (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_ERROR));

      switch (config->transfer_type)
 8021cfa:	7eaa      	ldrb	r2, [r5, #26]

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 8021cfc:	2301      	movs	r3, #1
 8021cfe:	40b3      	lsls	r3, r6
                                                           (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_ERROR));

      switch (config->transfer_type)
 8021d00:	3a01      	subs	r2, #1

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 8021d02:	f8c4 3338 	str.w	r3, [r4, #824]	; 0x338
 8021d06:	f8c4 3340 	str.w	r3, [r4, #832]	; 0x340
 8021d0a:	f8c4 3348 	str.w	r3, [r4, #840]	; 0x348
 8021d0e:	f8c4 3350 	str.w	r3, [r4, #848]	; 0x350
 8021d12:	f8c4 3358 	str.w	r3, [r4, #856]	; 0x358
                                                           (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_ERROR));

      switch (config->transfer_type)
 8021d16:	2a07      	cmp	r2, #7
 8021d18:	d86c      	bhi.n	8021df4 <XMC_DMA_CH_Init+0x184>
 8021d1a:	e8df f002 	tbb	[pc, r2]
 8021d1e:	9e95      	.short	0x9e95
 8021d20:	8c7f766d 	.word	0x8c7f766d
 8021d24:	b4a7      	.short	0xb4a7

#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    status = !XMC_SCU_RESET_IsPeripheralResetAsserted(XMC_SCU_PERIPHERAL_RESET_GPDMA0);
 8021d26:	4876      	ldr	r0, [pc, #472]	; (8021f00 <XMC_DMA_CH_Init+0x290>)
 8021d28:	f7ff fb8e 	bl	8021448 <XMC_SCU_RESET_IsPeripheralResetAsserted>
#if defined(CLOCK_GATING_SUPPORTED)
    status = status && !XMC_SCU_CLOCK_IsPeripheralClockGated(XMC_SCU_PERIPHERAL_CLOCK_GPDMA0);
 8021d2c:	2800      	cmp	r0, #0
 8021d2e:	d1aa      	bne.n	8021c86 <XMC_DMA_CH_Init+0x16>
 8021d30:	4873      	ldr	r0, [pc, #460]	; (8021f00 <XMC_DMA_CH_Init+0x290>)
 8021d32:	f7ff fbf9 	bl	8021528 <XMC_SCU_CLOCK_IsPeripheralClockGated>
 8021d36:	f080 0001 	eor.w	r0, r0, #1
 8021d3a:	b2c0      	uxtb	r0, r0
 8021d3c:	e7ab      	b.n	8021c96 <XMC_DMA_CH_Init+0x26>

      dma->CH[channel].CFGL = (uint32_t)((uint32_t)config->priority |
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_SRC_Msk |
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_DST_Msk);

      if ((dma == XMC_DMA0) && (channel < (uint8_t)2))
 8021d3e:	2e01      	cmp	r6, #1
 8021d40:	d8cd      	bhi.n	8021cde <XMC_DMA_CH_Init+0x6e>
      {
        /* Configure scatter and gather */
        dma->CH[channel].SGR = config->src_gather_control;
 8021d42:	692a      	ldr	r2, [r5, #16]
 8021d44:	649a      	str	r2, [r3, #72]	; 0x48
        dma->CH[channel].DSR = config->dst_scatter_control;
 8021d46:	696a      	ldr	r2, [r5, #20]
 8021d48:	651a      	str	r2, [r3, #80]	; 0x50
 8021d4a:	e7c8      	b.n	8021cde <XMC_DMA_CH_Init+0x6e>
        /* Hardware handshaking interface configuration */
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_M2P_DMA) ||
            (config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2P_DMA))
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
 8021d4c:	4b6a      	ldr	r3, [pc, #424]	; (8021ef8 <XMC_DMA_CH_Init+0x288>)
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021d4e:	496d      	ldr	r1, [pc, #436]	; (8021f04 <XMC_DMA_CH_Init+0x294>)
            line = config->dst_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
          }
#endif
          peripheral = config->dst_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_DEST_PER_Pos);
 8021d50:	2258      	movs	r2, #88	; 0x58
 8021d52:	fb02 4206 	mla	r2, r2, r6, r4
        /* Hardware handshaking interface configuration */
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_M2P_DMA) ||
            (config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2P_DMA))
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
 8021d56:	429c      	cmp	r4, r3
            line = config->dst_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
          }
#endif
          peripheral = config->dst_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_DEST_PER_Pos);
 8021d58:	6c57      	ldr	r7, [r2, #68]	; 0x44
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
          {
#endif
            line = config->dst_peripheral_request & GPDMA0_CH_CFGH_PER_Msk;
 8021d5a:	f895 3022 	ldrb.w	r3, [r5, #34]	; 0x22
        /* Hardware handshaking interface configuration */
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_M2P_DMA) ||
            (config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2P_DMA))
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
 8021d5e:	f000 80b3 	beq.w	8021ec8 <XMC_DMA_CH_Init+0x258>
            line = config->dst_peripheral_request & GPDMA0_CH_CFGH_PER_Msk;
#if defined(GPDMA1)
          }
          else
          {
            line = config->dst_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
 8021d62:	f003 0003 	and.w	r0, r3, #3
          }
#endif
          peripheral = config->dst_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_DEST_PER_Pos);
 8021d66:	ea47 27c0 	orr.w	r7, r7, r0, lsl #11
 8021d6a:	6457      	str	r7, [r2, #68]	; 0x44
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
#if defined(GPDMA1)
  }
  else
  {
    DLR->SRSEL1 = ((DLR->SRSEL1 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021d6c:	68cf      	ldr	r7, [r1, #12]
 8021d6e:	ea4f 0e80 	mov.w	lr, r0, lsl #2
 8021d72:	220f      	movs	r2, #15
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 8021d74:	091b      	lsrs	r3, r3, #4
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
#if defined(GPDMA1)
  }
  else
  {
    DLR->SRSEL1 = ((DLR->SRSEL1 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021d76:	fa02 f20e 	lsl.w	r2, r2, lr
 8021d7a:	ea27 0202 	bic.w	r2, r7, r2
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 8021d7e:	fa03 f30e 	lsl.w	r3, r3, lr
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
#if defined(GPDMA1)
  }
  else
  {
    DLR->SRSEL1 = ((DLR->SRSEL1 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021d82:	4313      	orrs	r3, r2
 8021d84:	60cb      	str	r3, [r1, #12]
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
    DLR->LNEN |= (0x100UL << line);
 8021d86:	690a      	ldr	r2, [r1, #16]
 8021d88:	f44f 7380 	mov.w	r3, #256	; 0x100
 8021d8c:	4083      	lsls	r3, r0
 8021d8e:	4313      	orrs	r3, r2
 8021d90:	610b      	str	r3, [r1, #16]
#endif
          peripheral = config->dst_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_DEST_PER_Pos);
          XMC_DMA_EnableRequestLine(dma, line, peripheral);
          dma->CH[channel].CFGL &= (uint32_t)~GPDMA0_CH_CFGL_HS_SEL_DST_Msk;
 8021d92:	2358      	movs	r3, #88	; 0x58
 8021d94:	fb03 4306 	mla	r3, r3, r6, r4
 8021d98:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8021d9a:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8021d9e:	641a      	str	r2, [r3, #64]	; 0x40
 8021da0:	e7a4      	b.n	8021cec <XMC_DMA_CH_Init+0x7c>
      {
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2M_DMA) ||
            (config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2P_DMA))
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
 8021da2:	4b55      	ldr	r3, [pc, #340]	; (8021ef8 <XMC_DMA_CH_Init+0x288>)
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021da4:	4957      	ldr	r1, [pc, #348]	; (8021f04 <XMC_DMA_CH_Init+0x294>)
            line = config->src_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
          }
#endif
          peripheral = config->src_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_SRC_PER_Pos);
 8021da6:	2258      	movs	r2, #88	; 0x58
 8021da8:	fb02 4206 	mla	r2, r2, r6, r4
      {
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2M_DMA) ||
            (config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2P_DMA))
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
 8021dac:	429c      	cmp	r4, r3
            line = config->src_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
          }
#endif
          peripheral = config->src_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_SRC_PER_Pos);
 8021dae:	6c57      	ldr	r7, [r2, #68]	; 0x44
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
          {
#endif
            line = config->src_peripheral_request & GPDMA0_CH_CFGH_PER_Msk;
 8021db0:	7fab      	ldrb	r3, [r5, #30]
      {
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2M_DMA) ||
            (config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2P_DMA))
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
 8021db2:	d071      	beq.n	8021e98 <XMC_DMA_CH_Init+0x228>
            line = config->src_peripheral_request & GPDMA0_CH_CFGH_PER_Msk;
#if defined(GPDMA1)
          }
          else
          {
            line = config->src_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
 8021db4:	f003 0003 	and.w	r0, r3, #3
          }
#endif
          peripheral = config->src_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_SRC_PER_Pos);
 8021db8:	ea47 17c0 	orr.w	r7, r7, r0, lsl #7
 8021dbc:	6457      	str	r7, [r2, #68]	; 0x44
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
#if defined(GPDMA1)
  }
  else
  {
    DLR->SRSEL1 = ((DLR->SRSEL1 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021dbe:	68cf      	ldr	r7, [r1, #12]
 8021dc0:	ea4f 0e80 	mov.w	lr, r0, lsl #2
 8021dc4:	220f      	movs	r2, #15
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 8021dc6:	091b      	lsrs	r3, r3, #4
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
#if defined(GPDMA1)
  }
  else
  {
    DLR->SRSEL1 = ((DLR->SRSEL1 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021dc8:	fa02 f20e 	lsl.w	r2, r2, lr
 8021dcc:	ea27 0202 	bic.w	r2, r7, r2
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 8021dd0:	fa03 f30e 	lsl.w	r3, r3, lr
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
#if defined(GPDMA1)
  }
  else
  {
    DLR->SRSEL1 = ((DLR->SRSEL1 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021dd4:	4313      	orrs	r3, r2
 8021dd6:	60cb      	str	r3, [r1, #12]
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
    DLR->LNEN |= (0x100UL << line);
 8021dd8:	690a      	ldr	r2, [r1, #16]
 8021dda:	f44f 7380 	mov.w	r3, #256	; 0x100
 8021dde:	4083      	lsls	r3, r0
 8021de0:	4313      	orrs	r3, r2
 8021de2:	610b      	str	r3, [r1, #16]
#endif
          peripheral = config->src_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_SRC_PER_Pos);
          XMC_DMA_EnableRequestLine(dma, line, peripheral);
          dma->CH[channel].CFGL &= (uint32_t)~GPDMA0_CH_CFGL_HS_SEL_SRC_Msk;
 8021de4:	2358      	movs	r3, #88	; 0x58
 8021de6:	fb03 4306 	mla	r3, r3, r6, r4
 8021dea:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8021dec:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8021df0:	641a      	str	r2, [r3, #64]	; 0x40
 8021df2:	e782      	b.n	8021cfa <XMC_DMA_CH_Init+0x8a>

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 8021df4:	2000      	movs	r0, #0
 8021df6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_CONTIGUOUS:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)((uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk |
 8021df8:	2158      	movs	r1, #88	; 0x58
 8021dfa:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 8021dfe:	2000      	movs	r0, #0
        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_CONTIGUOUS:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)((uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk |
 8021e00:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8021e02:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 8021e06:	6423      	str	r3, [r4, #64]	; 0x40
                                              (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk);
          break;
 8021e08:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_CONTIGUOUS_DSTADR_LINKED:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_DST_EN_Msk;
 8021e0a:	2158      	movs	r1, #88	; 0x58
 8021e0c:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 8021e10:	2000      	movs	r0, #0
          dma->CH[channel].CFGL |= (uint32_t)((uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk |
                                              (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk);
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_CONTIGUOUS_DSTADR_LINKED:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_DST_EN_Msk;
 8021e12:	69a3      	ldr	r3, [r4, #24]
 8021e14:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 8021e18:	61a3      	str	r3, [r4, #24]
          break;
 8021e1a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_LINKED:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
 8021e1c:	2158      	movs	r1, #88	; 0x58
 8021e1e:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 8021e22:	2000      	movs	r0, #0
        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_CONTIGUOUS_DSTADR_LINKED:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_DST_EN_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_LINKED:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
 8021e24:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8021e26:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8021e2a:	6423      	str	r3, [r4, #64]	; 0x40
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_DST_EN_Msk;
 8021e2c:	69a3      	ldr	r3, [r4, #24]
 8021e2e:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 8021e32:	61a3      	str	r3, [r4, #24]
          break;
 8021e34:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_CONTIGUOUS:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk;
 8021e36:	2158      	movs	r1, #88	; 0x58
 8021e38:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 8021e3c:	2000      	movs	r0, #0
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_DST_EN_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_CONTIGUOUS:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk;
 8021e3e:	69a3      	ldr	r3, [r4, #24]
 8021e40:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8021e44:	61a3      	str	r3, [r4, #24]
          break;
 8021e46:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      {
        case XMC_DMA_CH_TRANSFER_TYPE_SINGLE_BLOCK:
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_CONTIGUOUS_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk;
 8021e48:	2158      	movs	r1, #88	; 0x58
 8021e4a:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 8021e4e:	2000      	movs	r0, #0
      {
        case XMC_DMA_CH_TRANSFER_TYPE_SINGLE_BLOCK:
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_CONTIGUOUS_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk;
 8021e50:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8021e52:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8021e56:	6423      	str	r3, [r4, #64]	; 0x40
          break;
 8021e58:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_CONTIGUOUS:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
 8021e5a:	2158      	movs	r1, #88	; 0x58
 8021e5c:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 8021e60:	2000      	movs	r0, #0
        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_CONTIGUOUS_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_CONTIGUOUS:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
 8021e62:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8021e64:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8021e68:	6423      	str	r3, [r4, #64]	; 0x40
          break;
 8021e6a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_CONTIGUOUS:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk;
 8021e6c:	2158      	movs	r1, #88	; 0x58
 8021e6e:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 8021e72:	2000      	movs	r0, #0
        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_CONTIGUOUS:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk;
 8021e74:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8021e76:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8021e7a:	6423      	str	r3, [r4, #64]	; 0x40
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk;
 8021e7c:	69a3      	ldr	r3, [r4, #24]
 8021e7e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8021e82:	61a3      	str	r3, [r4, #24]
          break;
 8021e84:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_LINKED:
          dma->CH[channel].CTLL |= (uint32_t)((uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk |
 8021e86:	2158      	movs	r1, #88	; 0x58
 8021e88:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 8021e8c:	2000      	movs	r0, #0
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk;
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_LINKED:
          dma->CH[channel].CTLL |= (uint32_t)((uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk |
 8021e8e:	69a3      	ldr	r3, [r4, #24]
 8021e90:	f043 53c0 	orr.w	r3, r3, #402653184	; 0x18000000
 8021e94:	61a3      	str	r3, [r4, #24]
                                              (uint32_t)GPDMA0_CH_CTLL_LLP_DST_EN_Msk);
          break;
 8021e96:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
          {
#endif
            line = config->src_peripheral_request & GPDMA0_CH_CFGH_PER_Msk;
 8021e98:	f003 0007 	and.w	r0, r3, #7
            line = config->src_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
          }
#endif
          peripheral = config->src_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_SRC_PER_Pos);
 8021e9c:	ea47 17c0 	orr.w	r7, r7, r0, lsl #7
 8021ea0:	6457      	str	r7, [r2, #68]	; 0x44
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021ea2:	688f      	ldr	r7, [r1, #8]
 8021ea4:	ea4f 0e80 	mov.w	lr, r0, lsl #2
 8021ea8:	220f      	movs	r2, #15
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 8021eaa:	091b      	lsrs	r3, r3, #4
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021eac:	fa02 f20e 	lsl.w	r2, r2, lr
 8021eb0:	ea27 0202 	bic.w	r2, r7, r2
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 8021eb4:	fa03 f30e 	lsl.w	r3, r3, lr
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021eb8:	4313      	orrs	r3, r2
 8021eba:	608b      	str	r3, [r1, #8]
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
 8021ebc:	690a      	ldr	r2, [r1, #16]
 8021ebe:	2301      	movs	r3, #1
 8021ec0:	4083      	lsls	r3, r0
 8021ec2:	4313      	orrs	r3, r2
 8021ec4:	610b      	str	r3, [r1, #16]
 8021ec6:	e78d      	b.n	8021de4 <XMC_DMA_CH_Init+0x174>
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
          {
#endif
            line = config->dst_peripheral_request & GPDMA0_CH_CFGH_PER_Msk;
 8021ec8:	f003 0007 	and.w	r0, r3, #7
            line = config->dst_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
          }
#endif
          peripheral = config->dst_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_DEST_PER_Pos);
 8021ecc:	ea47 27c0 	orr.w	r7, r7, r0, lsl #11
 8021ed0:	6457      	str	r7, [r2, #68]	; 0x44
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021ed2:	688f      	ldr	r7, [r1, #8]
 8021ed4:	ea4f 0e80 	mov.w	lr, r0, lsl #2
 8021ed8:	220f      	movs	r2, #15
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 8021eda:	091b      	lsrs	r3, r3, #4
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021edc:	fa02 f20e 	lsl.w	r2, r2, lr
 8021ee0:	ea27 0202 	bic.w	r2, r7, r2
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 8021ee4:	fa03 f30e 	lsl.w	r3, r3, lr
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021ee8:	4313      	orrs	r3, r2
 8021eea:	608b      	str	r3, [r1, #8]
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
 8021eec:	690a      	ldr	r2, [r1, #16]
 8021eee:	2301      	movs	r3, #1
 8021ef0:	4083      	lsls	r3, r0
 8021ef2:	4313      	orrs	r3, r2
 8021ef4:	610b      	str	r3, [r1, #16]
 8021ef6:	e74c      	b.n	8021d92 <XMC_DMA_CH_Init+0x122>
 8021ef8:	50014000 	.word	0x50014000
 8021efc:	20000020 	.word	0x20000020
 8021f00:	20000010 	.word	0x20000010
 8021f04:	50004900 	.word	0x50004900

08021f08 <XMC_DMA_CH_EnableEvent>:

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & ((uint32_t)0x1UL << event_idx))
    {
      dma->MASKCHEV[event_idx * 2UL] = ((uint32_t)0x101UL << channel);
 8021f08:	f240 1301 	movw	r3, #257	; 0x101
 8021f0c:	408b      	lsls	r3, r1
{
  uint32_t event_idx;

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & ((uint32_t)0x1UL << event_idx))
 8021f0e:	07d1      	lsls	r1, r2, #31
    {
      dma->MASKCHEV[event_idx * 2UL] = ((uint32_t)0x101UL << channel);
 8021f10:	bf48      	it	mi
 8021f12:	f8c0 3310 	strmi.w	r3, [r0, #784]	; 0x310
{
  uint32_t event_idx;

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & ((uint32_t)0x1UL << event_idx))
 8021f16:	0791      	lsls	r1, r2, #30
    {
      dma->MASKCHEV[event_idx * 2UL] = ((uint32_t)0x101UL << channel);
 8021f18:	bf48      	it	mi
 8021f1a:	f8c0 3318 	strmi.w	r3, [r0, #792]	; 0x318
{
  uint32_t event_idx;

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & ((uint32_t)0x1UL << event_idx))
 8021f1e:	0751      	lsls	r1, r2, #29
    {
      dma->MASKCHEV[event_idx * 2UL] = ((uint32_t)0x101UL << channel);
 8021f20:	bf48      	it	mi
 8021f22:	f8c0 3320 	strmi.w	r3, [r0, #800]	; 0x320
{
  uint32_t event_idx;

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & ((uint32_t)0x1UL << event_idx))
 8021f26:	0711      	lsls	r1, r2, #28
    {
      dma->MASKCHEV[event_idx * 2UL] = ((uint32_t)0x101UL << channel);
 8021f28:	bf48      	it	mi
 8021f2a:	f8c0 3328 	strmi.w	r3, [r0, #808]	; 0x328
{
  uint32_t event_idx;

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & ((uint32_t)0x1UL << event_idx))
 8021f2e:	06d2      	lsls	r2, r2, #27
    {
      dma->MASKCHEV[event_idx * 2UL] = ((uint32_t)0x101UL << channel);
 8021f30:	bf48      	it	mi
 8021f32:	f8c0 3330 	strmi.w	r3, [r0, #816]	; 0x330
 8021f36:	4770      	bx	lr

08021f38 <XMC_DMA_CH_SetEventHandler>:

/* Set event handler */
void XMC_DMA_CH_SetEventHandler(XMC_DMA_t *const dma, const uint8_t channel, XMC_DMA_CH_EVENT_HANDLER_t event_handler)
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8021f38:	4b03      	ldr	r3, [pc, #12]	; (8021f48 <XMC_DMA_CH_SetEventHandler+0x10>)
 8021f3a:	4298      	cmp	r0, r3
  {
#endif
    dma0_event_handlers[channel] = event_handler;
 8021f3c:	bf0c      	ite	eq
 8021f3e:	4b03      	ldreq	r3, [pc, #12]	; (8021f4c <XMC_DMA_CH_SetEventHandler+0x14>)
#if defined(GPDMA1)
  }
  else
  {
    dma1_event_handlers[channel] = event_handler;
 8021f40:	4b03      	ldrne	r3, [pc, #12]	; (8021f50 <XMC_DMA_CH_SetEventHandler+0x18>)
 8021f42:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
 8021f46:	4770      	bx	lr
 8021f48:	50014000 	.word	0x50014000
 8021f4c:	1fffa834 	.word	0x1fffa834
 8021f50:	1fffa854 	.word	0x1fffa854

08021f54 <XMC_DMA_CH_ClearSourcePeripheralRequest>:
}

void XMC_DMA_CH_ClearSourcePeripheralRequest(XMC_DMA_t *const dma, uint8_t channel)
{
  uint32_t line;
  line = (dma->CH[channel].CFGH & GPDMA0_CH_CFGH_SRC_PER_Msk) >> GPDMA0_CH_CFGH_SRC_PER_Pos;
 8021f54:	2358      	movs	r3, #88	; 0x58
 8021f56:	fb03 0101 	mla	r1, r3, r1, r0
}

void XMC_DMA_ClearRequestLine(XMC_DMA_t *const dma, uint8_t line)
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8021f5a:	4a0a      	ldr	r2, [pc, #40]	; (8021f84 <XMC_DMA_CH_ClearSourcePeripheralRequest+0x30>)
}

void XMC_DMA_CH_ClearSourcePeripheralRequest(XMC_DMA_t *const dma, uint8_t channel)
{
  uint32_t line;
  line = (dma->CH[channel].CFGH & GPDMA0_CH_CFGH_SRC_PER_Msk) >> GPDMA0_CH_CFGH_SRC_PER_Pos;
 8021f5c:	6c4b      	ldr	r3, [r1, #68]	; 0x44
 8021f5e:	f3c3 11c3 	ubfx	r1, r3, #7, #4
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->LNEN &= ~(0x1UL << line);
 8021f62:	4b09      	ldr	r3, [pc, #36]	; (8021f88 <XMC_DMA_CH_ClearSourcePeripheralRequest+0x34>)
}

void XMC_DMA_ClearRequestLine(XMC_DMA_t *const dma, uint8_t line)
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8021f64:	4290      	cmp	r0, r2
  {
#endif
    DLR->LNEN &= ~(0x1UL << line);
 8021f66:	bf08      	it	eq
 8021f68:	2201      	moveq	r2, #1
	DLR->LNEN |= 0x1UL << line;
#if defined(GPDMA1)
  }
  else
  {
    DLR->LNEN &= ~(0x100UL << line);
 8021f6a:	6918      	ldr	r0, [r3, #16]
 8021f6c:	bf18      	it	ne
 8021f6e:	f44f 7280 	movne.w	r2, #256	; 0x100
 8021f72:	408a      	lsls	r2, r1
 8021f74:	ea20 0102 	bic.w	r1, r0, r2
 8021f78:	6119      	str	r1, [r3, #16]
	DLR->LNEN |= 0x100UL << line;
 8021f7a:	6919      	ldr	r1, [r3, #16]
 8021f7c:	430a      	orrs	r2, r1
 8021f7e:	611a      	str	r2, [r3, #16]
 8021f80:	4770      	bx	lr
 8021f82:	bf00      	nop
 8021f84:	50014000 	.word	0x50014000
 8021f88:	50004900 	.word	0x50004900

08021f8c <XMC_DMA_IRQHandler>:
    dma_event_handlers = dma0_event_handlers;
#if defined(GPDMA1)
  }
  else
  {
    dma_event_handlers = dma1_event_handlers;
 8021f8c:	4a5a      	ldr	r2, [pc, #360]	; (80220f8 <XMC_DMA_IRQHandler+0x16c>)
 8021f8e:	495b      	ldr	r1, [pc, #364]	; (80220fc <XMC_DMA_IRQHandler+0x170>)
 * Destination transaction complete -> ::XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE <br>
 * DMA error event -> ::XMC_DMA_CH_EVENT_ERROR                                     <br>
 */
__STATIC_INLINE uint32_t XMC_DMA_GetEventStatus(XMC_DMA_t *const dma)
{
  return (dma->STATUSGLEV);
 8021f90:	f8d0 3360 	ldr.w	r3, [r0, #864]	; 0x360
  XMC_DMA_ClearRequestLine(dma, (uint8_t)line);
}

/* Default DMA IRQ handler */
void XMC_DMA_IRQHandler(XMC_DMA_t *const dma)
{
 8021f94:	b430      	push	{r4, r5}
  uint32_t mask;
  XMC_DMA_CH_EVENT_HANDLER_t *dma_event_handlers;
  XMC_DMA_CH_EVENT_HANDLER_t event_handler;

#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8021f96:	4d5a      	ldr	r5, [pc, #360]	; (8022100 <XMC_DMA_IRQHandler+0x174>)
    dma_event_handlers = dma0_event_handlers;
#if defined(GPDMA1)
  }
  else
  {
    dma_event_handlers = dma1_event_handlers;
 8021f98:	42a8      	cmp	r0, r5
 8021f9a:	bf0c      	ite	eq
 8021f9c:	460d      	moveq	r5, r1
 8021f9e:	4615      	movne	r5, r2
#endif
  
  event = XMC_DMA_GetEventStatus(dma);
  channel = 0;

  if ((event & (uint32_t)XMC_DMA_CH_EVENT_ERROR) != (uint32_t)0UL)
 8021fa0:	f013 0210 	ands.w	r2, r3, #16
 8021fa4:	d01d      	beq.n	8021fe2 <XMC_DMA_IRQHandler+0x56>
 * \par
 * The function returns error interrupt status. <br>
 */
__STATIC_INLINE uint32_t XMC_DMA_GetChannelsErrorStatus(XMC_DMA_t *const dma)
{
  return (dma->STATUSCHEV[8]);
 8021fa6:	f8d0 1308 	ldr.w	r1, [r0, #776]	; 0x308
  {
    event = XMC_DMA_GetChannelsErrorStatus(dma);
    while (event != 0)
 8021faa:	b1c1      	cbz	r1, 8021fde <XMC_DMA_IRQHandler+0x52>
    {
      mask = (uint32_t)1U << channel;
      if ((event & mask) != 0)
 8021fac:	07cb      	lsls	r3, r1, #31
 8021fae:	f100 8097 	bmi.w	80220e0 <XMC_DMA_IRQHandler+0x154>
 8021fb2:	2301      	movs	r3, #1
  if ((event & (uint32_t)XMC_DMA_CH_EVENT_ERROR) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsErrorStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 8021fb4:	461c      	mov	r4, r3
 8021fb6:	e000      	b.n	8021fba <XMC_DMA_IRQHandler+0x2e>
          event_handler(XMC_DMA_CH_EVENT_ERROR);
        }
       
        break;
      }
      ++channel;
 8021fb8:	3301      	adds	r3, #1
  if ((event & (uint32_t)XMC_DMA_CH_EVENT_ERROR) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsErrorStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 8021fba:	fa04 f203 	lsl.w	r2, r4, r3
      if ((event & mask) != 0)
 8021fbe:	420a      	tst	r2, r1
 8021fc0:	d0fa      	beq.n	8021fb8 <XMC_DMA_IRQHandler+0x2c>
 8021fc2:	009a      	lsls	r2, r3, #2
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)XMC_DMA_CH_EVENT_ERROR);

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
 8021fc4:	58a9      	ldr	r1, [r5, r2]

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 8021fc6:	b2db      	uxtb	r3, r3
 8021fc8:	2201      	movs	r2, #1
 8021fca:	fa02 f303 	lsl.w	r3, r2, r3
 8021fce:	f8c0 3358 	str.w	r3, [r0, #856]	; 0x358
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)XMC_DMA_CH_EVENT_ERROR);

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
 8021fd2:	b121      	cbz	r1, 8021fde <XMC_DMA_IRQHandler+0x52>
        {
          event_handler(XMC_DMA_CH_EVENT_ERROR);
 8021fd4:	2010      	movs	r0, #16
  else
  {
    /* no active interrupt was found? */
  }

}
 8021fd6:	bc30      	pop	{r4, r5}

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
        {
          event_handler(XMC_DMA_CH_EVENT_ERROR);
 8021fd8:	4708      	bx	r1
        break;
      }
      ++channel;
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE) != (uint32_t)0UL)
 8021fda:	071a      	lsls	r2, r3, #28
 8021fdc:	d465      	bmi.n	80220aa <XMC_DMA_IRQHandler+0x11e>
  else
  {
    /* no active interrupt was found? */
  }

}
 8021fde:	bc30      	pop	{r4, r5}
 8021fe0:	4770      	bx	lr
        break;
      }
      ++channel;
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_TRANSFER_COMPLETE) != (uint32_t)0UL)
 8021fe2:	f013 0401 	ands.w	r4, r3, #1
 8021fe6:	d020      	beq.n	802202a <XMC_DMA_IRQHandler+0x9e>
 * \par
 * The function returns GPDMA transfer complete interrupt status. <br>
 */
__STATIC_INLINE uint32_t XMC_DMA_GetChannelsTransferCompleteStatus(XMC_DMA_t *const dma)
{
  return (dma->STATUSCHEV[0]);
 8021fe8:	f8d0 12e8 	ldr.w	r1, [r0, #744]	; 0x2e8
  {
    event = XMC_DMA_GetChannelsTransferCompleteStatus(dma);
    while (event != 0)
 8021fec:	2900      	cmp	r1, #0
 8021fee:	d0f6      	beq.n	8021fde <XMC_DMA_IRQHandler+0x52>
    {
      mask = (uint32_t)1U << channel;
      if (event & mask)
 8021ff0:	07cc      	lsls	r4, r1, #31
 8021ff2:	d478      	bmi.n	80220e6 <XMC_DMA_IRQHandler+0x15a>
 8021ff4:	2301      	movs	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_TRANSFER_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsTransferCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 8021ff6:	461c      	mov	r4, r3
 8021ff8:	e000      	b.n	8021ffc <XMC_DMA_IRQHandler+0x70>
          event_handler(XMC_DMA_CH_EVENT_TRANSFER_COMPLETE);
        }
																	  
        break;
      }
      ++channel;
 8021ffa:	3301      	adds	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_TRANSFER_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsTransferCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 8021ffc:	fa04 f203 	lsl.w	r2, r4, r3
      if (event & mask)
 8022000:	420a      	tst	r2, r1
 8022002:	d0fa      	beq.n	8021ffa <XMC_DMA_IRQHandler+0x6e>
 8022004:	009a      	lsls	r2, r3, #2
                                                                      (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE | 
                                                                      (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE | 
                                                                      (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE));

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
 8022006:	58aa      	ldr	r2, [r5, r2]

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 8022008:	b2db      	uxtb	r3, r3
 802200a:	2101      	movs	r1, #1
 802200c:	fa01 f303 	lsl.w	r3, r1, r3
 8022010:	f8c0 3338 	str.w	r3, [r0, #824]	; 0x338
 8022014:	f8c0 3340 	str.w	r3, [r0, #832]	; 0x340
 8022018:	f8c0 3348 	str.w	r3, [r0, #840]	; 0x348
 802201c:	f8c0 3350 	str.w	r3, [r0, #848]	; 0x350
                                                                      (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE | 
                                                                      (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE));

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
 8022020:	2a00      	cmp	r2, #0
 8022022:	d0dc      	beq.n	8021fde <XMC_DMA_IRQHandler+0x52>
        {
          event_handler(XMC_DMA_CH_EVENT_TRANSFER_COMPLETE);
 8022024:	4608      	mov	r0, r1
  else
  {
    /* no active interrupt was found? */
  }

}
 8022026:	bc30      	pop	{r4, r5}

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
        {
          event_handler(XMC_DMA_CH_EVENT_TRANSFER_COMPLETE);
 8022028:	4710      	bx	r2
        break;
      }
      ++channel;
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE) != (uint32_t)0UL)
 802202a:	f013 0202 	ands.w	r2, r3, #2
 802202e:	d11d      	bne.n	802206c <XMC_DMA_IRQHandler+0xe0>
        break;
      }
      ++channel;
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE) != (uint32_t)0UL)
 8022030:	f013 0404 	ands.w	r4, r3, #4
 8022034:	d0d1      	beq.n	8021fda <XMC_DMA_IRQHandler+0x4e>
 * If the source peripheral is memory, the source transaction complete interrupt is
 * ignored.
 */
__STATIC_INLINE uint32_t XMC_DMA_GetChannelsSourceTransactionCompleteStatus(XMC_DMA_t *const dma)
{
  return (dma->STATUSCHEV[4]);
 8022036:	f8d0 12f8 	ldr.w	r1, [r0, #760]	; 0x2f8
  {
    event = XMC_DMA_GetChannelsSourceTransactionCompleteStatus(dma);
    while (event != 0)
 802203a:	2900      	cmp	r1, #0
 802203c:	d0cf      	beq.n	8021fde <XMC_DMA_IRQHandler+0x52>
    {
      mask = (uint32_t)1U << channel;
      if (event & mask)
 802203e:	07cc      	lsls	r4, r1, #31
 8022040:	d455      	bmi.n	80220ee <XMC_DMA_IRQHandler+0x162>
 8022042:	2301      	movs	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsSourceTransactionCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 8022044:	461c      	mov	r4, r3
 8022046:	e000      	b.n	802204a <XMC_DMA_IRQHandler+0xbe>
          event_handler(XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE);
        }
        
        break;
      }
      ++channel;
 8022048:	3301      	adds	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsSourceTransactionCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 802204a:	fa04 f203 	lsl.w	r2, r4, r3
      if (event & mask)
 802204e:	420a      	tst	r2, r1
 8022050:	d0fa      	beq.n	8022048 <XMC_DMA_IRQHandler+0xbc>
 8022052:	009a      	lsls	r2, r3, #2
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE);

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
 8022054:	58a9      	ldr	r1, [r5, r2]

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 8022056:	b2db      	uxtb	r3, r3
 8022058:	2201      	movs	r2, #1
 802205a:	fa02 f303 	lsl.w	r3, r2, r3
 802205e:	f8c0 3348 	str.w	r3, [r0, #840]	; 0x348
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE);

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
 8022062:	2900      	cmp	r1, #0
 8022064:	d0bb      	beq.n	8021fde <XMC_DMA_IRQHandler+0x52>
        {
          event_handler(XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE);
 8022066:	2004      	movs	r0, #4
  else
  {
    /* no active interrupt was found? */
  }

}
 8022068:	bc30      	pop	{r4, r5}

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
        {
          event_handler(XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE);
 802206a:	4708      	bx	r1
 * \par
 * The function returns GPDMA block transfer complete interrupt status. <br>
 */
__STATIC_INLINE uint32_t XMC_DMA_GetChannelsBlockCompleteStatus(XMC_DMA_t *const dma)
{
  return (dma->STATUSCHEV[2]);
 802206c:	f8d0 12f0 	ldr.w	r1, [r0, #752]	; 0x2f0
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsBlockCompleteStatus(dma);
    while (event != 0)
 8022070:	2900      	cmp	r1, #0
 8022072:	d0b4      	beq.n	8021fde <XMC_DMA_IRQHandler+0x52>
    {
      mask = (uint32_t)1U << channel;
      if (event & mask)
 8022074:	07cb      	lsls	r3, r1, #31
 8022076:	d438      	bmi.n	80220ea <XMC_DMA_IRQHandler+0x15e>
 8022078:	2301      	movs	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsBlockCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 802207a:	461c      	mov	r4, r3
 802207c:	e000      	b.n	8022080 <XMC_DMA_IRQHandler+0xf4>
          event_handler(XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE);
        }

        break;
      }
      ++channel;
 802207e:	3301      	adds	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsBlockCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 8022080:	fa04 f203 	lsl.w	r2, r4, r3
      if (event & mask)
 8022084:	420a      	tst	r2, r1
 8022086:	d0fa      	beq.n	802207e <XMC_DMA_IRQHandler+0xf2>
 8022088:	009c      	lsls	r4, r3, #2
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)((uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE |
                                                                      (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE | 
                                                                      (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE));

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
 802208a:	5929      	ldr	r1, [r5, r4]

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 802208c:	b2db      	uxtb	r3, r3
 802208e:	2201      	movs	r2, #1
 8022090:	fa02 f303 	lsl.w	r3, r2, r3
 8022094:	f8c0 3340 	str.w	r3, [r0, #832]	; 0x340
 8022098:	f8c0 3348 	str.w	r3, [r0, #840]	; 0x348
 802209c:	f8c0 3350 	str.w	r3, [r0, #848]	; 0x350
                                                                      (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE | 
                                                                      (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE));

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
 80220a0:	2900      	cmp	r1, #0
 80220a2:	d09c      	beq.n	8021fde <XMC_DMA_IRQHandler+0x52>
        {
          event_handler(XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE);
 80220a4:	2002      	movs	r0, #2
  else
  {
    /* no active interrupt was found? */
  }

}
 80220a6:	bc30      	pop	{r4, r5}

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
        {
          event_handler(XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE);
 80220a8:	4708      	bx	r1
 * If the destination peripheral is memory, the destination transaction complete
 * interrupt is ignored.
 */
__STATIC_INLINE uint32_t XMC_DMA_GetChannelsDestinationTransactionCompleteStatus(XMC_DMA_t *const dma)
{
  return (dma->STATUSCHEV[6]);
 80220aa:	f8d0 1300 	ldr.w	r1, [r0, #768]	; 0x300
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsDestinationTransactionCompleteStatus(dma);
    while (event != 0)
 80220ae:	2900      	cmp	r1, #0
 80220b0:	d095      	beq.n	8021fde <XMC_DMA_IRQHandler+0x52>
    {
      mask = (uint32_t)1U << channel;
      if (event & mask)
 80220b2:	07cb      	lsls	r3, r1, #31
 80220b4:	d41d      	bmi.n	80220f2 <XMC_DMA_IRQHandler+0x166>
 80220b6:	2301      	movs	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsDestinationTransactionCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 80220b8:	461c      	mov	r4, r3
 80220ba:	e000      	b.n	80220be <XMC_DMA_IRQHandler+0x132>
          event_handler(XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE);
        }      

        break;
      }
      ++channel;
 80220bc:	3301      	adds	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsDestinationTransactionCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 80220be:	fa04 f203 	lsl.w	r2, r4, r3
      if (event & mask)
 80220c2:	420a      	tst	r2, r1
 80220c4:	d0fa      	beq.n	80220bc <XMC_DMA_IRQHandler+0x130>
 80220c6:	009c      	lsls	r4, r3, #2

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 80220c8:	b2db      	uxtb	r3, r3
      if (event & mask)
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE);

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
 80220ca:	5929      	ldr	r1, [r5, r4]

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 80220cc:	2201      	movs	r2, #1
 80220ce:	fa02 f303 	lsl.w	r3, r2, r3
 80220d2:	f8c0 3350 	str.w	r3, [r0, #848]	; 0x350
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE);

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
 80220d6:	2900      	cmp	r1, #0
 80220d8:	d081      	beq.n	8021fde <XMC_DMA_IRQHandler+0x52>
        {
          event_handler(XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE);
 80220da:	2008      	movs	r0, #8
  else
  {
    /* no active interrupt was found? */
  }

}
 80220dc:	bc30      	pop	{r4, r5}

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
        {
          event_handler(XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE);
 80220de:	4708      	bx	r1
  {
    event = XMC_DMA_GetChannelsErrorStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
      if ((event & mask) != 0)
 80220e0:	2200      	movs	r2, #0
    dma_event_handlers = dma1_event_handlers;
  }
#endif
  
  event = XMC_DMA_GetEventStatus(dma);
  channel = 0;
 80220e2:	4613      	mov	r3, r2
 80220e4:	e76e      	b.n	8021fc4 <XMC_DMA_IRQHandler+0x38>
 80220e6:	4613      	mov	r3, r2
 80220e8:	e78d      	b.n	8022006 <XMC_DMA_IRQHandler+0x7a>
 80220ea:	4623      	mov	r3, r4
 80220ec:	e7cd      	b.n	802208a <XMC_DMA_IRQHandler+0xfe>
 80220ee:	4613      	mov	r3, r2
 80220f0:	e7b0      	b.n	8022054 <XMC_DMA_IRQHandler+0xc8>
 80220f2:	4623      	mov	r3, r4
 80220f4:	e7e8      	b.n	80220c8 <XMC_DMA_IRQHandler+0x13c>
 80220f6:	bf00      	nop
 80220f8:	1fffa854 	.word	0x1fffa854
 80220fc:	1fffa834 	.word	0x1fffa834
 8022100:	50014000 	.word	0x50014000

08022104 <XMC_ERU_ETL_Init>:
 ********************************************************************************************************************/
/* Initializes the selected ERU_ETLx channel with the config structure.  */
void XMC_ERU_ETL_Init(XMC_ERU_t *const eru,
                      const uint8_t channel,
                      const XMC_ERU_ETL_CONFIG_t *const config)
{ 
 8022104:	b570      	push	{r4, r5, r6, lr}
 8022106:	4616      	mov	r6, r2
 8022108:	4605      	mov	r5, r0
 802210a:	460c      	mov	r4, r1
  XMC_ASSERT("XMC_ERU_ETL_Init:Invalid Module Pointer", XMC_ERU_CHECK_MODULE_PTR(eru));
  XMC_ASSERT("XMC_ERU_ETL_Init:Invalid Channel Number", (channel < 4U));

  XMC_ERU_Enable(eru);
 802210c:	f7ff f8d2 	bl	80212b4 <XMC_ERU_Enable>

  eru->EXISEL = (eru->EXISEL & 
                 ~((uint32_t)(ERU_EXISEL_EXS0A_Msk | ERU_EXISEL_EXS0B_Msk) << (channel * ERU_EXISEL_BITSIZE))) |
 8022110:	00a2      	lsls	r2, r4, #2
  XMC_ASSERT("XMC_ERU_ETL_Init:Invalid Module Pointer", XMC_ERU_CHECK_MODULE_PTR(eru));
  XMC_ASSERT("XMC_ERU_ETL_Init:Invalid Channel Number", (channel < 4U));

  XMC_ERU_Enable(eru);

  eru->EXISEL = (eru->EXISEL & 
 8022112:	6828      	ldr	r0, [r5, #0]
                 ~((uint32_t)(ERU_EXISEL_EXS0A_Msk | ERU_EXISEL_EXS0B_Msk) << (channel * ERU_EXISEL_BITSIZE))) |
                (config->input << (channel * (uint32_t)ERU_EXISEL_BITSIZE));
 8022114:	6833      	ldr	r3, [r6, #0]
  XMC_ASSERT("XMC_ERU_ETL_Init:Invalid Channel Number", (channel < 4U));

  XMC_ERU_Enable(eru);

  eru->EXISEL = (eru->EXISEL & 
                 ~((uint32_t)(ERU_EXISEL_EXS0A_Msk | ERU_EXISEL_EXS0B_Msk) << (channel * ERU_EXISEL_BITSIZE))) |
 8022116:	210f      	movs	r1, #15
 8022118:	4091      	lsls	r1, r2
  XMC_ASSERT("XMC_ERU_ETL_Init:Invalid Module Pointer", XMC_ERU_CHECK_MODULE_PTR(eru));
  XMC_ASSERT("XMC_ERU_ETL_Init:Invalid Channel Number", (channel < 4U));

  XMC_ERU_Enable(eru);

  eru->EXISEL = (eru->EXISEL & 
 802211a:	ea20 0101 	bic.w	r1, r0, r1
                 ~((uint32_t)(ERU_EXISEL_EXS0A_Msk | ERU_EXISEL_EXS0B_Msk) << (channel * ERU_EXISEL_BITSIZE))) |
                (config->input << (channel * (uint32_t)ERU_EXISEL_BITSIZE));
 802211e:	4093      	lsls	r3, r2
  XMC_ASSERT("XMC_ERU_ETL_Init:Invalid Channel Number", (channel < 4U));

  XMC_ERU_Enable(eru);

  eru->EXISEL = (eru->EXISEL & 
                 ~((uint32_t)(ERU_EXISEL_EXS0A_Msk | ERU_EXISEL_EXS0B_Msk) << (channel * ERU_EXISEL_BITSIZE))) |
 8022120:	430b      	orrs	r3, r1
  XMC_ASSERT("XMC_ERU_ETL_Init:Invalid Module Pointer", XMC_ERU_CHECK_MODULE_PTR(eru));
  XMC_ASSERT("XMC_ERU_ETL_Init:Invalid Channel Number", (channel < 4U));

  XMC_ERU_Enable(eru);

  eru->EXISEL = (eru->EXISEL & 
 8022122:	602b      	str	r3, [r5, #0]
                 ~((uint32_t)(ERU_EXISEL_EXS0A_Msk | ERU_EXISEL_EXS0B_Msk) << (channel * ERU_EXISEL_BITSIZE))) |
                (config->input << (channel * (uint32_t)ERU_EXISEL_BITSIZE));
  
  eru->EXICON[channel] = config->raw;
 8022124:	3404      	adds	r4, #4
 8022126:	6873      	ldr	r3, [r6, #4]
 8022128:	f845 3024 	str.w	r3, [r5, r4, lsl #2]
 802212c:	bd70      	pop	{r4, r5, r6, pc}
 802212e:	bf00      	nop

08022130 <XMC_ERU_OGU_Init>:

/* Initializes the selected ERU_OGUy channel with the config structure.  */
void XMC_ERU_OGU_Init(XMC_ERU_t *const eru,
                      const uint8_t channel,
                      const XMC_ERU_OGU_CONFIG_t *const config)
{
 8022130:	b570      	push	{r4, r5, r6, lr}
 8022132:	460c      	mov	r4, r1
 8022134:	4616      	mov	r6, r2
 8022136:	4605      	mov	r5, r0
  XMC_ASSERT("XMC_ERU_OGU_Init:Invalid Module Pointer", XMC_ERU_CHECK_MODULE_PTR(eru));
  XMC_ASSERT("XMC_ERU_OGU_Init:Invalid Channel Number", (channel < 4U));

  XMC_ERU_Enable(eru);

  eru->EXOCON[channel] = config->raw;
 8022138:	3408      	adds	r4, #8
                      const XMC_ERU_OGU_CONFIG_t *const config)
{
  XMC_ASSERT("XMC_ERU_OGU_Init:Invalid Module Pointer", XMC_ERU_CHECK_MODULE_PTR(eru));
  XMC_ASSERT("XMC_ERU_OGU_Init:Invalid Channel Number", (channel < 4U));

  XMC_ERU_Enable(eru);
 802213a:	f7ff f8bb 	bl	80212b4 <XMC_ERU_Enable>

  eru->EXOCON[channel] = config->raw;
 802213e:	6833      	ldr	r3, [r6, #0]
 8022140:	f845 3024 	str.w	r3, [r5, r4, lsl #2]
 8022144:	bd70      	pop	{r4, r5, r6, pc}
 8022146:	bf00      	nop

08022148 <XMC_FCE_Init>:
/*
 * Initialize the FCE peripheral:
 * Update FCE configuration and initialize seed value
 */
XMC_FCE_STATUS_t XMC_FCE_Init(const XMC_FCE_t *const engine)
{
 8022148:	4603      	mov	r3, r0
  engine->kernel_ptr->CFG = engine->fce_cfg_update.regval;
  engine->kernel_ptr->CRC = engine->seedvalue;
  
  return XMC_FCE_STATUS_OK;
}
 802214a:	2000      	movs	r0, #0
 * Initialize the FCE peripheral:
 * Update FCE configuration and initialize seed value
 */
XMC_FCE_STATUS_t XMC_FCE_Init(const XMC_FCE_t *const engine)
{
  engine->kernel_ptr->CFG = engine->fce_cfg_update.regval;
 802214c:	681a      	ldr	r2, [r3, #0]
 802214e:	6859      	ldr	r1, [r3, #4]
  engine->kernel_ptr->CRC = engine->seedvalue;
 8022150:	689b      	ldr	r3, [r3, #8]
 * Initialize the FCE peripheral:
 * Update FCE configuration and initialize seed value
 */
XMC_FCE_STATUS_t XMC_FCE_Init(const XMC_FCE_t *const engine)
{
  engine->kernel_ptr->CFG = engine->fce_cfg_update.regval;
 8022152:	6091      	str	r1, [r2, #8]
  engine->kernel_ptr->CRC = engine->seedvalue;
 8022154:	6193      	str	r3, [r2, #24]
  
  return XMC_FCE_STATUS_OK;
}
 8022156:	4770      	bx	lr

08022158 <XMC_FCE_Enable>:

}

/* Enable FCE */
void XMC_FCE_Enable(void)
{
 8022158:	b510      	push	{r4, lr}
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_FCE);
 802215a:	4c06      	ldr	r4, [pc, #24]	; (8022174 <XMC_FCE_Enable+0x1c>)
 802215c:	4620      	mov	r0, r4
 802215e:	f7ff f9d7 	bl	8021510 <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif

  XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_FCE);
 8022162:	4620      	mov	r0, r4
 8022164:	f7ff f964 	bl	8021430 <XMC_SCU_RESET_DeassertPeripheralReset>

  FCE->CLC &= (uint32_t)~FCE_CLC_DISR_Msk;
 8022168:	4a03      	ldr	r2, [pc, #12]	; (8022178 <XMC_FCE_Enable+0x20>)
 802216a:	6813      	ldr	r3, [r2, #0]
 802216c:	f023 0301 	bic.w	r3, r3, #1
 8022170:	6013      	str	r3, [r2, #0]
 8022172:	bd10      	pop	{r4, pc}
 8022174:	20000040 	.word	0x20000040
 8022178:	50020000 	.word	0x50020000

0802217c <XMC_FCE_CalculateCRC32>:
  XMC_ASSERT("XMC_FCE_CalculateCRC32: Length field is empty", (length != 0));
  XMC_ASSERT("XMC_FCE_CalculateCRC32: Length is not aligned", ((length & 0x03) == 0));
  XMC_ASSERT("XMC_FCE_CalculateCRC32: Buffer is not aligned", (((uint32_t)data % 4U) == 0));

  /* Check if data and length are word aligned */
  if (((length & 0x03U) != 0U) || (((uint32_t)length % 4U) != 0U))
 802217c:	f012 0f03 	tst.w	r2, #3
 8022180:	d001      	beq.n	8022186 <XMC_FCE_CalculateCRC32+0xa>
  {
    status = XMC_FCE_STATUS_ERROR;
 8022182:	2002      	movs	r0, #2
 8022184:	4770      	bx	lr
/* Calculate and return the IEEE 802.3 Ethernet CRC32 checksum */
XMC_FCE_STATUS_t XMC_FCE_CalculateCRC32(const XMC_FCE_t *const engine,
                                        const uint32_t *data,
										uint32_t length,
										uint32_t *result)
{
 8022186:	b410      	push	{r4}
 8022188:	6804      	ldr	r4, [r0, #0]
  {
    status = XMC_FCE_STATUS_ERROR;
  }
  else
  {
    while (0UL != length)
 802218a:	b122      	cbz	r2, 8022196 <XMC_FCE_CalculateCRC32+0x1a>
    {
      engine->kernel_ptr->IR = *data;
 802218c:	f851 0b04 	ldr.w	r0, [r1], #4
 8022190:	6020      	str	r0, [r4, #0]
  {
    status = XMC_FCE_STATUS_ERROR;
  }
  else
  {
    while (0UL != length)
 8022192:	3a04      	subs	r2, #4
 8022194:	d1fa      	bne.n	802218c <XMC_FCE_CalculateCRC32+0x10>
      engine->kernel_ptr->IR = *data;
      data++;
      length -= 4U;
    }

    *result = engine->kernel_ptr->CRC;
 8022196:	69a2      	ldr	r2, [r4, #24]
 8022198:	601a      	str	r2, [r3, #0]
XMC_FCE_STATUS_t XMC_FCE_CalculateCRC32(const XMC_FCE_t *const engine,
                                        const uint32_t *data,
										uint32_t length,
										uint32_t *result)
{
  XMC_FCE_STATUS_t status = XMC_FCE_STATUS_OK;
 802219a:	2000      	movs	r0, #0

    *result = engine->kernel_ptr->CRC;
  }
  
  return status;
}
 802219c:	f85d 4b04 	ldr.w	r4, [sp], #4
 80221a0:	4770      	bx	lr
 80221a2:	bf00      	nop

080221a4 <XMC_GPIO_SetHardwareControl>:
  port->IOCR[(uint32_t)pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U)));
  port->IOCR[(uint32_t)pin >> 2U] |= (uint32_t)mode << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U));
}

void XMC_GPIO_SetHardwareControl(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_HWCTRL_t hwctrl)
{
 80221a4:	b410      	push	{r4}
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid hwctrl", XMC_GPIO_CHECK_HWCTRL(hwctrl));

  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
 80221a6:	0049      	lsls	r1, r1, #1
 80221a8:	6f44      	ldr	r4, [r0, #116]	; 0x74
 80221aa:	2303      	movs	r3, #3
 80221ac:	408b      	lsls	r3, r1
 80221ae:	ea24 0303 	bic.w	r3, r4, r3
 80221b2:	6743      	str	r3, [r0, #116]	; 0x74
  port->HWSEL |= (uint32_t)hwctrl << ((uint32_t)pin << 1U);
 80221b4:	6f43      	ldr	r3, [r0, #116]	; 0x74
}
 80221b6:	f85d 4b04 	ldr.w	r4, [sp], #4
{
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid hwctrl", XMC_GPIO_CHECK_HWCTRL(hwctrl));

  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
  port->HWSEL |= (uint32_t)hwctrl << ((uint32_t)pin << 1U);
 80221ba:	408a      	lsls	r2, r1
 80221bc:	4313      	orrs	r3, r2
 80221be:	6743      	str	r3, [r0, #116]	; 0x74
}
 80221c0:	4770      	bx	lr
 80221c2:	bf00      	nop

080221c4 <XMC_USBD_GetCapabilities>:
  cap.event_remote_wakeup = 1U;
  cap.event_reset = 1U;
  cap.event_resume = 1U;
  cap.event_suspend = 1U;
  cap.reserved = 0U;
  return cap;
 80221c4:	2000      	movs	r0, #0
 80221c6:	f36f 0000 	bfc	r0, #0, #1
 80221ca:	f36f 0041 	bfc	r0, #1, #1
 80221ce:	f040 001c 	orr.w	r0, r0, #28
 80221d2:	f36f 1045 	bfc	r0, #5, #1
 80221d6:	f440 70e0 	orr.w	r0, r0, #448	; 0x1c0
}
 80221da:	f3c0 0008 	ubfx	r0, r0, #0, #9
 80221de:	4770      	bx	lr

080221e0 <XMC_USBD_DeviceConnect>:
 **/
XMC_USBD_STATUS_t XMC_USBD_DeviceConnect() 
{
  /* Just disable softdisconnect */
  dctl_data_t dctl;
	dctl.d32 = xmc_device.device_register->dctl;
 80221e0:	4b04      	ldr	r3, [pc, #16]	; (80221f4 <XMC_USBD_DeviceConnect+0x14>)
 80221e2:	f8d3 21a4 	ldr.w	r2, [r3, #420]	; 0x1a4
 80221e6:	6853      	ldr	r3, [r2, #4]
  dctl.b.sftdiscon = 0U;
 80221e8:	f36f 0341 	bfc	r3, #1, #1
  xmc_device.device_register->dctl = dctl.d32;
 80221ec:	6053      	str	r3, [r2, #4]
  return XMC_USBD_STATUS_OK;
}
 80221ee:	2000      	movs	r0, #0
 80221f0:	4770      	bx	lr
 80221f2:	bf00      	nop
 80221f4:	1fffa868 	.word	0x1fffa868

080221f8 <XMC_USBD_DeviceDisconnect>:
 * Disconnects the USB device from host
 **/
XMC_USBD_STATUS_t XMC_USBD_DeviceDisconnect() 
{
  dctl_data_t dctl;
	dctl.d32 = xmc_device.device_register->dctl;
 80221f8:	4b04      	ldr	r3, [pc, #16]	; (802220c <XMC_USBD_DeviceDisconnect+0x14>)
 80221fa:	f8d3 21a4 	ldr.w	r2, [r3, #420]	; 0x1a4
 80221fe:	6853      	ldr	r3, [r2, #4]
  dctl.b.sftdiscon = 1U;
 8022200:	f043 0302 	orr.w	r3, r3, #2
  xmc_device.device_register->dctl = dctl.d32;
 8022204:	6053      	str	r3, [r2, #4]
  return XMC_USBD_STATUS_OK;
}
 8022206:	2000      	movs	r0, #0
 8022208:	4770      	bx	lr
 802220a:	bf00      	nop
 802220c:	1fffa868 	.word	0x1fffa868

08022210 <XMC_USBD_DeviceGetState>:
 **/
XMC_USBD_STATE_t XMC_USBD_DeviceGetState(const XMC_USBD_t *const obj) 
{
  XMC_USBD_STATE_t state={0U};
  state.speed = XMC_USBD_SPEED_FULL;
  state.connected = xmc_device.IsConnected;
 8022210:	4a44      	ldr	r2, [pc, #272]	; (8022324 <XMC_USBD_DeviceGetState+0x114>)
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 8022212:	7b01      	ldrb	r1, [r0, #12]

/**
 * Gets the USB device state.
 **/
XMC_USBD_STATE_t XMC_USBD_DeviceGetState(const XMC_USBD_t *const obj) 
{
 8022214:	b470      	push	{r4, r5, r6}
  XMC_USBD_STATE_t state={0U};
  state.speed = XMC_USBD_SPEED_FULL;
  state.connected = xmc_device.IsConnected;
 8022216:	f892 41fe 	ldrb.w	r4, [r2, #510]	; 0x1fe
/**
 * Gets the USB device state.
 **/
XMC_USBD_STATE_t XMC_USBD_DeviceGetState(const XMC_USBD_t *const obj) 
{
  XMC_USBD_STATE_t state={0U};
 802221a:	2000      	movs	r0, #0
  state.speed = XMC_USBD_SPEED_FULL;
  state.connected = xmc_device.IsConnected;
 802221c:	f004 0401 	and.w	r4, r4, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 8022220:	2900      	cmp	r1, #0
 8022222:	d07c      	beq.n	802231e <XMC_USBD_DeviceGetState+0x10e>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 8022224:	6853      	ldr	r3, [r2, #4]
 8022226:	071e      	lsls	r6, r3, #28
 8022228:	bf56      	itet	pl
 802222a:	6853      	ldrpl	r3, [r2, #4]
    {
      result = 1U;
 802222c:	2301      	movmi	r3, #1
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 802222e:	f3c3 1300 	ubfxpl	r3, r3, #4, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 8022232:	2901      	cmp	r1, #1
 8022234:	d954      	bls.n	80222e0 <XMC_USBD_DeviceGetState+0xd0>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 8022236:	6b95      	ldr	r5, [r2, #56]	; 0x38
 8022238:	4e3a      	ldr	r6, [pc, #232]	; (8022324 <XMC_USBD_DeviceGetState+0x114>)
 802223a:	072d      	lsls	r5, r5, #28
 802223c:	d461      	bmi.n	8022302 <XMC_USBD_DeviceGetState+0xf2>
 802223e:	6bb5      	ldr	r5, [r6, #56]	; 0x38
    {
      result = 1U;
 8022240:	f015 0f10 	tst.w	r5, #16
 8022244:	bf18      	it	ne
 8022246:	2301      	movne	r3, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 8022248:	2902      	cmp	r1, #2
 802224a:	d049      	beq.n	80222e0 <XMC_USBD_DeviceGetState+0xd0>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 802224c:	6ed5      	ldr	r5, [r2, #108]	; 0x6c
 802224e:	4e35      	ldr	r6, [pc, #212]	; (8022324 <XMC_USBD_DeviceGetState+0x114>)
 8022250:	072d      	lsls	r5, r5, #28
 8022252:	d462      	bmi.n	802231a <XMC_USBD_DeviceGetState+0x10a>
 8022254:	6ef5      	ldr	r5, [r6, #108]	; 0x6c
    {
      result = 1U;
 8022256:	f015 0f10 	tst.w	r5, #16
 802225a:	bf18      	it	ne
 802225c:	2301      	movne	r3, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 802225e:	2903      	cmp	r1, #3
 8022260:	d03e      	beq.n	80222e0 <XMC_USBD_DeviceGetState+0xd0>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 8022262:	f8d2 50a0 	ldr.w	r5, [r2, #160]	; 0xa0
 8022266:	4e2f      	ldr	r6, [pc, #188]	; (8022324 <XMC_USBD_DeviceGetState+0x114>)
 8022268:	072d      	lsls	r5, r5, #28
 802226a:	d454      	bmi.n	8022316 <XMC_USBD_DeviceGetState+0x106>
 802226c:	f8d6 50a0 	ldr.w	r5, [r6, #160]	; 0xa0
    {
      result = 1U;
 8022270:	f015 0f10 	tst.w	r5, #16
 8022274:	bf18      	it	ne
 8022276:	2301      	movne	r3, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 8022278:	2904      	cmp	r1, #4
 802227a:	d031      	beq.n	80222e0 <XMC_USBD_DeviceGetState+0xd0>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 802227c:	f8d2 50d4 	ldr.w	r5, [r2, #212]	; 0xd4
 8022280:	4e28      	ldr	r6, [pc, #160]	; (8022324 <XMC_USBD_DeviceGetState+0x114>)
 8022282:	072d      	lsls	r5, r5, #28
 8022284:	d445      	bmi.n	8022312 <XMC_USBD_DeviceGetState+0x102>
 8022286:	f8d6 50d4 	ldr.w	r5, [r6, #212]	; 0xd4
    {
      result = 1U;
 802228a:	f015 0f10 	tst.w	r5, #16
 802228e:	bf18      	it	ne
 8022290:	2301      	movne	r3, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 8022292:	2905      	cmp	r1, #5
 8022294:	d024      	beq.n	80222e0 <XMC_USBD_DeviceGetState+0xd0>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 8022296:	f8d2 5108 	ldr.w	r5, [r2, #264]	; 0x108
 802229a:	4e22      	ldr	r6, [pc, #136]	; (8022324 <XMC_USBD_DeviceGetState+0x114>)
 802229c:	072d      	lsls	r5, r5, #28
 802229e:	d436      	bmi.n	802230e <XMC_USBD_DeviceGetState+0xfe>
 80222a0:	f8d6 5108 	ldr.w	r5, [r6, #264]	; 0x108
    {
      result = 1U;
 80222a4:	f015 0f10 	tst.w	r5, #16
 80222a8:	bf18      	it	ne
 80222aa:	2301      	movne	r3, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 80222ac:	2906      	cmp	r1, #6
 80222ae:	d017      	beq.n	80222e0 <XMC_USBD_DeviceGetState+0xd0>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 80222b0:	f8d2 513c 	ldr.w	r5, [r2, #316]	; 0x13c
 80222b4:	4e1b      	ldr	r6, [pc, #108]	; (8022324 <XMC_USBD_DeviceGetState+0x114>)
 80222b6:	072d      	lsls	r5, r5, #28
 80222b8:	d427      	bmi.n	802230a <XMC_USBD_DeviceGetState+0xfa>
 80222ba:	f8d6 513c 	ldr.w	r5, [r6, #316]	; 0x13c
    {
      result = 1U;
 80222be:	f015 0f10 	tst.w	r5, #16
 80222c2:	bf18      	it	ne
 80222c4:	2301      	movne	r3, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 80222c6:	2907      	cmp	r1, #7
 80222c8:	d00a      	beq.n	80222e0 <XMC_USBD_DeviceGetState+0xd0>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 80222ca:	f8d2 1170 	ldr.w	r1, [r2, #368]	; 0x170
 80222ce:	4d15      	ldr	r5, [pc, #84]	; (8022324 <XMC_USBD_DeviceGetState+0x114>)
 80222d0:	0709      	lsls	r1, r1, #28
 80222d2:	d418      	bmi.n	8022306 <XMC_USBD_DeviceGetState+0xf6>
 80222d4:	f8d5 1170 	ldr.w	r1, [r5, #368]	; 0x170
    {
      result = 1U;
 80222d8:	f011 0f10 	tst.w	r1, #16
 80222dc:	bf18      	it	ne
 80222de:	2301      	movne	r3, #1
 80222e0:	f003 0301 	and.w	r3, r3, #1
{
  XMC_USBD_STATE_t state={0U};
  state.speed = XMC_USBD_SPEED_FULL;
  state.connected = xmc_device.IsConnected;
  state.active = XMC_USBD_lDeviceActive(obj);
  state.powered = xmc_device.IsPowered;
 80222e4:	f892 21fe 	ldrb.w	r2, [r2, #510]	; 0x1fe
  return state;
 80222e8:	f3c2 0280 	ubfx	r2, r2, #2, #1
 80222ec:	f362 0000 	bfi	r0, r2, #0, #1
 80222f0:	f364 0041 	bfi	r0, r4, #1, #1
 80222f4:	f363 0082 	bfi	r0, r3, #2, #1
 80222f8:	2301      	movs	r3, #1
 80222fa:	f363 00c4 	bfi	r0, r3, #3, #2
}
 80222fe:	bc70      	pop	{r4, r5, r6}
 8022300:	4770      	bx	lr
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
    {
      result = 1U;
 8022302:	2301      	movs	r3, #1
 8022304:	e7a0      	b.n	8022248 <XMC_USBD_DeviceGetState+0x38>
 8022306:	2301      	movs	r3, #1
 8022308:	e7ea      	b.n	80222e0 <XMC_USBD_DeviceGetState+0xd0>
 802230a:	2301      	movs	r3, #1
 802230c:	e7db      	b.n	80222c6 <XMC_USBD_DeviceGetState+0xb6>
 802230e:	2301      	movs	r3, #1
 8022310:	e7cc      	b.n	80222ac <XMC_USBD_DeviceGetState+0x9c>
 8022312:	2301      	movs	r3, #1
 8022314:	e7bd      	b.n	8022292 <XMC_USBD_DeviceGetState+0x82>
 8022316:	2301      	movs	r3, #1
 8022318:	e7ae      	b.n	8022278 <XMC_USBD_DeviceGetState+0x68>
 802231a:	2301      	movs	r3, #1
 802231c:	e79f      	b.n	802225e <XMC_USBD_DeviceGetState+0x4e>
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 802231e:	4603      	mov	r3, r0
 8022320:	e7e0      	b.n	80222e4 <XMC_USBD_DeviceGetState+0xd4>
 8022322:	bf00      	nop
 8022324:	1fffa868 	.word	0x1fffa868

08022328 <XMC_USBD_DeviceSetAddress>:
 * Sets the USB device address.
 **/
XMC_USBD_STATUS_t XMC_USBD_DeviceSetAddress(const uint8_t address,const XMC_USBD_SET_ADDRESS_STAGE_t stage) 
{
  dcfg_data_t data;
  data.d32 = xmc_device.device_register->dcfg;
 8022328:	4b04      	ldr	r3, [pc, #16]	; (802233c <XMC_USBD_DeviceSetAddress+0x14>)
 802232a:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 802232e:	681a      	ldr	r2, [r3, #0]
  if (stage == XMC_USBD_SET_ADDRESS_STAGE_SETUP)
 8022330:	b911      	cbnz	r1, 8022338 <XMC_USBD_DeviceSetAddress+0x10>
  {
    data.b.devaddr = address;
 8022332:	f360 120a 	bfi	r2, r0, #4, #7
    xmc_device.device_register->dcfg = data.d32;
 8022336:	601a      	str	r2, [r3, #0]
  }
	return XMC_USBD_STATUS_OK;
}
 8022338:	2000      	movs	r0, #0
 802233a:	4770      	bx	lr
 802233c:	1fffa868 	.word	0x1fffa868

08022340 <XMC_USBD_EndpointStall>:
 * Set/clear stall on the selected endpoint.
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointStall(const uint8_t ep_addr, const bool stall) 
{
  depctl_data_t data;
  XMC_USBD_EP_t *ep = &xmc_device.ep[(ep_addr & (uint8_t)XMC_USBD_EP_NUM_MASK)];
 8022340:	f000 020f 	and.w	r2, r0, #15
  if (stall)
 8022344:	b1e9      	cbz	r1, 8022382 <XMC_USBD_EndpointStall+0x42>
  {
    if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
    {
      /*set stall bit */
      data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022346:	2334      	movs	r3, #52	; 0x34
{
  depctl_data_t data;
  XMC_USBD_EP_t *ep = &xmc_device.ep[(ep_addr & (uint8_t)XMC_USBD_EP_NUM_MASK)];
  if (stall)
  {
    if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
 8022348:	f010 0f80 	tst.w	r0, #128	; 0x80
    {
      /*set stall bit */
      data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 802234c:	fb03 f302 	mul.w	r3, r3, r2
 8022350:	481d      	ldr	r0, [pc, #116]	; (80223c8 <XMC_USBD_EndpointStall+0x88>)
 8022352:	5cc3      	ldrb	r3, [r0, r3]
 8022354:	f003 030f 	and.w	r3, r3, #15
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
    }
    else
    {
      /*set stall bit */
      data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 8022358:	bf0b      	itete	eq
 802235a:	eb00 0383 	addeq.w	r3, r0, r3, lsl #2
  if (stall)
  {
    if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
    {
      /*set stall bit */
      data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 802235e:	336a      	addne	r3, #106	; 0x6a
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
    }
    else
    {
      /*set stall bit */
      data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 8022360:	f8d3 11c4 	ldreq.w	r1, [r3, #452]	; 0x1c4
  if (stall)
  {
    if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
    {
      /*set stall bit */
      data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022364:	f850 1023 	ldrne.w	r1, [r0, r3, lsl #2]
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
    }
    else
    {
      /*set stall bit */
      data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 8022368:	680b      	ldr	r3, [r1, #0]
      data.b.stall = 1U;
 802236a:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
      xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
 802236e:	600b      	str	r3, [r1, #0]
    }
    ep->isStalled = 1U;
 8022370:	2334      	movs	r3, #52	; 0x34
 8022372:	fb03 0202 	mla	r2, r3, r2, r0
			xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
		}
		ep->isStalled = 0U;
	}
	return XMC_USBD_STATUS_OK;
}
 8022376:	2000      	movs	r0, #0
      /*set stall bit */
      data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
      data.b.stall = 1U;
      xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
    }
    ep->isStalled = 1U;
 8022378:	7913      	ldrb	r3, [r2, #4]
 802237a:	f043 0320 	orr.w	r3, r3, #32
 802237e:	7113      	strb	r3, [r2, #4]
			xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
		}
		ep->isStalled = 0U;
	}
	return XMC_USBD_STATUS_OK;
}
 8022380:	4770      	bx	lr

/**
 * Set/clear stall on the selected endpoint.
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointStall(const uint8_t ep_addr, const bool stall) 
{
 8022382:	b410      	push	{r4}
  else
  {
    /* just clear stall bit */
		if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
		{
			data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022384:	2334      	movs	r3, #52	; 0x34
    ep->isStalled = 1U;
  }
  else
  {
    /* just clear stall bit */
		if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
 8022386:	f010 0f80 	tst.w	r0, #128	; 0x80
		{
			data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 802238a:	fb03 f302 	mul.w	r3, r3, r2
 802238e:	480e      	ldr	r0, [pc, #56]	; (80223c8 <XMC_USBD_EndpointStall+0x88>)
 8022390:	5cc3      	ldrb	r3, [r0, r3]
 8022392:	f003 030f 	and.w	r3, r3, #15
			data.b.setd0pid = 1U; /* reset pid to 0 */
			xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
		}
		else
		{
			data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 8022396:	bf0b      	itete	eq
 8022398:	eb00 0383 	addeq.w	r3, r0, r3, lsl #2
  else
  {
    /* just clear stall bit */
		if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
		{
			data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 802239c:	336a      	addne	r3, #106	; 0x6a
			data.b.setd0pid = 1U; /* reset pid to 0 */
			xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
		}
		else
		{
			data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 802239e:	f8d3 41c4 	ldreq.w	r4, [r3, #452]	; 0x1c4
  else
  {
    /* just clear stall bit */
		if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
		{
			data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 80223a2:	f850 4023 	ldrne.w	r4, [r0, r3, lsl #2]
			data.b.setd0pid = 1U; /* reset pid to 0 */
			xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
		}
		else
		{
			data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 80223a6:	6823      	ldr	r3, [r4, #0]
			data.b.stall = 0U;
 80223a8:	f361 5355 	bfi	r3, r1, #21, #1
			data.b.setd0pid = 1U; /* reset pid to 0 */
 80223ac:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
			xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
 80223b0:	6023      	str	r3, [r4, #0]
		}
		ep->isStalled = 0U;
 80223b2:	2334      	movs	r3, #52	; 0x34
 80223b4:	fb03 0202 	mla	r2, r3, r2, r0
	}
	return XMC_USBD_STATUS_OK;
}
 80223b8:	f85d 4b04 	ldr.w	r4, [sp], #4
			data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
			data.b.stall = 0U;
			data.b.setd0pid = 1U; /* reset pid to 0 */
			xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
		}
		ep->isStalled = 0U;
 80223bc:	7913      	ldrb	r3, [r2, #4]
 80223be:	f36f 1345 	bfc	r3, #5, #1
	}
	return XMC_USBD_STATUS_OK;
}
 80223c2:	2000      	movs	r0, #0
			data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
			data.b.stall = 0U;
			data.b.setd0pid = 1U; /* reset pid to 0 */
			xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
		}
		ep->isStalled = 0U;
 80223c4:	7113      	strb	r3, [r2, #4]
	}
	return XMC_USBD_STATUS_OK;
}
 80223c6:	4770      	bx	lr
 80223c8:	1fffa868 	.word	0x1fffa868

080223cc <XMC_USBD_EndpointAbort>:

/**
 * Aborts the data transfer on the selected endpoint
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointAbort(const uint8_t ep_addr) {
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_addr & (uint8_t)XMC_USBD_ENDPOINT_NUMBER_MASK];
 80223cc:	f000 000f 	and.w	r0, r0, #15
  if (ep->address_u.address_st.direction)
 80223d0:	2234      	movs	r2, #52	; 0x34
 80223d2:	fb02 f200 	mul.w	r2, r2, r0
 80223d6:	4b0d      	ldr	r3, [pc, #52]	; (802240c <XMC_USBD_EndpointAbort+0x40>)
 80223d8:	5c99      	ldrb	r1, [r3, r2]
 80223da:	441a      	add	r2, r3
 80223dc:	f011 0f80 	tst.w	r1, #128	; 0x80
  {
    ep->inInUse = 0U;
 80223e0:	6851      	ldr	r1, [r2, #4]
  }
  if (!ep->address_u.address_st.direction)
  {
    ep->outInUse = 0U;
 80223e2:	bf0c      	ite	eq
 80223e4:	f021 0110 	biceq.w	r1, r1, #16
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointAbort(const uint8_t ep_addr) {
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_addr & (uint8_t)XMC_USBD_ENDPOINT_NUMBER_MASK];
  if (ep->address_u.address_st.direction)
  {
    ep->inInUse = 0U;
 80223e8:	f021 0108 	bicne.w	r1, r1, #8
 80223ec:	6051      	str	r1, [r2, #4]
  }
  if (!ep->address_u.address_st.direction)
  {
    ep->outInUse = 0U;
  }
  ep->isStalled = 0U;
 80223ee:	2234      	movs	r2, #52	; 0x34
 80223f0:	fb02 3300 	mla	r3, r2, r0, r3
  ep->outBytesAvailable = 0U;
 80223f4:	2000      	movs	r0, #0
  }
  if (!ep->address_u.address_st.direction)
  {
    ep->outInUse = 0U;
  }
  ep->isStalled = 0U;
 80223f6:	791a      	ldrb	r2, [r3, #4]
  ep->outBytesAvailable = 0U;
  ep->outOffset = 0U;
  ep->xferLength = 0U;
  ep->xferCount = 0U;
 80223f8:	62d8      	str	r0, [r3, #44]	; 0x2c
  }
  if (!ep->address_u.address_st.direction)
  {
    ep->outInUse = 0U;
  }
  ep->isStalled = 0U;
 80223fa:	f36f 1245 	bfc	r2, #5, #1
 80223fe:	711a      	strb	r2, [r3, #4]
  ep->outBytesAvailable = 0U;
 8022400:	6118      	str	r0, [r3, #16]
  ep->outOffset = 0U;
 8022402:	6198      	str	r0, [r3, #24]
  ep->xferLength = 0U;
 8022404:	6298      	str	r0, [r3, #40]	; 0x28
  ep->xferCount = 0U;
  ep->xferTotal = 0U;
 8022406:	6318      	str	r0, [r3, #48]	; 0x30

  return XMC_USBD_STATUS_OK;
}
 8022408:	4770      	bx	lr
 802240a:	bf00      	nop
 802240c:	1fffa868 	.word	0x1fffa868

08022410 <XMC_USBD_EndpointUnconfigure>:

/**
 * Unconfigure the selected endpoint.
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointUnconfigure(const uint8_t ep_addr) 
{
 8022410:	b5f0      	push	{r4, r5, r6, r7, lr}
  depctl_data_t data;
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
 8022412:	4b3d      	ldr	r3, [pc, #244]	; (8022508 <XMC_USBD_EndpointUnconfigure+0xf8>)
/**
 * Unconfigure the selected endpoint.
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointUnconfigure(const uint8_t ep_addr) 
{
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_addr & (uint8_t)XMC_USBD_ENDPOINT_NUMBER_MASK];
 8022414:	f000 000f 	and.w	r0, r0, #15
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  number_temp = (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
 8022418:	2134      	movs	r1, #52	; 0x34
 802241a:	fb01 f100 	mul.w	r1, r1, r0
 802241e:	185a      	adds	r2, r3, r1
 8022420:	f813 e001 	ldrb.w	lr, [r3, r1]
  /* if not configured return an error */
  if (!ep->isConfigured)
 8022424:	7914      	ldrb	r4, [r2, #4]
  depctl_data_t data;
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
 8022426:	f8d3 71a4 	ldr.w	r7, [r3, #420]	; 0x1a4
  number_temp = (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
  /* if not configured return an error */
  if (!ep->isConfigured)
 802242a:	f014 0f04 	tst.w	r4, #4
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  number_temp = (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
 802242e:	f00e 060f 	and.w	r6, lr, #15
  depctl_data_t data;
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
 8022432:	69fd      	ldr	r5, [r7, #28]
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_addr & (uint8_t)XMC_USBD_ENDPOINT_NUMBER_MASK];
  depctl_data_t data;
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
 8022434:	f04f 0100 	mov.w	r1, #0
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  number_temp = (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
  /* if not configured return an error */
  if (!ep->isConfigured)
 8022438:	d05a      	beq.n	80224f0 <XMC_USBD_EndpointUnconfigure+0xe0>
    data.b.usbactep = 0U;
    data.b.epdis =  1U;
    data.b.snak =  1U;
    data.b.stall =  0U;
    ep->isConfigured =  0U;
    ep->isStalled =  0U;
 802243a:	f004 04fb 	and.w	r4, r4, #251	; 0xfb
 802243e:	f36f 1445 	bfc	r4, #5, #1
 8022442:	7114      	strb	r4, [r2, #4]
    ep->outInUse =  0U;
 8022444:	6854      	ldr	r4, [r2, #4]
 8022446:	f024 0410 	bic.w	r4, r4, #16
 802244a:	6054      	str	r4, [r2, #4]
    ep->inInUse =  0U;
 802244c:	6854      	ldr	r4, [r2, #4]
     result = XMC_USBD_STATUS_ERROR;
  }
  else
  {
    /* disable the endpoint, deactivate it and only send naks */
    data.b.usbactep = 0U;
 802244e:	f361 31cf 	bfi	r1, r1, #15, #1
    data.b.epdis =  1U;
    data.b.snak =  1U;
 8022452:	f041 4190 	orr.w	r1, r1, #1207959552	; 0x48000000
    data.b.stall =  0U;
    ep->isConfigured =  0U;
    ep->isStalled =  0U;
    ep->outInUse =  0U;
    ep->inInUse =  0U;
 8022456:	f024 0408 	bic.w	r4, r4, #8
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  number_temp = (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
 802245a:	f04f 0c01 	mov.w	ip, #1
    ep->isConfigured =  0U;
    ep->isStalled =  0U;
    ep->outInUse =  0U;
    ep->inInUse =  0U;
    /* chose register based on the direction. Control Endpoint need both */
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
 802245e:	f01e 0f80 	tst.w	lr, #128	; 0x80
  {
    /* disable the endpoint, deactivate it and only send naks */
    data.b.usbactep = 0U;
    data.b.epdis =  1U;
    data.b.snak =  1U;
    data.b.stall =  0U;
 8022462:	f36f 5155 	bfc	r1, #21, #1
    ep->isConfigured =  0U;
    ep->isStalled =  0U;
    ep->outInUse =  0U;
    ep->inInUse =  0U;
 8022466:	6054      	str	r4, [r2, #4]
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  number_temp = (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
 8022468:	fa0c fc06 	lsl.w	ip, ip, r6
    ep->isConfigured =  0U;
    ep->isStalled =  0U;
    ep->outInUse =  0U;
    ep->inInUse =  0U;
    /* chose register based on the direction. Control Endpoint need both */
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
 802246c:	d02f      	beq.n	80224ce <XMC_USBD_EndpointUnconfigure+0xbe>
    {
      /* disable endpoint configuration */
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
 802246e:	f106 0e6a 	add.w	lr, r6, #106	; 0x6a
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
 8022472:	ea6f 040c 	mvn.w	r4, ip
    ep->inInUse =  0U;
    /* chose register based on the direction. Control Endpoint need both */
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      /* disable endpoint configuration */
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
 8022476:	f853 e02e 	ldr.w	lr, [r3, lr, lsl #2]
 802247a:	f8ce 1000 	str.w	r1, [lr]
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
    }
    if ((ep->address_u.address_st.direction == 0U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
 802247e:	7912      	ldrb	r2, [r2, #4]
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      /* disable endpoint configuration */
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
 8022480:	fa1f fe84 	uxth.w	lr, r4
 8022484:	ea0e 0c05 	and.w	ip, lr, r5
    }
    if ((ep->address_u.address_st.direction == 0U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
 8022488:	0792      	lsls	r2, r2, #30
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      /* disable endpoint configuration */
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
 802248a:	f36c 050f 	bfi	r5, ip, #0, #16
    }
    if ((ep->address_u.address_st.direction == 0U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
 802248e:	d10d      	bne.n	80224ac <XMC_USBD_EndpointUnconfigure+0x9c>
    {
      xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
      daintmsk.ep.out = (uint16_t)((uint32_t)daintmsk.ep.out & (~(uint32_t)number_temp));
      if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022490:	4a1e      	ldr	r2, [pc, #120]	; (802250c <XMC_USBD_EndpointUnconfigure+0xfc>)
 8022492:	6812      	ldr	r2, [r2, #0]
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
    }
    if ((ep->address_u.address_st.direction == 0U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
 8022494:	eb03 0686 	add.w	r6, r3, r6, lsl #2
      daintmsk.ep.out = (uint16_t)((uint32_t)daintmsk.ep.out & (~(uint32_t)number_temp));
      if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022498:	7b52      	ldrb	r2, [r2, #13]
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
    }
    if ((ep->address_u.address_st.direction == 0U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
 802249a:	f8d6 61c4 	ldr.w	r6, [r6, #452]	; 0x1c4
      daintmsk.ep.out = (uint16_t)((uint32_t)daintmsk.ep.out & (~(uint32_t)number_temp));
 802249e:	ea0e 4e15 	and.w	lr, lr, r5, lsr #16
      if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 80224a2:	2a01      	cmp	r2, #1
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
    }
    if ((ep->address_u.address_st.direction == 0U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
 80224a4:	6031      	str	r1, [r6, #0]
      daintmsk.ep.out = (uint16_t)((uint32_t)daintmsk.ep.out & (~(uint32_t)number_temp));
 80224a6:	f36e 451f 	bfi	r5, lr, #16, #16
      if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 80224aa:	d028      	beq.n	80224fe <XMC_USBD_EndpointUnconfigure+0xee>
      {
        xmc_device.device_register->dtknqr4_fifoemptymsk &= ~number_temp;
      }
    }
    xmc_device.device_register->daintmsk = daintmsk.d32;
    XMC_USBD_lUnassignFifo(ep->txFifoNum); /* free fifo */
 80224ac:	2234      	movs	r2, #52	; 0x34
 80224ae:	fb02 3000 	mla	r0, r2, r0, r3
      if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
      {
        xmc_device.device_register->dtknqr4_fifoemptymsk &= ~number_temp;
      }
    }
    xmc_device.device_register->daintmsk = daintmsk.d32;
 80224b2:	61fd      	str	r5, [r7, #28]
    XMC_USBD_lUnassignFifo(ep->txFifoNum); /* free fifo */
 80224b4:	8880      	ldrh	r0, [r0, #4]
 * Mark an used tx fifo as free.
 * @param[in] fifo_nr Fifo number to free
 */
static void XMC_USBD_lUnassignFifo(const uint8_t fifo_nr) 
{
  xmc_device.txfifomsk = (uint16_t)((uint32_t)xmc_device.txfifomsk & (uint32_t)(~((uint32_t)((uint32_t)1U << fifo_nr))));
 80224b6:	f8b3 11fc 	ldrh.w	r1, [r3, #508]	; 0x1fc
 80224ba:	f3c0 1083 	ubfx	r0, r0, #6, #4
 80224be:	2201      	movs	r2, #1
 80224c0:	4082      	lsls	r2, r0
 80224c2:	ea21 0202 	bic.w	r2, r1, r2
 80224c6:	f8a3 21fc 	strh.w	r2, [r3, #508]	; 0x1fc
        xmc_device.device_register->dtknqr4_fifoemptymsk &= ~number_temp;
      }
    }
    xmc_device.device_register->daintmsk = daintmsk.d32;
    XMC_USBD_lUnassignFifo(ep->txFifoNum); /* free fifo */
    result = XMC_USBD_STATUS_OK;
 80224ca:	2000      	movs	r0, #0
 80224cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ep->isConfigured =  0U;
    ep->isStalled =  0U;
    ep->outInUse =  0U;
    ep->inInUse =  0U;
    /* chose register based on the direction. Control Endpoint need both */
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
 80224ce:	7912      	ldrb	r2, [r2, #4]
 80224d0:	0794      	lsls	r4, r2, #30
 80224d2:	d10f      	bne.n	80224f4 <XMC_USBD_EndpointUnconfigure+0xe4>
    {
      /* disable endpoint configuration */
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
 80224d4:	f106 026a 	add.w	r2, r6, #106	; 0x6a
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
 80224d8:	ea6f 040c 	mvn.w	r4, ip
 80224dc:	fa1f fe84 	uxth.w	lr, r4
    ep->inInUse =  0U;
    /* chose register based on the direction. Control Endpoint need both */
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      /* disable endpoint configuration */
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
 80224e0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
 80224e4:	ea0e 0c05 	and.w	ip, lr, r5
 80224e8:	f36c 050f 	bfi	r5, ip, #0, #16
    ep->inInUse =  0U;
    /* chose register based on the direction. Control Endpoint need both */
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      /* disable endpoint configuration */
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
 80224ec:	6011      	str	r1, [r2, #0]
 80224ee:	e7cf      	b.n	8022490 <XMC_USBD_EndpointUnconfigure+0x80>
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  number_temp = (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
  /* if not configured return an error */
  if (!ep->isConfigured)
  {
     result = XMC_USBD_STATUS_ERROR;
 80224f0:	2001      	movs	r0, #1
 80224f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80224f4:	ea6f 040c 	mvn.w	r4, ip
 80224f8:	fa1f fe84 	uxth.w	lr, r4
 80224fc:	e7c8      	b.n	8022490 <XMC_USBD_EndpointUnconfigure+0x80>
    {
      xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
      daintmsk.ep.out = (uint16_t)((uint32_t)daintmsk.ep.out & (~(uint32_t)number_temp));
      if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
      {
        xmc_device.device_register->dtknqr4_fifoemptymsk &= ~number_temp;
 80224fe:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8022500:	4014      	ands	r4, r2
 8022502:	637c      	str	r4, [r7, #52]	; 0x34
 8022504:	e7d2      	b.n	80224ac <XMC_USBD_EndpointUnconfigure+0x9c>
 8022506:	bf00      	nop
 8022508:	1fffa868 	.word	0x1fffa868
 802250c:	1fffa864 	.word	0x1fffa864

08022510 <XMC_USBD_GetFrameNumber>:
 **/
uint16_t XMC_USBD_GetFrameNumber(void) 
{
  uint16_t result;
  dsts_data_t dsts;
  dsts.d32 = xmc_device.device_register->dsts;
 8022510:	4b03      	ldr	r3, [pc, #12]	; (8022520 <XMC_USBD_GetFrameNumber+0x10>)
 8022512:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 8022516:	6898      	ldr	r0, [r3, #8]
  result = (uint16_t)dsts.b.soffn;
  return result;
}
 8022518:	f3c0 200d 	ubfx	r0, r0, #8, #14
 802251c:	4770      	bx	lr
 802251e:	bf00      	nop
 8022520:	1fffa868 	.word	0x1fffa868

08022524 <XMC_USBD_IsEnumDone>:
 * This should not be used for the actual USB enumeration completion status. For the actual USB enumeration status,
 * the application layer should check for the completion of USB standard request Set configuration.
 **/
uint32_t XMC_USBD_IsEnumDone(void)
{
  return (uint32_t)((uint8_t)xmc_device.IsConnected && (uint8_t)xmc_device.IsPowered);
 8022524:	4b05      	ldr	r3, [pc, #20]	; (802253c <XMC_USBD_IsEnumDone+0x18>)
 8022526:	f893 01fe 	ldrb.w	r0, [r3, #510]	; 0x1fe
 802252a:	f000 0005 	and.w	r0, r0, #5
}
 802252e:	f1a0 0005 	sub.w	r0, r0, #5
 8022532:	fab0 f080 	clz	r0, r0
 8022536:	0940      	lsrs	r0, r0, #5
 8022538:	4770      	bx	lr
 802253a:	bf00      	nop
 802253c:	1fffa868 	.word	0x1fffa868

08022540 <XMC_USBD_Uninitialize>:
 **/
XMC_USBD_STATUS_t XMC_USBD_Uninitialize() 
{
  /* Disconnect the device */
  dctl_data_t dctl;
	dctl.d32 = xmc_device.device_register->dctl;
 8022540:	4807      	ldr	r0, [pc, #28]	; (8022560 <XMC_USBD_Uninitialize+0x20>)
 8022542:	f8d0 21a4 	ldr.w	r2, [r0, #420]	; 0x1a4

/**
 * Uninitializes the USB device
 **/
XMC_USBD_STATUS_t XMC_USBD_Uninitialize() 
{
 8022546:	b508      	push	{r3, lr}
  /* Disconnect the device */
  dctl_data_t dctl;
	dctl.d32 = xmc_device.device_register->dctl;
 8022548:	6853      	ldr	r3, [r2, #4]
  dctl.b.sftdiscon = 1U;
 802254a:	f043 0302 	orr.w	r3, r3, #2
  xmc_device.device_register->dctl = dctl.d32;
 802254e:	6053      	str	r3, [r2, #4]
  /* clean up */
  memset((void*)&xmc_device,0U,sizeof(xmc_device));
 8022550:	2100      	movs	r1, #0
 8022552:	f44f 7202 	mov.w	r2, #520	; 0x208
 8022556:	f008 faee 	bl	802ab36 <memset>
  return XMC_USBD_STATUS_OK;
}
 802255a:	2000      	movs	r0, #0
 802255c:	bd08      	pop	{r3, pc}
 802255e:	bf00      	nop
 8022560:	1fffa868 	.word	0x1fffa868

08022564 <XMC_USBD_EndpointConfigure>:
 * Configures the given endpoint
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointConfigure(const uint8_t ep_addr,
		                                     const XMC_USBD_ENDPOINT_TYPE_t ep_type,
		                                     const uint16_t ep_max_packet_size) 
{
 8022564:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  daint_data_t daintmsk;
  XMC_USBD_EP_t *ep;
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
 8022568:	4d9a      	ldr	r5, [pc, #616]	; (80227d4 <XMC_USBD_EndpointConfigure+0x270>)
  else
  {
    ep->maxTransferSize = (uint32_t)XMC_USBD_MAX_TRANSFER_SIZE_EP0;
  }
  /* transfer buffer */
  ep->inBuffer = XMC_USBD_EP_IN_BUFFER[ep->address_u.address_st.number];
 802256a:	f8df 826c 	ldr.w	r8, [pc, #620]	; 80227d8 <XMC_USBD_EndpointConfigure+0x274>
		                                     const XMC_USBD_ENDPOINT_TYPE_t ep_type,
		                                     const uint16_t ep_max_packet_size) 
{
  daint_data_t daintmsk;
  XMC_USBD_EP_t *ep;
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
 802256e:	f8d5 31a4 	ldr.w	r3, [r5, #420]	; 0x1a4
  }
  /* transfer buffer */
  ep->inBuffer = XMC_USBD_EP_IN_BUFFER[ep->address_u.address_st.number];
  ep->outBuffer = XMC_USBD_EP_OUT_BUFFER[ep->address_u.address_st.number];
  /* buffer size*/
  ep->inBufferSize = XMC_USBD_EP_IN_BUFFERSIZE[ep->address_u.address_st.number];
 8022572:	f8df a268 	ldr.w	sl, [pc, #616]	; 80227dc <XMC_USBD_EndpointConfigure+0x278>
		                                     const XMC_USBD_ENDPOINT_TYPE_t ep_type,
		                                     const uint16_t ep_max_packet_size) 
{
  daint_data_t daintmsk;
  XMC_USBD_EP_t *ep;
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
 8022576:	f8d3 e01c 	ldr.w	lr, [r3, #28]
  /* transfer buffer */
  ep->inBuffer = XMC_USBD_EP_IN_BUFFER[ep->address_u.address_st.number];
  ep->outBuffer = XMC_USBD_EP_OUT_BUFFER[ep->address_u.address_st.number];
  /* buffer size*/
  ep->inBufferSize = XMC_USBD_EP_IN_BUFFERSIZE[ep->address_u.address_st.number];
  ep->outBufferSize = XMC_USBD_EP_OUT_BUFFERSIZE[ep->address_u.address_st.number];
 802257a:	f8df 9264 	ldr.w	r9, [pc, #612]	; 80227e0 <XMC_USBD_EndpointConfigure+0x27c>
		                                     const uint16_t ep_max_packet_size) 
{
  daint_data_t daintmsk;
  XMC_USBD_EP_t *ep;
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  ep =&xmc_device.ep[ep_addr & (uint32_t)XMC_USBD_ENDPOINT_NUMBER_MASK];
 802257e:	f000 0c0f 	and.w	ip, r0, #15
  memset((void*)ep,0x0U,sizeof(XMC_USBD_EP_t)); /* clear endpoint structure */
 8022582:	2734      	movs	r7, #52	; 0x34
 8022584:	fb07 f70c 	mul.w	r7, r7, ip
 8022588:	19ee      	adds	r6, r5, r7
 802258a:	f106 0308 	add.w	r3, r6, #8
 802258e:	2400      	movs	r4, #0
 8022590:	51ec      	str	r4, [r5, r7]
 8022592:	6074      	str	r4, [r6, #4]
 8022594:	f843 4b04 	str.w	r4, [r3], #4
 8022598:	f843 4b04 	str.w	r4, [r3], #4
 802259c:	f843 4b04 	str.w	r4, [r3], #4
 80225a0:	f843 4b04 	str.w	r4, [r3], #4
 80225a4:	f843 4b04 	str.w	r4, [r3], #4
 80225a8:	f843 4b04 	str.w	r4, [r3], #4
 80225ac:	f843 4b04 	str.w	r4, [r3], #4
 80225b0:	f843 4b04 	str.w	r4, [r3], #4
 80225b4:	f843 4b04 	str.w	r4, [r3], #4
 80225b8:	f843 4b04 	str.w	r4, [r3], #4
 80225bc:	601c      	str	r4, [r3, #0]
  /* do ep configuration */
  ep->address_u.address = ep_addr;
  ep->isConfigured = 1U;
 80225be:	7933      	ldrb	r3, [r6, #4]
  XMC_USBD_EP_t *ep;
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  ep =&xmc_device.ep[ep_addr & (uint32_t)XMC_USBD_ENDPOINT_NUMBER_MASK];
  memset((void*)ep,0x0U,sizeof(XMC_USBD_EP_t)); /* clear endpoint structure */
  /* do ep configuration */
  ep->address_u.address = ep_addr;
 80225c0:	55e8      	strb	r0, [r5, r7]
  ep->isConfigured = 1U;
 80225c2:	f043 0304 	orr.w	r3, r3, #4
 80225c6:	7133      	strb	r3, [r6, #4]
  ep->maxPacketSize = (uint8_t)ep_max_packet_size;
 80225c8:	6874      	ldr	r4, [r6, #4]
 80225ca:	4633      	mov	r3, r6
 80225cc:	f362 24d1 	bfi	r4, r2, #11, #7
 80225d0:	f843 4f04 	str.w	r4, [r3, #4]!
  {
    ep->maxTransferSize = (uint32_t)XMC_USBD_MAX_TRANSFER_SIZE;
  }
  else
  {
    ep->maxTransferSize = (uint32_t)XMC_USBD_MAX_TRANSFER_SIZE_EP0;
 80225d4:	2800      	cmp	r0, #0
 80225d6:	685c      	ldr	r4, [r3, #4]
 80225d8:	f64f 70c0 	movw	r0, #65472	; 0xffc0
 80225dc:	bf08      	it	eq
 80225de:	2040      	moveq	r0, #64	; 0x40
 80225e0:	f360 0412 	bfi	r4, r0, #0, #19
 80225e4:	605c      	str	r4, [r3, #4]
  }
  /* transfer buffer */
  ep->inBuffer = XMC_USBD_EP_IN_BUFFER[ep->address_u.address_st.number];
 80225e6:	5deb      	ldrb	r3, [r5, r7]
 80225e8:	f003 030f 	and.w	r3, r3, #15
 80225ec:	0218      	lsls	r0, r3, #8
  ep->outBuffer = XMC_USBD_EP_OUT_BUFFER[ep->address_u.address_st.number];
 80225ee:	f508 6be0 	add.w	fp, r8, #1792	; 0x700
  else
  {
    ep->maxTransferSize = (uint32_t)XMC_USBD_MAX_TRANSFER_SIZE_EP0;
  }
  /* transfer buffer */
  ep->inBuffer = XMC_USBD_EP_IN_BUFFER[ep->address_u.address_st.number];
 80225f2:	eb08 0400 	add.w	r4, r8, r0
  ep->outBuffer = XMC_USBD_EP_OUT_BUFFER[ep->address_u.address_st.number];
 80225f6:	eb00 080b 	add.w	r8, r0, fp
  /* buffer size*/
  ep->inBufferSize = XMC_USBD_EP_IN_BUFFERSIZE[ep->address_u.address_st.number];
 80225fa:	f85a 0023 	ldr.w	r0, [sl, r3, lsl #2]
 80225fe:	6230      	str	r0, [r6, #32]
  ep->outBufferSize = XMC_USBD_EP_OUT_BUFFERSIZE[ep->address_u.address_st.number];
 8022600:	f859 0023 	ldr.w	r0, [r9, r3, lsl #2]
 8022604:	6170      	str	r0, [r6, #20]
  else
  {
    ep->maxTransferSize = (uint32_t)XMC_USBD_MAX_TRANSFER_SIZE_EP0;
  }
  /* transfer buffer */
  ep->inBuffer = XMC_USBD_EP_IN_BUFFER[ep->address_u.address_st.number];
 8022606:	61f4      	str	r4, [r6, #28]
  ep->outBuffer = XMC_USBD_EP_OUT_BUFFER[ep->address_u.address_st.number];
 8022608:	f8c6 800c 	str.w	r8, [r6, #12]
  /* buffer size*/
  ep->inBufferSize = XMC_USBD_EP_IN_BUFFERSIZE[ep->address_u.address_st.number];
  ep->outBufferSize = XMC_USBD_EP_OUT_BUFFERSIZE[ep->address_u.address_st.number];
  /* is in */
  if ((ep->address_u.address_st.direction == 1U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
 802260c:	5de8      	ldrb	r0, [r5, r7]
 802260e:	0600      	lsls	r0, r0, #24
 8022610:	d41f      	bmi.n	8022652 <XMC_USBD_EndpointConfigure+0xee>
 8022612:	2900      	cmp	r1, #0
 8022614:	d07f      	beq.n	8022716 <XMC_USBD_EndpointConfigure+0x1b2>
  }
  if ((ep->address_u.address_st.direction == 0U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
  {
    /* is out */
		depctl_data_t data;
		data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 8022616:	eb05 0483 	add.w	r4, r5, r3, lsl #2
 802261a:	2001      	movs	r0, #1
 802261c:	f8d4 61c4 	ldr.w	r6, [r4, #452]	; 0x1c4
 8022620:	6834      	ldr	r4, [r6, #0]
 8022622:	4098      	lsls	r0, r3
		/*enable endpoint */
		data.b.usbactep = 1U;
 8022624:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
		/* set ep type */
		data.b.eptype = (uint8_t)ep_type;
 8022628:	f361 4493 	bfi	r4, r1, #18, #2
 802262c:	b280      	uxth	r0, r0
					break;
			}
		}
		else
		{
			data.b.mps = ep_max_packet_size;
 802262e:	f362 040a 	bfi	r4, r2, #0, #11
		}
		/* set first data0 pid */
		data.b.setd0pid = 1U;
 8022632:	f044 5480 	orr.w	r4, r4, #268435456	; 0x10000000
		/* clear stall */
		data.b.stall =(uint8_t) 0U;
 8022636:	f36f 5455 	bfc	r4, #21, #1
		xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32; /* configure endpoint */
		daintmsk.ep.out |=(uint16_t) ((uint16_t)1U << (uint8_t)ep->address_u.address_st.number); /* enable interrupts */
 802263a:	ea40 401e 	orr.w	r0, r0, lr, lsr #16
		}
		/* set first data0 pid */
		data.b.setd0pid = 1U;
		/* clear stall */
		data.b.stall =(uint8_t) 0U;
		xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32; /* configure endpoint */
 802263e:	6034      	str	r4, [r6, #0]
		daintmsk.ep.out |=(uint16_t) ((uint16_t)1U << (uint8_t)ep->address_u.address_st.number); /* enable interrupts */
 8022640:	f360 4e1f 	bfi	lr, r0, #16, #16
  }
  xmc_device.device_register->daintmsk = daintmsk.d32;
 8022644:	f8d5 31a4 	ldr.w	r3, [r5, #420]	; 0x1a4
  return XMC_USBD_STATUS_OK;
}
 8022648:	2000      	movs	r0, #0
		/* clear stall */
		data.b.stall =(uint8_t) 0U;
		xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32; /* configure endpoint */
		daintmsk.ep.out |=(uint16_t) ((uint16_t)1U << (uint8_t)ep->address_u.address_st.number); /* enable interrupts */
  }
  xmc_device.device_register->daintmsk = daintmsk.d32;
 802264a:	f8c3 e01c 	str.w	lr, [r3, #28]
  return XMC_USBD_STATUS_OK;
}
 802264e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  ep->outBufferSize = XMC_USBD_EP_OUT_BUFFERSIZE[ep->address_u.address_st.number];
  /* is in */
  if ((ep->address_u.address_st.direction == 1U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
  {
    depctl_data_t data;
    data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022652:	f103 006a 	add.w	r0, r3, #106	; 0x6a
 8022656:	f855 6020 	ldr.w	r6, [r5, r0, lsl #2]
 802265a:	6834      	ldr	r4, [r6, #0]
		/*enable endpoint */
		data.b.usbactep = 1U;
 802265c:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
		/* set ep type */
		data.b.eptype = (uint8_t)ep_type;
 8022660:	f361 4493 	bfi	r4, r1, #18, #2
		/* set mps */
    if (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL)
 8022664:	2900      	cmp	r1, #0
 8022666:	d05f      	beq.n	8022728 <XMC_USBD_EndpointConfigure+0x1c4>
				break;
			}
		}
		else
		{
			data.b.mps = ep_max_packet_size;
 8022668:	f362 040a 	bfi	r4, r2, #0, #11
 802266c:	f8b5 01fc 	ldrh.w	r0, [r5, #508]	; 0x1fc
		}
		/* set first data0 pid */
		data.b.setd0pid = 1U;
 8022670:	f044 5480 	orr.w	r4, r4, #268435456	; 0x10000000
static uint8_t XMC_USBD_lAssignTXFifo(void) 
{
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
 8022674:	f010 0701 	ands.w	r7, r0, #1
			data.b.mps = ep_max_packet_size;
		}
		/* set first data0 pid */
		data.b.setd0pid = 1U;
		/* clear stall */
		data.b.stall = 0U;
 8022678:	f36f 5455 	bfc	r4, #21, #1
static uint8_t XMC_USBD_lAssignTXFifo(void) 
{
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
 802267c:	f000 808e 	beq.w	802279c <XMC_USBD_EndpointConfigure+0x238>
 8022680:	0787      	lsls	r7, r0, #30
 8022682:	f140 808e 	bpl.w	80227a2 <XMC_USBD_EndpointConfigure+0x23e>
 8022686:	0747      	lsls	r7, r0, #29
 8022688:	f140 808f 	bpl.w	80227aa <XMC_USBD_EndpointConfigure+0x246>
 802268c:	0707      	lsls	r7, r0, #28
 802268e:	f140 8090 	bpl.w	80227b2 <XMC_USBD_EndpointConfigure+0x24e>
 8022692:	06c7      	lsls	r7, r0, #27
 8022694:	f140 8091 	bpl.w	80227ba <XMC_USBD_EndpointConfigure+0x256>
 8022698:	0687      	lsls	r7, r0, #26
 802269a:	f140 8092 	bpl.w	80227c2 <XMC_USBD_EndpointConfigure+0x25e>
 802269e:	0647      	lsls	r7, r0, #25
 80226a0:	f140 8093 	bpl.w	80227ca <XMC_USBD_EndpointConfigure+0x266>
  {
    mask = (uint16_t)(mask << 1U);
    i++;
  }
  if ((xmc_device.txfifomsk & mask) == 0U)
 80226a4:	0607      	lsls	r7, r0, #24
 80226a6:	d449      	bmi.n	802273c <XMC_USBD_EndpointConfigure+0x1d8>
 80226a8:	2707      	movs	r7, #7
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
 80226aa:	f04f 0880 	mov.w	r8, #128	; 0x80
    i++;
  }
  if ((xmc_device.txfifomsk & mask) == 0U)
  {
    xmc_device.txfifomsk |= mask;
 80226ae:	ea48 0000 	orr.w	r0, r8, r0
 80226b2:	f8a5 01fc 	strh.w	r0, [r5, #508]	; 0x1fc
		/* set first data0 pid */
		data.b.setd0pid = 1U;
		/* clear stall */
		data.b.stall = 0U;
		/* set tx fifo */
		ep->txFifoNum = XMC_USBD_lAssignTXFifo(); /* get tx fifo */
 80226b6:	2034      	movs	r0, #52	; 0x34
 80226b8:	fb00 fc0c 	mul.w	ip, r0, ip
 80226bc:	eb05 090c 	add.w	r9, r5, ip
		data.b.txfnum = ep->txFifoNum;
 80226c0:	f367 5499 	bfi	r4, r7, #22, #4
		/* set first data0 pid */
		data.b.setd0pid = 1U;
		/* clear stall */
		data.b.stall = 0U;
		/* set tx fifo */
		ep->txFifoNum = XMC_USBD_lAssignTXFifo(); /* get tx fifo */
 80226c4:	f8b9 a004 	ldrh.w	sl, [r9, #4]
 80226c8:	f8df 8108 	ldr.w	r8, [pc, #264]	; 80227d4 <XMC_USBD_EndpointConfigure+0x270>
 80226cc:	f367 1a89 	bfi	sl, r7, #6, #4
 80226d0:	f8a9 a004 	strh.w	sl, [r9, #4]
		data.b.txfnum = ep->txFifoNum;
		xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32; /* configure endpoint */
		daintmsk.ep.in |= (uint16_t)((uint16_t)1U << (uint8_t)ep->address_u.address_st.number); /* enable interrupts for endpoint */
 80226d4:	2001      	movs	r0, #1
		/* clear stall */
		data.b.stall = 0U;
		/* set tx fifo */
		ep->txFifoNum = XMC_USBD_lAssignTXFifo(); /* get tx fifo */
		data.b.txfnum = ep->txFifoNum;
		xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32; /* configure endpoint */
 80226d6:	6034      	str	r4, [r6, #0]
		daintmsk.ep.in |= (uint16_t)((uint16_t)1U << (uint8_t)ep->address_u.address_st.number); /* enable interrupts for endpoint */
 80226d8:	4098      	lsls	r0, r3
  }
  if ((ep->address_u.address_st.direction == 0U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
 80226da:	f815 400c 	ldrb.w	r4, [r5, ip]
		data.b.stall = 0U;
		/* set tx fifo */
		ep->txFifoNum = XMC_USBD_lAssignTXFifo(); /* get tx fifo */
		data.b.txfnum = ep->txFifoNum;
		xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32; /* configure endpoint */
		daintmsk.ep.in |= (uint16_t)((uint16_t)1U << (uint8_t)ep->address_u.address_st.number); /* enable interrupts for endpoint */
 80226de:	b280      	uxth	r0, r0
 80226e0:	ea40 060e 	orr.w	r6, r0, lr
  }
  if ((ep->address_u.address_st.direction == 0U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
 80226e4:	0624      	lsls	r4, r4, #24
		data.b.stall = 0U;
		/* set tx fifo */
		ep->txFifoNum = XMC_USBD_lAssignTXFifo(); /* get tx fifo */
		data.b.txfnum = ep->txFifoNum;
		xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32; /* configure endpoint */
		daintmsk.ep.in |= (uint16_t)((uint16_t)1U << (uint8_t)ep->address_u.address_st.number); /* enable interrupts for endpoint */
 80226e6:	f366 0e0f 	bfi	lr, r6, #0, #16
  }
  if ((ep->address_u.address_st.direction == 0U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
 80226ea:	d529      	bpl.n	8022740 <XMC_USBD_EndpointConfigure+0x1dc>
 80226ec:	2900      	cmp	r1, #0
 80226ee:	d1a9      	bne.n	8022644 <XMC_USBD_EndpointConfigure+0xe0>
  {
    /* is out */
		depctl_data_t data;
		data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 80226f0:	eb08 0383 	add.w	r3, r8, r3, lsl #2
 80226f4:	f8d3 61c4 	ldr.w	r6, [r3, #452]	; 0x1c4
 80226f8:	6834      	ldr	r4, [r6, #0]
		/*enable endpoint */
		data.b.usbactep = 1U;
 80226fa:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
		/* set ep type */
		data.b.eptype = (uint8_t)ep_type;
 80226fe:	f361 4493 	bfi	r4, r1, #18, #2
    /* set mps */
    if (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL)
		{
			switch(ep_max_packet_size)
 8022702:	2a10      	cmp	r2, #16
 8022704:	d03c      	beq.n	8022780 <XMC_USBD_EndpointConfigure+0x21c>
 8022706:	d934      	bls.n	8022772 <XMC_USBD_EndpointConfigure+0x20e>
 8022708:	2a20      	cmp	r2, #32
 802270a:	d02e      	beq.n	802276a <XMC_USBD_EndpointConfigure+0x206>
 802270c:	2a40      	cmp	r2, #64	; 0x40
 802270e:	d190      	bne.n	8022632 <XMC_USBD_EndpointConfigure+0xce>
			{
				case (64U):
					data.b.mps = 0x0U;
 8022710:	f36f 040a 	bfc	r4, #0, #11
					break;
 8022714:	e78d      	b.n	8022632 <XMC_USBD_EndpointConfigure+0xce>
  ep->outBufferSize = XMC_USBD_EP_OUT_BUFFERSIZE[ep->address_u.address_st.number];
  /* is in */
  if ((ep->address_u.address_st.direction == 1U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
  {
    depctl_data_t data;
    data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022716:	f103 006a 	add.w	r0, r3, #106	; 0x6a
 802271a:	f855 6020 	ldr.w	r6, [r5, r0, lsl #2]
 802271e:	6834      	ldr	r4, [r6, #0]
		/*enable endpoint */
		data.b.usbactep = 1U;
 8022720:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
		/* set ep type */
		data.b.eptype = (uint8_t)ep_type;
 8022724:	f361 4493 	bfi	r4, r1, #18, #2
		/* set mps */
    if (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL)
    {
			switch(ep_max_packet_size)
 8022728:	2a10      	cmp	r2, #16
 802272a:	d031      	beq.n	8022790 <XMC_USBD_EndpointConfigure+0x22c>
 802272c:	d915      	bls.n	802275a <XMC_USBD_EndpointConfigure+0x1f6>
 802272e:	2a20      	cmp	r2, #32
 8022730:	d02a      	beq.n	8022788 <XMC_USBD_EndpointConfigure+0x224>
 8022732:	2a40      	cmp	r2, #64	; 0x40
 8022734:	d19a      	bne.n	802266c <XMC_USBD_EndpointConfigure+0x108>
			{
				case (64U):
				data.b.mps = 0x0U;
 8022736:	f36f 040a 	bfc	r4, #0, #11
				break;
 802273a:	e797      	b.n	802266c <XMC_USBD_EndpointConfigure+0x108>
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
    i++;
  }
  if ((xmc_device.txfifomsk & mask) == 0U)
 802273c:	2700      	movs	r7, #0
 802273e:	e7ba      	b.n	80226b6 <XMC_USBD_EndpointConfigure+0x152>
  }
  if ((ep->address_u.address_st.direction == 0U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
  {
    /* is out */
		depctl_data_t data;
		data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 8022740:	eb08 0383 	add.w	r3, r8, r3, lsl #2
 8022744:	f8d3 61c4 	ldr.w	r6, [r3, #452]	; 0x1c4
 8022748:	6834      	ldr	r4, [r6, #0]
		/*enable endpoint */
		data.b.usbactep = 1U;
 802274a:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
		/* set ep type */
		data.b.eptype = (uint8_t)ep_type;
 802274e:	f361 4493 	bfi	r4, r1, #18, #2
    /* set mps */
    if (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL)
 8022752:	2900      	cmp	r1, #0
 8022754:	f47f af6b 	bne.w	802262e <XMC_USBD_EndpointConfigure+0xca>
 8022758:	e7d3      	b.n	8022702 <XMC_USBD_EndpointConfigure+0x19e>
		/* set ep type */
		data.b.eptype = (uint8_t)ep_type;
		/* set mps */
    if (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL)
    {
			switch(ep_max_packet_size)
 802275a:	2a08      	cmp	r2, #8
 802275c:	d186      	bne.n	802266c <XMC_USBD_EndpointConfigure+0x108>
				break;
				case (16U):
				data.b.mps = 0x2U;
				break;
				case (8U):
				data.b.mps = 0x3U;
 802275e:	2703      	movs	r7, #3
 8022760:	f855 6020 	ldr.w	r6, [r5, r0, lsl #2]
 8022764:	f367 040a 	bfi	r4, r7, #0, #11
				break;
 8022768:	e780      	b.n	802266c <XMC_USBD_EndpointConfigure+0x108>
			{
				case (64U):
					data.b.mps = 0x0U;
					break;
				case (32U):
					data.b.mps = 0x1U;
 802276a:	2301      	movs	r3, #1
 802276c:	f363 040a 	bfi	r4, r3, #0, #11
					break;
 8022770:	e75f      	b.n	8022632 <XMC_USBD_EndpointConfigure+0xce>
		/* set ep type */
		data.b.eptype = (uint8_t)ep_type;
    /* set mps */
    if (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL)
		{
			switch(ep_max_packet_size)
 8022772:	2a08      	cmp	r2, #8
 8022774:	f47f af5d 	bne.w	8022632 <XMC_USBD_EndpointConfigure+0xce>
					break;
				case (16U):
					data.b.mps = 0x2U;
					break;
				case (8U):
					data.b.mps = 0x3U;
 8022778:	2303      	movs	r3, #3
 802277a:	f363 040a 	bfi	r4, r3, #0, #11
					break;
 802277e:	e758      	b.n	8022632 <XMC_USBD_EndpointConfigure+0xce>
					break;
				case (32U):
					data.b.mps = 0x1U;
					break;
				case (16U):
					data.b.mps = 0x2U;
 8022780:	2302      	movs	r3, #2
 8022782:	f363 040a 	bfi	r4, r3, #0, #11
					break;
 8022786:	e754      	b.n	8022632 <XMC_USBD_EndpointConfigure+0xce>
			{
				case (64U):
				data.b.mps = 0x0U;
				break;
				case (32U):
				data.b.mps = 0x1U;
 8022788:	2001      	movs	r0, #1
 802278a:	f360 040a 	bfi	r4, r0, #0, #11
				break;
 802278e:	e76d      	b.n	802266c <XMC_USBD_EndpointConfigure+0x108>
				case (16U):
				data.b.mps = 0x2U;
 8022790:	2702      	movs	r7, #2
 8022792:	f855 6020 	ldr.w	r6, [r5, r0, lsl #2]
 8022796:	f367 040a 	bfi	r4, r7, #0, #11
				break;
 802279a:	e767      	b.n	802266c <XMC_USBD_EndpointConfigure+0x108>
 *
 * @return Fifo number for a free fifo
 */
static uint8_t XMC_USBD_lAssignTXFifo(void) 
{
  uint16_t mask = 1U;
 802279c:	f04f 0801 	mov.w	r8, #1
 80227a0:	e785      	b.n	80226ae <XMC_USBD_EndpointConfigure+0x14a>
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
    i++;
 80227a2:	2701      	movs	r7, #1
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
 80227a4:	f04f 0802 	mov.w	r8, #2
 80227a8:	e781      	b.n	80226ae <XMC_USBD_EndpointConfigure+0x14a>
    i++;
 80227aa:	2702      	movs	r7, #2
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
 80227ac:	f04f 0804 	mov.w	r8, #4
 80227b0:	e77d      	b.n	80226ae <XMC_USBD_EndpointConfigure+0x14a>
    i++;
 80227b2:	2703      	movs	r7, #3
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
 80227b4:	f04f 0808 	mov.w	r8, #8
 80227b8:	e779      	b.n	80226ae <XMC_USBD_EndpointConfigure+0x14a>
    i++;
 80227ba:	2704      	movs	r7, #4
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
 80227bc:	f04f 0810 	mov.w	r8, #16
 80227c0:	e775      	b.n	80226ae <XMC_USBD_EndpointConfigure+0x14a>
    i++;
 80227c2:	2705      	movs	r7, #5
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
 80227c4:	f04f 0820 	mov.w	r8, #32
 80227c8:	e771      	b.n	80226ae <XMC_USBD_EndpointConfigure+0x14a>
    i++;
 80227ca:	2706      	movs	r7, #6
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
 80227cc:	f04f 0840 	mov.w	r8, #64	; 0x40
 80227d0:	e76d      	b.n	80226ae <XMC_USBD_EndpointConfigure+0x14a>
 80227d2:	bf00      	nop
 80227d4:	1fffa868 	.word	0x1fffa868
 80227d8:	20000000 	.word	0x20000000
 80227dc:	1ffe8ce0 	.word	0x1ffe8ce0
 80227e0:	1ffe8cc4 	.word	0x1ffe8cc4

080227e4 <XMC_USBD_EndpointRead>:

/**
 * Reads the number of bytes from the USB OUT endpoint
 **/
int32_t XMC_USBD_EndpointRead(const uint8_t ep_num,uint8_t * buffer,uint32_t length) 
{
 80227e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_num];
  if (length > ep->outBytesAvailable)
 80227e6:	4f0e      	ldr	r7, [pc, #56]	; (8022820 <XMC_USBD_EndpointRead+0x3c>)
 80227e8:	2434      	movs	r4, #52	; 0x34
 80227ea:	fb04 7400 	mla	r4, r4, r0, r7

/**
 * Reads the number of bytes from the USB OUT endpoint
 **/
int32_t XMC_USBD_EndpointRead(const uint8_t ep_num,uint8_t * buffer,uint32_t length) 
{
 80227ee:	4606      	mov	r6, r0
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_num];
  if (length > ep->outBytesAvailable)
 80227f0:	6925      	ldr	r5, [r4, #16]
  {
    length = ep->outBytesAvailable;
  }
  memcpy(buffer,&ep->outBuffer[ep->outOffset],length);
 80227f2:	69a3      	ldr	r3, [r4, #24]
 80227f4:	4295      	cmp	r5, r2
 80227f6:	4608      	mov	r0, r1
 80227f8:	68e1      	ldr	r1, [r4, #12]
 80227fa:	bf28      	it	cs
 80227fc:	4615      	movcs	r5, r2
 80227fe:	4419      	add	r1, r3
 8022800:	462a      	mov	r2, r5
 8022802:	f008 f98d 	bl	802ab20 <memcpy>
  ep->outBytesAvailable -= length;
 8022806:	6923      	ldr	r3, [r4, #16]
 8022808:	1b5b      	subs	r3, r3, r5
 802280a:	6123      	str	r3, [r4, #16]
  if (ep->outBytesAvailable)
 802280c:	b10b      	cbz	r3, 8022812 <XMC_USBD_EndpointRead+0x2e>
  {
    ep->outOffset += length;
 802280e:	69a3      	ldr	r3, [r4, #24]
 8022810:	442b      	add	r3, r5
 8022812:	2234      	movs	r2, #52	; 0x34
 8022814:	fb02 7606 	mla	r6, r2, r6, r7
  else
  {
    ep->outOffset = 0U;
  }
  return (int32_t)length;
}
 8022818:	4628      	mov	r0, r5
 802281a:	61b3      	str	r3, [r6, #24]
 802281c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802281e:	bf00      	nop
 8022820:	1fffa868 	.word	0x1fffa868

08022824 <XMC_USBD_Init>:

/**
 * Initializes the USB device
 **/
XMC_USBD_STATUS_t XMC_USBD_Init(XMC_USBD_t *obj)
{
 8022824:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8022828:	4607      	mov	r7, r0
 802282a:	b083      	sub	sp, #12
 * Enables the USB0 module
 **/
void XMC_USBD_Enable(void) 
{
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USB0);
 802282c:	4869      	ldr	r0, [pc, #420]	; (80229d4 <XMC_USBD_Init+0x1b0>)
	  XMC_USBD_EP_OUT_BUFFERSIZE[i] = XMC_USBD_EP0_BUFFER_SIZE;
	  XMC_USBD_EP_IN_BUFFERSIZE[i] 	= XMC_USBD_EP0_BUFFER_SIZE;
  }

  /* clear device status */
  memset((void*)&xmc_device,0x0U,sizeof(XMC_USBD_DEVICE_t));
 802282e:	4c6a      	ldr	r4, [pc, #424]	; (80229d8 <XMC_USBD_Init+0x1b4>)
  usbd_init = obj;

  /* Filling out buffer size */
  for(i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
	  XMC_USBD_EP_OUT_BUFFERSIZE[i] = XMC_USBD_EP0_BUFFER_SIZE;
 8022830:	4e6a      	ldr	r6, [pc, #424]	; (80229dc <XMC_USBD_Init+0x1b8>)
	  XMC_USBD_EP_IN_BUFFERSIZE[i] 	= XMC_USBD_EP0_BUFFER_SIZE;
 8022832:	4d6b      	ldr	r5, [pc, #428]	; (80229e0 <XMC_USBD_Init+0x1bc>)
 * Enables the USB0 module
 **/
void XMC_USBD_Enable(void) 
{
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USB0);
 8022834:	f7fe fe6c 	bl	8021510 <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif
  /* Reset and power up */
  XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_USB0);
 8022838:	4866      	ldr	r0, [pc, #408]	; (80229d4 <XMC_USBD_Init+0x1b0>)
 802283a:	f7fe fdf9 	bl	8021430 <XMC_SCU_RESET_DeassertPeripheralReset>
  XMC_SCU_POWER_EnableUsb();
 802283e:	f7fe fea5 	bl	802158c <XMC_SCU_POWER_EnableUsb>
  XMC_ASSERT("XMC_USBD_Init: obj.usbd_max_num_eps not of type XMC_USBD_MAX_NUM_EPS_t",
 		      XMC_USBD_CHECK_INPUT_MAX_NUM_EPS(obj->usbd_max_num_eps))
  
  XMC_USBD_Enable();
  
  usbd_init = obj;
 8022842:	4b68      	ldr	r3, [pc, #416]	; (80229e4 <XMC_USBD_Init+0x1c0>)
	  XMC_USBD_EP_OUT_BUFFERSIZE[i] = XMC_USBD_EP0_BUFFER_SIZE;
	  XMC_USBD_EP_IN_BUFFERSIZE[i] 	= XMC_USBD_EP0_BUFFER_SIZE;
  }

  /* clear device status */
  memset((void*)&xmc_device,0x0U,sizeof(XMC_USBD_DEVICE_t));
 8022844:	2100      	movs	r1, #0
  XMC_ASSERT("XMC_USBD_Init: obj.usbd_max_num_eps not of type XMC_USBD_MAX_NUM_EPS_t",
 		      XMC_USBD_CHECK_INPUT_MAX_NUM_EPS(obj->usbd_max_num_eps))
  
  XMC_USBD_Enable();
  
  usbd_init = obj;
 8022846:	601f      	str	r7, [r3, #0]
	  XMC_USBD_EP_OUT_BUFFERSIZE[i] = XMC_USBD_EP0_BUFFER_SIZE;
	  XMC_USBD_EP_IN_BUFFERSIZE[i] 	= XMC_USBD_EP0_BUFFER_SIZE;
  }

  /* clear device status */
  memset((void*)&xmc_device,0x0U,sizeof(XMC_USBD_DEVICE_t));
 8022848:	f44f 7202 	mov.w	r2, #520	; 0x208
  usbd_init = obj;

  /* Filling out buffer size */
  for(i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
	  XMC_USBD_EP_OUT_BUFFERSIZE[i] = XMC_USBD_EP0_BUFFER_SIZE;
 802284c:	2340      	movs	r3, #64	; 0x40
	  XMC_USBD_EP_IN_BUFFERSIZE[i] 	= XMC_USBD_EP0_BUFFER_SIZE;
  }

  /* clear device status */
  memset((void*)&xmc_device,0x0U,sizeof(XMC_USBD_DEVICE_t));
 802284e:	4620      	mov	r0, r4
  usbd_init = obj;

  /* Filling out buffer size */
  for(i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
	  XMC_USBD_EP_OUT_BUFFERSIZE[i] = XMC_USBD_EP0_BUFFER_SIZE;
 8022850:	6033      	str	r3, [r6, #0]
 8022852:	6073      	str	r3, [r6, #4]
 8022854:	60b3      	str	r3, [r6, #8]
 8022856:	60f3      	str	r3, [r6, #12]
 8022858:	6133      	str	r3, [r6, #16]
 802285a:	6173      	str	r3, [r6, #20]
 802285c:	61b3      	str	r3, [r6, #24]
	  XMC_USBD_EP_IN_BUFFERSIZE[i] 	= XMC_USBD_EP0_BUFFER_SIZE;
 802285e:	602b      	str	r3, [r5, #0]
 8022860:	606b      	str	r3, [r5, #4]
 8022862:	60ab      	str	r3, [r5, #8]
 8022864:	60eb      	str	r3, [r5, #12]
 8022866:	612b      	str	r3, [r5, #16]
 8022868:	616b      	str	r3, [r5, #20]
 802286a:	61ab      	str	r3, [r5, #24]
  }

  /* clear device status */
  memset((void*)&xmc_device,0x0U,sizeof(XMC_USBD_DEVICE_t));
 802286c:	f008 f963 	bl	802ab36 <memset>

  /* assign callbacks */
  xmc_device.DeviceEvent_cb = obj->cb_xmc_device_event;
  xmc_device.EndpointEvent_cb = obj->cb_endpoint_event;
  XMC_USBD_BASE_ADDRESS = (uint8_t *)(obj->usbd);
 8022870:	683b      	ldr	r3, [r7, #0]
  /* Done by driver core */
  /* configure ahb details */  
  gahbcfg.d32 = xmc_device.global_register->gahbcfg;
  gahbcfg.b.glblintrmsk = 1U; /* enable interrupts ( global mask ) */
  gahbcfg.b.nptxfemplvl_txfemplvl = 1U;
  if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022872:	7b7d      	ldrb	r5, [r7, #13]
    						(i * XMC_USBD_TX_FIFO_OFFSET));
  }
  /* obj data structure for endpoint 0 */
  /* Done by driver core */
  /* configure ahb details */  
  gahbcfg.d32 = xmc_device.global_register->gahbcfg;
 8022874:	689a      	ldr	r2, [r3, #8]

  /* clear device status */
  memset((void*)&xmc_device,0x0U,sizeof(XMC_USBD_DEVICE_t));

  /* assign callbacks */
  xmc_device.DeviceEvent_cb = obj->cb_xmc_device_event;
 8022876:	6878      	ldr	r0, [r7, #4]
  xmc_device.EndpointEvent_cb = obj->cb_endpoint_event;
 8022878:	68be      	ldr	r6, [r7, #8]
  /* Done by driver core */
  /* configure ahb details */  
  gahbcfg.d32 = xmc_device.global_register->gahbcfg;
  gahbcfg.b.glblintrmsk = 1U; /* enable interrupts ( global mask ) */
  gahbcfg.b.nptxfemplvl_txfemplvl = 1U;
  if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 802287a:	fab5 f185 	clz	r1, r5
  xmc_device.DeviceEvent_cb = obj->cb_xmc_device_event;
  xmc_device.EndpointEvent_cb = obj->cb_endpoint_event;
  XMC_USBD_BASE_ADDRESS = (uint8_t *)(obj->usbd);
  /* assign register address */
  xmc_device.global_register = (dwc_otg_core_global_regs_t*)(obj->usbd);
  xmc_device.device_register = ((dwc_otg_device_global_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_GLOBAL_REG_OFFSET));
 802287e:	f503 6a00 	add.w	sl, r3, #2048	; 0x800
  /* Done by driver core */
  /* configure ahb details */  
  gahbcfg.d32 = xmc_device.global_register->gahbcfg;
  gahbcfg.b.glblintrmsk = 1U; /* enable interrupts ( global mask ) */
  gahbcfg.b.nptxfemplvl_txfemplvl = 1U;
  if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022882:	0949      	lsrs	r1, r1, #5
  /* assign register address */
  xmc_device.global_register = (dwc_otg_core_global_regs_t*)(obj->usbd);
  xmc_device.device_register = ((dwc_otg_device_global_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_GLOBAL_REG_OFFSET));
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
    xmc_device.endpoint_in_register[i] = (dwc_otg_dev_in_ep_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_IN_EP_REG_OFFSET +
 8022884:	f503 6910 	add.w	r9, r3, #2304	; 0x900
  /* obj data structure for endpoint 0 */
  /* Done by driver core */
  /* configure ahb details */  
  gahbcfg.d32 = xmc_device.global_register->gahbcfg;
  gahbcfg.b.glblintrmsk = 1U; /* enable interrupts ( global mask ) */
  gahbcfg.b.nptxfemplvl_txfemplvl = 1U;
 8022888:	f042 0281 	orr.w	r2, r2, #129	; 0x81

  /* clear device status */
  memset((void*)&xmc_device,0x0U,sizeof(XMC_USBD_DEVICE_t));

  /* assign callbacks */
  xmc_device.DeviceEvent_cb = obj->cb_xmc_device_event;
 802288c:	f8c4 0200 	str.w	r0, [r4, #512]	; 0x200
  xmc_device.EndpointEvent_cb = obj->cb_endpoint_event;
 8022890:	f8c4 6204 	str.w	r6, [r4, #516]	; 0x204
  XMC_USBD_BASE_ADDRESS = (uint8_t *)(obj->usbd);
  /* assign register address */
  xmc_device.global_register = (dwc_otg_core_global_regs_t*)(obj->usbd);
  xmc_device.device_register = ((dwc_otg_device_global_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_GLOBAL_REG_OFFSET));
 8022894:	f8c4 a1a4 	str.w	sl, [r4, #420]	; 0x1a4
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
    xmc_device.endpoint_in_register[i] = (dwc_otg_dev_in_ep_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_IN_EP_REG_OFFSET +
 8022898:	f8c4 91a8 	str.w	r9, [r4, #424]	; 0x1a8
 802289c:	f361 1245 	bfi	r2, r1, #5, #1
 80228a0:	f503 6812 	add.w	r8, r3, #2336	; 0x920
 80228a4:	f503 6c14 	add.w	ip, r3, #2368	; 0x940
 80228a8:	f503 6e16 	add.w	lr, r3, #2400	; 0x960
 80228ac:	f503 6718 	add.w	r7, r3, #2432	; 0x980
 80228b0:	f503 601a 	add.w	r0, r3, #2464	; 0x9a0
 80228b4:	f503 6b1c 	add.w	fp, r3, #2496	; 0x9c0
    ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
    xmc_device.endpoint_out_register[i] = (dwc_otg_dev_out_ep_regs_t*)(XMC_USBD_BASE_ADDRESS +
    									  DWC_DEV_OUT_EP_REG_OFFSET +
 80228b8:	f503 6130 	add.w	r1, r3, #2816	; 0xb00
 80228bc:	f503 6632 	add.w	r6, r3, #2848	; 0xb20
 80228c0:	f503 6a34 	add.w	sl, r3, #2880	; 0xb40
 80228c4:	f503 6936 	add.w	r9, r3, #2912	; 0xb60
  /* assign register address */
  xmc_device.global_register = (dwc_otg_core_global_regs_t*)(obj->usbd);
  xmc_device.device_register = ((dwc_otg_device_global_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_GLOBAL_REG_OFFSET));
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
    xmc_device.endpoint_in_register[i] = (dwc_otg_dev_in_ep_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_IN_EP_REG_OFFSET +
 80228c8:	f8c4 81ac 	str.w	r8, [r4, #428]	; 0x1ac
 80228cc:	f8c4 c1b0 	str.w	ip, [r4, #432]	; 0x1b0
 80228d0:	f8c4 e1b4 	str.w	lr, [r4, #436]	; 0x1b4
 80228d4:	f8c4 71b8 	str.w	r7, [r4, #440]	; 0x1b8
 80228d8:	f8c4 01bc 	str.w	r0, [r4, #444]	; 0x1bc
 80228dc:	f8c4 b1c0 	str.w	fp, [r4, #448]	; 0x1c0
    ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
    xmc_device.endpoint_out_register[i] = (dwc_otg_dev_out_ep_regs_t*)(XMC_USBD_BASE_ADDRESS +
 80228e0:	f8c4 11c4 	str.w	r1, [r4, #452]	; 0x1c4
 80228e4:	f8c4 61c8 	str.w	r6, [r4, #456]	; 0x1c8
 80228e8:	f8c4 a1cc 	str.w	sl, [r4, #460]	; 0x1cc
 80228ec:	f8c4 91d0 	str.w	r9, [r4, #464]	; 0x1d0
    									  ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.fifo[i] = (uint32_t*)(XMC_USBD_BASE_ADDRESS +
    						XMC_USBD_TX_FIFO_REG_OFFSET +
 80228f0:	f503 4180 	add.w	r1, r3, #16384	; 0x4000
    ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
    xmc_device.endpoint_out_register[i] = (dwc_otg_dev_out_ep_regs_t*)(XMC_USBD_BASE_ADDRESS +
    									  DWC_DEV_OUT_EP_REG_OFFSET +
 80228f4:	f503 6838 	add.w	r8, r3, #2944	; 0xb80
 80228f8:	f503 6c3a 	add.w	ip, r3, #2976	; 0xba0
 80228fc:	f503 6e3c 	add.w	lr, r3, #3008	; 0xbc0
    									  ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.fifo[i] = (uint32_t*)(XMC_USBD_BASE_ADDRESS +
    						XMC_USBD_TX_FIFO_REG_OFFSET +
 8022900:	f503 5780 	add.w	r7, r3, #4096	; 0x1000
 8022904:	f503 5000 	add.w	r0, r3, #8192	; 0x2000
 8022908:	f503 5b40 	add.w	fp, r3, #12288	; 0x3000
 802290c:	f503 46a0 	add.w	r6, r3, #20480	; 0x5000
 8022910:	f503 4ac0 	add.w	sl, r3, #24576	; 0x6000
 8022914:	f503 49e0 	add.w	r9, r3, #28672	; 0x7000
    									  DWC_DEV_OUT_EP_REG_OFFSET +
    									  ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.fifo[i] = (uint32_t*)(XMC_USBD_BASE_ADDRESS +
 8022918:	f8c4 11ec 	str.w	r1, [r4, #492]	; 0x1ec
  /* assign callbacks */
  xmc_device.DeviceEvent_cb = obj->cb_xmc_device_event;
  xmc_device.EndpointEvent_cb = obj->cb_endpoint_event;
  XMC_USBD_BASE_ADDRESS = (uint8_t *)(obj->usbd);
  /* assign register address */
  xmc_device.global_register = (dwc_otg_core_global_regs_t*)(obj->usbd);
 802291c:	f8c4 31a0 	str.w	r3, [r4, #416]	; 0x1a0
    xmc_device.endpoint_in_register[i] = (dwc_otg_dev_in_ep_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_IN_EP_REG_OFFSET +
    ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
    xmc_device.endpoint_out_register[i] = (dwc_otg_dev_out_ep_regs_t*)(XMC_USBD_BASE_ADDRESS +
 8022920:	f8c4 81d4 	str.w	r8, [r4, #468]	; 0x1d4
 8022924:	f8c4 c1d8 	str.w	ip, [r4, #472]	; 0x1d8
 8022928:	f8c4 e1dc 	str.w	lr, [r4, #476]	; 0x1dc
    									  DWC_DEV_OUT_EP_REG_OFFSET +
    									  ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.fifo[i] = (uint32_t*)(XMC_USBD_BASE_ADDRESS +
 802292c:	f8c4 71e0 	str.w	r7, [r4, #480]	; 0x1e0
 8022930:	f8c4 01e4 	str.w	r0, [r4, #484]	; 0x1e4
 8022934:	f8c4 b1e8 	str.w	fp, [r4, #488]	; 0x1e8
 8022938:	f8c4 61f0 	str.w	r6, [r4, #496]	; 0x1f0
 802293c:	f8c4 a1f4 	str.w	sl, [r4, #500]	; 0x1f4
 8022940:	f8c4 91f8 	str.w	r9, [r4, #504]	; 0x1f8
  }
  else
  {
    gahbcfg.b.dmaenable = 0U;
  }
  xmc_device.global_register->gahbcfg = gahbcfg.d32;
 8022944:	609a      	str	r2, [r3, #8]
  /* configure usb details */  
  gusbcfg.d32= xmc_device.global_register->gusbcfg;
 8022946:	68d9      	ldr	r1, [r3, #12]
  gusbcfg.b.force_dev_mode = 1U; /* force us into device mode */
  gusbcfg.b.srpcap = 1U; /* enable session request protocoll */
 8022948:	f041 4180 	orr.w	r1, r1, #1073741824	; 0x40000000
 802294c:	f441 7180 	orr.w	r1, r1, #256	; 0x100
  xmc_device.global_register->gusbcfg = gusbcfg.d32;
 8022950:	60d9      	str	r1, [r3, #12]

  /* Device init */
  /* configure device speed */  
  dcfg.d32 = xmc_device.device_register->dcfg;
 8022952:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
  dcfg.b.devspd = XMC_USBD_DCFG_DEVSPD_FS;
 8022956:	f042 0203 	orr.w	r2, r2, #3
  dcfg.b.descdma = 0U;
 802295a:	f36f 52d7 	bfc	r2, #23, #1
  xmc_device.device_register->dcfg = dcfg.d32;
 802295e:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
  /* configure device functions */  
  dctl.d32 = xmc_device.device_register->dctl;
 8022962:	f8d3 2804 	ldr.w	r2, [r3, #2052]	; 0x804
 */
static void XMC_USBD_lFlushTXFifo(const uint8_t fifo_num) 
{
  volatile grstctl_t data;  
  uint32_t count;
  data.d32 = 0U;
 8022966:	2100      	movs	r1, #0
  dcfg.b.devspd = XMC_USBD_DCFG_DEVSPD_FS;
  dcfg.b.descdma = 0U;
  xmc_device.device_register->dcfg = dcfg.d32;
  /* configure device functions */  
  dctl.d32 = xmc_device.device_register->dctl;
  dctl.b.sftdiscon = 1U; /* disconnect the device until its connected by the user */
 8022968:	f042 0202 	orr.w	r2, r2, #2
  /* all other config is done by default register value */
  xmc_device.device_register->dctl = dctl.d32;
 802296c:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
 */
static void XMC_USBD_lFlushTXFifo(const uint8_t fifo_num) 
{
  volatile grstctl_t data;  
  uint32_t count;
  data.d32 = 0U;
 8022970:	9100      	str	r1, [sp, #0]
  /*flush fifo */
  data.b.txfflsh = 1U;
 8022972:	9a00      	ldr	r2, [sp, #0]
 8022974:	f042 0220 	orr.w	r2, r2, #32
 8022978:	9200      	str	r2, [sp, #0]
  data.b.txfnum = fifo_num;
 802297a:	9900      	ldr	r1, [sp, #0]
 802297c:	f421 61f8 	bic.w	r1, r1, #1984	; 0x7c0
 8022980:	f441 6180 	orr.w	r1, r1, #1024	; 0x400
 8022984:	9100      	str	r1, [sp, #0]
  xmc_device.global_register->grstctl = data.d32;
 8022986:	9a00      	ldr	r2, [sp, #0]
 8022988:	611a      	str	r2, [r3, #16]
  for (count = 0U;count < 1000U; count++){}
  do
  {
   data.d32 = xmc_device.global_register->grstctl;
 802298a:	691a      	ldr	r2, [r3, #16]
 802298c:	9200      	str	r2, [sp, #0]
  } while (data.b.txfflsh);
 802298e:	9a00      	ldr	r2, [sp, #0]
 8022990:	f3c2 1240 	ubfx	r2, r2, #5, #1
 8022994:	2a00      	cmp	r2, #0
 8022996:	d1f8      	bne.n	802298a <XMC_USBD_Init+0x166>
static void XMC_USBD_lFlushRXFifo(void) 
{
  volatile grstctl_t data;  
  uint32_t count;
	
	data.d32 = 0U;
 8022998:	9201      	str	r2, [sp, #4]
  data.b.rxfflsh = 1U;
 802299a:	9a01      	ldr	r2, [sp, #4]
 802299c:	f042 0210 	orr.w	r2, r2, #16
 80229a0:	9201      	str	r2, [sp, #4]
  /* flush FIFO */
  xmc_device.global_register->grstctl = data.d32;
 80229a2:	9a01      	ldr	r2, [sp, #4]
 80229a4:	611a      	str	r2, [r3, #16]
  do
  {
    for (count = 0U; count < 1000U; count++){}
    data.d32 = xmc_device.global_register->grstctl;
 80229a6:	691a      	ldr	r2, [r3, #16]
 80229a8:	9201      	str	r2, [sp, #4]
  } while (data.b.rxfflsh);
 80229aa:	9801      	ldr	r0, [sp, #4]
 80229ac:	f3c0 1000 	ubfx	r0, r0, #4, #1
 80229b0:	2800      	cmp	r0, #0
 80229b2:	d1f8      	bne.n	80229a6 <XMC_USBD_Init+0x182>
  gintmsk.b.usbsuspend = 1U;
  gintmsk.b.wkupintr = 1U;
  gintmsk.b.sofintr = 1U;
  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
  {
    gintmsk.b.rxstsqlvl = 1U;
 80229b4:	490c      	ldr	r1, [pc, #48]	; (80229e8 <XMC_USBD_Init+0x1c4>)
 80229b6:	4a0d      	ldr	r2, [pc, #52]	; (80229ec <XMC_USBD_Init+0x1c8>)
  /* flush the fifos for proper operation */
  XMC_USBD_lFlushTXFifo((uint8_t)0x10U); /* 0x10 == all fifos, see doc */
  XMC_USBD_lFlushRXFifo();
  /* Enable Global Interrupts */
  /* clear interrupt status bits prior to unmasking */
  xmc_device.global_register->gintmsk = 0U; /* disable all interrupts */
 80229b8:	6198      	str	r0, [r3, #24]
  gintmsk.b.usbsuspend = 1U;
  gintmsk.b.wkupintr = 1U;
  gintmsk.b.sofintr = 1U;
  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
  {
    gintmsk.b.rxstsqlvl = 1U;
 80229ba:	2d01      	cmp	r5, #1
 80229bc:	bf18      	it	ne
 80229be:	460a      	movne	r2, r1
  }
  gintmsk.b.outepintr = 1U;
  gintmsk.b.inepintr = 1U;
 80229c0:	f442 2240 	orr.w	r2, r2, #786432	; 0xc0000
  XMC_USBD_lFlushTXFifo((uint8_t)0x10U); /* 0x10 == all fifos, see doc */
  XMC_USBD_lFlushRXFifo();
  /* Enable Global Interrupts */
  /* clear interrupt status bits prior to unmasking */
  xmc_device.global_register->gintmsk = 0U; /* disable all interrupts */
  xmc_device.global_register->gintsts = 0xFFFFFFFFU; /* clear all interrupts */
 80229c4:	f04f 31ff 	mov.w	r1, #4294967295
 80229c8:	6159      	str	r1, [r3, #20]
  {
    gintmsk.b.rxstsqlvl = 1U;
  }
  gintmsk.b.outepintr = 1U;
  gintmsk.b.inepintr = 1U;
  xmc_device.global_register->gintmsk = gintmsk.d32;
 80229ca:	619a      	str	r2, [r3, #24]
  return XMC_USBD_STATUS_OK;
}
 80229cc:	b003      	add	sp, #12
 80229ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80229d2:	bf00      	nop
 80229d4:	20000080 	.word	0x20000080
 80229d8:	1fffa868 	.word	0x1fffa868
 80229dc:	1ffe8cc4 	.word	0x1ffe8cc4
 80229e0:	1ffe8ce0 	.word	0x1ffe8ce0
 80229e4:	1fffa864 	.word	0x1fffa864
 80229e8:	c0003c0e 	.word	0xc0003c0e
 80229ec:	c0003c1e 	.word	0xc0003c1e

080229f0 <XMC_USBD_EndpointReadStart>:

/**
 * Prepares the endpoint to read next OUT packet
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointReadStart(const uint8_t ep_addr, uint32_t size) 
{
 80229f0:	b4f0      	push	{r4, r5, r6, r7}
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_addr & (uint8_t)XMC_USBD_EP_NUM_MASK];
 80229f2:	f000 000f 	and.w	r0, r0, #15
  XMC_USBD_STATUS_t result;
	
  if (ep->outInUse || !ep->isConfigured)
 80229f6:	2434      	movs	r4, #52	; 0x34
 80229f8:	4e33      	ldr	r6, [pc, #204]	; (8022ac8 <XMC_USBD_EndpointReadStart+0xd8>)
 80229fa:	fb04 f400 	mul.w	r4, r4, r0
 80229fe:	1932      	adds	r2, r6, r4

/**
 * Prepares the endpoint to read next OUT packet
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointReadStart(const uint8_t ep_addr, uint32_t size) 
{
 8022a00:	b082      	sub	sp, #8
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_addr & (uint8_t)XMC_USBD_EP_NUM_MASK];
  XMC_USBD_STATUS_t result;
	
  if (ep->outInUse || !ep->isConfigured)
 8022a02:	6853      	ldr	r3, [r2, #4]
 8022a04:	f3c3 1300 	ubfx	r3, r3, #4, #1
 8022a08:	2b00      	cmp	r3, #0
 8022a0a:	d136      	bne.n	8022a7a <XMC_USBD_EndpointReadStart+0x8a>
 8022a0c:	7915      	ldrb	r5, [r2, #4]
 8022a0e:	076d      	lsls	r5, r5, #29
 8022a10:	d533      	bpl.n	8022a7a <XMC_USBD_EndpointReadStart+0x8a>
{
  deptsiz_data_t data;
  depctl_data_t epctl;
	
  data.d32 =  0U;
  if ((ep->xferTotal - ep->xferLength) > ep->maxTransferSize)
 8022a12:	6895      	ldr	r5, [r2, #8]
 8022a14:	9501      	str	r5, [sp, #4]
 8022a16:	6955      	ldr	r5, [r2, #20]
    }
    /* set ep values */
    ep->xferTotal = size;
    ep->xferCount = 0U;
    ep->xferLength = 0U;
    ep->xferBuffer = ep->outBuffer;
 8022a18:	68d7      	ldr	r7, [r2, #12]
    {
      size = ep->outBufferSize;
    }
    /* set ep values */
    ep->xferTotal = size;
    ep->xferCount = 0U;
 8022a1a:	62d3      	str	r3, [r2, #44]	; 0x2c
 8022a1c:	42a9      	cmp	r1, r5
 8022a1e:	bf28      	it	cs
 8022a20:	4629      	movcs	r1, r5
{
  deptsiz_data_t data;
  depctl_data_t epctl;
	
  data.d32 =  0U;
  if ((ep->xferTotal - ep->xferLength) > ep->maxTransferSize)
 8022a22:	9d01      	ldr	r5, [sp, #4]
    /* set ep values */
    ep->xferTotal = size;
    ep->xferCount = 0U;
    ep->xferLength = 0U;
    ep->xferBuffer = ep->outBuffer;
    ep->outBytesAvailable = 0U;
 8022a24:	6113      	str	r3, [r2, #16]
{
  deptsiz_data_t data;
  depctl_data_t epctl;
	
  data.d32 =  0U;
  if ((ep->xferTotal - ep->xferLength) > ep->maxTransferSize)
 8022a26:	f3c5 0512 	ubfx	r5, r5, #0, #19
 8022a2a:	428d      	cmp	r5, r1
 8022a2c:	bf28      	it	cs
 8022a2e:	460d      	movcs	r5, r1
    if (size > ep->outBufferSize)
    {
      size = ep->outBufferSize;
    }
    /* set ep values */
    ep->xferTotal = size;
 8022a30:	6311      	str	r1, [r2, #48]	; 0x30
 8022a32:	6295      	str	r5, [r2, #40]	; 0x28
    ep->xferCount = 0U;
    ep->xferLength = 0U;
    ep->xferBuffer = ep->outBuffer;
 8022a34:	6257      	str	r7, [r2, #36]	; 0x24
  }
  else
  {
    ep->xferLength = ep->xferTotal;
  }
  if (ep->address_u.address_st.number == 0U)
 8022a36:	5d34      	ldrb	r4, [r6, r4]
 8022a38:	0724      	lsls	r4, r4, #28
 8022a3a:	d022      	beq.n	8022a82 <XMC_USBD_EndpointReadStart+0x92>
    ep0_data->b.xfersize = (uint8_t)ep->xferTotal;
  }
  else
  {
    /* If requested length is zero, just receive one zero length packet */
    if (ep->xferLength == 0U)
 8022a3c:	2d00      	cmp	r5, #0
 8022a3e:	d137      	bne.n	8022ab0 <XMC_USBD_EndpointReadStart+0xc0>
    {
      data.b.xfersize = 0U;
      data.b.pktcnt = 1U;
 8022a40:	2201      	movs	r2, #1
 8022a42:	f362 43dc 	bfi	r3, r2, #19, #10
      /* setup endpoint to recive a amount of packages by given size */
      data.b.pktcnt = (uint16_t)(((ep->xferLength - ep->xferCount) + (ep->maxPacketSize -(uint32_t)1U))/ep->maxPacketSize);
      data.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
    }
  }
  if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022a46:	4a21      	ldr	r2, [pc, #132]	; (8022acc <XMC_USBD_EndpointReadStart+0xdc>)
 8022a48:	6812      	ldr	r2, [r2, #0]
 8022a4a:	7b52      	ldrb	r2, [r2, #13]
 8022a4c:	bb2a      	cbnz	r2, 8022a9a <XMC_USBD_EndpointReadStart+0xaa>
  {
    /* Programm dma address if needed */
    xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepdma = (uint32_t)(ep->xferBuffer);
 8022a4e:	2234      	movs	r2, #52	; 0x34
 8022a50:	fb02 f000 	mul.w	r0, r2, r0
 8022a54:	1831      	adds	r1, r6, r0
 8022a56:	5c32      	ldrb	r2, [r6, r0]
 8022a58:	6a49      	ldr	r1, [r1, #36]	; 0x24
 8022a5a:	f002 020f 	and.w	r2, r2, #15
 8022a5e:	eb06 0282 	add.w	r2, r6, r2, lsl #2
 8022a62:	f8d2 21c4 	ldr.w	r2, [r2, #452]	; 0x1c4
 8022a66:	6151      	str	r1, [r2, #20]
  }
  /* setup endpoint size and enable endpoint */
  xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doeptsiz = data.d32;
 8022a68:	6113      	str	r3, [r2, #16]
 
  epctl.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 8022a6a:	6813      	ldr	r3, [r2, #0]
    ep->xferCount = 0U;
    ep->xferLength = 0U;
    ep->xferBuffer = ep->outBuffer;
    ep->outBytesAvailable = 0U;
    XMC_USBD_lStartReadXfer(ep);
    result= XMC_USBD_STATUS_OK;
 8022a6c:	2000      	movs	r0, #0
  /* setup endpoint size and enable endpoint */
  xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doeptsiz = data.d32;
 
  epctl.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
  epctl.b.cnak = 1U;
  epctl.b.epena = 1U;
 8022a6e:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
  xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = epctl.d32;
 8022a72:	6013      	str	r3, [r2, #0]
    ep->outBytesAvailable = 0U;
    XMC_USBD_lStartReadXfer(ep);
    result= XMC_USBD_STATUS_OK;
  }
  return result;
}
 8022a74:	b002      	add	sp, #8
 8022a76:	bcf0      	pop	{r4, r5, r6, r7}
 8022a78:	4770      	bx	lr
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_addr & (uint8_t)XMC_USBD_EP_NUM_MASK];
  XMC_USBD_STATUS_t result;
	
  if (ep->outInUse || !ep->isConfigured)
  {
    result = XMC_USBD_STATUS_ERROR;
 8022a7a:	2001      	movs	r0, #1
    ep->outBytesAvailable = 0U;
    XMC_USBD_lStartReadXfer(ep);
    result= XMC_USBD_STATUS_OK;
  }
  return result;
}
 8022a7c:	b002      	add	sp, #8
 8022a7e:	bcf0      	pop	{r4, r5, r6, r7}
 8022a80:	4770      	bx	lr
  if (ep->address_u.address_st.number == 0U)
  {
	/* Setup the endpoint to receive 3 setup packages and one normal package.*/
	/* Cast the data pointer to use only one variable */
    deptsiz0_data_t *ep0_data = (deptsiz0_data_t*)&data;
    ep0_data->b.pktcnt = 0x1U;
 8022a82:	2201      	movs	r2, #1
 8022a84:	f362 43d4 	bfi	r3, r2, #19, #2
      /* setup endpoint to recive a amount of packages by given size */
      data.b.pktcnt = (uint16_t)(((ep->xferLength - ep->xferCount) + (ep->maxPacketSize -(uint32_t)1U))/ep->maxPacketSize);
      data.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
    }
  }
  if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022a88:	4a10      	ldr	r2, [pc, #64]	; (8022acc <XMC_USBD_EndpointReadStart+0xdc>)
 8022a8a:	6812      	ldr	r2, [r2, #0]
 8022a8c:	7b52      	ldrb	r2, [r2, #13]
  {
	/* Setup the endpoint to receive 3 setup packages and one normal package.*/
	/* Cast the data pointer to use only one variable */
    deptsiz0_data_t *ep0_data = (deptsiz0_data_t*)&data;
    ep0_data->b.pktcnt = 0x1U;
    ep0_data->b.supcnt = 0x3U;
 8022a8e:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
    ep0_data->b.xfersize = (uint8_t)ep->xferTotal;
 8022a92:	f361 0306 	bfi	r3, r1, #0, #7
      /* setup endpoint to recive a amount of packages by given size */
      data.b.pktcnt = (uint16_t)(((ep->xferLength - ep->xferCount) + (ep->maxPacketSize -(uint32_t)1U))/ep->maxPacketSize);
      data.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
    }
  }
  if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022a96:	2a00      	cmp	r2, #0
 8022a98:	d0d9      	beq.n	8022a4e <XMC_USBD_EndpointReadStart+0x5e>
 8022a9a:	2234      	movs	r2, #52	; 0x34
 8022a9c:	fb02 f000 	mul.w	r0, r2, r0
 8022aa0:	5c32      	ldrb	r2, [r6, r0]
 8022aa2:	f002 020f 	and.w	r2, r2, #15
 8022aa6:	eb06 0282 	add.w	r2, r6, r2, lsl #2
 8022aaa:	f8d2 21c4 	ldr.w	r2, [r2, #452]	; 0x1c4
 8022aae:	e7db      	b.n	8022a68 <XMC_USBD_EndpointReadStart+0x78>
      data.b.pktcnt = 1U;
    }
    else
    {
      /* setup endpoint to recive a amount of packages by given size */
      data.b.pktcnt = (uint16_t)(((ep->xferLength - ep->xferCount) + (ep->maxPacketSize -(uint32_t)1U))/ep->maxPacketSize);
 8022ab0:	6852      	ldr	r2, [r2, #4]
 8022ab2:	f3c2 21c6 	ubfx	r1, r2, #11, #7
 8022ab6:	1e4a      	subs	r2, r1, #1
 8022ab8:	442a      	add	r2, r5
 8022aba:	fbb2 f2f1 	udiv	r2, r2, r1
 8022abe:	f362 43dc 	bfi	r3, r2, #19, #10
      data.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
 8022ac2:	f365 0312 	bfi	r3, r5, #0, #19
 8022ac6:	e7be      	b.n	8022a46 <XMC_USBD_EndpointReadStart+0x56>
 8022ac8:	1fffa868 	.word	0x1fffa868
 8022acc:	1fffa864 	.word	0x1fffa864

08022ad0 <XMC_USBD_EndpointWrite>:

/**
 * Writes number of bytes in to the USB IN endpoint.
 **/
int32_t XMC_USBD_EndpointWrite(const uint8_t ep_num,const uint8_t * buffer,uint32_t length) 
{
 8022ad0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  XMC_USBD_EP_t * ep = &xmc_device.ep[ep_num & (uint8_t)XMC_USBD_EP_NUM_MASK];
 8022ad4:	f000 070f 	and.w	r7, r0, #15
  int32_t result;
  if (!ep->isConfigured)
 8022ad8:	2634      	movs	r6, #52	; 0x34
 8022ada:	4d39      	ldr	r5, [pc, #228]	; (8022bc0 <XMC_USBD_EndpointWrite+0xf0>)
 8022adc:	fb06 f607 	mul.w	r6, r6, r7
 8022ae0:	19ac      	adds	r4, r5, r6
 8022ae2:	7923      	ldrb	r3, [r4, #4]
 8022ae4:	075b      	lsls	r3, r3, #29
 8022ae6:	d553      	bpl.n	8022b90 <XMC_USBD_EndpointWrite+0xc0>
  {
    result = (int32_t)XMC_USBD_STATUS_ERROR;
  }
  else if (ep->inInUse == 1U)
 8022ae8:	6863      	ldr	r3, [r4, #4]
 8022aea:	0718      	lsls	r0, r3, #28
 8022aec:	d457      	bmi.n	8022b9e <XMC_USBD_EndpointWrite+0xce>
  {
    result=(int32_t)0;
  }
  else
  {
    if (length > ep->inBufferSize)
 8022aee:	6a23      	ldr	r3, [r4, #32]
    {
      length = ep->inBufferSize;
    }
    /* copy data into input buffer for DMA and FIFO mode */
		memcpy(ep->inBuffer,(const void *)buffer,length);
 8022af0:	69e0      	ldr	r0, [r4, #28]
 8022af2:	429a      	cmp	r2, r3
 8022af4:	bf28      	it	cs
 8022af6:	461a      	movcs	r2, r3
 8022af8:	4691      	mov	r9, r2
 8022afa:	f008 f811 	bl	802ab20 <memcpy>
		ep->xferBuffer = ep->inBuffer;
    ep->xferTotal = length;
    /* set transfer values */
    ep->xferLength = 0U;
    ep->xferCount = 0U;
    ep->inInUse = 1U;
 8022afe:	6863      	ldr	r3, [r4, #4]
    {
      length = ep->inBufferSize;
    }
    /* copy data into input buffer for DMA and FIFO mode */
		memcpy(ep->inBuffer,(const void *)buffer,length);
		ep->xferBuffer = ep->inBuffer;
 8022b00:	f8d4 c01c 	ldr.w	ip, [r4, #28]
 8022b04:	f8c4 c024 	str.w	ip, [r4, #36]	; 0x24
    ep->xferTotal = length;
    /* set transfer values */
    ep->xferLength = 0U;
    ep->xferCount = 0U;
    ep->inInUse = 1U;
 8022b08:	f043 0308 	orr.w	r3, r3, #8
		memcpy(ep->inBuffer,(const void *)buffer,length);
		ep->xferBuffer = ep->inBuffer;
    ep->xferTotal = length;
    /* set transfer values */
    ep->xferLength = 0U;
    ep->xferCount = 0U;
 8022b0c:	2100      	movs	r1, #0
    ep->inInUse = 1U;
 8022b0e:	6063      	str	r3, [r4, #4]
		memcpy(ep->inBuffer,(const void *)buffer,length);
		ep->xferBuffer = ep->inBuffer;
    ep->xferTotal = length;
    /* set transfer values */
    ep->xferLength = 0U;
    ep->xferCount = 0U;
 8022b10:	62e1      	str	r1, [r4, #44]	; 0x2c
      length = ep->inBufferSize;
    }
    /* copy data into input buffer for DMA and FIFO mode */
		memcpy(ep->inBuffer,(const void *)buffer,length);
		ep->xferBuffer = ep->inBuffer;
    ep->xferTotal = length;
 8022b12:	f8c4 9030 	str.w	r9, [r4, #48]	; 0x30
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
  ctl.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022b16:	5da8      	ldrb	r0, [r5, r6]

  if ((ep->xferTotal - ep->xferLength)  < ep->maxTransferSize)
 8022b18:	68a3      	ldr	r3, [r4, #8]
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
  ctl.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022b1a:	f000 000f 	and.w	r0, r0, #15
 8022b1e:	f100 0e6a 	add.w	lr, r0, #106	; 0x6a

  if ((ep->xferTotal - ep->xferLength)  < ep->maxTransferSize)
 8022b22:	f3c3 0212 	ubfx	r2, r3, #0, #19
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
  ctl.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022b26:	f855 802e 	ldr.w	r8, [r5, lr, lsl #2]
 8022b2a:	454a      	cmp	r2, r9
 8022b2c:	bf28      	it	cs
 8022b2e:	464a      	movcs	r2, r9
 8022b30:	f8d8 e000 	ldr.w	lr, [r8]
 8022b34:	62a2      	str	r2, [r4, #40]	; 0x28
  }
  else
  {
    ep->xferLength += ep->maxTransferSize;
  }
  if (ep->xferLength == 0U)
 8022b36:	b3aa      	cbz	r2, 8022ba4 <XMC_USBD_EndpointWrite+0xd4>
    size.b.xfersize = 0U;
    size.b.pktcnt = 1U;
  }
  else
  {
    if (ep->address_u.address_st.number == 0U)
 8022b38:	5dab      	ldrb	r3, [r5, r6]
 8022b3a:	071b      	lsls	r3, r3, #28
 8022b3c:	d02b      	beq.n	8022b96 <XMC_USBD_EndpointWrite+0xc6>
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
    }
    else
    {
      size.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
      size.b.pktcnt = (uint16_t)(((uint16_t)(ep->xferLength - ep->xferCount) + (uint16_t)((uint16_t)ep->maxPacketSize - 1U))/
 8022b3e:	6863      	ldr	r3, [r4, #4]
 8022b40:	f3c3 24c6 	ubfx	r4, r3, #11, #7
 8022b44:	1e63      	subs	r3, r4, #1
 8022b46:	b29b      	uxth	r3, r3
 8022b48:	fa13 f382 	uxtah	r3, r3, r2
      /* ep->maxXferSize equals maxPacketSize */
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
    }
    else
    {
      size.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
 8022b4c:	f3c2 0212 	ubfx	r2, r2, #0, #19
      size.b.pktcnt = (uint16_t)(((uint16_t)(ep->xferLength - ep->xferCount) + (uint16_t)((uint16_t)ep->maxPacketSize - 1U))/
 8022b50:	fb93 f3f4 	sdiv	r3, r3, r4
 8022b54:	f3c3 0309 	ubfx	r3, r3, #0, #10
    		 ep->maxPacketSize);
    }
    if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022b58:	4c1a      	ldr	r4, [pc, #104]	; (8022bc4 <XMC_USBD_EndpointWrite+0xf4>)
 8022b5a:	6824      	ldr	r4, [r4, #0]
 8022b5c:	7b64      	ldrb	r4, [r4, #13]
 8022b5e:	f362 0112 	bfi	r1, r2, #0, #19
 8022b62:	f363 41dc 	bfi	r1, r3, #19, #10
 8022b66:	bb0c      	cbnz	r4, 8022bac <XMC_USBD_EndpointWrite+0xdc>
    {
      /* Program dma*/
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepdma = (uint32_t)ep->xferBuffer;
 8022b68:	f8c8 c014 	str.w	ip, [r8, #20]
			xmc_device.device_register->dtknqr4_fifoemptymsk |= (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
    }
  }

  /* Program size of transfer and enable endpoint */
  xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dieptsiz = size.d32;
 8022b6c:	2334      	movs	r3, #52	; 0x34
 8022b6e:	fb03 f707 	mul.w	r7, r3, r7
 8022b72:	19ea      	adds	r2, r5, r7
 8022b74:	5deb      	ldrb	r3, [r5, r7]
    ep->xferLength = 0U;
    ep->xferCount = 0U;
    ep->inInUse = 1U;
    /* start the transfer */
    XMC_USBD_lStartWriteXfer(ep);
    result=(int32_t)ep->xferTotal;
 8022b76:	6b10      	ldr	r0, [r2, #48]	; 0x30
			xmc_device.device_register->dtknqr4_fifoemptymsk |= (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
    }
  }

  /* Program size of transfer and enable endpoint */
  xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dieptsiz = size.d32;
 8022b78:	f003 030f 	and.w	r3, r3, #15
 8022b7c:	336a      	adds	r3, #106	; 0x6a
  ctl.b.epena = 1U;
  ctl.b.cnak = 1U;
 8022b7e:	f04e 4e04 	orr.w	lr, lr, #2214592512	; 0x84000000
			xmc_device.device_register->dtknqr4_fifoemptymsk |= (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
    }
  }

  /* Program size of transfer and enable endpoint */
  xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dieptsiz = size.d32;
 8022b82:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 8022b86:	6119      	str	r1, [r3, #16]
  ctl.b.epena = 1U;
  ctl.b.cnak = 1U;
  xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = ctl.d32;
 8022b88:	f8c3 e000 	str.w	lr, [r3]
 8022b8c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
{
  XMC_USBD_EP_t * ep = &xmc_device.ep[ep_num & (uint8_t)XMC_USBD_EP_NUM_MASK];
  int32_t result;
  if (!ep->isConfigured)
  {
    result = (int32_t)XMC_USBD_STATUS_ERROR;
 8022b90:	2001      	movs	r0, #1
 8022b92:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  {
    if (ep->address_u.address_st.number == 0U)
    {
      size.b.pktcnt = 1U;
      /* ep->maxXferSize equals maxPacketSize */
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
 8022b96:	f3c2 0212 	ubfx	r2, r2, #0, #19
  }
  else
  {
    if (ep->address_u.address_st.number == 0U)
    {
      size.b.pktcnt = 1U;
 8022b9a:	2301      	movs	r3, #1
 8022b9c:	e7dc      	b.n	8022b58 <XMC_USBD_EndpointWrite+0x88>
  {
    result = (int32_t)XMC_USBD_STATUS_ERROR;
  }
  else if (ep->inInUse == 1U)
  {
    result=(int32_t)0;
 8022b9e:	2000      	movs	r0, #0
    /* start the transfer */
    XMC_USBD_lStartWriteXfer(ep);
    result=(int32_t)ep->xferTotal;
  }
  return result;
}
 8022ba0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    ep->xferLength += ep->maxTransferSize;
  }
  if (ep->xferLength == 0U)
  {
    size.b.xfersize = 0U;
    size.b.pktcnt = 1U;
 8022ba4:	2301      	movs	r3, #1
 8022ba6:	f363 41dc 	bfi	r1, r3, #19, #10
 8022baa:	e7df      	b.n	8022b6c <XMC_USBD_EndpointWrite+0x9c>
    if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
    {
      /* Program dma*/
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepdma = (uint32_t)ep->xferBuffer;
    }
    if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022bac:	2c01      	cmp	r4, #1
 8022bae:	d1dd      	bne.n	8022b6c <XMC_USBD_EndpointWrite+0x9c>
    {
      /* enable fifo empty interrupt */
			xmc_device.device_register->dtknqr4_fifoemptymsk |= (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
 8022bb0:	f8d5 21a4 	ldr.w	r2, [r5, #420]	; 0x1a4
 8022bb4:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8022bb6:	4084      	lsls	r4, r0
 8022bb8:	431c      	orrs	r4, r3
 8022bba:	6354      	str	r4, [r2, #52]	; 0x34
 8022bbc:	e7d6      	b.n	8022b6c <XMC_USBD_EndpointWrite+0x9c>
 8022bbe:	bf00      	nop
 8022bc0:	1fffa868 	.word	0x1fffa868
 8022bc4:	1fffa864 	.word	0x1fffa864

08022bc8 <XMC_USBD_IRQHandler>:
 *
 * The handler first checks, which global interrupt has caused the interrupt
 * and then dispatches interrupt to the corresponding sub-handler.
 */
void XMC_USBD_IRQHandler(const XMC_USBD_t *const obj) 
{
 8022bc8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  gintmsk_data_t gintmsk;
  gintsts_data_t data;
	
  gintmsk.d32 = xmc_device.global_register->gintmsk;
 8022bcc:	4cb9      	ldr	r4, [pc, #740]	; (8022eb4 <XMC_USBD_IRQHandler+0x2ec>)
 8022bce:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
 8022bd2:	699d      	ldr	r5, [r3, #24]
  data.d32 = xmc_device.global_register->gintsts & gintmsk.d32;
 8022bd4:	695a      	ldr	r2, [r3, #20]
 *
 * The handler first checks, which global interrupt has caused the interrupt
 * and then dispatches interrupt to the corresponding sub-handler.
 */
void XMC_USBD_IRQHandler(const XMC_USBD_t *const obj) 
{
 8022bd6:	b08f      	sub	sp, #60	; 0x3c
  gintmsk_data_t gintmsk;
  gintsts_data_t data;
	
  gintmsk.d32 = xmc_device.global_register->gintmsk;
  data.d32 = xmc_device.global_register->gintsts & gintmsk.d32;
 8022bd8:	ea02 0a05 	and.w	sl, r2, r5
	
  if (data.b.sofintr)
 8022bdc:	fa5f f68a 	uxtb.w	r6, sl
 *
 * The handler first checks, which global interrupt has caused the interrupt
 * and then dispatches interrupt to the corresponding sub-handler.
 */
void XMC_USBD_IRQHandler(const XMC_USBD_t *const obj) 
{
 8022be0:	9001      	str	r0, [sp, #4]
  gintsts_data_t data;
	
  gintmsk.d32 = xmc_device.global_register->gintmsk;
  data.d32 = xmc_device.global_register->gintsts & gintmsk.d32;
	
  if (data.b.sofintr)
 8022be2:	0730      	lsls	r0, r6, #28
 8022be4:	f100 82eb 	bmi.w	80231be <XMC_USBD_IRQHandler+0x5f6>
  {
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_SOF);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_SOF);
  }
  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022be8:	9a01      	ldr	r2, [sp, #4]
 8022bea:	7b52      	ldrb	r2, [r2, #13]
 8022bec:	2a01      	cmp	r2, #1
 8022bee:	f000 82f3 	beq.w	80231d8 <XMC_USBD_IRQHandler+0x610>
      XMC_USBD_lHandleRxFLvl(); /* handle the interrupt */
      gintmsk.b.rxstsqlvl = 1U;
      xmc_device.global_register->gintmsk = gintmsk.d32;
    }
  }
  if (data.b.erlysuspend)
 8022bf2:	f3ca 2507 	ubfx	r5, sl, #8, #8
 8022bf6:	0769      	lsls	r1, r5, #29
	  break;
    case (XMC_USBD_EVENT_SOF):
	  clear.b.sofintr = 1U;
	  break;
    case (XMC_USBD_EVENT_EARLYSUSPEND):
	  clear.b.erlysuspend = 1U;
 8022bf8:	bf44      	itt	mi
 8022bfa:	f44f 6280 	movmi.w	r2, #1024	; 0x400
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022bfe:	615a      	strmi	r2, [r3, #20]
  }
  if (data.b.erlysuspend)
  {
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_EARLYSUSPEND);
  }
  if (data.b.usbsuspend)
 8022c00:	072a      	lsls	r2, r5, #28
 8022c02:	f100 82d2 	bmi.w	80231aa <XMC_USBD_IRQHandler+0x5e2>
  {
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_SUSPEND);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_SUSPEND);
  }
  if (data.b.wkupintr)
 8022c06:	ea4f 661a 	mov.w	r6, sl, lsr #24
 8022c0a:	0637      	lsls	r7, r6, #24
 8022c0c:	f100 82c3 	bmi.w	8023196 <XMC_USBD_IRQHandler+0x5ce>
  {
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_REMOTE_WAKEUP);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_REMOTE_WAKEUP);
  }
  if (data.b.sessreqintr)
 8022c10:	0670      	lsls	r0, r6, #25
 8022c12:	f100 82b0 	bmi.w	8023176 <XMC_USBD_IRQHandler+0x5ae>
  {
    xmc_device.IsPowered = 1U;
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_POWER_ON);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_POWER_ON);
  }
  if (data.b.usbreset)
 8022c16:	06e9      	lsls	r1, r5, #27
 8022c18:	f100 81f1 	bmi.w	8022ffe <XMC_USBD_IRQHandler+0x436>
  {
    XMC_USBD_lHandleUSBReset(obj);
  }
  if (data.b.enumdone)
 8022c1c:	06aa      	lsls	r2, r5, #26
 8022c1e:	f100 81d3 	bmi.w	8022fc8 <XMC_USBD_IRQHandler+0x400>
  {
    XMC_USBD_lHandleEnumDone();
  }
  if (data.b.inepint)
 8022c22:	f41a 2f80 	tst.w	sl, #262144	; 0x40000
 8022c26:	f040 8105 	bne.w	8022e34 <XMC_USBD_IRQHandler+0x26c>
  {
    XMC_USBD_lHandleIEPInt(obj);
  }
  if (data.b.outepintr)
 8022c2a:	f41a 2f00 	tst.w	sl, #524288	; 0x80000
 8022c2e:	d118      	bne.n	8022c62 <XMC_USBD_IRQHandler+0x9a>
  {
		XMC_USBD_lHandleOEPInt(obj);
  }
	if (data.b.otgintr)
 8022c30:	f01a 0f04 	tst.w	sl, #4
 8022c34:	d102      	bne.n	8022c3c <XMC_USBD_IRQHandler+0x74>
  {
	  XMC_USBD_lHandleOTGInt();
  }

}
 8022c36:	b00f      	add	sp, #60	; 0x3c
 8022c38:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
* It detects especially connect and disconnect events.
*/
static void XMC_USBD_lHandleOTGInt(void) 
{
  gotgint_data_t data;
  data.d32 = xmc_device.global_register->gotgint;
 8022c3c:	685d      	ldr	r5, [r3, #4]
  if (data.b.sesenddet)
 8022c3e:	0768      	lsls	r0, r5, #29
 8022c40:	d50b      	bpl.n	8022c5a <XMC_USBD_IRQHandler+0x92>
  {
		xmc_device.IsPowered = 0U;
 8022c42:	f894 31fe 	ldrb.w	r3, [r4, #510]	; 0x1fe
		xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_POWER_OFF);
 8022c46:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
{
  gotgint_data_t data;
  data.d32 = xmc_device.global_register->gotgint;
  if (data.b.sesenddet)
  {
		xmc_device.IsPowered = 0U;
 8022c4a:	f36f 0382 	bfc	r3, #2, #1
 8022c4e:	f884 31fe 	strb.w	r3, [r4, #510]	; 0x1fe
		xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_POWER_OFF);
 8022c52:	2001      	movs	r0, #1
 8022c54:	4790      	blx	r2
 8022c56:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
 **/
static void XMC_USBD_lClearEventOTG(uint32_t event)
{
  gotgint_data_t clear = { .d32 = 0U};
  clear.d32 = event;
  xmc_device.global_register->gotgint = clear.d32;
 8022c5a:	605d      	str	r5, [r3, #4]
	if (data.b.otgintr)
  {
	  XMC_USBD_lHandleOTGInt();
  }

}
 8022c5c:	b00f      	add	sp, #60	; 0x3c
 8022c5e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  uint16_t temp;
  uint16_t temp1;
  uint16_t mask;
  uint8_t ep_num;
	
  daint.d32 = xmc_device.device_register->daint;
 8022c62:	f8d4 21a4 	ldr.w	r2, [r4, #420]	; 0x1a4
 8022c66:	6993      	ldr	r3, [r2, #24]
  
  daintmsk.d32 = xmc_device.device_register->daintmsk;
 8022c68:	69d7      	ldr	r7, [r2, #28]
  
  doepmsk.d32 = xmc_device.device_register->doepmsk;  
 8022c6a:	6952      	ldr	r2, [r2, #20]
 8022c6c:	9202      	str	r2, [sp, #8]
  
  mask = daint.ep.out & daintmsk.ep.out;
 8022c6e:	f3c3 430f 	ubfx	r3, r3, #16, #16
  ep_num = 0U;
  doeptsiz.d32 = 0U;
 8022c72:	2200      	movs	r2, #0
 
  while ((uint16_t)mask >> ep_num)
 8022c74:	ea13 4717 	ands.w	r7, r3, r7, lsr #16
  
  doepmsk.d32 = xmc_device.device_register->doepmsk;  
  
  mask = daint.ep.out & daintmsk.ep.out;
  ep_num = 0U;
  doeptsiz.d32 = 0U;
 8022c78:	9203      	str	r2, [sp, #12]
 
  while ((uint16_t)mask >> ep_num)
 8022c7a:	f000 8097 	beq.w	8022dac <XMC_USBD_IRQHandler+0x1e4>
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8022c7e:	f8dd b004 	ldr.w	fp, [sp, #4]
 8022c82:	f8cd a010 	str.w	sl, [sp, #16]
 8022c86:	4616      	mov	r6, r2
  
  mask = daint.ep.out & daintmsk.ep.out;
  ep_num = 0U;
  doeptsiz.d32 = 0U;
 
  while ((uint16_t)mask >> ep_num)
 8022c88:	463b      	mov	r3, r7
 8022c8a:	4615      	mov	r5, r2
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8022c8c:	f04f 0c34 	mov.w	ip, #52	; 0x34
 8022c90:	46b8      	mov	r8, r7
 
  while ((uint16_t)mask >> ep_num)
  {
    temp1 = (mask >> (uint16_t)ep_num);
    temp = temp1 & 0x1U;
    if (temp)
 8022c92:	07df      	lsls	r7, r3, #31
 8022c94:	f140 8081 	bpl.w	8022d9a <XMC_USBD_IRQHandler+0x1d2>
    {
      /* load register data for endpoint */
      ep = &xmc_device.ep[ep_num];
      doepint.d32 = xmc_device.endpoint_out_register[ep_num]->doepint & doepmsk.d32;
 8022c98:	f106 0970 	add.w	r9, r6, #112	; 0x70
 8022c9c:	eb04 0289 	add.w	r2, r4, r9, lsl #2
 8022ca0:	9902      	ldr	r1, [sp, #8]
 8022ca2:	6852      	ldr	r2, [r2, #4]
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022ca4:	f89b 300d 	ldrb.w	r3, [fp, #13]
    temp = temp1 & 0x1U;
    if (temp)
    {
      /* load register data for endpoint */
      ep = &xmc_device.ep[ep_num];
      doepint.d32 = xmc_device.endpoint_out_register[ep_num]->doepint & doepmsk.d32;
 8022ca8:	6897      	ldr	r7, [r2, #8]
 8022caa:	400f      	ands	r7, r1
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
      {
        doeptsiz.d32 = xmc_device.endpoint_out_register[ep_num]->doeptsiz;
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
 8022cac:	fa5f fa87 	uxtb.w	sl, r7
    if (temp)
    {
      /* load register data for endpoint */
      ep = &xmc_device.ep[ep_num];
      doepint.d32 = xmc_device.endpoint_out_register[ep_num]->doepint & doepmsk.d32;
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022cb0:	2b00      	cmp	r3, #0
 8022cb2:	f040 8081 	bne.w	8022db8 <XMC_USBD_IRQHandler+0x1f0>
      {
        doeptsiz.d32 = xmc_device.endpoint_out_register[ep_num]->doeptsiz;
 8022cb6:	6911      	ldr	r1, [r2, #16]
 8022cb8:	9103      	str	r1, [sp, #12]
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
 8022cba:	f01a 0f08 	tst.w	sl, #8
 8022cbe:	d021      	beq.n	8022d04 <XMC_USBD_IRQHandler+0x13c>
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8022cc0:	4a7c      	ldr	r2, [pc, #496]	; (8022eb4 <XMC_USBD_IRQHandler+0x2ec>)
 8022cc2:	fb0c 2006 	mla	r0, ip, r6, r2
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* calculate size for setup packet */
		  ep->outBytesAvailable = (uint32_t)(((uint32_t)XMC_USBD_SETUP_COUNT -
		  (uint32_t)((deptsiz0_data_t*)&doeptsiz)->b.supcnt)*(uint32_t)XMC_USBD_SETUP_SIZE);
 8022cc6:	9a03      	ldr	r2, [sp, #12]
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8022cc8:	7901      	ldrb	r1, [r0, #4]
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* calculate size for setup packet */
		  ep->outBytesAvailable = (uint32_t)(((uint32_t)XMC_USBD_SETUP_COUNT -
		  (uint32_t)((deptsiz0_data_t*)&doeptsiz)->b.supcnt)*(uint32_t)XMC_USBD_SETUP_SIZE);
 8022cca:	f3c2 7241 	ubfx	r2, r2, #29, #2
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* calculate size for setup packet */
		  ep->outBytesAvailable = (uint32_t)(((uint32_t)XMC_USBD_SETUP_COUNT -
 8022cce:	00d2      	lsls	r2, r2, #3
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8022cd0:	f363 1145 	bfi	r1, r3, #5, #1
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* calculate size for setup packet */
		  ep->outBytesAvailable = (uint32_t)(((uint32_t)XMC_USBD_SETUP_COUNT -
 8022cd4:	f1c2 0218 	rsb	r2, r2, #24
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8022cd8:	7101      	strb	r1, [r0, #4]
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* calculate size for setup packet */
		  ep->outBytesAvailable = (uint32_t)(((uint32_t)XMC_USBD_SETUP_COUNT -
 8022cda:	6102      	str	r2, [r0, #16]
        }
		if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
		{
			ep->outBytesAvailable += ep->xferCount;
		}
		ep->outInUse = 0U;
 8022cdc:	fb0c 4306 	mla	r3, ip, r6, r4
 8022ce0:	f8cd c004 	str.w	ip, [sp, #4]
 8022ce4:	685a      	ldr	r2, [r3, #4]
 8022ce6:	f022 0210 	bic.w	r2, r2, #16
 8022cea:	605a      	str	r2, [r3, #4]
		xmc_device.EndpointEvent_cb(0U,XMC_USBD_EP_EVENT_SETUP); /* signal endpoint event */
 8022cec:	2000      	movs	r0, #0
 8022cee:	f8d4 3204 	ldr.w	r3, [r4, #516]	; 0x204
 8022cf2:	4601      	mov	r1, r0
 8022cf4:	4798      	blx	r3
 **/
void XMC_USBD_ClearEventOUTEP(uint32_t event,const uint8_t ep_num)
{
  doepint_data_t clear;
  clear.d32 = event;
  xmc_device.endpoint_out_register[ep_num]->doepint = clear.d32;
 8022cf6:	eb04 0389 	add.w	r3, r4, r9, lsl #2
 8022cfa:	2108      	movs	r1, #8
 8022cfc:	685a      	ldr	r2, [r3, #4]
 8022cfe:	f8dd c004 	ldr.w	ip, [sp, #4]
 8022d02:	6091      	str	r1, [r2, #8]
		ep->outInUse = 0U;
		xmc_device.EndpointEvent_cb(0U,XMC_USBD_EP_EVENT_SETUP); /* signal endpoint event */
				/* clear the interrupt */
		XMC_USBD_ClearEventOUTEP((uint32_t)XMC_USBD_EVENT_OUT_EP_SETUP,ep_num);
      }
      if (doepint.b.xfercompl)
 8022d04:	f01a 0f01 	tst.w	sl, #1
 8022d08:	d046      	beq.n	8022d98 <XMC_USBD_IRQHandler+0x1d0>
      {
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022d0a:	f89b 300d 	ldrb.w	r3, [fp, #13]
 8022d0e:	2b00      	cmp	r3, #0
 8022d10:	d063      	beq.n	8022dda <XMC_USBD_IRQHandler+0x212>
 8022d12:	fb0c 4306 	mla	r3, ip, r6, r4
 8022d16:	6a99      	ldr	r1, [r3, #40]	; 0x28
        {
          uint32_t bytes = (ep->xferLength - ep->xferCount) - doeptsiz.b.xfersize;
          ep->xferCount += bytes;
          ep->xferBuffer += bytes;
				}
        if (ep->xferTotal == ep->xferLength)
 8022d18:	fb0c 4306 	mla	r3, ip, r6, r4
 8022d1c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8022d1e:	428a      	cmp	r2, r1
 8022d20:	d072      	beq.n	8022e08 <XMC_USBD_IRQHandler+0x240>
{
  deptsiz_data_t data;
  depctl_data_t epctl;
	
  data.d32 =  0U;
  if ((ep->xferTotal - ep->xferLength) > ep->maxTransferSize)
 8022d22:	6898      	ldr	r0, [r3, #8]
 8022d24:	ebc1 0e02 	rsb	lr, r1, r2
 8022d28:	f3c0 0012 	ubfx	r0, r0, #0, #19
 8022d2c:	4586      	cmp	lr, r0
 8022d2e:	fb0c fe06 	mul.w	lr, ip, r6
  {
    ep->xferLength += ep->maxTransferSize;
 8022d32:	bf88      	it	hi
 8022d34:	1809      	addhi	r1, r1, r0
 8022d36:	eb04 000e 	add.w	r0, r4, lr
{
  deptsiz_data_t data;
  depctl_data_t epctl;
	
  data.d32 =  0U;
  if ((ep->xferTotal - ep->xferLength) > ep->maxTransferSize)
 8022d3a:	bf98      	it	ls
 8022d3c:	4611      	movls	r1, r2
 8022d3e:	6281      	str	r1, [r0, #40]	; 0x28
  }
  else
  {
    ep->xferLength = ep->xferTotal;
  }
  if (ep->address_u.address_st.number == 0U)
 8022d40:	f814 e00e 	ldrb.w	lr, [r4, lr]
 8022d44:	f01e 0f0f 	tst.w	lr, #15
static void XMC_USBD_lStartReadXfer(XMC_USBD_EP_t *const ep) 
{
  deptsiz_data_t data;
  depctl_data_t epctl;
	
  data.d32 =  0U;
 8022d48:	f04f 0300 	mov.w	r3, #0
 8022d4c:	f100 0a28 	add.w	sl, r0, #40	; 0x28
  }
  else
  {
    ep->xferLength = ep->xferTotal;
  }
  if (ep->address_u.address_st.number == 0U)
 8022d50:	f040 82ae 	bne.w	80232b0 <XMC_USBD_IRQHandler+0x6e8>
  {
	/* Setup the endpoint to receive 3 setup packages and one normal package.*/
	/* Cast the data pointer to use only one variable */
    deptsiz0_data_t *ep0_data = (deptsiz0_data_t*)&data;
    ep0_data->b.pktcnt = 0x1U;
 8022d54:	2101      	movs	r1, #1
 8022d56:	f361 43d4 	bfi	r3, r1, #19, #2
    ep0_data->b.supcnt = 0x3U;
 8022d5a:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
    ep0_data->b.xfersize = (uint8_t)ep->xferTotal;
 8022d5e:	f362 0306 	bfi	r3, r2, #0, #7
      /* setup endpoint to recive a amount of packages by given size */
      data.b.pktcnt = (uint16_t)(((ep->xferLength - ep->xferCount) + (ep->maxPacketSize -(uint32_t)1U))/ep->maxPacketSize);
      data.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
    }
  }
  if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022d62:	4a55      	ldr	r2, [pc, #340]	; (8022eb8 <XMC_USBD_IRQHandler+0x2f0>)
 8022d64:	6812      	ldr	r2, [r2, #0]
 8022d66:	7b52      	ldrb	r2, [r2, #13]
  {
    /* Programm dma address if needed */
    xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepdma = (uint32_t)(ep->xferBuffer);
 8022d68:	fb0c f606 	mul.w	r6, ip, r6
      /* setup endpoint to recive a amount of packages by given size */
      data.b.pktcnt = (uint16_t)(((ep->xferLength - ep->xferCount) + (ep->maxPacketSize -(uint32_t)1U))/ep->maxPacketSize);
      data.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
    }
  }
  if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022d6c:	2a00      	cmp	r2, #0
 8022d6e:	f040 82a6 	bne.w	80232be <XMC_USBD_IRQHandler+0x6f6>
  {
    /* Programm dma address if needed */
    xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepdma = (uint32_t)(ep->xferBuffer);
 8022d72:	5da2      	ldrb	r2, [r4, r6]
 8022d74:	f002 020f 	and.w	r2, r2, #15
 8022d78:	19a1      	adds	r1, r4, r6
 8022d7a:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 8022d7e:	6a48      	ldr	r0, [r1, #36]	; 0x24
 8022d80:	f8d2 11c4 	ldr.w	r1, [r2, #452]	; 0x1c4
 8022d84:	6148      	str	r0, [r1, #20]
  }
  /* setup endpoint size and enable endpoint */
  xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doeptsiz = data.d32;
 8022d86:	610b      	str	r3, [r1, #16]
 
  epctl.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 8022d88:	680b      	ldr	r3, [r1, #0]
 8022d8a:	eb04 0989 	add.w	r9, r4, r9, lsl #2
  epctl.b.cnak = 1U;
  epctl.b.epena = 1U;
 8022d8e:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 8022d92:	f8d9 2004 	ldr.w	r2, [r9, #4]
  xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = epctl.d32;
 8022d96:	600b      	str	r3, [r1, #0]
 **/
void XMC_USBD_ClearEventOUTEP(uint32_t event,const uint8_t ep_num)
{
  doepint_data_t clear;
  clear.d32 = event;
  xmc_device.endpoint_out_register[ep_num]->doepint = clear.d32;
 8022d98:	6097      	str	r7, [r2, #8]

      }

      XMC_USBD_ClearEventOUTEP(doepint.d32,ep_num);
    }
    ep_num++;
 8022d9a:	3501      	adds	r5, #1
 8022d9c:	b2ed      	uxtb	r5, r5
  
  mask = daint.ep.out & daintmsk.ep.out;
  ep_num = 0U;
  doeptsiz.d32 = 0U;
 
  while ((uint16_t)mask >> ep_num)
 8022d9e:	fa58 f305 	asrs.w	r3, r8, r5
 8022da2:	462e      	mov	r6, r5
 8022da4:	f47f af75 	bne.w	8022c92 <XMC_USBD_IRQHandler+0xca>
 8022da8:	f8dd a010 	ldr.w	sl, [sp, #16]
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022dac:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
	  break;
    case (XMC_USBD_EVENT_ENUMDONE):
	  clear.b.enumdone = 1U;
	  break;
    case (XMC_USBD_EVENT_OUTEP):
	  clear.b.outepintr = 1U;
 8022db0:	f44f 2200 	mov.w	r2, #524288	; 0x80000
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022db4:	615a      	str	r2, [r3, #20]
 8022db6:	e73b      	b.n	8022c30 <XMC_USBD_IRQHandler+0x68>
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
      {
        doeptsiz.d32 = xmc_device.endpoint_out_register[ep_num]->doeptsiz;
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
 8022db8:	f01a 0f08 	tst.w	sl, #8
 8022dbc:	d0a2      	beq.n	8022d04 <XMC_USBD_IRQHandler+0x13c>
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8022dbe:	4a3d      	ldr	r2, [pc, #244]	; (8022eb4 <XMC_USBD_IRQHandler+0x2ec>)
 8022dc0:	fb0c 2106 	mla	r1, ip, r6, r2
        {
          /* calculate size for setup packet */
		  ep->outBytesAvailable = (uint32_t)(((uint32_t)XMC_USBD_SETUP_COUNT -
		  (uint32_t)((deptsiz0_data_t*)&doeptsiz)->b.supcnt)*(uint32_t)XMC_USBD_SETUP_SIZE);
        }
		if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022dc4:	2b01      	cmp	r3, #1
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8022dc6:	790a      	ldrb	r2, [r1, #4]
 8022dc8:	f36f 1245 	bfc	r2, #5, #1
 8022dcc:	710a      	strb	r2, [r1, #4]
        {
          /* calculate size for setup packet */
		  ep->outBytesAvailable = (uint32_t)(((uint32_t)XMC_USBD_SETUP_COUNT -
		  (uint32_t)((deptsiz0_data_t*)&doeptsiz)->b.supcnt)*(uint32_t)XMC_USBD_SETUP_SIZE);
        }
		if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022dce:	d185      	bne.n	8022cdc <XMC_USBD_IRQHandler+0x114>
		{
			ep->outBytesAvailable += ep->xferCount;
 8022dd0:	690b      	ldr	r3, [r1, #16]
 8022dd2:	6aca      	ldr	r2, [r1, #44]	; 0x2c
 8022dd4:	4413      	add	r3, r2
 8022dd6:	610b      	str	r3, [r1, #16]
 8022dd8:	e780      	b.n	8022cdc <XMC_USBD_IRQHandler+0x114>
      }
      if (doepint.b.xfercompl)
      {
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          uint32_t bytes = (ep->xferLength - ep->xferCount) - doeptsiz.b.xfersize;
 8022dda:	fb0c 4006 	mla	r0, ip, r6, r4
 8022dde:	9b03      	ldr	r3, [sp, #12]
 8022de0:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8022de2:	6a81      	ldr	r1, [r0, #40]	; 0x28
 8022de4:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8022de8:	ebc2 0e01 	rsb	lr, r2, r1
 8022dec:	ebc3 030e 	rsb	r3, r3, lr
          ep->xferCount += bytes;
 8022df0:	eb02 0e03 	add.w	lr, r2, r3
          ep->xferBuffer += bytes;
 8022df4:	6a42      	ldr	r2, [r0, #36]	; 0x24
      if (doepint.b.xfercompl)
      {
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          uint32_t bytes = (ep->xferLength - ep->xferCount) - doeptsiz.b.xfersize;
          ep->xferCount += bytes;
 8022df6:	f8c0 e02c 	str.w	lr, [r0, #44]	; 0x2c
          ep->xferBuffer += bytes;
 8022dfa:	4413      	add	r3, r2
 8022dfc:	6243      	str	r3, [r0, #36]	; 0x24
				}
        if (ep->xferTotal == ep->xferLength)
 8022dfe:	fb0c 4306 	mla	r3, ip, r6, r4
 8022e02:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8022e04:	428a      	cmp	r2, r1
 8022e06:	d18c      	bne.n	8022d22 <XMC_USBD_IRQHandler+0x15a>
 8022e08:	f8cd c004 	str.w	ip, [sp, #4]
        {
          ep->outBytesAvailable = ep->xferCount;
          ep->outInUse = 0U;
 8022e0c:	685a      	ldr	r2, [r3, #4]
          ep->xferCount += bytes;
          ep->xferBuffer += bytes;
				}
        if (ep->xferTotal == ep->xferLength)
        {
          ep->outBytesAvailable = ep->xferCount;
 8022e0e:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8022e10:	6119      	str	r1, [r3, #16]
          ep->outInUse = 0U;
 8022e12:	f022 0210 	bic.w	r2, r2, #16
 8022e16:	605a      	str	r2, [r3, #4]
          xmc_device.EndpointEvent_cb(ep_num,XMC_USBD_EP_EVENT_OUT);
 8022e18:	4b26      	ldr	r3, [pc, #152]	; (8022eb4 <XMC_USBD_IRQHandler+0x2ec>)
 8022e1a:	4628      	mov	r0, r5
 8022e1c:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
 8022e20:	2101      	movs	r1, #1
 8022e22:	4798      	blx	r3
 8022e24:	4b23      	ldr	r3, [pc, #140]	; (8022eb4 <XMC_USBD_IRQHandler+0x2ec>)
 8022e26:	f8dd c004 	ldr.w	ip, [sp, #4]
 8022e2a:	eb03 0989 	add.w	r9, r3, r9, lsl #2
 8022e2e:	f8d9 2004 	ldr.w	r2, [r9, #4]
 8022e32:	e7b1      	b.n	8022d98 <XMC_USBD_IRQHandler+0x1d0>
  uint16_t temp1;
  uint16_t mask;
  uint8_t ep_num;
  uint32_t inepint;
	
  daint.d32 = xmc_device.device_register->daint;
 8022e34:	f8d4 31a4 	ldr.w	r3, [r4, #420]	; 0x1a4
 8022e38:	699a      	ldr	r2, [r3, #24]
  
  diepmsk.d32 = xmc_device.device_register->diepmsk;
 8022e3a:	691b      	ldr	r3, [r3, #16]
 8022e3c:	9303      	str	r3, [sp, #12]
  
  dieptsiz.d32 = 0U;
  mask = daint.ep.in;
  ep_num = 0U;
  
  while ((uint16_t)mask >> ep_num)
 8022e3e:	b297      	uxth	r7, r2
 8022e40:	2f00      	cmp	r7, #0
 8022e42:	d061      	beq.n	8022f08 <XMC_USBD_IRQHandler+0x340>
 8022e44:	2600      	movs	r6, #0
 8022e46:	46b6      	mov	lr, r6
 8022e48:	463b      	mov	r3, r7
    if ((uint16_t)temp)
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
 8022e4a:	f04f 0b34 	mov.w	fp, #52	; 0x34
 8022e4e:	f8cd a010 	str.w	sl, [sp, #16]
 8022e52:	46b9      	mov	r9, r7
  
  while ((uint16_t)mask >> ep_num)
  {
    temp1 = ((uint16_t)mask >> (uint16_t)ep_num);
    temp = (uint16_t)temp1 & (uint16_t)0x1U;
    if ((uint16_t)temp)
 8022e54:	07db      	lsls	r3, r3, #31
 8022e56:	d54f      	bpl.n	8022ef8 <XMC_USBD_IRQHandler+0x330>
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
 8022e58:	f10e 036a 	add.w	r3, lr, #106	; 0x6a
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
 8022e5c:	fb0b f00e 	mul.w	r0, fp, lr
    temp1 = ((uint16_t)mask >> (uint16_t)ep_num);
    temp = (uint16_t)temp1 & (uint16_t)0x1U;
    if ((uint16_t)temp)
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
 8022e60:	9302      	str	r3, [sp, #8]
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
 8022e62:	f8d4 a1a4 	ldr.w	sl, [r4, #420]	; 0x1a4
    temp1 = ((uint16_t)mask >> (uint16_t)ep_num);
    temp = (uint16_t)temp1 & (uint16_t)0x1U;
    if ((uint16_t)temp)
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
 8022e66:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
 8022e6a:	f814 8000 	ldrb.w	r8, [r4, r0]
    temp1 = ((uint16_t)mask >> (uint16_t)ep_num);
    temp = (uint16_t)temp1 & (uint16_t)0x1U;
    if ((uint16_t)temp)
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
 8022e6e:	689d      	ldr	r5, [r3, #8]
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
 8022e70:	f8da 1034 	ldr.w	r1, [sl, #52]	; 0x34
                     0x1U) << 7U) | (uint32_t)diepmsk.d32);
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022e74:	9a01      	ldr	r2, [sp, #4]
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
                     0x1U) << 7U) | (uint32_t)diepmsk.d32);
 8022e76:	9f03      	ldr	r7, [sp, #12]
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022e78:	7b52      	ldrb	r2, [r2, #13]
    if ((uint16_t)temp)
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
 8022e7a:	f008 0c0f 	and.w	ip, r8, #15
 8022e7e:	fa21 f10c 	lsr.w	r1, r1, ip
                     0x1U) << 7U) | (uint32_t)diepmsk.d32);
 8022e82:	01c9      	lsls	r1, r1, #7
 8022e84:	b2c9      	uxtb	r1, r1
 8022e86:	4339      	orrs	r1, r7
    if ((uint16_t)temp)
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
 8022e88:	4420      	add	r0, r4
    temp = (uint16_t)temp1 & (uint16_t)0x1U;
    if ((uint16_t)temp)
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
      diepint.d32 = inepint &
 8022e8a:	400d      	ands	r5, r1
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
                     0x1U) << 7U) | (uint32_t)diepmsk.d32);
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022e8c:	b9b2      	cbnz	r2, 8022ebc <XMC_USBD_IRQHandler+0x2f4>
          bytes = XMC_USBD_lWriteFifo(ep);
          ep->xferCount += bytes;
          ep->xferBuffer += bytes;
        }
      }
      if (diepint.b.xfercompl)
 8022e8e:	07ef      	lsls	r7, r5, #31
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
                     0x1U) << 7U) | (uint32_t)diepmsk.d32);
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
      {
        dieptsiz.d32 = xmc_device.endpoint_in_register[ep_num]->dieptsiz;
 8022e90:	691a      	ldr	r2, [r3, #16]
          bytes = XMC_USBD_lWriteFifo(ep);
          ep->xferCount += bytes;
          ep->xferBuffer += bytes;
        }
      }
      if (diepint.b.xfercompl)
 8022e92:	d530      	bpl.n	8022ef6 <XMC_USBD_IRQHandler+0x32e>
      {
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* update xfer values */
          if ((dieptsiz.b.pktcnt == 0U) && (dieptsiz.b.xfersize == 0U))
 8022e94:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
 8022e98:	2a00      	cmp	r2, #0
 8022e9a:	f000 8218 	beq.w	80232ce <XMC_USBD_IRQHandler+0x706>
 8022e9e:	6a81      	ldr	r1, [r0, #40]	; 0x28
            uint32_t Bytes = ep->xferLength - ep->xferCount;
            ep->xferCount += Bytes;
            ep->xferBuffer += Bytes;
          }
        }
        if (ep->xferTotal==ep->xferLength)
 8022ea0:	fb0b 420e 	mla	r2, fp, lr, r4
 8022ea4:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8022ea6:	428b      	cmp	r3, r1
 8022ea8:	d133      	bne.n	8022f12 <XMC_USBD_IRQHandler+0x34a>
        {
          ep->inInUse = 0U;
 8022eaa:	6853      	ldr	r3, [r2, #4]
 8022eac:	f023 0308 	bic.w	r3, r3, #8
 8022eb0:	6053      	str	r3, [r2, #4]
 8022eb2:	e017      	b.n	8022ee4 <XMC_USBD_IRQHandler+0x31c>
 8022eb4:	1fffa868 	.word	0x1fffa868
 8022eb8:	1fffa864 	.word	0x1fffa864
                     0x1U) << 7U) | (uint32_t)diepmsk.d32);
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
      {
        dieptsiz.d32 = xmc_device.endpoint_in_register[ep_num]->dieptsiz;
      }
      if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022ebc:	2a01      	cmp	r2, #1
 8022ebe:	d102      	bne.n	8022ec6 <XMC_USBD_IRQHandler+0x2fe>
      {
        if (diepint.b.emptyintr)
 8022ec0:	0629      	lsls	r1, r5, #24
 8022ec2:	f100 822a 	bmi.w	802331a <XMC_USBD_IRQHandler+0x752>
          bytes = XMC_USBD_lWriteFifo(ep);
          ep->xferCount += bytes;
          ep->xferBuffer += bytes;
        }
      }
      if (diepint.b.xfercompl)
 8022ec6:	07e9      	lsls	r1, r5, #31
 8022ec8:	d515      	bpl.n	8022ef6 <XMC_USBD_IRQHandler+0x32e>
            uint32_t Bytes = ep->xferLength - ep->xferCount;
            ep->xferCount += Bytes;
            ep->xferBuffer += Bytes;
          }
        }
        if (ep->xferTotal==ep->xferLength)
 8022eca:	fb0b 400e 	mla	r0, fp, lr, r4
 8022ece:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8022ed0:	6a81      	ldr	r1, [r0, #40]	; 0x28
 8022ed2:	428b      	cmp	r3, r1
 8022ed4:	d11d      	bne.n	8022f12 <XMC_USBD_IRQHandler+0x34a>
        {
          ep->inInUse = 0U;
 8022ed6:	6843      	ldr	r3, [r0, #4]
          if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022ed8:	2a01      	cmp	r2, #1
            ep->xferBuffer += Bytes;
          }
        }
        if (ep->xferTotal==ep->xferLength)
        {
          ep->inInUse = 0U;
 8022eda:	f023 0308 	bic.w	r3, r3, #8
 8022ede:	6043      	str	r3, [r0, #4]
          if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022ee0:	f000 8273 	beq.w	80233ca <XMC_USBD_IRQHandler+0x802>
          {
            /* mask fifo empty interrupt */
            xmc_device.device_register->dtknqr4_fifoemptymsk =
            (uint32_t)(xmc_device.device_register->dtknqr4_fifoemptymsk & ~(((uint32_t)1U << ep_num)));
          }
          xmc_device.EndpointEvent_cb(0x80U | ep_num,XMC_USBD_EP_EVENT_IN);
 8022ee4:	f8d4 3204 	ldr.w	r3, [r4, #516]	; 0x204
 8022ee8:	f046 0080 	orr.w	r0, r6, #128	; 0x80
 8022eec:	2102      	movs	r1, #2
 8022eee:	4798      	blx	r3
 8022ef0:	9b02      	ldr	r3, [sp, #8]
 8022ef2:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 **/
void XMC_USBD_ClearEventINEP(uint32_t event,const uint8_t ep_num)
{
  diepint_data_t clear;
  clear.d32 = event;
  xmc_device.endpoint_in_register[ep_num]->diepint = clear.d32;
 8022ef6:	609d      	str	r5, [r3, #8]

      }

      XMC_USBD_ClearEventINEP((uint32_t)diepint.d32,ep_num);
    }
    ep_num++;
 8022ef8:	3601      	adds	r6, #1
 8022efa:	b2f6      	uxtb	r6, r6
  
  dieptsiz.d32 = 0U;
  mask = daint.ep.in;
  ep_num = 0U;
  
  while ((uint16_t)mask >> ep_num)
 8022efc:	fa59 f306 	asrs.w	r3, r9, r6
 8022f00:	46b6      	mov	lr, r6
 8022f02:	d1a7      	bne.n	8022e54 <XMC_USBD_IRQHandler+0x28c>
 8022f04:	f8dd a010 	ldr.w	sl, [sp, #16]
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022f08:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
 8022f0c:	2200      	movs	r2, #0
 8022f0e:	615a      	str	r2, [r3, #20]
 8022f10:	e68b      	b.n	8022c2a <XMC_USBD_IRQHandler+0x62>
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
  ctl.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022f12:	fb0b f20e 	mul.w	r2, fp, lr
 8022f16:	18a0      	adds	r0, r4, r2
 8022f18:	5ca2      	ldrb	r2, [r4, r2]

  if ((ep->xferTotal - ep->xferLength)  < ep->maxTransferSize)
 8022f1a:	6880      	ldr	r0, [r0, #8]
 8022f1c:	ebc1 0803 	rsb	r8, r1, r3
 8022f20:	f3c0 0c12 	ubfx	ip, r0, #0, #19
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
  ctl.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022f24:	f002 020f 	and.w	r2, r2, #15

  if ((ep->xferTotal - ep->xferLength)  < ep->maxTransferSize)
 8022f28:	45e0      	cmp	r8, ip
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
  ctl.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022f2a:	9206      	str	r2, [sp, #24]
 8022f2c:	f102 026a 	add.w	r2, r2, #106	; 0x6a
  {
    ep->xferLength = ep->xferTotal;
  }
  else
  {
    ep->xferLength += ep->maxTransferSize;
 8022f30:	bf28      	it	cs
 8022f32:	eb01 030c 	addcs.w	r3, r1, ip
 8022f36:	fb0b fc0e 	mul.w	ip, fp, lr
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
  ctl.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022f3a:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 8022f3e:	9205      	str	r2, [sp, #20]
 8022f40:	eb04 010c 	add.w	r1, r4, ip
 8022f44:	6812      	ldr	r2, [r2, #0]
 8022f46:	628b      	str	r3, [r1, #40]	; 0x28
static void XMC_USBD_lStartWriteXfer(XMC_USBD_EP_t *const ep) 
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
 8022f48:	2000      	movs	r0, #0
 8022f4a:	f101 0828 	add.w	r8, r1, #40	; 0x28
  }
  else
  {
    ep->xferLength += ep->maxTransferSize;
  }
  if (ep->xferLength == 0U)
 8022f4e:	2b00      	cmp	r3, #0
 8022f50:	f000 81dd 	beq.w	802330e <XMC_USBD_IRQHandler+0x746>
    size.b.xfersize = 0U;
    size.b.pktcnt = 1U;
  }
  else
  {
    if (ep->address_u.address_st.number == 0U)
 8022f54:	f814 c00c 	ldrb.w	ip, [r4, ip]
 8022f58:	f01c 0f0f 	tst.w	ip, #15
 8022f5c:	f000 81cf 	beq.w	80232fe <XMC_USBD_IRQHandler+0x736>
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
    }
    else
    {
      size.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
      size.b.pktcnt = (uint16_t)(((uint16_t)(ep->xferLength - ep->xferCount) + (uint16_t)((uint16_t)ep->maxPacketSize - 1U))/
 8022f60:	6849      	ldr	r1, [r1, #4]
      /* ep->maxXferSize equals maxPacketSize */
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
    }
    else
    {
      size.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
 8022f62:	f8d8 7004 	ldr.w	r7, [r8, #4]
      size.b.pktcnt = (uint16_t)(((uint16_t)(ep->xferLength - ep->xferCount) + (uint16_t)((uint16_t)ep->maxPacketSize - 1U))/
 8022f66:	f3c1 2cc6 	ubfx	ip, r1, #11, #7
 8022f6a:	f10c 38ff 	add.w	r8, ip, #4294967295
 8022f6e:	1bd9      	subs	r1, r3, r7
      /* ep->maxXferSize equals maxPacketSize */
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
    }
    else
    {
      size.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
 8022f70:	460b      	mov	r3, r1
      size.b.pktcnt = (uint16_t)(((uint16_t)(ep->xferLength - ep->xferCount) + (uint16_t)((uint16_t)ep->maxPacketSize - 1U))/
 8022f72:	fa1f f888 	uxth.w	r8, r8
 8022f76:	fa18 f181 	uxtah	r1, r8, r1
      /* ep->maxXferSize equals maxPacketSize */
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
    }
    else
    {
      size.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
 8022f7a:	f3c3 0312 	ubfx	r3, r3, #0, #19
      size.b.pktcnt = (uint16_t)(((uint16_t)(ep->xferLength - ep->xferCount) + (uint16_t)((uint16_t)ep->maxPacketSize - 1U))/
 8022f7e:	fb91 fcfc 	sdiv	ip, r1, ip
 8022f82:	f3cc 0c09 	ubfx	ip, ip, #0, #10
    		 ep->maxPacketSize);
    }
    if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022f86:	49c2      	ldr	r1, [pc, #776]	; (8023290 <XMC_USBD_IRQHandler+0x6c8>)
 8022f88:	6809      	ldr	r1, [r1, #0]
 8022f8a:	7b49      	ldrb	r1, [r1, #13]
 8022f8c:	f363 0012 	bfi	r0, r3, #0, #19
 8022f90:	f36c 40dc 	bfi	r0, ip, #19, #10
 8022f94:	2900      	cmp	r1, #0
 8022f96:	f040 820d 	bne.w	80233b4 <XMC_USBD_IRQHandler+0x7ec>
    {
      /* Program dma*/
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepdma = (uint32_t)ep->xferBuffer;
 8022f9a:	fb0b 430e 	mla	r3, fp, lr, r4
 8022f9e:	9905      	ldr	r1, [sp, #20]
 8022fa0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8022fa2:	614b      	str	r3, [r1, #20]
			xmc_device.device_register->dtknqr4_fifoemptymsk |= (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
    }
  }

  /* Program size of transfer and enable endpoint */
  xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dieptsiz = size.d32;
 8022fa4:	fb0b fe0e 	mul.w	lr, fp, lr
 8022fa8:	9b02      	ldr	r3, [sp, #8]
 8022faa:	f814 100e 	ldrb.w	r1, [r4, lr]
 8022fae:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 8022fb2:	f001 010f 	and.w	r1, r1, #15
 8022fb6:	316a      	adds	r1, #106	; 0x6a
  ctl.b.epena = 1U;
  ctl.b.cnak = 1U;
 8022fb8:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
			xmc_device.device_register->dtknqr4_fifoemptymsk |= (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
    }
  }

  /* Program size of transfer and enable endpoint */
  xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dieptsiz = size.d32;
 8022fbc:	f854 1021 	ldr.w	r1, [r4, r1, lsl #2]
 8022fc0:	6108      	str	r0, [r1, #16]
  ctl.b.epena = 1U;
  ctl.b.cnak = 1U;
  xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = ctl.d32;
 8022fc2:	600a      	str	r2, [r1, #0]
 **/
void XMC_USBD_ClearEventINEP(uint32_t event,const uint8_t ep_num)
{
  diepint_data_t clear;
  clear.d32 = event;
  xmc_device.endpoint_in_register[ep_num]->diepint = clear.d32;
 8022fc4:	609d      	str	r5, [r3, #8]
 8022fc6:	e797      	b.n	8022ef8 <XMC_USBD_IRQHandler+0x330>
  /* Normaly we need to check dctl
   * We are always fullspeed, so max it up. */
  depctl_data_t epctl;
  gusbcfg_data_t gusbcfg;
	
  epctl.d32=xmc_device.endpoint_in_register[0U]->diepctl;
 8022fc8:	f8d4 11a8 	ldr.w	r1, [r4, #424]	; 0x1a8
  epctl.b.mps = 0x00U; /* 64 Byte, this is also automatically set for out ep */
  xmc_device.endpoint_in_register[0U]->diepctl = epctl.d32;

  /* update device connected flag */
  xmc_device.IsConnected = 1U;
 8022fcc:	f894 21fe 	ldrb.w	r2, [r4, #510]	; 0x1fe
  /* Normaly we need to check dctl
   * We are always fullspeed, so max it up. */
  depctl_data_t epctl;
  gusbcfg_data_t gusbcfg;
	
  epctl.d32=xmc_device.endpoint_in_register[0U]->diepctl;
 8022fd0:	680b      	ldr	r3, [r1, #0]

  /* update device connected flag */
  xmc_device.IsConnected = 1U;
  xmc_device.IsPowered = 1U;

  xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_CONNECT);
 8022fd2:	f8d4 5200 	ldr.w	r5, [r4, #512]	; 0x200
   * We are always fullspeed, so max it up. */
  depctl_data_t epctl;
  gusbcfg_data_t gusbcfg;
	
  epctl.d32=xmc_device.endpoint_in_register[0U]->diepctl;
  epctl.b.mps = 0x00U; /* 64 Byte, this is also automatically set for out ep */
 8022fd6:	f36f 030a 	bfc	r3, #0, #11
  xmc_device.endpoint_in_register[0U]->diepctl = epctl.d32;

  /* update device connected flag */
  xmc_device.IsConnected = 1U;
  xmc_device.IsPowered = 1U;
 8022fda:	f042 0205 	orr.w	r2, r2, #5
  depctl_data_t epctl;
  gusbcfg_data_t gusbcfg;
	
  epctl.d32=xmc_device.endpoint_in_register[0U]->diepctl;
  epctl.b.mps = 0x00U; /* 64 Byte, this is also automatically set for out ep */
  xmc_device.endpoint_in_register[0U]->diepctl = epctl.d32;
 8022fde:	600b      	str	r3, [r1, #0]

  /* update device connected flag */
  xmc_device.IsConnected = 1U;
  xmc_device.IsPowered = 1U;

  xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_CONNECT);
 8022fe0:	2002      	movs	r0, #2
  epctl.b.mps = 0x00U; /* 64 Byte, this is also automatically set for out ep */
  xmc_device.endpoint_in_register[0U]->diepctl = epctl.d32;

  /* update device connected flag */
  xmc_device.IsConnected = 1U;
  xmc_device.IsPowered = 1U;
 8022fe2:	f884 21fe 	strb.w	r2, [r4, #510]	; 0x1fe

  xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_CONNECT);
 8022fe6:	47a8      	blx	r5

  /* Set Trim */  
  gusbcfg.d32 = xmc_device.global_register->gusbcfg;
 8022fe8:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
 8022fec:	68da      	ldr	r2, [r3, #12]
  gusbcfg.b.usbtrdtim = 9U; /* default value for LS/FS */
 8022fee:	2109      	movs	r1, #9
 8022ff0:	f361 228d 	bfi	r2, r1, #10, #4
	  break;
    case (XMC_USBD_EVENT_EARLYSUSPEND):
	  clear.b.erlysuspend = 1U;
	  break;
    case (XMC_USBD_EVENT_ENUMDONE):
	  clear.b.enumdone = 1U;
 8022ff4:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_CONNECT);

  /* Set Trim */  
  gusbcfg.d32 = xmc_device.global_register->gusbcfg;
  gusbcfg.b.usbtrdtim = 9U; /* default value for LS/FS */
  xmc_device.global_register->gusbcfg = gusbcfg.d32;
 8022ff8:	60da      	str	r2, [r3, #12]
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022ffa:	6159      	str	r1, [r3, #20]
 8022ffc:	e611      	b.n	8022c22 <XMC_USBD_IRQHandler+0x5a>
  fifosize_data_t gnptxfsiz;
  daint_data_t daint;
  dcfg_data_t dcfg;
	
  /* Clear the Remote Wakeup Signaling */
  dctl.d32 = xmc_device.device_register->dctl;
 8022ffe:	f8d4 11a4 	ldr.w	r1, [r4, #420]	; 0x1a4
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 8023002:	f8d4 91c4 	ldr.w	r9, [r4, #452]	; 0x1c4
  fifosize_data_t gnptxfsiz;
  daint_data_t daint;
  dcfg_data_t dcfg;
	
  /* Clear the Remote Wakeup Signaling */
  dctl.d32 = xmc_device.device_register->dctl;
 8023006:	684a      	ldr	r2, [r1, #4]
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 8023008:	f8d4 71d4 	ldr.w	r7, [r4, #468]	; 0x1d4
 802300c:	f8d4 61d8 	ldr.w	r6, [r4, #472]	; 0x1d8
 8023010:	f8d4 01dc 	ldr.w	r0, [r4, #476]	; 0x1dc
  daint_data_t daint;
  dcfg_data_t dcfg;
	
  /* Clear the Remote Wakeup Signaling */
  dctl.d32 = xmc_device.device_register->dctl;
  dctl.b.rmtwkupsig = 1U;
 8023014:	f042 0201 	orr.w	r2, r2, #1
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 8023018:	f504 78e4 	add.w	r8, r4, #456	; 0x1c8
 802301c:	e898 5100 	ldmia.w	r8, {r8, ip, lr}
  dcfg_data_t dcfg;
	
  /* Clear the Remote Wakeup Signaling */
  dctl.d32 = xmc_device.device_register->dctl;
  dctl.b.rmtwkupsig = 1U;
  xmc_device.device_register->dctl = dctl.d32;
 8023020:	604a      	str	r2, [r1, #4]

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 8023022:	f8d9 2000 	ldr.w	r2, [r9]
		epctl.b.snak = 1U;
 8023026:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
		epctl.b.stall = 0U;
 802302a:	f36f 5255 	bfc	r2, #21, #1
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
 802302e:	f8c9 2000 	str.w	r2, [r9]
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 8023032:	f8d8 2000 	ldr.w	r2, [r8]
  gnptxfsiz.b.startaddr = 64U;
  xmc_device.global_register->gnptxfsiz = gnptxfsiz.d32;
  /* calculate the size for the rest */
  for (i = 1U;i < (uint8_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.global_register->dtxfsiz[i- 1U] = (uint32_t)(((256U + (i*(64U)))/4U) | ((uint32_t)16U << 16U));
 8023036:	f8df 9268 	ldr.w	r9, [pc, #616]	; 80232a0 <XMC_USBD_IRQHandler+0x6d8>

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
		epctl.b.snak = 1U;
 802303a:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
		epctl.b.stall = 0U;
 802303e:	f36f 5255 	bfc	r2, #21, #1
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
 8023042:	f8c8 2000 	str.w	r2, [r8]
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 8023046:	f8dc 2000 	ldr.w	r2, [ip]
  gnptxfsiz.b.startaddr = 64U;
  xmc_device.global_register->gnptxfsiz = gnptxfsiz.d32;
  /* calculate the size for the rest */
  for (i = 1U;i < (uint8_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.global_register->dtxfsiz[i- 1U] = (uint32_t)(((256U + (i*(64U)))/4U) | ((uint32_t)16U << 16U));
 802304a:	f8df 8258 	ldr.w	r8, [pc, #600]	; 80232a4 <XMC_USBD_IRQHandler+0x6dc>

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
		epctl.b.snak = 1U;
 802304e:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
		epctl.b.stall = 0U;
 8023052:	f36f 5255 	bfc	r2, #21, #1
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
 8023056:	f8cc 2000 	str.w	r2, [ip]
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 802305a:	f8de 2000 	ldr.w	r2, [lr]
  gnptxfsiz.b.startaddr = 64U;
  xmc_device.global_register->gnptxfsiz = gnptxfsiz.d32;
  /* calculate the size for the rest */
  for (i = 1U;i < (uint8_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.global_register->dtxfsiz[i- 1U] = (uint32_t)(((256U + (i*(64U)))/4U) | ((uint32_t)16U << 16U));
 802305e:	f8df c248 	ldr.w	ip, [pc, #584]	; 80232a8 <XMC_USBD_IRQHandler+0x6e0>

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
		epctl.b.snak = 1U;
 8023062:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
		epctl.b.stall = 0U;
 8023066:	f36f 5255 	bfc	r2, #21, #1
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
 802306a:	f8ce 2000 	str.w	r2, [lr]
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 802306e:	683a      	ldr	r2, [r7, #0]
  gnptxfsiz.b.startaddr = 64U;
  xmc_device.global_register->gnptxfsiz = gnptxfsiz.d32;
  /* calculate the size for the rest */
  for (i = 1U;i < (uint8_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.global_register->dtxfsiz[i- 1U] = (uint32_t)(((256U + (i*(64U)))/4U) | ((uint32_t)16U << 16U));
 8023070:	f8df e238 	ldr.w	lr, [pc, #568]	; 80232ac <XMC_USBD_IRQHandler+0x6e4>

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
		epctl.b.snak = 1U;
 8023074:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
		epctl.b.stall = 0U;
 8023078:	f36f 5255 	bfc	r2, #21, #1
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
 802307c:	603a      	str	r2, [r7, #0]
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 802307e:	6832      	ldr	r2, [r6, #0]
  gnptxfsiz.b.startaddr = 64U;
  xmc_device.global_register->gnptxfsiz = gnptxfsiz.d32;
  /* calculate the size for the rest */
  for (i = 1U;i < (uint8_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.global_register->dtxfsiz[i- 1U] = (uint32_t)(((256U + (i*(64U)))/4U) | ((uint32_t)16U << 16U));
 8023080:	4f84      	ldr	r7, [pc, #528]	; (8023294 <XMC_USBD_IRQHandler+0x6cc>)

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
		epctl.b.snak = 1U;
 8023082:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
		epctl.b.stall = 0U;
 8023086:	f36f 5255 	bfc	r2, #21, #1
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
 802308a:	6032      	str	r2, [r6, #0]
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 802308c:	6802      	ldr	r2, [r0, #0]
  gnptxfsiz.b.startaddr = 64U;
  xmc_device.global_register->gnptxfsiz = gnptxfsiz.d32;
  /* calculate the size for the rest */
  for (i = 1U;i < (uint8_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.global_register->dtxfsiz[i- 1U] = (uint32_t)(((256U + (i*(64U)))/4U) | ((uint32_t)16U << 16U));
 802308e:	4e82      	ldr	r6, [pc, #520]	; (8023298 <XMC_USBD_IRQHandler+0x6d0>)

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
		epctl.b.snak = 1U;
 8023090:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
		epctl.b.stall = 0U;
 8023094:	f36f 5255 	bfc	r2, #21, #1
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
 8023098:	6002      	str	r2, [r0, #0]
  }

  /* Configure fifos */
  /* Calculate the size of the rx fifo */
  xmc_device.global_register->grxfsiz = 64U;
 802309a:	2040      	movs	r0, #64	; 0x40
  /* Calculate the size of the tx fifo for ep 0 */  
  gnptxfsiz.d32 = 0U;
  gnptxfsiz.b.depth = 16U;
 802309c:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
  }

  /* Configure fifos */
  /* Calculate the size of the rx fifo */
  xmc_device.global_register->grxfsiz = 64U;
 80230a0:	6258      	str	r0, [r3, #36]	; 0x24
  /* Calculate the size of the tx fifo for ep 0 */  
  gnptxfsiz.d32 = 0U;
  gnptxfsiz.b.depth = 16U;
  gnptxfsiz.b.startaddr = 64U;
 80230a2:	f360 020f 	bfi	r2, r0, #0, #16
 */
static void XMC_USBD_lFlushTXFifo(const uint8_t fifo_num) 
{
  volatile grstctl_t data;  
  uint32_t count;
  data.d32 = 0U;
 80230a6:	2000      	movs	r0, #0
  xmc_device.global_register->grxfsiz = 64U;
  /* Calculate the size of the tx fifo for ep 0 */  
  gnptxfsiz.d32 = 0U;
  gnptxfsiz.b.depth = 16U;
  gnptxfsiz.b.startaddr = 64U;
  xmc_device.global_register->gnptxfsiz = gnptxfsiz.d32;
 80230a8:	629a      	str	r2, [r3, #40]	; 0x28
  /* calculate the size for the rest */
  for (i = 1U;i < (uint8_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.global_register->dtxfsiz[i- 1U] = (uint32_t)(((256U + (i*(64U)))/4U) | ((uint32_t)16U << 16U));
 80230aa:	f8c3 9104 	str.w	r9, [r3, #260]	; 0x104
 80230ae:	f8c3 8108 	str.w	r8, [r3, #264]	; 0x108
 80230b2:	f8c3 c10c 	str.w	ip, [r3, #268]	; 0x10c
 80230b6:	f8c3 e110 	str.w	lr, [r3, #272]	; 0x110
 80230ba:	f8c3 7114 	str.w	r7, [r3, #276]	; 0x114
 80230be:	f8c3 6118 	str.w	r6, [r3, #280]	; 0x118
 */
static void XMC_USBD_lFlushTXFifo(const uint8_t fifo_num) 
{
  volatile grstctl_t data;  
  uint32_t count;
  data.d32 = 0U;
 80230c2:	900d      	str	r0, [sp, #52]	; 0x34
  /*flush fifo */
  data.b.txfflsh = 1U;
 80230c4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80230c6:	f042 0220 	orr.w	r2, r2, #32
 80230ca:	920d      	str	r2, [sp, #52]	; 0x34
  data.b.txfnum = fifo_num;
 80230cc:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80230ce:	f422 62f8 	bic.w	r2, r2, #1984	; 0x7c0
 80230d2:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80230d6:	920d      	str	r2, [sp, #52]	; 0x34
  xmc_device.global_register->grstctl = data.d32;
 80230d8:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80230da:	611a      	str	r2, [r3, #16]
  for (count = 0U;count < 1000U; count++){}
  do
  {
   data.d32 = xmc_device.global_register->grstctl;
 80230dc:	691a      	ldr	r2, [r3, #16]
 80230de:	920d      	str	r2, [sp, #52]	; 0x34
  } while (data.b.txfflsh);
 80230e0:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80230e2:	f3c2 1240 	ubfx	r2, r2, #5, #1
 80230e6:	2a00      	cmp	r2, #0
 80230e8:	d1f8      	bne.n	80230dc <XMC_USBD_IRQHandler+0x514>
 */
static void XMC_USBD_lFlushTXFifo(const uint8_t fifo_num) 
{
  volatile grstctl_t data;  
  uint32_t count;
  data.d32 = 0U;
 80230ea:	920c      	str	r2, [sp, #48]	; 0x30
  /*flush fifo */
  data.b.txfflsh = 1U;
 80230ec:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80230ee:	f042 0220 	orr.w	r2, r2, #32
 80230f2:	920c      	str	r2, [sp, #48]	; 0x30
  data.b.txfnum = fifo_num;
 80230f4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80230f6:	f422 62f8 	bic.w	r2, r2, #1984	; 0x7c0
 80230fa:	920c      	str	r2, [sp, #48]	; 0x30
  xmc_device.global_register->grstctl = data.d32;
 80230fc:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80230fe:	611a      	str	r2, [r3, #16]
  for (count = 0U;count < 1000U; count++){}
  do
  {
   data.d32 = xmc_device.global_register->grstctl;
 8023100:	691a      	ldr	r2, [r3, #16]
 8023102:	920c      	str	r2, [sp, #48]	; 0x30
  } while (data.b.txfflsh);
 8023104:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8023106:	f3c2 1240 	ubfx	r2, r2, #5, #1
 802310a:	2a00      	cmp	r2, #0
 802310c:	d1f8      	bne.n	8023100 <XMC_USBD_IRQHandler+0x538>
static void XMC_USBD_lFlushRXFifo(void) 
{
  volatile grstctl_t data;  
  uint32_t count;
	
	data.d32 = 0U;
 802310e:	920b      	str	r2, [sp, #44]	; 0x2c
  data.b.rxfflsh = 1U;
 8023110:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8023112:	f042 0210 	orr.w	r2, r2, #16
 8023116:	920b      	str	r2, [sp, #44]	; 0x2c
  /* flush FIFO */
  xmc_device.global_register->grstctl = data.d32;
 8023118:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 802311a:	611a      	str	r2, [r3, #16]
  do
  {
    for (count = 0U; count < 1000U; count++){}
    data.d32 = xmc_device.global_register->grstctl;
 802311c:	691a      	ldr	r2, [r3, #16]
 802311e:	920b      	str	r2, [sp, #44]	; 0x2c
  } while (data.b.rxfflsh);
 8023120:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8023122:	f3c2 1200 	ubfx	r2, r2, #4, #1
 8023126:	2a00      	cmp	r2, #0
 8023128:	d1f8      	bne.n	802311c <XMC_USBD_IRQHandler+0x554>
  XMC_USBD_lFlushRXFifo();
  /* Flush learning queue not needed due to fifo config */
  /* enable ep0 interrupts */  
  daint.d32 = 0U;
  daint.b.inep0 = 1U;
  daint.b.outep0 = 1U;
 802312a:	f04f 1301 	mov.w	r3, #65537	; 0x10001
  xmc_device.device_register->daintmsk = daint.d32;
 802312e:	61cb      	str	r3, [r1, #28]
 **/
void XMC_USBD_EnableEventOUTEP(uint32_t event)
{
	doepint_data_t doepint;
	doepint.d32 = event;
	xmc_device.device_register->doepmsk |= doepint.d32;
 8023130:	694b      	ldr	r3, [r1, #20]
  /* Clear device Address */  
  dcfg.d32 = xmc_device.device_register->dcfg;
  dcfg.b.devaddr = 0U;
  xmc_device.device_register->dcfg = dcfg.d32;

  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8023132:	9801      	ldr	r0, [sp, #4]
 **/
void XMC_USBD_EnableEventOUTEP(uint32_t event)
{
	doepint_data_t doepint;
	doepint.d32 = event;
	xmc_device.device_register->doepmsk |= doepint.d32;
 8023134:	f043 030f 	orr.w	r3, r3, #15
  /* Clear device Address */  
  dcfg.d32 = xmc_device.device_register->dcfg;
  dcfg.b.devaddr = 0U;
  xmc_device.device_register->dcfg = dcfg.d32;

  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8023138:	7b40      	ldrb	r0, [r0, #13]
 **/
void XMC_USBD_EnableEventOUTEP(uint32_t event)
{
	doepint_data_t doepint;
	doepint.d32 = event;
	xmc_device.device_register->doepmsk |= doepint.d32;
 802313a:	614b      	str	r3, [r1, #20]
 **/
void XMC_USBD_EnableEventINEP(uint32_t event)
{
	diepint_data_t diepint;
	diepint.d32 = event;
	xmc_device.device_register->diepmsk |= diepint.d32;
 802313c:	690b      	ldr	r3, [r1, #16]
 802313e:	f043 030f 	orr.w	r3, r3, #15
 8023142:	610b      	str	r3, [r1, #16]
  XMC_USBD_EnableEventINEP(((uint32_t)XMC_USBD_EVENT_IN_EP_TX_COMPLET | (uint32_t)XMC_USBD_EVENT_IN_EP_DISABLED |
		  (uint32_t)XMC_USBD_EVENT_IN_EP_AHB_ERROR | (uint32_t)XMC_USBD_EVENT_IN_EP_TIMEOUT));


  /* Clear device Address */  
  dcfg.d32 = xmc_device.device_register->dcfg;
 8023144:	680b      	ldr	r3, [r1, #0]
  dcfg.b.devaddr = 0U;
  xmc_device.device_register->dcfg = dcfg.d32;

  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8023146:	2801      	cmp	r0, #1
		  (uint32_t)XMC_USBD_EVENT_IN_EP_AHB_ERROR | (uint32_t)XMC_USBD_EVENT_IN_EP_TIMEOUT));


  /* Clear device Address */  
  dcfg.d32 = xmc_device.device_register->dcfg;
  dcfg.b.devaddr = 0U;
 8023148:	f362 130a 	bfi	r3, r2, #4, #7
  xmc_device.device_register->dcfg = dcfg.d32;
 802314c:	600b      	str	r3, [r1, #0]

  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
  {
    /* Clear Empty interrupt */
    xmc_device.device_register->dtknqr4_fifoemptymsk = 0U;
 802314e:	bf08      	it	eq
 8023150:	634a      	streq	r2, [r1, #52]	; 0x34
  }

  xmc_device.ep[0U].outInUse = 0U;
 8023152:	6863      	ldr	r3, [r4, #4]
  xmc_device.ep[0U].inInUse = 0U;

  xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_RESET);
 8023154:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
  {
    /* Clear Empty interrupt */
    xmc_device.device_register->dtknqr4_fifoemptymsk = 0U;
  }

  xmc_device.ep[0U].outInUse = 0U;
 8023158:	f023 0310 	bic.w	r3, r3, #16
 802315c:	6063      	str	r3, [r4, #4]
  xmc_device.ep[0U].inInUse = 0U;
 802315e:	6863      	ldr	r3, [r4, #4]
 8023160:	f023 0308 	bic.w	r3, r3, #8
 8023164:	6063      	str	r3, [r4, #4]

  xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_RESET);
 8023166:	2004      	movs	r0, #4
 8023168:	4790      	blx	r2
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 802316a:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
  {
    case (XMC_USBD_EVENT_POWER_ON):
	  clear.b.sessreqintr = 1U;
	  break;
    case (XMC_USBD_EVENT_RESET):
	  clear.b.usbreset = 1U;
 802316e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8023172:	615a      	str	r2, [r3, #20]
 8023174:	e552      	b.n	8022c1c <XMC_USBD_IRQHandler+0x54>
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_REMOTE_WAKEUP);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_REMOTE_WAKEUP);
  }
  if (data.b.sessreqintr)
  {
    xmc_device.IsPowered = 1U;
 8023176:	f894 31fe 	ldrb.w	r3, [r4, #510]	; 0x1fe
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_POWER_ON);
 802317a:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_REMOTE_WAKEUP);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_REMOTE_WAKEUP);
  }
  if (data.b.sessreqintr)
  {
    xmc_device.IsPowered = 1U;
 802317e:	f043 0304 	orr.w	r3, r3, #4
 8023182:	f884 31fe 	strb.w	r3, [r4, #510]	; 0x1fe
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_POWER_ON);
 8023186:	2000      	movs	r0, #0
 8023188:	4790      	blx	r2
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 802318a:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
  gintsts_data_t clear;
  clear.d32 = 0U;
  switch(event)
  {
    case (XMC_USBD_EVENT_POWER_ON):
	  clear.b.sessreqintr = 1U;
 802318e:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8023192:	615a      	str	r2, [r3, #20]
 8023194:	e53f      	b.n	8022c16 <XMC_USBD_IRQHandler+0x4e>
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_SUSPEND);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_SUSPEND);
  }
  if (data.b.wkupintr)
  {
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_REMOTE_WAKEUP);
 8023196:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
 802319a:	2008      	movs	r0, #8
 802319c:	4798      	blx	r3
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 802319e:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
	  break;
    case (XMC_USBD_EVENT_RESUME):
	  clear.b.wkupintr = 1U;
	  break;
    case (XMC_USBD_EVENT_REMOTE_WAKEUP):
	  clear.b.wkupintr = 1U;
 80231a2:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 80231a6:	615a      	str	r2, [r3, #20]
 80231a8:	e532      	b.n	8022c10 <XMC_USBD_IRQHandler+0x48>
  {
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_EARLYSUSPEND);
  }
  if (data.b.usbsuspend)
  {
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_SUSPEND);
 80231aa:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
 80231ae:	2006      	movs	r0, #6
 80231b0:	4798      	blx	r3
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 80231b2:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
	  break;
    case (XMC_USBD_EVENT_RESET):
	  clear.b.usbreset = 1U;
	  break;
    case (XMC_USBD_EVENT_SUSPEND):
	  clear.b.usbsuspend = 1U;
 80231b6:	f44f 6200 	mov.w	r2, #2048	; 0x800
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 80231ba:	615a      	str	r2, [r3, #20]
 80231bc:	e523      	b.n	8022c06 <XMC_USBD_IRQHandler+0x3e>
  gintmsk.d32 = xmc_device.global_register->gintmsk;
  data.d32 = xmc_device.global_register->gintsts & gintmsk.d32;
	
  if (data.b.sofintr)
  {
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_SOF);
 80231be:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
 80231c2:	2009      	movs	r0, #9
 80231c4:	4798      	blx	r3
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 80231c6:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
	  break;
    case (XMC_USBD_EVENT_REMOTE_WAKEUP):
	  clear.b.wkupintr = 1U;
	  break;
    case (XMC_USBD_EVENT_SOF):
	  clear.b.sofintr = 1U;
 80231ca:	2208      	movs	r2, #8
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 80231cc:	615a      	str	r2, [r3, #20]
  if (data.b.sofintr)
  {
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_SOF);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_SOF);
  }
  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 80231ce:	9a01      	ldr	r2, [sp, #4]
 80231d0:	7b52      	ldrb	r2, [r2, #13]
 80231d2:	2a01      	cmp	r2, #1
 80231d4:	f47f ad0d 	bne.w	8022bf2 <XMC_USBD_IRQHandler+0x2a>
  {
    if (data.b.rxstsqlvl)
 80231d8:	06f1      	lsls	r1, r6, #27
 80231da:	f57f ad0a 	bpl.w	8022bf2 <XMC_USBD_IRQHandler+0x2a>
    {
      /* Masked that interrupt so its only done once */
      gintmsk.b.rxstsqlvl = 0U;
 80231de:	f36f 1504 	bfc	r5, #4, #1
      xmc_device.global_register->gintmsk = gintmsk.d32;
 80231e2:	619d      	str	r5, [r3, #24]
 * This function handles the interrupt, when the rx fifo is not empty anymore.
 */
static void XMC_USBD_lHandleRxFLvl(void) 
{
  device_grxsts_data_t data;	
  data.d32 = xmc_device.global_register->grxstsp;
 80231e4:	6a1a      	ldr	r2, [r3, #32]

  switch (data.b.pktsts)
 80231e6:	f3c2 4143 	ubfx	r1, r2, #17, #4
 80231ea:	2902      	cmp	r1, #2
 80231ec:	f000 80ff 	beq.w	80233ee <XMC_USBD_IRQHandler+0x826>
 80231f0:	2906      	cmp	r1, #6
 80231f2:	d149      	bne.n	8023288 <XMC_USBD_IRQHandler+0x6c0>
      break;
    case XMC_USBD_GRXSTS_PKTSTS_OUTDATA:
      XMC_USBD_lReadFifo((uint32_t)data.b.epnum,(uint32_t)data.b.bcnt);
      break;
    case XMC_USBD_GRXSTS_PKTSTS_SETUP:
      XMC_USBD_lReadFifo((uint32_t)data.b.epnum,(uint32_t)data.b.bcnt);
 80231f4:	f002 070f 	and.w	r7, r2, #15
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
  uint32_t i;
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
 80231f8:	eb04 0187 	add.w	r1, r4, r7, lsl #2
      break;
    case XMC_USBD_GRXSTS_PKTSTS_OUTDATA:
      XMC_USBD_lReadFifo((uint32_t)data.b.epnum,(uint32_t)data.b.bcnt);
      break;
    case XMC_USBD_GRXSTS_PKTSTS_SETUP:
      XMC_USBD_lReadFifo((uint32_t)data.b.epnum,(uint32_t)data.b.bcnt);
 80231fc:	f3c2 120a 	ubfx	r2, r2, #4, #11
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
  uint32_t i;
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
 8023200:	f8d1 11c4 	ldr.w	r1, [r1, #452]	; 0x1c4
{
  XMC_USBD_EP_t * ep = &xmc_device.ep[ep_num];
  uint32_t word_count;
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
 8023204:	4825      	ldr	r0, [pc, #148]	; (802329c <XMC_USBD_IRQHandler+0x6d4>)
  uint32_t i;
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
 8023206:	6809      	ldr	r1, [r1, #0]
{
  XMC_USBD_EP_t * ep = &xmc_device.ep[ep_num];
  uint32_t word_count;
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
 8023208:	f8d4 81e0 	ldr.w	r8, [r4, #480]	; 0x1e0
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
  word_count = (byte_count >> 2U );
  temp_word_count = (word_count << 2U);
  /* Check if ep is enabled and has buffer */
  if (!data.b.usbactep)
 802320c:	040e      	lsls	r6, r1, #16
 802320e:	d53b      	bpl.n	8023288 <XMC_USBD_IRQHandler+0x6c0>
  {
    /*Do Nothing*/
  }
  else if (ep->xferBuffer == NULL)
 8023210:	2134      	movs	r1, #52	; 0x34
 8023212:	fb01 0e07 	mla	lr, r1, r7, r0
 8023216:	f8de 0024 	ldr.w	r0, [lr, #36]	; 0x24
 802321a:	b3a8      	cbz	r0, 8023288 <XMC_USBD_IRQHandler+0x6c0>
	/*Do Nothing*/
  }
  else
  {
    /* store the data */
    for (i = 0U;i < word_count; i++)
 802321c:	ea5f 0c92 	movs.w	ip, r2, lsr #2
 8023220:	d00b      	beq.n	802323a <XMC_USBD_IRQHandler+0x672>
 8023222:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 8023226:	2100      	movs	r1, #0
 8023228:	e001      	b.n	802322e <XMC_USBD_IRQHandler+0x666>
 802322a:	f8de 0024 	ldr.w	r0, [lr, #36]	; 0x24
    {
      *(((uint32_t*)ep->xferBuffer)+i) = *fifo;
 802322e:	f8d8 6000 	ldr.w	r6, [r8]
 8023232:	5046      	str	r6, [r0, r1]
 8023234:	3104      	adds	r1, #4
	/*Do Nothing*/
  }
  else
  {
    /* store the data */
    for (i = 0U;i < word_count; i++)
 8023236:	4561      	cmp	r1, ip
 8023238:	d1f7      	bne.n	802322a <XMC_USBD_IRQHandler+0x662>
    {
      *(((uint32_t*)ep->xferBuffer)+i) = *fifo;
    }
    /* space is not devidable by 4 */
    if (byte_count!=temp_word_count)
 802323a:	4562      	cmp	r2, ip
 802323c:	d01b      	beq.n	8023276 <XMC_USBD_IRQHandler+0x6ae>
    {
      temp_data = *fifo;
 802323e:	f8d8 8000 	ldr.w	r8, [r8]
      for (i = 0U;(temp_word_count + i) < byte_count;i++)
 8023242:	d918      	bls.n	8023276 <XMC_USBD_IRQHandler+0x6ae>
      {
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
 8023244:	f04f 0e34 	mov.w	lr, #52	; 0x34
    }
    /* space is not devidable by 4 */
    if (byte_count!=temp_word_count)
    {
      temp_data = *fifo;
      for (i = 0U;(temp_word_count + i) < byte_count;i++)
 8023248:	4663      	mov	r3, ip
      {
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
 802324a:	fb0e 4e07 	mla	lr, lr, r7, r4
    }
    /* space is not devidable by 4 */
    if (byte_count!=temp_word_count)
    {
      temp_data = *fifo;
      for (i = 0U;(temp_word_count + i) < byte_count;i++)
 802324e:	2600      	movs	r6, #0
      {
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
 8023250:	f04f 09ff 	mov.w	r9, #255	; 0xff
 8023254:	fa09 f106 	lsl.w	r1, r9, r6
 8023258:	ea01 0108 	and.w	r1, r1, r8
 802325c:	f8de 0024 	ldr.w	r0, [lr, #36]	; 0x24
 8023260:	f8df c038 	ldr.w	ip, [pc, #56]	; 802329c <XMC_USBD_IRQHandler+0x6d4>
 8023264:	40f1      	lsrs	r1, r6
 8023266:	54c1      	strb	r1, [r0, r3]
    }
    /* space is not devidable by 4 */
    if (byte_count!=temp_word_count)
    {
      temp_data = *fifo;
      for (i = 0U;(temp_word_count + i) < byte_count;i++)
 8023268:	3301      	adds	r3, #1
 802326a:	429a      	cmp	r2, r3
 802326c:	f106 0608 	add.w	r6, r6, #8
 8023270:	d1f0      	bne.n	8023254 <XMC_USBD_IRQHandler+0x68c>
 8023272:	f8dc 31a0 	ldr.w	r3, [ip, #416]	; 0x1a0
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
      }
    }

    /* save the amount of data */
    ep->xferCount += byte_count;
 8023276:	2634      	movs	r6, #52	; 0x34
 8023278:	fb06 4607 	mla	r6, r6, r7, r4
 802327c:	6af1      	ldr	r1, [r6, #44]	; 0x2c
    ep->xferBuffer += byte_count;
 802327e:	6a70      	ldr	r0, [r6, #36]	; 0x24
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
      }
    }

    /* save the amount of data */
    ep->xferCount += byte_count;
 8023280:	4411      	add	r1, r2
    ep->xferBuffer += byte_count;
 8023282:	4402      	add	r2, r0
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
      }
    }

    /* save the amount of data */
    ep->xferCount += byte_count;
 8023284:	62f1      	str	r1, [r6, #44]	; 0x2c
    ep->xferBuffer += byte_count;
 8023286:	6272      	str	r2, [r6, #36]	; 0x24
    {
      /* Masked that interrupt so its only done once */
      gintmsk.b.rxstsqlvl = 0U;
      xmc_device.global_register->gintmsk = gintmsk.d32;
      XMC_USBD_lHandleRxFLvl(); /* handle the interrupt */
      gintmsk.b.rxstsqlvl = 1U;
 8023288:	f045 0510 	orr.w	r5, r5, #16
      xmc_device.global_register->gintmsk = gintmsk.d32;
 802328c:	619d      	str	r5, [r3, #24]
 802328e:	e4b0      	b.n	8022bf2 <XMC_USBD_IRQHandler+0x2a>
 8023290:	1fffa864 	.word	0x1fffa864
 8023294:	00100090 	.word	0x00100090
 8023298:	001000a0 	.word	0x001000a0
 802329c:	1fffa868 	.word	0x1fffa868
 80232a0:	00100050 	.word	0x00100050
 80232a4:	00100060 	.word	0x00100060
 80232a8:	00100070 	.word	0x00100070
 80232ac:	00100080 	.word	0x00100080
    ep0_data->b.xfersize = (uint8_t)ep->xferTotal;
  }
  else
  {
    /* If requested length is zero, just receive one zero length packet */
    if (ep->xferLength == 0U)
 80232b0:	b9a9      	cbnz	r1, 80232de <XMC_USBD_IRQHandler+0x716>
    {
      data.b.xfersize = 0U;
 80232b2:	f361 0312 	bfi	r3, r1, #0, #19
      data.b.pktcnt = 1U;
 80232b6:	2201      	movs	r2, #1
 80232b8:	f362 43dc 	bfi	r3, r2, #19, #10
 80232bc:	e551      	b.n	8022d62 <XMC_USBD_IRQHandler+0x19a>
 80232be:	5da2      	ldrb	r2, [r4, r6]
 80232c0:	f002 020f 	and.w	r2, r2, #15
 80232c4:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 80232c8:	f8d2 11c4 	ldr.w	r1, [r2, #452]	; 0x1c4
 80232cc:	e55b      	b.n	8022d86 <XMC_USBD_IRQHandler+0x1be>
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* update xfer values */
          if ((dieptsiz.b.pktcnt == 0U) && (dieptsiz.b.xfersize == 0U))
          {
            uint32_t Bytes = ep->xferLength - ep->xferCount;
 80232ce:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 80232d0:	6a81      	ldr	r1, [r0, #40]	; 0x28
            ep->xferCount += Bytes;
            ep->xferBuffer += Bytes;
 80232d2:	6a43      	ldr	r3, [r0, #36]	; 0x24
        {
          /* update xfer values */
          if ((dieptsiz.b.pktcnt == 0U) && (dieptsiz.b.xfersize == 0U))
          {
            uint32_t Bytes = ep->xferLength - ep->xferCount;
            ep->xferCount += Bytes;
 80232d4:	62c1      	str	r1, [r0, #44]	; 0x2c
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* update xfer values */
          if ((dieptsiz.b.pktcnt == 0U) && (dieptsiz.b.xfersize == 0U))
          {
            uint32_t Bytes = ep->xferLength - ep->xferCount;
 80232d6:	1a8a      	subs	r2, r1, r2
            ep->xferCount += Bytes;
            ep->xferBuffer += Bytes;
 80232d8:	441a      	add	r2, r3
 80232da:	6242      	str	r2, [r0, #36]	; 0x24
 80232dc:	e5e0      	b.n	8022ea0 <XMC_USBD_IRQHandler+0x2d8>
      data.b.pktcnt = 1U;
    }
    else
    {
      /* setup endpoint to recive a amount of packages by given size */
      data.b.pktcnt = (uint16_t)(((ep->xferLength - ep->xferCount) + (ep->maxPacketSize -(uint32_t)1U))/ep->maxPacketSize);
 80232de:	6842      	ldr	r2, [r0, #4]
 80232e0:	f8da 0004 	ldr.w	r0, [sl, #4]
 80232e4:	f3c2 22c6 	ubfx	r2, r2, #11, #7
 80232e8:	1a09      	subs	r1, r1, r0
 80232ea:	f102 3eff 	add.w	lr, r2, #4294967295
 80232ee:	448e      	add	lr, r1
 80232f0:	fbbe f2f2 	udiv	r2, lr, r2
 80232f4:	f362 43dc 	bfi	r3, r2, #19, #10
      data.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
 80232f8:	f361 0312 	bfi	r3, r1, #0, #19
 80232fc:	e531      	b.n	8022d62 <XMC_USBD_IRQHandler+0x19a>
  {
    if (ep->address_u.address_st.number == 0U)
    {
      size.b.pktcnt = 1U;
      /* ep->maxXferSize equals maxPacketSize */
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
 80232fe:	f8d8 1004 	ldr.w	r1, [r8, #4]
 8023302:	1a5b      	subs	r3, r3, r1
 8023304:	f3c3 0312 	ubfx	r3, r3, #0, #19
  }
  else
  {
    if (ep->address_u.address_st.number == 0U)
    {
      size.b.pktcnt = 1U;
 8023308:	f04f 0c01 	mov.w	ip, #1
 802330c:	e63b      	b.n	8022f86 <XMC_USBD_IRQHandler+0x3be>
  {
    ep->xferLength += ep->maxTransferSize;
  }
  if (ep->xferLength == 0U)
  {
    size.b.xfersize = 0U;
 802330e:	f363 0012 	bfi	r0, r3, #0, #19
    size.b.pktcnt = 1U;
 8023312:	2301      	movs	r3, #1
 8023314:	f363 40dc 	bfi	r0, r3, #19, #10
 8023318:	e644      	b.n	8022fa4 <XMC_USBD_IRQHandler+0x3dc>
  volatile uint32_t *fifo;
  uint32_t byte_count;
  uint32_t word_count;
  uint32_t result;
  uint32_t i;
  fifo = xmc_device.fifo[ep->address_u.address_st.number]; /* fifo */
 802331a:	f008 080f 	and.w	r8, r8, #15
  freeSpace.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dtxfsts;
 802331e:	f108 016a 	add.w	r1, r8, #106	; 0x6a
 8023322:	4f5e      	ldr	r7, [pc, #376]	; (802349c <XMC_USBD_IRQHandler+0x8d4>)
 8023324:	f857 1021 	ldr.w	r1, [r7, r1, lsl #2]
  /* calculate the length and the amount of dwords to copy based on the fifo status */
  byte_count = ep->xferLength - ep->xferCount;
 8023328:	6ac7      	ldr	r7, [r0, #44]	; 0x2c
  uint32_t byte_count;
  uint32_t word_count;
  uint32_t result;
  uint32_t i;
  fifo = xmc_device.fifo[ep->address_u.address_st.number]; /* fifo */
  freeSpace.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dtxfsts;
 802332a:	f8d1 c018 	ldr.w	ip, [r1, #24]
  volatile uint32_t *fifo;
  uint32_t byte_count;
  uint32_t word_count;
  uint32_t result;
  uint32_t i;
  fifo = xmc_device.fifo[ep->address_u.address_st.number]; /* fifo */
 802332e:	495b      	ldr	r1, [pc, #364]	; (802349c <XMC_USBD_IRQHandler+0x8d4>)
  freeSpace.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dtxfsts;
  /* calculate the length and the amount of dwords to copy based on the fifo status */
  byte_count = ep->xferLength - ep->xferCount;
 8023330:	9706      	str	r7, [sp, #24]
  volatile uint32_t *fifo;
  uint32_t byte_count;
  uint32_t word_count;
  uint32_t result;
  uint32_t i;
  fifo = xmc_device.fifo[ep->address_u.address_st.number]; /* fifo */
 8023332:	f108 0878 	add.w	r8, r8, #120	; 0x78
 8023336:	f851 1028 	ldr.w	r1, [r1, r8, lsl #2]
 802333a:	9107      	str	r1, [sp, #28]
  freeSpace.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dtxfsts;
  /* calculate the length and the amount of dwords to copy based on the fifo status */
  byte_count = ep->xferLength - ep->xferCount;
  if (!byte_count)
 802333c:	6a81      	ldr	r1, [r0, #40]	; 0x28
 802333e:	1bc9      	subs	r1, r1, r7
 8023340:	9105      	str	r1, [sp, #20]
 8023342:	d051      	beq.n	80233e8 <XMC_USBD_IRQHandler+0x820>
    result = 0U;
  }
  else
  {
    /* add the unaligned bytes to the word count to compare with the fifo space */
    word_count = ((uint32_t)byte_count + 3U) >> 2U;
 8023344:	f101 0803 	add.w	r8, r1, #3
    if (word_count > (uint32_t)freeSpace.b.txfspcavail )
 8023348:	fa1f fc8c 	uxth.w	ip, ip
    result = 0U;
  }
  else
  {
    /* add the unaligned bytes to the word count to compare with the fifo space */
    word_count = ((uint32_t)byte_count + 3U) >> 2U;
 802334c:	ea4f 0898 	mov.w	r8, r8, lsr #2
    if (word_count > (uint32_t)freeSpace.b.txfspcavail )
 8023350:	45e0      	cmp	r8, ip
 8023352:	d844      	bhi.n	80233de <XMC_USBD_IRQHandler+0x816>
 8023354:	fb0b 410e 	mla	r1, fp, lr, r4
      word_count = (uint32_t)freeSpace.b.txfspcavail;
      byte_count = (uint32_t)word_count << (uint32_t)2U;
    }

    /* copy data dword wise */
    for (i = 0U; i < word_count;ep->xferBuffer+= 4U)
 8023358:	f1b8 0f00 	cmp.w	r8, #0
 802335c:	f000 809b 	beq.w	8023496 <XMC_USBD_IRQHandler+0x8ce>
 8023360:	9106      	str	r1, [sp, #24]
 8023362:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
 8023366:	6a49      	ldr	r1, [r1, #36]	; 0x24
 8023368:	f8dd c01c 	ldr.w	ip, [sp, #28]
 802336c:	9f02      	ldr	r7, [sp, #8]
 802336e:	f8dd 9018 	ldr.w	r9, [sp, #24]
 8023372:	f8cd e020 	str.w	lr, [sp, #32]
 8023376:	2000      	movs	r0, #0
    {
      *fifo = *(uint32_t*)ep->xferBuffer;
 8023378:	6809      	ldr	r1, [r1, #0]
 802337a:	f8cc 1000 	str.w	r1, [ip]
      word_count = (uint32_t)freeSpace.b.txfspcavail;
      byte_count = (uint32_t)word_count << (uint32_t)2U;
    }

    /* copy data dword wise */
    for (i = 0U; i < word_count;ep->xferBuffer+= 4U)
 802337e:	f8d9 1024 	ldr.w	r1, [r9, #36]	; 0x24
    {
      *fifo = *(uint32_t*)ep->xferBuffer;
      i++;
 8023382:	3001      	adds	r0, #1
      word_count = (uint32_t)freeSpace.b.txfspcavail;
      byte_count = (uint32_t)word_count << (uint32_t)2U;
    }

    /* copy data dword wise */
    for (i = 0U; i < word_count;ep->xferBuffer+= 4U)
 8023384:	3104      	adds	r1, #4
 8023386:	4540      	cmp	r0, r8
 8023388:	f8c9 1024 	str.w	r1, [r9, #36]	; 0x24
 802338c:	d1f4      	bne.n	8023378 <XMC_USBD_IRQHandler+0x7b0>
 802338e:	9806      	ldr	r0, [sp, #24]
 8023390:	f8dd e020 	ldr.w	lr, [sp, #32]
 8023394:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8023396:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
 802339a:	9702      	str	r7, [sp, #8]
 802339c:	9006      	str	r0, [sp, #24]
 802339e:	4607      	mov	r7, r0
      {
        if (diepint.b.emptyintr)
        {
          uint32_t bytes;
          bytes = XMC_USBD_lWriteFifo(ep);
          ep->xferCount += bytes;
 80233a0:	46bc      	mov	ip, r7
 80233a2:	9f05      	ldr	r7, [sp, #20]
 80233a4:	fb0b 400e 	mla	r0, fp, lr, r4
 80233a8:	44bc      	add	ip, r7
          ep->xferBuffer += bytes;
 80233aa:	4439      	add	r1, r7
      {
        if (diepint.b.emptyintr)
        {
          uint32_t bytes;
          bytes = XMC_USBD_lWriteFifo(ep);
          ep->xferCount += bytes;
 80233ac:	f8c0 c02c 	str.w	ip, [r0, #44]	; 0x2c
          ep->xferBuffer += bytes;
 80233b0:	6241      	str	r1, [r0, #36]	; 0x24
 80233b2:	e588      	b.n	8022ec6 <XMC_USBD_IRQHandler+0x2fe>
    if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
    {
      /* Program dma*/
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepdma = (uint32_t)ep->xferBuffer;
    }
    if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 80233b4:	2901      	cmp	r1, #1
 80233b6:	f47f adf5 	bne.w	8022fa4 <XMC_USBD_IRQHandler+0x3dc>
    {
      /* enable fifo empty interrupt */
			xmc_device.device_register->dtknqr4_fifoemptymsk |= (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
 80233ba:	9f06      	ldr	r7, [sp, #24]
 80233bc:	f8da 3034 	ldr.w	r3, [sl, #52]	; 0x34
 80233c0:	40b9      	lsls	r1, r7
 80233c2:	4319      	orrs	r1, r3
 80233c4:	f8ca 1034 	str.w	r1, [sl, #52]	; 0x34
 80233c8:	e5ec      	b.n	8022fa4 <XMC_USBD_IRQHandler+0x3dc>
          ep->inInUse = 0U;
          if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
          {
            /* mask fifo empty interrupt */
            xmc_device.device_register->dtknqr4_fifoemptymsk =
            (uint32_t)(xmc_device.device_register->dtknqr4_fifoemptymsk & ~(((uint32_t)1U << ep_num)));
 80233ca:	4b34      	ldr	r3, [pc, #208]	; (802349c <XMC_USBD_IRQHandler+0x8d4>)
 80233cc:	f8d3 11a4 	ldr.w	r1, [r3, #420]	; 0x1a4
 80233d0:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 80233d2:	fa02 f20e 	lsl.w	r2, r2, lr
 80233d6:	ea23 0202 	bic.w	r2, r3, r2
        {
          ep->inInUse = 0U;
          if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
          {
            /* mask fifo empty interrupt */
            xmc_device.device_register->dtknqr4_fifoemptymsk =
 80233da:	634a      	str	r2, [r1, #52]	; 0x34
 80233dc:	e582      	b.n	8022ee4 <XMC_USBD_IRQHandler+0x31c>
    /* add the unaligned bytes to the word count to compare with the fifo space */
    word_count = ((uint32_t)byte_count + 3U) >> 2U;
    if (word_count > (uint32_t)freeSpace.b.txfspcavail )
    {
      word_count = (uint32_t)freeSpace.b.txfspcavail;
      byte_count = (uint32_t)word_count << (uint32_t)2U;
 80233de:	ea4f 018c 	mov.w	r1, ip, lsl #2
 80233e2:	9105      	str	r1, [sp, #20]
 80233e4:	46e0      	mov	r8, ip
 80233e6:	e7b5      	b.n	8023354 <XMC_USBD_IRQHandler+0x78c>
 80233e8:	6a41      	ldr	r1, [r0, #36]	; 0x24
 80233ea:	9f06      	ldr	r7, [sp, #24]
 80233ec:	e7d8      	b.n	80233a0 <XMC_USBD_IRQHandler+0x7d8>
    case XMC_USBD_GRXSTS_PKTSTS_GOUTNAK:
      break;
    case XMC_USBD_GRXSTS_PKTSTS_OUTCMPL:
      break;
    case XMC_USBD_GRXSTS_PKTSTS_OUTDATA:
      XMC_USBD_lReadFifo((uint32_t)data.b.epnum,(uint32_t)data.b.bcnt);
 80233ee:	f002 070f 	and.w	r7, r2, #15
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
  uint32_t i;
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
 80233f2:	eb04 0187 	add.w	r1, r4, r7, lsl #2
    case XMC_USBD_GRXSTS_PKTSTS_GOUTNAK:
      break;
    case XMC_USBD_GRXSTS_PKTSTS_OUTCMPL:
      break;
    case XMC_USBD_GRXSTS_PKTSTS_OUTDATA:
      XMC_USBD_lReadFifo((uint32_t)data.b.epnum,(uint32_t)data.b.bcnt);
 80233f6:	f3c2 100a 	ubfx	r0, r2, #4, #11
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
  uint32_t i;
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
 80233fa:	f8d1 21c4 	ldr.w	r2, [r1, #452]	; 0x1c4
{
  XMC_USBD_EP_t * ep = &xmc_device.ep[ep_num];
  uint32_t word_count;
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
 80233fe:	f8d4 c1e0 	ldr.w	ip, [r4, #480]	; 0x1e0
  uint32_t i;
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
 8023402:	6812      	ldr	r2, [r2, #0]
{
  XMC_USBD_EP_t * ep = &xmc_device.ep[ep_num];
  uint32_t word_count;
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
 8023404:	4925      	ldr	r1, [pc, #148]	; (802349c <XMC_USBD_IRQHandler+0x8d4>)
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
  word_count = (byte_count >> 2U );
  temp_word_count = (word_count << 2U);
  /* Check if ep is enabled and has buffer */
  if (!data.b.usbactep)
 8023406:	0412      	lsls	r2, r2, #16
 8023408:	f57f af3e 	bpl.w	8023288 <XMC_USBD_IRQHandler+0x6c0>
  {
    /*Do Nothing*/
  }
  else if (ep->xferBuffer == NULL)
 802340c:	2234      	movs	r2, #52	; 0x34
 802340e:	fb02 1e07 	mla	lr, r2, r7, r1
 8023412:	f8de 1024 	ldr.w	r1, [lr, #36]	; 0x24
 8023416:	2900      	cmp	r1, #0
 8023418:	f43f af36 	beq.w	8023288 <XMC_USBD_IRQHandler+0x6c0>
	/*Do Nothing*/
  }
  else
  {
    /* store the data */
    for (i = 0U;i < word_count; i++)
 802341c:	ea5f 0890 	movs.w	r8, r0, lsr #2
 8023420:	d00f      	beq.n	8023442 <XMC_USBD_IRQHandler+0x87a>
 8023422:	ea4f 0888 	mov.w	r8, r8, lsl #2
 8023426:	2200      	movs	r2, #0
 8023428:	e001      	b.n	802342e <XMC_USBD_IRQHandler+0x866>
 802342a:	f8de 1024 	ldr.w	r1, [lr, #36]	; 0x24
    {
      *(((uint32_t*)ep->xferBuffer)+i) = *fifo;
 802342e:	f8dc 6000 	ldr.w	r6, [ip]
 8023432:	508e      	str	r6, [r1, r2]
 8023434:	3204      	adds	r2, #4
	/*Do Nothing*/
  }
  else
  {
    /* store the data */
    for (i = 0U;i < word_count; i++)
 8023436:	4542      	cmp	r2, r8
 8023438:	d1f7      	bne.n	802342a <XMC_USBD_IRQHandler+0x862>
 802343a:	2234      	movs	r2, #52	; 0x34
 802343c:	fb02 4207 	mla	r2, r2, r7, r4
 8023440:	6a51      	ldr	r1, [r2, #36]	; 0x24
    {
      *(((uint32_t*)ep->xferBuffer)+i) = *fifo;
    }
    /* space is not devidable by 4 */
    if (byte_count!=temp_word_count)
 8023442:	4540      	cmp	r0, r8
 8023444:	d01e      	beq.n	8023484 <XMC_USBD_IRQHandler+0x8bc>
    {
      temp_data = *fifo;
 8023446:	f8dc c000 	ldr.w	ip, [ip]
      for (i = 0U;(temp_word_count + i) < byte_count;i++)
 802344a:	d91b      	bls.n	8023484 <XMC_USBD_IRQHandler+0x8bc>
 802344c:	f04f 0e34 	mov.w	lr, #52	; 0x34
 8023450:	4643      	mov	r3, r8
 8023452:	fb0e 4e07 	mla	lr, lr, r7, r4
 8023456:	2600      	movs	r6, #0
      {
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
 8023458:	f04f 08ff 	mov.w	r8, #255	; 0xff
 802345c:	e001      	b.n	8023462 <XMC_USBD_IRQHandler+0x89a>
 802345e:	f8de 1024 	ldr.w	r1, [lr, #36]	; 0x24
 8023462:	fa08 f206 	lsl.w	r2, r8, r6
 8023466:	ea02 020c 	and.w	r2, r2, ip
 802346a:	40f2      	lsrs	r2, r6
 802346c:	54ca      	strb	r2, [r1, r3]
    }
    /* space is not devidable by 4 */
    if (byte_count!=temp_word_count)
    {
      temp_data = *fifo;
      for (i = 0U;(temp_word_count + i) < byte_count;i++)
 802346e:	3301      	adds	r3, #1
 8023470:	4298      	cmp	r0, r3
 8023472:	f106 0608 	add.w	r6, r6, #8
 8023476:	d1f2      	bne.n	802345e <XMC_USBD_IRQHandler+0x896>
 8023478:	2234      	movs	r2, #52	; 0x34
 802347a:	fb02 4207 	mla	r2, r2, r7, r4
 802347e:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
 8023482:	6a51      	ldr	r1, [r2, #36]	; 0x24
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
      }
    }

    /* save the amount of data */
    ep->xferCount += byte_count;
 8023484:	2234      	movs	r2, #52	; 0x34
 8023486:	fb02 4707 	mla	r7, r2, r7, r4
    ep->xferBuffer += byte_count;
 802348a:	4401      	add	r1, r0
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
      }
    }

    /* save the amount of data */
    ep->xferCount += byte_count;
 802348c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    ep->xferBuffer += byte_count;
 802348e:	6279      	str	r1, [r7, #36]	; 0x24
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
      }
    }

    /* save the amount of data */
    ep->xferCount += byte_count;
 8023490:	4402      	add	r2, r0
 8023492:	62fa      	str	r2, [r7, #44]	; 0x2c
 8023494:	e6f8      	b.n	8023288 <XMC_USBD_IRQHandler+0x6c0>
 8023496:	6a49      	ldr	r1, [r1, #36]	; 0x24
 8023498:	9f06      	ldr	r7, [sp, #24]
 802349a:	e781      	b.n	80233a0 <XMC_USBD_IRQHandler+0x7d8>
 802349c:	1fffa868 	.word	0x1fffa868

080234a0 <XMC_USBD_Disable>:

/**
 * Disables the USB0 module
 **/
void XMC_USBD_Disable(void) 
{
 80234a0:	b510      	push	{r4, lr}
  /* Clear Reset and power up */
  XMC_SCU_RESET_AssertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_USB0);
 80234a2:	4c05      	ldr	r4, [pc, #20]	; (80234b8 <XMC_USBD_Disable+0x18>)
 80234a4:	4620      	mov	r0, r4
 80234a6:	f7fd ffb7 	bl	8021418 <XMC_SCU_RESET_AssertPeripheralReset>
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_SCU_CLOCK_GatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USB0);
 80234aa:	4620      	mov	r0, r4
 80234ac:	f7fe f824 	bl	80214f8 <XMC_SCU_CLOCK_GatePeripheralClock>
#endif
  XMC_SCU_POWER_DisableUsb();
}
 80234b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  /* Clear Reset and power up */
  XMC_SCU_RESET_AssertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_USB0);
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_SCU_CLOCK_GatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USB0);
#endif
  XMC_SCU_POWER_DisableUsb();
 80234b4:	f7fe b872 	b.w	802159c <XMC_SCU_POWER_DisableUsb>
 80234b8:	20000080 	.word	0x20000080

080234bc <XMC_VADC_GLOBAL_Init>:
}


/* API to initialize global resources */
void XMC_VADC_GLOBAL_Init(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_GLOBAL_CONFIG_t *config)
{
 80234bc:	b538      	push	{r3, r4, r5, lr}
 80234be:	460d      	mov	r5, r1
 80234c0:	4604      	mov	r4, r0
#if defined (COMPARATOR)
  COMPARATOR->ORCCTRL = (uint32_t)0xFF;
#endif

#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_VADC);
 80234c2:	2001      	movs	r0, #1
 80234c4:	f7fe f824 	bl	8021510 <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif

#if defined(PERIPHERAL_RESET_SUPPORTED)
  /* Reset the Hardware */
  XMC_SCU_RESET_DeassertPeripheralReset((XMC_SCU_PERIPHERAL_RESET_t)XMC_SCU_PERIPHERAL_RESET_VADC );
 80234c8:	2001      	movs	r0, #1
 80234ca:	f7fd ffb1 	bl	8021430 <XMC_SCU_RESET_DeassertPeripheralReset>
  XMC_ASSERT("XMC_VADC_GLOBAL_Init:Wrong Module Pointer", (global_ptr == VADC))

  /* Enable the VADC module*/
  XMC_VADC_GLOBAL_EnableModule();

  global_ptr->CLC = (uint32_t)(config->clc);
 80234ce:	696b      	ldr	r3, [r5, #20]
 80234d0:	6023      	str	r3, [r4, #0]

  /* Clock configuration */

#if (XMC_VADC_GROUP_AVAILABLE == 1U)
  global_ptr->GLOBCFG  = (uint32_t)(config->clock_config.globcfg | (uint32_t)(VADC_GLOBCFG_DIVWC_Msk));
 80234d2:	686b      	ldr	r3, [r5, #4]
 80234d4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80234d8:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
#endif

  /* ICLASS-0 configuration */
  global_ptr->GLOBICLASS[0] = (uint32_t)(config->class0.globiclass);
 80234dc:	68ab      	ldr	r3, [r5, #8]
 80234de:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0

  /* ICLASS-1 configuration */
  global_ptr->GLOBICLASS[1] = (uint32_t)(config->class1.globiclass);
 80234e2:	68eb      	ldr	r3, [r5, #12]
 80234e4:	f8c4 30a4 	str.w	r3, [r4, #164]	; 0xa4


  /*Result generation related configuration */
  global_ptr->GLOBRCR = (uint32_t)(config->globrcr);
 80234e8:	692b      	ldr	r3, [r5, #16]
 80234ea:	f8c4 3280 	str.w	r3, [r4, #640]	; 0x280

#if (XMC_VADC_BOUNDARY_AVAILABLE == 1U)

  /* Boundaries */
  global_ptr->GLOBBOUND = (uint32_t)(config->globbound);
 80234ee:	682b      	ldr	r3, [r5, #0]
 80234f0:	f8c4 30b8 	str.w	r3, [r4, #184]	; 0xb8
 80234f4:	bd38      	pop	{r3, r4, r5, pc}
 80234f6:	bf00      	nop

080234f8 <XMC_VADC_GLOBAL_InputClassInit>:
  XMC_ASSERT("XMC_VADC_GLOBAL_InputClassInit:Wrong Module Pointer", (global_ptr == VADC))
  XMC_ASSERT("XMC_VADC_GLOBAL_InputClassInit:Wrong Conversion Type", ((conv_type) <= XMC_VADC_GROUP_CONV_EMUX))
  XMC_ASSERT("XMC_VADC_GLOBAL_InputClassInit:Wrong ICLASS set number", (set_num < XMC_VADC_MAX_ICLASS_SET))

#if(XMC_VADC_EMUX_AVAILABLE == 1U)
  if (conv_type == XMC_VADC_GROUP_CONV_STD )
 80234f8:	b12a      	cbz	r2, 8023506 <XMC_VADC_GLOBAL_InputClassInit+0xe>
                                      (uint32_t)(VADC_GLOBICLASS_CMS_Msk | VADC_GLOBICLASS_STCS_Msk);
#if(XMC_VADC_EMUX_AVAILABLE == 1U)
  }
  else
  {
    global_ptr->GLOBICLASS[set_num] = config.globiclass & (uint32_t)(VADC_GLOBICLASS_CME_Msk | VADC_GLOBICLASS_STCE_Msk);
 80234fa:	4a06      	ldr	r2, [pc, #24]	; (8023514 <XMC_VADC_GLOBAL_InputClassInit+0x1c>)
 80234fc:	3328      	adds	r3, #40	; 0x28
 80234fe:	400a      	ands	r2, r1
 8023500:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
 8023504:	4770      	bx	lr

#if(XMC_VADC_EMUX_AVAILABLE == 1U)
  if (conv_type == XMC_VADC_GROUP_CONV_STD )
  {
#endif
    global_ptr->GLOBICLASS[set_num] = config.globiclass &
 8023506:	3328      	adds	r3, #40	; 0x28
 8023508:	f240 721f 	movw	r2, #1823	; 0x71f
 802350c:	400a      	ands	r2, r1
 802350e:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
 8023512:	4770      	bx	lr
 8023514:	071f0000 	.word	0x071f0000

08023518 <XMC_VADC_GLOBAL_StartupCalibration>:
  VADC_G_TypeDef *group_ptr;
#endif
  
  XMC_ASSERT("XMC_VADC_GLOBAL_StartupCalibration:Wrong Module Pointer", (global_ptr == VADC))

  global_ptr->GLOBCFG |= (uint32_t)VADC_GLOBCFG_SUCAL_Msk;
 8023518:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
 802351c:	490c      	ldr	r1, [pc, #48]	; (8023550 <XMC_VADC_GLOBAL_StartupCalibration+0x38>)
 802351e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8023522:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
 8023526:	f101 0010 	add.w	r0, r1, #16

#if (XMC_VADC_GROUP_AVAILABLE == 1U)
  /* Loop until all active groups finish calibration */
  for(i=0U; i<XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
  {
    group_ptr = g_xmc_vadc_group_array[i];
 802352a:	f851 2b04 	ldr.w	r2, [r1], #4
    if ( (group_ptr->ARBCFG) & (uint32_t)VADC_G_ARBCFG_ANONS_Msk)
 802352e:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 8023532:	f413 3f40 	tst.w	r3, #196608	; 0x30000
 8023536:	d102      	bne.n	802353e <XMC_VADC_GLOBAL_StartupCalibration+0x26>

  global_ptr->GLOBCFG |= (uint32_t)VADC_GLOBCFG_SUCAL_Msk;

#if (XMC_VADC_GROUP_AVAILABLE == 1U)
  /* Loop until all active groups finish calibration */
  for(i=0U; i<XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 8023538:	4281      	cmp	r1, r0
 802353a:	d1f6      	bne.n	802352a <XMC_VADC_GLOBAL_StartupCalibration+0x12>
         XMC_VADC_SHS_START_UP_CAL_ACTIVE )
  {
    /* NOP */
  }
#endif
}
 802353c:	4770      	bx	lr
  {
    group_ptr = g_xmc_vadc_group_array[i];
    if ( (group_ptr->ARBCFG) & (uint32_t)VADC_G_ARBCFG_ANONS_Msk)
    {
      /* This group is active. Loop until it finishes calibration */
      while((group_ptr->ARBCFG) & (uint32_t)VADC_G_ARBCFG_CAL_Msk)
 802353e:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 8023542:	00db      	lsls	r3, r3, #3
 8023544:	d5f8      	bpl.n	8023538 <XMC_VADC_GLOBAL_StartupCalibration+0x20>
 8023546:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 802354a:	00db      	lsls	r3, r3, #3
 802354c:	d4f7      	bmi.n	802353e <XMC_VADC_GLOBAL_StartupCalibration+0x26>
 802354e:	e7f3      	b.n	8023538 <XMC_VADC_GLOBAL_StartupCalibration+0x20>
 8023550:	0802acac 	.word	0x0802acac

08023554 <XMC_VADC_GROUP_Init>:
}

/* API to initialize an instance of group of VADC hardware */
#if (XMC_VADC_GROUP_AVAILABLE == 1U)  
void XMC_VADC_GROUP_Init( XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_GROUP_CONFIG_t *config)
{
 8023554:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023558:	794b      	ldrb	r3, [r1, #5]
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
  }

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];
 802355a:	f8d0 50a0 	ldr.w	r5, [r0, #160]	; 0xa0
 802355e:	f891 a004 	ldrb.w	sl, [r1, #4]
 8023562:	78ce      	ldrb	r6, [r1, #3]
 8023564:	7acc      	ldrb	r4, [r1, #11]
 8023566:	f891 b007 	ldrb.w	fp, [r1, #7]
 802356a:	f891 9006 	ldrb.w	r9, [r1, #6]
 802356e:	f891 8009 	ldrb.w	r8, [r1, #9]
 8023572:	7a0a      	ldrb	r2, [r1, #8]
 8023574:	f891 c00a 	ldrb.w	ip, [r1, #10]
 8023578:	f8b1 e002 	ldrh.w	lr, [r1, #2]
 802357c:	780f      	ldrb	r7, [r1, #0]

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
 802357e:	f425 65e0 	bic.w	r5, r5, #1792	; 0x700
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 8023582:	f003 0307 	and.w	r3, r3, #7
 8023586:	ea45 2303 	orr.w	r3, r5, r3, lsl #8
  conv_class &= ~(sample_time_mask);
 802358a:	f023 031f 	bic.w	r3, r3, #31
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CMS_Pos;
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CMS_Msk;
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCS_Pos;
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCS_Msk;
    sample_time      = (uint32_t) config.sample_time_std_conv;
 802358e:	f00a 0a1f 	and.w	sl, sl, #31

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
  conv_class &= ~(sample_time_mask);
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
 8023592:	ea43 050a 	orr.w	r5, r3, sl
  group_ptr->ICLASS[set_num] = conv_class;
 8023596:	f8c0 50a0 	str.w	r5, [r0, #160]	; 0xa0
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
  }

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];
 802359a:	f8d0 30a0 	ldr.w	r3, [r0, #160]	; 0xa0

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 802359e:	f00b 0b07 	and.w	fp, fp, #7

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
 80235a2:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 80235a6:	ea43 630b 	orr.w	r3, r3, fp, lsl #24
  conv_class &= ~(sample_time_mask);
 80235aa:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CME_Pos;
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CME_Msk;
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCE_Pos;
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCE_Msk;
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
 80235ae:	f009 051f 	and.w	r5, r9, #31

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
  conv_class &= ~(sample_time_mask);
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
 80235b2:	ea43 4505 	orr.w	r5, r3, r5, lsl #16
  group_ptr->ICLASS[set_num] = conv_class;
 80235b6:	f8c0 50a0 	str.w	r5, [r0, #160]	; 0xa0
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
  }

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];
 80235ba:	f8d0 30a4 	ldr.w	r3, [r0, #164]	; 0xa4

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 80235be:	f008 0807 	and.w	r8, r8, #7

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
 80235c2:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 80235c6:	ea43 2308 	orr.w	r3, r3, r8, lsl #8
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CMS_Pos;
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CMS_Msk;
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCS_Pos;
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCS_Msk;
    sample_time      = (uint32_t) config.sample_time_std_conv;
 80235ca:	f002 021f 	and.w	r2, r2, #31
  conv_class  = group_ptr->ICLASS[set_num];

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
  conv_class &= ~(sample_time_mask);
 80235ce:	f023 031f 	bic.w	r3, r3, #31
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
 80235d2:	4313      	orrs	r3, r2
  group_ptr->ICLASS[set_num] = conv_class;
 80235d4:	f8c0 30a4 	str.w	r3, [r0, #164]	; 0xa4
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
  }

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];
 80235d8:	f8d0 50a4 	ldr.w	r5, [r0, #164]	; 0xa4

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 80235dc:	f004 0207 	and.w	r2, r4, #7

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
 80235e0:	f025 64e0 	bic.w	r4, r5, #117440512	; 0x7000000
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 80235e4:	ea44 6402 	orr.w	r4, r4, r2, lsl #24
  conv_class &= ~(sample_time_mask);
 80235e8:	f424 14f8 	bic.w	r4, r4, #2031616	; 0x1f0000
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CME_Pos;
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CME_Msk;
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCE_Pos;
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCE_Msk;
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
 80235ec:	f00c 021f 	and.w	r2, ip, #31

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
  conv_class &= ~(sample_time_mask);
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
 80235f0:	ea44 4202 	orr.w	r2, r4, r2, lsl #16
  group_ptr->ICLASS[set_num] = conv_class;
 80235f4:	f8c0 20a4 	str.w	r2, [r0, #164]	; 0xa4
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class0, XMC_VADC_GROUP_CONV_STD, 0U);
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class0, XMC_VADC_GROUP_CONV_EMUX, 0U);
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class1, XMC_VADC_GROUP_CONV_STD, 1U);
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class1, XMC_VADC_GROUP_CONV_EMUX, 1U);

  group_ptr->ARBCFG = config->g_arbcfg;
 80235f8:	690b      	ldr	r3, [r1, #16]
 80235fa:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
  uint32_t   emux_config;

  XMC_ASSERT("XMC_VADC_GROUP_ExternalMuxControlInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  emux_config = ((uint32_t)emux_cfg.starting_external_channel << (uint32_t)VADC_G_EMUXCTR_EMUXSET_Pos) |
              ((uint32_t)emux_cfg.connected_channel << (uint32_t)VADC_G_EMUXCTR_EMUXCH_Pos);
 80235fe:	f3ce 0e09 	ubfx	lr, lr, #0, #10
{
  uint32_t   emux_config;

  XMC_ASSERT("XMC_VADC_GROUP_ExternalMuxControlInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  emux_config = ((uint32_t)emux_cfg.starting_external_channel << (uint32_t)VADC_G_EMUXCTR_EMUXSET_Pos) |
 8023602:	f007 0707 	and.w	r7, r7, #7

  group_ptr->BOUND = config->g_bound;
 8023606:	68cb      	ldr	r3, [r1, #12]
 8023608:	f8c0 30b8 	str.w	r3, [r0, #184]	; 0xb8
 802360c:	ea47 470e 	orr.w	r7, r7, lr, lsl #16
              ((uint32_t)emux_cfg.connected_channel << (uint32_t)VADC_G_EMUXCTR_EMUXCH_Pos);

  group_ptr->EMUXCTR  = emux_config;
 8023610:	f8c0 71f0 	str.w	r7, [r0, #496]	; 0x1f0
                ((uint32_t)emux_cfg.stce_usage << (uint32_t)VADC_G_EMUXCTR_EMXST_Pos);

#if (XMC_VADC_EMUX_CH_SEL_STYLE == 1U)
  emux_config |= ((uint32_t)emux_cfg.emux_channel_select_style << (uint32_t)VADC_G_EMUXCTR_EMXCSS_Pos);
#endif
  group_ptr->EMUXCTR  |= (emux_config | ((uint32_t)VADC_G_EMUXCTR_EMXWC_Msk)) ;
 8023614:	f8d0 21f0 	ldr.w	r2, [r0, #496]	; 0x1f0
 8023618:	f3c6 1300 	ubfx	r3, r6, #4, #1
 802361c:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8023620:	ea42 7203 	orr.w	r2, r2, r3, lsl #28
 8023624:	f3c6 0381 	ubfx	r3, r6, #2, #2
 8023628:	ea42 6283 	orr.w	r2, r2, r3, lsl #26
 802362c:	f3c6 1340 	ubfx	r3, r6, #5, #1
 8023630:	ea42 7243 	orr.w	r2, r2, r3, lsl #29
 8023634:	f3c6 1380 	ubfx	r3, r6, #6, #1
 8023638:	ea42 7383 	orr.w	r3, r2, r3, lsl #30
 802363c:	f8c0 31f0 	str.w	r3, [r0, #496]	; 0x1f0
 8023640:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08023644 <XMC_VADC_GROUP_InputClassInit>:
}

/* API to program conversion characteristics */
void XMC_VADC_GROUP_InputClassInit(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_GROUP_CLASS_t config,
                                          const XMC_VADC_GROUP_CONV_t conv_type, const uint32_t set_num)
{
 8023644:	b4f0      	push	{r4, r5, r6, r7}

  /* 
   * Obtain the mask and position macros of the parameters based on what is being requested - Standard channels vs
   * external mux channels.
   */
  if (XMC_VADC_GROUP_CONV_STD == conv_type)
 8023646:	b1ba      	cbz	r2, 8023678 <XMC_VADC_GROUP_InputClassInit+0x34>
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CME_Pos;
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CME_Msk;
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCE_Pos;
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCE_Msk;
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
 8023648:	f3c1 4204 	ubfx	r2, r1, #16, #5
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
 802364c:	2510      	movs	r5, #16
 802364e:	f3c1 6102 	ubfx	r1, r1, #24, #3
 8023652:	f46f 16f8 	mvn.w	r6, #2031616	; 0x1f0000
 8023656:	2418      	movs	r4, #24
 8023658:	f06f 67e0 	mvn.w	r7, #117440512	; 0x7000000
 802365c:	eb00 0383 	add.w	r3, r0, r3, lsl #2
  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 8023660:	40a1      	lsls	r1, r4
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
  }

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];
 8023662:	f8d3 40a0 	ldr.w	r4, [r3, #160]	; 0xa0

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
 8023666:	403c      	ands	r4, r7
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 8023668:	4321      	orrs	r1, r4
  conv_class &= ~(sample_time_mask);
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
 802366a:	40aa      	lsls	r2, r5
  conv_class  = group_ptr->ICLASS[set_num];

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
  conv_class &= ~(sample_time_mask);
 802366c:	4031      	ands	r1, r6
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
 802366e:	4311      	orrs	r1, r2
  group_ptr->ICLASS[set_num] = conv_class;
 8023670:	f8c3 10a0 	str.w	r1, [r3, #160]	; 0xa0
}
 8023674:	bcf0      	pop	{r4, r5, r6, r7}
 8023676:	4770      	bx	lr
 8023678:	4615      	mov	r5, r2
 802367a:	f06f 061f 	mvn.w	r6, #31
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CMS_Pos;
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CMS_Msk;
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCS_Pos;
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCS_Msk;
    sample_time      = (uint32_t) config.sample_time_std_conv;
 802367e:	f001 021f 	and.w	r2, r1, #31
 8023682:	2408      	movs	r4, #8
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_standard;
 8023684:	f3c1 2102 	ubfx	r1, r1, #8, #3
 8023688:	f46f 67e0 	mvn.w	r7, #1792	; 0x700
 802368c:	e7e6      	b.n	802365c <XMC_VADC_GROUP_InputClassInit+0x18>
 802368e:	bf00      	nop

08023690 <XMC_VADC_GROUP_SetPowerMode>:
  uint32_t arbcfg;

  XMC_ASSERT("XMC_VADC_GROUP_SetPowerMode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_SetPowerMode:Wrong Power Mode", (power_mode <= XMC_VADC_GROUP_POWERMODE_NORMAL))

  arbcfg = group_ptr->ARBCFG;
 8023690:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80

  arbcfg &= ~((uint32_t)VADC_G_ARBCFG_ANONC_Msk);
 8023694:	f023 0303 	bic.w	r3, r3, #3
  arbcfg |= (uint32_t)power_mode;
 8023698:	4319      	orrs	r1, r3

  group_ptr->ARBCFG = arbcfg;
 802369a:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
 802369e:	4770      	bx	lr

080236a0 <XMC_VADC_GROUP_SetSyncSlave>:
    master_grp = master_grp + 1U;
  }
  #endif
  
  /* Program SYNCTR */
  synctr = group_ptr->SYNCTR;
 80236a0:	f8d0 30c0 	ldr.w	r3, [r0, #192]	; 0xc0
  XMC_ASSERT("XMC_VADC_GROUP_SetSyncSlave:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  
  #if (XMC_VADC_MULTIPLE_SLAVEGROUPS == 1U )

  /* Determine the coding of SYNCTR */
  if (slave_grp > master_grp)
 80236a4:	428a      	cmp	r2, r1
  {
    master_grp = master_grp + 1U;
 80236a6:	bf88      	it	hi
 80236a8:	3101      	addhi	r1, #1
  }
  #endif
  
  /* Program SYNCTR */
  synctr = group_ptr->SYNCTR;
  synctr   &= ~((uint32_t)VADC_G_SYNCTR_STSEL_Msk);
 80236aa:	f023 0303 	bic.w	r3, r3, #3
  synctr   |= master_grp;
 80236ae:	4319      	orrs	r1, r3
  group_ptr->SYNCTR = synctr;
 80236b0:	f8c0 10c0 	str.w	r1, [r0, #192]	; 0xc0
 80236b4:	4770      	bx	lr
 80236b6:	bf00      	nop

080236b8 <XMC_VADC_GROUP_SetSyncMaster>:
{
  uint32_t synctr;

  XMC_ASSERT("XMC_VADC_GROUP_SetSyncMaster:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  synctr = group_ptr->SYNCTR;
 80236b8:	f8d0 30c0 	ldr.w	r3, [r0, #192]	; 0xc0
  synctr   &= ~((uint32_t)VADC_G_SYNCTR_STSEL_Msk);
 80236bc:	f023 0303 	bic.w	r3, r3, #3
  group_ptr->SYNCTR = synctr;
 80236c0:	f8c0 30c0 	str.w	r3, [r0, #192]	; 0xc0
 80236c4:	4770      	bx	lr
 80236c6:	bf00      	nop

080236c8 <XMC_VADC_GROUP_CheckSlaveReadiness>:
  XMC_ASSERT("XMC_VADC_GROUP_CheckSlaveReadiness:Wrong Slave group", ((slave_group >= 0) && (slave_group <= (XMC_VADC_MAXIMUM_NUM_GROUPS - 1))))

  master_grp_num =0;
  for(i=0; i<XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
  {
    if(g_xmc_vadc_group_array[i] == group_ptr)
 80236c8:	4b0e      	ldr	r3, [pc, #56]	; (8023704 <XMC_VADC_GROUP_CheckSlaveReadiness+0x3c>)
 80236ca:	4298      	cmp	r0, r3
 80236cc:	d010      	beq.n	80236f0 <XMC_VADC_GROUP_CheckSlaveReadiness+0x28>
 80236ce:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80236d2:	4298      	cmp	r0, r3
 80236d4:	d011      	beq.n	80236fa <XMC_VADC_GROUP_CheckSlaveReadiness+0x32>
 80236d6:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80236da:	4298      	cmp	r0, r3
 80236dc:	d00f      	beq.n	80236fe <XMC_VADC_GROUP_CheckSlaveReadiness+0x36>

  if(slave_group < master_grp_num)
  {
    slave_group++;
  }
  group_ptr->SYNCTR |= (1U << (slave_group + XMC_VADC_SYNCTR_START_LOCATION));
 80236de:	f8d0 20c0 	ldr.w	r2, [r0, #192]	; 0xc0
 80236e2:	3103      	adds	r1, #3
 80236e4:	2301      	movs	r3, #1
 80236e6:	408b      	lsls	r3, r1
 80236e8:	4313      	orrs	r3, r2
 80236ea:	f8c0 30c0 	str.w	r3, [r0, #192]	; 0xc0
 80236ee:	4770      	bx	lr
  uint32_t i,master_grp_num;
  XMC_ASSERT("XMC_VADC_GROUP_CheckSlaveReadiness:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_CheckSlaveReadiness:Wrong Slave group", ((slave_group >= 0) && (slave_group <= (XMC_VADC_MAXIMUM_NUM_GROUPS - 1))))

  master_grp_num =0;
  for(i=0; i<XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 80236f0:	2301      	movs	r3, #1
      master_grp_num = i;
    }
  }


  if(slave_group < master_grp_num)
 80236f2:	4299      	cmp	r1, r3
  {
    slave_group++;
 80236f4:	bf38      	it	cc
 80236f6:	3101      	addcc	r1, #1
 80236f8:	e7f1      	b.n	80236de <XMC_VADC_GROUP_CheckSlaveReadiness+0x16>
  uint32_t i,master_grp_num;
  XMC_ASSERT("XMC_VADC_GROUP_CheckSlaveReadiness:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_CheckSlaveReadiness:Wrong Slave group", ((slave_group >= 0) && (slave_group <= (XMC_VADC_MAXIMUM_NUM_GROUPS - 1))))

  master_grp_num =0;
  for(i=0; i<XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 80236fa:	2302      	movs	r3, #2
 80236fc:	e7f9      	b.n	80236f2 <XMC_VADC_GROUP_CheckSlaveReadiness+0x2a>
 80236fe:	2303      	movs	r3, #3
 8023700:	e7f7      	b.n	80236f2 <XMC_VADC_GROUP_CheckSlaveReadiness+0x2a>
 8023702:	bf00      	nop
 8023704:	40004800 	.word	0x40004800

08023708 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>:
                                            uint32_t eval_origin_group)
{
  XMC_ASSERT("XMC_VADC_GROUP_SetSyncSlaveReadySignal:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_SetSyncSlaveReadySignal:Wrong Group numbers", (eval_waiting_group == eval_origin_group ))

  if(eval_origin_group < eval_waiting_group)
 8023708:	428a      	cmp	r2, r1
  {
	  eval_origin_group++;
 802370a:	bf38      	it	cc
 802370c:	3201      	addcc	r2, #1
  }
  group_ptr->SYNCTR |= (1U << (eval_origin_group + XMC_VADC_SYNCTR_START_LOCATION));
 802370e:	f8d0 10c0 	ldr.w	r1, [r0, #192]	; 0xc0
 8023712:	3203      	adds	r2, #3
 8023714:	2301      	movs	r3, #1
 8023716:	4093      	lsls	r3, r2
 8023718:	430b      	orrs	r3, r1
 802371a:	f8c0 30c0 	str.w	r3, [r0, #192]	; 0xc0
 802371e:	4770      	bx	lr

08023720 <XMC_VADC_GROUP_ScanInit>:
 *  XMC_VADC_GROUP_ScanEnableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_ScanDisableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanDisableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->ARBPR &= ~((uint32_t)VADC_G_ARBPR_ASEN1_Msk);
 8023720:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
  /* Read in the existing contents of arbitration priority register */
  reg = group_ptr->ARBPR;

  /* Program the priority of the request source */
  reg &= ~(uint32_t)VADC_G_ARBPR_PRIO1_Msk;
  reg |= (uint32_t)((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO1_Pos);
 8023724:	780a      	ldrb	r2, [r1, #0]
 8023726:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 802372a:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84

  /* All configurations have to be performed with the arbitration slot disabled */
  XMC_VADC_GROUP_ScanDisableArbitrationSlot(group_ptr);
  
  /* Read in the existing contents of arbitration priority register */
  reg = group_ptr->ARBPR;
 802372e:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
#endif

#if (XMC_VADC_GSCAN_AVAILABLE == 1U)   
/* API to initialize the group scan hardware of a kernel */
void XMC_VADC_GROUP_ScanInit(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_SCAN_CONFIG_t *config)
{
 8023732:	b410      	push	{r4}
  
  /* Read in the existing contents of arbitration priority register */
  reg = group_ptr->ARBPR;

  /* Program the priority of the request source */
  reg &= ~(uint32_t)VADC_G_ARBPR_PRIO1_Msk;
 8023734:	f023 0330 	bic.w	r3, r3, #48	; 0x30
  reg |= (uint32_t)((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO1_Pos);
 8023738:	f3c2 0481 	ubfx	r4, r2, #2, #2
  
  /* Program the start mode */
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)(config->conv_start_mode))
 802373c:	f012 0203 	ands.w	r2, r2, #3
  /* Read in the existing contents of arbitration priority register */
  reg = group_ptr->ARBPR;

  /* Program the priority of the request source */
  reg &= ~(uint32_t)VADC_G_ARBPR_PRIO1_Msk;
  reg |= (uint32_t)((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO1_Pos);
 8023740:	ea43 1304 	orr.w	r3, r3, r4, lsl #4
  
  /* Program the start mode */
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)(config->conv_start_mode))
 8023744:	d020      	beq.n	8023788 <XMC_VADC_GROUP_ScanInit+0x68>
  {
    reg |= (uint32_t)(VADC_G_ARBPR_CSM1_Msk);
 8023746:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  }

  group_ptr->ARBPR = reg;
 802374a:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84

  group_ptr->ASCTRL = (uint32_t)(config->asctrl |(VADC_G_ASCTRL_XTWC_Msk) |(VADC_G_ASCTRL_GTWC_Msk) |
 802374e:	684b      	ldr	r3, [r1, #4]
 8023750:	f043 2380 	orr.w	r3, r3, #2147516416	; 0x80008000
 8023754:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8023758:	f8c0 3120 	str.w	r3, [r0, #288]	; 0x120
                                                 (VADC_G_ASCTRL_TMWC_Msk));

  group_ptr->ASMR  = (uint32_t)((config->asmr)| (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_G_ASMR_ENGT_Pos));
 802375c:	688b      	ldr	r3, [r1, #8]
  
  if (XMC_VADC_STARTMODE_CNR == (XMC_VADC_STARTMODE_t)(config->conv_start_mode))
 802375e:	2a02      	cmp	r2, #2
  group_ptr->ARBPR = reg;

  group_ptr->ASCTRL = (uint32_t)(config->asctrl |(VADC_G_ASCTRL_XTWC_Msk) |(VADC_G_ASCTRL_GTWC_Msk) |
                                                 (VADC_G_ASCTRL_TMWC_Msk));

  group_ptr->ASMR  = (uint32_t)((config->asmr)| (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_G_ASMR_ENGT_Pos));
 8023760:	f043 0301 	orr.w	r3, r3, #1
 8023764:	f8c0 3124 	str.w	r3, [r0, #292]	; 0x124
  
  if (XMC_VADC_STARTMODE_CNR == (XMC_VADC_STARTMODE_t)(config->conv_start_mode))
 8023768:	d105      	bne.n	8023776 <XMC_VADC_GROUP_ScanInit+0x56>
  {
    group_ptr->ASMR |= (uint32_t)VADC_G_ASMR_RPTDIS_Msk;
 802376a:	f8d0 3124 	ldr.w	r3, [r0, #292]	; 0x124
 802376e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8023772:	f8c0 3124 	str.w	r3, [r0, #292]	; 0x124
 *  XMC_VADC_GROUP_ScanDisableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_ScanEnableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanEnableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->ARBPR |= (uint32_t)VADC_G_ARBPR_ASEN1_Msk;
 8023776:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
  }
  
  /* Enable arbitration slot now */
  XMC_VADC_GROUP_ScanEnableArbitrationSlot(group_ptr);
  
}
 802377a:	f85d 4b04 	ldr.w	r4, [sp], #4
 802377e:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8023782:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
 8023786:	4770      	bx	lr
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)(config->conv_start_mode))
  {
    reg |= (uint32_t)(VADC_G_ARBPR_CSM1_Msk);
  }

  group_ptr->ARBPR = reg;
 8023788:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84

  group_ptr->ASCTRL = (uint32_t)(config->asctrl |(VADC_G_ASCTRL_XTWC_Msk) |(VADC_G_ASCTRL_GTWC_Msk) |
 802378c:	684b      	ldr	r3, [r1, #4]
 802378e:	f043 2380 	orr.w	r3, r3, #2147516416	; 0x80008000
 8023792:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8023796:	f8c0 3120 	str.w	r3, [r0, #288]	; 0x120
                                                 (VADC_G_ASCTRL_TMWC_Msk));

  group_ptr->ASMR  = (uint32_t)((config->asmr)| (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_G_ASMR_ENGT_Pos));
 802379a:	688b      	ldr	r3, [r1, #8]
 802379c:	f043 0301 	orr.w	r3, r3, #1
 80237a0:	f8c0 3124 	str.w	r3, [r0, #292]	; 0x124
 80237a4:	e7e7      	b.n	8023776 <XMC_VADC_GROUP_ScanInit+0x56>
 80237a6:	bf00      	nop

080237a8 <XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode>:

/* API to select a service request line (NVIC Node) for request source event */
void XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_SR_t sr)
{
  uint32_t sevnp;
  sevnp = group_ptr->SEVNP;
 80237a8:	f8d0 31c0 	ldr.w	r3, [r0, #448]	; 0x1c0

  XMC_ASSERT("XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode:Wrong Service Request", ((sr)  <= XMC_VADC_SR_SHARED_SR3))

  sevnp &= ~((uint32_t)VADC_G_SEVNP_SEV1NP_Msk);
 80237ac:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
  sevnp |= (uint32_t)((uint32_t)sr << VADC_G_SEVNP_SEV1NP_Pos);
 80237b0:	ea43 1101 	orr.w	r1, r3, r1, lsl #4

  group_ptr->SEVNP = sevnp;
 80237b4:	f8c0 11c0 	str.w	r1, [r0, #448]	; 0x1c0
 80237b8:	4770      	bx	lr
 80237ba:	bf00      	nop

080237bc <XMC_VADC_GROUP_QueueInit>:
 *  XMC_VADC_GROUP_QueueEnableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_QueueDisableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueDisableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr));
  group_ptr->ARBPR &= ~((uint32_t)VADC_G_ARBPR_ASEN0_Msk);
 80237bc:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
  
  reg = group_ptr->ARBPR;

  /* Request Source priority */
  reg &= ~((uint32_t)VADC_G_ARBPR_PRIO0_Msk);
  reg |= (uint32_t) ((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO0_Pos);
 80237c0:	780a      	ldrb	r2, [r1, #0]
 80237c2:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 80237c6:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  XMC_ASSERT("XMC_VADC_GROUP_QueueInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  /* Disable arbitration slot of the queue request source */
  XMC_VADC_GROUP_QueueDisableArbitrationSlot(group_ptr);
  
  reg = group_ptr->ARBPR;
 80237ca:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
}

#if (XMC_VADC_QUEUE_AVAILABLE == 1U)  
/* API to initialize queue request source */
void XMC_VADC_GROUP_QueueInit(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_QUEUE_CONFIG_t *config)
{
 80237ce:	b410      	push	{r4}
  XMC_VADC_GROUP_QueueDisableArbitrationSlot(group_ptr);
  
  reg = group_ptr->ARBPR;

  /* Request Source priority */
  reg &= ~((uint32_t)VADC_G_ARBPR_PRIO0_Msk);
 80237d0:	f023 0303 	bic.w	r3, r3, #3
  reg |= (uint32_t) ((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO0_Pos);
 80237d4:	f3c2 0481 	ubfx	r4, r2, #2, #2

  /* Conversion Start mode */
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)config->conv_start_mode)
 80237d8:	f012 0203 	ands.w	r2, r2, #3
  
  reg = group_ptr->ARBPR;

  /* Request Source priority */
  reg &= ~((uint32_t)VADC_G_ARBPR_PRIO0_Msk);
  reg |= (uint32_t) ((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO0_Pos);
 80237dc:	ea43 0304 	orr.w	r3, r3, r4

  /* Conversion Start mode */
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)config->conv_start_mode)
 80237e0:	d020      	beq.n	8023824 <XMC_VADC_GROUP_QueueInit+0x68>
  {
    reg |= (uint32_t)(VADC_G_ARBPR_CSM0_Msk);
 80237e2:	f043 0308 	orr.w	r3, r3, #8
  }

  group_ptr->ARBPR = reg;
 80237e6:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84


  group_ptr->QCTRL0 = (uint32_t)((config->qctrl0)|(uint32_t)(VADC_G_QCTRL0_XTWC_Msk)|
 80237ea:	684b      	ldr	r3, [r1, #4]
 80237ec:	f043 2380 	orr.w	r3, r3, #2147516416	; 0x80008000
 80237f0:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 80237f4:	f8c0 3100 	str.w	r3, [r0, #256]	; 0x100
                                                    (uint32_t)(VADC_G_QCTRL0_TMWC_Msk)|
                                                    (uint32_t)(VADC_G_QCTRL0_GTWC_Msk));

  /* Gating mode */
  group_ptr->QMR0 = ((uint32_t)(config->qmr0) | (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_G_QMR0_ENGT_Pos));
 80237f8:	688b      	ldr	r3, [r1, #8]

  if (XMC_VADC_STARTMODE_CNR == (XMC_VADC_STARTMODE_t)(config->conv_start_mode) )
 80237fa:	2a02      	cmp	r2, #2
  group_ptr->QCTRL0 = (uint32_t)((config->qctrl0)|(uint32_t)(VADC_G_QCTRL0_XTWC_Msk)|
                                                    (uint32_t)(VADC_G_QCTRL0_TMWC_Msk)|
                                                    (uint32_t)(VADC_G_QCTRL0_GTWC_Msk));

  /* Gating mode */
  group_ptr->QMR0 = ((uint32_t)(config->qmr0) | (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_G_QMR0_ENGT_Pos));
 80237fc:	f043 0301 	orr.w	r3, r3, #1
 8023800:	f8c0 3104 	str.w	r3, [r0, #260]	; 0x104

  if (XMC_VADC_STARTMODE_CNR == (XMC_VADC_STARTMODE_t)(config->conv_start_mode) )
 8023804:	d105      	bne.n	8023812 <XMC_VADC_GROUP_QueueInit+0x56>
  {
    group_ptr->QMR0 |= (uint32_t)((uint32_t)1 << VADC_G_QMR0_RPTDIS_Pos);
 8023806:	f8d0 3104 	ldr.w	r3, [r0, #260]	; 0x104
 802380a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 802380e:	f8c0 3104 	str.w	r3, [r0, #260]	; 0x104
 *  XMC_VADC_GROUP_QueueDisableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_QueueEnableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueEnableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr));
  group_ptr->ARBPR |= (uint32_t)((uint32_t)1 << VADC_G_ARBPR_ASEN0_Pos);
 8023812:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
  }
  /* Enable arbitration slot for the queue request source */
  XMC_VADC_GROUP_QueueEnableArbitrationSlot(group_ptr);

}
 8023816:	f85d 4b04 	ldr.w	r4, [sp], #4
 802381a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 802381e:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
 8023822:	4770      	bx	lr
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)config->conv_start_mode)
  {
    reg |= (uint32_t)(VADC_G_ARBPR_CSM0_Msk);
  }

  group_ptr->ARBPR = reg;
 8023824:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84


  group_ptr->QCTRL0 = (uint32_t)((config->qctrl0)|(uint32_t)(VADC_G_QCTRL0_XTWC_Msk)|
 8023828:	684b      	ldr	r3, [r1, #4]
 802382a:	f043 2380 	orr.w	r3, r3, #2147516416	; 0x80008000
 802382e:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8023832:	f8c0 3100 	str.w	r3, [r0, #256]	; 0x100
                                                    (uint32_t)(VADC_G_QCTRL0_TMWC_Msk)|
                                                    (uint32_t)(VADC_G_QCTRL0_GTWC_Msk));

  /* Gating mode */
  group_ptr->QMR0 = ((uint32_t)(config->qmr0) | (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_G_QMR0_ENGT_Pos));
 8023836:	688b      	ldr	r3, [r1, #8]
 8023838:	f043 0301 	orr.w	r3, r3, #1
 802383c:	f8c0 3104 	str.w	r3, [r0, #260]	; 0x104
 8023840:	e7e7      	b.n	8023812 <XMC_VADC_GROUP_QueueInit+0x56>
 8023842:	bf00      	nop

08023844 <XMC_VADC_GROUP_QueueSetReqSrcEventInterruptNode>:
  uint32_t sevnp;

  XMC_ASSERT("XMC_VADC_GROUP_QueueSetReqSrcEventInterruptNode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_QueueSetReqSrcEventInterruptNode:Wrong Service Request", ((sr)  <= XMC_VADC_SR_SHARED_SR3))

  sevnp = group_ptr->SEVNP;
 8023844:	f8d0 31c0 	ldr.w	r3, [r0, #448]	; 0x1c0

  sevnp &= ~((uint32_t)VADC_G_SEVNP_SEV0NP_Msk);
 8023848:	f023 030f 	bic.w	r3, r3, #15
  sevnp |= (uint32_t)((uint32_t)sr << VADC_G_SEVNP_SEV0NP_Pos);
 802384c:	4319      	orrs	r1, r3

  group_ptr->SEVNP = sevnp;
 802384e:	f8c0 11c0 	str.w	r1, [r0, #448]	; 0x1c0
 8023852:	4770      	bx	lr

08023854 <XMC_VADC_GROUP_ChannelInit>:

#if (XMC_VADC_GROUP_AVAILABLE ==1U)
/* API to initialize a channel unit */
void XMC_VADC_GROUP_ChannelInit(XMC_VADC_GROUP_t *const group_ptr, const uint32_t ch_num,
                                        const XMC_VADC_CHANNEL_CONFIG_t *config)
{
 8023854:	b430      	push	{r4, r5}


  XMC_ASSERT("XMC_VADC_GROUP_ChannelInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_ChannelInit:Wrong Channel Number", ((ch_num) < XMC_VADC_NUM_CHANNELS_PER_GROUP))
  
  prio  = (uint32_t)config->channel_priority;
 8023856:	7b13      	ldrb	r3, [r2, #12]

  /* Priority channel */
  ch_assign  = group_ptr->CHASS;
 8023858:	f8d0 5088 	ldr.w	r5, [r0, #136]	; 0x88
  ch_assign &= ~((uint32_t)((uint32_t)1 << ch_num));
 802385c:	2401      	movs	r4, #1
 802385e:	408c      	lsls	r4, r1
 8023860:	ea25 0404 	bic.w	r4, r5, r4
  ch_assign |= (uint32_t)(prio << ch_num);
 8023864:	408b      	lsls	r3, r1
 8023866:	4323      	orrs	r3, r4
  group_ptr->CHASS = ch_assign;
 8023868:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88

  /* Alias channel */
  if (config->alias_channel >= (int32_t)0)
 802386c:	7b53      	ldrb	r3, [r2, #13]
 802386e:	061c      	lsls	r4, r3, #24
 8023870:	d40a      	bmi.n	8023888 <XMC_VADC_GROUP_ChannelInit+0x34>
  {
    mask = (uint32_t)0;
    if ((uint32_t)1 == ch_num)
 8023872:	2901      	cmp	r1, #1
 8023874:	d023      	beq.n	80238be <XMC_VADC_GROUP_ChannelInit+0x6a>
    {
      mask = VADC_G_ALIAS_ALIAS1_Pos;
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS1_Msk);
    }
    else if ((uint32_t)0 == ch_num)
 8023876:	b1c9      	cbz	r1, 80238ac <XMC_VADC_GROUP_ChannelInit+0x58>
 8023878:	2500      	movs	r5, #0
    {
      mask = VADC_G_ALIAS_ALIAS0_Pos;
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS0_Msk);
    }

    group_ptr->ALIAS |= (uint32_t)(config->alias_channel << mask);
 802387a:	f8d0 40b0 	ldr.w	r4, [r0, #176]	; 0xb0
 802387e:	b25b      	sxtb	r3, r3
 8023880:	40ab      	lsls	r3, r5
 8023882:	4323      	orrs	r3, r4
 8023884:	f8c0 30b0 	str.w	r3, [r0, #176]	; 0xb0
  }

  group_ptr->BFL |= config->bfl;
 8023888:	f8d0 40c8 	ldr.w	r4, [r0, #200]	; 0xc8
 802388c:	6853      	ldr	r3, [r2, #4]
 802388e:	4323      	orrs	r3, r4
 8023890:	f8c0 30c8 	str.w	r3, [r0, #200]	; 0xc8

#if (XMC_VADC_BOUNDARY_FLAG_SELECT == 1U)
  group_ptr->BFLC |= config->bflc;
 8023894:	f8d0 40d0 	ldr.w	r4, [r0, #208]	; 0xd0
 8023898:	6893      	ldr	r3, [r2, #8]
 802389a:	4323      	orrs	r3, r4
 802389c:	f8c0 30d0 	str.w	r3, [r0, #208]	; 0xd0
#endif
  /* Program the CHCTR register */
  group_ptr->CHCTR[ch_num] = config->chctr;
 80238a0:	3180      	adds	r1, #128	; 0x80
 80238a2:	6813      	ldr	r3, [r2, #0]
 80238a4:	f840 3021 	str.w	r3, [r0, r1, lsl #2]

}
 80238a8:	bc30      	pop	{r4, r5}
 80238aa:	4770      	bx	lr
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS1_Msk);
    }
    else if ((uint32_t)0 == ch_num)
    {
      mask = VADC_G_ALIAS_ALIAS0_Pos;
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS0_Msk);
 80238ac:	f8d0 30b0 	ldr.w	r3, [r0, #176]	; 0xb0
 80238b0:	f023 031f 	bic.w	r3, r3, #31
 80238b4:	f8c0 30b0 	str.w	r3, [r0, #176]	; 0xb0
 80238b8:	7b53      	ldrb	r3, [r2, #13]
 80238ba:	460d      	mov	r5, r1
 80238bc:	e7dd      	b.n	802387a <XMC_VADC_GROUP_ChannelInit+0x26>
  {
    mask = (uint32_t)0;
    if ((uint32_t)1 == ch_num)
    {
      mask = VADC_G_ALIAS_ALIAS1_Pos;
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS1_Msk);
 80238be:	f8d0 30b0 	ldr.w	r3, [r0, #176]	; 0xb0
 80238c2:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
 80238c6:	f8c0 30b0 	str.w	r3, [r0, #176]	; 0xb0
 80238ca:	7b53      	ldrb	r3, [r2, #13]
 80238cc:	2508      	movs	r5, #8
 80238ce:	e7d4      	b.n	802387a <XMC_VADC_GROUP_ChannelInit+0x26>

080238d0 <XMC_VADC_GROUP_SetResultInterruptNode>:

  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Result Register", ((res_reg) < XMC_VADC_NUM_RESULT_REGISTERS))
  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Service Request", ((sr)  <= XMC_VADC_SR_SHARED_SR3))

  if (res_reg <= 7U)
 80238d0:	2907      	cmp	r1, #7

/* API to select a service request line (NVIC Node) for result event of specified unit of result hardware */
void XMC_VADC_GROUP_SetResultInterruptNode(XMC_VADC_GROUP_t *const group_ptr,
                                           const uint32_t res_reg,
                                           const XMC_VADC_SR_t sr)
{
 80238d2:	b410      	push	{r4}

  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Result Register", ((res_reg) < XMC_VADC_NUM_RESULT_REGISTERS))
  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Service Request", ((sr)  <= XMC_VADC_SR_SHARED_SR3))

  if (res_reg <= 7U)
 80238d4:	d910      	bls.n	80238f8 <XMC_VADC_GROUP_SetResultInterruptNode+0x28>
    group_ptr->REVNP0 = route_mask;
  }
  else
  {
    route_mask = group_ptr->REVNP1;
    route_mask &= ~((uint32_t)((uint32_t)15 << (( res_reg - (uint32_t)8) * (uint32_t)4) ));
 80238d6:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 80238da:	3908      	subs	r1, #8
    route_mask |= (uint32_t)((uint32_t)sr << (res_reg * (uint32_t)4));
    group_ptr->REVNP0 = route_mask;
  }
  else
  {
    route_mask = group_ptr->REVNP1;
 80238dc:	f8d0 41b4 	ldr.w	r4, [r0, #436]	; 0x1b4
    route_mask &= ~((uint32_t)((uint32_t)15 << (( res_reg - (uint32_t)8) * (uint32_t)4) ));
 80238e0:	0089      	lsls	r1, r1, #2
 80238e2:	230f      	movs	r3, #15
 80238e4:	408b      	lsls	r3, r1
 80238e6:	ea24 0303 	bic.w	r3, r4, r3
    route_mask |= (uint32_t)((uint32_t)sr << ((res_reg - (uint32_t)8) * (uint32_t)4));
 80238ea:	408a      	lsls	r2, r1
 80238ec:	431a      	orrs	r2, r3
    group_ptr->REVNP1 = route_mask;
 80238ee:	f8c0 21b4 	str.w	r2, [r0, #436]	; 0x1b4
  }
}
 80238f2:	f85d 4b04 	ldr.w	r4, [sp], #4
 80238f6:	4770      	bx	lr
  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Result Register", ((res_reg) < XMC_VADC_NUM_RESULT_REGISTERS))
  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Service Request", ((sr)  <= XMC_VADC_SR_SHARED_SR3))

  if (res_reg <= 7U)
  {
    route_mask  = group_ptr->REVNP0;
 80238f8:	f8d0 41b0 	ldr.w	r4, [r0, #432]	; 0x1b0
    route_mask &= ~((uint32_t)((uint32_t)15 << (res_reg * (uint32_t)4) ));
 80238fc:	0089      	lsls	r1, r1, #2
 80238fe:	230f      	movs	r3, #15
 8023900:	408b      	lsls	r3, r1
 8023902:	ea24 0303 	bic.w	r3, r4, r3
    route_mask |= (uint32_t)((uint32_t)sr << (res_reg * (uint32_t)4));
 8023906:	408a      	lsls	r2, r1
 8023908:	431a      	orrs	r2, r3
    group_ptr->REVNP0 = route_mask;
 802390a:	f8c0 21b0 	str.w	r2, [r0, #432]	; 0x1b0
    route_mask = group_ptr->REVNP1;
    route_mask &= ~((uint32_t)((uint32_t)15 << (( res_reg - (uint32_t)8) * (uint32_t)4) ));
    route_mask |= (uint32_t)((uint32_t)sr << ((res_reg - (uint32_t)8) * (uint32_t)4));
    group_ptr->REVNP1 = route_mask;
  }
}
 802390e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8023912:	4770      	bx	lr

08023914 <_init>:
  }
}

/* Init */
void _init(void)
{}
 8023914:	4770      	bx	lr
 8023916:	bf00      	nop

08023918 <ep_calibration_handle_message>:
   5. EXPORTED FUNCTIONS
==============================================================================
 */

uint16_t ep_calibration_handle_message(uint8_t endpoint, uint8_t* message_data, uint16_t num_bytes, void* context)
{
 8023918:	b5f0      	push	{r4, r5, r6, r7, lr}
	Radar_Handle_t radar_driver = (Radar_Handle_t) context;

	uint16_t error_code;

	switch (message_data[0])
 802391a:	780c      	ldrb	r4, [r1, #0]
 802391c:	3c01      	subs	r4, #1
   5. EXPORTED FUNCTIONS
==============================================================================
 */

uint16_t ep_calibration_handle_message(uint8_t endpoint, uint8_t* message_data, uint16_t num_bytes, void* context)
{
 802391e:	b087      	sub	sp, #28
 8023920:	4606      	mov	r6, r0
 8023922:	4615      	mov	r5, r2
	Radar_Handle_t radar_driver = (Radar_Handle_t) context;

	uint16_t error_code;

	switch (message_data[0])
 8023924:	2c0b      	cmp	r4, #11
 8023926:	d80a      	bhi.n	802393e <ep_calibration_handle_message+0x26>
 8023928:	e8df f004 	tbb	[pc, r4]
 802392c:	3931160d 	.word	0x3931160d
 8023930:	8b766e42 	.word	0x8b766e42
 8023934:	06bba59c 	.word	0x06bba59c

		//---------------------------------------------------------------

	case MSG_CLEAR_ALGO_SRAM_CALIBRATION:

		if (num_bytes == 1)
 8023938:	2d01      	cmp	r5, #1
 802393a:	f000 80dd 	beq.w	8023af8 <ep_calibration_handle_message+0x1e0>
	default:

		break;
	}

	return PROTOCOL_STATUS_INVALID_PAYLOAD;
 802393e:	f64f 70ff 	movw	r0, #65535	; 0xffff
}
 8023942:	b007      	add	sp, #28
 8023944:	bdf0      	pop	{r4, r5, r6, r7, pc}

		//---------------------------------------------------------------

	case MSG_SET_ADC_FLASH_CALIBRATION:

		if (num_bytes == 1)
 8023946:	2d01      	cmp	r5, #1
 8023948:	d1f9      	bne.n	802393e <ep_calibration_handle_message+0x26>
		{
			error_code = radar_save_calibration(radar_driver, CALIBRATION_TARGET_FLASH, CALIBRATION_DATA_ADC, NULL);
 802394a:	2100      	movs	r1, #0
 802394c:	4618      	mov	r0, r3
 802394e:	460a      	mov	r2, r1
 8023950:	460b      	mov	r3, r1
 8023952:	f7fc ffc9 	bl	80208e8 <radar_save_calibration>

			return error_code;
 8023956:	e7f4      	b.n	8023942 <ep_calibration_handle_message+0x2a>
	switch (message_data[0])
	{

	case MSG_GET_ADC_FLASH_CALIBRATION:

		if (num_bytes == 1)
 8023958:	2d01      	cmp	r5, #1
 802395a:	d1f0      	bne.n	802393e <ep_calibration_handle_message+0x26>
{
	uint16_t error_code = 0;

	uint16_t num_of_bytes;

	void* calibration_data_ptr = NULL;
 802395c:	aa06      	add	r2, sp, #24
 802395e:	2100      	movs	r1, #0
 8023960:	f842 1d08 	str.w	r1, [r2, #-8]!

	//----------------------------------------------------------------------

	error_code = radar_read_calibration(radar_driver, target, CALIBRATION_DATA_ADC, &calibration_data_ptr, &num_of_bytes);
 8023964:	f10d 040a 	add.w	r4, sp, #10
 8023968:	4618      	mov	r0, r3
 802396a:	9400      	str	r4, [sp, #0]
 802396c:	4613      	mov	r3, r2
 802396e:	460a      	mov	r2, r1
 8023970:	f7fd f882 	bl	8020a78 <radar_read_calibration>

	if (error_code == RADAR_ERR_OK)
 8023974:	4604      	mov	r4, r0
 8023976:	2800      	cmp	r0, #0
 8023978:	d144      	bne.n	8023a04 <ep_calibration_handle_message+0xec>
		else
		{
			wr_payload_u8(message_header, 0, MSG_GET_ADC_SRAM_CALIBRATION);
		}

		wr_payload_u16(message_header, 1, num_of_bytes);
 802397a:	f8bd 300a 	ldrh.w	r3, [sp, #10]

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 802397e:	f88d 300d 	strb.w	r3, [sp, #13]

		/* send message header */
		protocol_send_header(endpoint, sizeof(message_header) + num_of_bytes);
 8023982:	1cd9      	adds	r1, r3, #3
 8023984:	4630      	mov	r0, r6
 8023986:	b289      	uxth	r1, r1
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023988:	0a1b      	lsrs	r3, r3, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802398a:	2202      	movs	r2, #2
 802398c:	e029      	b.n	80239e2 <ep_calibration_handle_message+0xca>

		//---------------------------------------------------------------

	case MSG_CLEAR_ADC_FLASH_CALIBRATION:

		if (num_bytes == 1)
 802398e:	2d01      	cmp	r5, #1
 8023990:	d1d5      	bne.n	802393e <ep_calibration_handle_message+0x26>
		{
			error_code = radar_clear_calibration(radar_driver, CALIBRATION_TARGET_FLASH, CALIBRATION_DATA_ADC);
 8023992:	2100      	movs	r1, #0
 8023994:	4618      	mov	r0, r3
 8023996:	460a      	mov	r2, r1
 8023998:	f7fd f8b6 	bl	8020b08 <radar_clear_calibration>

			return error_code;
 802399c:	e7d1      	b.n	8023942 <ep_calibration_handle_message+0x2a>

		//---------------------------------------------------------------

	case MSG_SET_ADC_SRAM_CALIBRATION:

		if (num_bytes == 1)
 802399e:	2d01      	cmp	r5, #1
 80239a0:	d1cd      	bne.n	802393e <ep_calibration_handle_message+0x26>
		{
			error_code = radar_save_calibration(radar_driver, CALIBRATION_TARGET_SRAM,CALIBRATION_DATA_ADC, NULL);
 80239a2:	2200      	movs	r2, #0
 80239a4:	4618      	mov	r0, r3
 80239a6:	4629      	mov	r1, r5
 80239a8:	4613      	mov	r3, r2
 80239aa:	f7fc ff9d 	bl	80208e8 <radar_save_calibration>

			return error_code;
 80239ae:	e7c8      	b.n	8023942 <ep_calibration_handle_message+0x2a>

		//---------------------------------------------------------------

	case MSG_GET_ADC_SRAM_CALIBRATION:

		if (num_bytes == 1)
 80239b0:	2d01      	cmp	r5, #1
 80239b2:	d1c4      	bne.n	802393e <ep_calibration_handle_message+0x26>
{
	uint16_t error_code = 0;

	uint16_t num_of_bytes;

	void* calibration_data_ptr = NULL;
 80239b4:	ac06      	add	r4, sp, #24
 80239b6:	2200      	movs	r2, #0
 80239b8:	f844 2d08 	str.w	r2, [r4, #-8]!

	//----------------------------------------------------------------------

	error_code = radar_read_calibration(radar_driver, target, CALIBRATION_DATA_ADC, &calibration_data_ptr, &num_of_bytes);
 80239bc:	f10d 070a 	add.w	r7, sp, #10
 80239c0:	4618      	mov	r0, r3
 80239c2:	4629      	mov	r1, r5
 80239c4:	4623      	mov	r3, r4
 80239c6:	9700      	str	r7, [sp, #0]
 80239c8:	f7fd f856 	bl	8020a78 <radar_read_calibration>

	if (error_code == RADAR_ERR_OK)
 80239cc:	4604      	mov	r4, r0
 80239ce:	b9c8      	cbnz	r0, 8023a04 <ep_calibration_handle_message+0xec>
		else
		{
			wr_payload_u8(message_header, 0, MSG_GET_ADC_SRAM_CALIBRATION);
		}

		wr_payload_u16(message_header, 1, num_of_bytes);
 80239d0:	f8bd 300a 	ldrh.w	r3, [sp, #10]

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 80239d4:	f88d 300d 	strb.w	r3, [sp, #13]

		/* send message header */
		protocol_send_header(endpoint, sizeof(message_header) + num_of_bytes);
 80239d8:	1cd9      	adds	r1, r3, #3
 80239da:	4630      	mov	r0, r6
 80239dc:	b289      	uxth	r1, r1
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 80239de:	0a1b      	lsrs	r3, r3, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80239e0:	2205      	movs	r2, #5
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 80239e2:	f88d 300e 	strb.w	r3, [sp, #14]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80239e6:	f88d 200c 	strb.w	r2, [sp, #12]
 80239ea:	f001 f81d 	bl	8024a28 <protocol_send_header>

		protocol_send_payload(message_header, sizeof(message_header));
 80239ee:	a803      	add	r0, sp, #12
 80239f0:	2103      	movs	r1, #3
 80239f2:	f001 f82d 	bl	8024a50 <protocol_send_payload>

		protocol_send_payload((uint8_t*)calibration_data_ptr, num_of_bytes);
 80239f6:	9804      	ldr	r0, [sp, #16]
 80239f8:	f8bd 100a 	ldrh.w	r1, [sp, #10]
 80239fc:	f001 f828 	bl	8024a50 <protocol_send_payload>

		protocol_send_tail();
 8023a00:	f001 f828 	bl	8024a54 <protocol_send_tail>

	void* calibration_data_ptr;

	//----------------------------------------------------------------------

	error_code = radar_read_calibration(radar_driver, target, CALIBRATION_DATA_ALGO, &calibration_data_ptr, &num_of_bytes);
 8023a04:	4620      	mov	r0, r4

		if (num_bytes == 1)
		{
			error_code = send_algo_calibration_data(endpoint, radar_driver, CALIBRATION_TARGET_SRAM);

			return error_code;
 8023a06:	e79c      	b.n	8023942 <ep_calibration_handle_message+0x2a>

		//---------------------------------------------------------------

	case MSG_CLEAR_ADC_SRAM_CALIBRATION:

		if (num_bytes == 1)
 8023a08:	2d01      	cmp	r5, #1
 8023a0a:	d198      	bne.n	802393e <ep_calibration_handle_message+0x26>
		{
			error_code = radar_clear_calibration(radar_driver, CALIBRATION_TARGET_SRAM, CALIBRATION_DATA_ADC);
 8023a0c:	4618      	mov	r0, r3
 8023a0e:	4629      	mov	r1, r5
 8023a10:	2200      	movs	r2, #0
 8023a12:	f7fd f879 	bl	8020b08 <radar_clear_calibration>

			return error_code;
 8023a16:	e794      	b.n	8023942 <ep_calibration_handle_message+0x2a>

		//---------------------------------------------------------------

	case MSG_SET_ALGO_FLASH_CALIBRATION:

		if (num_bytes == 5)
 8023a18:	2d05      	cmp	r5, #5
 8023a1a:	d190      	bne.n	802393e <ep_calibration_handle_message+0x26>
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, uint16_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8023a1c:	788e      	ldrb	r6, [r1, #2]
 * than the native little endian implementations.
 */

static inline int16_t rd_payload_i16(const uint8_t* payload, uint16_t offset)
{
    return (int16_t)((((uint16_t)payload[offset + 1]) <<  8) |
 8023a1e:	78ca      	ldrb	r2, [r1, #3]
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, uint16_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8023a20:	784d      	ldrb	r5, [r1, #1]
 * than the native little endian implementations.
 */

static inline int16_t rd_payload_i16(const uint8_t* payload, uint16_t offset)
{
    return (int16_t)((((uint16_t)payload[offset + 1]) <<  8) |
 8023a22:	790c      	ldrb	r4, [r1, #4]
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, uint16_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8023a24:	ea45 2506 	orr.w	r5, r5, r6, lsl #8
 * than the native little endian implementations.
 */

static inline int16_t rd_payload_i16(const uint8_t* payload, uint16_t offset)
{
    return (int16_t)((((uint16_t)payload[offset + 1]) <<  8) |
 8023a28:	ea42 2404 	orr.w	r4, r2, r4, lsl #8
			/* extract parameters from message */

			algo_calibration_settings.distance_offset_cm = rd_payload_u16(message_data, 1);
			algo_calibration_settings.angle_offset_deg   = rd_payload_i16(message_data, 3);

			error_code = radar_save_calibration(radar_driver, CALIBRATION_TARGET_FLASH, CALIBRATION_DATA_ALGO, &algo_calibration_settings);
 8023a2c:	4618      	mov	r0, r3
 8023a2e:	2100      	movs	r1, #0
 8023a30:	2201      	movs	r2, #1
 8023a32:	ab04      	add	r3, sp, #16
		{
			Algo_Calibrations_t algo_calibration_settings;

			/* extract parameters from message */

			algo_calibration_settings.distance_offset_cm = rd_payload_u16(message_data, 1);
 8023a34:	f8ad 5010 	strh.w	r5, [sp, #16]
			algo_calibration_settings.angle_offset_deg   = rd_payload_i16(message_data, 3);
 8023a38:	f8ad 4012 	strh.w	r4, [sp, #18]

			error_code = radar_save_calibration(radar_driver, CALIBRATION_TARGET_FLASH, CALIBRATION_DATA_ALGO, &algo_calibration_settings);
 8023a3c:	f7fc ff54 	bl	80208e8 <radar_save_calibration>
 8023a40:	e77f      	b.n	8023942 <ep_calibration_handle_message+0x2a>

		//===============================================================

	case MSG_GET_ALGO_FLASH_CALIBRATION:

		if (num_bytes == 1)
 8023a42:	2d01      	cmp	r5, #1
 8023a44:	f47f af7b 	bne.w	802393e <ep_calibration_handle_message+0x26>

	void* calibration_data_ptr;

	//----------------------------------------------------------------------

	error_code = radar_read_calibration(radar_driver, target, CALIBRATION_DATA_ALGO, &calibration_data_ptr, &num_of_bytes);
 8023a48:	f10d 010a 	add.w	r1, sp, #10
 8023a4c:	4618      	mov	r0, r3
 8023a4e:	9100      	str	r1, [sp, #0]
 8023a50:	462a      	mov	r2, r5
 8023a52:	2100      	movs	r1, #0
 8023a54:	ab03      	add	r3, sp, #12
 8023a56:	f7fd f80f 	bl	8020a78 <radar_read_calibration>

	if (error_code == RADAR_ERR_OK)
 8023a5a:	4604      	mov	r4, r0
 8023a5c:	2800      	cmp	r0, #0
 8023a5e:	d1d1      	bne.n	8023a04 <ep_calibration_handle_message+0xec>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023a60:	2308      	movs	r3, #8
 8023a62:	e02e      	b.n	8023ac2 <ep_calibration_handle_message+0x1aa>

		//---------------------------------------------------------------

	case MSG_CLEAR_ALGO_FLASH_CALIBRATION:

		if (num_bytes == 1)
 8023a64:	2d01      	cmp	r5, #1
 8023a66:	f47f af6a 	bne.w	802393e <ep_calibration_handle_message+0x26>
		{
			error_code = radar_clear_calibration(radar_driver, CALIBRATION_TARGET_FLASH, CALIBRATION_DATA_ALGO);
 8023a6a:	4618      	mov	r0, r3
 8023a6c:	462a      	mov	r2, r5
 8023a6e:	2100      	movs	r1, #0
 8023a70:	f7fd f84a 	bl	8020b08 <radar_clear_calibration>

			return error_code;
 8023a74:	e765      	b.n	8023942 <ep_calibration_handle_message+0x2a>

		//---------------------------------------------------------------

	case MSG_SET_ALGO_SRAM_CALIBRATION:

		if (num_bytes == 5)
 8023a76:	2d05      	cmp	r5, #5
 8023a78:	f47f af61 	bne.w	802393e <ep_calibration_handle_message+0x26>
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, uint16_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8023a7c:	788e      	ldrb	r6, [r1, #2]
 * than the native little endian implementations.
 */

static inline int16_t rd_payload_i16(const uint8_t* payload, uint16_t offset)
{
    return (int16_t)((((uint16_t)payload[offset + 1]) <<  8) |
 8023a7e:	78ca      	ldrb	r2, [r1, #3]
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, uint16_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8023a80:	784d      	ldrb	r5, [r1, #1]
 * than the native little endian implementations.
 */

static inline int16_t rd_payload_i16(const uint8_t* payload, uint16_t offset)
{
    return (int16_t)((((uint16_t)payload[offset + 1]) <<  8) |
 8023a82:	790c      	ldrb	r4, [r1, #4]

			/* extract parameters from message */
			algo_calibration_settings.distance_offset_cm = rd_payload_u16(message_data, 1);
			algo_calibration_settings.angle_offset_deg   = rd_payload_i16(message_data, 3);

			error_code = radar_save_calibration(radar_driver, CALIBRATION_TARGET_SRAM, CALIBRATION_DATA_ALGO, &algo_calibration_settings);
 8023a84:	2101      	movs	r1, #1
 8023a86:	ea42 2404 	orr.w	r4, r2, r4, lsl #8
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, uint16_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8023a8a:	ea45 2506 	orr.w	r5, r5, r6, lsl #8
 8023a8e:	4618      	mov	r0, r3
 8023a90:	460a      	mov	r2, r1
 8023a92:	ab04      	add	r3, sp, #16
		if (num_bytes == 5)
		{
			Algo_Calibrations_t algo_calibration_settings;

			/* extract parameters from message */
			algo_calibration_settings.distance_offset_cm = rd_payload_u16(message_data, 1);
 8023a94:	f8ad 5010 	strh.w	r5, [sp, #16]
			algo_calibration_settings.angle_offset_deg   = rd_payload_i16(message_data, 3);
 8023a98:	f8ad 4012 	strh.w	r4, [sp, #18]

			error_code = radar_save_calibration(radar_driver, CALIBRATION_TARGET_SRAM, CALIBRATION_DATA_ALGO, &algo_calibration_settings);
 8023a9c:	f7fc ff24 	bl	80208e8 <radar_save_calibration>
 8023aa0:	e74f      	b.n	8023942 <ep_calibration_handle_message+0x2a>

		//---------------------------------------------------------------

	case MSG_GET_ALGO_SRAM_CALIBRATION:

		if (num_bytes == 1)
 8023aa2:	2d01      	cmp	r5, #1
 8023aa4:	f47f af4b 	bne.w	802393e <ep_calibration_handle_message+0x26>

	void* calibration_data_ptr;

	//----------------------------------------------------------------------

	error_code = radar_read_calibration(radar_driver, target, CALIBRATION_DATA_ALGO, &calibration_data_ptr, &num_of_bytes);
 8023aa8:	f10d 020a 	add.w	r2, sp, #10
 8023aac:	4618      	mov	r0, r3
 8023aae:	9200      	str	r2, [sp, #0]
 8023ab0:	4629      	mov	r1, r5
 8023ab2:	462a      	mov	r2, r5
 8023ab4:	ab03      	add	r3, sp, #12
 8023ab6:	f7fc ffdf 	bl	8020a78 <radar_read_calibration>

	if (error_code == RADAR_ERR_OK)
 8023aba:	4604      	mov	r4, r0
 8023abc:	2800      	cmp	r0, #0
 8023abe:	d1a1      	bne.n	8023a04 <ep_calibration_handle_message+0xec>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023ac0:	230b      	movs	r3, #11
		else
		{
			wr_payload_u8(message_header, 0, MSG_GET_ALGO_SRAM_CALIBRATION);
		}

		wr_payload_u16(message_header, 1, ((Algo_Calibrations_t*)calibration_data_ptr)->distance_offset_cm);
 8023ac2:	9a03      	ldr	r2, [sp, #12]
 8023ac4:	f88d 3010 	strb.w	r3, [sp, #16]
 8023ac8:	8813      	ldrh	r3, [r2, #0]

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8023aca:	f88d 3011 	strb.w	r3, [sp, #17]
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023ace:	0a1b      	lsrs	r3, r3, #8
 8023ad0:	f88d 3012 	strb.w	r3, [sp, #18]
		wr_payload_i16(message_header, 3, ((Algo_Calibrations_t*)calibration_data_ptr)->angle_offset_deg);
 8023ad4:	8853      	ldrh	r3, [r2, #2]

static inline void wr_payload_i16(uint8_t* payload, uint16_t offset,
                                  int16_t value)
{
    payload[offset + 1] = (((uint16_t)value) >>  8) & 0xFF;
    payload[offset    ] =  ((uint16_t)value)        & 0xFF;
 8023ad6:	f88d 3013 	strb.w	r3, [sp, #19]

		/* send message header */
		protocol_send_header(endpoint, sizeof(message_header));
 8023ada:	4630      	mov	r0, r6
}

static inline void wr_payload_i16(uint8_t* payload, uint16_t offset,
                                  int16_t value)
{
    payload[offset + 1] = (((uint16_t)value) >>  8) & 0xFF;
 8023adc:	0a1b      	lsrs	r3, r3, #8
 8023ade:	2105      	movs	r1, #5
 8023ae0:	f88d 3014 	strb.w	r3, [sp, #20]
 8023ae4:	f000 ffa0 	bl	8024a28 <protocol_send_header>

		protocol_send_payload(message_header, sizeof(message_header));
 8023ae8:	a804      	add	r0, sp, #16
 8023aea:	2105      	movs	r1, #5
 8023aec:	f000 ffb0 	bl	8024a50 <protocol_send_payload>

		protocol_send_tail();
 8023af0:	f000 ffb0 	bl	8024a54 <protocol_send_tail>

	void* calibration_data_ptr;

	//----------------------------------------------------------------------

	error_code = radar_read_calibration(radar_driver, target, CALIBRATION_DATA_ALGO, &calibration_data_ptr, &num_of_bytes);
 8023af4:	4620      	mov	r0, r4
 8023af6:	e724      	b.n	8023942 <ep_calibration_handle_message+0x2a>

	case MSG_CLEAR_ALGO_SRAM_CALIBRATION:

		if (num_bytes == 1)
		{
			error_code = radar_clear_calibration(radar_driver, CALIBRATION_TARGET_SRAM, CALIBRATION_DATA_ALGO);
 8023af8:	4618      	mov	r0, r3
 8023afa:	4629      	mov	r1, r5
 8023afc:	462a      	mov	r2, r5
 8023afe:	f7fd f803 	bl	8020b08 <radar_clear_calibration>

			return error_code;
 8023b02:	e71e      	b.n	8023942 <ep_calibration_handle_message+0x2a>

08023b04 <ep_calibration_handle_change>:
}

//==============================================================================

void ep_calibration_handle_change (uint8_t endpoint, void* context, uint32_t what)
{
 8023b04:	4770      	bx	lr
 8023b06:	bf00      	nop

08023b08 <send_adc_configuration>:
==============================================================================
*/

uint16_t send_adc_configuration(uint8_t endpoint,
                                       Radar_Handle_t radar_driver)
{
 8023b08:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16_t error_code;
    Adc_Configuration_t adc_configuration;

    adc_endpoint = endpoint;
 8023b0a:	4b17      	ldr	r3, [pc, #92]	; (8023b68 <send_adc_configuration+0x60>)
==============================================================================
*/

uint16_t send_adc_configuration(uint8_t endpoint,
                                       Radar_Handle_t radar_driver)
{
 8023b0c:	b085      	sub	sp, #20
 8023b0e:	4605      	mov	r5, r0
    Adc_Configuration_t adc_configuration;

    adc_endpoint = endpoint;

    /* read ADC configuration from device */
    error_code = radar_get_adc_configuration(radar_driver,
 8023b10:	4608      	mov	r0, r1
 8023b12:	a902      	add	r1, sp, #8
                                       Radar_Handle_t radar_driver)
{
    uint16_t error_code;
    Adc_Configuration_t adc_configuration;

    adc_endpoint = endpoint;
 8023b14:	701d      	strb	r5, [r3, #0]

    /* read ADC configuration from device */
    error_code = radar_get_adc_configuration(radar_driver,
 8023b16:	f7fc fcc9 	bl	80204ac <radar_get_adc_configuration>
                                             &adc_configuration);

    if (error_code == RADAR_ERR_OK)
 8023b1a:	4604      	mov	r4, r0
 8023b1c:	bb08      	cbnz	r0, 8023b62 <send_adc_configuration+0x5a>
    {
        uint8_t message[7];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_CONFIGURATION);
        wr_payload_u32(message, 1, adc_configuration.samplerate_Hz);
 8023b1e:	9b02      	ldr	r3, [sp, #8]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023b20:	f89d 200d 	ldrb.w	r2, [sp, #13]
 8023b24:	f89d 600c 	ldrb.w	r6, [sp, #12]
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8023b28:	f88d 3001 	strb.w	r3, [sp, #1]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023b2c:	ea4f 6e13 	mov.w	lr, r3, lsr #24
        wr_payload_u8 (message, 5, adc_configuration.resolution);
        wr_payload_u8 (message, 6, adc_configuration.use_post_calibration);

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 8023b30:	4628      	mov	r0, r5
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023b32:	0c1f      	lsrs	r7, r3, #16
 8023b34:	2107      	movs	r1, #7
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023b36:	0a1b      	lsrs	r3, r3, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023b38:	2501      	movs	r5, #1
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023b3a:	f88d e004 	strb.w	lr, [sp, #4]
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023b3e:	f88d 3002 	strb.w	r3, [sp, #2]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023b42:	f88d 2006 	strb.w	r2, [sp, #6]

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023b46:	f88d 7003 	strb.w	r7, [sp, #3]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023b4a:	f88d 5000 	strb.w	r5, [sp]
 8023b4e:	f88d 6005 	strb.w	r6, [sp, #5]
 8023b52:	f000 ff69 	bl	8024a28 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 8023b56:	4668      	mov	r0, sp
 8023b58:	2107      	movs	r1, #7
 8023b5a:	f000 ff79 	bl	8024a50 <protocol_send_payload>
        protocol_send_tail();
 8023b5e:	f000 ff79 	bl	8024a54 <protocol_send_tail>
    }
    return error_code;
}
 8023b62:	4620      	mov	r0, r4
 8023b64:	b005      	add	sp, #20
 8023b66:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8023b68:	1ffe8cfc 	.word	0x1ffe8cfc

08023b6c <ep_radar_adcxmc_handle_message>:

uint16_t ep_radar_adcxmc_handle_message(uint8_t endpoint,
                                        uint8_t* message_data,
                                        uint16_t num_bytes,
                                        void* context)
{
 8023b6c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8023b6e:	4605      	mov	r5, r0
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (message_data[0])
 8023b70:	7808      	ldrb	r0, [r1, #0]

uint16_t ep_radar_adcxmc_handle_message(uint8_t endpoint,
                                        uint8_t* message_data,
                                        uint16_t num_bytes,
                                        void* context)
{
 8023b72:	b087      	sub	sp, #28
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (message_data[0])
 8023b74:	b328      	cbz	r0, 8023bc2 <ep_radar_adcxmc_handle_message+0x56>
 8023b76:	2801      	cmp	r0, #1
 8023b78:	d004      	beq.n	8023b84 <ep_radar_adcxmc_handle_message+0x18>
        break;

    default:
        break;
    }
    return PROTOCOL_STATUS_INVALID_PAYLOAD;
 8023b7a:	f64f 74ff 	movw	r4, #65535	; 0xffff
}
 8023b7e:	4620      	mov	r0, r4
 8023b80:	b007      	add	sp, #28
 8023b82:	bdf0      	pop	{r4, r5, r6, r7, pc}
            return send_adc_configuration(endpoint, radar_driver);
        }
        break;

    case MSG_SET_CONFIGURATION:
        if (num_bytes == 7)
 8023b84:	2a07      	cmp	r2, #7
 8023b86:	d1f8      	bne.n	8023b7a <ep_radar_adcxmc_handle_message+0xe>
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 8023b88:	78cc      	ldrb	r4, [r1, #3]
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 8023b8a:	790a      	ldrb	r2, [r1, #4]
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
            ((uint32_t)payload[offset    ]);
 8023b8c:	7848      	ldrb	r0, [r1, #1]

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 8023b8e:	788e      	ldrb	r6, [r1, #2]
            unsigned error_code;
            Adc_Configuration_t config;

            /* extract parameters from message */
            config.samplerate_Hz        = rd_payload_u32(message_data, 1);
            config.resolution           = rd_payload_u8 (message_data, 5);
 8023b90:	794f      	ldrb	r7, [r1, #5]
            config.use_post_calibration = rd_payload_u8 (message_data, 6);
 8023b92:	798d      	ldrb	r5, [r1, #6]

            /* apply ADC configuration */
            error_code = radar_set_adc_configuration(radar_driver, &config);
 8023b94:	9301      	str	r3, [sp, #4]
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 8023b96:	0421      	lsls	r1, r4, #16
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 8023b98:	ea41 6202 	orr.w	r2, r1, r2, lsl #24
 8023b9c:	4302      	orrs	r2, r0
 8023b9e:	ea42 2206 	orr.w	r2, r2, r6, lsl #8
 8023ba2:	a904      	add	r1, sp, #16
 8023ba4:	4618      	mov	r0, r3
            unsigned error_code;
            Adc_Configuration_t config;

            /* extract parameters from message */
            config.samplerate_Hz        = rd_payload_u32(message_data, 1);
            config.resolution           = rd_payload_u8 (message_data, 5);
 8023ba6:	f88d 7014 	strb.w	r7, [sp, #20]
        {
            unsigned error_code;
            Adc_Configuration_t config;

            /* extract parameters from message */
            config.samplerate_Hz        = rd_payload_u32(message_data, 1);
 8023baa:	9204      	str	r2, [sp, #16]
            config.resolution           = rd_payload_u8 (message_data, 5);
            config.use_post_calibration = rd_payload_u8 (message_data, 6);
 8023bac:	f88d 5015 	strb.w	r5, [sp, #21]

            /* apply ADC configuration */
            error_code = radar_set_adc_configuration(radar_driver, &config);
 8023bb0:	f7fc fc2e 	bl	8020410 <radar_set_adc_configuration>

            /* inform other endpoints of the change */
            protocol_broadcast_change(radar_driver,
 8023bb4:	9b01      	ldr	r3, [sp, #4]
            config.samplerate_Hz        = rd_payload_u32(message_data, 1);
            config.resolution           = rd_payload_u8 (message_data, 5);
            config.use_post_calibration = rd_payload_u8 (message_data, 6);

            /* apply ADC configuration */
            error_code = radar_set_adc_configuration(radar_driver, &config);
 8023bb6:	4604      	mov	r4, r0

            /* inform other endpoints of the change */
            protocol_broadcast_change(radar_driver,
 8023bb8:	2104      	movs	r1, #4
 8023bba:	4618      	mov	r0, r3
 8023bbc:	f001 f90a 	bl	8024dd4 <protocol_broadcast_change>
 8023bc0:	e7dd      	b.n	8023b7e <ep_radar_adcxmc_handle_message+0x12>
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (message_data[0])
    {
    case MSG_GET_CONFIGURATION:
        if (num_bytes == 1)
 8023bc2:	2a01      	cmp	r2, #1
 8023bc4:	d1d9      	bne.n	8023b7a <ep_radar_adcxmc_handle_message+0xe>
                                       Radar_Handle_t radar_driver)
{
    uint16_t error_code;
    Adc_Configuration_t adc_configuration;

    adc_endpoint = endpoint;
 8023bc6:	4c16      	ldr	r4, [pc, #88]	; (8023c20 <ep_radar_adcxmc_handle_message+0xb4>)
 8023bc8:	9201      	str	r2, [sp, #4]

    /* read ADC configuration from device */
    error_code = radar_get_adc_configuration(radar_driver,
 8023bca:	4618      	mov	r0, r3
 8023bcc:	a904      	add	r1, sp, #16
                                       Radar_Handle_t radar_driver)
{
    uint16_t error_code;
    Adc_Configuration_t adc_configuration;

    adc_endpoint = endpoint;
 8023bce:	7025      	strb	r5, [r4, #0]

    /* read ADC configuration from device */
    error_code = radar_get_adc_configuration(radar_driver,
 8023bd0:	f7fc fc6c 	bl	80204ac <radar_get_adc_configuration>
                                             &adc_configuration);

    if (error_code == RADAR_ERR_OK)
 8023bd4:	9a01      	ldr	r2, [sp, #4]
 8023bd6:	4604      	mov	r4, r0
 8023bd8:	2800      	cmp	r0, #0
 8023bda:	d1d0      	bne.n	8023b7e <ep_radar_adcxmc_handle_message+0x12>
    {
        uint8_t message[7];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_CONFIGURATION);
        wr_payload_u32(message, 1, adc_configuration.samplerate_Hz);
 8023bdc:	9b04      	ldr	r3, [sp, #16]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023bde:	f89d 7014 	ldrb.w	r7, [sp, #20]
 8023be2:	f89d 6015 	ldrb.w	r6, [sp, #21]
 8023be6:	f88d 2008 	strb.w	r2, [sp, #8]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023bea:	ea4f 6e13 	mov.w	lr, r3, lsr #24
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023bee:	0a1a      	lsrs	r2, r3, #8
        wr_payload_u8 (message, 5, adc_configuration.resolution);
        wr_payload_u8 (message, 6, adc_configuration.use_post_calibration);

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 8023bf0:	4628      	mov	r0, r5
 8023bf2:	2107      	movs	r1, #7

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023bf4:	0c1d      	lsrs	r5, r3, #16
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8023bf6:	f88d 3009 	strb.w	r3, [sp, #9]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023bfa:	f88d e00c 	strb.w	lr, [sp, #12]
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023bfe:	f88d 200a 	strb.w	r2, [sp, #10]

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023c02:	f88d 500b 	strb.w	r5, [sp, #11]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023c06:	f88d 700d 	strb.w	r7, [sp, #13]
 8023c0a:	f88d 600e 	strb.w	r6, [sp, #14]
 8023c0e:	f000 ff0b 	bl	8024a28 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 8023c12:	a802      	add	r0, sp, #8
 8023c14:	2107      	movs	r1, #7
 8023c16:	f000 ff1b 	bl	8024a50 <protocol_send_payload>
        protocol_send_tail();
 8023c1a:	f000 ff1b 	bl	8024a54 <protocol_send_tail>
    switch (message_data[0])
    {
    case MSG_GET_CONFIGURATION:
        if (num_bytes == 1)
        {
            return send_adc_configuration(endpoint, radar_driver);
 8023c1e:	e7ae      	b.n	8023b7e <ep_radar_adcxmc_handle_message+0x12>
 8023c20:	1ffe8cfc 	.word	0x1ffe8cfc

08023c24 <ep_radar_adcxmc_handle_change>:
void ep_radar_adcxmc_handle_change(uint8_t endpoint, void* context,
                                   uint32_t what)
{
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    if (what == EP_RADAR_CHNG_ADC_SETTINGS)
 8023c24:	2a04      	cmp	r2, #4
 8023c26:	d000      	beq.n	8023c2a <ep_radar_adcxmc_handle_change+0x6>
 8023c28:	4770      	bx	lr
    return PROTOCOL_STATUS_INVALID_PAYLOAD;
}

void ep_radar_adcxmc_handle_change(uint8_t endpoint, void* context,
                                   uint32_t what)
{
 8023c2a:	b5f0      	push	{r4, r5, r6, r7, lr}
                                       Radar_Handle_t radar_driver)
{
    uint16_t error_code;
    Adc_Configuration_t adc_configuration;

    adc_endpoint = endpoint;
 8023c2c:	4b15      	ldr	r3, [pc, #84]	; (8023c84 <ep_radar_adcxmc_handle_change+0x60>)
    return PROTOCOL_STATUS_INVALID_PAYLOAD;
}

void ep_radar_adcxmc_handle_change(uint8_t endpoint, void* context,
                                   uint32_t what)
{
 8023c2e:	b085      	sub	sp, #20
 8023c30:	4604      	mov	r4, r0
    Adc_Configuration_t adc_configuration;

    adc_endpoint = endpoint;

    /* read ADC configuration from device */
    error_code = radar_get_adc_configuration(radar_driver,
 8023c32:	4608      	mov	r0, r1
 8023c34:	a902      	add	r1, sp, #8
                                       Radar_Handle_t radar_driver)
{
    uint16_t error_code;
    Adc_Configuration_t adc_configuration;

    adc_endpoint = endpoint;
 8023c36:	701c      	strb	r4, [r3, #0]

    /* read ADC configuration from device */
    error_code = radar_get_adc_configuration(radar_driver,
 8023c38:	f7fc fc38 	bl	80204ac <radar_get_adc_configuration>
                                             &adc_configuration);

    if (error_code == RADAR_ERR_OK)
 8023c3c:	bb00      	cbnz	r0, 8023c80 <ep_radar_adcxmc_handle_change+0x5c>
    {
        uint8_t message[7];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_CONFIGURATION);
        wr_payload_u32(message, 1, adc_configuration.samplerate_Hz);
 8023c3e:	9b02      	ldr	r3, [sp, #8]
 8023c40:	f89d 200d 	ldrb.w	r2, [sp, #13]
 8023c44:	f89d 500c 	ldrb.w	r5, [sp, #12]
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8023c48:	f88d 3001 	strb.w	r3, [sp, #1]
        wr_payload_u8 (message, 5, adc_configuration.resolution);
        wr_payload_u8 (message, 6, adc_configuration.use_post_calibration);

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 8023c4c:	4620      	mov	r0, r4
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023c4e:	0e1f      	lsrs	r7, r3, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023c50:	0c1e      	lsrs	r6, r3, #16
 8023c52:	2107      	movs	r1, #7
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023c54:	0a1b      	lsrs	r3, r3, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023c56:	2401      	movs	r4, #1
static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023c58:	f88d 3002 	strb.w	r3, [sp, #2]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023c5c:	f88d 2006 	strb.w	r2, [sp, #6]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023c60:	f88d 7004 	strb.w	r7, [sp, #4]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023c64:	f88d 6003 	strb.w	r6, [sp, #3]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023c68:	f88d 4000 	strb.w	r4, [sp]
 8023c6c:	f88d 5005 	strb.w	r5, [sp, #5]
 8023c70:	f000 feda 	bl	8024a28 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 8023c74:	4668      	mov	r0, sp
 8023c76:	2107      	movs	r1, #7
 8023c78:	f000 feea 	bl	8024a50 <protocol_send_payload>
        protocol_send_tail();
 8023c7c:	f000 feea 	bl	8024a54 <protocol_send_tail>
{
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    if (what == EP_RADAR_CHNG_ADC_SETTINGS)
        send_adc_configuration(endpoint, radar_driver);
}
 8023c80:	b005      	add	sp, #20
 8023c82:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8023c84:	1ffe8cfc 	.word	0x1ffe8cfc

08023c88 <ep_radar_base_handle_message>:
==============================================================================
*/

uint16_t ep_radar_base_handle_message(uint8_t endpoint, uint8_t* message_data,
                                      uint16_t num_bytes, void* context)
{
 8023c88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (message_data[0])
 8023c8c:	780e      	ldrb	r6, [r1, #0]
==============================================================================
*/

uint16_t ep_radar_base_handle_message(uint8_t endpoint, uint8_t* message_data,
                                      uint16_t num_bytes, void* context)
{
 8023c8e:	4680      	mov	r8, r0
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (message_data[0])
 8023c90:	1e70      	subs	r0, r6, #1
==============================================================================
*/

uint16_t ep_radar_base_handle_message(uint8_t endpoint, uint8_t* message_data,
                                      uint16_t num_bytes, void* context)
{
 8023c92:	b09f      	sub	sp, #124	; 0x7c
 8023c94:	4615      	mov	r5, r2
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (message_data[0])
 8023c96:	2841      	cmp	r0, #65	; 0x41
 8023c98:	d846      	bhi.n	8023d28 <ep_radar_base_handle_message+0xa0>
 8023c9a:	e8df f010 	tbh	[pc, r0, lsl #1]
 8023c9e:	004b      	.short	0x004b
 8023ca0:	01280116 	.word	0x01280116
 8023ca4:	00450045 	.word	0x00450045
 8023ca8:	00450045 	.word	0x00450045
 8023cac:	00450045 	.word	0x00450045
 8023cb0:	00450045 	.word	0x00450045
 8023cb4:	00450045 	.word	0x00450045
 8023cb8:	00450045 	.word	0x00450045
 8023cbc:	00450045 	.word	0x00450045
 8023cc0:	00450045 	.word	0x00450045
 8023cc4:	00450045 	.word	0x00450045
 8023cc8:	00450045 	.word	0x00450045
 8023ccc:	00450045 	.word	0x00450045
 8023cd0:	00450045 	.word	0x00450045
 8023cd4:	00450045 	.word	0x00450045
 8023cd8:	00450045 	.word	0x00450045
 8023cdc:	0045013f 	.word	0x0045013f
 8023ce0:	0045015d 	.word	0x0045015d
 8023ce4:	00450045 	.word	0x00450045
 8023ce8:	00450045 	.word	0x00450045
 8023cec:	00450045 	.word	0x00450045
 8023cf0:	00450045 	.word	0x00450045
 8023cf4:	00450045 	.word	0x00450045
 8023cf8:	00450045 	.word	0x00450045
 8023cfc:	004501c2 	.word	0x004501c2
 8023d00:	004501d8 	.word	0x004501d8
 8023d04:	00450201 	.word	0x00450201
 8023d08:	00450215 	.word	0x00450215
 8023d0c:	00450045 	.word	0x00450045
 8023d10:	00450045 	.word	0x00450045
 8023d14:	00450045 	.word	0x00450045
 8023d18:	00450045 	.word	0x00450045
 8023d1c:	027b023a 	.word	0x027b023a
 8023d20:	0042      	.short	0x0042

            return error_code;
        }
        break;
    case MSG_GET_FFT_INFO:
		if (num_bytes == 1)
 8023d22:	2d01      	cmp	r5, #1
 8023d24:	f000 8266 	beq.w	80241f4 <ep_radar_base_handle_message+0x56c>
		break;

    default:
        break;
    }
    return PROTOCOL_STATUS_INVALID_PAYLOAD;
 8023d28:	f64f 74ff 	movw	r4, #65535	; 0xffff
}
 8023d2c:	4620      	mov	r0, r4
 8023d2e:	b01f      	add	sp, #124	; 0x7c
 8023d30:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (message_data[0])
    {
    case MSG_GET_FRAME_DATA:
        if (num_bytes == 2)
 8023d34:	2d02      	cmp	r5, #2
 8023d36:	d1f7      	bne.n	8023d28 <ep_radar_base_handle_message+0xa0>
    uint16_t error_code;

    Frame_Info_t frame_info;

    /* get frame data */
    error_code = radar_get_frame(radar_driver, &frame_info, wait);
 8023d38:	784a      	ldrb	r2, [r1, #1]
 8023d3a:	4618      	mov	r0, r3
 8023d3c:	a917      	add	r1, sp, #92	; 0x5c
 8023d3e:	f7fc fd1f 	bl	8020780 <radar_get_frame>

    if (error_code == RADAR_ERR_OK)
 8023d42:	900b      	str	r0, [sp, #44]	; 0x2c
 8023d44:	2800      	cmp	r0, #0
 8023d46:	f040 80be 	bne.w	8023ec6 <ep_radar_base_handle_message+0x23e>
        uint8_t message_header[18];
        uint32_t sample_start = 0;

        uint32_t num_used_ant = 2;

        if (frame_info.adc_resolution == 12)
 8023d4a:	f89d 4075 	ldrb.w	r4, [sp, #117]	; 0x75
 8023d4e:	2c0c      	cmp	r4, #12
 8023d50:	f000 8314 	beq.w	802437c <ep_radar_base_handle_message+0x6f4>
 8023d54:	46a9      	mov	r9, r5
        uint32_t num_samples;
        uint32_t data_size;
        uint8_t message_header[18];
        uint32_t sample_start = 0;

        uint32_t num_used_ant = 2;
 8023d56:	4629      	mov	r1, r5
 8023d58:	f89d c074 	ldrb.w	ip, [sp, #116]	; 0x74

        /* send message containing frame data */
        uint32_t num_samples;
        uint32_t data_size;
        uint8_t message_header[18];
        uint32_t sample_start = 0;
 8023d5c:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8023d5e:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8023d60:	9a19      	ldr	r2, [sp, #100]	; 0x64
 8023d62:	f89d e077 	ldrb.w	lr, [sp, #119]	; 0x77
 8023d66:	f88d 9051 	strb.w	r9, [sp, #81]	; 0x51
        /* calculate size of data */
        /* calculate total number of bits and divide by 8 to get number of
           bytes. Always round upwards */
        num_samples = frame_info.num_chirps *
                      frame_info.num_samples_per_chirp *
                      num_used_ant *
 8023d6a:	f1be 0f00 	cmp.w	lr, #0
        wr_payload_u8 (message_header, 17, frame_info.interleaved_rx);

        /* calculate size of data */
        /* calculate total number of bits and divide by 8 to get number of
           bytes. Always round upwards */
        num_samples = frame_info.num_chirps *
 8023d6e:	fb02 f603 	mul.w	r6, r2, r3
                      frame_info.num_samples_per_chirp *
                      num_used_ant *
 8023d72:	bf0c      	ite	eq
 8023d74:	2001      	moveq	r0, #1
 8023d76:	2002      	movne	r0, #2

        /* calculate size of data */
        /* calculate total number of bits and divide by 8 to get number of
           bytes. Always round upwards */
        num_samples = frame_info.num_chirps *
                      frame_info.num_samples_per_chirp *
 8023d78:	fb01 f106 	mul.w	r1, r1, r6
        wr_payload_u8 (message_header, 17, frame_info.interleaved_rx);

        /* calculate size of data */
        /* calculate total number of bits and divide by 8 to get number of
           bytes. Always round upwards */
        num_samples = frame_info.num_chirps *
 8023d7c:	fb00 f601 	mul.w	r6, r0, r1
                      frame_info.num_samples_per_chirp *
                      num_used_ant *
                      (frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);

        data_size = num_samples * frame_info.adc_resolution;
 8023d80:	fb04 f006 	mul.w	r0, r4, r6
        data_size = (data_size >> 3) + ((data_size & 0x07) ? 1 : 0);
 8023d84:	f010 0107 	ands.w	r1, r0, #7
 8023d88:	bf18      	it	ne
 8023d8a:	2101      	movne	r1, #1
 8023d8c:	eb01 01d0 	add.w	r1, r1, r0, lsr #3
						(frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);
			}
        }
        /* setup message header */
        wr_payload_u8 (message_header,  0, MSG_FRAME_DATA);
        wr_payload_u32(message_header,  1, frame_info.frame_number);
 8023d90:	9818      	ldr	r0, [sp, #96]	; 0x60
 8023d92:	f88d c056 	strb.w	ip, [sp, #86]	; 0x56

        data_size = num_samples * frame_info.adc_resolution;
        data_size = (data_size >> 3) + ((data_size & 0x07) ? 1 : 0);

        /* send message header */
        protocol_send_header(endpoint, data_size + sizeof(message_header));
 8023d96:	b289      	uxth	r1, r1
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023d98:	ea4f 6910 	mov.w	r9, r0, lsr #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023d9c:	ea4f 4c10 	mov.w	ip, r0, lsr #16
 8023da0:	910e      	str	r1, [sp, #56]	; 0x38
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023da2:	f88d e057 	strb.w	lr, [sp, #87]	; 0x57
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8023da6:	f88d 0049 	strb.w	r0, [sp, #73]	; 0x49
static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023daa:	ea4f 2e10 	mov.w	lr, r0, lsr #8
 8023dae:	3112      	adds	r1, #18
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023db0:	0e10      	lsrs	r0, r2, #24
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023db2:	f89d 7076 	ldrb.w	r7, [sp, #118]	; 0x76
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8023db6:	f88d 204d 	strb.w	r2, [sp, #77]	; 0x4d
 8023dba:	b289      	uxth	r1, r1
 8023dbc:	f88d 3052 	strb.w	r3, [sp, #82]	; 0x52
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023dc0:	f88d 4058 	strb.w	r4, [sp, #88]	; 0x58
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023dc4:	f88d 904c 	strb.w	r9, [sp, #76]	; 0x4c
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023dc8:	f88d c04b 	strb.w	ip, [sp, #75]	; 0x4b
 8023dcc:	ea4f 4912 	mov.w	r9, r2, lsr #16
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023dd0:	ea4f 6c13 	mov.w	ip, r3, lsr #24
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023dd4:	0a12      	lsrs	r2, r2, #8
 8023dd6:	f88d e04a 	strb.w	lr, [sp, #74]	; 0x4a
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023dda:	f88d 0050 	strb.w	r0, [sp, #80]	; 0x50
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023dde:	ea4f 4e13 	mov.w	lr, r3, lsr #16
 8023de2:	4640      	mov	r0, r8
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023de4:	0a1b      	lsrs	r3, r3, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023de6:	2400      	movs	r4, #0
static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023de8:	f88d 204e 	strb.w	r2, [sp, #78]	; 0x4e
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023dec:	f88d c055 	strb.w	ip, [sp, #85]	; 0x55
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023df0:	f88d e054 	strb.w	lr, [sp, #84]	; 0x54
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023df4:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023df8:	f88d 4048 	strb.w	r4, [sp, #72]	; 0x48

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023dfc:	f88d 904f 	strb.w	r9, [sp, #79]	; 0x4f
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023e00:	f88d 7059 	strb.w	r7, [sp, #89]	; 0x59
 8023e04:	f000 fe10 	bl	8024a28 <protocol_send_header>
        protocol_send_payload(message_header, sizeof(message_header));
 8023e08:	a812      	add	r0, sp, #72	; 0x48
 8023e0a:	2112      	movs	r1, #18
 8023e0c:	f000 fe20 	bl	8024a50 <protocol_send_payload>

        if (frame_info.adc_resolution == 12)
 8023e10:	f89d a075 	ldrb.w	sl, [sp, #117]	; 0x75
 8023e14:	f1ba 0f0c 	cmp.w	sl, #12
 8023e18:	f000 8223 	beq.w	8024262 <ep_radar_base_handle_message+0x5da>
			protocol_send_payload((uint8_t*)transport_buffer, data_size);
        }

        else
        {
             uint16_t sample_bit_mask = (1 << frame_info.adc_resolution) - 1;
 8023e1c:	2701      	movs	r7, #1
 8023e1e:	fa07 f70a 	lsl.w	r7, r7, sl
 8023e22:	3f01      	subs	r7, #1
 			 uint16_t sample_bit_stream = 0;
 8023e24:	f8ad 4040 	strh.w	r4, [sp, #64]	; 0x40
			protocol_send_payload((uint8_t*)transport_buffer, data_size);
        }

        else
        {
             uint16_t sample_bit_mask = (1 << frame_info.adc_resolution) - 1;
 8023e28:	b2bf      	uxth	r7, r7
 			 uint16_t sample_bit_stream = 0;
			 uint16_t write_bit_position = 0;

			 for (unsigned i = 0; i < num_samples; ++i)
 8023e2a:	b33e      	cbz	r6, 8023e7c <ep_radar_base_handle_message+0x1f4>
 8023e2c:	006d      	lsls	r5, r5, #1
 8023e2e:	4622      	mov	r2, r4
 8023e30:	46a1      	mov	r9, r4
 8023e32:	e001      	b.n	8023e38 <ep_radar_base_handle_message+0x1b0>
 8023e34:	f89d a075 	ldrb.w	sl, [sp, #117]	; 0x75
			 {
				const uint16_t* unpacked_data = &((uint16_t*)frame_info.sample_data)[sample_start];
				 sample_bit_stream |= (unpacked_data[i] & sample_bit_mask) <<
 8023e38:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8023e3a:	5b5b      	ldrh	r3, [r3, r5]
 8023e3c:	403b      	ands	r3, r7
									   write_bit_position;
				 write_bit_position += frame_info.adc_resolution;
 8023e3e:	4492      	add	sl, r2
			 uint16_t write_bit_position = 0;

			 for (unsigned i = 0; i < num_samples; ++i)
			 {
				const uint16_t* unpacked_data = &((uint16_t*)frame_info.sample_data)[sample_start];
				 sample_bit_stream |= (unpacked_data[i] & sample_bit_mask) <<
 8023e40:	4093      	lsls	r3, r2
 8023e42:	431c      	orrs	r4, r3
									   write_bit_position;
				 write_bit_position += frame_info.adc_resolution;

				 protocol_send_payload((uint8_t*)&sample_bit_stream,
 8023e44:	f3ca 01cf 	ubfx	r1, sl, #3, #16
 8023e48:	a810      	add	r0, sp, #64	; 0x40
			 uint16_t write_bit_position = 0;

			 for (unsigned i = 0; i < num_samples; ++i)
			 {
				const uint16_t* unpacked_data = &((uint16_t*)frame_info.sample_data)[sample_start];
				 sample_bit_stream |= (unpacked_data[i] & sample_bit_mask) <<
 8023e4a:	f8ad 4040 	strh.w	r4, [sp, #64]	; 0x40
									   write_bit_position;
				 write_bit_position += frame_info.adc_resolution;

				 protocol_send_payload((uint8_t*)&sample_bit_stream,
 8023e4e:	f000 fdff 	bl	8024a50 <protocol_send_payload>
									   write_bit_position >> 3);
				 sample_bit_stream >>= write_bit_position & 0xF8;
 8023e52:	f8bd 4040 	ldrh.w	r4, [sp, #64]	; 0x40
 8023e56:	f00a 03f8 	and.w	r3, sl, #248	; 0xf8
 8023e5a:	411c      	asrs	r4, r3
        {
             uint16_t sample_bit_mask = (1 << frame_info.adc_resolution) - 1;
 			 uint16_t sample_bit_stream = 0;
			 uint16_t write_bit_position = 0;

			 for (unsigned i = 0; i < num_samples; ++i)
 8023e5c:	f109 0901 	add.w	r9, r9, #1
									   write_bit_position;
				 write_bit_position += frame_info.adc_resolution;

				 protocol_send_payload((uint8_t*)&sample_bit_stream,
									   write_bit_position >> 3);
				 sample_bit_stream >>= write_bit_position & 0xF8;
 8023e60:	b2a4      	uxth	r4, r4
        {
             uint16_t sample_bit_mask = (1 << frame_info.adc_resolution) - 1;
 			 uint16_t sample_bit_stream = 0;
			 uint16_t write_bit_position = 0;

			 for (unsigned i = 0; i < num_samples; ++i)
 8023e62:	45b1      	cmp	r9, r6
 8023e64:	f105 0502 	add.w	r5, r5, #2
				 write_bit_position += frame_info.adc_resolution;

				 protocol_send_payload((uint8_t*)&sample_bit_stream,
									   write_bit_position >> 3);
				 sample_bit_stream >>= write_bit_position & 0xF8;
				 write_bit_position &= 0x07;
 8023e68:	f00a 0207 	and.w	r2, sl, #7
									   write_bit_position;
				 write_bit_position += frame_info.adc_resolution;

				 protocol_send_payload((uint8_t*)&sample_bit_stream,
									   write_bit_position >> 3);
				 sample_bit_stream >>= write_bit_position & 0xF8;
 8023e6c:	f8ad 4040 	strh.w	r4, [sp, #64]	; 0x40
        {
             uint16_t sample_bit_mask = (1 << frame_info.adc_resolution) - 1;
 			 uint16_t sample_bit_stream = 0;
			 uint16_t write_bit_position = 0;

			 for (unsigned i = 0; i < num_samples; ++i)
 8023e70:	d1e0      	bne.n	8023e34 <ep_radar_base_handle_message+0x1ac>
				 protocol_send_payload((uint8_t*)&sample_bit_stream,
									   write_bit_position >> 3);
				 sample_bit_stream >>= write_bit_position & 0xF8;
				 write_bit_position &= 0x07;
			 }
			 if (write_bit_position != 0)
 8023e72:	b11a      	cbz	r2, 8023e7c <ep_radar_base_handle_message+0x1f4>
				 protocol_send_payload((uint8_t*)&sample_bit_stream, 1);
 8023e74:	a810      	add	r0, sp, #64	; 0x40
 8023e76:	2101      	movs	r1, #1
 8023e78:	f000 fdea 	bl	8024a50 <protocol_send_payload>

        /* send another message, containing the temperature */
        {
            // Send the temperature, only when the value is changing!
        	static int32_t previous_temp = 0;
            if( frame_info.temperature_001C != previous_temp )
 8023e7c:	4cc4      	ldr	r4, [pc, #784]	; (8024190 <ep_radar_base_handle_message+0x508>)
			 if (write_bit_position != 0)
				 protocol_send_payload((uint8_t*)&sample_bit_stream, 1);
        }


        protocol_send_tail();
 8023e7e:	f000 fde9 	bl	8024a54 <protocol_send_tail>

        /* send another message, containing the temperature */
        {
            // Send the temperature, only when the value is changing!
        	static int32_t previous_temp = 0;
            if( frame_info.temperature_001C != previous_temp )
 8023e82:	6822      	ldr	r2, [r4, #0]
 8023e84:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8023e86:	4293      	cmp	r3, r2
 8023e88:	d01d      	beq.n	8023ec6 <ep_radar_base_handle_message+0x23e>
}

static inline void wr_payload_i32(uint8_t* payload, uint16_t offset,
                                  int32_t value)
{
    payload[offset + 3] = (((uint32_t)value) >> 24) & 0xFF;
 8023e8a:	0e1e      	lsrs	r6, r3, #24
    payload[offset + 2] = (((uint32_t)value) >> 16) & 0xFF;
 8023e8c:	0c1d      	lsrs	r5, r3, #16
    payload[offset + 1] = (((uint32_t)value) >>  8) & 0xFF;
 8023e8e:	0a1a      	lsrs	r2, r3, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023e90:	f04f 0e31 	mov.w	lr, #49	; 0x31
				wr_payload_u8 (message, 0, MSG_SET_TEMPRATURE);
				wr_payload_u8 (message, 1, 0);
				wr_payload_i32(message, 2, frame_info.temperature_001C);

				/* send message */
				protocol_send_header(endpoint, sizeof(message));
 8023e94:	4640      	mov	r0, r8
 8023e96:	2106      	movs	r1, #6
 8023e98:	2700      	movs	r7, #0
                                  int32_t value)
{
    payload[offset + 3] = (((uint32_t)value) >> 24) & 0xFF;
    payload[offset + 2] = (((uint32_t)value) >> 16) & 0xFF;
    payload[offset + 1] = (((uint32_t)value) >>  8) & 0xFF;
    payload[offset    ] =  ((uint32_t)value)        & 0xFF;
 8023e9a:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023e9e:	f88d e040 	strb.w	lr, [sp, #64]	; 0x40
static inline void wr_payload_i32(uint8_t* payload, uint16_t offset,
                                  int32_t value)
{
    payload[offset + 3] = (((uint32_t)value) >> 24) & 0xFF;
    payload[offset + 2] = (((uint32_t)value) >> 16) & 0xFF;
    payload[offset + 1] = (((uint32_t)value) >>  8) & 0xFF;
 8023ea2:	f88d 2043 	strb.w	r2, [sp, #67]	; 0x43
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023ea6:	f88d 7041 	strb.w	r7, [sp, #65]	; 0x41
}

static inline void wr_payload_i32(uint8_t* payload, uint16_t offset,
                                  int32_t value)
{
    payload[offset + 3] = (((uint32_t)value) >> 24) & 0xFF;
 8023eaa:	f88d 6045 	strb.w	r6, [sp, #69]	; 0x45
    payload[offset + 2] = (((uint32_t)value) >> 16) & 0xFF;
 8023eae:	f88d 5044 	strb.w	r5, [sp, #68]	; 0x44
 8023eb2:	f000 fdb9 	bl	8024a28 <protocol_send_header>
				protocol_send_payload(message, sizeof(message));
 8023eb6:	a810      	add	r0, sp, #64	; 0x40
 8023eb8:	2106      	movs	r1, #6
 8023eba:	f000 fdc9 	bl	8024a50 <protocol_send_payload>
				protocol_send_tail();
 8023ebe:	f000 fdc9 	bl	8024a54 <protocol_send_tail>
				previous_temp = frame_info.temperature_001C;
 8023ec2:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8023ec4:	6023      	str	r3, [r4, #0]
    uint16_t error_code;

    Frame_Info_t frame_info;

    /* get frame data */
    error_code = radar_get_frame(radar_driver, &frame_info, wait);
 8023ec6:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
            uint8_t wait;

            /* extract parameters from message */
            wait = rd_payload_u8(message_data, 1);

            return send_frame_data(endpoint, radar_driver, wait);
 8023ec8:	e730      	b.n	8023d2c <ep_radar_base_handle_message+0xa4>
        }
        break;

    case MSG_SET_AUTOMATIC_TRIGGER:
        if (num_bytes == 5)
 8023eca:	2d05      	cmp	r5, #5
 8023ecc:	f47f af2c 	bne.w	8023d28 <ep_radar_base_handle_message+0xa0>
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 8023ed0:	78ca      	ldrb	r2, [r1, #3]
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 8023ed2:	790c      	ldrb	r4, [r1, #4]
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
            ((uint32_t)payload[offset    ]);
 8023ed4:	7848      	ldrb	r0, [r1, #1]

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 8023ed6:	7889      	ldrb	r1, [r1, #2]
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 8023ed8:	0412      	lsls	r2, r2, #16
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 8023eda:	ea42 6204 	orr.w	r2, r2, r4, lsl #24
 8023ede:	4302      	orrs	r2, r0

            /* extract parameters from message */
            frame_interval = rd_payload_u32(message_data, 1);

            /* apply new settings */
            error_code = radar_set_automatic_frame_trigger(radar_driver,
 8023ee0:	ea42 2101 	orr.w	r1, r2, r1, lsl #8
 8023ee4:	4618      	mov	r0, r3
 8023ee6:	f7fc fc97 	bl	8020818 <radar_set_automatic_frame_trigger>
 8023eea:	4604      	mov	r4, r0
                                                           frame_interval);

            return error_code;
 8023eec:	e71e      	b.n	8023d2c <ep_radar_base_handle_message+0xa4>
        }
        break;

    case MSG_ENABLE_TEST_MODE:
        if (num_bytes == 8)
 8023eee:	2d08      	cmp	r5, #8
 8023ef0:	f47f af1a 	bne.w	8023d28 <ep_radar_base_handle_message+0xa0>
           (((uint32_t)payload[offset + 2]) << 16) |
 8023ef4:	7948      	ldrb	r0, [r1, #5]
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 8023ef6:	798f      	ldrb	r7, [r1, #6]
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
            ((uint32_t)payload[offset    ]);
 8023ef8:	78cc      	ldrb	r4, [r1, #3]

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 8023efa:	790e      	ldrb	r6, [r1, #4]
            rx_mask   = rd_payload_u8 (message_data, 2);
            frequency = rd_payload_u32(message_data, 3);
            tx_power  = rd_payload_u8 (message_data, 7);

            /* apply new settings */
            error_code = radar_test_antennas(radar_driver, tx_mask, rx_mask,
 8023efc:	784d      	ldrb	r5, [r1, #1]
 8023efe:	788a      	ldrb	r2, [r1, #2]
 8023f00:	79c9      	ldrb	r1, [r1, #7]
 8023f02:	9100      	str	r1, [sp, #0]
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 8023f04:	0400      	lsls	r0, r0, #16
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 8023f06:	ea40 6007 	orr.w	r0, r0, r7, lsl #24
 8023f0a:	4304      	orrs	r4, r0
 8023f0c:	4629      	mov	r1, r5
 8023f0e:	4618      	mov	r0, r3
 8023f10:	ea44 2306 	orr.w	r3, r4, r6, lsl #8
 8023f14:	f7fc fcd8 	bl	80208c8 <radar_test_antennas>
 8023f18:	4604      	mov	r4, r0
                                             frequency, tx_power);

            return error_code;
 8023f1a:	e707      	b.n	8023d2c <ep_radar_base_handle_message+0xa4>
        }
        break;

    case MSG_GET_DRIVER_VERSION:
        if (num_bytes == 1)
 8023f1c:	2d01      	cmp	r5, #1
 8023f1e:	f47f af03 	bne.w	8023d28 <ep_radar_base_handle_message+0xa0>
==============================================================================
*/

static void send_driver_version(uint8_t endpoint)
{
    const Driver_Version_t* driver_version = radar_get_driver_version();
 8023f22:	f7fc facd 	bl	80204c0 <radar_get_driver_version>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023f26:	2221      	movs	r2, #33	; 0x21
 8023f28:	f88d 205c 	strb.w	r2, [sp, #92]	; 0x5c

    uint8_t message[4];

    /* compile message */
    wr_payload_u8(message, 0, MSG_SET_DRIVER_VERSION);
    wr_payload_u8(message, 1, driver_version->major);
 8023f2c:	7802      	ldrb	r2, [r0, #0]
 8023f2e:	f88d 205d 	strb.w	r2, [sp, #93]	; 0x5d
    wr_payload_u8(message, 2, driver_version->minor);
 8023f32:	7842      	ldrb	r2, [r0, #1]
 8023f34:	f88d 205e 	strb.w	r2, [sp, #94]	; 0x5e
==============================================================================
*/

static void send_driver_version(uint8_t endpoint)
{
    const Driver_Version_t* driver_version = radar_get_driver_version();
 8023f38:	4603      	mov	r3, r0
    wr_payload_u8(message, 1, driver_version->major);
    wr_payload_u8(message, 2, driver_version->minor);
    wr_payload_u8(message, 3, driver_version->revision);

    /* send message */
    protocol_send_header(endpoint, sizeof(message));
 8023f3a:	2104      	movs	r1, #4

    /* compile message */
    wr_payload_u8(message, 0, MSG_SET_DRIVER_VERSION);
    wr_payload_u8(message, 1, driver_version->major);
    wr_payload_u8(message, 2, driver_version->minor);
    wr_payload_u8(message, 3, driver_version->revision);
 8023f3c:	789b      	ldrb	r3, [r3, #2]
 8023f3e:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f

    /* send message */
    protocol_send_header(endpoint, sizeof(message));
 8023f42:	4640      	mov	r0, r8
 8023f44:	f000 fd70 	bl	8024a28 <protocol_send_header>
    protocol_send_payload(message, sizeof(message));
 8023f48:	a817      	add	r0, sp, #92	; 0x5c
 8023f4a:	2104      	movs	r1, #4
 8023f4c:	f000 fd80 	bl	8024a50 <protocol_send_payload>
        if (num_bytes == 1)
        {
            /* send driver version info back to host */
            send_driver_version(endpoint);

            return RADAR_ERR_OK;
 8023f50:	2400      	movs	r4, #0
    wr_payload_u8(message, 3, driver_version->revision);

    /* send message */
    protocol_send_header(endpoint, sizeof(message));
    protocol_send_payload(message, sizeof(message));
    protocol_send_tail();
 8023f52:	f000 fd7f 	bl	8024a54 <protocol_send_tail>
 8023f56:	e6e9      	b.n	8023d2c <ep_radar_base_handle_message+0xa4>
            return RADAR_ERR_OK;
        }
        break;

    case MSG_GET_DEVICE_INFO:
        if (num_bytes == 1)
 8023f58:	2d01      	cmp	r5, #1
 8023f5a:	f47f aee5 	bne.w	8023d28 <ep_radar_base_handle_message+0xa0>
{
    uint16_t error_code;
    Device_Info_t device_info;

    /* read device info from device */
    error_code = radar_get_device_info(radar_driver, &device_info);
 8023f5e:	4618      	mov	r0, r3
 8023f60:	a917      	add	r1, sp, #92	; 0x5c
 8023f62:	f7fc fb29 	bl	80205b8 <radar_get_device_info>

    if (error_code == RADAR_ERR_OK)
 8023f66:	4604      	mov	r4, r0
 8023f68:	2800      	cmp	r0, #0
 8023f6a:	f47f aedf 	bne.w	8023d2c <ep_radar_base_handle_message+0xa4>
        uint16_t string_length;
        uint8_t message[17];

        /* compile message */
        wr_payload_u8 (message,  0, MSG_SET_DEVICE_INFO);
        wr_payload_u32(message,  1, device_info.min_rf_frequency_kHz);
 8023f6e:	9918      	ldr	r1, [sp, #96]	; 0x60
        wr_payload_u32(message,  5, device_info.max_rf_frequency_kHz);
 8023f70:	9b19      	ldr	r3, [sp, #100]	; 0x64
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8023f72:	f88d 1049 	strb.w	r1, [sp, #73]	; 0x49
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023f76:	ea4f 6b11 	mov.w	fp, r1, lsr #24
 8023f7a:	f88d b04c 	strb.w	fp, [sp, #76]	; 0x4c
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023f7e:	ea4f 4b11 	mov.w	fp, r1, lsr #16
 8023f82:	f88d b04b 	strb.w	fp, [sp, #75]	; 0x4b
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023f86:	0a09      	lsrs	r1, r1, #8
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023f88:	ea4f 6b13 	mov.w	fp, r3, lsr #24
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023f8c:	f89d 506e 	ldrb.w	r5, [sp, #110]	; 0x6e
static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023f90:	f88d 104a 	strb.w	r1, [sp, #74]	; 0x4a
    payload[offset    ] =  value        & 0xFF;
 8023f94:	f88d 304d 	strb.w	r3, [sp, #77]	; 0x4d

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023f98:	0c19      	lsrs	r1, r3, #16
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023f9a:	f88d b050 	strb.w	fp, [sp, #80]	; 0x50
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023f9e:	0a1b      	lsrs	r3, r3, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023fa0:	f89d a068 	ldrb.w	sl, [sp, #104]	; 0x68
 8023fa4:	f89d 9069 	ldrb.w	r9, [sp, #105]	; 0x69
 8023fa8:	f89d c06a 	ldrb.w	ip, [sp, #106]	; 0x6a
 8023fac:	f89d e06b 	ldrb.w	lr, [sp, #107]	; 0x6b
 8023fb0:	f89d 706c 	ldrb.w	r7, [sp, #108]	; 0x6c
 8023fb4:	f89d 606d 	ldrb.w	r6, [sp, #109]	; 0x6d
 8023fb8:	f89d 006f 	ldrb.w	r0, [sp, #111]	; 0x6f
        wr_payload_u8 (message, 15, device_info.interleaved_rx);
        wr_payload_u8 (message, 16, device_info.data_format);

        /* count string length (add 1 for the terminating 0) */
        string_length = 0;
        while (device_info.description[string_length] != 0)
 8023fbc:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8023fbe:	f88d 5057 	strb.w	r5, [sp, #87]	; 0x57
 8023fc2:	f04f 0b23 	mov.w	fp, #35	; 0x23

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023fc6:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023fca:	f88d 304e 	strb.w	r3, [sp, #78]	; 0x4e
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023fce:	f88d b048 	strb.w	fp, [sp, #72]	; 0x48
 8023fd2:	f88d a051 	strb.w	sl, [sp, #81]	; 0x51
 8023fd6:	f88d 9052 	strb.w	r9, [sp, #82]	; 0x52
 8023fda:	f88d c053 	strb.w	ip, [sp, #83]	; 0x53
 8023fde:	f88d e054 	strb.w	lr, [sp, #84]	; 0x54
 8023fe2:	f88d 7055 	strb.w	r7, [sp, #85]	; 0x55
 8023fe6:	f88d 6056 	strb.w	r6, [sp, #86]	; 0x56
 8023fea:	f88d 0058 	strb.w	r0, [sp, #88]	; 0x58
 8023fee:	7813      	ldrb	r3, [r2, #0]
 8023ff0:	4625      	mov	r5, r4
 8023ff2:	b123      	cbz	r3, 8023ffe <ep_radar_base_handle_message+0x376>
            ++string_length;
 8023ff4:	3501      	adds	r5, #1
 8023ff6:	b2ad      	uxth	r5, r5
        wr_payload_u8 (message, 15, device_info.interleaved_rx);
        wr_payload_u8 (message, 16, device_info.data_format);

        /* count string length (add 1 for the terminating 0) */
        string_length = 0;
        while (device_info.description[string_length] != 0)
 8023ff8:	5d53      	ldrb	r3, [r2, r5]
 8023ffa:	2b00      	cmp	r3, #0
 8023ffc:	d1fa      	bne.n	8023ff4 <ep_radar_base_handle_message+0x36c>
            ++string_length;
        ++string_length;

        /* send message */
        protocol_send_header(endpoint, sizeof(message) + string_length);
 8023ffe:	f105 0112 	add.w	r1, r5, #18
 8024002:	4640      	mov	r0, r8
 8024004:	b289      	uxth	r1, r1
 8024006:	f000 fd0f 	bl	8024a28 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 802400a:	a812      	add	r0, sp, #72	; 0x48
 802400c:	2111      	movs	r1, #17
 802400e:	f000 fd1f 	bl	8024a50 <protocol_send_payload>

        /* count string length (add 1 for the terminating 0) */
        string_length = 0;
        while (device_info.description[string_length] != 0)
            ++string_length;
        ++string_length;
 8024012:	1c69      	adds	r1, r5, #1

        /* send message */
        protocol_send_header(endpoint, sizeof(message) + string_length);
        protocol_send_payload(message, sizeof(message));
        protocol_send_payload((const uint8_t*)device_info.description,
 8024014:	b289      	uxth	r1, r1
 8024016:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8024018:	f000 fd1a 	bl	8024a50 <protocol_send_payload>
                              string_length);
        protocol_send_tail();
 802401c:	f000 fd1a 	bl	8024a54 <protocol_send_tail>
        break;

    case MSG_GET_DEVICE_INFO:
        if (num_bytes == 1)
        {
            return send_device_info(endpoint, radar_driver);
 8024020:	e684      	b.n	8023d2c <ep_radar_base_handle_message+0xa4>
        }
        break;

    case MSG_GET_TEMPRATURE:
    if (num_bytes == 2)
 8024022:	2d02      	cmp	r5, #2
 8024024:	f47f ae80 	bne.w	8023d28 <ep_radar_base_handle_message+0xa0>
 *
 * \return The function returns the value read from the payload.
 */
static inline uint8_t rd_payload_u8(const uint8_t* payload, uint16_t offset)
{
    return payload[offset];
 8024028:	784d      	ldrb	r5, [r1, #1]
{
    uint16_t error_code;
    int32_t temperature;

    /* read temperature value */
    error_code = radar_get_temperature(radar_driver, temp_sensor,
 802402a:	4618      	mov	r0, r3
 802402c:	4629      	mov	r1, r5
 802402e:	aa12      	add	r2, sp, #72	; 0x48
 8024030:	f7fc face 	bl	80205d0 <radar_get_temperature>
                                       &temperature);

    if (error_code == RADAR_ERR_OK)
 8024034:	4604      	mov	r4, r0
 8024036:	2800      	cmp	r0, #0
 8024038:	f47f ae78 	bne.w	8023d2c <ep_radar_base_handle_message+0xa4>
        uint8_t message[6];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_TEMPRATURE);
        wr_payload_u8 (message, 1, temp_sensor);
        wr_payload_i32(message, 2, temperature);
 802403c:	9b12      	ldr	r3, [sp, #72]	; 0x48
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802403e:	f88d 505d 	strb.w	r5, [sp, #93]	; 0x5d

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 8024042:	4640      	mov	r0, r8
}

static inline void wr_payload_i32(uint8_t* payload, uint16_t offset,
                                  int32_t value)
{
    payload[offset + 3] = (((uint32_t)value) >> 24) & 0xFF;
 8024044:	0e1f      	lsrs	r7, r3, #24
    payload[offset + 2] = (((uint32_t)value) >> 16) & 0xFF;
 8024046:	0c1e      	lsrs	r6, r3, #16
    payload[offset + 1] = (((uint32_t)value) >>  8) & 0xFF;
 8024048:	0a1d      	lsrs	r5, r3, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802404a:	2231      	movs	r2, #49	; 0x31
 802404c:	e014      	b.n	8024078 <ep_radar_base_handle_message+0x3f0>
            return send_temperature(endpoint, radar_driver, temp_sensor);
        }
        break;

    case MSG_GET_TX_POWER:
    if (num_bytes == 2)
 802404e:	2d02      	cmp	r5, #2
 8024050:	f47f ae6a 	bne.w	8023d28 <ep_radar_base_handle_message+0xa0>
 *
 * \return The function returns the value read from the payload.
 */
static inline uint8_t rd_payload_u8(const uint8_t* payload, uint16_t offset)
{
    return payload[offset];
 8024054:	784d      	ldrb	r5, [r1, #1]
{
    uint16_t error_code;
    int32_t tx_power;

    /* read TX power value value */
    error_code =  radar_get_tx_power(radar_driver, tx_antenna, &tx_power);
 8024056:	4618      	mov	r0, r3
 8024058:	4629      	mov	r1, r5
 802405a:	aa12      	add	r2, sp, #72	; 0x48
 802405c:	f7fc face 	bl	80205fc <radar_get_tx_power>

    if (error_code == RADAR_ERR_OK)
 8024060:	4604      	mov	r4, r0
 8024062:	2800      	cmp	r0, #0
 8024064:	f47f ae62 	bne.w	8023d2c <ep_radar_base_handle_message+0xa4>
        uint8_t message[6];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_TX_POWER);
        wr_payload_u8 (message, 1, tx_antenna);
        wr_payload_i32(message, 2, tx_power);
 8024068:	9b12      	ldr	r3, [sp, #72]	; 0x48
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802406a:	f88d 505d 	strb.w	r5, [sp, #93]	; 0x5d

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 802406e:	4640      	mov	r0, r8
}

static inline void wr_payload_i32(uint8_t* payload, uint16_t offset,
                                  int32_t value)
{
    payload[offset + 3] = (((uint32_t)value) >> 24) & 0xFF;
 8024070:	0e1f      	lsrs	r7, r3, #24
    payload[offset + 2] = (((uint32_t)value) >> 16) & 0xFF;
 8024072:	0c1e      	lsrs	r6, r3, #16
    payload[offset + 1] = (((uint32_t)value) >>  8) & 0xFF;
 8024074:	0a1d      	lsrs	r5, r3, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024076:	2233      	movs	r2, #51	; 0x33
 8024078:	2106      	movs	r1, #6
                                  int32_t value)
{
    payload[offset + 3] = (((uint32_t)value) >> 24) & 0xFF;
    payload[offset + 2] = (((uint32_t)value) >> 16) & 0xFF;
    payload[offset + 1] = (((uint32_t)value) >>  8) & 0xFF;
    payload[offset    ] =  ((uint32_t)value)        & 0xFF;
 802407a:	f88d 305e 	strb.w	r3, [sp, #94]	; 0x5e
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802407e:	f88d 205c 	strb.w	r2, [sp, #92]	; 0x5c
}

static inline void wr_payload_i32(uint8_t* payload, uint16_t offset,
                                  int32_t value)
{
    payload[offset + 3] = (((uint32_t)value) >> 24) & 0xFF;
 8024082:	f88d 7061 	strb.w	r7, [sp, #97]	; 0x61
    payload[offset + 2] = (((uint32_t)value) >> 16) & 0xFF;
 8024086:	f88d 6060 	strb.w	r6, [sp, #96]	; 0x60
    payload[offset + 1] = (((uint32_t)value) >>  8) & 0xFF;
 802408a:	f88d 505f 	strb.w	r5, [sp, #95]	; 0x5f
 802408e:	f000 fccb 	bl	8024a28 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 8024092:	a817      	add	r0, sp, #92	; 0x5c
 8024094:	2106      	movs	r1, #6
 8024096:	f000 fcdb 	bl	8024a50 <protocol_send_payload>
        protocol_send_tail();
 802409a:	f000 fcdb 	bl	8024a54 <protocol_send_tail>
            uint8_t tx_antenna;

            /* extract parameters from message */
            tx_antenna = rd_payload_u8(message_data, 1);

            return send_tx_power(endpoint, radar_driver, tx_antenna);
 802409e:	e645      	b.n	8023d2c <ep_radar_base_handle_message+0xa4>
        }
        break;

    case MSG_GET_CHRIP_DURATION:
    if (num_bytes == 1)
 80240a0:	2d01      	cmp	r5, #1
 80240a2:	f47f ae41 	bne.w	8023d28 <ep_radar_base_handle_message+0xa0>
{
    uint16_t error_code;
    uint32_t chirp_duration;

    /* read chirp duration */
    error_code = radar_get_chirp_duration(radar_driver, &chirp_duration);
 80240a6:	4618      	mov	r0, r3
 80240a8:	a912      	add	r1, sp, #72	; 0x48
 80240aa:	f7fc fabd 	bl	8020628 <radar_get_chirp_duration>

    if (error_code == RADAR_ERR_OK)
 80240ae:	4604      	mov	r4, r0
 80240b0:	2800      	cmp	r0, #0
 80240b2:	f47f ae3b 	bne.w	8023d2c <ep_radar_base_handle_message+0xa4>
    {
        uint8_t message[5];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_CHRIP_DURATION);
        wr_payload_u32(message, 1, chirp_duration);
 80240b6:	9b12      	ldr	r3, [sp, #72]	; 0x48
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 80240b8:	f88d 305d 	strb.w	r3, [sp, #93]	; 0x5d
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 80240bc:	0e1e      	lsrs	r6, r3, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 80240be:	0c1d      	lsrs	r5, r3, #16

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 80240c0:	4640      	mov	r0, r8
    payload[offset + 1] = (value >>  8) & 0xFF;
 80240c2:	0a1b      	lsrs	r3, r3, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80240c4:	2235      	movs	r2, #53	; 0x35
 80240c6:	e012      	b.n	80240ee <ep_radar_base_handle_message+0x466>
            return send_chirp_duration(endpoint, radar_driver);
        }
        break;

    case MSG_GET_MIN_INTERVAL:
    if (num_bytes == 1)
 80240c8:	2d01      	cmp	r5, #1
 80240ca:	f47f ae2d 	bne.w	8023d28 <ep_radar_base_handle_message+0xa0>
{
    uint16_t error_code;
    uint32_t min_frame_interval;

    /* read minimum frame interval */
    error_code = radar_get_min_frame_interval(radar_driver,
 80240ce:	4618      	mov	r0, r3
 80240d0:	a912      	add	r1, sp, #72	; 0x48
 80240d2:	f7fc fab5 	bl	8020640 <radar_get_min_frame_interval>
                                              &min_frame_interval);

    if (error_code == RADAR_ERR_OK)
 80240d6:	4604      	mov	r4, r0
 80240d8:	2800      	cmp	r0, #0
 80240da:	f47f ae27 	bne.w	8023d2c <ep_radar_base_handle_message+0xa4>
    {
        uint8_t message[5];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_MIN_INTERVAL);
        wr_payload_u32(message, 1, min_frame_interval);
 80240de:	9b12      	ldr	r3, [sp, #72]	; 0x48
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 80240e0:	f88d 305d 	strb.w	r3, [sp, #93]	; 0x5d
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 80240e4:	0e1e      	lsrs	r6, r3, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 80240e6:	0c1d      	lsrs	r5, r3, #16

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 80240e8:	4640      	mov	r0, r8
    payload[offset + 1] = (value >>  8) & 0xFF;
 80240ea:	0a1b      	lsrs	r3, r3, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80240ec:	2237      	movs	r2, #55	; 0x37
 80240ee:	2105      	movs	r1, #5
static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 80240f0:	f88d 305e 	strb.w	r3, [sp, #94]	; 0x5e
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80240f4:	f88d 205c 	strb.w	r2, [sp, #92]	; 0x5c
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 80240f8:	f88d 6060 	strb.w	r6, [sp, #96]	; 0x60
    payload[offset + 2] = (value >> 16) & 0xFF;
 80240fc:	f88d 505f 	strb.w	r5, [sp, #95]	; 0x5f
 8024100:	f000 fc92 	bl	8024a28 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 8024104:	a817      	add	r0, sp, #92	; 0x5c
 8024106:	2105      	movs	r1, #5
 8024108:	f000 fca2 	bl	8024a50 <protocol_send_payload>
        protocol_send_tail();
 802410c:	f000 fca2 	bl	8024a54 <protocol_send_tail>
        break;

    case MSG_GET_MIN_INTERVAL:
    if (num_bytes == 1)
        {
            return send_min_frame_interval(endpoint, radar_driver);
 8024110:	e60c      	b.n	8023d2c <ep_radar_base_handle_message+0xa4>
        }
        break;

    case MSG_GET_FRAME_FORMAT:
        if (num_bytes == 1)
 8024112:	2d01      	cmp	r5, #1
 8024114:	f47f ae08 	bne.w	8023d28 <ep_radar_base_handle_message+0xa0>
{
    uint16_t error_code;
    Frame_Format_t frame_format;

    /* get current frame format from radar driver */
    error_code = radar_get_frame_format(radar_driver, &frame_format);
 8024118:	4618      	mov	r0, r3
 802411a:	a917      	add	r1, sp, #92	; 0x5c
 802411c:	f7fc fb2a 	bl	8020774 <radar_get_frame_format>

    if (error_code == RADAR_ERR_OK)
 8024120:	4604      	mov	r4, r0
 8024122:	2800      	cmp	r0, #0
 8024124:	f47f ae02 	bne.w	8023d2c <ep_radar_base_handle_message+0xa4>
        uint8_t message[11];

        /* compile message */
        wr_payload_u8 (message,  0, MSG_SET_FRAME_FORMAT);
        wr_payload_u32(message,  1, frame_format.num_samples_per_chirp);
        wr_payload_u32(message,  5, frame_format.num_chirps_per_frame);
 8024128:	9a18      	ldr	r2, [sp, #96]	; 0x60
    {
        uint8_t message[11];

        /* compile message */
        wr_payload_u8 (message,  0, MSG_SET_FRAME_FORMAT);
        wr_payload_u32(message,  1, frame_format.num_samples_per_chirp);
 802412a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802412c:	f89d 6064 	ldrb.w	r6, [sp, #100]	; 0x64
 8024130:	f89d 5065 	ldrb.w	r5, [sp, #101]	; 0x65
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024134:	f88d 3049 	strb.w	r3, [sp, #73]	; 0x49

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024138:	ea4f 4c12 	mov.w	ip, r2, lsr #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 802413c:	ea4f 2e12 	mov.w	lr, r2, lsr #8
        wr_payload_u32(message,  5, frame_format.num_chirps_per_frame);
        wr_payload_u8 (message,  9, frame_format.rx_mask);
        wr_payload_u8 (message, 10, frame_format.signal_part);

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 8024140:	4640      	mov	r0, r8
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024142:	ea4f 6a13 	mov.w	sl, r3, lsr #24
 8024146:	ea4f 6812 	mov.w	r8, r2, lsr #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 802414a:	ea4f 4913 	mov.w	r9, r3, lsr #16
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802414e:	2741      	movs	r7, #65	; 0x41
static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024150:	0a1b      	lsrs	r3, r3, #8
 8024152:	210b      	movs	r1, #11
 8024154:	f88d 304a 	strb.w	r3, [sp, #74]	; 0x4a
    payload[offset    ] =  value        & 0xFF;
 8024158:	f88d 204d 	strb.w	r2, [sp, #77]	; 0x4d

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 802415c:	f88d c04f 	strb.w	ip, [sp, #79]	; 0x4f
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024160:	f88d e04e 	strb.w	lr, [sp, #78]	; 0x4e
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024164:	f88d a04c 	strb.w	sl, [sp, #76]	; 0x4c
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024168:	f88d 904b 	strb.w	r9, [sp, #75]	; 0x4b
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 802416c:	f88d 8050 	strb.w	r8, [sp, #80]	; 0x50
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024170:	f88d 7048 	strb.w	r7, [sp, #72]	; 0x48
 8024174:	f88d 6051 	strb.w	r6, [sp, #81]	; 0x51
 8024178:	f88d 5052 	strb.w	r5, [sp, #82]	; 0x52
 802417c:	f000 fc54 	bl	8024a28 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 8024180:	a812      	add	r0, sp, #72	; 0x48
 8024182:	210b      	movs	r1, #11
 8024184:	f000 fc64 	bl	8024a50 <protocol_send_payload>
        protocol_send_tail();
 8024188:	f000 fc64 	bl	8024a54 <protocol_send_tail>
        break;

    case MSG_GET_FRAME_FORMAT:
        if (num_bytes == 1)
        {
            return send_frame_format(endpoint, radar_driver);
 802418c:	e5ce      	b.n	8023d2c <ep_radar_base_handle_message+0xa4>
 802418e:	bf00      	nop
 8024190:	1ffe8d00 	.word	0x1ffe8d00
        }
        break;

    case MSG_SET_FRAME_FORMAT:
        if (num_bytes == 11)
 8024194:	2d0b      	cmp	r5, #11
 8024196:	f47f adc7 	bne.w	8023d28 <ep_radar_base_handle_message+0xa0>
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 802419a:	f891 c003 	ldrb.w	ip, [r1, #3]
 802419e:	79ce      	ldrb	r6, [r1, #7]
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 80241a0:	f891 8004 	ldrb.w	r8, [r1, #4]
 80241a4:	7a0a      	ldrb	r2, [r1, #8]
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
            ((uint32_t)payload[offset    ]);
 80241a6:	784d      	ldrb	r5, [r1, #1]
 80241a8:	7948      	ldrb	r0, [r1, #5]

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 80241aa:	f891 e006 	ldrb.w	lr, [r1, #6]
            Frame_Format_t format;

            /* extract parameters from message */
            format.num_samples_per_chirp = rd_payload_u32(message_data,  1);
            format.num_chirps_per_frame  = rd_payload_u32(message_data,  5);
            format.rx_mask               = rd_payload_u8 (message_data,  9);
 80241ae:	f891 9009 	ldrb.w	r9, [r1, #9]
            format.signal_part           = rd_payload_u8 (message_data, 10);
 80241b2:	7a8f      	ldrb	r7, [r1, #10]
 80241b4:	788c      	ldrb	r4, [r1, #2]

            /* apply new frame format */
            error_code = radar_set_frame_format(radar_driver, &format);
 80241b6:	9302      	str	r3, [sp, #8]
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 80241b8:	ea4f 410c 	mov.w	r1, ip, lsl #16
 80241bc:	0436      	lsls	r6, r6, #16
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 80241be:	ea41 6108 	orr.w	r1, r1, r8, lsl #24
 80241c2:	ea46 6202 	orr.w	r2, r6, r2, lsl #24
 80241c6:	4329      	orrs	r1, r5
 80241c8:	4302      	orrs	r2, r0
 80241ca:	ea41 2404 	orr.w	r4, r1, r4, lsl #8
 80241ce:	ea42 220e 	orr.w	r2, r2, lr, lsl #8
 80241d2:	a917      	add	r1, sp, #92	; 0x5c
 80241d4:	4618      	mov	r0, r3
        {
            unsigned error_code;
            Frame_Format_t format;

            /* extract parameters from message */
            format.num_samples_per_chirp = rd_payload_u32(message_data,  1);
 80241d6:	9417      	str	r4, [sp, #92]	; 0x5c
            format.num_chirps_per_frame  = rd_payload_u32(message_data,  5);
            format.rx_mask               = rd_payload_u8 (message_data,  9);
 80241d8:	f88d 9064 	strb.w	r9, [sp, #100]	; 0x64
            unsigned error_code;
            Frame_Format_t format;

            /* extract parameters from message */
            format.num_samples_per_chirp = rd_payload_u32(message_data,  1);
            format.num_chirps_per_frame  = rd_payload_u32(message_data,  5);
 80241dc:	9218      	str	r2, [sp, #96]	; 0x60
            format.rx_mask               = rd_payload_u8 (message_data,  9);
            format.signal_part           = rd_payload_u8 (message_data, 10);
 80241de:	f88d 7065 	strb.w	r7, [sp, #101]	; 0x65

            /* apply new frame format */
            error_code = radar_set_frame_format(radar_driver, &format);
 80241e2:	f7fc fa61 	bl	80206a8 <radar_set_frame_format>

            /* inform other endpoints of the change */
            protocol_broadcast_change(radar_driver,
 80241e6:	9b02      	ldr	r3, [sp, #8]
            format.num_chirps_per_frame  = rd_payload_u32(message_data,  5);
            format.rx_mask               = rd_payload_u8 (message_data,  9);
            format.signal_part           = rd_payload_u8 (message_data, 10);

            /* apply new frame format */
            error_code = radar_set_frame_format(radar_driver, &format);
 80241e8:	4604      	mov	r4, r0

            /* inform other endpoints of the change */
            protocol_broadcast_change(radar_driver,
 80241ea:	2101      	movs	r1, #1
 80241ec:	4618      	mov	r0, r3
 80241ee:	f000 fdf1 	bl	8024dd4 <protocol_broadcast_change>
 80241f2:	e59b      	b.n	8023d2c <ep_radar_base_handle_message+0xa4>
static uint16_t send_fft_config(uint8_t endpoint,
                                 Radar_Handle_t radar_driver)
{

	FFT_configuration_t fft_conf;
	radar_get_fft_configuration(radar_driver,&fft_conf);
 80241f4:	4618      	mov	r0, r3
 80241f6:	a917      	add	r1, sp, #92	; 0x5c
 80241f8:	f7fc fb6a 	bl	80208d0 <radar_get_fft_configuration>

	union {
			uint32_t  u32_value;
			float	  f32_value;
		} convert_helper;
	convert_helper.f32_value = fft_conf.scaling_factor;
 80241fc:	9a19      	ldr	r2, [sp, #100]	; 0x64

    uint8_t message[11];

	/* compile message */
	wr_payload_u8 (message,  0, MSG_SET_FFT_INFO);
	wr_payload_u32(message,  1, fft_conf.fft_window_size);
 80241fe:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024200:	f89d 4061 	ldrb.w	r4, [sp, #97]	; 0x61
 8024204:	f89d 5060 	ldrb.w	r5, [sp, #96]	; 0x60
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024208:	f88d 3049 	strb.w	r3, [sp, #73]	; 0x49
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 802420c:	ea4f 6e13 	mov.w	lr, r3, lsr #24
 8024210:	ea4f 6912 	mov.w	r9, r2, lsr #24
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024214:	ea4f 2c12 	mov.w	ip, r2, lsr #8
	wr_payload_u8(message,   5, (uint8_t)fft_conf.window_type);
	wr_payload_u8 (message,  6, fft_conf.mean_removed);
	wr_payload_u32(message,  7, convert_helper.u32_value);

	/* send message */
	protocol_send_header(endpoint, sizeof(message));
 8024218:	4640      	mov	r0, r8

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 802421a:	0c1f      	lsrs	r7, r3, #16
 802421c:	ea4f 4812 	mov.w	r8, r2, lsr #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024220:	0a1b      	lsrs	r3, r3, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024222:	2643      	movs	r6, #67	; 0x43
 8024224:	210b      	movs	r1, #11
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024226:	f88d 204f 	strb.w	r2, [sp, #79]	; 0x4f
static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 802422a:	f88d c050 	strb.w	ip, [sp, #80]	; 0x50
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 802422e:	f88d e04c 	strb.w	lr, [sp, #76]	; 0x4c
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024232:	f88d 304a 	strb.w	r3, [sp, #74]	; 0x4a
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024236:	f88d 404e 	strb.w	r4, [sp, #78]	; 0x4e
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 802423a:	f88d 9052 	strb.w	r9, [sp, #82]	; 0x52
    payload[offset + 2] = (value >> 16) & 0xFF;
 802423e:	f88d 8051 	strb.w	r8, [sp, #81]	; 0x51
 8024242:	f88d 704b 	strb.w	r7, [sp, #75]	; 0x4b
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024246:	f88d 6048 	strb.w	r6, [sp, #72]	; 0x48
 802424a:	f88d 504d 	strb.w	r5, [sp, #77]	; 0x4d
 802424e:	f000 fbeb 	bl	8024a28 <protocol_send_header>
	protocol_send_payload(message, sizeof(message));
 8024252:	a812      	add	r0, sp, #72	; 0x48
 8024254:	210b      	movs	r1, #11
 8024256:	f000 fbfb 	bl	8024a50 <protocol_send_payload>
        }
        break;
    case MSG_GET_FFT_INFO:
		if (num_bytes == 1)
		{
			return send_fft_config(endpoint, radar_driver);
 802425a:	2400      	movs	r4, #0
	wr_payload_u32(message,  7, convert_helper.u32_value);

	/* send message */
	protocol_send_header(endpoint, sizeof(message));
	protocol_send_payload(message, sizeof(message));
	protocol_send_tail();
 802425c:	f000 fbfa 	bl	8024a54 <protocol_send_tail>
        }
        break;
    case MSG_GET_FFT_INFO:
		if (num_bytes == 1)
		{
			return send_fft_config(endpoint, radar_driver);
 8024260:	e564      	b.n	8023d2c <ep_radar_base_handle_message+0xa4>
        if (frame_info.adc_resolution == 12)
        {
			uint8_t *destPtr = (uint8_t *)&transport_buffer[0];
			uint8_t *srcPtr  = (uint8_t *)frame_info.sample_data;

			uint32_t channel_inc = frame_info.num_samples_per_chirp*sizeof(uint16_t);
 8024262:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8024264:	9302      	str	r3, [sp, #8]
 8024266:	4619      	mov	r1, r3
			uint32_t chirp_inc   = channel_inc * frame_info.num_rx_antennas * (frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);
 8024268:	f89d 3077 	ldrb.w	r3, [sp, #119]	; 0x77
 802426c:	9308      	str	r3, [sp, #32]
 802426e:	4618      	mov	r0, r3
 8024270:	f89d 3068 	ldrb.w	r3, [sp, #104]	; 0x68
 8024274:	9304      	str	r3, [sp, #16]
 8024276:	461d      	mov	r5, r3

			uint32_t processed_out_bytes = 0;

			for(uint32_t chirp = 0; chirp < frame_info.num_chirps; chirp++)
 8024278:	9b19      	ldr	r3, [sp, #100]	; 0x64
 802427a:	930d      	str	r3, [sp, #52]	; 0x34
        {
			uint8_t *destPtr = (uint8_t *)&transport_buffer[0];
			uint8_t *srcPtr  = (uint8_t *)frame_info.sample_data;

			uint32_t channel_inc = frame_info.num_samples_per_chirp*sizeof(uint16_t);
			uint32_t chirp_inc   = channel_inc * frame_info.num_rx_antennas * (frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);
 802427c:	42a0      	cmp	r0, r4

			uint32_t processed_out_bytes = 0;

			for(uint32_t chirp = 0; chirp < frame_info.num_chirps; chirp++)
 802427e:	461e      	mov	r6, r3
        if (frame_info.adc_resolution == 12)
        {
			uint8_t *destPtr = (uint8_t *)&transport_buffer[0];
			uint8_t *srcPtr  = (uint8_t *)frame_info.sample_data;

			uint32_t channel_inc = frame_info.num_samples_per_chirp*sizeof(uint16_t);
 8024280:	ea4f 0941 	mov.w	r9, r1, lsl #1
        protocol_send_payload(message_header, sizeof(message_header));

        if (frame_info.adc_resolution == 12)
        {
			uint8_t *destPtr = (uint8_t *)&transport_buffer[0];
			uint8_t *srcPtr  = (uint8_t *)frame_info.sample_data;
 8024284:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8024286:	9307      	str	r3, [sp, #28]

			uint32_t channel_inc = frame_info.num_samples_per_chirp*sizeof(uint16_t);
			uint32_t chirp_inc   = channel_inc * frame_info.num_rx_antennas * (frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);
 8024288:	bf08      	it	eq
 802428a:	2201      	moveq	r2, #1
 802428c:	fb09 f305 	mul.w	r3, r9, r5
 8024290:	bf18      	it	ne
 8024292:	2202      	movne	r2, #2
 8024294:	fb02 f303 	mul.w	r3, r2, r3
 8024298:	930c      	str	r3, [sp, #48]	; 0x30

			uint32_t processed_out_bytes = 0;

			for(uint32_t chirp = 0; chirp < frame_info.num_chirps; chirp++)
 802429a:	2e00      	cmp	r6, #0
 802429c:	d04e      	beq.n	802433c <ep_radar_base_handle_message+0x6b4>
 802429e:	1e8b      	subs	r3, r1, #2
 80242a0:	085b      	lsrs	r3, r3, #1
 80242a2:	3301      	adds	r3, #1
 80242a4:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80242a8:	2901      	cmp	r1, #1
 80242aa:	9303      	str	r3, [sp, #12]
 80242ac:	bf98      	it	ls
 80242ae:	4623      	movls	r3, r4
 80242b0:	f011 0201 	ands.w	r2, r1, #1
 80242b4:	bf08      	it	eq
 80242b6:	469b      	moveq	fp, r3
 80242b8:	f8df e110 	ldr.w	lr, [pc, #272]	; 80243cc <ep_radar_base_handle_message+0x744>
 80242bc:	f89d 3074 	ldrb.w	r3, [sp, #116]	; 0x74
 80242c0:	f8cd 803c 	str.w	r8, [sp, #60]	; 0x3c
 80242c4:	9409      	str	r4, [sp, #36]	; 0x24
 80242c6:	bf18      	it	ne
 80242c8:	f04f 3bff 	movne.w	fp, #4294967295
 80242cc:	940a      	str	r4, [sp, #40]	; 0x28
 80242ce:	9305      	str	r3, [sp, #20]
 80242d0:	4690      	mov	r8, r2
			{
				for(uint32_t ant_idx= 0; ant_idx < frame_info.num_rx_antennas; ant_idx++)  // max Ant mask!
 80242d2:	9b04      	ldr	r3, [sp, #16]
 80242d4:	b333      	cbz	r3, 8024324 <ep_radar_base_handle_message+0x69c>
 80242d6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80242d8:	3304      	adds	r3, #4
 80242da:	f04f 0a00 	mov.w	sl, #0
 80242de:	9306      	str	r3, [sp, #24]
				{
					uint8_t mask = (1 << ant_idx);
 80242e0:	2301      	movs	r3, #1
					if( (mask & frame_info.rx_mask) != 0 )
 80242e2:	9a05      	ldr	r2, [sp, #20]

			for(uint32_t chirp = 0; chirp < frame_info.num_chirps; chirp++)
			{
				for(uint32_t ant_idx= 0; ant_idx < frame_info.num_rx_antennas; ant_idx++)  // max Ant mask!
				{
					uint8_t mask = (1 << ant_idx);
 80242e4:	fa03 f30a 	lsl.w	r3, r3, sl
					if( (mask & frame_info.rx_mask) != 0 )
 80242e8:	421a      	tst	r2, r3
 80242ea:	d016      	beq.n	802431a <ep_radar_base_handle_message+0x692>
					{
						uint32_t num_chan_per_ant = (frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);
 80242ec:	9b08      	ldr	r3, [sp, #32]
 80242ee:	2b00      	cmp	r3, #0
 80242f0:	9b06      	ldr	r3, [sp, #24]
 80242f2:	bf0c      	ite	eq
 80242f4:	f04f 0c01 	moveq.w	ip, #1
 80242f8:	f04f 0c02 	movne.w	ip, #2
 80242fc:	fb09 f70a 	mul.w	r7, r9, sl
 8024300:	fb0c 3707 	mla	r7, ip, r7, r3
 8024304:	9b07      	ldr	r3, [sp, #28]
						for(uint32_t ch_idx = 0; ch_idx < num_chan_per_ant; ch_idx++)
 8024306:	2600      	movs	r6, #0
 8024308:	441f      	add	r7, r3


static size_t packing_helper_12Bit( uint8_t *p_dest, uint16_t *p_src, size_t numSamples)
{
	/* numBytes needs to be devided by 2 */
	if( (numSamples & 1) != 0)
 802430a:	f1b8 0f00 	cmp.w	r8, #0
 802430e:	d01a      	beq.n	8024346 <ep_radar_base_handle_message+0x6be>
				{
					uint8_t mask = (1 << ant_idx);
					if( (mask & frame_info.rx_mask) != 0 )
					{
						uint32_t num_chan_per_ant = (frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);
						for(uint32_t ch_idx = 0; ch_idx < num_chan_per_ant; ch_idx++)
 8024310:	3601      	adds	r6, #1
 8024312:	4566      	cmp	r6, ip
						{
							uint32_t in_offset = (chirp_inc * chirp) + (channel_inc*(ant_idx*num_chan_per_ant + ch_idx ));
							size_t out_offset = packing_helper_12Bit(destPtr, (uint16_t *)&srcPtr[in_offset], frame_info.num_samples_per_chirp );
			
							destPtr += out_offset;
 8024314:	44de      	add	lr, fp
 8024316:	444f      	add	r7, r9
				{
					uint8_t mask = (1 << ant_idx);
					if( (mask & frame_info.rx_mask) != 0 )
					{
						uint32_t num_chan_per_ant = (frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);
						for(uint32_t ch_idx = 0; ch_idx < num_chan_per_ant; ch_idx++)
 8024318:	d1f7      	bne.n	802430a <ep_radar_base_handle_message+0x682>

			uint32_t processed_out_bytes = 0;

			for(uint32_t chirp = 0; chirp < frame_info.num_chirps; chirp++)
			{
				for(uint32_t ant_idx= 0; ant_idx < frame_info.num_rx_antennas; ant_idx++)  // max Ant mask!
 802431a:	9b04      	ldr	r3, [sp, #16]
 802431c:	f10a 0a01 	add.w	sl, sl, #1
 8024320:	4553      	cmp	r3, sl
 8024322:	d1dd      	bne.n	80242e0 <ep_radar_base_handle_message+0x658>
 8024324:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8024326:	990c      	ldr	r1, [sp, #48]	; 0x30
			uint32_t channel_inc = frame_info.num_samples_per_chirp*sizeof(uint16_t);
			uint32_t chirp_inc   = channel_inc * frame_info.num_rx_antennas * (frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);

			uint32_t processed_out_bytes = 0;

			for(uint32_t chirp = 0; chirp < frame_info.num_chirps; chirp++)
 8024328:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802432a:	440a      	add	r2, r1
 802432c:	9209      	str	r2, [sp, #36]	; 0x24
 802432e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8024330:	3301      	adds	r3, #1
 8024332:	4293      	cmp	r3, r2
 8024334:	930a      	str	r3, [sp, #40]	; 0x28
 8024336:	d1cc      	bne.n	80242d2 <ep_radar_base_handle_message+0x64a>
 8024338:	f8dd 803c 	ldr.w	r8, [sp, #60]	; 0x3c
						}
					}
				}
			}
			/* now send the packed data at once */
			protocol_send_payload((uint8_t*)transport_buffer, data_size);
 802433c:	990e      	ldr	r1, [sp, #56]	; 0x38
 802433e:	4823      	ldr	r0, [pc, #140]	; (80243cc <ep_radar_base_handle_message+0x744>)
 8024340:	f000 fb86 	bl	8024a50 <protocol_send_payload>
 8024344:	e59a      	b.n	8023e7c <ep_radar_base_handle_message+0x1f4>
	if( (numSamples & 1) != 0)
		return -1;

	size_t   processed_output_bytes = 0;

	while (numSamples >= 2)
 8024346:	9b02      	ldr	r3, [sp, #8]
 8024348:	2b01      	cmp	r3, #1
 802434a:	d9e1      	bls.n	8024310 <ep_radar_base_handle_message+0x688>
 802434c:	9b03      	ldr	r3, [sp, #12]
 802434e:	4639      	mov	r1, r7
 8024350:	eb0e 0503 	add.w	r5, lr, r3
 8024354:	4672      	mov	r2, lr
	{
		/* pack two samples into one 32 bit word */
		uint32_t packed_word;
		packed_word  = *p_src++;
		packed_word |= *p_src++ << 12;
 8024356:	f831 0c02 	ldrh.w	r0, [r1, #-2]

	while (numSamples >= 2)
	{
		/* pack two samples into one 32 bit word */
		uint32_t packed_word;
		packed_word  = *p_src++;
 802435a:	f831 3c04 	ldrh.w	r3, [r1, #-4]
		packed_word |= *p_src++ << 12;
 802435e:	ea43 3300 	orr.w	r3, r3, r0, lsl #12
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024362:	0e18      	lsrs	r0, r3, #24
 8024364:	70d0      	strb	r0, [r2, #3]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024366:	0c1c      	lsrs	r4, r3, #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024368:	0a18      	lsrs	r0, r3, #8

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 802436a:	7094      	strb	r4, [r2, #2]
    payload[offset + 1] = (value >>  8) & 0xFF;
 802436c:	7050      	strb	r0, [r2, #1]
    payload[offset    ] =  value        & 0xFF;
 802436e:	f802 3b03 	strb.w	r3, [r2], #3
	if( (numSamples & 1) != 0)
		return -1;

	size_t   processed_output_bytes = 0;

	while (numSamples >= 2)
 8024372:	42aa      	cmp	r2, r5
 8024374:	f101 0104 	add.w	r1, r1, #4
 8024378:	d1ed      	bne.n	8024356 <ep_radar_base_handle_message+0x6ce>
 802437a:	e7c9      	b.n	8024310 <ep_radar_base_handle_message+0x688>
        uint32_t num_used_ant = 2;

        if (frame_info.adc_resolution == 12)
        {
        	/* Selection of Antenna to output is currently only supported for 12 Bit ADC resolution! */
        	if( frame_info.rx_mask == 1 )
 802437c:	f89d c074 	ldrb.w	ip, [sp, #116]	; 0x74
 8024380:	f1bc 0f01 	cmp.w	ip, #1
 8024384:	46e1      	mov	r9, ip
 8024386:	d00a      	beq.n	802439e <ep_radar_base_handle_message+0x716>
			{
				sample_start = 0;
				num_used_ant = 1;

			}
			else if( frame_info.rx_mask == 2 )
 8024388:	f1bc 0f02 	cmp.w	ip, #2
 802438c:	d00e      	beq.n	80243ac <ep_radar_base_handle_message+0x724>
 802438e:	46a9      	mov	r9, r5
        uint32_t num_samples;
        uint32_t data_size;
        uint8_t message_header[18];
        uint32_t sample_start = 0;

        uint32_t num_used_ant = 2;
 8024390:	4629      	mov	r1, r5
 8024392:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8024394:	9a19      	ldr	r2, [sp, #100]	; 0x64
 8024396:	f89d e077 	ldrb.w	lr, [sp, #119]	; 0x77

        /* send message containing frame data */
        uint32_t num_samples;
        uint32_t data_size;
        uint8_t message_header[18];
        uint32_t sample_start = 0;
 802439a:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 802439c:	e4e3      	b.n	8023d66 <ep_radar_base_handle_message+0xde>
        {
        	/* Selection of Antenna to output is currently only supported for 12 Bit ADC resolution! */
        	if( frame_info.rx_mask == 1 )
			{
				sample_start = 0;
				num_used_ant = 1;
 802439e:	4661      	mov	r1, ip
        if (frame_info.adc_resolution == 12)
        {
        	/* Selection of Antenna to output is currently only supported for 12 Bit ADC resolution! */
        	if( frame_info.rx_mask == 1 )
			{
				sample_start = 0;
 80243a0:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 80243a2:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 80243a4:	9a19      	ldr	r2, [sp, #100]	; 0x64
 80243a6:	f89d e077 	ldrb.w	lr, [sp, #119]	; 0x77
 80243aa:	e4dc      	b.n	8023d66 <ep_radar_base_handle_message+0xde>
			else if( frame_info.rx_mask == 2 )
			{
				num_used_ant = 1;
				sample_start = frame_info.num_chirps *
						frame_info.num_samples_per_chirp *
						num_used_ant *
 80243ac:	f89d e077 	ldrb.w	lr, [sp, #119]	; 0x77

			}
			else if( frame_info.rx_mask == 2 )
			{
				num_used_ant = 1;
				sample_start = frame_info.num_chirps *
 80243b0:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 80243b2:	9a19      	ldr	r2, [sp, #100]	; 0x64
						frame_info.num_samples_per_chirp *
						num_used_ant *
 80243b4:	f1be 0f00 	cmp.w	lr, #0

			}
			else if( frame_info.rx_mask == 2 )
			{
				num_used_ant = 1;
				sample_start = frame_info.num_chirps *
 80243b8:	fb02 f103 	mul.w	r1, r2, r3
						frame_info.num_samples_per_chirp *
						num_used_ant *
 80243bc:	bf0c      	ite	eq
 80243be:	2501      	moveq	r5, #1
 80243c0:	2502      	movne	r5, #2

			}
			else if( frame_info.rx_mask == 2 )
			{
				num_used_ant = 1;
				sample_start = frame_info.num_chirps *
 80243c2:	fb05 f501 	mul.w	r5, r5, r1
 80243c6:	46b1      	mov	r9, r6
				num_used_ant = 1;

			}
			else if( frame_info.rx_mask == 2 )
			{
				num_used_ant = 1;
 80243c8:	2101      	movs	r1, #1
 80243ca:	e4cc      	b.n	8023d66 <ep_radar_base_handle_message+0xde>
 80243cc:	1ffe8d04 	.word	0x1ffe8d04

080243d0 <ep_radar_base_handle_change>:
    return PROTOCOL_STATUS_INVALID_PAYLOAD;
}

void ep_radar_base_handle_change(uint8_t endpoint, void* context,
                                 uint32_t what)
{
 80243d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (what)
 80243d4:	3a01      	subs	r2, #1
    return PROTOCOL_STATUS_INVALID_PAYLOAD;
}

void ep_radar_base_handle_change(uint8_t endpoint, void* context,
                                 uint32_t what)
{
 80243d6:	b086      	sub	sp, #24
 80243d8:	4680      	mov	r8, r0
 80243da:	460d      	mov	r5, r1
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (what)
 80243dc:	2a04      	cmp	r2, #4
 80243de:	d84e      	bhi.n	802447e <ep_radar_base_handle_change+0xae>
 80243e0:	e8df f002 	tbb	[pc, r2]
 80243e4:	84505003 	.word	0x84505003
 80243e8:	50          	.byte	0x50
 80243e9:	00          	.byte	0x00
{
    uint16_t error_code;
    Frame_Format_t frame_format;

    /* get current frame format from radar driver */
    error_code = radar_get_frame_format(radar_driver, &frame_format);
 80243ea:	a903      	add	r1, sp, #12
 80243ec:	4628      	mov	r0, r5
 80243ee:	f7fc f9c1 	bl	8020774 <radar_get_frame_format>

    if (error_code == RADAR_ERR_OK)
 80243f2:	2800      	cmp	r0, #0
 80243f4:	f000 80a1 	beq.w	802453a <ep_radar_base_handle_change+0x16a>
 80243f8:	466f      	mov	r7, sp
{
    uint16_t error_code;
    uint32_t chirp_duration;

    /* read chirp duration */
    error_code = radar_get_chirp_duration(radar_driver, &chirp_duration);
 80243fa:	4628      	mov	r0, r5
 80243fc:	4639      	mov	r1, r7
 80243fe:	f7fc f913 	bl	8020628 <radar_get_chirp_duration>

    if (error_code == RADAR_ERR_OK)
 8024402:	b9c0      	cbnz	r0, 8024436 <ep_radar_base_handle_change+0x66>
    {
        uint8_t message[5];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_CHRIP_DURATION);
        wr_payload_u32(message, 1, chirp_duration);
 8024404:	9b00      	ldr	r3, [sp, #0]
 8024406:	f88d 300d 	strb.w	r3, [sp, #13]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802440a:	2235      	movs	r2, #53	; 0x35
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 802440c:	0e1e      	lsrs	r6, r3, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 802440e:	0c1c      	lsrs	r4, r3, #16

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 8024410:	4640      	mov	r0, r8
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024412:	0a1b      	lsrs	r3, r3, #8
 8024414:	2105      	movs	r1, #5
 8024416:	f88d 300e 	strb.w	r3, [sp, #14]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802441a:	f88d 200c 	strb.w	r2, [sp, #12]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 802441e:	f88d 6010 	strb.w	r6, [sp, #16]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024422:	f88d 400f 	strb.w	r4, [sp, #15]
 8024426:	f000 faff 	bl	8024a28 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 802442a:	a803      	add	r0, sp, #12
 802442c:	2105      	movs	r1, #5
 802442e:	f000 fb0f 	bl	8024a50 <protocol_send_payload>
        protocol_send_tail();
 8024432:	f000 fb0f 	bl	8024a54 <protocol_send_tail>
{
    uint16_t error_code;
    uint32_t min_frame_interval;

    /* read minimum frame interval */
    error_code = radar_get_min_frame_interval(radar_driver,
 8024436:	4639      	mov	r1, r7
 8024438:	4628      	mov	r0, r5
 802443a:	f7fc f901 	bl	8020640 <radar_get_min_frame_interval>
                                              &min_frame_interval);

    if (error_code == RADAR_ERR_OK)
 802443e:	b9c0      	cbnz	r0, 8024472 <ep_radar_base_handle_change+0xa2>
    {
        uint8_t message[5];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_MIN_INTERVAL);
        wr_payload_u32(message, 1, min_frame_interval);
 8024440:	9b00      	ldr	r3, [sp, #0]
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024442:	f88d 300d 	strb.w	r3, [sp, #13]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024446:	2237      	movs	r2, #55	; 0x37

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 8024448:	4640      	mov	r0, r8
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 802444a:	0e1e      	lsrs	r6, r3, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 802444c:	0c1c      	lsrs	r4, r3, #16
 802444e:	2105      	movs	r1, #5
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024450:	0a1b      	lsrs	r3, r3, #8
 8024452:	f88d 300e 	strb.w	r3, [sp, #14]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024456:	f88d 200c 	strb.w	r2, [sp, #12]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 802445a:	f88d 6010 	strb.w	r6, [sp, #16]
    payload[offset + 2] = (value >> 16) & 0xFF;
 802445e:	f88d 400f 	strb.w	r4, [sp, #15]
 8024462:	f000 fae1 	bl	8024a28 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 8024466:	a803      	add	r0, sp, #12
 8024468:	2105      	movs	r1, #5
 802446a:	f000 faf1 	bl	8024a50 <protocol_send_payload>
        protocol_send_tail();
 802446e:	f000 faf1 	bl	8024a54 <protocol_send_tail>
        send_min_frame_interval(endpoint, radar_driver);

        {
        	extern uint8_t adc_endpoint;

        	if( adc_endpoint != 0)
 8024472:	4b58      	ldr	r3, [pc, #352]	; (80245d4 <ep_radar_base_handle_change+0x204>)
 8024474:	7818      	ldrb	r0, [r3, #0]
 8024476:	b110      	cbz	r0, 802447e <ep_radar_base_handle_change+0xae>
        		send_adc_configuration(adc_endpoint,radar_driver); // change
 8024478:	4629      	mov	r1, r5
 802447a:	f7ff fb45 	bl	8023b08 <send_adc_configuration>
        break;

    default:
        break;
    }
}
 802447e:	b006      	add	sp, #24
 8024480:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
void ep_radar_base_handle_change(uint8_t endpoint, void* context,
                                 uint32_t what)
{
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (what)
 8024484:	2600      	movs	r6, #0
 8024486:	466f      	mov	r7, sp
 8024488:	b2f4      	uxtb	r4, r6
{
    uint16_t error_code;
    int32_t tx_power;

    /* read TX power value value */
    error_code =  radar_get_tx_power(radar_driver, tx_antenna, &tx_power);
 802448a:	4621      	mov	r1, r4
 802448c:	4628      	mov	r0, r5
 802448e:	463a      	mov	r2, r7
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024490:	f04f 0933 	mov.w	r9, #51	; 0x33
 8024494:	f7fc f8b2 	bl	80205fc <radar_get_tx_power>

    if (error_code == RADAR_ERR_OK)
 8024498:	2800      	cmp	r0, #0
 802449a:	d1f0      	bne.n	802447e <ep_radar_base_handle_change+0xae>
        uint8_t message[6];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_TX_POWER);
        wr_payload_u8 (message, 1, tx_antenna);
        wr_payload_i32(message, 2, tx_power);
 802449c:	9b00      	ldr	r3, [sp, #0]
                                  int32_t value)
{
    payload[offset + 3] = (((uint32_t)value) >> 24) & 0xFF;
    payload[offset + 2] = (((uint32_t)value) >> 16) & 0xFF;
    payload[offset + 1] = (((uint32_t)value) >>  8) & 0xFF;
    payload[offset    ] =  ((uint32_t)value)        & 0xFF;
 802449e:	f88d 300e 	strb.w	r3, [sp, #14]
static inline void wr_payload_i32(uint8_t* payload, uint16_t offset,
                                  int32_t value)
{
    payload[offset + 3] = (((uint32_t)value) >> 24) & 0xFF;
    payload[offset + 2] = (((uint32_t)value) >> 16) & 0xFF;
    payload[offset + 1] = (((uint32_t)value) >>  8) & 0xFF;
 80244a2:	0a1a      	lsrs	r2, r3, #8
}

static inline void wr_payload_i32(uint8_t* payload, uint16_t offset,
                                  int32_t value)
{
    payload[offset + 3] = (((uint32_t)value) >> 24) & 0xFF;
 80244a4:	ea4f 6c13 	mov.w	ip, r3, lsr #24
    payload[offset + 2] = (((uint32_t)value) >> 16) & 0xFF;
 80244a8:	ea4f 4e13 	mov.w	lr, r3, lsr #16

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 80244ac:	4640      	mov	r0, r8
 80244ae:	2106      	movs	r1, #6
 80244b0:	3601      	adds	r6, #1
    payload[offset + 1] = (((uint32_t)value) >>  8) & 0xFF;
 80244b2:	f88d 200f 	strb.w	r2, [sp, #15]
}

static inline void wr_payload_i32(uint8_t* payload, uint16_t offset,
                                  int32_t value)
{
    payload[offset + 3] = (((uint32_t)value) >> 24) & 0xFF;
 80244b6:	f88d c011 	strb.w	ip, [sp, #17]
    payload[offset + 2] = (((uint32_t)value) >> 16) & 0xFF;
 80244ba:	f88d e010 	strb.w	lr, [sp, #16]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80244be:	f88d 400d 	strb.w	r4, [sp, #13]
 80244c2:	f88d 900c 	strb.w	r9, [sp, #12]
 80244c6:	b2f4      	uxtb	r4, r6
 80244c8:	f000 faae 	bl	8024a28 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 80244cc:	a803      	add	r0, sp, #12
 80244ce:	2106      	movs	r1, #6
 80244d0:	f000 fabe 	bl	8024a50 <protocol_send_payload>
        protocol_send_tail();
 80244d4:	f000 fabe 	bl	8024a54 <protocol_send_tail>
{
    uint16_t error_code;
    int32_t tx_power;

    /* read TX power value value */
    error_code =  radar_get_tx_power(radar_driver, tx_antenna, &tx_power);
 80244d8:	4621      	mov	r1, r4
 80244da:	4628      	mov	r0, r5
 80244dc:	463a      	mov	r2, r7
 80244de:	f7fc f88d 	bl	80205fc <radar_get_tx_power>

    if (error_code == RADAR_ERR_OK)
 80244e2:	2800      	cmp	r0, #0
 80244e4:	d0da      	beq.n	802449c <ep_radar_base_handle_change+0xcc>
        break;

    default:
        break;
    }
}
 80244e6:	b006      	add	sp, #24
 80244e8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
{
    uint16_t error_code;
    uint32_t chirp_duration;

    /* read chirp duration */
    error_code = radar_get_chirp_duration(radar_driver, &chirp_duration);
 80244ec:	4669      	mov	r1, sp
 80244ee:	4628      	mov	r0, r5
 80244f0:	466f      	mov	r7, sp
 80244f2:	f7fc f899 	bl	8020628 <radar_get_chirp_duration>

    if (error_code == RADAR_ERR_OK)
 80244f6:	2800      	cmp	r0, #0
 80244f8:	d052      	beq.n	80245a0 <ep_radar_base_handle_change+0x1d0>
{
    uint16_t error_code;
    uint32_t min_frame_interval;

    /* read minimum frame interval */
    error_code = radar_get_min_frame_interval(radar_driver,
 80244fa:	4628      	mov	r0, r5
 80244fc:	4639      	mov	r1, r7
 80244fe:	f7fc f89f 	bl	8020640 <radar_get_min_frame_interval>
                                              &min_frame_interval);

    if (error_code == RADAR_ERR_OK)
 8024502:	2800      	cmp	r0, #0
 8024504:	d1bb      	bne.n	802447e <ep_radar_base_handle_change+0xae>
    {
        uint8_t message[5];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_MIN_INTERVAL);
        wr_payload_u32(message, 1, min_frame_interval);
 8024506:	9b00      	ldr	r3, [sp, #0]
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024508:	f88d 300d 	strb.w	r3, [sp, #13]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802450c:	2237      	movs	r2, #55	; 0x37

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 802450e:	4640      	mov	r0, r8
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024510:	0e1d      	lsrs	r5, r3, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024512:	0c1c      	lsrs	r4, r3, #16
 8024514:	2105      	movs	r1, #5
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024516:	0a1b      	lsrs	r3, r3, #8
 8024518:	f88d 300e 	strb.w	r3, [sp, #14]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802451c:	f88d 200c 	strb.w	r2, [sp, #12]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024520:	f88d 5010 	strb.w	r5, [sp, #16]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024524:	f88d 400f 	strb.w	r4, [sp, #15]
 8024528:	f000 fa7e 	bl	8024a28 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 802452c:	a803      	add	r0, sp, #12
 802452e:	2105      	movs	r1, #5
 8024530:	f000 fa8e 	bl	8024a50 <protocol_send_payload>
        protocol_send_tail();
 8024534:	f000 fa8e 	bl	8024a54 <protocol_send_tail>
 8024538:	e7a1      	b.n	802447e <ep_radar_base_handle_change+0xae>
    {
        uint8_t message[11];

        /* compile message */
        wr_payload_u8 (message,  0, MSG_SET_FRAME_FORMAT);
        wr_payload_u32(message,  1, frame_format.num_samples_per_chirp);
 802453a:	9b03      	ldr	r3, [sp, #12]
        wr_payload_u32(message,  5, frame_format.num_chirps_per_frame);
 802453c:	9a04      	ldr	r2, [sp, #16]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802453e:	f89d 6014 	ldrb.w	r6, [sp, #20]
 8024542:	f89d 4015 	ldrb.w	r4, [sp, #21]
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024546:	f88d 3001 	strb.w	r3, [sp, #1]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 802454a:	0e19      	lsrs	r1, r3, #24
 802454c:	ea4f 6a12 	mov.w	sl, r2, lsr #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024550:	ea4f 4912 	mov.w	r9, r2, lsr #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024554:	ea4f 2c12 	mov.w	ip, r2, lsr #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024558:	f04f 0e41 	mov.w	lr, #65	; 0x41

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 802455c:	0c1f      	lsrs	r7, r3, #16
        wr_payload_u8 (message,  9, frame_format.rx_mask);
        wr_payload_u8 (message, 10, frame_format.signal_part);

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 802455e:	4640      	mov	r0, r8
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024560:	0a1b      	lsrs	r3, r3, #8
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024562:	f88d 1004 	strb.w	r1, [sp, #4]
 8024566:	210b      	movs	r1, #11
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024568:	f88d 7003 	strb.w	r7, [sp, #3]
    payload[offset + 1] = (value >>  8) & 0xFF;
 802456c:	f88d 3002 	strb.w	r3, [sp, #2]
    payload[offset    ] =  value        & 0xFF;
 8024570:	f88d 2005 	strb.w	r2, [sp, #5]
static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024574:	f88d c006 	strb.w	ip, [sp, #6]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024578:	f88d e000 	strb.w	lr, [sp]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 802457c:	f88d a008 	strb.w	sl, [sp, #8]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024580:	f88d 9007 	strb.w	r9, [sp, #7]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024584:	f88d 6009 	strb.w	r6, [sp, #9]
 8024588:	f88d 400a 	strb.w	r4, [sp, #10]
 802458c:	f000 fa4c 	bl	8024a28 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 8024590:	4668      	mov	r0, sp
 8024592:	210b      	movs	r1, #11
 8024594:	466f      	mov	r7, sp
 8024596:	f000 fa5b 	bl	8024a50 <protocol_send_payload>
        protocol_send_tail();
 802459a:	f000 fa5b 	bl	8024a54 <protocol_send_tail>
 802459e:	e72c      	b.n	80243fa <ep_radar_base_handle_change+0x2a>
    {
        uint8_t message[5];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_CHRIP_DURATION);
        wr_payload_u32(message, 1, chirp_duration);
 80245a0:	9b00      	ldr	r3, [sp, #0]
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 80245a2:	f88d 300d 	strb.w	r3, [sp, #13]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80245a6:	2235      	movs	r2, #53	; 0x35
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 80245a8:	0e1e      	lsrs	r6, r3, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 80245aa:	0c1c      	lsrs	r4, r3, #16

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 80245ac:	4640      	mov	r0, r8
    payload[offset + 1] = (value >>  8) & 0xFF;
 80245ae:	0a1b      	lsrs	r3, r3, #8
 80245b0:	2105      	movs	r1, #5
 80245b2:	f88d 300e 	strb.w	r3, [sp, #14]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80245b6:	f88d 200c 	strb.w	r2, [sp, #12]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 80245ba:	f88d 6010 	strb.w	r6, [sp, #16]
    payload[offset + 2] = (value >> 16) & 0xFF;
 80245be:	f88d 400f 	strb.w	r4, [sp, #15]
 80245c2:	f000 fa31 	bl	8024a28 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 80245c6:	a803      	add	r0, sp, #12
 80245c8:	2105      	movs	r1, #5
 80245ca:	f000 fa41 	bl	8024a50 <protocol_send_payload>
        protocol_send_tail();
 80245ce:	f000 fa41 	bl	8024a54 <protocol_send_tail>
 80245d2:	e792      	b.n	80244fa <ep_radar_base_handle_change+0x12a>
 80245d4:	1ffe8cfc 	.word	0x1ffe8cfc

080245d8 <send_fmcw_configuration>:
==============================================================================
*/

static uint16_t send_fmcw_configuration(uint8_t endpoint,
                                        Radar_Handle_t radar_driver)
{
 80245d8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80245dc:	b08c      	sub	sp, #48	; 0x30
 80245de:	4606      	mov	r6, r0
    uint16_t error_code;
    Fmcw_Configuration_t fmcw_configuration;

    /* read FMCW configuration from device */
    error_code = radar_get_fmcw_configuration(radar_driver,
 80245e0:	4608      	mov	r0, r1
 80245e2:	a906      	add	r1, sp, #24
 80245e4:	f7fc fdda 	bl	802119c <radar_get_fmcw_configuration>
                                              &fmcw_configuration);

    if (error_code == RADAR_ERR_OK)
 80245e8:	4604      	mov	r4, r0
 80245ea:	bba8      	cbnz	r0, 8024658 <send_fmcw_configuration+0x80>
        wr_payload_u32(message,   1, fmcw_configuration.lower_frequency_kHz);
        wr_payload_u32(message,   5, fmcw_configuration.upper_frequency_kHz);
        wr_payload_u8 (message,   9, fmcw_configuration.direction);
        wr_payload_u8 (message,  10, fmcw_configuration.tx_power);

        if( g_host_supports_advanced_configuration ) {
 80245ec:	4932      	ldr	r1, [pc, #200]	; (80246b8 <send_fmcw_configuration+0xe0>)
        uint8_t message[11 + 12];
        size_t len = 11;

        /* compile message */
        wr_payload_u8 (message,   0, MSG_SET_CONFIGURATION);
        wr_payload_u32(message,   1, fmcw_configuration.lower_frequency_kHz);
 80245ee:	9b06      	ldr	r3, [sp, #24]
        wr_payload_u32(message,   5, fmcw_configuration.upper_frequency_kHz);
 80245f0:	9a07      	ldr	r2, [sp, #28]
        wr_payload_u8 (message,   9, fmcw_configuration.direction);
        wr_payload_u8 (message,  10, fmcw_configuration.tx_power);

        if( g_host_supports_advanced_configuration ) {
 80245f2:	6809      	ldr	r1, [r1, #0]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80245f4:	f89d 5020 	ldrb.w	r5, [sp, #32]
 80245f8:	f89d 0021 	ldrb.w	r0, [sp, #33]	; 0x21
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 80245fc:	f88d 3001 	strb.w	r3, [sp, #1]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024600:	ea4f 6a13 	mov.w	sl, r3, lsr #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024604:	ea4f 4913 	mov.w	r9, r3, lsr #16
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024608:	ea4f 6812 	mov.w	r8, r2, lsr #24
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 802460c:	0a1b      	lsrs	r3, r3, #8

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 802460e:	ea4f 4c12 	mov.w	ip, r2, lsr #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024612:	ea4f 2e12 	mov.w	lr, r2, lsr #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024616:	2701      	movs	r7, #1
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024618:	f88d a004 	strb.w	sl, [sp, #4]
    payload[offset + 2] = (value >> 16) & 0xFF;
 802461c:	f88d 9003 	strb.w	r9, [sp, #3]
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024620:	f88d 3002 	strb.w	r3, [sp, #2]
    payload[offset    ] =  value        & 0xFF;
 8024624:	f88d 2005 	strb.w	r2, [sp, #5]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024628:	f88d 8008 	strb.w	r8, [sp, #8]
    payload[offset + 2] = (value >> 16) & 0xFF;
 802462c:	f88d c007 	strb.w	ip, [sp, #7]
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024630:	f88d e006 	strb.w	lr, [sp, #6]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024634:	f88d 7000 	strb.w	r7, [sp]
 8024638:	f88d 5009 	strb.w	r5, [sp, #9]
 802463c:	f88d 000a 	strb.w	r0, [sp, #10]
 8024640:	b971      	cbnz	r1, 8024660 <send_fmcw_configuration+0x88>
 8024642:	250b      	movs	r5, #11
			wr_payload_u32 (message, 15, fmcw_configuration.down_chirp_duration_nsec);
			wr_payload_u32 (message, 19, fmcw_configuration.chirp_to_chirp_delay_nsec);
			len += 4*sizeof(uint32_t);
        }
        /* send message */
        protocol_send_header(endpoint, len);
 8024644:	4630      	mov	r0, r6
 8024646:	4629      	mov	r1, r5
 8024648:	f000 f9ee 	bl	8024a28 <protocol_send_header>
        protocol_send_payload(message, len);
 802464c:	4629      	mov	r1, r5
 802464e:	4668      	mov	r0, sp
 8024650:	f000 f9fe 	bl	8024a50 <protocol_send_payload>
        protocol_send_tail();
 8024654:	f000 f9fe 	bl	8024a54 <protocol_send_tail>
    }
    return error_code;
}
 8024658:	4620      	mov	r0, r4
 802465a:	b00c      	add	sp, #48	; 0x30
 802465c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        wr_payload_u32(message,   5, fmcw_configuration.upper_frequency_kHz);
        wr_payload_u8 (message,   9, fmcw_configuration.direction);
        wr_payload_u8 (message,  10, fmcw_configuration.tx_power);

        if( g_host_supports_advanced_configuration ) {
			wr_payload_u32 (message, 11, fmcw_configuration.up_chirp_duration_nsec);
 8024660:	9b09      	ldr	r3, [sp, #36]	; 0x24
			wr_payload_u32 (message, 15, fmcw_configuration.down_chirp_duration_nsec);
 8024662:	990a      	ldr	r1, [sp, #40]	; 0x28
			wr_payload_u32 (message, 19, fmcw_configuration.chirp_to_chirp_delay_nsec);
 8024664:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024666:	f88d 300b 	strb.w	r3, [sp, #11]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 802466a:	ea4f 6a13 	mov.w	sl, r3, lsr #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 802466e:	ea4f 4913 	mov.w	r9, r3, lsr #16
 8024672:	0c15      	lsrs	r5, r2, #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024674:	0a1b      	lsrs	r3, r3, #8
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024676:	ea4f 6811 	mov.w	r8, r1, lsr #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 802467a:	ea4f 4c11 	mov.w	ip, r1, lsr #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 802467e:	ea4f 2e11 	mov.w	lr, r1, lsr #8
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024682:	0e17      	lsrs	r7, r2, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024684:	0a10      	lsrs	r0, r2, #8

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024686:	f88d 5015 	strb.w	r5, [sp, #21]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 802468a:	f88d a00e 	strb.w	sl, [sp, #14]
    payload[offset + 2] = (value >> 16) & 0xFF;
 802468e:	f88d 900d 	strb.w	r9, [sp, #13]
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024692:	f88d 300c 	strb.w	r3, [sp, #12]
    payload[offset    ] =  value        & 0xFF;
 8024696:	f88d 100f 	strb.w	r1, [sp, #15]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 802469a:	f88d 8012 	strb.w	r8, [sp, #18]
    payload[offset + 2] = (value >> 16) & 0xFF;
 802469e:	f88d c011 	strb.w	ip, [sp, #17]
    payload[offset + 1] = (value >>  8) & 0xFF;
 80246a2:	f88d e010 	strb.w	lr, [sp, #16]
    payload[offset    ] =  value        & 0xFF;
 80246a6:	f88d 2013 	strb.w	r2, [sp, #19]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 80246aa:	f88d 7016 	strb.w	r7, [sp, #22]
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 80246ae:	f88d 0014 	strb.w	r0, [sp, #20]
    payload[offset    ] =  value        & 0xFF;
 80246b2:	251b      	movs	r5, #27
 80246b4:	e7c6      	b.n	8024644 <send_fmcw_configuration+0x6c>
 80246b6:	bf00      	nop
 80246b8:	1fff0d04 	.word	0x1fff0d04

080246bc <ep_radar_fmcw_handle_message>:
==============================================================================
*/

uint16_t ep_radar_fmcw_handle_message(uint8_t endpoint, uint8_t* message_data,
                                      uint16_t num_bytes, void* context)
{
 80246bc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80246c0:	4605      	mov	r5, r0
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (message_data[0])
 80246c2:	7808      	ldrb	r0, [r1, #0]
==============================================================================
*/

uint16_t ep_radar_fmcw_handle_message(uint8_t endpoint, uint8_t* message_data,
                                      uint16_t num_bytes, void* context)
{
 80246c4:	b08b      	sub	sp, #44	; 0x2c
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (message_data[0])
 80246c6:	2803      	cmp	r0, #3
 80246c8:	d805      	bhi.n	80246d6 <ep_radar_fmcw_handle_message+0x1a>
 80246ca:	e8df f000 	tbb	[pc, r0]
 80246ce:	1443      	.short	0x1443
 80246d0:	0a02      	.short	0x0a02
            return error_code;
        }
        break;

    case MSG_GET_BW_PER_SECOND:
        if (num_bytes == 1)
 80246d2:	2a01      	cmp	r2, #1
 80246d4:	d049      	beq.n	802476a <ep_radar_fmcw_handle_message+0xae>
        break;

    default:
        break;
    }
    return PROTOCOL_STATUS_INVALID_PAYLOAD;
 80246d6:	f64f 74ff 	movw	r4, #65535	; 0xffff
}
 80246da:	4620      	mov	r0, r4
 80246dc:	b00b      	add	sp, #44	; 0x2c
 80246de:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        	g_host_supports_advanced_configuration = 0;
            return send_fmcw_configuration(endpoint, radar_driver);
        }
        break;
    case MSG_GET_ADV_CONFIGURATION:
		if (num_bytes == 1)
 80246e2:	2a01      	cmp	r2, #1
 80246e4:	d1f7      	bne.n	80246d6 <ep_radar_fmcw_handle_message+0x1a>
		{
			g_host_supports_advanced_configuration = 1;
 80246e6:	4c31      	ldr	r4, [pc, #196]	; (80247ac <ep_radar_fmcw_handle_message+0xf0>)
			return send_fmcw_configuration(endpoint, radar_driver);
 80246e8:	4628      	mov	r0, r5
 80246ea:	4619      	mov	r1, r3
        }
        break;
    case MSG_GET_ADV_CONFIGURATION:
		if (num_bytes == 1)
		{
			g_host_supports_advanced_configuration = 1;
 80246ec:	6022      	str	r2, [r4, #0]
			return send_fmcw_configuration(endpoint, radar_driver);
 80246ee:	f7ff ff73 	bl	80245d8 <send_fmcw_configuration>
 80246f2:	4604      	mov	r4, r0
 80246f4:	e7f1      	b.n	80246da <ep_radar_fmcw_handle_message+0x1e>
		}
		break;

    case MSG_SET_CONFIGURATION:
        if (num_bytes == 11)
 80246f6:	2a0b      	cmp	r2, #11
 80246f8:	d1ed      	bne.n	80246d6 <ep_radar_fmcw_handle_message+0x1a>
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 80246fa:	f891 c003 	ldrb.w	ip, [r1, #3]
 80246fe:	79ce      	ldrb	r6, [r1, #7]
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 8024700:	f891 8004 	ldrb.w	r8, [r1, #4]
 8024704:	7a0a      	ldrb	r2, [r1, #8]
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
            ((uint32_t)payload[offset    ]);
 8024706:	784d      	ldrb	r5, [r1, #1]
 8024708:	7948      	ldrb	r0, [r1, #5]

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 802470a:	f891 e006 	ldrb.w	lr, [r1, #6]
            Fmcw_Configuration_t config;

            /* extract parameters from message */
            config.lower_frequency_kHz = rd_payload_u32(message_data,  1);
            config.upper_frequency_kHz = rd_payload_u32(message_data,  5);
            config.direction           = rd_payload_u8 (message_data,  9);
 802470e:	f891 9009 	ldrb.w	r9, [r1, #9]
            config.tx_power            = rd_payload_u8 (message_data, 10);
 8024712:	7a8f      	ldrb	r7, [r1, #10]
 8024714:	788c      	ldrb	r4, [r1, #2]

            /* apply FMCW configuration */
            error_code = radar_set_fmcw_configuration(radar_driver, &config);
 8024716:	9301      	str	r3, [sp, #4]
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 8024718:	ea4f 410c 	mov.w	r1, ip, lsl #16
 802471c:	0436      	lsls	r6, r6, #16
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 802471e:	ea41 6108 	orr.w	r1, r1, r8, lsl #24
 8024722:	ea46 6202 	orr.w	r2, r6, r2, lsl #24
 8024726:	4329      	orrs	r1, r5
 8024728:	4302      	orrs	r2, r0
 802472a:	ea41 2404 	orr.w	r4, r1, r4, lsl #8
 802472e:	ea42 220e 	orr.w	r2, r2, lr, lsl #8
 8024732:	a904      	add	r1, sp, #16
 8024734:	4618      	mov	r0, r3
        {
            unsigned error_code;
            Fmcw_Configuration_t config;

            /* extract parameters from message */
            config.lower_frequency_kHz = rd_payload_u32(message_data,  1);
 8024736:	9404      	str	r4, [sp, #16]
            config.upper_frequency_kHz = rd_payload_u32(message_data,  5);
            config.direction           = rd_payload_u8 (message_data,  9);
 8024738:	f88d 9018 	strb.w	r9, [sp, #24]
            unsigned error_code;
            Fmcw_Configuration_t config;

            /* extract parameters from message */
            config.lower_frequency_kHz = rd_payload_u32(message_data,  1);
            config.upper_frequency_kHz = rd_payload_u32(message_data,  5);
 802473c:	9205      	str	r2, [sp, #20]
            config.direction           = rd_payload_u8 (message_data,  9);
            config.tx_power            = rd_payload_u8 (message_data, 10);
 802473e:	f88d 7019 	strb.w	r7, [sp, #25]

            /* apply FMCW configuration */
            error_code = radar_set_fmcw_configuration(radar_driver, &config);
 8024742:	f7fc fce7 	bl	8021114 <radar_set_fmcw_configuration>

            /* inform other endpoints of the change */
            protocol_broadcast_change(radar_driver,
 8024746:	9b01      	ldr	r3, [sp, #4]
            config.upper_frequency_kHz = rd_payload_u32(message_data,  5);
            config.direction           = rd_payload_u8 (message_data,  9);
            config.tx_power            = rd_payload_u8 (message_data, 10);

            /* apply FMCW configuration */
            error_code = radar_set_fmcw_configuration(radar_driver, &config);
 8024748:	4604      	mov	r4, r0

            /* inform other endpoints of the change */
            protocol_broadcast_change(radar_driver,
 802474a:	2102      	movs	r1, #2
 802474c:	4618      	mov	r0, r3
 802474e:	f000 fb41 	bl	8024dd4 <protocol_broadcast_change>
 8024752:	e7c2      	b.n	80246da <ep_radar_fmcw_handle_message+0x1e>
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (message_data[0])
    {
    case MSG_GET_CONFIGURATION:
        if (num_bytes == 1)
 8024754:	2a01      	cmp	r2, #1
 8024756:	d1be      	bne.n	80246d6 <ep_radar_fmcw_handle_message+0x1a>
        {
        	// a local variable does not work, because the updates are also sent on updates!
        	g_host_supports_advanced_configuration = 0;
 8024758:	4a14      	ldr	r2, [pc, #80]	; (80247ac <ep_radar_fmcw_handle_message+0xf0>)
            return send_fmcw_configuration(endpoint, radar_driver);
 802475a:	4619      	mov	r1, r3
 802475c:	4628      	mov	r0, r5
    {
    case MSG_GET_CONFIGURATION:
        if (num_bytes == 1)
        {
        	// a local variable does not work, because the updates are also sent on updates!
        	g_host_supports_advanced_configuration = 0;
 802475e:	2300      	movs	r3, #0
 8024760:	6013      	str	r3, [r2, #0]
            return send_fmcw_configuration(endpoint, radar_driver);
 8024762:	f7ff ff39 	bl	80245d8 <send_fmcw_configuration>
 8024766:	4604      	mov	r4, r0
 8024768:	e7b7      	b.n	80246da <ep_radar_fmcw_handle_message+0x1e>
{
    uint16_t error_code;
    uint32_t bandwidth_per_second;

    /* read bandwidth per second from device */
    error_code = radar_get_bandwidth_per_second(radar_driver,
 802476a:	4618      	mov	r0, r3
 802476c:	a903      	add	r1, sp, #12
 802476e:	f7fc fd1b 	bl	80211a8 <radar_get_bandwidth_per_second>
                                                &bandwidth_per_second);

    if (error_code == RADAR_ERR_OK)
 8024772:	4604      	mov	r4, r0
 8024774:	2800      	cmp	r0, #0
 8024776:	d1b0      	bne.n	80246da <ep_radar_fmcw_handle_message+0x1e>
    {
        uint8_t message[5];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_BW_PER_SECOND);
        wr_payload_u32(message, 1, bandwidth_per_second);
 8024778:	9b03      	ldr	r3, [sp, #12]
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 802477a:	f88d 3011 	strb.w	r3, [sp, #17]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802477e:	2202      	movs	r2, #2

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 8024780:	4628      	mov	r0, r5
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024782:	0e1e      	lsrs	r6, r3, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024784:	0c1d      	lsrs	r5, r3, #16
 8024786:	2105      	movs	r1, #5
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024788:	0a1b      	lsrs	r3, r3, #8
 802478a:	f88d 3012 	strb.w	r3, [sp, #18]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802478e:	f88d 2010 	strb.w	r2, [sp, #16]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024792:	f88d 6014 	strb.w	r6, [sp, #20]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024796:	f88d 5013 	strb.w	r5, [sp, #19]
 802479a:	f000 f945 	bl	8024a28 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 802479e:	a804      	add	r0, sp, #16
 80247a0:	2105      	movs	r1, #5
 80247a2:	f000 f955 	bl	8024a50 <protocol_send_payload>
        protocol_send_tail();
 80247a6:	f000 f955 	bl	8024a54 <protocol_send_tail>
        break;

    case MSG_GET_BW_PER_SECOND:
        if (num_bytes == 1)
        {
            return send_bandwidth_per_second(endpoint, radar_driver);
 80247aa:	e796      	b.n	80246da <ep_radar_fmcw_handle_message+0x1e>
 80247ac:	1fff0d04 	.word	0x1fff0d04

080247b0 <ep_radar_fmcw_handle_change>:
    return PROTOCOL_STATUS_INVALID_PAYLOAD;
}

void ep_radar_fmcw_handle_change(uint8_t endpoint, void* context,
                                 uint32_t what)
{
 80247b0:	b570      	push	{r4, r5, r6, lr}
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (what)
 80247b2:	2a02      	cmp	r2, #2
    return PROTOCOL_STATUS_INVALID_PAYLOAD;
}

void ep_radar_fmcw_handle_change(uint8_t endpoint, void* context,
                                 uint32_t what)
{
 80247b4:	b084      	sub	sp, #16
 80247b6:	4614      	mov	r4, r2
 80247b8:	4606      	mov	r6, r0
 80247ba:	460d      	mov	r5, r1
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (what)
 80247bc:	d026      	beq.n	802480c <ep_radar_fmcw_handle_change+0x5c>
 80247be:	2a04      	cmp	r2, #4
 80247c0:	d003      	beq.n	80247ca <ep_radar_fmcw_handle_change+0x1a>
 80247c2:	2a01      	cmp	r2, #1
 80247c4:	d001      	beq.n	80247ca <ep_radar_fmcw_handle_change+0x1a>
        break;

    default:
        break;
    }
}
 80247c6:	b004      	add	sp, #16
 80247c8:	bd70      	pop	{r4, r5, r6, pc}
{
    uint16_t error_code;
    uint32_t bandwidth_per_second;

    /* read bandwidth per second from device */
    error_code = radar_get_bandwidth_per_second(radar_driver,
 80247ca:	4628      	mov	r0, r5
 80247cc:	a901      	add	r1, sp, #4
 80247ce:	f7fc fceb 	bl	80211a8 <radar_get_bandwidth_per_second>
                                                &bandwidth_per_second);

    if (error_code == RADAR_ERR_OK)
 80247d2:	2800      	cmp	r0, #0
 80247d4:	d1f7      	bne.n	80247c6 <ep_radar_fmcw_handle_change+0x16>
    {
        uint8_t message[5];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_BW_PER_SECOND);
        wr_payload_u32(message, 1, bandwidth_per_second);
 80247d6:	9b01      	ldr	r3, [sp, #4]
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 80247d8:	f88d 3009 	strb.w	r3, [sp, #9]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 80247dc:	0e1d      	lsrs	r5, r3, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 80247de:	0c1c      	lsrs	r4, r3, #16
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80247e0:	2202      	movs	r2, #2
static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 80247e2:	0a1b      	lsrs	r3, r3, #8

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 80247e4:	4630      	mov	r0, r6
 80247e6:	2105      	movs	r1, #5
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 80247e8:	f88d 500c 	strb.w	r5, [sp, #12]
    payload[offset + 2] = (value >> 16) & 0xFF;
 80247ec:	f88d 400b 	strb.w	r4, [sp, #11]
    payload[offset + 1] = (value >>  8) & 0xFF;
 80247f0:	f88d 300a 	strb.w	r3, [sp, #10]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80247f4:	f88d 2008 	strb.w	r2, [sp, #8]
 80247f8:	f000 f916 	bl	8024a28 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 80247fc:	a802      	add	r0, sp, #8
 80247fe:	2105      	movs	r1, #5
 8024800:	f000 f926 	bl	8024a50 <protocol_send_payload>
        protocol_send_tail();
 8024804:	f000 f926 	bl	8024a54 <protocol_send_tail>
        break;

    default:
        break;
    }
}
 8024808:	b004      	add	sp, #16
 802480a:	bd70      	pop	{r4, r5, r6, pc}
    case EP_RADAR_CHNG_FRAME_FORMAT:
        send_bandwidth_per_second(endpoint, radar_driver);
        break;

    case EP_RADAR_CHNG_FMCW_SETTINGS:
        send_fmcw_configuration(endpoint, radar_driver);
 802480c:	f7ff fee4 	bl	80245d8 <send_fmcw_configuration>
{
    uint16_t error_code;
    uint32_t bandwidth_per_second;

    /* read bandwidth per second from device */
    error_code = radar_get_bandwidth_per_second(radar_driver,
 8024810:	4628      	mov	r0, r5
 8024812:	a901      	add	r1, sp, #4
 8024814:	f7fc fcc8 	bl	80211a8 <radar_get_bandwidth_per_second>
                                                &bandwidth_per_second);

    if (error_code == RADAR_ERR_OK)
 8024818:	2800      	cmp	r0, #0
 802481a:	d1d4      	bne.n	80247c6 <ep_radar_fmcw_handle_change+0x16>
    {
        uint8_t message[5];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_BW_PER_SECOND);
        wr_payload_u32(message, 1, bandwidth_per_second);
 802481c:	9b01      	ldr	r3, [sp, #4]
 802481e:	f88d 4008 	strb.w	r4, [sp, #8]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024822:	0e1d      	lsrs	r5, r3, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024824:	0c1c      	lsrs	r4, r3, #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024826:	0a1a      	lsrs	r2, r3, #8

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 8024828:	4630      	mov	r0, r6
 802482a:	2105      	movs	r1, #5
    payload[offset    ] =  value        & 0xFF;
 802482c:	f88d 3009 	strb.w	r3, [sp, #9]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024830:	f88d 500c 	strb.w	r5, [sp, #12]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024834:	f88d 400b 	strb.w	r4, [sp, #11]
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024838:	f88d 200a 	strb.w	r2, [sp, #10]
 802483c:	e7dc      	b.n	80247f8 <ep_radar_fmcw_handle_change+0x48>
 802483e:	bf00      	nop

08024840 <ep_radar_industrial_handle_message>:
==============================================================================
*/

uint16_t ep_radar_industrial_handle_message(uint8_t endpoint, uint8_t* message_data,
											uint16_t num_bytes,	void* context)
{
 8024840:	b530      	push	{r4, r5, lr}
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

	uint16_t error_code = 0;

    switch (message_data[0])
 8024842:	780c      	ldrb	r4, [r1, #0]
==============================================================================
*/

uint16_t ep_radar_industrial_handle_message(uint8_t endpoint, uint8_t* message_data,
											uint16_t num_bytes,	void* context)
{
 8024844:	b083      	sub	sp, #12
 8024846:	4605      	mov	r5, r0
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

	uint16_t error_code = 0;

    switch (message_data[0])
 8024848:	2c05      	cmp	r4, #5
 802484a:	d806      	bhi.n	802485a <ep_radar_industrial_handle_message+0x1a>
 802484c:	e8df f004 	tbb	[pc, r4]
 8024850:	31171009 	.word	0x31171009
 8024854:	0338      	.short	0x0338
        }
        break;

	case MSG_IS_ENABLE_BGT_LNA:

		if (num_bytes == 1)
 8024856:	2a01      	cmp	r2, #1
 8024858:	d039      	beq.n	80248ce <ep_radar_industrial_handle_message+0x8e>
    default:
	
		break;
    }

    return PROTOCOL_STATUS_INVALID_PAYLOAD;
 802485a:	f64f 70ff 	movw	r0, #65535	; 0xffff
}
 802485e:	b003      	add	sp, #12
 8024860:	bd30      	pop	{r4, r5, pc}
    switch (message_data[0])
    {
		
    case MSG_DISABLE_DUTY_CYCLE:
	
        if (num_bytes == 1)
 8024862:	2a01      	cmp	r2, #1
 8024864:	d1f9      	bne.n	802485a <ep_radar_industrial_handle_message+0x1a>
        {
			error_code = radar_set_duty_cycle(radar_driver, 0);
 8024866:	4618      	mov	r0, r3
 8024868:	2100      	movs	r1, #0
 802486a:	f7fc fcd7 	bl	802121c <radar_set_duty_cycle>
			
            return error_code;
 802486e:	e7f6      	b.n	802485e <ep_radar_industrial_handle_message+0x1e>
        }
        break;
		
	case MSG_ENABLE_DUTY_CYCLE:
	
        if (num_bytes == 1)
 8024870:	2a01      	cmp	r2, #1
 8024872:	d1f2      	bne.n	802485a <ep_radar_industrial_handle_message+0x1a>
        {
			error_code = radar_set_duty_cycle(radar_driver, 1);
 8024874:	4618      	mov	r0, r3
 8024876:	4611      	mov	r1, r2
 8024878:	f7fc fcd0 	bl	802121c <radar_set_duty_cycle>
			
            return error_code;
 802487c:	e7ef      	b.n	802485e <ep_radar_industrial_handle_message+0x1e>
        }
        break;

	case MSG_IS_ENABLE_DUTY_CYCLE:

		if (num_bytes == 1)
 802487e:	2a01      	cmp	r2, #1
 8024880:	d1eb      	bne.n	802485a <ep_radar_industrial_handle_message+0x1a>
		{
			uint8_t message[2];

			uint8_t flag;

			radar_get_duty_cycle(radar_driver, &flag);
 8024882:	4618      	mov	r0, r3
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024884:	2402      	movs	r4, #2
 8024886:	f10d 0103 	add.w	r1, sp, #3
 802488a:	f7fc fcd9 	bl	8021240 <radar_get_duty_cycle>
 802488e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8024892:	f88d 3005 	strb.w	r3, [sp, #5]
			/* compile message */
			wr_payload_u8(message, 0, MSG_IS_ENABLE_DUTY_CYCLE);
			wr_payload_u8(message, 1, flag);

			/* send message */
			protocol_send_header(endpoint, sizeof(message));
 8024896:	4628      	mov	r0, r5
 8024898:	4621      	mov	r1, r4
 802489a:	f88d 4004 	strb.w	r4, [sp, #4]
 802489e:	f000 f8c3 	bl	8024a28 <protocol_send_header>
			protocol_send_payload(message, sizeof(message));
 80248a2:	a801      	add	r0, sp, #4
 80248a4:	4621      	mov	r1, r4
 80248a6:	f000 f8d3 	bl	8024a50 <protocol_send_payload>
			protocol_send_tail();
 80248aa:	f000 f8d3 	bl	8024a54 <protocol_send_tail>

			return RADAR_ERR_OK;
 80248ae:	2000      	movs	r0, #0
 80248b0:	e7d5      	b.n	802485e <ep_radar_industrial_handle_message+0x1e>

		break;

    case MSG_DISABLE_BGT_LNA:
	
        if (num_bytes == 1)
 80248b2:	2a01      	cmp	r2, #1
 80248b4:	d1d1      	bne.n	802485a <ep_radar_industrial_handle_message+0x1a>
        {    		
        	radar_disable_lna_gain(radar_driver);
 80248b6:	4618      	mov	r0, r3
 80248b8:	f7fc fcca 	bl	8021250 <radar_disable_lna_gain>
			
            return RADAR_ERR_OK;
 80248bc:	2000      	movs	r0, #0
 80248be:	e7ce      	b.n	802485e <ep_radar_industrial_handle_message+0x1e>
        }
        break;
		
	case MSG_ENABLE_BGT_LNA:
	
        if (num_bytes == 1)
 80248c0:	2a01      	cmp	r2, #1
 80248c2:	d1ca      	bne.n	802485a <ep_radar_industrial_handle_message+0x1a>
        {    		
        	radar_enable_lna_gain(radar_driver);
 80248c4:	4618      	mov	r0, r3
 80248c6:	f7fc fccb 	bl	8021260 <radar_enable_lna_gain>

            return RADAR_ERR_OK;
 80248ca:	2000      	movs	r0, #0
 80248cc:	e7c7      	b.n	802485e <ep_radar_industrial_handle_message+0x1e>
		if (num_bytes == 1)
		{
			uint8_t message[2];
			uint8_t flag;

			flag = radar_get_lna_gain_enable_status(radar_driver);
 80248ce:	4618      	mov	r0, r3
 80248d0:	f7fc fcce 	bl	8021270 <radar_get_lna_gain_enable_status>
 80248d4:	2305      	movs	r3, #5
 80248d6:	f88d 0005 	strb.w	r0, [sp, #5]
			/* compile message */
			wr_payload_u8(message, 0, MSG_IS_ENABLE_BGT_LNA);
			wr_payload_u8(message, 1, flag);

			/* send message */
			protocol_send_header(endpoint, sizeof(message));
 80248da:	2102      	movs	r1, #2
 80248dc:	4628      	mov	r0, r5
 80248de:	f88d 3004 	strb.w	r3, [sp, #4]
 80248e2:	f000 f8a1 	bl	8024a28 <protocol_send_header>
			protocol_send_payload(message, sizeof(message));
 80248e6:	a801      	add	r0, sp, #4
 80248e8:	2102      	movs	r1, #2
 80248ea:	f000 f8b1 	bl	8024a50 <protocol_send_payload>
			protocol_send_tail();
 80248ee:	f000 f8b1 	bl	8024a54 <protocol_send_tail>

			return RADAR_ERR_OK;
 80248f2:	2000      	movs	r0, #0
 80248f4:	e7b3      	b.n	802485e <ep_radar_industrial_handle_message+0x1e>
 80248f6:	bf00      	nop

080248f8 <ep_radar_industrial_handle_change>:
    return PROTOCOL_STATUS_INVALID_PAYLOAD;
}

void ep_radar_industrial_handle_change(uint8_t endpoint, void* context,
                                  	   uint32_t what)
{
 80248f8:	4770      	bx	lr
 80248fa:	bf00      	nop

080248fc <ep_radar_p2g_handle_message>:

uint16_t ep_radar_p2g_handle_message(uint8_t endpoint,
                                     uint8_t* message_data,
                                       uint16_t num_bytes,
                                       void* context)
{
 80248fc:	b530      	push	{r4, r5, lr}
	
    (void) radar_driver; /* Suppress compiler warnings of unused variable */

	uint16_t error_code;

    switch (message_data[0])
 80248fe:	780c      	ldrb	r4, [r1, #0]

uint16_t ep_radar_p2g_handle_message(uint8_t endpoint,
                                     uint8_t* message_data,
                                       uint16_t num_bytes,
                                       void* context)
{
 8024900:	b085      	sub	sp, #20
	
    (void) radar_driver; /* Suppress compiler warnings of unused variable */

	uint16_t error_code;

    switch (message_data[0])
 8024902:	b17c      	cbz	r4, 8024924 <ep_radar_p2g_handle_message+0x28>
 8024904:	2c01      	cmp	r4, #1
 8024906:	d003      	beq.n	8024910 <ep_radar_p2g_handle_message+0x14>
    default:
	
		break;
    }

    return PROTOCOL_STATUS_INVALID_PAYLOAD;
 8024908:	f64f 70ff 	movw	r0, #65535	; 0xffff
}
 802490c:	b005      	add	sp, #20
 802490e:	bd30      	pop	{r4, r5, pc}
        }
        break;
	
    case MSG_SET_PGA_LEVEL:
	
        if (num_bytes == 3)
 8024910:	2a03      	cmp	r2, #3
 8024912:	d1f9      	bne.n	8024908 <ep_radar_p2g_handle_message+0xc>
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, uint16_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8024914:	788c      	ldrb	r4, [r1, #2]
 8024916:	7849      	ldrb	r1, [r1, #1]

            /* extract parameters from message */
            gain_level = rd_payload_u16(message_data, 1);
            
            /* apply PGA Gain Level */
            error_code = radar_set_gain_level(radar_driver, gain_level);
 8024918:	4618      	mov	r0, r3
 802491a:	ea41 2104 	orr.w	r1, r1, r4, lsl #8
 802491e:	f7fc fcad 	bl	802127c <radar_set_gain_level>

            return error_code;
 8024922:	e7f3      	b.n	802490c <ep_radar_p2g_handle_message+0x10>
    switch (message_data[0])
    {
		
    case MSG_GET_PGA_LEVEL:
	
        if (num_bytes == 1)
 8024924:	2a01      	cmp	r2, #1
 8024926:	d1ef      	bne.n	8024908 <ep_radar_p2g_handle_message+0xc>
 8024928:	4605      	mov	r5, r0
    uint16_t error_code;
    
	uint16_t gain_level;

    /* get current PGA Gain level from driver */
	error_code = radar_get_gain_level(device, &gain_level);
 802492a:	f10d 010a 	add.w	r1, sp, #10
 802492e:	4618      	mov	r0, r3
 8024930:	9201      	str	r2, [sp, #4]
 8024932:	f7fc fcb7 	bl	80212a4 <radar_get_gain_level>

    if (error_code == RADAR_ERR_OK)
 8024936:	9a01      	ldr	r2, [sp, #4]
 8024938:	4604      	mov	r4, r0
 802493a:	b108      	cbz	r0, 8024940 <ep_radar_p2g_handle_message+0x44>
    uint16_t error_code;
    
	uint16_t gain_level;

    /* get current PGA Gain level from driver */
	error_code = radar_get_gain_level(device, &gain_level);
 802493c:	4620      	mov	r0, r4
	
        if (num_bytes == 1)
        {
			error_code = send_pga_level(radar_driver, endpoint);
			
            return error_code;
 802493e:	e7e5      	b.n	802490c <ep_radar_p2g_handle_message+0x10>
    {
        uint8_t message[3];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_PGA_LEVEL);
        wr_payload_u16(message, 1, gain_level);
 8024940:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024944:	f88d 200c 	strb.w	r2, [sp, #12]

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 8024948:	4628      	mov	r0, r5
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 802494a:	0a1a      	lsrs	r2, r3, #8
 802494c:	2103      	movs	r1, #3
    payload[offset    ] =  value        & 0xFF;
 802494e:	f88d 300d 	strb.w	r3, [sp, #13]
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024952:	f88d 200e 	strb.w	r2, [sp, #14]
 8024956:	f000 f867 	bl	8024a28 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 802495a:	a803      	add	r0, sp, #12
 802495c:	2103      	movs	r1, #3
 802495e:	f000 f877 	bl	8024a50 <protocol_send_payload>
        protocol_send_tail();
 8024962:	f000 f877 	bl	8024a54 <protocol_send_tail>
    uint16_t error_code;
    
	uint16_t gain_level;

    /* get current PGA Gain level from driver */
	error_code = radar_get_gain_level(device, &gain_level);
 8024966:	4620      	mov	r0, r4
 8024968:	e7d0      	b.n	802490c <ep_radar_p2g_handle_message+0x10>
 802496a:	bf00      	nop

0802496c <ep_radar_p2g_handle_change>:
    return PROTOCOL_STATUS_INVALID_PAYLOAD;
}

void ep_radar_p2g_handle_change(uint8_t endpoint, void* context,
                                uint32_t what)
{
 802496c:	4770      	bx	lr
 802496e:	bf00      	nop

08024970 <receive_data>:
    instance.receive_pointer   = instance.message_frame;
    instance.num_bytes_awaited = 4;
}

static void receive_data(void)
{
 8024970:	b530      	push	{r4, r5, lr}
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
 8024972:	4c17      	ldr	r4, [pc, #92]	; (80249d0 <receive_data+0x60>)
    instance.receive_pointer   = instance.message_frame;
    instance.num_bytes_awaited = 4;
}

static void receive_data(void)
{
 8024974:	b083      	sub	sp, #12
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
 8024976:	89a1      	ldrh	r1, [r4, #12]
 8024978:	68a0      	ldr	r0, [r4, #8]
 802497a:	f004 f80d 	bl	8028998 <com_get_data>
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
 802497e:	68a2      	ldr	r2, [r4, #8]
    instance.num_bytes_awaited -= num_received_bytes;
 8024980:	89a3      	ldrh	r3, [r4, #12]

    /* check for timeout */
    if (instance.get_time != NULL)
 8024982:	6a21      	ldr	r1, [r4, #32]
static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
 8024984:	4402      	add	r2, r0
    instance.num_bytes_awaited -= num_received_bytes;
 8024986:	1a1b      	subs	r3, r3, r0
}

static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
 8024988:	4605      	mov	r5, r0
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
 802498a:	60a2      	str	r2, [r4, #8]
    instance.num_bytes_awaited -= num_received_bytes;
 802498c:	81a3      	strh	r3, [r4, #12]

    /* check for timeout */
    if (instance.get_time != NULL)
 802498e:	b1e9      	cbz	r1, 80249cc <receive_data+0x5c>
    {
        /* get current time */
        uint32_t current_time = instance.get_time();
 8024990:	4788      	blx	r1

        /* if no data has been received, check the time since last received
         * bytes
         */
        if (num_received_bytes == 0)
 8024992:	b9d5      	cbnz	r5, 80249ca <receive_data+0x5a>
        {

        	if( instance.time_of_last_byte > current_time)
 8024994:	6923      	ldr	r3, [r4, #16]
 8024996:	4298      	cmp	r0, r3
 8024998:	d317      	bcc.n	80249ca <receive_data+0x5a>
        		/* Handle time wrap-around */
        		instance.time_of_last_byte = current_time;
        	}
        	else {

				if ((instance.state != PROTOCOL_STATE_IDLE) &&
 802499a:	7961      	ldrb	r1, [r4, #5]
 802499c:	b1b1      	cbz	r1, 80249cc <receive_data+0x5c>
					(current_time >= instance.time_of_last_byte +
 802499e:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80249a0:	4413      	add	r3, r2
        		/* Handle time wrap-around */
        		instance.time_of_last_byte = current_time;
        	}
        	else {

				if ((instance.state != PROTOCOL_STATE_IDLE) &&
 80249a2:	4298      	cmp	r0, r3
 80249a4:	d312      	bcc.n	80249cc <receive_data+0x5c>
					(current_time >= instance.time_of_last_byte +
									 instance.timeout_interval))
				{
					/* a timeout has occurred, reset protocol state */
					if (instance.state != PROTOCOL_STATE_CONFUSED)
 80249a6:	2904      	cmp	r1, #4
 80249a8:	d008      	beq.n	80249bc <receive_data+0x4c>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80249aa:	a802      	add	r0, sp, #8
 80249ac:	4b09      	ldr	r3, [pc, #36]	; (80249d4 <receive_data+0x64>)
 80249ae:	f840 3d04 	str.w	r3, [r0, #-4]!
    wr_payload_u8 (status_message, 0, CNST_STARTBYTE_STATUS);
    wr_payload_u8 (status_message, 1, endpoint);
    wr_payload_u16(status_message, 2, status_code);

    /* now send message */
    com_send_data(status_message, sizeof(status_message));
 80249b2:	2104      	movs	r1, #4
 80249b4:	f003 ffee 	bl	8028994 <com_send_data>
    com_flush();
 80249b8:	f003 fffe 	bl	80289b8 <com_flush>
}

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state            = PROTOCOL_STATE_IDLE;
 80249bc:	2300      	movs	r3, #0
    instance.receive_pointer   = instance.message_frame;
 80249be:	4a06      	ldr	r2, [pc, #24]	; (80249d8 <receive_data+0x68>)
}

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state            = PROTOCOL_STATE_IDLE;
 80249c0:	7163      	strb	r3, [r4, #5]
    instance.receive_pointer   = instance.message_frame;
    instance.num_bytes_awaited = 4;
 80249c2:	2304      	movs	r3, #4

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state            = PROTOCOL_STATE_IDLE;
    instance.receive_pointer   = instance.message_frame;
 80249c4:	60a2      	str	r2, [r4, #8]
    instance.num_bytes_awaited = 4;
 80249c6:	81a3      	strh	r3, [r4, #12]
 80249c8:	e000      	b.n	80249cc <receive_data+0x5c>
        else
        {
            /* data has been received, so remember current time for next
             * timeout check
             */
            instance.time_of_last_byte = current_time;
 80249ca:	6120      	str	r0, [r4, #16]
        }
    }
}
 80249cc:	b003      	add	sp, #12
 80249ce:	bd30      	pop	{r4, r5, pc}
 80249d0:	1fff0d08 	.word	0x1fff0d08
 80249d4:	0001005b 	.word	0x0001005b
 80249d8:	1fff0d1c 	.word	0x1fff0d1c

080249dc <protocol_init>:
*/

void protocol_init(Endpoint_t* endpoints, uint8_t num_endpoints,
                   uint32_t (*get_time)(void), uint32_t timeout_interval,
                   void (*do_system_reset)(void))
{
 80249dc:	b538      	push	{r3, r4, r5, lr}
    /* initialize the internal state structure */
    instance.get_time = get_time;
 80249de:	4c0f      	ldr	r4, [pc, #60]	; (8024a1c <protocol_init+0x40>)
*/

void protocol_init(Endpoint_t* endpoints, uint8_t num_endpoints,
                   uint32_t (*get_time)(void), uint32_t timeout_interval,
                   void (*do_system_reset)(void))
{
 80249e0:	9d04      	ldr	r5, [sp, #16]
    /* initialize the internal state structure */
    instance.get_time = get_time;
    instance.timeout_interval = timeout_interval;
 80249e2:	6263      	str	r3, [r4, #36]	; 0x24
    instance.do_system_reset = do_system_reset;

    instance.endpoints = endpoints;
    instance.num_endpoints = num_endpoints;

    instance.state = PROTOCOL_STATE_IDLE;
 80249e4:	2300      	movs	r3, #0
void protocol_init(Endpoint_t* endpoints, uint8_t num_endpoints,
                   uint32_t (*get_time)(void), uint32_t timeout_interval,
                   void (*do_system_reset)(void))
{
    /* initialize the internal state structure */
    instance.get_time = get_time;
 80249e6:	6222      	str	r2, [r4, #32]
    instance.timeout_interval = timeout_interval;
    instance.do_system_reset = do_system_reset;

    instance.endpoints = endpoints;
 80249e8:	6020      	str	r0, [r4, #0]
    instance.num_endpoints = num_endpoints;
 80249ea:	7121      	strb	r1, [r4, #4]
                   void (*do_system_reset)(void))
{
    /* initialize the internal state structure */
    instance.get_time = get_time;
    instance.timeout_interval = timeout_interval;
    instance.do_system_reset = do_system_reset;
 80249ec:	62a5      	str	r5, [r4, #40]	; 0x28

    instance.endpoints = endpoints;
    instance.num_endpoints = num_endpoints;

    instance.state = PROTOCOL_STATE_IDLE;
 80249ee:	7163      	strb	r3, [r4, #5]
    instance.receive_pointer = NULL;
 80249f0:	60a3      	str	r3, [r4, #8]
    instance.num_bytes_awaited = 0;
 80249f2:	81a3      	strh	r3, [r4, #12]
    instance.time_of_last_byte = (get_time != NULL) ? instance.get_time() : 0;
 80249f4:	b182      	cbz	r2, 8024a18 <protocol_init+0x3c>
 80249f6:	4790      	blx	r2
    instance.payload = data_payload;
 80249f8:	4d09      	ldr	r5, [pc, #36]	; (8024a20 <protocol_init+0x44>)
    instance.num_endpoints = num_endpoints;

    instance.state = PROTOCOL_STATE_IDLE;
    instance.receive_pointer = NULL;
    instance.num_bytes_awaited = 0;
    instance.time_of_last_byte = (get_time != NULL) ? instance.get_time() : 0;
 80249fa:	6120      	str	r0, [r4, #16]
static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state            = PROTOCOL_STATE_IDLE;
    instance.receive_pointer   = instance.message_frame;
    instance.num_bytes_awaited = 4;
 80249fc:	2304      	movs	r3, #4

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state            = PROTOCOL_STATE_IDLE;
    instance.receive_pointer   = instance.message_frame;
 80249fe:	4a09      	ldr	r2, [pc, #36]	; (8024a24 <protocol_init+0x48>)

    instance.state = PROTOCOL_STATE_IDLE;
    instance.receive_pointer = NULL;
    instance.num_bytes_awaited = 0;
    instance.time_of_last_byte = (get_time != NULL) ? instance.get_time() : 0;
    instance.payload = data_payload;
 8024a00:	61e5      	str	r5, [r4, #28]
	instance.max_payload = PROTOCOL_MAX_PAYLOAD_SIZE;
 8024a02:	f44f 7000 	mov.w	r0, #512	; 0x200
}

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state            = PROTOCOL_STATE_IDLE;
 8024a06:	2100      	movs	r1, #0
    instance.state = PROTOCOL_STATE_IDLE;
    instance.receive_pointer = NULL;
    instance.num_bytes_awaited = 0;
    instance.time_of_last_byte = (get_time != NULL) ? instance.get_time() : 0;
    instance.payload = data_payload;
	instance.max_payload = PROTOCOL_MAX_PAYLOAD_SIZE;
 8024a08:	62e0      	str	r0, [r4, #44]	; 0x2c
}

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state            = PROTOCOL_STATE_IDLE;
 8024a0a:	7161      	strb	r1, [r4, #5]
    instance.receive_pointer   = instance.message_frame;
 8024a0c:	60a2      	str	r2, [r4, #8]
    instance.num_bytes_awaited = 4;
 8024a0e:	81a3      	strh	r3, [r4, #12]
    /* initialize state */
    reset_state();

    /* initialize communication interface */
    com_init();
}
 8024a10:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

    /* initialize state */
    reset_state();

    /* initialize communication interface */
    com_init();
 8024a14:	f003 bfbc 	b.w	8028990 <com_init>
    instance.num_endpoints = num_endpoints;

    instance.state = PROTOCOL_STATE_IDLE;
    instance.receive_pointer = NULL;
    instance.num_bytes_awaited = 0;
    instance.time_of_last_byte = (get_time != NULL) ? instance.get_time() : 0;
 8024a18:	4610      	mov	r0, r2
 8024a1a:	e7ed      	b.n	80249f8 <protocol_init+0x1c>
 8024a1c:	1fff0d08 	.word	0x1fff0d08
 8024a20:	1fff0d38 	.word	0x1fff0d38
 8024a24:	1fff0d1c 	.word	0x1fff0d1c

08024a28 <protocol_send_header>:
         */
    }
}

void protocol_send_header(uint8_t endpoint, uint16_t num_bytes)
{
 8024a28:	b510      	push	{r4, lr}
 8024a2a:	b082      	sub	sp, #8
 8024a2c:	460b      	mov	r3, r1
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024a2e:	0a0c      	lsrs	r4, r1, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024a30:	f88d 0005 	strb.w	r0, [sp, #5]
 8024a34:	225a      	movs	r2, #90	; 0x5a
    uint8_t header[4];
    wr_payload_u8 (header, 0, CNST_STARTBYTE_DATA);
    wr_payload_u8 (header, 1, endpoint);
    wr_payload_u16(header, 2, num_bytes);

    com_send_data(header, sizeof(header));
 8024a36:	a801      	add	r0, sp, #4
 8024a38:	2104      	movs	r1, #4

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024a3a:	f88d 3006 	strb.w	r3, [sp, #6]
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024a3e:	f88d 4007 	strb.w	r4, [sp, #7]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024a42:	f88d 2004 	strb.w	r2, [sp, #4]
 8024a46:	f003 ffa5 	bl	8028994 <com_send_data>
}
 8024a4a:	b002      	add	sp, #8
 8024a4c:	bd10      	pop	{r4, pc}
 8024a4e:	bf00      	nop

08024a50 <protocol_send_payload>:

void protocol_send_payload(const uint8_t* message_data, uint16_t num_bytes)
{
    /* send the data through the communication stream interface */
    com_send_data(message_data, num_bytes);
 8024a50:	f003 bfa0 	b.w	8028994 <com_send_data>

08024a54 <protocol_send_tail>:
}

void protocol_send_tail(void)
{
 8024a54:	b500      	push	{lr}
 8024a56:	b083      	sub	sp, #12

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024a58:	a802      	add	r0, sp, #8
 8024a5a:	23db      	movs	r3, #219	; 0xdb
 8024a5c:	f800 3d04 	strb.w	r3, [r0, #-4]!
    /* setup message tail and send it */
    uint8_t tail[2];
    wr_payload_u16(tail, 0, CNST_END_OF_PAYLOAD);

    com_send_data(tail, sizeof(tail));
 8024a60:	2102      	movs	r1, #2
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024a62:	23e0      	movs	r3, #224	; 0xe0
 8024a64:	f88d 3005 	strb.w	r3, [sp, #5]
 8024a68:	f003 ff94 	bl	8028994 <com_send_data>
    com_flush();
 8024a6c:	f003 ffa4 	bl	80289b8 <com_flush>
}
 8024a70:	b003      	add	sp, #12
 8024a72:	f85d fb04 	ldr.w	pc, [sp], #4
 8024a76:	bf00      	nop

08024a78 <protocol_run>:
    /* initialize communication interface */
    com_init();
}

void protocol_run(void)
{
 8024a78:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if (instance.state != PROTOCOL_STATE_CONFUSED)
 8024a7c:	4c9b      	ldr	r4, [pc, #620]	; (8024cec <protocol_run+0x274>)
 8024a7e:	7963      	ldrb	r3, [r4, #5]
 8024a80:	2b04      	cmp	r3, #4
    /* initialize communication interface */
    com_init();
}

void protocol_run(void)
{
 8024a82:	b092      	sub	sp, #72	; 0x48
    if (instance.state != PROTOCOL_STATE_CONFUSED)
 8024a84:	d02b      	beq.n	8024ade <protocol_run+0x66>
    {
        /* if the protocol is in a defined state, read the next bytes from the
         * input stream
         */
        receive_data();
 8024a86:	f7ff ff73 	bl	8024970 <receive_data>
        /*
         * now process data until the end of a message has been reached
         * (note the missing brakes, the fall through is intended to proceed
         * with the message, so don't wonder)
         */
        switch (instance.state)
 8024a8a:	7963      	ldrb	r3, [r4, #5]
 8024a8c:	2b03      	cmp	r3, #3
 8024a8e:	d824      	bhi.n	8024ada <protocol_run+0x62>
 8024a90:	e8df f003 	tbb	[pc, r3]
 8024a94:	70890207 	.word	0x70890207
            /* no break, fall through and continue with
             * PROTOCOL_STATE_RECEIVING_HEADER
             */

        case PROTOCOL_STATE_RECEIVING_HEADER:
            if (instance.num_bytes_awaited == 0)
 8024a98:	89a3      	ldrh	r3, [r4, #12]
 8024a9a:	b153      	cbz	r3, 8024ab2 <protocol_run+0x3a>
        /*
         * The receive_data function may switch the state back to idle, if a
         * timeout occurs, this is the  only way to get out of confused state.
         */
    }
}
 8024a9c:	b012      	add	sp, #72	; 0x48
 8024a9e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        {
        case PROTOCOL_STATE_IDLE:
            /* if at least one byte has been received, the state is not idle
             *  any more
             */
            if (instance.num_bytes_awaited < 4)
 8024aa2:	89a3      	ldrh	r3, [r4, #12]
 8024aa4:	4a91      	ldr	r2, [pc, #580]	; (8024cec <protocol_run+0x274>)
 8024aa6:	2b03      	cmp	r3, #3
 8024aa8:	d8f8      	bhi.n	8024a9c <protocol_run+0x24>
                instance.state = PROTOCOL_STATE_RECEIVING_HEADER;
 8024aaa:	2101      	movs	r1, #1
 8024aac:	7151      	strb	r1, [r2, #5]
            /* no break, fall through and continue with
             * PROTOCOL_STATE_RECEIVING_HEADER
             */

        case PROTOCOL_STATE_RECEIVING_HEADER:
            if (instance.num_bytes_awaited == 0)
 8024aae:	2b00      	cmp	r3, #0
 8024ab0:	d1f4      	bne.n	8024a9c <protocol_run+0x24>
                sync_byte    = rd_payload_u8 (instance.message_frame, 0);
                endpoint     = rd_payload_u8 (instance.message_frame, 1);
                payload_size = rd_payload_u16(instance.message_frame, 2);

                /* check sync bye, message must be a payload message */
                if (sync_byte != CNST_STARTBYTE_DATA)
 8024ab2:	7d23      	ldrb	r3, [r4, #20]
 *
 * \return The function returns the value read from the payload.
 */
static inline uint8_t rd_payload_u8(const uint8_t* payload, uint16_t offset)
{
    return payload[offset];
 8024ab4:	4e8d      	ldr	r6, [pc, #564]	; (8024cec <protocol_run+0x274>)
 8024ab6:	7d60      	ldrb	r0, [r4, #21]
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, uint16_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8024ab8:	7de1      	ldrb	r1, [r4, #23]
            ((uint16_t)payload[offset    ]);
 8024aba:	7da2      	ldrb	r2, [r4, #22]
 8024abc:	2b5a      	cmp	r3, #90	; 0x5a
 8024abe:	d078      	beq.n	8024bb2 <protocol_run+0x13a>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024ac0:	4b8b      	ldr	r3, [pc, #556]	; (8024cf0 <protocol_run+0x278>)
 8024ac2:	ad12      	add	r5, sp, #72	; 0x48
 8024ac4:	f845 3d40 	str.w	r3, [r5, #-64]!
                end_sequence = rd_payload_u16(instance.message_frame, 4);

                /* check end of payload sequence */
                if (end_sequence != CNST_END_OF_PAYLOAD)
                {
                    instance.state = PROTOCOL_STATE_CONFUSED;
 8024ac8:	2304      	movs	r3, #4
    wr_payload_u8 (status_message, 0, CNST_STARTBYTE_STATUS);
    wr_payload_u8 (status_message, 1, endpoint);
    wr_payload_u16(status_message, 2, status_code);

    /* now send message */
    com_send_data(status_message, sizeof(status_message));
 8024aca:	4628      	mov	r0, r5
 8024acc:	4619      	mov	r1, r3
                end_sequence = rd_payload_u16(instance.message_frame, 4);

                /* check end of payload sequence */
                if (end_sequence != CNST_END_OF_PAYLOAD)
                {
                    instance.state = PROTOCOL_STATE_CONFUSED;
 8024ace:	7173      	strb	r3, [r6, #5]
    wr_payload_u8 (status_message, 0, CNST_STARTBYTE_STATUS);
    wr_payload_u8 (status_message, 1, endpoint);
    wr_payload_u16(status_message, 2, status_code);

    /* now send message */
    com_send_data(status_message, sizeof(status_message));
 8024ad0:	f003 ff60 	bl	8028994 <com_send_data>
    com_flush();
 8024ad4:	f003 ff70 	bl	80289b8 <com_flush>
 8024ad8:	7973      	ldrb	r3, [r6, #5]
    }

    /* if state is confused, keep on reading into a dummy buffer, until
     * receive buffer is empty
     */
    if (instance.state == PROTOCOL_STATE_CONFUSED)
 8024ada:	2b04      	cmp	r3, #4
 8024adc:	d1de      	bne.n	8024a9c <protocol_run+0x24>
    {
        uint8_t dummy_buffer[64];
        do
        {
            instance.receive_pointer = dummy_buffer;
 8024ade:	4e83      	ldr	r6, [pc, #524]	; (8024cec <protocol_run+0x274>)
 8024ae0:	ad02      	add	r5, sp, #8
            instance.num_bytes_awaited = sizeof(dummy_buffer);
 8024ae2:	2740      	movs	r7, #64	; 0x40
}

static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
 8024ae4:	2140      	movs	r1, #64	; 0x40
 8024ae6:	4628      	mov	r0, r5
    if (instance.state == PROTOCOL_STATE_CONFUSED)
    {
        uint8_t dummy_buffer[64];
        do
        {
            instance.receive_pointer = dummy_buffer;
 8024ae8:	60a5      	str	r5, [r4, #8]
            instance.num_bytes_awaited = sizeof(dummy_buffer);
 8024aea:	81a7      	strh	r7, [r4, #12]
}

static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
 8024aec:	f003 ff54 	bl	8028998 <com_get_data>
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
    instance.num_bytes_awaited -= num_received_bytes;
 8024af0:	89a3      	ldrh	r3, [r4, #12]
static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
 8024af2:	68a2      	ldr	r2, [r4, #8]
    instance.num_bytes_awaited -= num_received_bytes;

    /* check for timeout */
    if (instance.get_time != NULL)
 8024af4:	6a21      	ldr	r1, [r4, #32]
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
    instance.num_bytes_awaited -= num_received_bytes;
 8024af6:	1a1b      	subs	r3, r3, r0
 8024af8:	b29b      	uxth	r3, r3
static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
 8024afa:	4402      	add	r2, r0
}

static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
 8024afc:	4680      	mov	r8, r0
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
    instance.num_bytes_awaited -= num_received_bytes;
 8024afe:	81a3      	strh	r3, [r4, #12]
static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
 8024b00:	60a2      	str	r2, [r4, #8]
    instance.num_bytes_awaited -= num_received_bytes;

    /* check for timeout */
    if (instance.get_time != NULL)
 8024b02:	b311      	cbz	r1, 8024b4a <protocol_run+0xd2>
    {
        /* get current time */
        uint32_t current_time = instance.get_time();
 8024b04:	4788      	blx	r1

        /* if no data has been received, check the time since last received
         * bytes
         */
        if (num_received_bytes == 0)
 8024b06:	f1b8 0f00 	cmp.w	r8, #0
 8024b0a:	d121      	bne.n	8024b50 <protocol_run+0xd8>
        {

        	if( instance.time_of_last_byte > current_time)
 8024b0c:	6933      	ldr	r3, [r6, #16]
 8024b0e:	4298      	cmp	r0, r3
 8024b10:	d319      	bcc.n	8024b46 <protocol_run+0xce>
        		/* Handle time wrap-around */
        		instance.time_of_last_byte = current_time;
        	}
        	else {

				if ((instance.state != PROTOCOL_STATE_IDLE) &&
 8024b12:	7971      	ldrb	r1, [r6, #5]
 8024b14:	b309      	cbz	r1, 8024b5a <protocol_run+0xe2>
					(current_time >= instance.time_of_last_byte +
 8024b16:	6a72      	ldr	r2, [r6, #36]	; 0x24
 8024b18:	4413      	add	r3, r2
        		/* Handle time wrap-around */
        		instance.time_of_last_byte = current_time;
        	}
        	else {

				if ((instance.state != PROTOCOL_STATE_IDLE) &&
 8024b1a:	4298      	cmp	r0, r3
 8024b1c:	d31d      	bcc.n	8024b5a <protocol_run+0xe2>
					(current_time >= instance.time_of_last_byte +
									 instance.timeout_interval))
				{
					/* a timeout has occurred, reset protocol state */
					if (instance.state != PROTOCOL_STATE_CONFUSED)
 8024b1e:	2904      	cmp	r1, #4
 8024b20:	d008      	beq.n	8024b34 <protocol_run+0xbc>
 8024b22:	a812      	add	r0, sp, #72	; 0x48
 8024b24:	4b73      	ldr	r3, [pc, #460]	; (8024cf4 <protocol_run+0x27c>)
 8024b26:	f840 3d44 	str.w	r3, [r0, #-68]!
    wr_payload_u8 (status_message, 0, CNST_STARTBYTE_STATUS);
    wr_payload_u8 (status_message, 1, endpoint);
    wr_payload_u16(status_message, 2, status_code);

    /* now send message */
    com_send_data(status_message, sizeof(status_message));
 8024b2a:	2104      	movs	r1, #4
 8024b2c:	f003 ff32 	bl	8028994 <com_send_data>
    com_flush();
 8024b30:	f003 ff42 	bl	80289b8 <com_flush>
}

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state            = PROTOCOL_STATE_IDLE;
 8024b34:	2300      	movs	r3, #0
    instance.receive_pointer   = instance.message_frame;
 8024b36:	4a70      	ldr	r2, [pc, #448]	; (8024cf8 <protocol_run+0x280>)
}

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state            = PROTOCOL_STATE_IDLE;
 8024b38:	7163      	strb	r3, [r4, #5]
    instance.receive_pointer   = instance.message_frame;
    instance.num_bytes_awaited = 4;
 8024b3a:	2304      	movs	r3, #4

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state            = PROTOCOL_STATE_IDLE;
    instance.receive_pointer   = instance.message_frame;
 8024b3c:	60a2      	str	r2, [r4, #8]
    instance.num_bytes_awaited = 4;
 8024b3e:	81a3      	strh	r3, [r4, #12]
        /*
         * The receive_data function may switch the state back to idle, if a
         * timeout occurs, this is the  only way to get out of confused state.
         */
    }
}
 8024b40:	b012      	add	sp, #72	; 0x48
 8024b42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8024b46:	89b3      	ldrh	r3, [r6, #12]
        {

        	if( instance.time_of_last_byte > current_time)
        	{
        		/* Handle time wrap-around */
        		instance.time_of_last_byte = current_time;
 8024b48:	6130      	str	r0, [r6, #16]
        do
        {
            instance.receive_pointer = dummy_buffer;
            instance.num_bytes_awaited = sizeof(dummy_buffer);
            receive_data();
        } while (instance.num_bytes_awaited == 0);
 8024b4a:	2b00      	cmp	r3, #0
 8024b4c:	d0ca      	beq.n	8024ae4 <protocol_run+0x6c>
 8024b4e:	e7a5      	b.n	8024a9c <protocol_run+0x24>
 8024b50:	89b3      	ldrh	r3, [r6, #12]
        else
        {
            /* data has been received, so remember current time for next
             * timeout check
             */
            instance.time_of_last_byte = current_time;
 8024b52:	6130      	str	r0, [r6, #16]
        do
        {
            instance.receive_pointer = dummy_buffer;
            instance.num_bytes_awaited = sizeof(dummy_buffer);
            receive_data();
        } while (instance.num_bytes_awaited == 0);
 8024b54:	2b00      	cmp	r3, #0
 8024b56:	d0c5      	beq.n	8024ae4 <protocol_run+0x6c>
 8024b58:	e7a0      	b.n	8024a9c <protocol_run+0x24>
 8024b5a:	89a3      	ldrh	r3, [r4, #12]
 8024b5c:	2b00      	cmp	r3, #0
 8024b5e:	d0c1      	beq.n	8024ae4 <protocol_run+0x6c>
 8024b60:	e79c      	b.n	8024a9c <protocol_run+0x24>

        case PROTOCOL_STATE_RECEIVING_PAYLOAD:
            if (instance.num_bytes_awaited == 0)
            {
                /* prepare for receiving message tail */
                instance.receive_pointer = instance.message_frame + 4;
 8024b62:	f103 0018 	add.w	r0, r3, #24
                instance.num_bytes_awaited = 2;
 8024b66:	2102      	movs	r1, #2
                instance.state = PROTOCOL_STATE_RECEIVING_TAIL;
 8024b68:	2203      	movs	r2, #3

        case PROTOCOL_STATE_RECEIVING_PAYLOAD:
            if (instance.num_bytes_awaited == 0)
            {
                /* prepare for receiving message tail */
                instance.receive_pointer = instance.message_frame + 4;
 8024b6a:	6098      	str	r0, [r3, #8]
                instance.num_bytes_awaited = 2;
 8024b6c:	8199      	strh	r1, [r3, #12]
                instance.state = PROTOCOL_STATE_RECEIVING_TAIL;
 8024b6e:	715a      	strb	r2, [r3, #5]

                /* try to read payload */
                receive_data();
 8024b70:	f7ff fefe 	bl	8024970 <receive_data>
                 */
                break;
            }

        case PROTOCOL_STATE_RECEIVING_TAIL:
            if (instance.num_bytes_awaited == 0)
 8024b74:	89a3      	ldrh	r3, [r4, #12]
 8024b76:	4e5d      	ldr	r6, [pc, #372]	; (8024cec <protocol_run+0x274>)
 8024b78:	2b00      	cmp	r3, #0
 8024b7a:	d1ad      	bne.n	8024ad8 <protocol_run+0x60>
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, uint16_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8024b7c:	7e71      	ldrb	r1, [r6, #25]
 8024b7e:	7e33      	ldrb	r3, [r6, #24]
 *
 * \return The function returns the value read from the payload.
 */
static inline uint8_t rd_payload_u8(const uint8_t* payload, uint16_t offset)
{
    return payload[offset];
 8024b80:	7d77      	ldrb	r7, [r6, #21]
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, uint16_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8024b82:	7df0      	ldrb	r0, [r6, #23]
            ((uint16_t)payload[offset    ]);
 8024b84:	7db2      	ldrb	r2, [r6, #22]
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, uint16_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8024b86:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
                endpoint     = rd_payload_u8 (instance.message_frame, 1);
                payload_size = rd_payload_u16(instance.message_frame, 2);
                end_sequence = rd_payload_u16(instance.message_frame, 4);

                /* check end of payload sequence */
                if (end_sequence != CNST_END_OF_PAYLOAD)
 8024b8a:	f24e 01db 	movw	r1, #57563	; 0xe0db
 8024b8e:	428b      	cmp	r3, r1
 8024b90:	d01b      	beq.n	8024bca <protocol_run+0x152>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024b92:	ad12      	add	r5, sp, #72	; 0x48
 8024b94:	4b59      	ldr	r3, [pc, #356]	; (8024cfc <protocol_run+0x284>)
 8024b96:	e795      	b.n	8024ac4 <protocol_run+0x4c>
                      instance.state = PROTOCOL_STATE_CONFUSED;
                      send_status_message(0, PROTOCOL_ERROR_OUT_OF_MEMORY);
                      break;
                    }

                    instance.receive_pointer = instance.payload;
 8024b98:	69f1      	ldr	r1, [r6, #28]
                    instance.num_bytes_awaited = payload_size;
 8024b9a:	81b2      	strh	r2, [r6, #12]
                    instance.state = PROTOCOL_STATE_RECEIVING_PAYLOAD;
 8024b9c:	2302      	movs	r3, #2
                      instance.state = PROTOCOL_STATE_CONFUSED;
                      send_status_message(0, PROTOCOL_ERROR_OUT_OF_MEMORY);
                      break;
                    }

                    instance.receive_pointer = instance.payload;
 8024b9e:	60b1      	str	r1, [r6, #8]
                    instance.num_bytes_awaited = payload_size;
                    instance.state = PROTOCOL_STATE_RECEIVING_PAYLOAD;
 8024ba0:	7173      	strb	r3, [r6, #5]
                    send_status_message(0, PROTOCOL_ERROR_BAD_ENDPOINT_ID);
                    break;
                }

                /* try to read payload */
                receive_data();
 8024ba2:	f7ff fee5 	bl	8024970 <receive_data>
                 */
                break;
            }

        case PROTOCOL_STATE_RECEIVING_PAYLOAD:
            if (instance.num_bytes_awaited == 0)
 8024ba6:	89a2      	ldrh	r2, [r4, #12]
 8024ba8:	4b50      	ldr	r3, [pc, #320]	; (8024cec <protocol_run+0x274>)
 8024baa:	2a00      	cmp	r2, #0
 8024bac:	d0d9      	beq.n	8024b62 <protocol_run+0xea>
 8024bae:	795b      	ldrb	r3, [r3, #5]
 8024bb0:	e793      	b.n	8024ada <protocol_run+0x62>
                    send_status_message(0, PROTOCOL_ERROR_BAD_MESSAGE_START);
                    break;
                }

                /* check message header for endpoint number */
                if (endpoint <= instance.num_endpoints)
 8024bb2:	7933      	ldrb	r3, [r6, #4]
 8024bb4:	4283      	cmp	r3, r0
 8024bb6:	d329      	bcc.n	8024c0c <protocol_run+0x194>
                {
                    /* check payload size (A message with no payload makes no
                     * sense)
                     */
                    if (payload_size == 0)
 8024bb8:	ea52 2201 	orrs.w	r2, r2, r1, lsl #8
 8024bbc:	d049      	beq.n	8024c52 <protocol_run+0x1da>
                        send_status_message(0, PROTOCOL_ERROR_NO_PAYLOAD);
                        break;
                    }

                    /* prepare for receiving payload */
                    if (payload_size > instance.max_payload)
 8024bbe:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8024bc0:	429a      	cmp	r2, r3
 8024bc2:	d9e9      	bls.n	8024b98 <protocol_run+0x120>
 8024bc4:	ad12      	add	r5, sp, #72	; 0x48
 8024bc6:	4b4e      	ldr	r3, [pc, #312]	; (8024d00 <protocol_run+0x288>)
 8024bc8:	e77c      	b.n	8024ac4 <protocol_run+0x4c>
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, uint16_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8024bca:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
                    instance.state = PROTOCOL_STATE_CONFUSED;
                    send_status_message(0, PROTOCOL_ERROR_BAD_PAYLOAD_END);
                    break;
                }

                if (endpoint != 0)
 8024bce:	b307      	cbz	r7, 8024c12 <protocol_run+0x19a>
                    Endpoint_t* current_ep;

                    /* now send the payload package to the addressed endpoint
                     * and send the status code back
                     */
                    current_ep = &(instance.endpoints[endpoint-1]);
 8024bd0:	6835      	ldr	r5, [r6, #0]
                    status_code = current_ep->handle_message(endpoint,
 8024bd2:	69f1      	ldr	r1, [r6, #28]
                    Endpoint_t* current_ep;

                    /* now send the payload package to the addressed endpoint
                     * and send the status code back
                     */
                    current_ep = &(instance.endpoints[endpoint-1]);
 8024bd4:	2014      	movs	r0, #20
 8024bd6:	f06f 0313 	mvn.w	r3, #19
 8024bda:	fb10 3307 	smlabb	r3, r0, r7, r3
 8024bde:	442b      	add	r3, r5
                    status_code = current_ep->handle_message(endpoint,
 8024be0:	4638      	mov	r0, r7
 8024be2:	689d      	ldr	r5, [r3, #8]
 8024be4:	68db      	ldr	r3, [r3, #12]
 8024be6:	47a8      	blx	r5
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024be8:	225b      	movs	r2, #91	; 0x5b
 8024bea:	4603      	mov	r3, r0
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024bec:	0a05      	lsrs	r5, r0, #8
    wr_payload_u8 (status_message, 0, CNST_STARTBYTE_STATUS);
    wr_payload_u8 (status_message, 1, endpoint);
    wr_payload_u16(status_message, 2, status_code);

    /* now send message */
    com_send_data(status_message, sizeof(status_message));
 8024bee:	2104      	movs	r1, #4
 8024bf0:	a802      	add	r0, sp, #8
    payload[offset    ] =  value        & 0xFF;
 8024bf2:	f88d 300a 	strb.w	r3, [sp, #10]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024bf6:	f88d 2008 	strb.w	r2, [sp, #8]
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024bfa:	f88d 500b 	strb.w	r5, [sp, #11]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024bfe:	f88d 7009 	strb.w	r7, [sp, #9]
 8024c02:	f003 fec7 	bl	8028994 <com_send_data>
    com_flush();
 8024c06:	f003 fed7 	bl	80289b8 <com_flush>
 8024c0a:	e793      	b.n	8024b34 <protocol_run+0xbc>
 8024c0c:	ad12      	add	r5, sp, #72	; 0x48
 8024c0e:	4b3d      	ldr	r3, [pc, #244]	; (8024d04 <protocol_run+0x28c>)
 8024c10:	e758      	b.n	8024ac4 <protocol_run+0x4c>
 8024c12:	69f3      	ldr	r3, [r6, #28]
 8024c14:	f893 8000 	ldrb.w	r8, [r3]
}

static uint16_t handle_message(uint8_t* message_data, uint16_t num_bytes)
{
    /* check command byte of received message */
    switch (message_data[0])
 8024c18:	f1b8 0f01 	cmp.w	r8, #1
 8024c1c:	d076      	beq.n	8024d0c <protocol_run+0x294>
 8024c1e:	d31b      	bcc.n	8024c58 <protocol_run+0x1e0>
 8024c20:	f1b8 0f02 	cmp.w	r8, #2
 8024c24:	d102      	bne.n	8024c2c <protocol_run+0x1b4>
            return PROTOCOL_ERROR_OK;
        }
        break;

    case CNST_MSG_FIRMWARE_RESET:
        if (num_bytes == 1)
 8024c26:	2a01      	cmp	r2, #1
 8024c28:	f000 80c1 	beq.w	8024dae <protocol_run+0x336>
        {
            /* if user did not set system reset function, this feature is not
             * supported.
             */
            if (instance.do_system_reset == NULL)
 8024c2c:	27ff      	movs	r7, #255	; 0xff
 8024c2e:	ad02      	add	r5, sp, #8
 8024c30:	225b      	movs	r2, #91	; 0x5b
 8024c32:	2300      	movs	r3, #0
    wr_payload_u8 (status_message, 0, CNST_STARTBYTE_STATUS);
    wr_payload_u8 (status_message, 1, endpoint);
    wr_payload_u16(status_message, 2, status_code);

    /* now send message */
    com_send_data(status_message, sizeof(status_message));
 8024c34:	4628      	mov	r0, r5
 8024c36:	2104      	movs	r1, #4
 8024c38:	f88d 2008 	strb.w	r2, [sp, #8]
 8024c3c:	f88d 3009 	strb.w	r3, [sp, #9]
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024c40:	f88d 700b 	strb.w	r7, [sp, #11]
    payload[offset    ] =  value        & 0xFF;
 8024c44:	f88d 700a 	strb.w	r7, [sp, #10]
 8024c48:	f003 fea4 	bl	8028994 <com_send_data>
    com_flush();
 8024c4c:	f003 feb4 	bl	80289b8 <com_flush>
 8024c50:	e770      	b.n	8024b34 <protocol_run+0xbc>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024c52:	ad12      	add	r5, sp, #72	; 0x48
 8024c54:	4b2c      	ldr	r3, [pc, #176]	; (8024d08 <protocol_run+0x290>)
 8024c56:	e735      	b.n	8024ac4 <protocol_run+0x4c>
{
    /* check command byte of received message */
    switch (message_data[0])
    {
    case CNST_MSG_QUERY_ENDPOINT_INFO:
        if (num_bytes == 1)
 8024c58:	2a01      	cmp	r2, #1
 8024c5a:	d1e7      	bne.n	8024c2c <protocol_run+0x1b4>
    uint8_t i;

    /* setup message start (type und number of endpoints */
    uint8_t message_header[2];
    wr_payload_u8(message_header, 0, CNST_MSG_ENDPOINT_INFO);
    wr_payload_u8(message_header, 1, instance.num_endpoints);
 8024c5c:	7932      	ldrb	r2, [r6, #4]
 8024c5e:	f88d 2005 	strb.w	r2, [sp, #5]

    /* calculate message size and send start of message */
    protocol_send_header(0, 6 * instance.num_endpoints +
 8024c62:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 8024c66:	005b      	lsls	r3, r3, #1
 8024c68:	3302      	adds	r3, #2
 8024c6a:	b29b      	uxth	r3, r3
    uint8_t header[4];
    wr_payload_u8 (header, 0, CNST_STARTBYTE_DATA);
    wr_payload_u8 (header, 1, endpoint);
    wr_payload_u16(header, 2, num_bytes);

    com_send_data(header, sizeof(header));
 8024c6c:	ad02      	add	r5, sp, #8
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024c6e:	ea4f 2c13 	mov.w	ip, r3, lsr #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024c72:	f04f 0e5a 	mov.w	lr, #90	; 0x5a
 8024c76:	4628      	mov	r0, r5
 8024c78:	2104      	movs	r1, #4

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024c7a:	f88d 300a 	strb.w	r3, [sp, #10]
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024c7e:	f88d c00b 	strb.w	ip, [sp, #11]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024c82:	f88d e008 	strb.w	lr, [sp, #8]
 8024c86:	f88d 7004 	strb.w	r7, [sp, #4]
 8024c8a:	f88d 7009 	strb.w	r7, [sp, #9]
 8024c8e:	f003 fe81 	bl	8028994 <com_send_data>
}

void protocol_send_payload(const uint8_t* message_data, uint16_t num_bytes)
{
    /* send the data through the communication stream interface */
    com_send_data(message_data, num_bytes);
 8024c92:	a801      	add	r0, sp, #4
 8024c94:	2102      	movs	r1, #2
 8024c96:	f003 fe7d 	bl	8028994 <com_send_data>
    protocol_send_header(0, 6 * instance.num_endpoints +
                            sizeof(message_header));
    protocol_send_payload(message_header, sizeof(message_header));

    /* now send type and version for each endpoint */
    for (i = 0; i < instance.num_endpoints; ++i)
 8024c9a:	7933      	ldrb	r3, [r6, #4]
 8024c9c:	b30b      	cbz	r3, 8024ce2 <protocol_run+0x26a>
    {
        uint8_t ep_info[6];
        wr_payload_u32(ep_info, 0, instance.endpoints[i].endpoint_type);
 8024c9e:	b23a      	sxth	r2, r7
 8024ca0:	6821      	ldr	r1, [r4, #0]
 8024ca2:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    protocol_send_header(0, 6 * instance.num_endpoints +
                            sizeof(message_header));
    protocol_send_payload(message_header, sizeof(message_header));

    /* now send type and version for each endpoint */
    for (i = 0; i < instance.num_endpoints; ++i)
 8024ca6:	3701      	adds	r7, #1
    {
        uint8_t ep_info[6];
        wr_payload_u32(ep_info, 0, instance.endpoints[i].endpoint_type);
 8024ca8:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024cac:	f88d 3008 	strb.w	r3, [sp, #8]
 8024cb0:	eb01 0282 	add.w	r2, r1, r2, lsl #2
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024cb4:	0e18      	lsrs	r0, r3, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024cb6:	0c19      	lsrs	r1, r3, #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024cb8:	0a1b      	lsrs	r3, r3, #8
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024cba:	f88d 000b 	strb.w	r0, [sp, #11]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024cbe:	f88d 100a 	strb.w	r1, [sp, #10]
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024cc2:	f88d 3009 	strb.w	r3, [sp, #9]
        wr_payload_u16(ep_info, 4, instance.endpoints[i].endpoint_version);
 8024cc6:	8893      	ldrh	r3, [r2, #4]

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024cc8:	f88d 300c 	strb.w	r3, [sp, #12]
}

void protocol_send_payload(const uint8_t* message_data, uint16_t num_bytes)
{
    /* send the data through the communication stream interface */
    com_send_data(message_data, num_bytes);
 8024ccc:	4628      	mov	r0, r5
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024cce:	0a1b      	lsrs	r3, r3, #8
 8024cd0:	2106      	movs	r1, #6
 8024cd2:	f88d 300d 	strb.w	r3, [sp, #13]
 8024cd6:	f003 fe5d 	bl	8028994 <com_send_data>
    protocol_send_header(0, 6 * instance.num_endpoints +
                            sizeof(message_header));
    protocol_send_payload(message_header, sizeof(message_header));

    /* now send type and version for each endpoint */
    for (i = 0; i < instance.num_endpoints; ++i)
 8024cda:	7923      	ldrb	r3, [r4, #4]
 8024cdc:	b2ff      	uxtb	r7, r7
 8024cde:	42bb      	cmp	r3, r7
 8024ce0:	d8dd      	bhi.n	8024c9e <protocol_run+0x226>
        wr_payload_u16(ep_info, 4, instance.endpoints[i].endpoint_version);
        protocol_send_payload(ep_info, sizeof(ep_info));
    }

    /* finish the message */
    protocol_send_tail();
 8024ce2:	f7ff feb7 	bl	8024a54 <protocol_send_tail>
 8024ce6:	4647      	mov	r7, r8
 8024ce8:	e7a2      	b.n	8024c30 <protocol_run+0x1b8>
 8024cea:	bf00      	nop
 8024cec:	1fff0d08 	.word	0x1fff0d08
 8024cf0:	0002005b 	.word	0x0002005b
 8024cf4:	0001005b 	.word	0x0001005b
 8024cf8:	1fff0d1c 	.word	0x1fff0d1c
 8024cfc:	0007005b 	.word	0x0007005b
 8024d00:	0006005b 	.word	0x0006005b
 8024d04:	0003005b 	.word	0x0003005b
 8024d08:	0005005b 	.word	0x0005005b
            return PROTOCOL_ERROR_OK;
        }
        break;

    case CNST_MSG_QUERY_FW_INFO:
        if (num_bytes == 1)
 8024d0c:	2a01      	cmp	r2, #1
 8024d0e:	d18d      	bne.n	8024c2c <protocol_run+0x1b4>
    uint16_t string_length = 0;

    /* setup message start (type and number of endpoints */
    uint8_t message[7];
    wr_payload_u8 (message, 0, CNST_MSG_FW_INFO);
    wr_payload_u16(message, 1, firmware_information.version_major);
 8024d10:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 8024dd0 <protocol_run+0x358>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024d14:	f88d 2008 	strb.w	r2, [sp, #8]
 8024d18:	f8b8 3004 	ldrh.w	r3, [r8, #4]
    wr_payload_u16(message, 3, firmware_information.version_minor);
 8024d1c:	f8b8 0006 	ldrh.w	r0, [r8, #6]
    wr_payload_u16(message, 5, firmware_information.version_build);
 8024d20:	f8b8 1008 	ldrh.w	r1, [r8, #8]

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024d24:	f88d 3009 	strb.w	r3, [sp, #9]
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024d28:	0a06      	lsrs	r6, r0, #8
 8024d2a:	0a1b      	lsrs	r3, r3, #8

    /* count length of firmware description string */
    while (firmware_information.description[string_length] != 0)
 8024d2c:	f8d8 2000 	ldr.w	r2, [r8]
 8024d30:	f88d 600c 	strb.w	r6, [sp, #12]
 8024d34:	0a0d      	lsrs	r5, r1, #8
 8024d36:	f88d 300a 	strb.w	r3, [sp, #10]
    payload[offset    ] =  value        & 0xFF;
 8024d3a:	f88d 000b 	strb.w	r0, [sp, #11]
 8024d3e:	f88d 100d 	strb.w	r1, [sp, #13]
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024d42:	f88d 500e 	strb.w	r5, [sp, #14]
 8024d46:	7813      	ldrb	r3, [r2, #0]
 8024d48:	463e      	mov	r6, r7
 8024d4a:	b123      	cbz	r3, 8024d56 <protocol_run+0x2de>
        ++string_length;
 8024d4c:	3601      	adds	r6, #1
 8024d4e:	b2b6      	uxth	r6, r6
    wr_payload_u16(message, 1, firmware_information.version_major);
    wr_payload_u16(message, 3, firmware_information.version_minor);
    wr_payload_u16(message, 5, firmware_information.version_build);

    /* count length of firmware description string */
    while (firmware_information.description[string_length] != 0)
 8024d50:	5d93      	ldrb	r3, [r2, r6]
 8024d52:	2b00      	cmp	r3, #0
 8024d54:	d1fa      	bne.n	8024d4c <protocol_run+0x2d4>
        ++string_length;
    ++string_length;

    /* send message */
    protocol_send_header(0, sizeof(message)  + string_length);
 8024d56:	f106 0308 	add.w	r3, r6, #8
 8024d5a:	b29b      	uxth	r3, r3
 8024d5c:	ea4f 2c13 	mov.w	ip, r3, lsr #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024d60:	f04f 0e5a 	mov.w	lr, #90	; 0x5a
 8024d64:	2200      	movs	r2, #0
    uint8_t header[4];
    wr_payload_u8 (header, 0, CNST_STARTBYTE_DATA);
    wr_payload_u8 (header, 1, endpoint);
    wr_payload_u16(header, 2, num_bytes);

    com_send_data(header, sizeof(header));
 8024d66:	a801      	add	r0, sp, #4
 8024d68:	2104      	movs	r1, #4
}

void protocol_send_payload(const uint8_t* message_data, uint16_t num_bytes)
{
    /* send the data through the communication stream interface */
    com_send_data(message_data, num_bytes);
 8024d6a:	ad02      	add	r5, sp, #8

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024d6c:	f88d 3006 	strb.w	r3, [sp, #6]
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024d70:	f88d c007 	strb.w	ip, [sp, #7]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024d74:	f88d e004 	strb.w	lr, [sp, #4]
 8024d78:	f88d 2005 	strb.w	r2, [sp, #5]
    uint8_t header[4];
    wr_payload_u8 (header, 0, CNST_STARTBYTE_DATA);
    wr_payload_u8 (header, 1, endpoint);
    wr_payload_u16(header, 2, num_bytes);

    com_send_data(header, sizeof(header));
 8024d7c:	f003 fe0a 	bl	8028994 <com_send_data>
}

void protocol_send_payload(const uint8_t* message_data, uint16_t num_bytes)
{
    /* send the data through the communication stream interface */
    com_send_data(message_data, num_bytes);
 8024d80:	4628      	mov	r0, r5
 8024d82:	2107      	movs	r1, #7
 8024d84:	f003 fe06 	bl	8028994 <com_send_data>
    wr_payload_u16(message, 5, firmware_information.version_build);

    /* count length of firmware description string */
    while (firmware_information.description[string_length] != 0)
        ++string_length;
    ++string_length;
 8024d88:	1c71      	adds	r1, r6, #1
}

void protocol_send_payload(const uint8_t* message_data, uint16_t num_bytes)
{
    /* send the data through the communication stream interface */
    com_send_data(message_data, num_bytes);
 8024d8a:	f8d8 0000 	ldr.w	r0, [r8]
 8024d8e:	b289      	uxth	r1, r1
 8024d90:	f003 fe00 	bl	8028994 <com_send_data>
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024d94:	22e0      	movs	r2, #224	; 0xe0
    payload[offset    ] =  value        & 0xFF;
 8024d96:	23db      	movs	r3, #219	; 0xdb
{
    /* setup message tail and send it */
    uint8_t tail[2];
    wr_payload_u16(tail, 0, CNST_END_OF_PAYLOAD);

    com_send_data(tail, sizeof(tail));
 8024d98:	a801      	add	r0, sp, #4
 8024d9a:	2102      	movs	r1, #2
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024d9c:	f88d 2005 	strb.w	r2, [sp, #5]
    payload[offset    ] =  value        & 0xFF;
 8024da0:	f88d 3004 	strb.w	r3, [sp, #4]
 8024da4:	f003 fdf6 	bl	8028994 <com_send_data>
    com_flush();
 8024da8:	f003 fe06 	bl	80289b8 <com_flush>
 8024dac:	e740      	b.n	8024c30 <protocol_run+0x1b8>
        if (num_bytes == 1)
        {
            /* if user did not set system reset function, this feature is not
             * supported.
             */
            if (instance.do_system_reset == NULL)
 8024dae:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 8024db0:	2b00      	cmp	r3, #0
 8024db2:	f43f af3b 	beq.w	8024c2c <protocol_run+0x1b4>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024db6:	ad12      	add	r5, sp, #72	; 0x48
 8024db8:	235b      	movs	r3, #91	; 0x5b
 8024dba:	f845 3d40 	str.w	r3, [r5, #-64]!
    wr_payload_u8 (status_message, 0, CNST_STARTBYTE_STATUS);
    wr_payload_u8 (status_message, 1, endpoint);
    wr_payload_u16(status_message, 2, status_code);

    /* now send message */
    com_send_data(status_message, sizeof(status_message));
 8024dbe:	2104      	movs	r1, #4
 8024dc0:	4628      	mov	r0, r5
 8024dc2:	f003 fde7 	bl	8028994 <com_send_data>
    com_flush();
 8024dc6:	f003 fdf7 	bl	80289b8 <com_flush>
             * possible.
             */
            send_status_message(0, PROTOCOL_ERROR_OK);

            /* now do the system reset */
            instance.do_system_reset();
 8024dca:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 8024dcc:	4798      	blx	r3
 8024dce:	e72f      	b.n	8024c30 <protocol_run+0x1b8>
 8024dd0:	1ffe8b6c 	.word	0x1ffe8b6c

08024dd4 <protocol_broadcast_change>:
    com_send_data(tail, sizeof(tail));
    com_flush();
}

void protocol_broadcast_change(void* context, uint32_t what)
{
 8024dd4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    uint8_t i;

    /* broadcast change notification to all endpoints that have a
     * handle_change function
     */
    for (i = 0; i < instance.num_endpoints; ++i)
 8024dd8:	4d16      	ldr	r5, [pc, #88]	; (8024e34 <protocol_broadcast_change+0x60>)
 8024dda:	f895 e004 	ldrb.w	lr, [r5, #4]
 8024dde:	f1be 0f00 	cmp.w	lr, #0
 8024de2:	d01c      	beq.n	8024e1e <protocol_broadcast_change+0x4a>
 8024de4:	4689      	mov	r9, r1
 8024de6:	4606      	mov	r6, r0
 8024de8:	2401      	movs	r4, #1
    {
        if ((instance.endpoints[i].handle_change) &&
 8024dea:	46a8      	mov	r8, r5
 8024dec:	e006      	b.n	8024dfc <protocol_broadcast_change+0x28>
 8024dee:	68db      	ldr	r3, [r3, #12]
 8024df0:	42b3      	cmp	r3, r6
 8024df2:	d016      	beq.n	8024e22 <protocol_broadcast_change+0x4e>
 8024df4:	3401      	adds	r4, #1
    uint8_t i;

    /* broadcast change notification to all endpoints that have a
     * handle_change function
     */
    for (i = 0; i < instance.num_endpoints; ++i)
 8024df6:	4572      	cmp	r2, lr
 8024df8:	b2e4      	uxtb	r4, r4
 8024dfa:	d210      	bcs.n	8024e1e <protocol_broadcast_change+0x4a>
 8024dfc:	1e63      	subs	r3, r4, #1
    {
        if ((instance.endpoints[i].handle_change) &&
 8024dfe:	682a      	ldr	r2, [r5, #0]
 8024e00:	b2db      	uxtb	r3, r3
 8024e02:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8024e06:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8024e0a:	4622      	mov	r2, r4
 8024e0c:	691f      	ldr	r7, [r3, #16]
 8024e0e:	2f00      	cmp	r7, #0
 8024e10:	d1ed      	bne.n	8024dee <protocol_broadcast_change+0x1a>
 8024e12:	4622      	mov	r2, r4
    uint8_t i;

    /* broadcast change notification to all endpoints that have a
     * handle_change function
     */
    for (i = 0; i < instance.num_endpoints; ++i)
 8024e14:	4572      	cmp	r2, lr
 8024e16:	f104 0401 	add.w	r4, r4, #1
 8024e1a:	b2e4      	uxtb	r4, r4
 8024e1c:	d3ee      	bcc.n	8024dfc <protocol_broadcast_change+0x28>
 8024e1e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    {
        if ((instance.endpoints[i].handle_change) &&
            (instance.endpoints[i].context == context))
        {
            instance.endpoints[i].handle_change(i + 1, context, what);
 8024e22:	464a      	mov	r2, r9
 8024e24:	4620      	mov	r0, r4
 8024e26:	4631      	mov	r1, r6
 8024e28:	47b8      	blx	r7
 8024e2a:	f898 e004 	ldrb.w	lr, [r8, #4]
 8024e2e:	4622      	mov	r2, r4
 8024e30:	e7e0      	b.n	8024df4 <protocol_broadcast_change+0x20>
 8024e32:	bf00      	nop
 8024e34:	1fff0d08 	.word	0x1fff0d08

08024e38 <USBD_VCOM_Event_GetDescriptor>:
	const uint8_t  descriptor_type   = (w_value >> 8);
	const uint8_t  descriptor_number = (w_value & 0xFF);
	const void* address = NULL;
	uint16_t    size    = NO_DESCRIPTOR;

	switch (descriptor_type)
 8024e38:	0a03      	lsrs	r3, r0, #8
 8024e3a:	2b02      	cmp	r3, #2
 8024e3c:	d016      	beq.n	8024e6c <USBD_VCOM_Event_GetDescriptor+0x34>
 8024e3e:	2b03      	cmp	r3, #3
 8024e40:	d009      	beq.n	8024e56 <USBD_VCOM_Event_GetDescriptor+0x1e>
 8024e42:	2b01      	cmp	r3, #1
 8024e44:	d003      	beq.n	8024e4e <USBD_VCOM_Event_GetDescriptor+0x16>
uint16_t USBD_VCOM_Event_GetDescriptor(const uint16_t w_value,
                                    const uint16_t w_index,
                                    const void** const descriptor_address)
{
	const uint8_t  descriptor_type   = (w_value >> 8);
	const uint8_t  descriptor_number = (w_value & 0xFF);
 8024e46:	2000      	movs	r0, #0
 8024e48:	4603      	mov	r3, r0
			}
			break;
	}

	(void)w_index;
	*descriptor_address = address;
 8024e4a:	6013      	str	r3, [r2, #0]
	return size;
}
 8024e4c:	4770      	bx	lr
	uint16_t    size    = NO_DESCRIPTOR;

	switch (descriptor_type)
	{
		case DTYPE_Device:
			address = &device_descriptor;
 8024e4e:	4b09      	ldr	r3, [pc, #36]	; (8024e74 <USBD_VCOM_Event_GetDescriptor+0x3c>)
			}
			break;
	}

	(void)w_index;
	*descriptor_address = address;
 8024e50:	6013      	str	r3, [r2, #0]

	switch (descriptor_type)
	{
		case DTYPE_Device:
			address = &device_descriptor;
			size    = sizeof(USB_Descriptor_Device_t);
 8024e52:	2012      	movs	r0, #18
	}

	(void)w_index;
	*descriptor_address = address;
	return size;
}
 8024e54:	4770      	bx	lr
uint16_t USBD_VCOM_Event_GetDescriptor(const uint16_t w_value,
                                    const uint16_t w_index,
                                    const void** const descriptor_address)
{
	const uint8_t  descriptor_type   = (w_value >> 8);
	const uint8_t  descriptor_number = (w_value & 0xFF);
 8024e56:	b2c0      	uxtb	r0, r0
 8024e58:	2802      	cmp	r0, #2
 8024e5a:	d8f4      	bhi.n	8024e46 <USBD_VCOM_Event_GetDescriptor+0xe>
 8024e5c:	4b06      	ldr	r3, [pc, #24]	; (8024e78 <USBD_VCOM_Event_GetDescriptor+0x40>)
 8024e5e:	4907      	ldr	r1, [pc, #28]	; (8024e7c <USBD_VCOM_Event_GetDescriptor+0x44>)
 8024e60:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
			}
			break;
	}

	(void)w_index;
	*descriptor_address = address;
 8024e64:	6013      	str	r3, [r2, #0]
 8024e66:	f831 0010 	ldrh.w	r0, [r1, r0, lsl #1]
	return size;
}
 8024e6a:	4770      	bx	lr
		case DTYPE_Device:
			address = &device_descriptor;
			size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			address = &configuration_descriptor;
 8024e6c:	4b04      	ldr	r3, [pc, #16]	; (8024e80 <USBD_VCOM_Event_GetDescriptor+0x48>)
			}
			break;
	}

	(void)w_index;
	*descriptor_address = address;
 8024e6e:	6013      	str	r3, [r2, #0]
			address = &device_descriptor;
			size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			address = &configuration_descriptor;
			size    = sizeof(USB_Descriptor_Configuration_t);
 8024e70:	203e      	movs	r0, #62	; 0x3e
	}

	(void)w_index;
	*descriptor_address = address;
	return size;
}
 8024e72:	4770      	bx	lr
 8024e74:	0802ad24 	.word	0x0802ad24
 8024e78:	0802ae08 	.word	0x0802ae08
 8024e7c:	0802ae14 	.word	0x0802ae14
 8024e80:	0802ae1c 	.word	0x0802ae1c

08024e84 <CDC_Device_ProcessControlRequest>:
	 *  packet, \c false otherwise.
	 */
	static inline bool Endpoint_IsSETUPReceived(void);
	static inline bool Endpoint_IsSETUPReceived(void)
	{
		return device.IsSetupRecieved;
 8024e84:	4a45      	ldr	r2, [pc, #276]	; (8024f9c <CDC_Device_ProcessControlRequest+0x118>)
 8024e86:	f892 313e 	ldrb.w	r3, [r2, #318]	; 0x13e
 * API IMPLEMENTATION
 **********************************************************************************************************************/
void CDC_Device_ProcessControlRequest(
					USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	if ((Endpoint_IsSETUPReceived() != 0) && (USB_ControlRequest.wIndex ==
 8024e8a:	079b      	lsls	r3, r3, #30
 8024e8c:	d510      	bpl.n	8024eb0 <CDC_Device_ProcessControlRequest+0x2c>
/**********************************************************************************************************************
 * API IMPLEMENTATION
 **********************************************************************************************************************/
void CDC_Device_ProcessControlRequest(
					USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
 8024e8e:	b570      	push	{r4, r5, r6, lr}
	if ((Endpoint_IsSETUPReceived() != 0) && (USB_ControlRequest.wIndex ==
 8024e90:	4943      	ldr	r1, [pc, #268]	; (8024fa0 <CDC_Device_ProcessControlRequest+0x11c>)
 8024e92:	7c84      	ldrb	r4, [r0, #18]
 8024e94:	888b      	ldrh	r3, [r1, #4]
 8024e96:	b29b      	uxth	r3, r3
 8024e98:	429c      	cmp	r4, r3
 8024e9a:	d000      	beq.n	8024e9e <CDC_Device_ProcessControlRequest+0x1a>
 8024e9c:	bd70      	pop	{r4, r5, r6, pc}
			CDCInterfaceInfo->Config.ControlInterfaceNumber))
	{

		switch (USB_ControlRequest.bRequest)
 8024e9e:	784b      	ldrb	r3, [r1, #1]
 8024ea0:	3b20      	subs	r3, #32
 8024ea2:	4604      	mov	r4, r0
 8024ea4:	2b03      	cmp	r3, #3
 8024ea6:	d8f9      	bhi.n	8024e9c <CDC_Device_ProcessControlRequest+0x18>
 8024ea8:	e8df f003 	tbb	[pc, r3]
 8024eac:	03633f18 	.word	0x03633f18
 8024eb0:	4770      	bx	lr

				}

				break;
			case CDC_REQ_SendBreak:
				if ((REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE) == USB_ControlRequest.bmRequestType)
 8024eb2:	780b      	ldrb	r3, [r1, #0]
 8024eb4:	493a      	ldr	r1, [pc, #232]	; (8024fa0 <CDC_Device_ProcessControlRequest+0x11c>)
 8024eb6:	2b21      	cmp	r3, #33	; 0x21
 8024eb8:	d1f0      	bne.n	8024e9c <CDC_Device_ProcessControlRequest+0x18>
				{
					Endpoint_ClearSETUP();
					Endpoint_ClearStatusStage();

					if(0 != cdc_class_events.Device_BreakSent)
 8024eba:	483a      	ldr	r0, [pc, #232]	; (8024fa4 <CDC_Device_ProcessControlRequest+0x120>)
	 *  \note This is not applicable for non CONTROL type endpoints.
	 */
	static inline void Endpoint_ClearSETUP(void);
	static inline void Endpoint_ClearSETUP(void)
	{
		device.IsSetupRecieved = 0;
 8024ebc:	f892 313e 	ldrb.w	r3, [r2, #318]	; 0x13e
 8024ec0:	6885      	ldr	r5, [r0, #8]
 8024ec2:	f023 0302 	bic.w	r3, r3, #2
 8024ec6:	f882 313e 	strb.w	r3, [r2, #318]	; 0x13e
 8024eca:	2d00      	cmp	r5, #0
 8024ecc:	d0e6      	beq.n	8024e9c <CDC_Device_ProcessControlRequest+0x18>
					{
						cdc_class_events.Device_BreakSent(CDCInterfaceInfo,	(uint8_t)USB_ControlRequest.wValue);
 8024ece:	8849      	ldrh	r1, [r1, #2]
 8024ed0:	4620      	mov	r0, r4
 8024ed2:	462b      	mov	r3, r5
 8024ed4:	b2c9      	uxtb	r1, r1
				}

				break;
		}
	}
}
 8024ed6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
					Endpoint_ClearSETUP();
					Endpoint_ClearStatusStage();

					if(0 != cdc_class_events.Device_BreakSent)
					{
						cdc_class_events.Device_BreakSent(CDCInterfaceInfo,	(uint8_t)USB_ControlRequest.wValue);
 8024eda:	4718      	bx	r3
					Endpoint_ClearStatusStage();
				}

				break;
			case CDC_REQ_SetLineEncoding:
				if ((REQDIR_HOSTTODEVICE |REQTYPE_CLASS | REQREC_INTERFACE) == USB_ControlRequest.bmRequestType)
 8024edc:	780b      	ldrb	r3, [r1, #0]
 8024ede:	2b21      	cmp	r3, #33	; 0x21
 8024ee0:	d1dc      	bne.n	8024e9c <CDC_Device_ProcessControlRequest+0x18>
 8024ee2:	f892 013e 	ldrb.w	r0, [r2, #318]	; 0x13e
 8024ee6:	f892 313c 	ldrb.w	r3, [r2, #316]	; 0x13c
				{
					Endpoint_ClearSETUP();

					while (!(Endpoint_IsOUTReceived()))
					{
						if (USB_DeviceState == DEVICE_STATE_Unattached)
 8024eea:	492f      	ldr	r1, [pc, #188]	; (8024fa8 <CDC_Device_ProcessControlRequest+0x124>)
 8024eec:	f020 0002 	bic.w	r0, r0, #2
	 */
	static inline bool Endpoint_IsOUTReceived(void);
	static inline bool Endpoint_IsOUTReceived(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->IsOutRecieved;
 8024ef0:	252c      	movs	r5, #44	; 0x2c
	 *  \note This is not applicable for non CONTROL type endpoints.
	 */
	static inline void Endpoint_ClearSETUP(void);
	static inline void Endpoint_ClearSETUP(void)
	{
		device.IsSetupRecieved = 0;
 8024ef2:	f882 013e 	strb.w	r0, [r2, #318]	; 0x13e
	 */
	static inline bool Endpoint_IsOUTReceived(void);
	static inline bool Endpoint_IsOUTReceived(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->IsOutRecieved;
 8024ef6:	fb05 2203 	mla	r2, r5, r3, r2
 8024efa:	e002      	b.n	8024f02 <CDC_Device_ProcessControlRequest+0x7e>
 8024efc:	780b      	ldrb	r3, [r1, #0]
 8024efe:	2b00      	cmp	r3, #0
 8024f00:	d0cc      	beq.n	8024e9c <CDC_Device_ProcessControlRequest+0x18>
 8024f02:	6893      	ldr	r3, [r2, #8]
			case CDC_REQ_SetLineEncoding:
				if ((REQDIR_HOSTTODEVICE |REQTYPE_CLASS | REQREC_INTERFACE) == USB_ControlRequest.bmRequestType)
				{
					Endpoint_ClearSETUP();

					while (!(Endpoint_IsOUTReceived()))
 8024f04:	069b      	lsls	r3, r3, #26
 8024f06:	d5f9      	bpl.n	8024efc <CDC_Device_ProcessControlRequest+0x78>
					{
						if (USB_DeviceState == DEVICE_STATE_Unattached)
						  return;
					}

					CDCInterfaceInfo->State.LineEncoding.BaudRateBPS = Endpoint_Read_32_LE();
 8024f08:	f000 fc30 	bl	802576c <Endpoint_Read_32_LE>
 8024f0c:	61a0      	str	r0, [r4, #24]
					CDCInterfaceInfo->State.LineEncoding.CharFormat  = Endpoint_Read_8();
 8024f0e:	f000 fc01 	bl	8025714 <Endpoint_Read_8>
 8024f12:	7720      	strb	r0, [r4, #28]
					CDCInterfaceInfo->State.LineEncoding.ParityType  = Endpoint_Read_8();
 8024f14:	f000 fbfe 	bl	8025714 <Endpoint_Read_8>
 8024f18:	7760      	strb	r0, [r4, #29]
					CDCInterfaceInfo->State.LineEncoding.DataBits    = Endpoint_Read_8();
 8024f1a:	f000 fbfb 	bl	8025714 <Endpoint_Read_8>

					//Endpoint_ClearOUT();
					Endpoint_ClearStatusStage();

					if(0 != cdc_class_events.LineEncodingChanged)
 8024f1e:	4b21      	ldr	r3, [pc, #132]	; (8024fa4 <CDC_Device_ProcessControlRequest+0x120>)
					}

					CDCInterfaceInfo->State.LineEncoding.BaudRateBPS = Endpoint_Read_32_LE();
					CDCInterfaceInfo->State.LineEncoding.CharFormat  = Endpoint_Read_8();
					CDCInterfaceInfo->State.LineEncoding.ParityType  = Endpoint_Read_8();
					CDCInterfaceInfo->State.LineEncoding.DataBits    = Endpoint_Read_8();
 8024f20:	77a0      	strb	r0, [r4, #30]

					//Endpoint_ClearOUT();
					Endpoint_ClearStatusStage();

					if(0 != cdc_class_events.LineEncodingChanged)
 8024f22:	681b      	ldr	r3, [r3, #0]
 8024f24:	2b00      	cmp	r3, #0
 8024f26:	d134      	bne.n	8024f92 <CDC_Device_ProcessControlRequest+0x10e>
 8024f28:	e7b8      	b.n	8024e9c <CDC_Device_ProcessControlRequest+0x18>
	{

		switch (USB_ControlRequest.bRequest)
		{
			case CDC_REQ_GetLineEncoding:
				if ((REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE) == USB_ControlRequest.bmRequestType)
 8024f2a:	780b      	ldrb	r3, [r1, #0]
 8024f2c:	2ba1      	cmp	r3, #161	; 0xa1
 8024f2e:	d1b5      	bne.n	8024e9c <CDC_Device_ProcessControlRequest+0x18>
	 *  \note This is not applicable for non CONTROL type endpoints.
	 */
	static inline void Endpoint_ClearSETUP(void);
	static inline void Endpoint_ClearSETUP(void)
	{
		device.IsSetupRecieved = 0;
 8024f30:	f892 113e 	ldrb.w	r1, [r2, #318]	; 0x13e
 8024f34:	f892 313c 	ldrb.w	r3, [r2, #316]	; 0x13c
 8024f38:	f021 0102 	bic.w	r1, r1, #2
	 */
	static inline bool Endpoint_IsINReady(void);
	static inline bool Endpoint_IsINReady(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->InInUse == 0 && ep->IsEnabled;
 8024f3c:	202c      	movs	r0, #44	; 0x2c
	 *  \note This is not applicable for non CONTROL type endpoints.
	 */
	static inline void Endpoint_ClearSETUP(void);
	static inline void Endpoint_ClearSETUP(void)
	{
		device.IsSetupRecieved = 0;
 8024f3e:	f882 113e 	strb.w	r1, [r2, #318]	; 0x13e
	 */
	static inline bool Endpoint_IsINReady(void);
	static inline bool Endpoint_IsINReady(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->InInUse == 0 && ep->IsEnabled;
 8024f42:	fb00 2203 	mla	r2, r0, r3, r2
 8024f46:	6893      	ldr	r3, [r2, #8]
 8024f48:	06d8      	lsls	r0, r3, #27
 8024f4a:	d4fc      	bmi.n	8024f46 <CDC_Device_ProcessControlRequest+0xc2>
 8024f4c:	6893      	ldr	r3, [r2, #8]
 8024f4e:	0799      	lsls	r1, r3, #30
 8024f50:	d5f9      	bpl.n	8024f46 <CDC_Device_ProcessControlRequest+0xc2>
				{
					Endpoint_ClearSETUP();

					while (!(Endpoint_IsINReady()));

					Endpoint_Write_32_LE(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS);
 8024f52:	69a0      	ldr	r0, [r4, #24]
 8024f54:	f000 fbf4 	bl	8025740 <Endpoint_Write_32_LE>
					Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.CharFormat);
 8024f58:	7f20      	ldrb	r0, [r4, #28]
 8024f5a:	f000 fbc5 	bl	80256e8 <Endpoint_Write_8>
					Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.ParityType);
 8024f5e:	7f60      	ldrb	r0, [r4, #29]
 8024f60:	f000 fbc2 	bl	80256e8 <Endpoint_Write_8>
					Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.DataBits);
 8024f64:	7fa0      	ldrb	r0, [r4, #30]
 8024f66:	f000 fbbf 	bl	80256e8 <Endpoint_Write_8>
				}

				break;
		}
	}
}
 8024f6a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
					Endpoint_Write_32_LE(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS);
					Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.CharFormat);
					Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.ParityType);
					Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.DataBits);

					Endpoint_ClearIN();
 8024f6e:	f000 bb6b 	b.w	8025648 <Endpoint_ClearIN>

				}

				break;
			case CDC_REQ_SetControlLineState:
				if ((REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE) == USB_ControlRequest.bmRequestType)
 8024f72:	780b      	ldrb	r3, [r1, #0]
 8024f74:	490a      	ldr	r1, [pc, #40]	; (8024fa0 <CDC_Device_ProcessControlRequest+0x11c>)
 8024f76:	2b21      	cmp	r3, #33	; 0x21
 8024f78:	d190      	bne.n	8024e9c <CDC_Device_ProcessControlRequest+0x18>
	 *  \note This is not applicable for non CONTROL type endpoints.
	 */
	static inline void Endpoint_ClearSETUP(void);
	static inline void Endpoint_ClearSETUP(void)
	{
		device.IsSetupRecieved = 0;
 8024f7a:	f892 313e 	ldrb.w	r3, [r2, #318]	; 0x13e
					Endpoint_ClearSETUP();
					Endpoint_ClearStatusStage();

					CDCInterfaceInfo->State.ControlLineStates.HostToDevice = USB_ControlRequest.wValue;

					if(0 != cdc_class_events.ControLineStateChanged)
 8024f7e:	4809      	ldr	r0, [pc, #36]	; (8024fa4 <CDC_Device_ProcessControlRequest+0x120>)
 8024f80:	f023 0302 	bic.w	r3, r3, #2
 8024f84:	f882 313e 	strb.w	r3, [r2, #318]	; 0x13e
 8024f88:	6843      	ldr	r3, [r0, #4]
				if ((REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE) == USB_ControlRequest.bmRequestType)
				{
					Endpoint_ClearSETUP();
					Endpoint_ClearStatusStage();

					CDCInterfaceInfo->State.ControlLineStates.HostToDevice = USB_ControlRequest.wValue;
 8024f8a:	884a      	ldrh	r2, [r1, #2]
 8024f8c:	82a2      	strh	r2, [r4, #20]

					if(0 != cdc_class_events.ControLineStateChanged)
 8024f8e:	2b00      	cmp	r3, #0
 8024f90:	d084      	beq.n	8024e9c <CDC_Device_ProcessControlRequest+0x18>
					{
						cdc_class_events.ControLineStateChanged(CDCInterfaceInfo);
 8024f92:	4620      	mov	r0, r4
				}

				break;
		}
	}
}
 8024f94:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

					CDCInterfaceInfo->State.ControlLineStates.HostToDevice = USB_ControlRequest.wValue;

					if(0 != cdc_class_events.ControLineStateChanged)
					{
						cdc_class_events.ControLineStateChanged(CDCInterfaceInfo);
 8024f98:	4718      	bx	r3
 8024f9a:	bf00      	nop
 8024f9c:	1fffad60 	.word	0x1fffad60
 8024fa0:	1fffab58 	.word	0x1fffab58
 8024fa4:	1ffe8840 	.word	0x1ffe8840
 8024fa8:	1fffab55 	.word	0x1fffab55

08024fac <CDC_Device_ConfigureEndpoints>:




bool CDC_Device_ConfigureEndpoints(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
 8024fac:	b538      	push	{r3, r4, r5, lr}
	bool status = true;
	memset(&CDCInterfaceInfo->State, 0x00, sizeof(CDCInterfaceInfo->State));

	CDCInterfaceInfo->Config.DataINEndpoint.Type       = EP_TYPE_BULK;
 8024fae:	2202      	movs	r2, #2


bool CDC_Device_ConfigureEndpoints(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	bool status = true;
	memset(&CDCInterfaceInfo->State, 0x00, sizeof(CDCInterfaceInfo->State));
 8024fb0:	2300      	movs	r3, #0

	CDCInterfaceInfo->Config.DataINEndpoint.Type       = EP_TYPE_BULK;
	CDCInterfaceInfo->Config.DataOUTEndpoint.Type      = EP_TYPE_BULK;
	CDCInterfaceInfo->Config.NotificationEndpoint.Type = EP_TYPE_INTERRUPT;
 8024fb2:	2103      	movs	r1, #3


bool CDC_Device_ConfigureEndpoints(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	bool status = true;
	memset(&CDCInterfaceInfo->State, 0x00, sizeof(CDCInterfaceInfo->State));
 8024fb4:	7503      	strb	r3, [r0, #20]
 8024fb6:	7543      	strb	r3, [r0, #21]
 8024fb8:	7583      	strb	r3, [r0, #22]
 8024fba:	75c3      	strb	r3, [r0, #23]
 8024fbc:	7603      	strb	r3, [r0, #24]
 8024fbe:	7643      	strb	r3, [r0, #25]
 8024fc0:	7683      	strb	r3, [r0, #26]
 8024fc2:	76c3      	strb	r3, [r0, #27]
 8024fc4:	7703      	strb	r3, [r0, #28]
 8024fc6:	7743      	strb	r3, [r0, #29]
 8024fc8:	7783      	strb	r3, [r0, #30]
 8024fca:	77c3      	strb	r3, [r0, #31]

	CDCInterfaceInfo->Config.DataINEndpoint.Type       = EP_TYPE_BULK;
 8024fcc:	7102      	strb	r2, [r0, #4]
	CDCInterfaceInfo->Config.DataOUTEndpoint.Type      = EP_TYPE_BULK;
 8024fce:	7282      	strb	r2, [r0, #10]
	CDCInterfaceInfo->Config.NotificationEndpoint.Type = EP_TYPE_INTERRUPT;
 8024fd0:	7401      	strb	r1, [r0, #16]

	if (!(Endpoint_ConfigureEndpointTable(&CDCInterfaceInfo->Config.DataINEndpoint, 1)))
 8024fd2:	2101      	movs	r1, #1




bool CDC_Device_ConfigureEndpoints(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
 8024fd4:	4604      	mov	r4, r0

	CDCInterfaceInfo->Config.DataINEndpoint.Type       = EP_TYPE_BULK;
	CDCInterfaceInfo->Config.DataOUTEndpoint.Type      = EP_TYPE_BULK;
	CDCInterfaceInfo->Config.NotificationEndpoint.Type = EP_TYPE_INTERRUPT;

	if (!(Endpoint_ConfigureEndpointTable(&CDCInterfaceInfo->Config.DataINEndpoint, 1)))
 8024fd6:	f000 fbdf 	bl	8025798 <Endpoint_ConfigureEndpointTable>
	{
		status = false;
	}

	if (!(Endpoint_ConfigureEndpointTable(
 8024fda:	2101      	movs	r1, #1

	CDCInterfaceInfo->Config.DataINEndpoint.Type       = EP_TYPE_BULK;
	CDCInterfaceInfo->Config.DataOUTEndpoint.Type      = EP_TYPE_BULK;
	CDCInterfaceInfo->Config.NotificationEndpoint.Type = EP_TYPE_INTERRUPT;

	if (!(Endpoint_ConfigureEndpointTable(&CDCInterfaceInfo->Config.DataINEndpoint, 1)))
 8024fdc:	4605      	mov	r5, r0
	{
		status = false;
	}

	if (!(Endpoint_ConfigureEndpointTable(
 8024fde:	1da0      	adds	r0, r4, #6
 8024fe0:	f000 fbda 	bl	8025798 <Endpoint_ConfigureEndpointTable>
							&CDCInterfaceInfo->Config.DataOUTEndpoint, 1)))
	{
		status = false;
	}

	if (!(Endpoint_ConfigureEndpointTable(
 8024fe4:	2101      	movs	r1, #1
	if (!(Endpoint_ConfigureEndpointTable(&CDCInterfaceInfo->Config.DataINEndpoint, 1)))
	{
		status = false;
	}

	if (!(Endpoint_ConfigureEndpointTable(
 8024fe6:	2800      	cmp	r0, #0
							&CDCInterfaceInfo->Config.DataOUTEndpoint, 1)))
	{
		status = false;
	}

	if (!(Endpoint_ConfigureEndpointTable(
 8024fe8:	f104 000c 	add.w	r0, r4, #12
	}

	if (!(Endpoint_ConfigureEndpointTable(
							&CDCInterfaceInfo->Config.DataOUTEndpoint, 1)))
	{
		status = false;
 8024fec:	bf08      	it	eq
 8024fee:	2500      	moveq	r5, #0
	}

	if (!(Endpoint_ConfigureEndpointTable(
 8024ff0:	f000 fbd2 	bl	8025798 <Endpoint_ConfigureEndpointTable>
 8024ff4:	2800      	cmp	r0, #0
	{
		status = false;
	}

	return status;
}
 8024ff6:	bf14      	ite	ne
 8024ff8:	4628      	movne	r0, r5
 8024ffa:	2000      	moveq	r0, #0
 8024ffc:	bd38      	pop	{r3, r4, r5, pc}
 8024ffe:	bf00      	nop

08025000 <CDC_Device_USBTask>:

void CDC_Device_USBTask(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 8025000:	4b1c      	ldr	r3, [pc, #112]	; (8025074 <CDC_Device_USBTask+0x74>)
 8025002:	781a      	ldrb	r2, [r3, #0]
 8025004:	2a04      	cmp	r2, #4
 8025006:	d000      	beq.n	802500a <CDC_Device_USBTask+0xa>
		{
		  CDC_Device_Flush(CDCInterfaceInfo);
		}
		#endif
	}
}
 8025008:	4770      	bx	lr
	return status;
}

void CDC_Device_USBTask(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 802500a:	6982      	ldr	r2, [r0, #24]
 802500c:	2a00      	cmp	r2, #0
 802500e:	d0fb      	beq.n	8025008 <CDC_Device_USBTask+0x8>

	return status;
}

void CDC_Device_USBTask(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
 8025010:	b470      	push	{r4, r5, r6}
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
	{
		#if !defined(NO_CLASS_DRIVER_AUTOFLUSH)
		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataINEndpoint.Address);
 8025012:	7802      	ldrb	r2, [r0, #0]
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8025014:	4918      	ldr	r1, [pc, #96]	; (8025078 <CDC_Device_USBTask+0x78>)
 8025016:	f002 040f 	and.w	r4, r2, #15
	 */
	static inline bool Endpoint_IsINReady(void);
	static inline bool Endpoint_IsINReady(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->InInUse == 0 && ep->IsEnabled;
 802501a:	262c      	movs	r6, #44	; 0x2c
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 802501c:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
	 */
	static inline bool Endpoint_IsINReady(void);
	static inline bool Endpoint_IsINReady(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->InInUse == 0 && ep->IsEnabled;
 8025020:	fb06 1504 	mla	r5, r6, r4, r1
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8025024:	f881 413c 	strb.w	r4, [r1, #316]	; 0x13c
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 8025028:	f881 213d 	strb.w	r2, [r1, #317]	; 0x13d
	 */
	static inline bool Endpoint_IsINReady(void);
	static inline bool Endpoint_IsINReady(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->InInUse == 0 && ep->IsEnabled;
 802502c:	68aa      	ldr	r2, [r5, #8]
 802502e:	06d4      	lsls	r4, r2, #27
 8025030:	d405      	bmi.n	802503e <CDC_Device_USBTask+0x3e>
 8025032:	68aa      	ldr	r2, [r5, #8]
 8025034:	0792      	lsls	r2, r2, #30
 8025036:	d502      	bpl.n	802503e <CDC_Device_USBTask+0x3e>
}

uint8_t CDC_Device_Flush(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 8025038:	781b      	ldrb	r3, [r3, #0]
 802503a:	2b04      	cmp	r3, #4
 802503c:	d001      	beq.n	8025042 <CDC_Device_USBTask+0x42>
		{
		  CDC_Device_Flush(CDCInterfaceInfo);
		}
		#endif
	}
}
 802503e:	bc70      	pop	{r4, r5, r6}
 8025040:	4770      	bx	lr
}

uint8_t CDC_Device_Flush(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 8025042:	6983      	ldr	r3, [r0, #24]
 8025044:	2b00      	cmp	r3, #0
 8025046:	d0fa      	beq.n	802503e <CDC_Device_USBTask+0x3e>
	{
		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataINEndpoint.Address);
 8025048:	7803      	ldrb	r3, [r0, #0]
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 802504a:	f003 020f 	and.w	r2, r3, #15
	 */
	static inline uint16_t Endpoint_BytesInEndpoint(void);
	static inline uint16_t Endpoint_BytesInEndpoint(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		if (ep->Direction)
 802504e:	fb06 1602 	mla	r6, r6, r2, r1
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 8025052:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8025056:	f881 213c 	strb.w	r2, [r1, #316]	; 0x13c
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 802505a:	f881 313d 	strb.w	r3, [r1, #317]	; 0x13d
	 */
	static inline uint16_t Endpoint_BytesInEndpoint(void);
	static inline uint16_t Endpoint_BytesInEndpoint(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		if (ep->Direction)
 802505e:	7933      	ldrb	r3, [r6, #4]
 8025060:	061b      	lsls	r3, r3, #24
			return (uint16_t)(ep->InBytesAvailable);
 8025062:	bf4c      	ite	mi
 8025064:	8bb3      	ldrhmi	r3, [r6, #28]
		else
			return (uint16_t)(ep->OutBytesAvailable);
 8025066:	89b3      	ldrhpl	r3, [r6, #12]

		if (Endpoint_BytesInEndpoint())
 8025068:	2b00      	cmp	r3, #0
 802506a:	d0e8      	beq.n	802503e <CDC_Device_USBTask+0x3e>
		{
		  CDC_Device_Flush(CDCInterfaceInfo);
		}
		#endif
	}
}
 802506c:	bc70      	pop	{r4, r5, r6}
	{
		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataINEndpoint.Address);

		if (Endpoint_BytesInEndpoint())
		{
			Endpoint_ClearIN();
 802506e:	f000 baeb 	b.w	8025648 <Endpoint_ClearIN>
 8025072:	bf00      	nop
 8025074:	1fffab55 	.word	0x1fffab55
 8025078:	1fffad60 	.word	0x1fffad60

0802507c <CDC_Device_SendData>:
uint8_t CDC_Device_SendData(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo,
                            const void* const Buffer,
                            const uint16_t Length)
{
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 802507c:	4b0c      	ldr	r3, [pc, #48]	; (80250b0 <CDC_Device_SendData+0x34>)
 802507e:	781b      	ldrb	r3, [r3, #0]
 8025080:	2b04      	cmp	r3, #4
 8025082:	d001      	beq.n	8025088 <CDC_Device_SendData+0xc>
	else
	{
		status = ENDPOINT_RWSTREAM_DeviceDisconnected;
	}
	return status;
}
 8025084:	2002      	movs	r0, #2
 8025086:	4770      	bx	lr
uint8_t CDC_Device_SendData(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo,
                            const void* const Buffer,
                            const uint16_t Length)
{
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 8025088:	6983      	ldr	r3, [r0, #24]
 802508a:	2b00      	cmp	r3, #0
 802508c:	d0fa      	beq.n	8025084 <CDC_Device_SendData+0x8>
}

uint8_t CDC_Device_SendData(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo,
                            const void* const Buffer,
                            const uint16_t Length)
{
 802508e:	b430      	push	{r4, r5}
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
	{

		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataINEndpoint.Address);
 8025090:	7803      	ldrb	r3, [r0, #0]
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8025092:	4c08      	ldr	r4, [pc, #32]	; (80250b4 <CDC_Device_SendData+0x38>)
 8025094:	f003 050f 	and.w	r5, r3, #15
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 8025098:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
		status = Endpoint_Write_Stream_LE(Buffer, Length, NULL);
 802509c:	4608      	mov	r0, r1
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 802509e:	f884 513c 	strb.w	r5, [r4, #316]	; 0x13c
 80250a2:	4611      	mov	r1, r2
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 80250a4:	f884 313d 	strb.w	r3, [r4, #317]	; 0x13d
 80250a8:	2200      	movs	r2, #0
	else
	{
		status = ENDPOINT_RWSTREAM_DeviceDisconnected;
	}
	return status;
}
 80250aa:	bc30      	pop	{r4, r5}
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
	{

		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataINEndpoint.Address);
		status = Endpoint_Write_Stream_LE(Buffer, Length, NULL);
 80250ac:	f000 b9b4 	b.w	8025418 <Endpoint_Write_Stream_LE>
 80250b0:	1fffab55 	.word	0x1fffab55
 80250b4:	1fffad60 	.word	0x1fffad60

080250b8 <CDC_Device_Flush>:
	return status;

}

uint8_t CDC_Device_Flush(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
 80250b8:	b508      	push	{r3, lr}
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 80250ba:	4b10      	ldr	r3, [pc, #64]	; (80250fc <CDC_Device_Flush+0x44>)
 80250bc:	781b      	ldrb	r3, [r3, #0]
 80250be:	2b04      	cmp	r3, #4
 80250c0:	d001      	beq.n	80250c6 <CDC_Device_Flush+0xe>

		status = ENDPOINT_READYWAIT_NoError;
	}
	else
	{
		status = ENDPOINT_RWSTREAM_DeviceDisconnected;
 80250c2:	2002      	movs	r0, #2
	}

	return status;
}
 80250c4:	bd08      	pop	{r3, pc}
}

uint8_t CDC_Device_Flush(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 80250c6:	6983      	ldr	r3, [r0, #24]
 80250c8:	2b00      	cmp	r3, #0
 80250ca:	d0fa      	beq.n	80250c2 <CDC_Device_Flush+0xa>
	{
		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataINEndpoint.Address);
 80250cc:	7803      	ldrb	r3, [r0, #0]
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 80250ce:	490c      	ldr	r1, [pc, #48]	; (8025100 <CDC_Device_Flush+0x48>)
 80250d0:	f003 000f 	and.w	r0, r3, #15
	 */
	static inline uint16_t Endpoint_BytesInEndpoint(void);
	static inline uint16_t Endpoint_BytesInEndpoint(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		if (ep->Direction)
 80250d4:	222c      	movs	r2, #44	; 0x2c
 80250d6:	fb02 1200 	mla	r2, r2, r0, r1
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 80250da:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 80250de:	f881 013c 	strb.w	r0, [r1, #316]	; 0x13c
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 80250e2:	f881 313d 	strb.w	r3, [r1, #317]	; 0x13d
	 */
	static inline uint16_t Endpoint_BytesInEndpoint(void);
	static inline uint16_t Endpoint_BytesInEndpoint(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		if (ep->Direction)
 80250e6:	7913      	ldrb	r3, [r2, #4]
 80250e8:	061b      	lsls	r3, r3, #24
			return (uint16_t)(ep->InBytesAvailable);
 80250ea:	bf4c      	ite	mi
 80250ec:	8b90      	ldrhmi	r0, [r2, #28]
		else
			return (uint16_t)(ep->OutBytesAvailable);
 80250ee:	8990      	ldrhpl	r0, [r2, #12]

		if (Endpoint_BytesInEndpoint())
 80250f0:	2800      	cmp	r0, #0
 80250f2:	d0e7      	beq.n	80250c4 <CDC_Device_Flush+0xc>
		{
			Endpoint_ClearIN();
 80250f4:	f000 faa8 	bl	8025648 <Endpoint_ClearIN>
 80250f8:	2000      	movs	r0, #0
 80250fa:	bd08      	pop	{r3, pc}
 80250fc:	1fffab55 	.word	0x1fffab55
 8025100:	1fffad60 	.word	0x1fffad60

08025104 <CDC_Device_BytesReceived>:

	return status;
}

uint16_t CDC_Device_BytesReceived(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
 8025104:	b508      	push	{r3, lr}
	uint16_t bytes = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 8025106:	4b13      	ldr	r3, [pc, #76]	; (8025154 <CDC_Device_BytesReceived+0x50>)
 8025108:	781b      	ldrb	r3, [r3, #0]
 802510a:	2b04      	cmp	r3, #4
 802510c:	d001      	beq.n	8025112 <CDC_Device_BytesReceived+0xe>
		if (Endpoint_IsOUTReceived())
		{
			if (!(Endpoint_BytesInEndpoint()))
			{
				Endpoint_ClearOUT();
				bytes = 0;
 802510e:	2000      	movs	r0, #0
			bytes = 0;
		}
	}

	return bytes;
}
 8025110:	bd08      	pop	{r3, pc}
}

uint16_t CDC_Device_BytesReceived(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	uint16_t bytes = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 8025112:	6983      	ldr	r3, [r0, #24]
 8025114:	2b00      	cmp	r3, #0
 8025116:	d0fa      	beq.n	802510e <CDC_Device_BytesReceived+0xa>
	{

		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataOUTEndpoint.Address);
 8025118:	7982      	ldrb	r2, [r0, #6]
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 802511a:	490f      	ldr	r1, [pc, #60]	; (8025158 <CDC_Device_BytesReceived+0x54>)
 802511c:	f002 000f 	and.w	r0, r2, #15
	 */
	static inline bool Endpoint_IsOUTReceived(void);
	static inline bool Endpoint_IsOUTReceived(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->IsOutRecieved;
 8025120:	232c      	movs	r3, #44	; 0x2c
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 8025122:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
	 */
	static inline bool Endpoint_IsOUTReceived(void);
	static inline bool Endpoint_IsOUTReceived(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->IsOutRecieved;
 8025126:	fb03 1300 	mla	r3, r3, r0, r1
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 802512a:	f881 213d 	strb.w	r2, [r1, #317]	; 0x13d
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 802512e:	f881 013c 	strb.w	r0, [r1, #316]	; 0x13c
	 */
	static inline bool Endpoint_IsOUTReceived(void);
	static inline bool Endpoint_IsOUTReceived(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->IsOutRecieved;
 8025132:	689a      	ldr	r2, [r3, #8]

		if (Endpoint_IsOUTReceived())
 8025134:	0691      	lsls	r1, r2, #26
 8025136:	d5ea      	bpl.n	802510e <CDC_Device_BytesReceived+0xa>
	 */
	static inline uint16_t Endpoint_BytesInEndpoint(void);
	static inline uint16_t Endpoint_BytesInEndpoint(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		if (ep->Direction)
 8025138:	791a      	ldrb	r2, [r3, #4]
 802513a:	0612      	lsls	r2, r2, #24
 802513c:	d505      	bpl.n	802514a <CDC_Device_BytesReceived+0x46>
			return (uint16_t)(ep->InBytesAvailable);
 802513e:	8b98      	ldrh	r0, [r3, #28]
		{
			if (!(Endpoint_BytesInEndpoint()))
 8025140:	2800      	cmp	r0, #0
 8025142:	d1e5      	bne.n	8025110 <CDC_Device_BytesReceived+0xc>
			{
				Endpoint_ClearOUT();
 8025144:	f000 fa54 	bl	80255f0 <Endpoint_ClearOUT>
 8025148:	e7e1      	b.n	802510e <CDC_Device_BytesReceived+0xa>
		else
			return (uint16_t)(ep->OutBytesAvailable);
 802514a:	8998      	ldrh	r0, [r3, #12]

		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataOUTEndpoint.Address);

		if (Endpoint_IsOUTReceived())
		{
			if (!(Endpoint_BytesInEndpoint()))
 802514c:	2800      	cmp	r0, #0
 802514e:	d1df      	bne.n	8025110 <CDC_Device_BytesReceived+0xc>
 8025150:	e7f8      	b.n	8025144 <CDC_Device_BytesReceived+0x40>
 8025152:	bf00      	nop
 8025154:	1fffab55 	.word	0x1fffab55
 8025158:	1fffad60 	.word	0x1fffad60

0802515c <USBD_VCOM_CDCClass_Event_LineEncodingChanged>:
 * as a parameter.*/
void USBD_VCOM_CDCClass_Event_LineEncodingChanged(USB_ClassInfo_CDC_Device_t* const cdc_interface_info)
{
  /*set here the global volatile flag(which can be polled from the top level application) to indicate
   * the event. */
  cdc_event_flags.line_encoding_event_flag = 1U;
 802515c:	4b01      	ldr	r3, [pc, #4]	; (8025164 <USBD_VCOM_CDCClass_Event_LineEncodingChanged+0x8>)
 802515e:	2201      	movs	r2, #1
 8025160:	701a      	strb	r2, [r3, #0]
 8025162:	4770      	bx	lr
 8025164:	1fffaab0 	.word	0x1fffaab0

08025168 <USBD_VCOM_CDCClass_Event_ControlLineStateChanged>:
 * line states, such as DTR).The new control line states are available in the ControlLineStates.HostToDevice
 * value inside the CDC interface structure passed as a parameter. */
void USBD_VCOM_CDCClass_Event_ControlLineStateChanged(USB_ClassInfo_CDC_Device_t* const cdc_interface_info)
{
  /*set here the global volatile flag(which can be polled from the top level application) to indicate the event */
  cdc_event_flags.control_line_state_change_event_flag = 1U;
 8025168:	4b01      	ldr	r3, [pc, #4]	; (8025170 <USBD_VCOM_CDCClass_Event_ControlLineStateChanged+0x8>)
 802516a:	2201      	movs	r2, #1
 802516c:	705a      	strb	r2, [r3, #1]
 802516e:	4770      	bx	lr
 8025170:	1fffaab0 	.word	0x1fffaab0

08025174 <USBD_VCOM_CDCClass_Event_BreakSent>:
/*CDC class driver event for a send break request sent to the device from the host.
 * This is generally used to separate data or to indicate a special condition to the receiving device.*/
void USBD_VCOM_CDCClass_Event_BreakSent(USB_ClassInfo_CDC_Device_t* const cdc_interface_info,	const uint8_t duration)
{
  /*set here the global volatile flag(which can be polled from the top level application) to indicate the event */
  cdc_event_flags.break_event_flag = 1U;
 8025174:	4b01      	ldr	r3, [pc, #4]	; (802517c <USBD_VCOM_CDCClass_Event_BreakSent+0x8>)
 8025176:	2201      	movs	r2, #1
 8025178:	709a      	strb	r2, [r3, #2]
 802517a:	4770      	bx	lr
 802517c:	1fffaab0 	.word	0x1fffaab0

08025180 <USBD_VCOM_Event_ConfigurationChanged>:

}

/* Event handler for the USB Configuration Changed event. */
void USBD_VCOM_Event_ConfigurationChanged(void)
{
 8025180:	b508      	push	{r3, lr}
  USBD_SetEndpointBuffer(((uint8_t)CDC_IN_EP_MASK|(uint8_t)CDC_NOTIFICATION_EPNUM), notification_ep_buf, 
 8025182:	2081      	movs	r0, #129	; 0x81
 8025184:	490e      	ldr	r1, [pc, #56]	; (80251c0 <USBD_VCOM_Event_ConfigurationChanged+0x40>)
 8025186:	2240      	movs	r2, #64	; 0x40
 8025188:	f000 fff6 	bl	8026178 <USBD_SetEndpointBuffer>
  (uint16_t)USB_FS_MAXPKT_SIZE);
  USBD_SetEndpointBuffer(((uint8_t)CDC_IN_EP_MASK|(uint8_t)CDC_TX_EPNUM), tx_ep_buf, (uint16_t)USB_FS_MAXPKT_SIZE);
 802518c:	2082      	movs	r0, #130	; 0x82
 802518e:	490d      	ldr	r1, [pc, #52]	; (80251c4 <USBD_VCOM_Event_ConfigurationChanged+0x44>)
 8025190:	2240      	movs	r2, #64	; 0x40
 8025192:	f000 fff1 	bl	8026178 <USBD_SetEndpointBuffer>
  USBD_SetEndpointBuffer((CDC_RX_EPNUM), rx_ep_buf, (uint16_t)USB_FS_MAXPKT_SIZE);
 8025196:	2003      	movs	r0, #3
 8025198:	490b      	ldr	r1, [pc, #44]	; (80251c8 <USBD_VCOM_Event_ConfigurationChanged+0x48>)
 802519a:	2240      	movs	r2, #64	; 0x40
 802519c:	f000 ffec 	bl	8026178 <USBD_SetEndpointBuffer>
  if (true == CDC_Device_ConfigureEndpoints(&USBD_VCOM_cdc_interface))
 80251a0:	480a      	ldr	r0, [pc, #40]	; (80251cc <USBD_VCOM_Event_ConfigurationChanged+0x4c>)
 80251a2:	f7ff ff03 	bl	8024fac <CDC_Device_ConfigureEndpoints>
 80251a6:	b148      	cbz	r0, 80251bc <USBD_VCOM_Event_ConfigurationChanged+0x3c>
  {
    device.IsConfigured = 1U;
 80251a8:	4a09      	ldr	r2, [pc, #36]	; (80251d0 <USBD_VCOM_Event_ConfigurationChanged+0x50>)
    USB_DeviceState = (uint8_t)DEVICE_STATE_Configured;
 80251aa:	490a      	ldr	r1, [pc, #40]	; (80251d4 <USBD_VCOM_Event_ConfigurationChanged+0x54>)
  (uint16_t)USB_FS_MAXPKT_SIZE);
  USBD_SetEndpointBuffer(((uint8_t)CDC_IN_EP_MASK|(uint8_t)CDC_TX_EPNUM), tx_ep_buf, (uint16_t)USB_FS_MAXPKT_SIZE);
  USBD_SetEndpointBuffer((CDC_RX_EPNUM), rx_ep_buf, (uint16_t)USB_FS_MAXPKT_SIZE);
  if (true == CDC_Device_ConfigureEndpoints(&USBD_VCOM_cdc_interface))
  {
    device.IsConfigured = 1U;
 80251ac:	f892 313e 	ldrb.w	r3, [r2, #318]	; 0x13e
    USB_DeviceState = (uint8_t)DEVICE_STATE_Configured;
 80251b0:	2004      	movs	r0, #4
  (uint16_t)USB_FS_MAXPKT_SIZE);
  USBD_SetEndpointBuffer(((uint8_t)CDC_IN_EP_MASK|(uint8_t)CDC_TX_EPNUM), tx_ep_buf, (uint16_t)USB_FS_MAXPKT_SIZE);
  USBD_SetEndpointBuffer((CDC_RX_EPNUM), rx_ep_buf, (uint16_t)USB_FS_MAXPKT_SIZE);
  if (true == CDC_Device_ConfigureEndpoints(&USBD_VCOM_cdc_interface))
  {
    device.IsConfigured = 1U;
 80251b2:	f043 0301 	orr.w	r3, r3, #1
 80251b6:	f882 313e 	strb.w	r3, [r2, #318]	; 0x13e
    USB_DeviceState = (uint8_t)DEVICE_STATE_Configured;
 80251ba:	7008      	strb	r0, [r1, #0]
 80251bc:	bd08      	pop	{r3, pc}
 80251be:	bf00      	nop
 80251c0:	1fffaab4 	.word	0x1fffaab4
 80251c4:	1fffaa70 	.word	0x1fffaa70
 80251c8:	1fffaaf4 	.word	0x1fffaaf4
 80251cc:	1fffab34 	.word	0x1fffab34
 80251d0:	1fffad60 	.word	0x1fffad60
 80251d4:	1fffab55 	.word	0x1fffab55

080251d8 <USBD_VCOM_Event_ControlRequest>:
}

/* Event handler for the USB Control Request reception event. */
void USBD_VCOM_Event_ControlRequest(void)
{
  CDC_Device_ProcessControlRequest(&USBD_VCOM_cdc_interface);
 80251d8:	4801      	ldr	r0, [pc, #4]	; (80251e0 <USBD_VCOM_Event_ControlRequest+0x8>)
 80251da:	f7ff be53 	b.w	8024e84 <CDC_Device_ProcessControlRequest>
 80251de:	bf00      	nop
 80251e0:	1fffab34 	.word	0x1fffab34

080251e4 <USBD_VCOM_Event_Reset>:

/* Event handler for the USB reset event. */
void USBD_VCOM_Event_Reset(void)
{
  /*For self powered devices, reinitialize USB*/
  if (device.IsConfigured)
 80251e4:	492d      	ldr	r1, [pc, #180]	; (802529c <USBD_VCOM_Event_Reset+0xb8>)
 80251e6:	f891 213e 	ldrb.w	r2, [r1, #318]	; 0x13e
 80251ea:	07d3      	lsls	r3, r2, #31
 80251ec:	d400      	bmi.n	80251f0 <USBD_VCOM_Event_Reset+0xc>
 80251ee:	4770      	bx	lr

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 80251f0:	482b      	ldr	r0, [pc, #172]	; (80252a0 <USBD_VCOM_Event_Reset+0xbc>)
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
 80251f2:	4b2c      	ldr	r3, [pc, #176]	; (80252a4 <USBD_VCOM_Event_Reset+0xc0>)

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 80251f4:	6800      	ldr	r0, [r0, #0]
  CDC_Device_ProcessControlRequest(&USBD_VCOM_cdc_interface);
}

/* Event handler for the USB reset event. */
void USBD_VCOM_Event_Reset(void)
{
 80251f6:	e92d 4ef0 	stmdb	sp!, {r4, r5, r6, r7, r9, sl, fp, lr}
  /*For self powered devices, reinitialize USB*/
  if (device.IsConfigured)
  {
    device.IsConfigured = 0U;
 80251fa:	f36f 0200 	bfc	r2, #0, #1
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
 80251fe:	f04f 0a00 	mov.w	sl, #0
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
 8025202:	f04f 0903 	mov.w	r9, #3

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8025206:	4c28      	ldr	r4, [pc, #160]	; (80252a8 <USBD_VCOM_Event_Reset+0xc4>)
void USBD_VCOM_Event_Reset(void)
{
  /*For self powered devices, reinitialize USB*/
  if (device.IsConfigured)
  {
    device.IsConfigured = 0U;
 8025208:	f881 213e 	strb.w	r2, [r1, #318]	; 0x13e
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
 802520c:	f883 a012 	strb.w	sl, [r3, #18]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Size = CDC_NOTIFICATION_EPSIZE;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Type = (uint8_t)EP_TYPE_INTERRUPT;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Banks = 0U;
 8025210:	f883 a011 	strb.w	sl, [r3, #17]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Size = CDC_NOTIFICATION_EPSIZE;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Type = (uint8_t)EP_TYPE_INTERRUPT;
 8025214:	f883 9010 	strb.w	r9, [r3, #16]

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8025218:	6902      	ldr	r2, [r0, #16]
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
 802521a:	6966      	ldr	r6, [r4, #20]
 802521c:	6156      	str	r6, [r2, #20]
    USBD_handle->event_cb->suspend = event_callback->suspend;
 802521e:	69e6      	ldr	r6, [r4, #28]
 8025220:	61d6      	str	r6, [r2, #28]
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
 8025222:	69a6      	ldr	r6, [r4, #24]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
 8025224:	f883 a00b 	strb.w	sl, [r3, #11]
  CDC_Device_ProcessControlRequest(&USBD_VCOM_cdc_interface);
}

/* Event handler for the USB reset event. */
void USBD_VCOM_Event_Reset(void)
{
 8025228:	b082      	sub	sp, #8
  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
 802522a:	f883 a005 	strb.w	sl, [r3, #5]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
 802522e:	f883 9006 	strb.w	r9, [r3, #6]
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
 8025232:	6196      	str	r6, [r2, #24]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
 8025234:	f04f 0a81 	mov.w	sl, #129	; 0x81

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8025238:	6926      	ldr	r6, [r4, #16]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
 802523a:	f883 a00c 	strb.w	sl, [r3, #12]
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Size = CDC_NOTIFICATION_EPSIZE;
 802523e:	f04f 0908 	mov.w	r9, #8
 8025242:	f8a3 900e 	strh.w	r9, [r3, #14]
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
 8025246:	6821      	ldr	r1, [r4, #0]
  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
 8025248:	68a7      	ldr	r7, [r4, #8]
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
 802524a:	68e5      	ldr	r5, [r4, #12]

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 802524c:	6116      	str	r6, [r2, #16]
  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
 802524e:	f04f 0b40 	mov.w	fp, #64	; 0x40
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
    USBD_handle->event_cb->start_of_frame = event_callback->start_of_frame;
 8025252:	6a26      	ldr	r6, [r4, #32]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
 8025254:	f8a3 b008 	strh.w	fp, [r3, #8]

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
 8025258:	f04f 0a02 	mov.w	sl, #2

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
 802525c:	f04f 0982 	mov.w	r9, #130	; 0x82
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
 8025260:	f883 a00a 	strb.w	sl, [r3, #10]
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
 8025264:	9101      	str	r1, [sp, #4]
  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
 8025266:	f8a3 b002 	strh.w	fp, [r3, #2]
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
 802526a:	6861      	ldr	r1, [r4, #4]

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
 802526c:	f883 a004 	strb.w	sl, [r3, #4]

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
 8025270:	f883 9000 	strb.w	r9, [r3]
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
    USBD_handle->event_cb->start_of_frame = event_callback->start_of_frame;
 8025274:	6216      	str	r6, [r2, #32]
  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
 8025276:	6097      	str	r7, [r2, #8]
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
 8025278:	60d5      	str	r5, [r2, #12]
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
 802527a:	9b01      	ldr	r3, [sp, #4]
 802527c:	6013      	str	r3, [r2, #0]
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
    USBD_handle->event_cb->start_of_frame = event_callback->start_of_frame;
    USBD_handle->event_cb->reset = event_callback->reset;
 802527e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
 8025280:	6051      	str	r1, [r2, #4]
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
    USBD_handle->event_cb->start_of_frame = event_callback->start_of_frame;
    USBD_handle->event_cb->reset = event_callback->reset;
 8025282:	6253      	str	r3, [r2, #36]	; 0x24
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Banks = 0U;

  /*Register the required USB events*/
  if (USBD_VCOM_STATUS_SUCCESS == USBD_VCOM_Register_USBEvent_CB(&usbd_vcom_events))
  {
    if (USBD_VCOM_STATUS_SUCCESS != (USBD_VCOM_STATUS_t)USBD_Init(USBD_handle))
 8025284:	f000 fee2 	bl	802604c <USBD_Init>
 8025288:	b110      	cbz	r0, 8025290 <USBD_VCOM_Event_Reset+0xac>
      if (USBD_VCOM_STATUS_SUCCESS != USBD_VCOM_Connect())
      {
      }
    }
  }
}
 802528a:	b002      	add	sp, #8
 802528c:	e8bd 8ef0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, sl, fp, pc}
 8025290:	b002      	add	sp, #8
 8025292:	e8bd 4ef0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, sl, fp, lr}
}

/*The API to connect the VCOM device to USB host*/
USBD_VCOM_STATUS_t USBD_VCOM_Connect(void)
{
  return (USBD_VCOM_STATUS_t)USBD_Connect();
 8025296:	f000 bf63 	b.w	8026160 <USBD_Connect>
 802529a:	bf00      	nop
 802529c:	1fffad60 	.word	0x1fffad60
 80252a0:	1ffe8874 	.word	0x1ffe8874
 80252a4:	1fffab34 	.word	0x1fffab34
 80252a8:	1ffe884c 	.word	0x1ffe884c

080252ac <USBD_VCOM_Init>:

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 80252ac:	4a26      	ldr	r2, [pc, #152]	; (8025348 <USBD_VCOM_Init+0x9c>)
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
 80252ae:	4b27      	ldr	r3, [pc, #156]	; (802534c <USBD_VCOM_Init+0xa0>)

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 80252b0:	6810      	ldr	r0, [r2, #0]
 80252b2:	4927      	ldr	r1, [pc, #156]	; (8025350 <USBD_VCOM_Init+0xa4>)
}


/*The function initializes the USB core layer and register USB event call backs. */
USBD_VCOM_STATUS_t USBD_VCOM_Init(USBD_VCOM_t *vcom_handle)
{
 80252b4:	e92d 4ef0 	stmdb	sp!, {r4, r5, r6, r7, r9, sl, fp, lr}
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
 80252b8:	f04f 0a00 	mov.w	sl, #0
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
 80252bc:	f04f 0903 	mov.w	r9, #3
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
 80252c0:	f883 a012 	strb.w	sl, [r3, #18]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Size = CDC_NOTIFICATION_EPSIZE;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Type = (uint8_t)EP_TYPE_INTERRUPT;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Banks = 0U;
 80252c4:	f883 a011 	strb.w	sl, [r3, #17]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Size = CDC_NOTIFICATION_EPSIZE;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Type = (uint8_t)EP_TYPE_INTERRUPT;
 80252c8:	f883 9010 	strb.w	r9, [r3, #16]

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 80252cc:	6902      	ldr	r2, [r0, #16]
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
 80252ce:	694e      	ldr	r6, [r1, #20]
 80252d0:	6156      	str	r6, [r2, #20]
    USBD_handle->event_cb->suspend = event_callback->suspend;
 80252d2:	69ce      	ldr	r6, [r1, #28]
 80252d4:	61d6      	str	r6, [r2, #28]
}


/*The function initializes the USB core layer and register USB event call backs. */
USBD_VCOM_STATUS_t USBD_VCOM_Init(USBD_VCOM_t *vcom_handle)
{
 80252d6:	b082      	sub	sp, #8
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
 80252d8:	698e      	ldr	r6, [r1, #24]
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
 80252da:	680c      	ldr	r4, [r1, #0]
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
 80252dc:	6196      	str	r6, [r2, #24]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
 80252de:	f883 a00b 	strb.w	sl, [r3, #11]

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 80252e2:	690e      	ldr	r6, [r1, #16]
  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
 80252e4:	f883 a005 	strb.w	sl, [r3, #5]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
 80252e8:	f883 9006 	strb.w	r9, [r3, #6]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
 80252ec:	f04f 0a81 	mov.w	sl, #129	; 0x81
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Size = CDC_NOTIFICATION_EPSIZE;
 80252f0:	f04f 0908 	mov.w	r9, #8
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
 80252f4:	68cd      	ldr	r5, [r1, #12]
  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
 80252f6:	688f      	ldr	r7, [r1, #8]

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 80252f8:	6116      	str	r6, [r2, #16]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
 80252fa:	f883 a00c 	strb.w	sl, [r3, #12]
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
    USBD_handle->event_cb->start_of_frame = event_callback->start_of_frame;
 80252fe:	6a0e      	ldr	r6, [r1, #32]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Size = CDC_NOTIFICATION_EPSIZE;
 8025300:	f8a3 900e 	strh.w	r9, [r3, #14]
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
 8025304:	9401      	str	r4, [sp, #4]
  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
 8025306:	f04f 0b40 	mov.w	fp, #64	; 0x40
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
 802530a:	f04f 0a02 	mov.w	sl, #2

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
 802530e:	f04f 0982 	mov.w	r9, #130	; 0x82
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
 8025312:	684c      	ldr	r4, [r1, #4]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
 8025314:	f8a3 b008 	strh.w	fp, [r3, #8]
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
    USBD_handle->event_cb->start_of_frame = event_callback->start_of_frame;
 8025318:	6216      	str	r6, [r2, #32]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
 802531a:	f883 a00a 	strb.w	sl, [r3, #10]
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
 802531e:	60d5      	str	r5, [r2, #12]
  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
 8025320:	6097      	str	r7, [r2, #8]
  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
 8025322:	f8a3 b002 	strh.w	fp, [r3, #2]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
 8025326:	f883 a004 	strb.w	sl, [r3, #4]

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
 802532a:	f883 9000 	strb.w	r9, [r3]
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
 802532e:	9b01      	ldr	r3, [sp, #4]
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
 8025330:	e882 0018 	stmia.w	r2, {r3, r4}
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
    USBD_handle->event_cb->start_of_frame = event_callback->start_of_frame;
    USBD_handle->event_cb->reset = event_callback->reset;
 8025334:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8025336:	6253      	str	r3, [r2, #36]	; 0x24
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Banks = 0U;

  /*Register the required USB events*/
  if (USBD_VCOM_STATUS_SUCCESS == USBD_VCOM_Register_USBEvent_CB(&usbd_vcom_events))
  {
    if (USBD_VCOM_STATUS_SUCCESS != (USBD_VCOM_STATUS_t)USBD_Init(USBD_handle))
 8025338:	f000 fe88 	bl	802604c <USBD_Init>
  }
  /*Remove the compilation warning*/
  (void)vcom_handle;

  return status;
}
 802533c:	3000      	adds	r0, #0
 802533e:	bf18      	it	ne
 8025340:	2001      	movne	r0, #1
 8025342:	b002      	add	sp, #8
 8025344:	e8bd 8ef0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, sl, fp, pc}
 8025348:	1ffe8874 	.word	0x1ffe8874
 802534c:	1fffab34 	.word	0x1fffab34
 8025350:	1ffe884c 	.word	0x1ffe884c

08025354 <USBD_VCOM_IsEnumDone>:

/*The function check if the enumeration has been done already. */
uint32_t USBD_VCOM_IsEnumDone(void)
{
 8025354:	b508      	push	{r3, lr}
  return (uint32_t)(USBD_IsEnumDone() && (USB_DeviceState == (uint8_t)DEVICE_STATE_Configured));
 8025356:	f000 ff09 	bl	802616c <USBD_IsEnumDone>
 802535a:	b130      	cbz	r0, 802536a <USBD_VCOM_IsEnumDone+0x16>
 802535c:	4b03      	ldr	r3, [pc, #12]	; (802536c <USBD_VCOM_IsEnumDone+0x18>)
 802535e:	7818      	ldrb	r0, [r3, #0]
 8025360:	f1a0 0004 	sub.w	r0, r0, #4
 8025364:	fab0 f080 	clz	r0, r0
 8025368:	0940      	lsrs	r0, r0, #5
}
 802536a:	bd08      	pop	{r3, pc}
 802536c:	1fffab55 	.word	0x1fffab55

08025370 <USBD_VCOM_SendData>:
  return status;
}

/* This function sends multiple bytes to the USB host. */
USBD_VCOM_STATUS_t USBD_VCOM_SendData(const int8_t* const data_buffer, const uint16_t length)
{
 8025370:	b510      	push	{r4, lr}
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  if ((length == 0U) || (data_buffer == NULL))
 8025372:	b911      	cbnz	r1, 802537a <USBD_VCOM_SendData+0xa>
  {
    status = USBD_VCOM_STATUS_CDC_ERROR;		  
 8025374:	2406      	movs	r4, #6
    {
      status = USBD_VCOM_STATUS_CDC_ERROR;
    }
  }
  return status;
}
 8025376:	4620      	mov	r0, r4
 8025378:	bd10      	pop	{r4, pc}
/* This function sends multiple bytes to the USB host. */
USBD_VCOM_STATUS_t USBD_VCOM_SendData(const int8_t* const data_buffer, const uint16_t length)
{
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  if ((length == 0U) || (data_buffer == NULL))
 802537a:	2800      	cmp	r0, #0
 802537c:	d0fa      	beq.n	8025374 <USBD_VCOM_SendData+0x4>
 802537e:	460a      	mov	r2, r1
 8025380:	4601      	mov	r1, r0
  }
  else
  {
    /* Send data to USB host.*/
    if ((uint8_t)ENDPOINT_RWSTREAM_NoError !=
        CDC_Device_SendData(&USBD_VCOM_cdc_interface, (const int8_t *)data_buffer, length))
 8025382:	4807      	ldr	r0, [pc, #28]	; (80253a0 <USBD_VCOM_SendData+0x30>)
 8025384:	f7ff fe7a 	bl	802507c <CDC_Device_SendData>
    status = USBD_VCOM_STATUS_CDC_ERROR;		  
  }
  else
  {
    /* Send data to USB host.*/
    if ((uint8_t)ENDPOINT_RWSTREAM_NoError !=
 8025388:	2800      	cmp	r0, #0
        CDC_Device_SendData(&USBD_VCOM_cdc_interface, (const int8_t *)data_buffer, length))
    {
      status = USBD_VCOM_STATUS_CDC_ERROR;
    }
    if ((uint8_t)ENDPOINT_READYWAIT_NoError != CDC_Device_Flush(&USBD_VCOM_cdc_interface))
 802538a:	4805      	ldr	r0, [pc, #20]	; (80253a0 <USBD_VCOM_SendData+0x30>)
  {
    /* Send data to USB host.*/
    if ((uint8_t)ENDPOINT_RWSTREAM_NoError !=
        CDC_Device_SendData(&USBD_VCOM_cdc_interface, (const int8_t *)data_buffer, length))
    {
      status = USBD_VCOM_STATUS_CDC_ERROR;
 802538c:	bf14      	ite	ne
 802538e:	2406      	movne	r4, #6
 8025390:	2400      	moveq	r4, #0
    }
    if ((uint8_t)ENDPOINT_READYWAIT_NoError != CDC_Device_Flush(&USBD_VCOM_cdc_interface))
 8025392:	f7ff fe91 	bl	80250b8 <CDC_Device_Flush>
 8025396:	2800      	cmp	r0, #0
    {
      status = USBD_VCOM_STATUS_CDC_ERROR;
 8025398:	bf18      	it	ne
 802539a:	2406      	movne	r4, #6
    }
  }
  return status;
}
 802539c:	4620      	mov	r0, r4
 802539e:	bd10      	pop	{r4, pc}
 80253a0:	1fffab34 	.word	0x1fffab34

080253a4 <USBD_VCOM_ReceiveData>:
  return status;
}

/* This function receives number of bytes from the USB host.*/
USBD_VCOM_STATUS_t USBD_VCOM_ReceiveData(int8_t* data_buffer, uint16_t data_byte)
{
 80253a4:	b530      	push	{r4, r5, lr}
 80253a6:	b083      	sub	sp, #12
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;
  uint16_t bytes_processed = 0U;
 80253a8:	2300      	movs	r3, #0
 80253aa:	f8ad 3006 	strh.w	r3, [sp, #6]
  uint8_t ret = 0U;

  if ((data_byte > 0U) && (data_buffer != NULL))
 80253ae:	b911      	cbnz	r1, 80253b6 <USBD_VCOM_ReceiveData+0x12>
      status = USBD_VCOM_STATUS_CDC_ERROR;
    }
  }
  else
  {
    status = USBD_VCOM_STATUS_CDC_ERROR;
 80253b0:	2006      	movs	r0, #6
  }

  return status;
}
 80253b2:	b003      	add	sp, #12
 80253b4:	bd30      	pop	{r4, r5, pc}
{
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;
  uint16_t bytes_processed = 0U;
  uint8_t ret = 0U;

  if ((data_byte > 0U) && (data_buffer != NULL))
 80253b6:	2800      	cmp	r0, #0
 80253b8:	d0fa      	beq.n	80253b0 <USBD_VCOM_ReceiveData+0xc>
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 80253ba:	4a0b      	ldr	r2, [pc, #44]	; (80253e8 <USBD_VCOM_ReceiveData+0x44>)
 80253bc:	460c      	mov	r4, r1
 80253be:	2103      	movs	r1, #3
 80253c0:	4605      	mov	r5, r0
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 80253c2:	f882 313d 	strb.w	r3, [r2, #317]	; 0x13d
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 80253c6:	f882 113c 	strb.w	r1, [r2, #316]	; 0x13c
  {
    /* Fix for new read/write */
    Endpoint_SelectEndpoint(CDC_RX_EPNUM);
    while ((uint8_t)ENDPOINT_RWSTREAM_IncompleteTransfer == 
 80253ca:	4628      	mov	r0, r5
 80253cc:	4621      	mov	r1, r4
 80253ce:	f10d 0206 	add.w	r2, sp, #6
 80253d2:	f000 f871 	bl	80254b8 <Endpoint_Read_Stream_LE>
 80253d6:	2805      	cmp	r0, #5
 80253d8:	d0f7      	beq.n	80253ca <USBD_VCOM_ReceiveData+0x26>
    (ret = Endpoint_Read_Stream_LE(data_buffer, data_byte,	&bytes_processed)))
    {      
    }      
    if ((uint8_t)ENDPOINT_RWSTREAM_NoError != ret )
    {
      status = USBD_VCOM_STATUS_CDC_ERROR;
 80253da:	2800      	cmp	r0, #0
 80253dc:	bf0c      	ite	eq
 80253de:	2000      	moveq	r0, #0
 80253e0:	2006      	movne	r0, #6
  {
    status = USBD_VCOM_STATUS_CDC_ERROR;
  }

  return status;
}
 80253e2:	b003      	add	sp, #12
 80253e4:	bd30      	pop	{r4, r5, pc}
 80253e6:	bf00      	nop
 80253e8:	1fffad60 	.word	0x1fffad60

080253ec <USBD_VCOM_BytesReceived>:
  return status;
}

/* This function checks number of bytes received from the USB host. */
uint16_t USBD_VCOM_BytesReceived(void)
{
 80253ec:	b538      	push	{r3, r4, r5, lr}
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80253ee:	4c07      	ldr	r4, [pc, #28]	; (802540c <USBD_VCOM_BytesReceived+0x20>)
 80253f0:	f44f 6500 	mov.w	r5, #2048	; 0x800
 80253f4:	f8c4 508c 	str.w	r5, [r4, #140]	; 0x8c
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 80253f8:	f3bf 8f4f 	dsb	sy
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 80253fc:	f3bf 8f6f 	isb	sy
  uint16_t bytes = 0U;

  /* Check if bytes are received from host */
  NVIC_DisableIRQ(USB0_0_IRQn);
  bytes = CDC_Device_BytesReceived(&USBD_VCOM_cdc_interface);
 8025400:	4803      	ldr	r0, [pc, #12]	; (8025410 <USBD_VCOM_BytesReceived+0x24>)
 8025402:	f7ff fe7f 	bl	8025104 <CDC_Device_BytesReceived>
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8025406:	60e5      	str	r5, [r4, #12]
  NVIC_EnableIRQ(USB0_0_IRQn);	
    
  return bytes;
}
 8025408:	bd38      	pop	{r3, r4, r5, pc}
 802540a:	bf00      	nop
 802540c:	e000e100 	.word	0xe000e100
 8025410:	1fffab34 	.word	0x1fffab34

08025414 <USBD_VCOM_Connect>:
}

/*The API to connect the VCOM device to USB host*/
USBD_VCOM_STATUS_t USBD_VCOM_Connect(void)
{
  return (USBD_VCOM_STATUS_t)USBD_Connect();
 8025414:	f000 bea4 	b.w	8026160 <USBD_Connect>

08025418 <Endpoint_Write_Stream_LE>:
/*Flag to indicate the zlp to be sent or not*/
volatile uint8_t zlp_flag = 0;

uint8_t Endpoint_Write_Stream_LE (const void *const Buffer, uint16_t Length,
											uint16_t *const BytesProcessed)
{
 8025418:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	USBD_Endpoint_t* ep = &device.Endpoints[device.CurrentEndpoint];
 802541c:	4b25      	ldr	r3, [pc, #148]	; (80254b4 <Endpoint_Write_Stream_LE+0x9c>)
/*Flag to indicate the zlp to be sent or not*/
volatile uint8_t zlp_flag = 0;

uint8_t Endpoint_Write_Stream_LE (const void *const Buffer, uint16_t Length,
											uint16_t *const BytesProcessed)
{
 802541e:	460c      	mov	r4, r1
 8025420:	4680      	mov	r8, r0
	USBD_Endpoint_t* ep = &device.Endpoints[device.CurrentEndpoint];
 8025422:	f893 113c 	ldrb.w	r1, [r3, #316]	; 0x13c
	uint16_t Bytes = 0;
	uint16_t BytesTransfered = 0;
	uint8_t ErrorCode;

	if (BytesProcessed!=NULL) 
 8025426:	4691      	mov	r9, r2
 8025428:	2a00      	cmp	r2, #0
 802542a:	d03b      	beq.n	80254a4 <Endpoint_Write_Stream_LE+0x8c>
	{
		Length -= *BytesProcessed;
 802542c:	8817      	ldrh	r7, [r2, #0]
 802542e:	1be4      	subs	r4, r4, r7
 8025430:	b2a4      	uxth	r4, r4
		BytesTransfered = *BytesProcessed;
	}

	while (Length) 
	{
		if (ep->InInUse)
 8025432:	262c      	movs	r6, #44	; 0x2c
 8025434:	fb06 3601 	mla	r6, r6, r1, r3
	{
		Length -= *BytesProcessed;
		BytesTransfered = *BytesProcessed;
	}

	while (Length) 
 8025438:	b1f4      	cbz	r4, 8025478 <Endpoint_Write_Stream_LE+0x60>
	{
		if (ep->InInUse)
 802543a:	68b3      	ldr	r3, [r6, #8]
 802543c:	06db      	lsls	r3, r3, #27
 802543e:	d4fc      	bmi.n	802543a <Endpoint_Write_Stream_LE+0x22>
		{
			continue;
		}
		if (Endpoint_IsReadWriteAllowed()) 
 8025440:	f000 f93a 	bl	80256b8 <Endpoint_IsReadWriteAllowed>
 8025444:	b1f8      	cbz	r0, 8025486 <Endpoint_Write_Stream_LE+0x6e>
		{
			if((ep->InBufferLength - ep->InBytesAvailable)  > Length)
 8025446:	6a75      	ldr	r5, [r6, #36]	; 0x24
 8025448:	69f0      	ldr	r0, [r6, #28]
 802544a:	1a2d      	subs	r5, r5, r0
 802544c:	42a5      	cmp	r5, r4
 802544e:	d816      	bhi.n	802547e <Endpoint_Write_Stream_LE+0x66>
			{
				Bytes = Length;
			}
			else
			{
				Bytes = (ep->InBufferLength - ep->InBytesAvailable);
 8025450:	b2ad      	uxth	r5, r5
 8025452:	1b64      	subs	r4, r4, r5
 8025454:	fa1f fb84 	uxth.w	fp, r4
 8025458:	462c      	mov	r4, r5
			}
			memcpy(ep->InBuffer + ep->InBytesAvailable,(uint8_t*)Buffer + BytesTransfered,Bytes);
 802545a:	6a33      	ldr	r3, [r6, #32]
 802545c:	eb08 0107 	add.w	r1, r8, r7
 8025460:	462a      	mov	r2, r5
 8025462:	4418      	add	r0, r3
 8025464:	f005 fb5c 	bl	802ab20 <memcpy>
			ep->InBytesAvailable += Bytes;
 8025468:	69f3      	ldr	r3, [r6, #28]
			BytesTransfered += Bytes;
 802546a:	4427      	add	r7, r4
			else
			{
				Bytes = (ep->InBufferLength - ep->InBytesAvailable);
			}
			memcpy(ep->InBuffer + ep->InBytesAvailable,(uint8_t*)Buffer + BytesTransfered,Bytes);
			ep->InBytesAvailable += Bytes;
 802546c:	441d      	add	r5, r3
			BytesTransfered += Bytes;
			Length -= Bytes;
 802546e:	465c      	mov	r4, fp
			{
				Bytes = (ep->InBufferLength - ep->InBytesAvailable);
			}
			memcpy(ep->InBuffer + ep->InBytesAvailable,(uint8_t*)Buffer + BytesTransfered,Bytes);
			ep->InBytesAvailable += Bytes;
			BytesTransfered += Bytes;
 8025470:	b2bf      	uxth	r7, r7
			else
			{
				Bytes = (ep->InBufferLength - ep->InBytesAvailable);
			}
			memcpy(ep->InBuffer + ep->InBytesAvailable,(uint8_t*)Buffer + BytesTransfered,Bytes);
			ep->InBytesAvailable += Bytes;
 8025472:	61f5      	str	r5, [r6, #28]
	{
		Length -= *BytesProcessed;
		BytesTransfered = *BytesProcessed;
	}

	while (Length) 
 8025474:	2c00      	cmp	r4, #0
 8025476:	d1e0      	bne.n	802543a <Endpoint_Write_Stream_LE+0x22>
				return ErrorCode;
			}
		}
	}
	
	return ENDPOINT_RWSTREAM_NoError;
 8025478:	4620      	mov	r0, r4
}
 802547a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802547e:	4625      	mov	r5, r4
 8025480:	f04f 0b00 	mov.w	fp, #0
 8025484:	e7e9      	b.n	802545a <Endpoint_Write_Stream_LE+0x42>
			BytesTransfered += Bytes;
			Length -= Bytes;
		}
		else 
		{
			Endpoint_ClearIN();
 8025486:	f000 f8df 	bl	8025648 <Endpoint_ClearIN>
			if(Length < ep->MaxPacketSize)
 802548a:	8933      	ldrh	r3, [r6, #8]
 802548c:	f3c3 1386 	ubfx	r3, r3, #6, #7
 8025490:	429c      	cmp	r4, r3
 8025492:	da02      	bge.n	802549a <Endpoint_Write_Stream_LE+0x82>
			{
				if (BytesProcessed!=NULL) 
 8025494:	f1b9 0f00 	cmp.w	r9, #0
 8025498:	d106      	bne.n	80254a8 <Endpoint_Write_Stream_LE+0x90>
					*BytesProcessed = BytesTransfered;
					return ENDPOINT_RWSTREAM_IncompleteTransfer;
				}
			}

			ErrorCode = Endpoint_WaitUntilReady();
 802549a:	f000 f85d 	bl	8025558 <Endpoint_WaitUntilReady>
			if (ErrorCode) 
 802549e:	2800      	cmp	r0, #0
 80254a0:	d0ca      	beq.n	8025438 <Endpoint_Write_Stream_LE+0x20>
 80254a2:	e7ea      	b.n	802547a <Endpoint_Write_Stream_LE+0x62>
uint8_t Endpoint_Write_Stream_LE (const void *const Buffer, uint16_t Length,
											uint16_t *const BytesProcessed)
{
	USBD_Endpoint_t* ep = &device.Endpoints[device.CurrentEndpoint];
	uint16_t Bytes = 0;
	uint16_t BytesTransfered = 0;
 80254a4:	4617      	mov	r7, r2
 80254a6:	e7c4      	b.n	8025432 <Endpoint_Write_Stream_LE+0x1a>
			Endpoint_ClearIN();
			if(Length < ep->MaxPacketSize)
			{
				if (BytesProcessed!=NULL) 
				{
					*BytesProcessed = BytesTransfered;
 80254a8:	f8a9 7000 	strh.w	r7, [r9]
					return ENDPOINT_RWSTREAM_IncompleteTransfer;
 80254ac:	2005      	movs	r0, #5
 80254ae:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80254b2:	bf00      	nop
 80254b4:	1fffad60 	.word	0x1fffad60

080254b8 <Endpoint_Read_Stream_LE>:
	return ENDPOINT_RWSTREAM_NoError;
}

uint8_t	Endpoint_Read_Stream_LE (void *const Buffer, uint16_t Length,
									uint16_t *const BytesProcessed)
{
 80254b8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	USBD_Endpoint_t* ep = &device.Endpoints[device.CurrentEndpoint];
 80254bc:	4b25      	ldr	r3, [pc, #148]	; (8025554 <Endpoint_Read_Stream_LE+0x9c>)
	return ENDPOINT_RWSTREAM_NoError;
}

uint8_t	Endpoint_Read_Stream_LE (void *const Buffer, uint16_t Length,
									uint16_t *const BytesProcessed)
{
 80254be:	460c      	mov	r4, r1
 80254c0:	4681      	mov	r9, r0
	USBD_Endpoint_t* ep = &device.Endpoints[device.CurrentEndpoint];
 80254c2:	f893 113c 	ldrb.w	r1, [r3, #316]	; 0x13c
	uint16_t Bytes = 0;
	uint16_t BytesTransfered = 0;
	uint8_t ErrorCode;

	if (BytesProcessed!=NULL) 
 80254c6:	4692      	mov	sl, r2
 80254c8:	2a00      	cmp	r2, #0
 80254ca:	d03b      	beq.n	8025544 <Endpoint_Read_Stream_LE+0x8c>
	{
		Length -= *BytesProcessed;
 80254cc:	f8b2 8000 	ldrh.w	r8, [r2]
 80254d0:	ebc8 0404 	rsb	r4, r8, r4
 80254d4:	b2a4      	uxth	r4, r4
		BytesTransfered = *BytesProcessed;
	}

	while (Length) 
	{
		if (ep->OutInUse)
 80254d6:	252c      	movs	r5, #44	; 0x2c
 80254d8:	fb05 3501 	mla	r5, r5, r1, r3
	{
		Length -= *BytesProcessed;
		BytesTransfered = *BytesProcessed;
	}

	while (Length) 
 80254dc:	b30c      	cbz	r4, 8025522 <Endpoint_Read_Stream_LE+0x6a>
	{
		if (ep->OutInUse)
 80254de:	68ab      	ldr	r3, [r5, #8]
 80254e0:	071b      	lsls	r3, r3, #28
 80254e2:	d4fc      	bmi.n	80254de <Endpoint_Read_Stream_LE+0x26>
		{
			continue;
		}
		if (Endpoint_IsReadWriteAllowed()) 
 80254e4:	f000 f8e8 	bl	80256b8 <Endpoint_IsReadWriteAllowed>
 80254e8:	b310      	cbz	r0, 8025530 <Endpoint_Read_Stream_LE+0x78>
		{
			if(ep->OutBytesAvailable  > Length)
 80254ea:	68ee      	ldr	r6, [r5, #12]
 80254ec:	42a6      	cmp	r6, r4
 80254ee:	d81b      	bhi.n	8025528 <Endpoint_Read_Stream_LE+0x70>
			{
				Bytes = Length;
			}
			else
			{
				Bytes = (uint16_t)ep->OutBytesAvailable;
 80254f0:	b2b3      	uxth	r3, r6
 80254f2:	1ae4      	subs	r4, r4, r3
 80254f4:	fa1f fb84 	uxth.w	fp, r4
 80254f8:	461c      	mov	r4, r3
			}

			memcpy((uint8_t*)Buffer + BytesTransfered,
									ep->OutBuffer + ep->OutOffset,Bytes);
 80254fa:	692b      	ldr	r3, [r5, #16]
 80254fc:	6969      	ldr	r1, [r5, #20]
			else
			{
				Bytes = (uint16_t)ep->OutBytesAvailable;
			}

			memcpy((uint8_t*)Buffer + BytesTransfered,
 80254fe:	4632      	mov	r2, r6
 8025500:	eb09 0008 	add.w	r0, r9, r8
 8025504:	4419      	add	r1, r3
 8025506:	f005 fb0b 	bl	802ab20 <memcpy>
									ep->OutBuffer + ep->OutOffset,Bytes);
			ep->OutBytesAvailable -= Bytes;
 802550a:	68ea      	ldr	r2, [r5, #12]
			ep->OutOffset += Bytes;
 802550c:	692b      	ldr	r3, [r5, #16]
			BytesTransfered += Bytes;
 802550e:	44a0      	add	r8, r4
				Bytes = (uint16_t)ep->OutBytesAvailable;
			}

			memcpy((uint8_t*)Buffer + BytesTransfered,
									ep->OutBuffer + ep->OutOffset,Bytes);
			ep->OutBytesAvailable -= Bytes;
 8025510:	1b92      	subs	r2, r2, r6
			ep->OutOffset += Bytes;
			BytesTransfered += Bytes;
			Length -= Bytes;
 8025512:	465c      	mov	r4, fp
			}

			memcpy((uint8_t*)Buffer + BytesTransfered,
									ep->OutBuffer + ep->OutOffset,Bytes);
			ep->OutBytesAvailable -= Bytes;
			ep->OutOffset += Bytes;
 8025514:	441e      	add	r6, r3
			BytesTransfered += Bytes;
 8025516:	fa1f f888 	uxth.w	r8, r8
				Bytes = (uint16_t)ep->OutBytesAvailable;
			}

			memcpy((uint8_t*)Buffer + BytesTransfered,
									ep->OutBuffer + ep->OutOffset,Bytes);
			ep->OutBytesAvailable -= Bytes;
 802551a:	60ea      	str	r2, [r5, #12]
			ep->OutOffset += Bytes;
 802551c:	612e      	str	r6, [r5, #16]
	{
		Length -= *BytesProcessed;
		BytesTransfered = *BytesProcessed;
	}

	while (Length) 
 802551e:	2c00      	cmp	r4, #0
 8025520:	d1dd      	bne.n	80254de <Endpoint_Read_Stream_LE+0x26>
			{
				return ErrorCode;
			}
		}
	}
	return ENDPOINT_RWSTREAM_NoError;
 8025522:	4620      	mov	r0, r4
}
 8025524:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8025528:	4626      	mov	r6, r4
 802552a:	f04f 0b00 	mov.w	fp, #0
 802552e:	e7e4      	b.n	80254fa <Endpoint_Read_Stream_LE+0x42>
			BytesTransfered += Bytes;
			Length -= Bytes;
		}
		else 
		{
			Endpoint_ClearOUT();
 8025530:	f000 f85e 	bl	80255f0 <Endpoint_ClearOUT>
			if (BytesProcessed != NULL) 
 8025534:	f1ba 0f00 	cmp.w	sl, #0
 8025538:	d106      	bne.n	8025548 <Endpoint_Read_Stream_LE+0x90>
			{
				*BytesProcessed = BytesTransfered;
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			ErrorCode = Endpoint_WaitUntilReady();
 802553a:	f000 f80d 	bl	8025558 <Endpoint_WaitUntilReady>
			if (ErrorCode) 
 802553e:	2800      	cmp	r0, #0
 8025540:	d0cc      	beq.n	80254dc <Endpoint_Read_Stream_LE+0x24>
 8025542:	e7ef      	b.n	8025524 <Endpoint_Read_Stream_LE+0x6c>
uint8_t	Endpoint_Read_Stream_LE (void *const Buffer, uint16_t Length,
									uint16_t *const BytesProcessed)
{
	USBD_Endpoint_t* ep = &device.Endpoints[device.CurrentEndpoint];
	uint16_t Bytes = 0;
	uint16_t BytesTransfered = 0;
 8025544:	4690      	mov	r8, r2
 8025546:	e7c6      	b.n	80254d6 <Endpoint_Read_Stream_LE+0x1e>
		else 
		{
			Endpoint_ClearOUT();
			if (BytesProcessed != NULL) 
			{
				*BytesProcessed = BytesTransfered;
 8025548:	f8aa 8000 	strh.w	r8, [sl]
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
 802554c:	2005      	movs	r0, #5
 802554e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8025552:	bf00      	nop
 8025554:	1fffad60 	.word	0x1fffad60

08025558 <Endpoint_WaitUntilReady>:

#define USB_STREAM_TIMEOUT_MS 100


uint8_t Endpoint_WaitUntilReady(void)
{
 8025558:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 *
 *  \return Current USB frame number from the USB controller.
 */
static inline uint16_t USB_Device_GetFrameNumber(void);
static inline uint16_t USB_Device_GetFrameNumber() {
	return device.Driver->GetFrameNumber();
 802555c:	4c22      	ldr	r4, [pc, #136]	; (80255e8 <Endpoint_WaitUntilReady+0x90>)
			{
			  return ENDPOINT_READYWAIT_NoError;
			}
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
 802555e:	4d23      	ldr	r5, [pc, #140]	; (80255ec <Endpoint_WaitUntilReady+0x94>)
 8025560:	6823      	ldr	r3, [r4, #0]
 8025562:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8025564:	4798      	blx	r3
	 */
	static inline bool Endpoint_IsStalled(void);
	static inline bool Endpoint_IsStalled(void)
	{
		bool status = false;
		if(device.Endpoints[device.CurrentEndpoint].IsHalted == 1)
 8025566:	46a1      	mov	r9, r4
 8025568:	4680      	mov	r8, r0


uint8_t Endpoint_WaitUntilReady(void)
{
	#if (USB_STREAM_TIMEOUT_MS < 0xFF)
	uint8_t  TimeoutMSRem = USB_STREAM_TIMEOUT_MS;
 802556a:	2664      	movs	r6, #100	; 0x64
	 */
	static inline uint8_t Endpoint_GetEndpointDirection(void);
	static inline uint8_t Endpoint_GetEndpointDirection(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->Address & ENDPOINT_DIR_MASK;
 802556c:	272c      	movs	r7, #44	; 0x2c
	 *  \c ENDPOINT_DIR_* mask.
	 */
	static inline uint8_t Endpoint_GetEndpointDirection(void);
	static inline uint8_t Endpoint_GetEndpointDirection(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
 802556e:	f894 313c 	ldrb.w	r3, [r4, #316]	; 0x13c
		return ep->Address & ENDPOINT_DIR_MASK;
 8025572:	fb07 4203 	mla	r2, r7, r3, r4
 8025576:	7911      	ldrb	r1, [r2, #4]

	uint16_t PreviousFrameNumber = USB_Device_GetFrameNumber();

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
 8025578:	0608      	lsls	r0, r1, #24
 802557a:	d41a      	bmi.n	80255b2 <Endpoint_WaitUntilReady+0x5a>
	 */
	static inline bool Endpoint_IsOUTReceived(void);
	static inline bool Endpoint_IsOUTReceived(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->IsOutRecieved;
 802557c:	6892      	ldr	r2, [r2, #8]
			  return ENDPOINT_READYWAIT_NoError;
			}
		}
		else
		{
			if (Endpoint_IsOUTReceived())
 802557e:	0692      	lsls	r2, r2, #26
 8025580:	d42b      	bmi.n	80255da <Endpoint_WaitUntilReady+0x82>
			{
			  return ENDPOINT_READYWAIT_NoError;
			}
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
 8025582:	782a      	ldrb	r2, [r5, #0]

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
 8025584:	f002 01ff 	and.w	r1, r2, #255	; 0xff
 8025588:	b322      	cbz	r2, 80255d4 <Endpoint_WaitUntilReady+0x7c>
		{
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		}
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
 802558a:	2905      	cmp	r1, #5
 802558c:	d01f      	beq.n	80255ce <Endpoint_WaitUntilReady+0x76>
	 */
	static inline bool Endpoint_IsStalled(void);
	static inline bool Endpoint_IsStalled(void)
	{
		bool status = false;
		if(device.Endpoints[device.CurrentEndpoint].IsHalted == 1)
 802558e:	fb07 4303 	mla	r3, r7, r3, r4
 8025592:	6898      	ldr	r0, [r3, #8]
 8025594:	f3c0 0080 	ubfx	r0, r0, #2, #1
 8025598:	b9a8      	cbnz	r0, 80255c6 <Endpoint_WaitUntilReady+0x6e>
 802559a:	f8d9 3000 	ldr.w	r3, [r9]
 802559e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80255a0:	4798      	blx	r3
		  return ENDPOINT_READYWAIT_EndpointStalled;
		}

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
 80255a2:	4580      	cmp	r8, r0
 80255a4:	d011      	beq.n	80255ca <Endpoint_WaitUntilReady+0x72>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
 80255a6:	1e73      	subs	r3, r6, #1
 80255a8:	b2db      	uxtb	r3, r3
 80255aa:	b1ce      	cbz	r6, 80255e0 <Endpoint_WaitUntilReady+0x88>
 80255ac:	4680      	mov	r8, r0
 80255ae:	461e      	mov	r6, r3
 80255b0:	e7dd      	b.n	802556e <Endpoint_WaitUntilReady+0x16>
	 */
	static inline bool Endpoint_IsINReady(void);
	static inline bool Endpoint_IsINReady(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->InInUse == 0 && ep->IsEnabled;
 80255b2:	6890      	ldr	r0, [r2, #8]
 80255b4:	f3c0 1000 	ubfx	r0, r0, #4, #1
 80255b8:	2800      	cmp	r0, #0
 80255ba:	d1e2      	bne.n	8025582 <Endpoint_WaitUntilReady+0x2a>
 80255bc:	6892      	ldr	r2, [r2, #8]
 80255be:	0791      	lsls	r1, r2, #30
 80255c0:	d5df      	bpl.n	8025582 <Endpoint_WaitUntilReady+0x2a>
			{
			  return ENDPOINT_READYWAIT_Timeout;
			}
		}
	}
}
 80255c2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80255c6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80255ca:	4633      	mov	r3, r6
 80255cc:	e7ee      	b.n	80255ac <Endpoint_WaitUntilReady+0x54>
		{
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		}
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		{
		  return ENDPOINT_READYWAIT_BusSuspended;
 80255ce:	2003      	movs	r0, #3
 80255d0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		{
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
 80255d4:	2002      	movs	r0, #2
 80255d6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			{
			  return ENDPOINT_READYWAIT_NoError;
 80255da:	2000      	movs	r0, #0
 80255dc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
			{
			  return ENDPOINT_READYWAIT_Timeout;
 80255e0:	2004      	movs	r0, #4
 80255e2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80255e6:	bf00      	nop
 80255e8:	1fffad60 	.word	0x1fffad60
 80255ec:	1fffab55 	.word	0x1fffab55

080255f0 <Endpoint_ClearOUT>:
		}
	}
}

void Endpoint_ClearOUT(void) 
{
 80255f0:	b570      	push	{r4, r5, r6, lr}
	USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
 80255f2:	4d14      	ldr	r5, [pc, #80]	; (8025644 <Endpoint_ClearOUT+0x54>)
 80255f4:	f895 313c 	ldrb.w	r3, [r5, #316]	; 0x13c
	/* if we have data left which isn't read yet, we leave this routine to
	 * not override it */
	if (ep->IsEnabled == 0)
 80255f8:	242c      	movs	r4, #44	; 0x2c
 80255fa:	fb04 5403 	mla	r4, r4, r3, r5
 80255fe:	68a3      	ldr	r3, [r4, #8]
 8025600:	079a      	lsls	r2, r3, #30
 8025602:	d400      	bmi.n	8025606 <Endpoint_ClearOUT+0x16>
 8025604:	bd70      	pop	{r4, r5, r6, pc}
	{
		return;
	}
	/* First Check whether we have data in the driver */
	ep->OutBytesAvailable = device.Driver->EndpointRead(ep->Address,ep->OutBuffer,ep->OutBufferLength);
 8025606:	682b      	ldr	r3, [r5, #0]
 8025608:	6961      	ldr	r1, [r4, #20]
 802560a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802560c:	69a2      	ldr	r2, [r4, #24]
 802560e:	7920      	ldrb	r0, [r4, #4]
 8025610:	4798      	blx	r3
	ep->OutOffset = 0;
	/* If we didn't request new data and all data has been read, request new */
	if (!ep->OutInUse && !ep->OutBytesAvailable) 
 8025612:	68a3      	ldr	r3, [r4, #8]
	if (ep->IsEnabled == 0)
	{
		return;
	}
	/* First Check whether we have data in the driver */
	ep->OutBytesAvailable = device.Driver->EndpointRead(ep->Address,ep->OutBuffer,ep->OutBufferLength);
 8025614:	60e0      	str	r0, [r4, #12]
	ep->OutOffset = 0;
 8025616:	2100      	movs	r1, #0
	/* If we didn't request new data and all data has been read, request new */
	if (!ep->OutInUse && !ep->OutBytesAvailable) 
 8025618:	071b      	lsls	r3, r3, #28
	if (ep->IsEnabled == 0)
	{
		return;
	}
	/* First Check whether we have data in the driver */
	ep->OutBytesAvailable = device.Driver->EndpointRead(ep->Address,ep->OutBuffer,ep->OutBufferLength);
 802561a:	4602      	mov	r2, r0
	ep->OutOffset = 0;
 802561c:	6121      	str	r1, [r4, #16]
	/* If we didn't request new data and all data has been read, request new */
	if (!ep->OutInUse && !ep->OutBytesAvailable) 
 802561e:	d4f1      	bmi.n	8025604 <Endpoint_ClearOUT+0x14>
 8025620:	2800      	cmp	r0, #0
 8025622:	d1ef      	bne.n	8025604 <Endpoint_ClearOUT+0x14>
	{
		ep->OutInUse = true;
 8025624:	8923      	ldrh	r3, [r4, #8]
		ep->IsOutRecieved = 0;
		device.Driver->EndpointReadStart(ep->Address,ep->OutBufferLength);
 8025626:	7920      	ldrb	r0, [r4, #4]
 8025628:	69a1      	ldr	r1, [r4, #24]
	ep->OutBytesAvailable = device.Driver->EndpointRead(ep->Address,ep->OutBuffer,ep->OutBufferLength);
	ep->OutOffset = 0;
	/* If we didn't request new data and all data has been read, request new */
	if (!ep->OutInUse && !ep->OutBytesAvailable) 
	{
		ep->OutInUse = true;
 802562a:	f043 0308 	orr.w	r3, r3, #8
 802562e:	8123      	strh	r3, [r4, #8]
		ep->IsOutRecieved = 0;
 8025630:	8923      	ldrh	r3, [r4, #8]
 8025632:	f362 1345 	bfi	r3, r2, #5, #1
 8025636:	8123      	strh	r3, [r4, #8]
		device.Driver->EndpointReadStart(ep->Address,ep->OutBufferLength);
 8025638:	682b      	ldr	r3, [r5, #0]
	}
}
 802563a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	/* If we didn't request new data and all data has been read, request new */
	if (!ep->OutInUse && !ep->OutBytesAvailable) 
	{
		ep->OutInUse = true;
		ep->IsOutRecieved = 0;
		device.Driver->EndpointReadStart(ep->Address,ep->OutBufferLength);
 802563e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8025640:	4718      	bx	r3
 8025642:	bf00      	nop
 8025644:	1fffad60 	.word	0x1fffad60

08025648 <Endpoint_ClearIN>:
	}
}

void Endpoint_ClearIN(void)
{
 8025648:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
 802564a:	4919      	ldr	r1, [pc, #100]	; (80256b0 <Endpoint_ClearIN+0x68>)
 802564c:	f891 313c 	ldrb.w	r3, [r1, #316]	; 0x13c
	int32_t data_count;
	/* don't clear if in use or not enabled */
	if (ep->InInUse == 1 || ep->IsEnabled == 0)
 8025650:	222c      	movs	r2, #44	; 0x2c
 8025652:	fb02 1303 	mla	r3, r2, r3, r1
 8025656:	689a      	ldr	r2, [r3, #8]
 8025658:	06d0      	lsls	r0, r2, #27
 802565a:	d402      	bmi.n	8025662 <Endpoint_ClearIN+0x1a>
 802565c:	689a      	ldr	r2, [r3, #8]
 802565e:	0792      	lsls	r2, r2, #30
 8025660:	d400      	bmi.n	8025664 <Endpoint_ClearIN+0x1c>
 8025662:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return;
	ep->InInUse = true;
 8025664:	8918      	ldrh	r0, [r3, #8]
	/* store transfer information to loop over, if underlying is smaller */
	ep->InDataBuffer = ep->InBuffer;
 8025666:	6a1f      	ldr	r7, [r3, #32]
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8025668:	4e12      	ldr	r6, [pc, #72]	; (80256b4 <Endpoint_ClearIN+0x6c>)
	USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
	int32_t data_count;
	/* don't clear if in use or not enabled */
	if (ep->InInUse == 1 || ep->IsEnabled == 0)
		return;
	ep->InInUse = true;
 802566a:	f040 0010 	orr.w	r0, r0, #16
	/* store transfer information to loop over, if underlying is smaller */
	ep->InDataBuffer = ep->InBuffer;
 802566e:	f103 0528 	add.w	r5, r3, #40	; 0x28
	ep->InDataLeft = ep->InBytesAvailable;
 8025672:	f103 0420 	add.w	r4, r3, #32
	USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
	int32_t data_count;
	/* don't clear if in use or not enabled */
	if (ep->InInUse == 1 || ep->IsEnabled == 0)
		return;
	ep->InInUse = true;
 8025676:	8118      	strh	r0, [r3, #8]
	/* store transfer information to loop over, if underlying is smaller */
	ep->InDataBuffer = ep->InBuffer;
	ep->InDataLeft = ep->InBytesAvailable;
 8025678:	69d8      	ldr	r0, [r3, #28]
 802567a:	60a0      	str	r0, [r4, #8]
	/* don't clear if in use or not enabled */
	if (ep->InInUse == 1 || ep->IsEnabled == 0)
		return;
	ep->InInUse = true;
	/* store transfer information to loop over, if underlying is smaller */
	ep->InDataBuffer = ep->InBuffer;
 802567c:	606f      	str	r7, [r5, #4]
	ep->InDataLeft = ep->InBytesAvailable;
	ep->InBytesAvailable = 0;
 802567e:	2000      	movs	r0, #0
 8025680:	f44f 6700 	mov.w	r7, #2048	; 0x800
 8025684:	61d8      	str	r0, [r3, #28]
 8025686:	f8c6 708c 	str.w	r7, [r6, #140]	; 0x8c
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 802568a:	f3bf 8f4f 	dsb	sy
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 802568e:	f3bf 8f6f 	isb	sy
	/* make next 3 operations atomic. Do not get interrupted.*/
	NVIC_DisableIRQ(USB0_0_IRQn);
	data_count = device.Driver->EndpointWrite(ep->Address,
 8025692:	680a      	ldr	r2, [r1, #0]
 8025694:	7918      	ldrb	r0, [r3, #4]
 8025696:	6869      	ldr	r1, [r5, #4]
 8025698:	6b13      	ldr	r3, [r2, #48]	; 0x30
 802569a:	68a2      	ldr	r2, [r4, #8]
 802569c:	4798      	blx	r3
			ep->InDataBuffer,ep->InDataLeft);
	ep->InDataBuffer += data_count;
 802569e:	686a      	ldr	r2, [r5, #4]
	ep->InDataLeft -= data_count;
 80256a0:	68a3      	ldr	r3, [r4, #8]
	ep->InBytesAvailable = 0;
	/* make next 3 operations atomic. Do not get interrupted.*/
	NVIC_DisableIRQ(USB0_0_IRQn);
	data_count = device.Driver->EndpointWrite(ep->Address,
			ep->InDataBuffer,ep->InDataLeft);
	ep->InDataBuffer += data_count;
 80256a2:	4402      	add	r2, r0
	ep->InDataLeft -= data_count;
 80256a4:	1a1b      	subs	r3, r3, r0
	ep->InBytesAvailable = 0;
	/* make next 3 operations atomic. Do not get interrupted.*/
	NVIC_DisableIRQ(USB0_0_IRQn);
	data_count = device.Driver->EndpointWrite(ep->Address,
			ep->InDataBuffer,ep->InDataLeft);
	ep->InDataBuffer += data_count;
 80256a6:	606a      	str	r2, [r5, #4]
	ep->InDataLeft -= data_count;
 80256a8:	60a3      	str	r3, [r4, #8]
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80256aa:	60f7      	str	r7, [r6, #12]
 80256ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80256ae:	bf00      	nop
 80256b0:	1fffad60 	.word	0x1fffad60
 80256b4:	e000e100 	.word	0xe000e100

080256b8 <Endpoint_IsReadWriteAllowed>:
	NVIC_EnableIRQ(USB0_0_IRQn);

}

bool Endpoint_IsReadWriteAllowed() {
	USBD_Endpoint_t *EndPoint = &device.Endpoints[device.CurrentEndpoint];
 80256b8:	4b0a      	ldr	r3, [pc, #40]	; (80256e4 <Endpoint_IsReadWriteAllowed+0x2c>)
 80256ba:	f893 213c 	ldrb.w	r2, [r3, #316]	; 0x13c
	bool Retval = false;

	if(EndPoint->Direction)
 80256be:	212c      	movs	r1, #44	; 0x2c
 80256c0:	fb01 3302 	mla	r3, r1, r2, r3
 80256c4:	791a      	ldrb	r2, [r3, #4]
 80256c6:	0612      	lsls	r2, r2, #24
 80256c8:	d404      	bmi.n	80256d4 <Endpoint_IsReadWriteAllowed+0x1c>
		Retval = (EndPoint->InBytesAvailable < EndPoint->InBufferLength)
														? true : false;
	}
	else
	{
		Retval = (EndPoint->OutBytesAvailable > 0) ? true : false;
 80256ca:	68d8      	ldr	r0, [r3, #12]
 80256cc:	3000      	adds	r0, #0
 80256ce:	bf18      	it	ne
 80256d0:	2001      	movne	r0, #1
	}
	return Retval;
}
 80256d2:	4770      	bx	lr
	USBD_Endpoint_t *EndPoint = &device.Endpoints[device.CurrentEndpoint];
	bool Retval = false;

	if(EndPoint->Direction)
	{
		Retval = (EndPoint->InBytesAvailable < EndPoint->InBufferLength)
 80256d4:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80256d6:	69da      	ldr	r2, [r3, #28]
 80256d8:	4282      	cmp	r2, r0
 80256da:	bf2c      	ite	cs
 80256dc:	2000      	movcs	r0, #0
 80256de:	2001      	movcc	r0, #1
 80256e0:	4770      	bx	lr
 80256e2:	bf00      	nop
 80256e4:	1fffad60 	.word	0x1fffad60

080256e8 <Endpoint_Write_8>:
	}
	return Retval;
}

void Endpoint_Write_8(const uint8_t Data) {
	USBD_Endpoint_t *EndPoint = &device.Endpoints[device.CurrentEndpoint];
 80256e8:	4a09      	ldr	r2, [pc, #36]	; (8025710 <Endpoint_Write_8+0x28>)
 80256ea:	f892 313c 	ldrb.w	r3, [r2, #316]	; 0x13c
 80256ee:	212c      	movs	r1, #44	; 0x2c
 80256f0:	fb01 2203 	mla	r2, r1, r3, r2
 80256f4:	f102 0318 	add.w	r3, r2, #24
 80256f8:	6a51      	ldr	r1, [r2, #36]	; 0x24
 80256fa:	685a      	ldr	r2, [r3, #4]
 80256fc:	428a      	cmp	r2, r1
 80256fe:	d300      	bcc.n	8025702 <Endpoint_Write_8+0x1a>
 8025700:	e7fe      	b.n	8025700 <Endpoint_Write_8+0x18>

	 do
	  {
	    if(EndPoint->InBytesAvailable < EndPoint->InBufferLength)
	    {
	      EndPoint->InBuffer[EndPoint->InBytesAvailable] = Data;
 8025702:	6899      	ldr	r1, [r3, #8]
 8025704:	5488      	strb	r0, [r1, r2]
	      EndPoint->InBytesAvailable++;
 8025706:	685a      	ldr	r2, [r3, #4]
 8025708:	3201      	adds	r2, #1
 802570a:	605a      	str	r2, [r3, #4]
 802570c:	4770      	bx	lr
 802570e:	bf00      	nop
 8025710:	1fffad60 	.word	0x1fffad60

08025714 <Endpoint_Read_8>:
	    }
	  }while(!Success);
}

uint8_t Endpoint_Read_8() {
	USBD_Endpoint_t *EndPoint = &device.Endpoints[device.CurrentEndpoint];
 8025714:	4b09      	ldr	r3, [pc, #36]	; (802573c <Endpoint_Read_8+0x28>)
 8025716:	f893 213c 	ldrb.w	r2, [r3, #316]	; 0x13c
 802571a:	212c      	movs	r1, #44	; 0x2c
 802571c:	fb01 3302 	mla	r3, r1, r2, r3
 8025720:	f103 0208 	add.w	r2, r3, #8
 8025724:	6851      	ldr	r1, [r2, #4]
 8025726:	b901      	cbnz	r1, 802572a <Endpoint_Read_8+0x16>
 8025728:	e7fe      	b.n	8025728 <Endpoint_Read_8+0x14>

	 do
	  {
		if(EndPoint->OutBytesAvailable > 0)
		{
		  data = EndPoint->OutBuffer[EndPoint->OutOffset];
 802572a:	6958      	ldr	r0, [r3, #20]
 802572c:	6893      	ldr	r3, [r2, #8]
		  EndPoint->OutOffset++;
		  EndPoint->OutBytesAvailable--;
 802572e:	3901      	subs	r1, #1

	 do
	  {
		if(EndPoint->OutBytesAvailable > 0)
		{
		  data = EndPoint->OutBuffer[EndPoint->OutOffset];
 8025730:	5cc0      	ldrb	r0, [r0, r3]
		  EndPoint->OutOffset++;
		  EndPoint->OutBytesAvailable--;
 8025732:	6051      	str	r1, [r2, #4]
	 do
	  {
		if(EndPoint->OutBytesAvailable > 0)
		{
		  data = EndPoint->OutBuffer[EndPoint->OutOffset];
		  EndPoint->OutOffset++;
 8025734:	3301      	adds	r3, #1
 8025736:	6093      	str	r3, [r2, #8]

		  Success = true;
		}
	  }while(!Success);
	 return data;
}
 8025738:	4770      	bx	lr
 802573a:	bf00      	nop
 802573c:	1fffad60 	.word	0x1fffad60

08025740 <Endpoint_Write_32_LE>:

void Endpoint_Write_32_LE(const uint32_t Data) {
	USBD_Endpoint_t *EndPoint = &device.Endpoints[device.CurrentEndpoint];
 8025740:	4a09      	ldr	r2, [pc, #36]	; (8025768 <Endpoint_Write_32_LE+0x28>)
 8025742:	f892 313c 	ldrb.w	r3, [r2, #316]	; 0x13c
 8025746:	212c      	movs	r1, #44	; 0x2c
 8025748:	fb01 2203 	mla	r2, r1, r3, r2
 802574c:	f102 0318 	add.w	r3, r2, #24
 8025750:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8025752:	6859      	ldr	r1, [r3, #4]
 8025754:	3a03      	subs	r2, #3
 8025756:	4291      	cmp	r1, r2
 8025758:	d300      	bcc.n	802575c <Endpoint_Write_32_LE+0x1c>
 802575a:	e7fe      	b.n	802575a <Endpoint_Write_32_LE+0x1a>
	bool Success = false;

	do {
		if(EndPoint->InBytesAvailable < (EndPoint->InBufferLength - 3)) {
			*(uint32_t*)(EndPoint->InBuffer + EndPoint->InBytesAvailable) =
 802575c:	689a      	ldr	r2, [r3, #8]
 802575e:	5050      	str	r0, [r2, r1]
																		Data;
			EndPoint->InBytesAvailable+=4;
 8025760:	685a      	ldr	r2, [r3, #4]
 8025762:	3204      	adds	r2, #4
 8025764:	605a      	str	r2, [r3, #4]
 8025766:	4770      	bx	lr
 8025768:	1fffad60 	.word	0x1fffad60

0802576c <Endpoint_Read_32_LE>:
		}
	}while(!Success);
}

uint32_t Endpoint_Read_32_LE() {
	USBD_Endpoint_t *EndPoint = &device.Endpoints[device.CurrentEndpoint];
 802576c:	4b09      	ldr	r3, [pc, #36]	; (8025794 <Endpoint_Read_32_LE+0x28>)
 802576e:	f893 213c 	ldrb.w	r2, [r3, #316]	; 0x13c
 8025772:	212c      	movs	r1, #44	; 0x2c
 8025774:	fb01 3302 	mla	r3, r1, r2, r3
 8025778:	f103 0208 	add.w	r2, r3, #8
 802577c:	6851      	ldr	r1, [r2, #4]
 802577e:	2903      	cmp	r1, #3
 8025780:	d800      	bhi.n	8025784 <Endpoint_Read_32_LE+0x18>
 8025782:	e7fe      	b.n	8025782 <Endpoint_Read_32_LE+0x16>
	bool Success = false;
	uint32_t data = 0;

	do {
		if(EndPoint->OutBytesAvailable > 3) {
			data = *(uint32_t*)(EndPoint->OutBuffer + EndPoint->OutOffset);
 8025784:	6958      	ldr	r0, [r3, #20]
 8025786:	6893      	ldr	r3, [r2, #8]
			EndPoint->OutOffset+=4;
			EndPoint->OutBytesAvailable-=4;
 8025788:	3904      	subs	r1, #4
	bool Success = false;
	uint32_t data = 0;

	do {
		if(EndPoint->OutBytesAvailable > 3) {
			data = *(uint32_t*)(EndPoint->OutBuffer + EndPoint->OutOffset);
 802578a:	58c0      	ldr	r0, [r0, r3]
			EndPoint->OutOffset+=4;
			EndPoint->OutBytesAvailable-=4;
 802578c:	6051      	str	r1, [r2, #4]
	uint32_t data = 0;

	do {
		if(EndPoint->OutBytesAvailable > 3) {
			data = *(uint32_t*)(EndPoint->OutBuffer + EndPoint->OutOffset);
			EndPoint->OutOffset+=4;
 802578e:	3304      	adds	r3, #4
 8025790:	6093      	str	r3, [r2, #8]

			Success = true;
		}
	} while(!Success);
	return data;
}
 8025792:	4770      	bx	lr
 8025794:	1fffad60 	.word	0x1fffad60

08025798 <Endpoint_ConfigureEndpointTable>:

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
			                                     const uint8_t Entries) {
	uint8_t i;
	uint8_t Number;
	for (i=0;i<Entries;i++) {
 8025798:	2900      	cmp	r1, #0
 802579a:	d042      	beq.n	8025822 <Endpoint_ConfigureEndpointTable+0x8a>
	} while(!Success);
	return data;
}

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
			                                     const uint8_t Entries) {
 802579c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80257a0:	1e4d      	subs	r5, r1, #1
 80257a2:	b2e9      	uxtb	r1, r5
 80257a4:	4f20      	ldr	r7, [pc, #128]	; (8025828 <Endpoint_ConfigureEndpointTable+0x90>)
 80257a6:	2506      	movs	r5, #6
 80257a8:	fb05 0501 	mla	r5, r5, r1, r0
 80257ac:	350a      	adds	r5, #10
 80257ae:	f100 0904 	add.w	r9, r0, #4
	uint8_t i;
	uint8_t Number;
	for (i=0;i<Entries;i++) {
		Number = Table[i].Address & ENDPOINT_EPNUM_MASK;
		/* Configure endpoint in device controller driver */
		if (device.Driver->EndpointConfigure(Table[i].Address,
 80257b2:	463e      	mov	r6, r7
				(XMC_USBD_ENDPOINT_TYPE_t)Table[i].Type,Table[i].Size) !=
																XMC_USBD_STATUS_OK)
			return false;
		/* Set device core values */
		device.Endpoints[Number].Address = Table[i].Address;
 80257b4:	f04f 082c 	mov.w	r8, #44	; 0x2c
 80257b8:	e01c      	b.n	80257f4 <Endpoint_ConfigureEndpointTable+0x5c>
 80257ba:	f819 2c04 	ldrb.w	r2, [r9, #-4]
 80257be:	711a      	strb	r2, [r3, #4]
		device.Endpoints[Number].MaxPacketSize = Table[i].Size;
 80257c0:	f839 2c02 	ldrh.w	r2, [r9, #-2]
 80257c4:	8919      	ldrh	r1, [r3, #8]
 80257c6:	f362 118c 	bfi	r1, r2, #6, #7
		device.Endpoints[Number].IsConfigured = 1;
 80257ca:	b2ca      	uxtb	r2, r1
 80257cc:	f042 0201 	orr.w	r2, r2, #1
				(XMC_USBD_ENDPOINT_TYPE_t)Table[i].Type,Table[i].Size) !=
																XMC_USBD_STATUS_OK)
			return false;
		/* Set device core values */
		device.Endpoints[Number].Address = Table[i].Address;
		device.Endpoints[Number].MaxPacketSize = Table[i].Size;
 80257d0:	8119      	strh	r1, [r3, #8]
		device.Endpoints[Number].IsConfigured = 1;
 80257d2:	721a      	strb	r2, [r3, #8]
		device.Endpoints[Number].IsEnabled = 1;
 80257d4:	891a      	ldrh	r2, [r3, #8]
 80257d6:	f042 0202 	orr.w	r2, r2, #2
 80257da:	811a      	strh	r2, [r3, #8]
		/* Start read for out endpoints */
		if (!(Table[i].Address & ENDPOINT_DIR_MASK))
 80257dc:	f819 0c04 	ldrb.w	r0, [r9, #-4]
 80257e0:	0602      	lsls	r2, r0, #24
 80257e2:	f109 0906 	add.w	r9, r9, #6
 80257e6:	d403      	bmi.n	80257f0 <Endpoint_ConfigureEndpointTable+0x58>
			device.Driver->EndpointReadStart(Table[i].Address,
 80257e8:	6832      	ldr	r2, [r6, #0]
 80257ea:	6999      	ldr	r1, [r3, #24]
 80257ec:	6a93      	ldr	r3, [r2, #40]	; 0x28
 80257ee:	4798      	blx	r3

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
			                                     const uint8_t Entries) {
	uint8_t i;
	uint8_t Number;
	for (i=0;i<Entries;i++) {
 80257f0:	45a9      	cmp	r9, r5
 80257f2:	d013      	beq.n	802581c <Endpoint_ConfigureEndpointTable+0x84>
		Number = Table[i].Address & ENDPOINT_EPNUM_MASK;
 80257f4:	f819 3c04 	ldrb.w	r3, [r9, #-4]
		/* Configure endpoint in device controller driver */
		if (device.Driver->EndpointConfigure(Table[i].Address,
 80257f8:	683a      	ldr	r2, [r7, #0]
 80257fa:	f899 1000 	ldrb.w	r1, [r9]
 80257fe:	f8d2 c01c 	ldr.w	ip, [r2, #28]
 8025802:	f839 2c02 	ldrh.w	r2, [r9, #-2]
 8025806:	4618      	mov	r0, r3
bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
			                                     const uint8_t Entries) {
	uint8_t i;
	uint8_t Number;
	for (i=0;i<Entries;i++) {
		Number = Table[i].Address & ENDPOINT_EPNUM_MASK;
 8025808:	f003 040f 	and.w	r4, r3, #15
		/* Configure endpoint in device controller driver */
		if (device.Driver->EndpointConfigure(Table[i].Address,
 802580c:	47e0      	blx	ip
				(XMC_USBD_ENDPOINT_TYPE_t)Table[i].Type,Table[i].Size) !=
																XMC_USBD_STATUS_OK)
			return false;
		/* Set device core values */
		device.Endpoints[Number].Address = Table[i].Address;
 802580e:	fb08 6304 	mla	r3, r8, r4, r6
	uint8_t i;
	uint8_t Number;
	for (i=0;i<Entries;i++) {
		Number = Table[i].Address & ENDPOINT_EPNUM_MASK;
		/* Configure endpoint in device controller driver */
		if (device.Driver->EndpointConfigure(Table[i].Address,
 8025812:	2800      	cmp	r0, #0
 8025814:	d0d1      	beq.n	80257ba <Endpoint_ConfigureEndpointTable+0x22>
				(XMC_USBD_ENDPOINT_TYPE_t)Table[i].Type,Table[i].Size) !=
																XMC_USBD_STATUS_OK)
			return false;
 8025816:	2000      	movs	r0, #0
		if (!(Table[i].Address & ENDPOINT_DIR_MASK))
			device.Driver->EndpointReadStart(Table[i].Address,
					device.Endpoints[Number].OutBufferLength);
	}
	return true;
}
 8025818:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		/* Start read for out endpoints */
		if (!(Table[i].Address & ENDPOINT_DIR_MASK))
			device.Driver->EndpointReadStart(Table[i].Address,
					device.Endpoints[Number].OutBufferLength);
	}
	return true;
 802581c:	2001      	movs	r0, #1
 802581e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8025822:	2001      	movs	r0, #1
}
 8025824:	4770      	bx	lr
 8025826:	bf00      	nop
 8025828:	1fffad60 	.word	0x1fffad60

0802582c <USBD_SignalDeviceEventHandler>:
 */
static void USBD_SignalDeviceEventHandler(XMC_USBD_EVENT_t event)
{
  uint32_t i;

  switch (event)
 802582c:	2809      	cmp	r0, #9
 802582e:	d80e      	bhi.n	802584e <USBD_SignalDeviceEventHandler+0x22>
 8025830:	e8df f010 	tbh	[pc, r0, lsl #1]
 8025834:	0019000a 	.word	0x0019000a
 8025838:	002a0023 	.word	0x002a0023
 802583c:	000d0034 	.word	0x000d0034
 8025840:	000e00e8 	.word	0x000e00e8
 8025844:	00f6000d 	.word	0x00f6000d
      {
        device.events->disconnect();
      }
      break;
    case XMC_USBD_EVENT_POWER_ON:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Powered;
 8025848:	4bb7      	ldr	r3, [pc, #732]	; (8025b28 <USBD_SignalDeviceEventHandler+0x2fc>)
 802584a:	2201      	movs	r2, #1
 802584c:	701a      	strb	r2, [r3, #0]
 802584e:	4770      	bx	lr
      break;
    case XMC_USBD_EVENT_REMOTE_WAKEUP:
      break;
    case XMC_USBD_EVENT_RESUME:
      USB_DeviceState = (uint8_t)device.pre_suspend_device_state;
 8025850:	4bb6      	ldr	r3, [pc, #728]	; (8025b2c <USBD_SignalDeviceEventHandler+0x300>)
 8025852:	4ab5      	ldr	r2, [pc, #724]	; (8025b28 <USBD_SignalDeviceEventHandler+0x2fc>)
      if (NULL != device.events->wakeup)
 8025854:	f8d3 0140 	ldr.w	r0, [r3, #320]	; 0x140
      USB_DeviceState = (uint8_t)DEVICE_STATE_Powered;
      break;
    case XMC_USBD_EVENT_REMOTE_WAKEUP:
      break;
    case XMC_USBD_EVENT_RESUME:
      USB_DeviceState = (uint8_t)device.pre_suspend_device_state;
 8025858:	f893 113a 	ldrb.w	r1, [r3, #314]	; 0x13a
      if (NULL != device.events->wakeup)
 802585c:	6983      	ldr	r3, [r0, #24]
      USB_DeviceState = (uint8_t)DEVICE_STATE_Powered;
      break;
    case XMC_USBD_EVENT_REMOTE_WAKEUP:
      break;
    case XMC_USBD_EVENT_RESUME:
      USB_DeviceState = (uint8_t)device.pre_suspend_device_state;
 802585e:	7011      	strb	r1, [r2, #0]
      if (NULL != device.events->wakeup)
 8025860:	2b00      	cmp	r3, #0
 8025862:	d0f4      	beq.n	802584e <USBD_SignalDeviceEventHandler+0x22>
      {
        device.events->wakeup();
 8025864:	4718      	bx	r3
        device.events->disconnect();
      }
      break;
    case XMC_USBD_EVENT_POWER_OFF:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
      if (NULL != device.events->disconnect)
 8025866:	4bb1      	ldr	r3, [pc, #708]	; (8025b2c <USBD_SignalDeviceEventHandler+0x300>)
      {
        device.events->disconnect();
      }
      break;
    case XMC_USBD_EVENT_POWER_OFF:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
 8025868:	4aaf      	ldr	r2, [pc, #700]	; (8025b28 <USBD_SignalDeviceEventHandler+0x2fc>)
      if (NULL != device.events->disconnect)
 802586a:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 802586e:	685b      	ldr	r3, [r3, #4]
      {
        device.events->disconnect();
      }
      break;
    case XMC_USBD_EVENT_POWER_OFF:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
 8025870:	2100      	movs	r1, #0
 8025872:	7011      	strb	r1, [r2, #0]
      if (NULL != device.events->disconnect)
 8025874:	2b00      	cmp	r3, #0
 8025876:	d1f5      	bne.n	8025864 <USBD_SignalDeviceEventHandler+0x38>
 8025878:	e7e9      	b.n	802584e <USBD_SignalDeviceEventHandler+0x22>
      {
        device.events->start_of_frame();
      }
      break;
    case XMC_USBD_EVENT_CONNECT:
      if (NULL != device.events->connect)
 802587a:	4bac      	ldr	r3, [pc, #688]	; (8025b2c <USBD_SignalDeviceEventHandler+0x300>)
 802587c:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 8025880:	681b      	ldr	r3, [r3, #0]
 8025882:	2b00      	cmp	r3, #0
 8025884:	d1ee      	bne.n	8025864 <USBD_SignalDeviceEventHandler+0x38>
 8025886:	e7e2      	b.n	802584e <USBD_SignalDeviceEventHandler+0x22>
        device.events->connect();
      }
      break;
    case XMC_USBD_EVENT_DISCONNECT:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Powered;
      if (NULL != device.events->disconnect)
 8025888:	4ba8      	ldr	r3, [pc, #672]	; (8025b2c <USBD_SignalDeviceEventHandler+0x300>)
      {
        device.events->connect();
      }
      break;
    case XMC_USBD_EVENT_DISCONNECT:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Powered;
 802588a:	4aa7      	ldr	r2, [pc, #668]	; (8025b28 <USBD_SignalDeviceEventHandler+0x2fc>)
      if (NULL != device.events->disconnect)
 802588c:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 8025890:	685b      	ldr	r3, [r3, #4]
      {
        device.events->connect();
      }
      break;
    case XMC_USBD_EVENT_DISCONNECT:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Powered;
 8025892:	2101      	movs	r1, #1
 8025894:	7011      	strb	r1, [r2, #0]
      if (NULL != device.events->disconnect)
 8025896:	2b00      	cmp	r3, #0
 8025898:	d1e4      	bne.n	8025864 <USBD_SignalDeviceEventHandler+0x38>
 802589a:	e7d8      	b.n	802584e <USBD_SignalDeviceEventHandler+0x22>
 * The device can have several events, by which it notifies the application about the occurance of event.
 * Not all events are available on all chip series. (Power Events are only supported on XMC4500)
 *
 */
static void USBD_SignalDeviceEventHandler(XMC_USBD_EVENT_t event)
{
 802589c:	b570      	push	{r4, r5, r6, lr}
  uint32_t i;

  switch (event)
  {
    case XMC_USBD_EVENT_RESET:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
 802589e:	4ba2      	ldr	r3, [pc, #648]	; (8025b28 <USBD_SignalDeviceEventHandler+0x2fc>)
      device.ep0_state = USBD_EP0_STATE_IDLE;
 80258a0:	4ca2      	ldr	r4, [pc, #648]	; (8025b2c <USBD_SignalDeviceEventHandler+0x300>)
  uint32_t i;

  switch (event)
  {
    case XMC_USBD_EVENT_RESET:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
 80258a2:	2202      	movs	r2, #2
 80258a4:	701a      	strb	r2, [r3, #0]
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 80258a6:	8922      	ldrh	r2, [r4, #8]
  switch (event)
  {
    case XMC_USBD_EVENT_RESET:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
 80258a8:	f894 313e 	ldrb.w	r3, [r4, #318]	; 0x13e
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 80258ac:	f36f 1204 	bfc	r2, #4, #1
 80258b0:	8122      	strh	r2, [r4, #8]
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
 80258b2:	8922      	ldrh	r2, [r4, #8]
 80258b4:	f36f 02c3 	bfc	r2, #3, #1
 80258b8:	8122      	strh	r2, [r4, #8]
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
 80258ba:	8922      	ldrh	r2, [r4, #8]
 80258bc:	f36f 0282 	bfc	r2, #2, #1
 80258c0:	8122      	strh	r2, [r4, #8]
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 80258c2:	8ea2      	ldrh	r2, [r4, #52]	; 0x34
 80258c4:	f36f 1204 	bfc	r2, #4, #1
 80258c8:	86a2      	strh	r2, [r4, #52]	; 0x34
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
 80258ca:	8ea2      	ldrh	r2, [r4, #52]	; 0x34
 80258cc:	f36f 02c3 	bfc	r2, #3, #1
 80258d0:	86a2      	strh	r2, [r4, #52]	; 0x34
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
 80258d2:	8ea2      	ldrh	r2, [r4, #52]	; 0x34
 80258d4:	f36f 0282 	bfc	r2, #2, #1
 80258d8:	86a2      	strh	r2, [r4, #52]	; 0x34
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
 80258da:	f894 2034 	ldrb.w	r2, [r4, #52]	; 0x34
  switch (event)
  {
    case XMC_USBD_EVENT_RESET:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
 80258de:	f36f 0382 	bfc	r3, #2, #1

  switch (event)
  {
    case XMC_USBD_EVENT_RESET:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
      device.ep0_state = USBD_EP0_STATE_IDLE;
 80258e2:	2101      	movs	r1, #1
      device.remote_wakeup = (uint8_t)0;
 80258e4:	f884 313e 	strb.w	r3, [r4, #318]	; 0x13e
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
 80258e8:	07d3      	lsls	r3, r2, #31

  switch (event)
  {
    case XMC_USBD_EVENT_RESET:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
      device.ep0_state = USBD_EP0_STATE_IDLE;
 80258ea:	f884 113b 	strb.w	r1, [r4, #315]	; 0x13b
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
 80258ee:	f100 809f 	bmi.w	8025a30 <USBD_SignalDeviceEventHandler+0x204>
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 80258f2:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
 80258f6:	4d8d      	ldr	r5, [pc, #564]	; (8025b2c <USBD_SignalDeviceEventHandler+0x300>)
 80258f8:	f36f 1304 	bfc	r3, #4, #1
 80258fc:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
 8025900:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
 8025904:	f36f 03c3 	bfc	r3, #3, #1
 8025908:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
 802590c:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
 8025910:	f36f 0382 	bfc	r3, #2, #1
 8025914:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
 8025918:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
 802591c:	07de      	lsls	r6, r3, #31
 802591e:	f100 80ec 	bmi.w	8025afa <USBD_SignalDeviceEventHandler+0x2ce>
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 8025922:	f8b4 308c 	ldrh.w	r3, [r4, #140]	; 0x8c
 8025926:	4d81      	ldr	r5, [pc, #516]	; (8025b2c <USBD_SignalDeviceEventHandler+0x300>)
 8025928:	f36f 1304 	bfc	r3, #4, #1
 802592c:	f8a4 308c 	strh.w	r3, [r4, #140]	; 0x8c
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
 8025930:	f8b4 308c 	ldrh.w	r3, [r4, #140]	; 0x8c
 8025934:	f36f 03c3 	bfc	r3, #3, #1
 8025938:	f8a4 308c 	strh.w	r3, [r4, #140]	; 0x8c
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
 802593c:	f8b4 308c 	ldrh.w	r3, [r4, #140]	; 0x8c
 8025940:	f36f 0382 	bfc	r3, #2, #1
 8025944:	f8a4 308c 	strh.w	r3, [r4, #140]	; 0x8c
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
 8025948:	f894 308c 	ldrb.w	r3, [r4, #140]	; 0x8c
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
 802594c:	07d8      	lsls	r0, r3, #31
 802594e:	f100 80bf 	bmi.w	8025ad0 <USBD_SignalDeviceEventHandler+0x2a4>
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 8025952:	f8b4 30b8 	ldrh.w	r3, [r4, #184]	; 0xb8
 8025956:	4d75      	ldr	r5, [pc, #468]	; (8025b2c <USBD_SignalDeviceEventHandler+0x300>)
 8025958:	f36f 1304 	bfc	r3, #4, #1
 802595c:	f8a4 30b8 	strh.w	r3, [r4, #184]	; 0xb8
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
 8025960:	f8b4 30b8 	ldrh.w	r3, [r4, #184]	; 0xb8
 8025964:	f36f 03c3 	bfc	r3, #3, #1
 8025968:	f8a4 30b8 	strh.w	r3, [r4, #184]	; 0xb8
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
 802596c:	f8b4 30b8 	ldrh.w	r3, [r4, #184]	; 0xb8
 8025970:	f36f 0382 	bfc	r3, #2, #1
 8025974:	f8a4 30b8 	strh.w	r3, [r4, #184]	; 0xb8
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
 8025978:	f894 30b8 	ldrb.w	r3, [r4, #184]	; 0xb8
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
 802597c:	07d9      	lsls	r1, r3, #31
 802597e:	f100 8092 	bmi.w	8025aa6 <USBD_SignalDeviceEventHandler+0x27a>
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 8025982:	f8b4 30e4 	ldrh.w	r3, [r4, #228]	; 0xe4
 8025986:	4d69      	ldr	r5, [pc, #420]	; (8025b2c <USBD_SignalDeviceEventHandler+0x300>)
 8025988:	f36f 1304 	bfc	r3, #4, #1
 802598c:	f8a4 30e4 	strh.w	r3, [r4, #228]	; 0xe4
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
 8025990:	f8b4 30e4 	ldrh.w	r3, [r4, #228]	; 0xe4
 8025994:	f36f 03c3 	bfc	r3, #3, #1
 8025998:	f8a4 30e4 	strh.w	r3, [r4, #228]	; 0xe4
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
 802599c:	f8b4 30e4 	ldrh.w	r3, [r4, #228]	; 0xe4
 80259a0:	f36f 0382 	bfc	r3, #2, #1
 80259a4:	f8a4 30e4 	strh.w	r3, [r4, #228]	; 0xe4
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
 80259a8:	f894 30e4 	ldrb.w	r3, [r4, #228]	; 0xe4
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
 80259ac:	07da      	lsls	r2, r3, #31
 80259ae:	d466      	bmi.n	8025a7e <USBD_SignalDeviceEventHandler+0x252>
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 80259b0:	f8b4 3110 	ldrh.w	r3, [r4, #272]	; 0x110
 80259b4:	4d5d      	ldr	r5, [pc, #372]	; (8025b2c <USBD_SignalDeviceEventHandler+0x300>)
 80259b6:	f36f 1304 	bfc	r3, #4, #1
 80259ba:	f8a4 3110 	strh.w	r3, [r4, #272]	; 0x110
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
 80259be:	f8b4 3110 	ldrh.w	r3, [r4, #272]	; 0x110
 80259c2:	f36f 03c3 	bfc	r3, #3, #1
 80259c6:	f8a4 3110 	strh.w	r3, [r4, #272]	; 0x110
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
 80259ca:	f8b4 3110 	ldrh.w	r3, [r4, #272]	; 0x110
 80259ce:	f36f 0382 	bfc	r3, #2, #1
 80259d2:	f8a4 3110 	strh.w	r3, [r4, #272]	; 0x110
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
 80259d6:	f894 3110 	ldrb.w	r3, [r4, #272]	; 0x110
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
 80259da:	07db      	lsls	r3, r3, #31
 80259dc:	d43b      	bmi.n	8025a56 <USBD_SignalDeviceEventHandler+0x22a>
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
          }
        }
      }
      device.configuration = (uint8_t)0;
 80259de:	2300      	movs	r3, #0
      for (i = ((uint32_t)NUM_INTERFACES); i > 0U; i--)
      {
        device.interface_settings[((uint32_t)NUM_INTERFACES - i)] = (uint8_t)0;
      }
      device.Driver->EndpointReadStart((uint8_t)device.Endpoints[0].Address,(uint32_t)USBD_EP0_3SETUP_PKT_SIZE);
 80259e0:	6822      	ldr	r2, [r4, #0]
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
          }
        }
      }
      device.configuration = (uint8_t)0;
 80259e2:	f884 3139 	strb.w	r3, [r4, #313]	; 0x139
      for (i = ((uint32_t)NUM_INTERFACES); i > 0U; i--)
      {
        device.interface_settings[((uint32_t)NUM_INTERFACES - i)] = (uint8_t)0;
 80259e6:	f884 3138 	strb.w	r3, [r4, #312]	; 0x138
      }
      device.Driver->EndpointReadStart((uint8_t)device.Endpoints[0].Address,(uint32_t)USBD_EP0_3SETUP_PKT_SIZE);
 80259ea:	6a93      	ldr	r3, [r2, #40]	; 0x28
 80259ec:	7920      	ldrb	r0, [r4, #4]
 80259ee:	2118      	movs	r1, #24
 80259f0:	4798      	blx	r3
      if (NULL != device.events->reset)
 80259f2:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
 80259f6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80259f8:	2b00      	cmp	r3, #0
 80259fa:	f000 8093 	beq.w	8025b24 <USBD_SignalDeviceEventHandler+0x2f8>
      }
      break;
    default:
      break;
  }
}
 80259fe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        device.interface_settings[((uint32_t)NUM_INTERFACES - i)] = (uint8_t)0;
      }
      device.Driver->EndpointReadStart((uint8_t)device.Endpoints[0].Address,(uint32_t)USBD_EP0_3SETUP_PKT_SIZE);
      if (NULL != device.events->reset)
      {
        device.events->reset();
 8025a02:	4718      	bx	r3
      {
        device.events->wakeup();
      }
      break;
    case XMC_USBD_EVENT_SUSPEND:
      device.pre_suspend_device_state = USB_DeviceState;
 8025a04:	4a49      	ldr	r2, [pc, #292]	; (8025b2c <USBD_SignalDeviceEventHandler+0x300>)
 8025a06:	4b48      	ldr	r3, [pc, #288]	; (8025b28 <USBD_SignalDeviceEventHandler+0x2fc>)
      USB_DeviceState = (uint8_t)DEVICE_STATE_Suspended;
      if (NULL != device.events->suspend)
 8025a08:	f8d2 1140 	ldr.w	r1, [r2, #320]	; 0x140
      {
        device.events->wakeup();
      }
      break;
    case XMC_USBD_EVENT_SUSPEND:
      device.pre_suspend_device_state = USB_DeviceState;
 8025a0c:	7818      	ldrb	r0, [r3, #0]
 8025a0e:	f882 013a 	strb.w	r0, [r2, #314]	; 0x13a
      USB_DeviceState = (uint8_t)DEVICE_STATE_Suspended;
      if (NULL != device.events->suspend)
 8025a12:	69ca      	ldr	r2, [r1, #28]
        device.events->wakeup();
      }
      break;
    case XMC_USBD_EVENT_SUSPEND:
      device.pre_suspend_device_state = USB_DeviceState;
      USB_DeviceState = (uint8_t)DEVICE_STATE_Suspended;
 8025a14:	2105      	movs	r1, #5
 8025a16:	7019      	strb	r1, [r3, #0]
      if (NULL != device.events->suspend)
 8025a18:	2a00      	cmp	r2, #0
 8025a1a:	f43f af18 	beq.w	802584e <USBD_SignalDeviceEventHandler+0x22>
      {
        device.events->suspend();
 8025a1e:	4710      	bx	r2
      {
        device.events->reset();
      }
      break;
    case XMC_USBD_EVENT_SOF:
      if (NULL != device.events->start_of_frame)
 8025a20:	4b42      	ldr	r3, [pc, #264]	; (8025b2c <USBD_SignalDeviceEventHandler+0x300>)
 8025a22:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 8025a26:	6a1b      	ldr	r3, [r3, #32]
 8025a28:	2b00      	cmp	r3, #0
 8025a2a:	f47f af1b 	bne.w	8025864 <USBD_SignalDeviceEventHandler+0x38>
 8025a2e:	e70e      	b.n	802584e <USBD_SignalDeviceEventHandler+0x22>
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
 8025a30:	6823      	ldr	r3, [r4, #0]
 8025a32:	f894 0030 	ldrb.w	r0, [r4, #48]	; 0x30
 8025a36:	6a1b      	ldr	r3, [r3, #32]
 8025a38:	4798      	blx	r3
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
 8025a3a:	2800      	cmp	r0, #0
 8025a3c:	f47f af59 	bne.w	80258f2 <USBD_SignalDeviceEventHandler+0xc6>
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
          ((uint8_t)device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].Address))
          {
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
 8025a40:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 8025a44:	f360 0300 	bfi	r3, r0, #0, #1
 8025a48:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
 8025a4c:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
 8025a4e:	f360 0341 	bfi	r3, r0, #1, #1
 8025a52:	86a3      	strh	r3, [r4, #52]	; 0x34
 8025a54:	e74d      	b.n	80258f2 <USBD_SignalDeviceEventHandler+0xc6>
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
 8025a56:	682b      	ldr	r3, [r5, #0]
 8025a58:	f895 010c 	ldrb.w	r0, [r5, #268]	; 0x10c
 8025a5c:	6a1b      	ldr	r3, [r3, #32]
 8025a5e:	4798      	blx	r3
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
 8025a60:	2800      	cmp	r0, #0
 8025a62:	d1bc      	bne.n	80259de <USBD_SignalDeviceEventHandler+0x1b2>
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
          ((uint8_t)device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].Address))
          {
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
 8025a64:	f895 3110 	ldrb.w	r3, [r5, #272]	; 0x110
 8025a68:	f360 0300 	bfi	r3, r0, #0, #1
 8025a6c:	f885 3110 	strb.w	r3, [r5, #272]	; 0x110
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
 8025a70:	f8b5 3110 	ldrh.w	r3, [r5, #272]	; 0x110
 8025a74:	f360 0341 	bfi	r3, r0, #1, #1
 8025a78:	f8a5 3110 	strh.w	r3, [r5, #272]	; 0x110
 8025a7c:	e7af      	b.n	80259de <USBD_SignalDeviceEventHandler+0x1b2>
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
 8025a7e:	682b      	ldr	r3, [r5, #0]
 8025a80:	f895 00e0 	ldrb.w	r0, [r5, #224]	; 0xe0
 8025a84:	6a1b      	ldr	r3, [r3, #32]
 8025a86:	4798      	blx	r3
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
 8025a88:	2800      	cmp	r0, #0
 8025a8a:	d191      	bne.n	80259b0 <USBD_SignalDeviceEventHandler+0x184>
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
          ((uint8_t)device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].Address))
          {
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
 8025a8c:	f895 30e4 	ldrb.w	r3, [r5, #228]	; 0xe4
 8025a90:	f360 0300 	bfi	r3, r0, #0, #1
 8025a94:	f885 30e4 	strb.w	r3, [r5, #228]	; 0xe4
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
 8025a98:	f8b5 30e4 	ldrh.w	r3, [r5, #228]	; 0xe4
 8025a9c:	f360 0341 	bfi	r3, r0, #1, #1
 8025aa0:	f8a5 30e4 	strh.w	r3, [r5, #228]	; 0xe4
 8025aa4:	e784      	b.n	80259b0 <USBD_SignalDeviceEventHandler+0x184>
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
 8025aa6:	682b      	ldr	r3, [r5, #0]
 8025aa8:	f895 00b4 	ldrb.w	r0, [r5, #180]	; 0xb4
 8025aac:	6a1b      	ldr	r3, [r3, #32]
 8025aae:	4798      	blx	r3
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
 8025ab0:	2800      	cmp	r0, #0
 8025ab2:	f47f af66 	bne.w	8025982 <USBD_SignalDeviceEventHandler+0x156>
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
          ((uint8_t)device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].Address))
          {
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
 8025ab6:	f895 30b8 	ldrb.w	r3, [r5, #184]	; 0xb8
 8025aba:	f360 0300 	bfi	r3, r0, #0, #1
 8025abe:	f885 30b8 	strb.w	r3, [r5, #184]	; 0xb8
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
 8025ac2:	f8b5 30b8 	ldrh.w	r3, [r5, #184]	; 0xb8
 8025ac6:	f360 0341 	bfi	r3, r0, #1, #1
 8025aca:	f8a5 30b8 	strh.w	r3, [r5, #184]	; 0xb8
 8025ace:	e758      	b.n	8025982 <USBD_SignalDeviceEventHandler+0x156>
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
 8025ad0:	682b      	ldr	r3, [r5, #0]
 8025ad2:	f895 0088 	ldrb.w	r0, [r5, #136]	; 0x88
 8025ad6:	6a1b      	ldr	r3, [r3, #32]
 8025ad8:	4798      	blx	r3
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
 8025ada:	2800      	cmp	r0, #0
 8025adc:	f47f af39 	bne.w	8025952 <USBD_SignalDeviceEventHandler+0x126>
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
          ((uint8_t)device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].Address))
          {
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
 8025ae0:	f895 308c 	ldrb.w	r3, [r5, #140]	; 0x8c
 8025ae4:	f360 0300 	bfi	r3, r0, #0, #1
 8025ae8:	f885 308c 	strb.w	r3, [r5, #140]	; 0x8c
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
 8025aec:	f8b5 308c 	ldrh.w	r3, [r5, #140]	; 0x8c
 8025af0:	f360 0341 	bfi	r3, r0, #1, #1
 8025af4:	f8a5 308c 	strh.w	r3, [r5, #140]	; 0x8c
 8025af8:	e72b      	b.n	8025952 <USBD_SignalDeviceEventHandler+0x126>
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
 8025afa:	682b      	ldr	r3, [r5, #0]
 8025afc:	f895 005c 	ldrb.w	r0, [r5, #92]	; 0x5c
 8025b00:	6a1b      	ldr	r3, [r3, #32]
 8025b02:	4798      	blx	r3
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
 8025b04:	2800      	cmp	r0, #0
 8025b06:	f47f af0c 	bne.w	8025922 <USBD_SignalDeviceEventHandler+0xf6>
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
          ((uint8_t)device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].Address))
          {
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
 8025b0a:	f895 3060 	ldrb.w	r3, [r5, #96]	; 0x60
 8025b0e:	f360 0300 	bfi	r3, r0, #0, #1
 8025b12:	f885 3060 	strb.w	r3, [r5, #96]	; 0x60
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
 8025b16:	f8b5 3060 	ldrh.w	r3, [r5, #96]	; 0x60
 8025b1a:	f360 0341 	bfi	r3, r0, #1, #1
 8025b1e:	f8a5 3060 	strh.w	r3, [r5, #96]	; 0x60
 8025b22:	e6fe      	b.n	8025922 <USBD_SignalDeviceEventHandler+0xf6>
 8025b24:	bd70      	pop	{r4, r5, r6, pc}
 8025b26:	bf00      	nop
 8025b28:	1fffab55 	.word	0x1fffab55
 8025b2c:	1fffad60 	.word	0x1fffad60

08025b30 <USBD_HandleEP0_Stall>:
 *
 * Stalls EP0 and then restarts a new transfer including setting EP0 state to
 * 																\ref USBD_EP0_STATE_IDLE.
 */
static void USBD_HandleEP0_Stall(void)
{
 8025b30:	b510      	push	{r4, lr}
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
 8025b32:	4c08      	ldr	r4, [pc, #32]	; (8025b54 <USBD_HandleEP0_Stall+0x24>)
 8025b34:	6823      	ldr	r3, [r4, #0]
 8025b36:	2080      	movs	r0, #128	; 0x80
 8025b38:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8025b3a:	2101      	movs	r1, #1
 8025b3c:	4798      	blx	r3
 8025b3e:	b100      	cbz	r0, 8025b42 <USBD_HandleEP0_Stall+0x12>
 8025b40:	bd10      	pop	{r4, pc}
  {
    device.ep0_state = USBD_EP0_STATE_IDLE;
    if ( USBD_STATUS_SUCCESS != (USBD_STATUS_t)device.Driver->EndpointReadStart(0U,USBD_EP0_3SETUP_PKT_SIZE))
 8025b42:	6823      	ldr	r3, [r4, #0]
{
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
  {
    device.ep0_state = USBD_EP0_STATE_IDLE;
 8025b44:	2201      	movs	r2, #1
    if ( USBD_STATUS_SUCCESS != (USBD_STATUS_t)device.Driver->EndpointReadStart(0U,USBD_EP0_3SETUP_PKT_SIZE))
 8025b46:	6a9b      	ldr	r3, [r3, #40]	; 0x28
{
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
  {
    device.ep0_state = USBD_EP0_STATE_IDLE;
 8025b48:	f884 213b 	strb.w	r2, [r4, #315]	; 0x13b
    if ( USBD_STATUS_SUCCESS != (USBD_STATUS_t)device.Driver->EndpointReadStart(0U,USBD_EP0_3SETUP_PKT_SIZE))
 8025b4c:	2118      	movs	r1, #24
    {
      XMC_ASSERT("USBD_HandleEP0_Stall: EndpointReadStart failed", 0);
    }
  }
}
 8025b4e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
  {
    device.ep0_state = USBD_EP0_STATE_IDLE;
    if ( USBD_STATUS_SUCCESS != (USBD_STATUS_t)device.Driver->EndpointReadStart(0U,USBD_EP0_3SETUP_PKT_SIZE))
 8025b52:	4718      	bx	r3
 8025b54:	1fffad60 	.word	0x1fffad60

08025b58 <USBD_Handle_DeviceRequest>:
 * handle some custom request or override the request handling in this function.
 * If the user has handled the request, he has to call \ref Endpoint_ClearSETUP.
 *
 */
static void USBD_Handle_DeviceRequest(void)
{
 8025b58:	b570      	push	{r4, r5, r6, lr}
  

  value = (uint32_t)USB_ControlRequest.wValue & (uint32_t)USBD_BYTE_MASK;

  /* Handling of class/vendor requests */
  if (NULL != device.events->control_request)
 8025b5a:	4ca2      	ldr	r4, [pc, #648]	; (8025de4 <USBD_Handle_DeviceRequest+0x28c>)
  uint32_t value;
  uint32_t tmp_value;
  uint32_t tmp_index;
  

  value = (uint32_t)USB_ControlRequest.wValue & (uint32_t)USBD_BYTE_MASK;
 8025b5c:	4ea2      	ldr	r6, [pc, #648]	; (8025de8 <USBD_Handle_DeviceRequest+0x290>)

  /* Handling of class/vendor requests */
  if (NULL != device.events->control_request)
 8025b5e:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
  uint32_t value;
  uint32_t tmp_value;
  uint32_t tmp_index;
  

  value = (uint32_t)USB_ControlRequest.wValue & (uint32_t)USBD_BYTE_MASK;
 8025b62:	8870      	ldrh	r0, [r6, #2]

  /* Handling of class/vendor requests */
  if (NULL != device.events->control_request)
 8025b64:	68da      	ldr	r2, [r3, #12]
 * handle some custom request or override the request handling in this function.
 * If the user has handled the request, he has to call \ref Endpoint_ClearSETUP.
 *
 */
static void USBD_Handle_DeviceRequest(void)
{
 8025b66:	b082      	sub	sp, #8
  uint32_t length = 0U;
  uint32_t ret;
  void *buffer = NULL;
 8025b68:	2300      	movs	r3, #0
  uint32_t value;
  uint32_t tmp_value;
  uint32_t tmp_index;
  

  value = (uint32_t)USB_ControlRequest.wValue & (uint32_t)USBD_BYTE_MASK;
 8025b6a:	b285      	uxth	r5, r0
 */
static void USBD_Handle_DeviceRequest(void)
{
  uint32_t length = 0U;
  uint32_t ret;
  void *buffer = NULL;
 8025b6c:	9300      	str	r3, [sp, #0]
  uint32_t status = 0U;
 8025b6e:	9301      	str	r3, [sp, #4]
  

  value = (uint32_t)USB_ControlRequest.wValue & (uint32_t)USBD_BYTE_MASK;

  /* Handling of class/vendor requests */
  if (NULL != device.events->control_request)
 8025b70:	b102      	cbz	r2, 8025b74 <USBD_Handle_DeviceRequest+0x1c>
  {
    device.events->control_request();
 8025b72:	4790      	blx	r2
  }

  if (1U == device.IsSetupRecieved)
 8025b74:	f894 313e 	ldrb.w	r3, [r4, #318]	; 0x13e
 8025b78:	079b      	lsls	r3, r3, #30
 8025b7a:	d407      	bmi.n	8025b8c <USBD_Handle_DeviceRequest+0x34>
      default:
        USBD_HandleEP0_Stall();
        break;
    }
  }
  device.IsSetupRecieved = 0U;
 8025b7c:	f894 313e 	ldrb.w	r3, [r4, #318]	; 0x13e
 8025b80:	f023 0302 	bic.w	r3, r3, #2
 8025b84:	f884 313e 	strb.w	r3, [r4, #318]	; 0x13e
}
 8025b88:	b002      	add	sp, #8
 8025b8a:	bd70      	pop	{r4, r5, r6, pc}
  }

  if (1U == device.IsSetupRecieved)
  {
    /* default request handling */
    switch (USB_ControlRequest.bRequest)
 8025b8c:	7873      	ldrb	r3, [r6, #1]
  uint32_t value;
  uint32_t tmp_value;
  uint32_t tmp_index;
  

  value = (uint32_t)USB_ControlRequest.wValue & (uint32_t)USBD_BYTE_MASK;
 8025b8e:	b2ed      	uxtb	r5, r5
  }

  if (1U == device.IsSetupRecieved)
  {
    /* default request handling */
    switch (USB_ControlRequest.bRequest)
 8025b90:	2b0c      	cmp	r3, #12
 8025b92:	d816      	bhi.n	8025bc2 <USBD_Handle_DeviceRequest+0x6a>
 8025b94:	e8df f013 	tbh	[pc, r3, lsl #1]
 8025b98:	00be0025 	.word	0x00be0025
 8025b9c:	009d0015 	.word	0x009d0015
 8025ba0:	00d00015 	.word	0x00d00015
 8025ba4:	00150056 	.word	0x00150056
 8025ba8:	008a0083 	.word	0x008a0083
 8025bac:	0078000d 	.word	0x0078000d
 8025bb0:	0015      	.short	0x0015
          device.Endpoints[0].InDataBuffer = (uint8_t *)buffer + ret;
        }
        break;

      case REQ_GetInterface:
        if ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState)
 8025bb2:	4b8e      	ldr	r3, [pc, #568]	; (8025dec <USBD_Handle_DeviceRequest+0x294>)
 8025bb4:	781a      	ldrb	r2, [r3, #0]
 8025bb6:	2a04      	cmp	r2, #4
 8025bb8:	f000 8136 	beq.w	8025e28 <USBD_Handle_DeviceRequest+0x2d0>
          tmp_value = (uint32_t)USB_ControlRequest.wValue;
          tmp_index = (uint32_t)USB_ControlRequest.wIndex;
          device.interface_settings[tmp_index] =	(uint8_t)tmp_value;
          break;
        }
        if ((uint8_t)DEVICE_STATE_Addressed == USB_DeviceState)
 8025bbc:	781b      	ldrb	r3, [r3, #0]
 8025bbe:	2b03      	cmp	r3, #3
 8025bc0:	d1dc      	bne.n	8025b7c <USBD_Handle_DeviceRequest+0x24>
 */
static void USBD_HandleEP0_Stall(void)
{
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
 8025bc2:	6823      	ldr	r3, [r4, #0]
 8025bc4:	4d87      	ldr	r5, [pc, #540]	; (8025de4 <USBD_Handle_DeviceRequest+0x28c>)
 8025bc6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8025bc8:	2080      	movs	r0, #128	; 0x80
 8025bca:	2101      	movs	r1, #1
 8025bcc:	4798      	blx	r3
 8025bce:	2800      	cmp	r0, #0
 8025bd0:	d1d4      	bne.n	8025b7c <USBD_Handle_DeviceRequest+0x24>
  {
    device.ep0_state = USBD_EP0_STATE_IDLE;
    if ( USBD_STATUS_SUCCESS != (USBD_STATUS_t)device.Driver->EndpointReadStart(0U,USBD_EP0_3SETUP_PKT_SIZE))
 8025bd2:	682b      	ldr	r3, [r5, #0]
{
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
  {
    device.ep0_state = USBD_EP0_STATE_IDLE;
 8025bd4:	2201      	movs	r2, #1
    if ( USBD_STATUS_SUCCESS != (USBD_STATUS_t)device.Driver->EndpointReadStart(0U,USBD_EP0_3SETUP_PKT_SIZE))
 8025bd6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
{
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
  {
    device.ep0_state = USBD_EP0_STATE_IDLE;
 8025bd8:	f885 213b 	strb.w	r2, [r5, #315]	; 0x13b
    if ( USBD_STATUS_SUCCESS != (USBD_STATUS_t)device.Driver->EndpointReadStart(0U,USBD_EP0_3SETUP_PKT_SIZE))
 8025bdc:	2118      	movs	r1, #24
 8025bde:	4798      	blx	r3
 8025be0:	e7cc      	b.n	8025b7c <USBD_Handle_DeviceRequest+0x24>
          break;
        }
        break;

      case REQ_GetStatus:
        if (REQREC_DEVICE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
 8025be2:	7830      	ldrb	r0, [r6, #0]
 8025be4:	4b80      	ldr	r3, [pc, #512]	; (8025de8 <USBD_Handle_DeviceRequest+0x290>)
 8025be6:	f010 0003 	ands.w	r0, r0, #3
 8025bea:	f000 8103 	beq.w	8025df4 <USBD_Handle_DeviceRequest+0x29c>
          {
            XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetStatus", 0);
          }          
          break;
        }
        if ((REQREC_INTERFACE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK)) &&
 8025bee:	781b      	ldrb	r3, [r3, #0]
 8025bf0:	f003 0303 	and.w	r3, r3, #3
 8025bf4:	2b01      	cmp	r3, #1
 8025bf6:	f000 80e7 	beq.w	8025dc8 <USBD_Handle_DeviceRequest+0x270>
            XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetStatus- REQREC_INTERFACE", 0);
          }          
          break;
        }

        if (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
 8025bfa:	7833      	ldrb	r3, [r6, #0]
 8025bfc:	4a7a      	ldr	r2, [pc, #488]	; (8025de8 <USBD_Handle_DeviceRequest+0x290>)
 8025bfe:	f003 0303 	and.w	r3, r3, #3
 8025c02:	2b02      	cmp	r3, #2
 8025c04:	d1dd      	bne.n	8025bc2 <USBD_Handle_DeviceRequest+0x6a>
        {
          index = (uint32_t)(USB_ControlRequest.wIndex & USBD_BYTE_MASK & ENDPOINT_EPNUM_MASK);
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0 == USB_ControlRequest.wIndex)) &&
 8025c06:	4979      	ldr	r1, [pc, #484]	; (8025dec <USBD_Handle_DeviceRequest+0x294>)
          break;
        }

        if (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)(USB_ControlRequest.wIndex & USBD_BYTE_MASK & ENDPOINT_EPNUM_MASK);
 8025c08:	8893      	ldrh	r3, [r2, #4]
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0 == USB_ControlRequest.wIndex)) &&
 8025c0a:	7809      	ldrb	r1, [r1, #0]
 8025c0c:	2904      	cmp	r1, #4
          break;
        }

        if (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)(USB_ControlRequest.wIndex & USBD_BYTE_MASK & ENDPOINT_EPNUM_MASK);
 8025c0e:	b29b      	uxth	r3, r3
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0 == USB_ControlRequest.wIndex)) &&
 8025c10:	d003      	beq.n	8025c1a <USBD_Handle_DeviceRequest+0xc2>
 8025c12:	8892      	ldrh	r2, [r2, #4]
 8025c14:	b292      	uxth	r2, r2
 8025c16:	2a00      	cmp	r2, #0
 8025c18:	d1d3      	bne.n	8025bc2 <USBD_Handle_DeviceRequest+0x6a>
              (1U == device.Endpoints[index].IsConfigured))
 8025c1a:	222c      	movs	r2, #44	; 0x2c
          break;
        }

        if (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)(USB_ControlRequest.wIndex & USBD_BYTE_MASK & ENDPOINT_EPNUM_MASK);
 8025c1c:	f003 030f 	and.w	r3, r3, #15
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0 == USB_ControlRequest.wIndex)) &&
              (1U == device.Endpoints[index].IsConfigured))
 8025c20:	fb02 4303 	mla	r3, r2, r3, r4
 8025c24:	496f      	ldr	r1, [pc, #444]	; (8025de4 <USBD_Handle_DeviceRequest+0x28c>)
 8025c26:	7a1a      	ldrb	r2, [r3, #8]
        }

        if (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)(USB_ControlRequest.wIndex & USBD_BYTE_MASK & ENDPOINT_EPNUM_MASK);
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0 == USB_ControlRequest.wIndex)) &&
 8025c28:	07d0      	lsls	r0, r2, #31
 8025c2a:	d5ca      	bpl.n	8025bc2 <USBD_Handle_DeviceRequest+0x6a>
              (1U == device.Endpoints[index].IsConfigured))
          {
            status = (uint32_t)device.Endpoints[index].IsHalted;
 8025c2c:	689b      	ldr	r3, [r3, #8]
            if (0U == (uint32_t)device.Driver->EndpointWrite(0U, (uint8_t*)&status, USBD_WORD_SIZE))
 8025c2e:	680a      	ldr	r2, [r1, #0]
        {
          index = (uint32_t)(USB_ControlRequest.wIndex & USBD_BYTE_MASK & ENDPOINT_EPNUM_MASK);
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0 == USB_ControlRequest.wIndex)) &&
              (1U == device.Endpoints[index].IsConfigured))
          {
            status = (uint32_t)device.Endpoints[index].IsHalted;
 8025c30:	a902      	add	r1, sp, #8
 8025c32:	f3c3 0380 	ubfx	r3, r3, #2, #1
 8025c36:	f841 3d04 	str.w	r3, [r1, #-4]!
            if (0U == (uint32_t)device.Driver->EndpointWrite(0U, (uint8_t*)&status, USBD_WORD_SIZE))
 8025c3a:	2000      	movs	r0, #0
 8025c3c:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8025c3e:	2202      	movs	r2, #2
 8025c40:	4798      	blx	r3
            {
              XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetStatus- REQREC_ENDPOINT", 0);
            }              
            break;
 8025c42:	e79b      	b.n	8025b7c <USBD_Handle_DeviceRequest+0x24>
          XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on get configuration request", 0);
        }
        break;

      case REQ_GetDescriptor:
        if (NULL != device.events->get_descriptor)
 8025c44:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
 8025c48:	695b      	ldr	r3, [r3, #20]
 8025c4a:	2b00      	cmp	r3, #0
 8025c4c:	d0b9      	beq.n	8025bc2 <USBD_Handle_DeviceRequest+0x6a>
        {
          tmp_value = (uint32_t)USB_ControlRequest.wValue;
 8025c4e:	8870      	ldrh	r0, [r6, #2]
          tmp_index = (uint32_t)USB_ControlRequest.wIndex;
 8025c50:	88b1      	ldrh	r1, [r6, #4]
        break;

      case REQ_GetDescriptor:
        if (NULL != device.events->get_descriptor)
        {
          tmp_value = (uint32_t)USB_ControlRequest.wValue;
 8025c52:	4e65      	ldr	r6, [pc, #404]	; (8025de8 <USBD_Handle_DeviceRequest+0x290>)
          tmp_index = (uint32_t)USB_ControlRequest.wIndex;
          length = (uint32_t)device.events->get_descriptor((uint16_t)tmp_value, (uint16_t)tmp_index, (void*)&buffer);
 8025c54:	b280      	uxth	r0, r0
 8025c56:	b289      	uxth	r1, r1
 8025c58:	466a      	mov	r2, sp
 8025c5a:	4798      	blx	r3
        }

        if (0U == length)
 8025c5c:	4605      	mov	r5, r0
 8025c5e:	2800      	cmp	r0, #0
 8025c60:	d0af      	beq.n	8025bc2 <USBD_Handle_DeviceRequest+0x6a>
        {
          USBD_HandleEP0_Stall();
        }
        else
        {
          if (length >= (uint32_t)USB_ControlRequest.wLength)
 8025c62:	88f3      	ldrh	r3, [r6, #6]
          {
            length = (uint32_t)USB_ControlRequest.wLength;
          }

          ret = (uint32_t)device.Driver->EndpointWrite(0U,buffer,length);
 8025c64:	9900      	ldr	r1, [sp, #0]
        {
          USBD_HandleEP0_Stall();
        }
        else
        {
          if (length >= (uint32_t)USB_ControlRequest.wLength)
 8025c66:	b29b      	uxth	r3, r3
 8025c68:	4298      	cmp	r0, r3
          {
            length = (uint32_t)USB_ControlRequest.wLength;
 8025c6a:	bf28      	it	cs
 8025c6c:	88f5      	ldrhcs	r5, [r6, #6]
          }

          ret = (uint32_t)device.Driver->EndpointWrite(0U,buffer,length);
 8025c6e:	6823      	ldr	r3, [r4, #0]
        }
        else
        {
          if (length >= (uint32_t)USB_ControlRequest.wLength)
          {
            length = (uint32_t)USB_ControlRequest.wLength;
 8025c70:	bf28      	it	cs
 8025c72:	b2ad      	uxthcs	r5, r5
          }

          ret = (uint32_t)device.Driver->EndpointWrite(0U,buffer,length);
 8025c74:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8025c76:	462a      	mov	r2, r5
 8025c78:	2000      	movs	r0, #0
 8025c7a:	4798      	blx	r3
          device.Endpoints[0].InDataLeft = length - ret;
          device.Endpoints[0].InDataBuffer = (uint8_t *)buffer + ret;
 8025c7c:	9b00      	ldr	r3, [sp, #0]
          {
            length = (uint32_t)USB_ControlRequest.wLength;
          }

          ret = (uint32_t)device.Driver->EndpointWrite(0U,buffer,length);
          device.Endpoints[0].InDataLeft = length - ret;
 8025c7e:	1a2d      	subs	r5, r5, r0
          device.Endpoints[0].InDataBuffer = (uint8_t *)buffer + ret;
 8025c80:	4418      	add	r0, r3
          {
            length = (uint32_t)USB_ControlRequest.wLength;
          }

          ret = (uint32_t)device.Driver->EndpointWrite(0U,buffer,length);
          device.Endpoints[0].InDataLeft = length - ret;
 8025c82:	62a5      	str	r5, [r4, #40]	; 0x28
          device.Endpoints[0].InDataBuffer = (uint8_t *)buffer + ret;
 8025c84:	62e0      	str	r0, [r4, #44]	; 0x2c
 8025c86:	e779      	b.n	8025b7c <USBD_Handle_DeviceRequest+0x24>
        /* Set Descriptor not supported, so stall */
        USBD_HandleEP0_Stall();
        break;

      case REQ_SetInterface:
        if ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState)
 8025c88:	4b58      	ldr	r3, [pc, #352]	; (8025dec <USBD_Handle_DeviceRequest+0x294>)
 8025c8a:	781a      	ldrb	r2, [r3, #0]
 8025c8c:	2a04      	cmp	r2, #4
 8025c8e:	d195      	bne.n	8025bbc <USBD_Handle_DeviceRequest+0x64>
        {
          tmp_value = (uint32_t)USB_ControlRequest.wValue;
 8025c90:	8872      	ldrh	r2, [r6, #2]
          tmp_index = (uint32_t)USB_ControlRequest.wIndex;
 8025c92:	88b3      	ldrh	r3, [r6, #4]
          device.interface_settings[tmp_index] =	(uint8_t)tmp_value;
 8025c94:	fa14 f383 	uxtah	r3, r4, r3
 8025c98:	f883 2138 	strb.w	r2, [r3, #312]	; 0x138
          break;
 8025c9c:	e76e      	b.n	8025b7c <USBD_Handle_DeviceRequest+0x24>
        }
        USBD_HandleEP0_Stall();
        break;

      case REQ_GetConfiguration:
        if (0U == (uint32_t)device.Driver->EndpointWrite(0U,&device.configuration,1U))
 8025c9e:	6823      	ldr	r3, [r4, #0]
 8025ca0:	4953      	ldr	r1, [pc, #332]	; (8025df0 <USBD_Handle_DeviceRequest+0x298>)
 8025ca2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8025ca4:	2201      	movs	r2, #1
 8025ca6:	2000      	movs	r0, #0
 8025ca8:	4798      	blx	r3
        {
          XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on get configuration request", 0);
        }
        break;
 8025caa:	e767      	b.n	8025b7c <USBD_Handle_DeviceRequest+0x24>

      case REQ_SetConfiguration:
        /* Regardless the state update the configuration to unconfigure
         * endpoints */
        device.configuration = (uint8_t)value;
        if (NULL != device.events->config_changed)
 8025cac:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
        break;

      case REQ_SetConfiguration:
        /* Regardless the state update the configuration to unconfigure
         * endpoints */
        device.configuration = (uint8_t)value;
 8025cb0:	f884 5139 	strb.w	r5, [r4, #313]	; 0x139
        if (NULL != device.events->config_changed)
 8025cb4:	689b      	ldr	r3, [r3, #8]
 8025cb6:	b103      	cbz	r3, 8025cba <USBD_Handle_DeviceRequest+0x162>
        {
          device.events->config_changed();
 8025cb8:	4798      	blx	r3
        }

        /* when config 0 is choosen, we are back in address state */
        if (0U == value)
 8025cba:	2d00      	cmp	r5, #0
 8025cbc:	d054      	beq.n	8025d68 <USBD_Handle_DeviceRequest+0x210>
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Addressed;
          break;
        }
        /* go ahead only with vailid config. (must be set in event) */
        if (1U == device.IsConfigured)
 8025cbe:	f894 313e 	ldrb.w	r3, [r4, #318]	; 0x13e
 8025cc2:	4d48      	ldr	r5, [pc, #288]	; (8025de4 <USBD_Handle_DeviceRequest+0x28c>)
 8025cc4:	07d9      	lsls	r1, r3, #31
 8025cc6:	f140 80a6 	bpl.w	8025e16 <USBD_Handle_DeviceRequest+0x2be>
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Configured;
 8025cca:	4b48      	ldr	r3, [pc, #288]	; (8025dec <USBD_Handle_DeviceRequest+0x294>)
 8025ccc:	2204      	movs	r2, #4
 8025cce:	701a      	strb	r2, [r3, #0]
 8025cd0:	e754      	b.n	8025b7c <USBD_Handle_DeviceRequest+0x24>
        }
        break;

      case REQ_SetFeature:
        /* we do not support test mode */
        if ((uint32_t)FEATURE_SEL_TestMode == value)
 8025cd2:	2d02      	cmp	r5, #2
 8025cd4:	f43f af75 	beq.w	8025bc2 <USBD_Handle_DeviceRequest+0x6a>
        {
          USBD_HandleEP0_Stall();
          break;
        }
        /* configured state */
        if ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState)
 8025cd8:	4b44      	ldr	r3, [pc, #272]	; (8025dec <USBD_Handle_DeviceRequest+0x294>)
 8025cda:	781a      	ldrb	r2, [r3, #0]
 8025cdc:	2a04      	cmp	r2, #4
 8025cde:	d067      	beq.n	8025db0 <USBD_Handle_DeviceRequest+0x258>
              break;
          }
          break;
        }
        /* when addressed, only ep0 can be halted */
        if ((uint8_t)DEVICE_STATE_Addressed == USB_DeviceState)
 8025ce0:	781b      	ldrb	r3, [r3, #0]
 8025ce2:	2b03      	cmp	r3, #3
 8025ce4:	f47f af6d 	bne.w	8025bc2 <USBD_Handle_DeviceRequest+0x6a>
        {
          if (((uint32_t)FEATURE_SEL_EndpointHalt == value) &&
 8025ce8:	2d00      	cmp	r5, #0
 8025cea:	f47f af6a 	bne.w	8025bc2 <USBD_Handle_DeviceRequest+0x6a>
              (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK)) &&
 8025cee:	7833      	ldrb	r3, [r6, #0]
 8025cf0:	4a3d      	ldr	r2, [pc, #244]	; (8025de8 <USBD_Handle_DeviceRequest+0x290>)
          break;
        }
        /* when addressed, only ep0 can be halted */
        if ((uint8_t)DEVICE_STATE_Addressed == USB_DeviceState)
        {
          if (((uint32_t)FEATURE_SEL_EndpointHalt == value) &&
 8025cf2:	f003 0303 	and.w	r3, r3, #3
 8025cf6:	2b02      	cmp	r3, #2
 8025cf8:	f47f af63 	bne.w	8025bc2 <USBD_Handle_DeviceRequest+0x6a>
              (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK)) &&
              ((uint16_t)0 == ((uint16_t)USB_ControlRequest.wIndex & (uint16_t)USBD_BYTE_MASK)))
 8025cfc:	8893      	ldrh	r3, [r2, #4]
        }
        /* when addressed, only ep0 can be halted */
        if ((uint8_t)DEVICE_STATE_Addressed == USB_DeviceState)
        {
          if (((uint32_t)FEATURE_SEL_EndpointHalt == value) &&
              (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK)) &&
 8025cfe:	f013 0fff 	tst.w	r3, #255	; 0xff
 8025d02:	f47f af5e 	bne.w	8025bc2 <USBD_Handle_DeviceRequest+0x6a>
              ((uint16_t)0 == ((uint16_t)USB_ControlRequest.wIndex & (uint16_t)USBD_BYTE_MASK)))
          {
            device.Endpoints[0].IsHalted = 1U;
 8025d06:	8923      	ldrh	r3, [r4, #8]
 8025d08:	f043 0304 	orr.w	r3, r3, #4
 8025d0c:	8123      	strh	r3, [r4, #8]
            USBD_HandleEP0_Stall();
 8025d0e:	f7ff ff0f 	bl	8025b30 <USBD_HandleEP0_Stall>
            break;
 8025d12:	e733      	b.n	8025b7c <USBD_Handle_DeviceRequest+0x24>
  {
    /* default request handling */
    switch (USB_ControlRequest.bRequest)
    {
      case REQ_ClearFeature:
        if ((uint8_t)REQREC_ENDPOINT == (USB_ControlRequest.bmRequestType & (uint8_t)REQ_RECIPIENT_MASK))
 8025d14:	7833      	ldrb	r3, [r6, #0]
 8025d16:	4a34      	ldr	r2, [pc, #208]	; (8025de8 <USBD_Handle_DeviceRequest+0x290>)
 8025d18:	f003 0303 	and.w	r3, r3, #3
 8025d1c:	2b02      	cmp	r3, #2
 8025d1e:	d027      	beq.n	8025d70 <USBD_Handle_DeviceRequest+0x218>
          {
            USBD_HandleEP0_Stall();
          }
          break;
        }
        if (REQREC_DEVICE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
 8025d20:	7813      	ldrb	r3, [r2, #0]
 8025d22:	f013 0303 	ands.w	r3, r3, #3
 8025d26:	f47f af4c 	bne.w	8025bc2 <USBD_Handle_DeviceRequest+0x6a>
        {
          device.remote_wakeup = 0U;
 8025d2a:	f894 213e 	ldrb.w	r2, [r4, #318]	; 0x13e
 8025d2e:	f363 0282 	bfi	r2, r3, #2, #1
 8025d32:	f884 213e 	strb.w	r2, [r4, #318]	; 0x13e
          break;
 8025d36:	e721      	b.n	8025b7c <USBD_Handle_DeviceRequest+0x24>
        break;

      case REQ_SetAddress:
        if (0U == value)
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
 8025d38:	4b2c      	ldr	r3, [pc, #176]	; (8025dec <USBD_Handle_DeviceRequest+0x294>)
        /* default stall */
        USBD_HandleEP0_Stall();
        break;

      case REQ_SetAddress:
        if (0U == value)
 8025d3a:	b995      	cbnz	r5, 8025d62 <USBD_Handle_DeviceRequest+0x20a>
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
 8025d3c:	2202      	movs	r2, #2
 8025d3e:	701a      	strb	r2, [r3, #0]
        }
        else
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Addressed;
        }
        if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->DeviceSetAddress((uint8_t)value,
 8025d40:	6823      	ldr	r3, [r4, #0]
 8025d42:	4e28      	ldr	r6, [pc, #160]	; (8025de4 <USBD_Handle_DeviceRequest+0x28c>)
 8025d44:	699b      	ldr	r3, [r3, #24]
 8025d46:	4628      	mov	r0, r5
 8025d48:	2100      	movs	r1, #0
 8025d4a:	4798      	blx	r3
 8025d4c:	2800      	cmp	r0, #0
 8025d4e:	f47f af15 	bne.w	8025b7c <USBD_Handle_DeviceRequest+0x24>
                                   XMC_USBD_SET_ADDRESS_STAGE_SETUP))
        {
          if (NULL != device.events->set_address)
 8025d52:	f8d6 3140 	ldr.w	r3, [r6, #320]	; 0x140
 8025d56:	691b      	ldr	r3, [r3, #16]
 8025d58:	2b00      	cmp	r3, #0
 8025d5a:	f43f af0f 	beq.w	8025b7c <USBD_Handle_DeviceRequest+0x24>
          {
            device.events->set_address();
 8025d5e:	4798      	blx	r3
 8025d60:	e70c      	b.n	8025b7c <USBD_Handle_DeviceRequest+0x24>
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
        }
        else
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Addressed;
 8025d62:	2203      	movs	r2, #3
 8025d64:	701a      	strb	r2, [r3, #0]
 8025d66:	e7eb      	b.n	8025d40 <USBD_Handle_DeviceRequest+0x1e8>
        }

        /* when config 0 is choosen, we are back in address state */
        if (0U == value)
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Addressed;
 8025d68:	4b20      	ldr	r3, [pc, #128]	; (8025dec <USBD_Handle_DeviceRequest+0x294>)
 8025d6a:	2203      	movs	r2, #3
 8025d6c:	701a      	strb	r2, [r3, #0]
          break;
 8025d6e:	e705      	b.n	8025b7c <USBD_Handle_DeviceRequest+0x24>
    {
      case REQ_ClearFeature:
        if ((uint8_t)REQREC_ENDPOINT == (USB_ControlRequest.bmRequestType & (uint8_t)REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)USB_ControlRequest.wIndex & (uint32_t)ENDPOINT_EPNUM_MASK;
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0U == USB_ControlRequest.wIndex)) &&
 8025d70:	491e      	ldr	r1, [pc, #120]	; (8025dec <USBD_Handle_DeviceRequest+0x294>)
    switch (USB_ControlRequest.bRequest)
    {
      case REQ_ClearFeature:
        if ((uint8_t)REQREC_ENDPOINT == (USB_ControlRequest.bmRequestType & (uint8_t)REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)USB_ControlRequest.wIndex & (uint32_t)ENDPOINT_EPNUM_MASK;
 8025d72:	8893      	ldrh	r3, [r2, #4]
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0U == USB_ControlRequest.wIndex)) &&
 8025d74:	7809      	ldrb	r1, [r1, #0]
 8025d76:	2904      	cmp	r1, #4
    switch (USB_ControlRequest.bRequest)
    {
      case REQ_ClearFeature:
        if ((uint8_t)REQREC_ENDPOINT == (USB_ControlRequest.bmRequestType & (uint8_t)REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)USB_ControlRequest.wIndex & (uint32_t)ENDPOINT_EPNUM_MASK;
 8025d78:	b29b      	uxth	r3, r3
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0U == USB_ControlRequest.wIndex)) &&
 8025d7a:	d004      	beq.n	8025d86 <USBD_Handle_DeviceRequest+0x22e>
 8025d7c:	8892      	ldrh	r2, [r2, #4]
 8025d7e:	b292      	uxth	r2, r2
 8025d80:	2a00      	cmp	r2, #0
 8025d82:	f47f af1e 	bne.w	8025bc2 <USBD_Handle_DeviceRequest+0x6a>
                  (1U == device.Endpoints[index].IsConfigured))
 8025d86:	222c      	movs	r2, #44	; 0x2c
    switch (USB_ControlRequest.bRequest)
    {
      case REQ_ClearFeature:
        if ((uint8_t)REQREC_ENDPOINT == (USB_ControlRequest.bmRequestType & (uint8_t)REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)USB_ControlRequest.wIndex & (uint32_t)ENDPOINT_EPNUM_MASK;
 8025d88:	f003 030f 	and.w	r3, r3, #15
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0U == USB_ControlRequest.wIndex)) &&
                  (1U == device.Endpoints[index].IsConfigured))
 8025d8c:	fb02 4303 	mla	r3, r2, r3, r4
 8025d90:	4914      	ldr	r1, [pc, #80]	; (8025de4 <USBD_Handle_DeviceRequest+0x28c>)
 8025d92:	7a1a      	ldrb	r2, [r3, #8]
    {
      case REQ_ClearFeature:
        if ((uint8_t)REQREC_ENDPOINT == (USB_ControlRequest.bmRequestType & (uint8_t)REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)USB_ControlRequest.wIndex & (uint32_t)ENDPOINT_EPNUM_MASK;
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0U == USB_ControlRequest.wIndex)) &&
 8025d94:	07d5      	lsls	r5, r2, #31
 8025d96:	f57f af14 	bpl.w	8025bc2 <USBD_Handle_DeviceRequest+0x6a>
                  (1U == device.Endpoints[index].IsConfigured))
          {
            device.Endpoints[index].IsHalted = 0U;
 8025d9a:	891a      	ldrh	r2, [r3, #8]
 8025d9c:	f36f 0282 	bfc	r2, #2, #1
 8025da0:	811a      	strh	r2, [r3, #8]
            if (USBD_STATUS_SUCCESS != 
                                 (USBD_STATUS_t)device.Driver->EndpointStall((uint8_t)USB_ControlRequest.wIndex,false))
 8025da2:	88b0      	ldrh	r0, [r6, #4]
 8025da4:	680b      	ldr	r3, [r1, #0]
 8025da6:	b2c0      	uxtb	r0, r0
 8025da8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8025daa:	2100      	movs	r1, #0
 8025dac:	4798      	blx	r3
          index = (uint32_t)USB_ControlRequest.wIndex & (uint32_t)ENDPOINT_EPNUM_MASK;
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0U == USB_ControlRequest.wIndex)) &&
                  (1U == device.Endpoints[index].IsConfigured))
          {
            device.Endpoints[index].IsHalted = 0U;
            if (USBD_STATUS_SUCCESS != 
 8025dae:	e6e5      	b.n	8025b7c <USBD_Handle_DeviceRequest+0x24>
          break;
        }
        /* configured state */
        if ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState)
        {
          switch (value)
 8025db0:	2d00      	cmp	r5, #0
 8025db2:	d044      	beq.n	8025e3e <USBD_Handle_DeviceRequest+0x2e6>
 8025db4:	2d01      	cmp	r5, #1
 8025db6:	f47f aee1 	bne.w	8025b7c <USBD_Handle_DeviceRequest+0x24>
          {
            case FEATURE_SEL_DeviceRemoteWakeup:
              device.remote_wakeup = 1U;
 8025dba:	f894 313e 	ldrb.w	r3, [r4, #318]	; 0x13e
 8025dbe:	f043 0304 	orr.w	r3, r3, #4
 8025dc2:	f884 313e 	strb.w	r3, [r4, #318]	; 0x13e
              break;
 8025dc6:	e6d9      	b.n	8025b7c <USBD_Handle_DeviceRequest+0x24>
            XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetStatus", 0);
          }          
          break;
        }
        if ((REQREC_INTERFACE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK)) &&
            ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState))
 8025dc8:	4b08      	ldr	r3, [pc, #32]	; (8025dec <USBD_Handle_DeviceRequest+0x294>)
 8025dca:	781b      	ldrb	r3, [r3, #0]
          {
            XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetStatus", 0);
          }          
          break;
        }
        if ((REQREC_INTERFACE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK)) &&
 8025dcc:	2b04      	cmp	r3, #4
 8025dce:	f47f af14 	bne.w	8025bfa <USBD_Handle_DeviceRequest+0xa2>
            ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState))
        {
          status = 0U;
 8025dd2:	a902      	add	r1, sp, #8
          if (0U == (uint32_t)device.Driver->EndpointWrite(0U, (uint8_t*)&status, USBD_WORD_SIZE))
 8025dd4:	6823      	ldr	r3, [r4, #0]
          break;
        }
        if ((REQREC_INTERFACE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK)) &&
            ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState))
        {
          status = 0U;
 8025dd6:	2000      	movs	r0, #0
 8025dd8:	f841 0d04 	str.w	r0, [r1, #-4]!
          if (0U == (uint32_t)device.Driver->EndpointWrite(0U, (uint8_t*)&status, USBD_WORD_SIZE))
 8025ddc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8025dde:	2202      	movs	r2, #2
 8025de0:	4798      	blx	r3
          {
            XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetStatus- REQREC_INTERFACE", 0);
          }          
          break;
 8025de2:	e6cb      	b.n	8025b7c <USBD_Handle_DeviceRequest+0x24>
 8025de4:	1fffad60 	.word	0x1fffad60
 8025de8:	1fffab58 	.word	0x1fffab58
 8025dec:	1fffab55 	.word	0x1fffab55
 8025df0:	1fffae99 	.word	0x1fffae99
        break;

      case REQ_GetStatus:
        if (REQREC_DEVICE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
        {
          status = (uint32_t)((uint8_t)(device.remote_wakeup << (uint8_t)1) | device.self_powered);					
 8025df4:	f894 313e 	ldrb.w	r3, [r4, #318]	; 0x13e
          if (0U == (uint32_t)device.Driver->EndpointWrite(0U, (uint8_t*)&status, USBD_WORD_SIZE))
 8025df8:	6822      	ldr	r2, [r4, #0]
        break;

      case REQ_GetStatus:
        if (REQREC_DEVICE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
        {
          status = (uint32_t)((uint8_t)(device.remote_wakeup << (uint8_t)1) | device.self_powered);					
 8025dfa:	f3c3 0580 	ubfx	r5, r3, #2, #1
 8025dfe:	006d      	lsls	r5, r5, #1
 8025e00:	b2ed      	uxtb	r5, r5
 8025e02:	a902      	add	r1, sp, #8
 8025e04:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 8025e08:	432b      	orrs	r3, r5
 8025e0a:	f841 3d04 	str.w	r3, [r1, #-4]!
          if (0U == (uint32_t)device.Driver->EndpointWrite(0U, (uint8_t*)&status, USBD_WORD_SIZE))
 8025e0e:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8025e10:	2202      	movs	r2, #2
 8025e12:	4798      	blx	r3
          {
            XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetStatus", 0);
          }          
          break;
 8025e14:	e6b2      	b.n	8025b7c <USBD_Handle_DeviceRequest+0x24>
 */
static void USBD_HandleEP0_Stall(void)
{
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
 8025e16:	682b      	ldr	r3, [r5, #0]
 8025e18:	2080      	movs	r0, #128	; 0x80
 8025e1a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8025e1c:	2101      	movs	r1, #1
 8025e1e:	4798      	blx	r3
 8025e20:	2800      	cmp	r0, #0
 8025e22:	f47f aeab 	bne.w	8025b7c <USBD_Handle_DeviceRequest+0x24>
 8025e26:	e6d4      	b.n	8025bd2 <USBD_Handle_DeviceRequest+0x7a>

      case REQ_GetInterface:
        if ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState)
        {          
          if (0U == (uint32_t)device.Driver->EndpointWrite(0U, 
             &device.interface_settings[USB_ControlRequest.wIndex], 1U))
 8025e28:	88b1      	ldrh	r1, [r6, #4]
        break;

      case REQ_GetInterface:
        if ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState)
        {          
          if (0U == (uint32_t)device.Driver->EndpointWrite(0U, 
 8025e2a:	6823      	ldr	r3, [r4, #0]
             &device.interface_settings[USB_ControlRequest.wIndex], 1U))
 8025e2c:	b289      	uxth	r1, r1
 8025e2e:	f501 719c 	add.w	r1, r1, #312	; 0x138
        break;

      case REQ_GetInterface:
        if ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState)
        {          
          if (0U == (uint32_t)device.Driver->EndpointWrite(0U, 
 8025e32:	4421      	add	r1, r4
 8025e34:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8025e36:	2201      	movs	r2, #1
 8025e38:	2000      	movs	r0, #0
 8025e3a:	4798      	blx	r3
             &device.interface_settings[USB_ControlRequest.wIndex], 1U))
          {
            XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetInterface", 0);
          }
          break;
 8025e3c:	e69e      	b.n	8025b7c <USBD_Handle_DeviceRequest+0x24>
          {
            case FEATURE_SEL_DeviceRemoteWakeup:
              device.remote_wakeup = 1U;
              break;
            case FEATURE_SEL_EndpointHalt:
              index = ((uint32_t)USB_ControlRequest.wIndex & (uint32_t)USBD_BYTE_MASK & 
 8025e3e:	88b3      	ldrh	r3, [r6, #4]
 8025e40:	480a      	ldr	r0, [pc, #40]	; (8025e6c <USBD_Handle_DeviceRequest+0x314>)
                      (uint32_t)XMC_USBD_ENDPOINT_NUMBER_MASK);
              if (0U == device.Endpoints[index].IsConfigured)
 8025e42:	490b      	ldr	r1, [pc, #44]	; (8025e70 <USBD_Handle_DeviceRequest+0x318>)
 8025e44:	222c      	movs	r2, #44	; 0x2c
          {
            case FEATURE_SEL_DeviceRemoteWakeup:
              device.remote_wakeup = 1U;
              break;
            case FEATURE_SEL_EndpointHalt:
              index = ((uint32_t)USB_ControlRequest.wIndex & (uint32_t)USBD_BYTE_MASK & 
 8025e46:	f003 030f 	and.w	r3, r3, #15
                      (uint32_t)XMC_USBD_ENDPOINT_NUMBER_MASK);
              if (0U == device.Endpoints[index].IsConfigured)
 8025e4a:	fb02 4303 	mla	r3, r2, r3, r4
 8025e4e:	7a1a      	ldrb	r2, [r3, #8]
 8025e50:	07d2      	lsls	r2, r2, #31
 8025e52:	f57f af5c 	bpl.w	8025d0e <USBD_Handle_DeviceRequest+0x1b6>
              {
                USBD_HandleEP0_Stall();
              }
              else
              {
                device.Endpoints[index].IsHalted = 1U;
 8025e56:	891a      	ldrh	r2, [r3, #8]
 8025e58:	f042 0204 	orr.w	r2, r2, #4
 8025e5c:	811a      	strh	r2, [r3, #8]
                if (USBD_STATUS_SUCCESS != 
                                  (USBD_STATUS_t)device.Driver->EndpointStall((uint8_t)USB_ControlRequest.wIndex,true))
 8025e5e:	680b      	ldr	r3, [r1, #0]
 8025e60:	8880      	ldrh	r0, [r0, #4]
 8025e62:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8025e64:	2101      	movs	r1, #1
 8025e66:	b2c0      	uxtb	r0, r0
 8025e68:	4798      	blx	r3
 8025e6a:	e687      	b.n	8025b7c <USBD_Handle_DeviceRequest+0x24>
 8025e6c:	1fffab58 	.word	0x1fffab58
 8025e70:	1fffad60 	.word	0x1fffad60

08025e74 <USBD_SignalEndpointEvent_Handler>:
 * If the driver detects an event (See XMC_USBD_EP_EVENT_t) for a specified endpoint it calls this function.
 * Based on the event some further action is taken, e.g. process control request or update transfer information
 * and read data from the driver into the core buffer.
 */
static void USBD_SignalEndpointEvent_Handler(uint8_t ep_addr, XMC_USBD_EP_EVENT_t ep_event)
{
 8025e74:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  uint32_t temp_num;
  uint32_t temp_dir;

  ep =  &device.Endpoints[(ep_addr & ENDPOINT_EPNUM_MASK)];
  /* store CurrentEndpoint and direction for restore after handling */
  temp_num = (uint32_t)device.CurrentEndpoint;
 8025e78:	4c72      	ldr	r4, [pc, #456]	; (8026044 <USBD_SignalEndpointEvent_Handler+0x1d0>)
  USBD_Endpoint_t *ep;
  int32_t data_count;
  uint32_t temp_num;
  uint32_t temp_dir;

  ep =  &device.Endpoints[(ep_addr & ENDPOINT_EPNUM_MASK)];
 8025e7a:	f000 050f 	and.w	r5, r0, #15
  temp_dir = (uint32_t)device.CurrentDirection;
  /* select the given endpoint */
  device.CurrentEndpoint = ep_addr & ENDPOINT_EPNUM_MASK;
  device.CurrentDirection = ep_addr & (uint8_t)ENDPOINT_DIR_MASK;
  /* choose what to do based on the event */
  switch (ep_event)
 8025e7e:	2901      	cmp	r1, #1
  /* store CurrentEndpoint and direction for restore after handling */
  temp_num = (uint32_t)device.CurrentEndpoint;
  temp_dir = (uint32_t)device.CurrentDirection;
  /* select the given endpoint */
  device.CurrentEndpoint = ep_addr & ENDPOINT_EPNUM_MASK;
  device.CurrentDirection = ep_addr & (uint8_t)ENDPOINT_DIR_MASK;
 8025e80:	f020 007f 	bic.w	r0, r0, #127	; 0x7f
  uint32_t temp_dir;

  ep =  &device.Endpoints[(ep_addr & ENDPOINT_EPNUM_MASK)];
  /* store CurrentEndpoint and direction for restore after handling */
  temp_num = (uint32_t)device.CurrentEndpoint;
  temp_dir = (uint32_t)device.CurrentDirection;
 8025e84:	f894 713d 	ldrb.w	r7, [r4, #317]	; 0x13d
  uint32_t temp_num;
  uint32_t temp_dir;

  ep =  &device.Endpoints[(ep_addr & ENDPOINT_EPNUM_MASK)];
  /* store CurrentEndpoint and direction for restore after handling */
  temp_num = (uint32_t)device.CurrentEndpoint;
 8025e88:	f894 813c 	ldrb.w	r8, [r4, #316]	; 0x13c
  temp_dir = (uint32_t)device.CurrentDirection;
  /* select the given endpoint */
  device.CurrentEndpoint = ep_addr & ENDPOINT_EPNUM_MASK;
  device.CurrentDirection = ep_addr & (uint8_t)ENDPOINT_DIR_MASK;
 8025e8c:	f884 013d 	strb.w	r0, [r4, #317]	; 0x13d
  USBD_Endpoint_t *ep;
  int32_t data_count;
  uint32_t temp_num;
  uint32_t temp_dir;

  ep =  &device.Endpoints[(ep_addr & ENDPOINT_EPNUM_MASK)];
 8025e90:	462e      	mov	r6, r5
  /* store CurrentEndpoint and direction for restore after handling */
  temp_num = (uint32_t)device.CurrentEndpoint;
  temp_dir = (uint32_t)device.CurrentDirection;
  /* select the given endpoint */
  device.CurrentEndpoint = ep_addr & ENDPOINT_EPNUM_MASK;
 8025e92:	f884 513c 	strb.w	r5, [r4, #316]	; 0x13c
  device.CurrentDirection = ep_addr & (uint8_t)ENDPOINT_DIR_MASK;
  /* choose what to do based on the event */
  switch (ep_event)
 8025e96:	d067      	beq.n	8025f68 <USBD_SignalEndpointEvent_Handler+0xf4>
 8025e98:	d33a      	bcc.n	8025f10 <USBD_SignalEndpointEvent_Handler+0x9c>
 8025e9a:	2902      	cmp	r1, #2
 8025e9c:	d132      	bne.n	8025f04 <USBD_SignalEndpointEvent_Handler+0x90>
          break;
      }
      break;
    case XMC_USBD_EP_EVENT_IN:
      /* loop write transfers */
      if (ep->InDataLeft > 0U)
 8025e9e:	232c      	movs	r3, #44	; 0x2c
 8025ea0:	fb03 4305 	mla	r3, r3, r5, r4
 8025ea4:	f103 0920 	add.w	r9, r3, #32
 8025ea8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8025eaa:	2a00      	cmp	r2, #0
 8025eac:	f040 8091 	bne.w	8025fd2 <USBD_SignalEndpointEvent_Handler+0x15e>
        data_count = device.Driver->EndpointWrite((uint8_t)ep->Address,ep->InDataBuffer,ep->InDataLeft);
        ep->InDataLeft -= (uint32_t)data_count;
        ep->InDataBuffer += (uint32_t)data_count;
        break;
      }
      else if (((uint32_t)ep->Number == 0U) && (ep->InBytesAvailable > 0U) &&
 8025eb0:	7918      	ldrb	r0, [r3, #4]
 8025eb2:	0702      	lsls	r2, r0, #28
 8025eb4:	d114      	bne.n	8025ee0 <USBD_SignalEndpointEvent_Handler+0x6c>
 8025eb6:	69da      	ldr	r2, [r3, #28]
 8025eb8:	b192      	cbz	r2, 8025ee0 <USBD_SignalEndpointEvent_Handler+0x6c>
              (ep->InBytesAvailable != (uint32_t)USB_ControlRequest.wLength) &&
 8025eba:	4963      	ldr	r1, [pc, #396]	; (8026048 <USBD_SignalEndpointEvent_Handler+0x1d4>)
 8025ebc:	88c9      	ldrh	r1, [r1, #6]
 8025ebe:	b289      	uxth	r1, r1
        data_count = device.Driver->EndpointWrite((uint8_t)ep->Address,ep->InDataBuffer,ep->InDataLeft);
        ep->InDataLeft -= (uint32_t)data_count;
        ep->InDataBuffer += (uint32_t)data_count;
        break;
      }
      else if (((uint32_t)ep->Number == 0U) && (ep->InBytesAvailable > 0U) &&
 8025ec0:	428a      	cmp	r2, r1
 8025ec2:	d00d      	beq.n	8025ee0 <USBD_SignalEndpointEvent_Handler+0x6c>
              (ep->InBytesAvailable != (uint32_t)USB_ControlRequest.wLength) &&
              ((ep->InBytesAvailable % (uint32_t)ep->MaxPacketSize) == 0U))
 8025ec4:	891b      	ldrh	r3, [r3, #8]
 8025ec6:	f3c3 1386 	ubfx	r3, r3, #6, #7
 8025eca:	fbb2 f1f3 	udiv	r1, r2, r3
 8025ece:	fb03 2111 	mls	r1, r3, r1, r2
        ep->InDataLeft -= (uint32_t)data_count;
        ep->InDataBuffer += (uint32_t)data_count;
        break;
      }
      else if (((uint32_t)ep->Number == 0U) && (ep->InBytesAvailable > 0U) &&
              (ep->InBytesAvailable != (uint32_t)USB_ControlRequest.wLength) &&
 8025ed2:	b929      	cbnz	r1, 8025ee0 <USBD_SignalEndpointEvent_Handler+0x6c>
              ((ep->InBytesAvailable % (uint32_t)ep->MaxPacketSize) == 0U))
      {
        /* if the amount of data for endpoint 0 is exact the requested
         * amount, then no zlp has to be send */
        device.Driver->EndpointWrite((uint8_t)ep->Address,0,0U);
 8025ed4:	6823      	ldr	r3, [r4, #0]
 8025ed6:	460a      	mov	r2, r1
 8025ed8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8025eda:	4798      	blx	r3
 8025edc:	f894 513c 	ldrb.w	r5, [r4, #316]	; 0x13c
      }
      else
      {
      }
      ep->InBytesAvailable = 0U;
 8025ee0:	f8df 9160 	ldr.w	r9, [pc, #352]	; 8026044 <USBD_SignalEndpointEvent_Handler+0x1d0>
 8025ee4:	232c      	movs	r3, #44	; 0x2c
 8025ee6:	fb03 4606 	mla	r6, r3, r6, r4
 8025eea:	2200      	movs	r2, #0
      ep->InInUse = (uint8_t)0;
 8025eec:	8933      	ldrh	r3, [r6, #8]
        device.Driver->EndpointWrite((uint8_t)ep->Address,0,0U);
      }
      else
      {
      }
      ep->InBytesAvailable = 0U;
 8025eee:	61f2      	str	r2, [r6, #28]
      ep->InInUse = (uint8_t)0;
 8025ef0:	f362 1304 	bfi	r3, r2, #4, #1
 8025ef4:	8133      	strh	r3, [r6, #8]
      switch (device.CurrentEndpoint)
 8025ef6:	b92d      	cbnz	r5, 8025f04 <USBD_SignalEndpointEvent_Handler+0x90>
 * In USBD_EP0_STATE_IN_STATUS state it starts a new read of setup packets and switches
 * to USBD_EP0_STATE_IDLE.
 */
static void USBD_HandleEP0_IN()
{
  if (USBD_EP0_STATE_IN_DATA == device.ep0_state)
 8025ef8:	f899 313b 	ldrb.w	r3, [r9, #315]	; 0x13b
 8025efc:	2b02      	cmp	r3, #2
 8025efe:	d078      	beq.n	8025ff2 <USBD_SignalEndpointEvent_Handler+0x17e>
  {
    /* Read zero length out data packet */
    device.Driver->EndpointReadStart((uint8_t)0,0U);
    device.ep0_state = USBD_EP0_STATE_OUT_STATUS;
  }
  else if (USBD_EP0_STATE_IN_STATUS == device.ep0_state)
 8025f00:	2b03      	cmp	r3, #3
 8025f02:	d04e      	beq.n	8025fa2 <USBD_SignalEndpointEvent_Handler+0x12e>
      }
      break;
    default:
      break;
  }
  device.CurrentEndpoint = (uint8_t)temp_num;
 8025f04:	f884 813c 	strb.w	r8, [r4, #316]	; 0x13c
  device.CurrentDirection = (uint8_t)temp_dir;
 8025f08:	f884 713d 	strb.w	r7, [r4, #317]	; 0x13d
 8025f0c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  device.CurrentDirection = ep_addr & (uint8_t)ENDPOINT_DIR_MASK;
  /* choose what to do based on the event */
  switch (ep_event)
  {
    case XMC_USBD_EP_EVENT_SETUP:
      ep->OutInUse = 0U;
 8025f10:	232c      	movs	r3, #44	; 0x2c
 8025f12:	fb03 4305 	mla	r3, r3, r5, r4
 8025f16:	891a      	ldrh	r2, [r3, #8]
 8025f18:	f36f 02c3 	bfc	r2, #3, #1
 8025f1c:	811a      	strh	r2, [r3, #8]
      switch (device.CurrentEndpoint)
 8025f1e:	2d00      	cmp	r5, #0
 8025f20:	d1f0      	bne.n	8025f04 <USBD_SignalEndpointEvent_Handler+0x90>
static void USBD_HandleEP0_SETUP()
{
  /* read setup packet from ep0 */
  uint32_t ret_val;

  ret_val = (uint32_t)device.Driver->EndpointRead((uint8_t)0,(void*)&USB_ControlRequest,
 8025f22:	6823      	ldr	r3, [r4, #0]
 8025f24:	4e48      	ldr	r6, [pc, #288]	; (8026048 <USBD_SignalEndpointEvent_Handler+0x1d4>)
 8025f26:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8025f28:	4631      	mov	r1, r6
 8025f2a:	4628      	mov	r0, r5
 8025f2c:	2208      	movs	r2, #8
 8025f2e:	4798      	blx	r3
            (uint32_t)USBD_EP0_SETUP_PKT_SIZE);
  device.IsSetupRecieved = (uint8_t)true;
 8025f30:	f894 313e 	ldrb.w	r3, [r4, #318]	; 0x13e

  if ((uint32_t)USBD_EP0_SETUP_PKT_SIZE == ret_val)
 8025f34:	2808      	cmp	r0, #8
  /* read setup packet from ep0 */
  uint32_t ret_val;

  ret_val = (uint32_t)device.Driver->EndpointRead((uint8_t)0,(void*)&USB_ControlRequest,
            (uint32_t)USBD_EP0_SETUP_PKT_SIZE);
  device.IsSetupRecieved = (uint8_t)true;
 8025f36:	f043 0302 	orr.w	r3, r3, #2
 8025f3a:	f884 313e 	strb.w	r3, [r4, #318]	; 0x13e

  if ((uint32_t)USBD_EP0_SETUP_PKT_SIZE == ret_val)
 8025f3e:	d1e1      	bne.n	8025f04 <USBD_SignalEndpointEvent_Handler+0x90>
  {
    /* if length is zero we have only a in_status phase */
    if (0U == (uint32_t)USB_ControlRequest.wLength)
 8025f40:	f8b6 9006 	ldrh.w	r9, [r6, #6]
 8025f44:	fa1f f989 	uxth.w	r9, r9
 8025f48:	f1b9 0f00 	cmp.w	r9, #0
 8025f4c:	d068      	beq.n	8026020 <USBD_SignalEndpointEvent_Handler+0x1ac>
      USBD_Handle_DeviceRequest();
      device.Driver->EndpointWrite((uint8_t)0, (uint8_t*)0, (uint32_t)0);
    }
    else
    {
      if (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_DIRECTION)
 8025f4e:	7833      	ldrb	r3, [r6, #0]
 8025f50:	0619      	lsls	r1, r3, #24
 8025f52:	d471      	bmi.n	8026038 <USBD_SignalEndpointEvent_Handler+0x1c4>
      }
      else
      {
        device.ep0_state = USBD_EP0_STATE_OUT_DATA;
        /* Do not process request here, first read data */
        device.Driver->EndpointReadStart((uint8_t)0, (uint32_t)USB_ControlRequest.wLength);
 8025f54:	88f1      	ldrh	r1, [r6, #6]
 8025f56:	6823      	ldr	r3, [r4, #0]
        device.ep0_state = USBD_EP0_STATE_IN_DATA;
        USBD_Handle_DeviceRequest();
      }
      else
      {
        device.ep0_state = USBD_EP0_STATE_OUT_DATA;
 8025f58:	2204      	movs	r2, #4
        /* Do not process request here, first read data */
        device.Driver->EndpointReadStart((uint8_t)0, (uint32_t)USB_ControlRequest.wLength);
 8025f5a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
        device.ep0_state = USBD_EP0_STATE_IN_DATA;
        USBD_Handle_DeviceRequest();
      }
      else
      {
        device.ep0_state = USBD_EP0_STATE_OUT_DATA;
 8025f5c:	f884 213b 	strb.w	r2, [r4, #315]	; 0x13b
        /* Do not process request here, first read data */
        device.Driver->EndpointReadStart((uint8_t)0, (uint32_t)USB_ControlRequest.wLength);
 8025f60:	b289      	uxth	r1, r1
 8025f62:	4628      	mov	r0, r5
 8025f64:	4798      	blx	r3
 8025f66:	e7cd      	b.n	8025f04 <USBD_SignalEndpointEvent_Handler+0x90>
        default:
          break;
      }
      break;
    case XMC_USBD_EP_EVENT_OUT:
      ep->IsOutRecieved = 1U;
 8025f68:	232c      	movs	r3, #44	; 0x2c
 8025f6a:	fb03 4305 	mla	r3, r3, r5, r4
 8025f6e:	4699      	mov	r9, r3
 8025f70:	891a      	ldrh	r2, [r3, #8]
 8025f72:	f042 0220 	orr.w	r2, r2, #32
 8025f76:	f829 2f08 	strh.w	r2, [r9, #8]!
      if (ep->OutBytesAvailable == 0U)
 8025f7a:	f8d9 2004 	ldr.w	r2, [r9, #4]
 8025f7e:	b1da      	cbz	r2, 8025fb8 <USBD_SignalEndpointEvent_Handler+0x144>
      {
        ep->OutOffset = 0U; /* clear offset, new data is there */
        ep->OutBytesAvailable = (uint32_t)device.Driver->EndpointRead((uint8_t)ep->Address,
                                ep->OutBuffer,ep->OutBufferLength);
      }
      ep->OutInUse = (uint8_t)0;
 8025f80:	232c      	movs	r3, #44	; 0x2c
 8025f82:	fb03 4606 	mla	r6, r3, r6, r4
 8025f86:	f8df 90bc 	ldr.w	r9, [pc, #188]	; 8026044 <USBD_SignalEndpointEvent_Handler+0x1d0>
 8025f8a:	8933      	ldrh	r3, [r6, #8]
 8025f8c:	f36f 03c3 	bfc	r3, #3, #1
 8025f90:	8133      	strh	r3, [r6, #8]
      switch (device.CurrentEndpoint)
 8025f92:	2d00      	cmp	r5, #0
 8025f94:	d1b6      	bne.n	8025f04 <USBD_SignalEndpointEvent_Handler+0x90>
 * USBD_EP0_STATE_OUT_DATA state, it handles the received data and starts a write
 * transaction for \ref USBD_EP0_STATE_IN_STATUS.
 */
static void USBD_HandleEP0_OUT()
{
  if (USBD_EP0_STATE_OUT_DATA == device.ep0_state)
 8025f96:	f899 313b 	ldrb.w	r3, [r9, #315]	; 0x13b
 8025f9a:	2b04      	cmp	r3, #4
 8025f9c:	d033      	beq.n	8026006 <USBD_SignalEndpointEvent_Handler+0x192>
    USBD_Handle_DeviceRequest();
    /* Zero length packet for status stage */
    device.Driver->EndpointWrite((uint8_t)0,(uint8_t*)0,(uint32_t)0);
    device.ep0_state = USBD_EP0_STATE_IN_STATUS;
  }
  else if (USBD_EP0_STATE_OUT_STATUS == device.ep0_state)
 8025f9e:	2b05      	cmp	r3, #5
 8025fa0:	d1b0      	bne.n	8025f04 <USBD_SignalEndpointEvent_Handler+0x90>
    device.ep0_state = USBD_EP0_STATE_OUT_STATUS;
  }
  else if (USBD_EP0_STATE_IN_STATUS == device.ep0_state)
  {
    /* Request new setup packet */
    device.Driver->EndpointReadStart((uint8_t)device.Endpoints[0].Address,(uint32_t)USBD_EP0_3SETUP_PKT_SIZE);
 8025fa2:	f8d9 3000 	ldr.w	r3, [r9]
 8025fa6:	f899 0004 	ldrb.w	r0, [r9, #4]
 8025faa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8025fac:	2118      	movs	r1, #24
 8025fae:	4798      	blx	r3
    device.ep0_state = USBD_EP0_STATE_IDLE;
 8025fb0:	2301      	movs	r3, #1
 8025fb2:	f889 313b 	strb.w	r3, [r9, #315]	; 0x13b
 8025fb6:	e7a5      	b.n	8025f04 <USBD_SignalEndpointEvent_Handler+0x90>
    case XMC_USBD_EP_EVENT_OUT:
      ep->IsOutRecieved = 1U;
      if (ep->OutBytesAvailable == 0U)
      {
        ep->OutOffset = 0U; /* clear offset, new data is there */
        ep->OutBytesAvailable = (uint32_t)device.Driver->EndpointRead((uint8_t)ep->Address,
 8025fb8:	6821      	ldr	r1, [r4, #0]
      break;
    case XMC_USBD_EP_EVENT_OUT:
      ep->IsOutRecieved = 1U;
      if (ep->OutBytesAvailable == 0U)
      {
        ep->OutOffset = 0U; /* clear offset, new data is there */
 8025fba:	f8c9 2008 	str.w	r2, [r9, #8]
        ep->OutBytesAvailable = (uint32_t)device.Driver->EndpointRead((uint8_t)ep->Address,
 8025fbe:	6acd      	ldr	r5, [r1, #44]	; 0x2c
 8025fc0:	7918      	ldrb	r0, [r3, #4]
 8025fc2:	6959      	ldr	r1, [r3, #20]
 8025fc4:	699a      	ldr	r2, [r3, #24]
 8025fc6:	47a8      	blx	r5
 8025fc8:	f894 513c 	ldrb.w	r5, [r4, #316]	; 0x13c
 8025fcc:	f8c9 0004 	str.w	r0, [r9, #4]
 8025fd0:	e7d6      	b.n	8025f80 <USBD_SignalEndpointEvent_Handler+0x10c>
      break;
    case XMC_USBD_EP_EVENT_IN:
      /* loop write transfers */
      if (ep->InDataLeft > 0U)
      {
        data_count = device.Driver->EndpointWrite((uint8_t)ep->Address,ep->InDataBuffer,ep->InDataLeft);
 8025fd2:	6821      	ldr	r1, [r4, #0]
 8025fd4:	7918      	ldrb	r0, [r3, #4]
 8025fd6:	6b0e      	ldr	r6, [r1, #48]	; 0x30
 8025fd8:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8025fda:	f103 0528 	add.w	r5, r3, #40	; 0x28
 8025fde:	47b0      	blx	r6
        ep->InDataLeft -= (uint32_t)data_count;
        ep->InDataBuffer += (uint32_t)data_count;
 8025fe0:	686a      	ldr	r2, [r5, #4]
    case XMC_USBD_EP_EVENT_IN:
      /* loop write transfers */
      if (ep->InDataLeft > 0U)
      {
        data_count = device.Driver->EndpointWrite((uint8_t)ep->Address,ep->InDataBuffer,ep->InDataLeft);
        ep->InDataLeft -= (uint32_t)data_count;
 8025fe2:	f8d9 3008 	ldr.w	r3, [r9, #8]
        ep->InDataBuffer += (uint32_t)data_count;
 8025fe6:	4402      	add	r2, r0
    case XMC_USBD_EP_EVENT_IN:
      /* loop write transfers */
      if (ep->InDataLeft > 0U)
      {
        data_count = device.Driver->EndpointWrite((uint8_t)ep->Address,ep->InDataBuffer,ep->InDataLeft);
        ep->InDataLeft -= (uint32_t)data_count;
 8025fe8:	1a1b      	subs	r3, r3, r0
        ep->InDataBuffer += (uint32_t)data_count;
 8025fea:	606a      	str	r2, [r5, #4]
    case XMC_USBD_EP_EVENT_IN:
      /* loop write transfers */
      if (ep->InDataLeft > 0U)
      {
        data_count = device.Driver->EndpointWrite((uint8_t)ep->Address,ep->InDataBuffer,ep->InDataLeft);
        ep->InDataLeft -= (uint32_t)data_count;
 8025fec:	f8c9 3008 	str.w	r3, [r9, #8]
        ep->InDataBuffer += (uint32_t)data_count;
        break;
 8025ff0:	e788      	b.n	8025f04 <USBD_SignalEndpointEvent_Handler+0x90>
static void USBD_HandleEP0_IN()
{
  if (USBD_EP0_STATE_IN_DATA == device.ep0_state)
  {
    /* Read zero length out data packet */
    device.Driver->EndpointReadStart((uint8_t)0,0U);
 8025ff2:	f8d9 3000 	ldr.w	r3, [r9]
 8025ff6:	4628      	mov	r0, r5
 8025ff8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8025ffa:	4629      	mov	r1, r5
 8025ffc:	4798      	blx	r3
    device.ep0_state = USBD_EP0_STATE_OUT_STATUS;
 8025ffe:	2305      	movs	r3, #5
 8026000:	f889 313b 	strb.w	r3, [r9, #315]	; 0x13b
 8026004:	e77e      	b.n	8025f04 <USBD_SignalEndpointEvent_Handler+0x90>
static void USBD_HandleEP0_OUT()
{
  if (USBD_EP0_STATE_OUT_DATA == device.ep0_state)
  {
    /* Now we have the data for handling the request */
    USBD_Handle_DeviceRequest();
 8026006:	f7ff fda7 	bl	8025b58 <USBD_Handle_DeviceRequest>
    /* Zero length packet for status stage */
    device.Driver->EndpointWrite((uint8_t)0,(uint8_t*)0,(uint32_t)0);
 802600a:	f8d9 3000 	ldr.w	r3, [r9]
 802600e:	4628      	mov	r0, r5
 8026010:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8026012:	4629      	mov	r1, r5
 8026014:	462a      	mov	r2, r5
 8026016:	4798      	blx	r3
    device.ep0_state = USBD_EP0_STATE_IN_STATUS;
 8026018:	2303      	movs	r3, #3
 802601a:	f889 313b 	strb.w	r3, [r9, #315]	; 0x13b
 802601e:	e771      	b.n	8025f04 <USBD_SignalEndpointEvent_Handler+0x90>
  if ((uint32_t)USBD_EP0_SETUP_PKT_SIZE == ret_val)
  {
    /* if length is zero we have only a in_status phase */
    if (0U == (uint32_t)USB_ControlRequest.wLength)
    {
      device.ep0_state = USBD_EP0_STATE_IN_STATUS;
 8026020:	2303      	movs	r3, #3
 8026022:	f884 313b 	strb.w	r3, [r4, #315]	; 0x13b
      USBD_Handle_DeviceRequest();
 8026026:	f7ff fd97 	bl	8025b58 <USBD_Handle_DeviceRequest>
      device.Driver->EndpointWrite((uint8_t)0, (uint8_t*)0, (uint32_t)0);
 802602a:	6823      	ldr	r3, [r4, #0]
 802602c:	4648      	mov	r0, r9
 802602e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8026030:	4649      	mov	r1, r9
 8026032:	464a      	mov	r2, r9
 8026034:	4798      	blx	r3
 8026036:	e765      	b.n	8025f04 <USBD_SignalEndpointEvent_Handler+0x90>
    }
    else
    {
      if (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_DIRECTION)
      {
        device.ep0_state = USBD_EP0_STATE_IN_DATA;
 8026038:	2302      	movs	r3, #2
 802603a:	f884 313b 	strb.w	r3, [r4, #315]	; 0x13b
        USBD_Handle_DeviceRequest();
 802603e:	f7ff fd8b 	bl	8025b58 <USBD_Handle_DeviceRequest>
 8026042:	e75f      	b.n	8025f04 <USBD_SignalEndpointEvent_Handler+0x90>
 8026044:	1fffad60 	.word	0x1fffad60
 8026048:	1fffab58 	.word	0x1fffab58

0802604c <USBD_Init>:
 * Intializes the USB driver core data structures and sets it into default
 * state. Afterwards it initializes the USB device controller driver and prepare
 *  it for connection via USBD_Connect.
 */
USBD_STATUS_t USBD_Init(USBD_t *handle)
{
 802604c:	b570      	push	{r4, r5, r6, lr}
	/* Disable USB to resolve the disconnect issue on self powered devices.
	 * Later in the XMC_USBD_Init() it enables the USB.
	 */
	XMC_USBD_Disable();

	memset(&device,0x0,sizeof(USB_Device_t));
 802604e:	4c3b      	ldr	r4, [pc, #236]	; (802613c <USBD_Init+0xf0>)
 * Intializes the USB driver core data structures and sets it into default
 * state. Afterwards it initializes the USB device controller driver and prepare
 *  it for connection via USBD_Connect.
 */
USBD_STATUS_t USBD_Init(USBD_t *handle)
{
 8026050:	4605      	mov	r5, r0


	/* Disable USB to resolve the disconnect issue on self powered devices.
	 * Later in the XMC_USBD_Init() it enables the USB.
	 */
	XMC_USBD_Disable();
 8026052:	f7fd fa25 	bl	80234a0 <XMC_USBD_Disable>

	memset(&device,0x0,sizeof(USB_Device_t));
 8026056:	2100      	movs	r1, #0
 8026058:	f44f 72a2 	mov.w	r2, #324	; 0x144
 802605c:	4620      	mov	r0, r4
 802605e:	f004 fd6a 	bl	802ab36 <memset>
	USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
 8026062:	4b37      	ldr	r3, [pc, #220]	; (8026140 <USBD_Init+0xf4>)
	device.Driver = &Driver_USBD0;
 8026064:	4837      	ldr	r0, [pc, #220]	; (8026144 <USBD_Init+0xf8>)
 8026066:	6020      	str	r0, [r4, #0]
	device.Endpoints[0].InBuffer = endpoint0_in_buffer;
	device.Endpoints[0].InBufferLength = USBD_EP0_BUF_SIZE;
	device.Endpoints[0].OutBuffer = endpoint0_out_buffer;
	device.Endpoints[0].OutBufferLength = USBD_EP0_BUF_SIZE;
	device.Endpoints[0].Direction = (uint8_t)0;
	device.Endpoints[0].IsConfigured = (uint8_t)1;
 8026068:	2601      	movs	r6, #1
	 * Later in the XMC_USBD_Init() it enables the USB.
	 */
	XMC_USBD_Disable();

	memset(&device,0x0,sizeof(USB_Device_t));
	USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
 802606a:	2000      	movs	r0, #0
 802606c:	7018      	strb	r0, [r3, #0]
	device.Endpoints[0].InBuffer = endpoint0_in_buffer;
	device.Endpoints[0].InBufferLength = USBD_EP0_BUF_SIZE;
	device.Endpoints[0].OutBuffer = endpoint0_out_buffer;
	device.Endpoints[0].OutBufferLength = USBD_EP0_BUF_SIZE;
	device.Endpoints[0].Direction = (uint8_t)0;
	device.Endpoints[0].IsConfigured = (uint8_t)1;
 802606e:	7226      	strb	r6, [r4, #8]
	device.Endpoints[0].IsEnabled = (uint8_t)1;
 8026070:	8923      	ldrh	r3, [r4, #8]
	USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
	device.Driver = &Driver_USBD0;
	device.ep0_state = USBD_EP0_STATE_IDLE;
	device.Endpoints[0].InBuffer = endpoint0_in_buffer;
	device.Endpoints[0].InBufferLength = USBD_EP0_BUF_SIZE;
	device.Endpoints[0].OutBuffer = endpoint0_out_buffer;
 8026072:	4a35      	ldr	r2, [pc, #212]	; (8026148 <USBD_Init+0xfc>)
 8026074:	6162      	str	r2, [r4, #20]
	device.Endpoints[0].OutBufferLength = USBD_EP0_BUF_SIZE;
	device.Endpoints[0].Direction = (uint8_t)0;
	device.Endpoints[0].IsConfigured = (uint8_t)1;
	device.Endpoints[0].IsEnabled = (uint8_t)1;
 8026076:	f043 0302 	orr.w	r3, r3, #2
 802607a:	8123      	strh	r3, [r4, #8]
	device.Endpoints[0].MaxPacketSize = (uint8_t)USBD_EP0_MAX_PKT_SIZE;
 802607c:	8923      	ldrh	r3, [r4, #8]

	memset(&device,0x0,sizeof(USB_Device_t));
	USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
	device.Driver = &Driver_USBD0;
	device.ep0_state = USBD_EP0_STATE_IDLE;
	device.Endpoints[0].InBuffer = endpoint0_in_buffer;
 802607e:	4933      	ldr	r1, [pc, #204]	; (802614c <USBD_Init+0x100>)
 8026080:	6221      	str	r1, [r4, #32]
	device.Endpoints[0].OutBuffer = endpoint0_out_buffer;
	device.Endpoints[0].OutBufferLength = USBD_EP0_BUF_SIZE;
	device.Endpoints[0].Direction = (uint8_t)0;
	device.Endpoints[0].IsConfigured = (uint8_t)1;
	device.Endpoints[0].IsEnabled = (uint8_t)1;
	device.Endpoints[0].MaxPacketSize = (uint8_t)USBD_EP0_MAX_PKT_SIZE;
 8026082:	2240      	movs	r2, #64	; 0x40
 8026084:	f362 138c 	bfi	r3, r2, #6, #7
 8026088:	8123      	strh	r3, [r4, #8]

	if ((handle->event_cb->control_request == 0) ||
 802608a:	692b      	ldr	r3, [r5, #16]
 802608c:	68d9      	ldr	r1, [r3, #12]
	XMC_USBD_Disable();

	memset(&device,0x0,sizeof(USB_Device_t));
	USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
	device.Driver = &Driver_USBD0;
	device.ep0_state = USBD_EP0_STATE_IDLE;
 802608e:	f884 613b 	strb.w	r6, [r4, #315]	; 0x13b
	device.Endpoints[0].InBuffer = endpoint0_in_buffer;
	device.Endpoints[0].InBufferLength = USBD_EP0_BUF_SIZE;
 8026092:	f44f 7280 	mov.w	r2, #256	; 0x100
	XMC_USBD_Disable();

	memset(&device,0x0,sizeof(USB_Device_t));
	USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
	device.Driver = &Driver_USBD0;
	device.ep0_state = USBD_EP0_STATE_IDLE;
 8026096:	4630      	mov	r0, r6
	device.Endpoints[0].InBuffer = endpoint0_in_buffer;
	device.Endpoints[0].InBufferLength = USBD_EP0_BUF_SIZE;
 8026098:	6262      	str	r2, [r4, #36]	; 0x24
	device.Endpoints[0].OutBuffer = endpoint0_out_buffer;
	device.Endpoints[0].OutBufferLength = USBD_EP0_BUF_SIZE;
 802609a:	61a2      	str	r2, [r4, #24]
	device.Endpoints[0].Direction = (uint8_t)0;
	device.Endpoints[0].IsConfigured = (uint8_t)1;
	device.Endpoints[0].IsEnabled = (uint8_t)1;
	device.Endpoints[0].MaxPacketSize = (uint8_t)USBD_EP0_MAX_PKT_SIZE;

	if ((handle->event_cb->control_request == 0) ||
 802609c:	b321      	cbz	r1, 80260e8 <USBD_Init+0x9c>
 802609e:	695a      	ldr	r2, [r3, #20]
 80260a0:	b312      	cbz	r2, 80260e8 <USBD_Init+0x9c>
	    (handle->event_cb->get_descriptor == 0) ||
 80260a2:	689a      	ldr	r2, [r3, #8]
 80260a4:	b302      	cbz	r2, 80260e8 <USBD_Init+0x9c>
	{
	  status = USBD_STATUS_FAILURE;
	}
	else
	{
	  device.events = handle->event_cb;
 80260a6:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140

	  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_USB);
 80260aa:	f7fb fa1f 	bl	80214ec <XMC_SCU_CLOCK_EnableClock>

	  /* First initalize the device */
	  handle->usb_init.cb_xmc_device_event = USBD_SignalDeviceEventHandler;
	  handle->usb_init.cb_endpoint_event = USBD_SignalEndpointEvent_Handler;

	  status = (USBD_STATUS_t)device.Driver->Initialize(&handle->usb_init);
 80260ae:	6823      	ldr	r3, [r4, #0]
	  device.events = handle->event_cb;

	  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_USB);

	  /* First initalize the device */
	  handle->usb_init.cb_xmc_device_event = USBD_SignalDeviceEventHandler;
 80260b0:	4927      	ldr	r1, [pc, #156]	; (8026150 <USBD_Init+0x104>)
	  handle->usb_init.cb_endpoint_event = USBD_SignalEndpointEvent_Handler;
 80260b2:	4a28      	ldr	r2, [pc, #160]	; (8026154 <USBD_Init+0x108>)

	  status = (USBD_STATUS_t)device.Driver->Initialize(&handle->usb_init);
 80260b4:	685b      	ldr	r3, [r3, #4]
	  device.events = handle->event_cb;

	  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_USB);

	  /* First initalize the device */
	  handle->usb_init.cb_xmc_device_event = USBD_SignalDeviceEventHandler;
 80260b6:	6069      	str	r1, [r5, #4]
	  handle->usb_init.cb_endpoint_event = USBD_SignalEndpointEvent_Handler;
 80260b8:	60aa      	str	r2, [r5, #8]

	  status = (USBD_STATUS_t)device.Driver->Initialize(&handle->usb_init);
 80260ba:	4628      	mov	r0, r5
 80260bc:	4798      	blx	r3
	  if (USBD_STATUS_SUCCESS == status)
 80260be:	4605      	mov	r5, r0
 80260c0:	b1a8      	cbz	r0, 80260ee <USBD_Init+0xa2>
	       (uint16_t)XMC_USBD_MAX_PACKET_SIZE);
	  }

	  if (USBD_STATUS_SUCCESS != status)
	  {
	  XMC_USBD_Disable();
 80260c2:	f7fd f9ed 	bl	80234a0 <XMC_USBD_Disable>
	  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->Uninitialize())
 80260c6:	6823      	ldr	r3, [r4, #0]
 80260c8:	689b      	ldr	r3, [r3, #8]
 80260ca:	4798      	blx	r3
 80260cc:	b950      	cbnz	r0, 80260e4 <USBD_Init+0x98>
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80260ce:	4b22      	ldr	r3, [pc, #136]	; (8026158 <USBD_Init+0x10c>)
 80260d0:	f44f 6200 	mov.w	r2, #2048	; 0x800
 80260d4:	f8c3 218c 	str.w	r2, [r3, #396]	; 0x18c
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80260d8:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 80260dc:	f3bf 8f4f 	dsb	sy
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 80260e0:	f3bf 8f6f 	isb	sy
	  }
	}


	return status;
}
 80260e4:	4628      	mov	r0, r5
 80260e6:	bd70      	pop	{r4, r5, r6, pc}

	if ((handle->event_cb->control_request == 0) ||
	    (handle->event_cb->get_descriptor == 0) ||
	    (handle->event_cb->config_changed == 0))
	{
	  status = USBD_STATUS_FAILURE;
 80260e8:	4605      	mov	r5, r0
	  }
	}


	return status;
}
 80260ea:	4628      	mov	r0, r5
 80260ec:	bd70      	pop	{r4, r5, r6, pc}
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80260ee:	4b1b      	ldr	r3, [pc, #108]	; (802615c <USBD_Init+0x110>)
 80260f0:	68db      	ldr	r3, [r3, #12]
 80260f2:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80260f6:	f1c3 0107 	rsb	r1, r3, #7
 80260fa:	2906      	cmp	r1, #6
 80260fc:	bf28      	it	cs
 80260fe:	2106      	movcs	r1, #6
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8026100:	b1cb      	cbz	r3, 8026136 <USBD_Init+0xea>
 8026102:	1e5a      	subs	r2, r3, #1

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8026104:	2301      	movs	r3, #1
 8026106:	408b      	lsls	r3, r1
 8026108:	3b01      	subs	r3, #1
 802610a:	4093      	lsls	r3, r2
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802610c:	009b      	lsls	r3, r3, #2
 802610e:	4a12      	ldr	r2, [pc, #72]	; (8026158 <USBD_Init+0x10c>)
 8026110:	b2db      	uxtb	r3, r3
 8026112:	f882 336b 	strb.w	r3, [r2, #875]	; 0x36b
	  {
	  /* Enable Interrupts in NVIC */
	  USB_EnableUSBInterrupt();

	  /* then configure endpoint 0 */
	  status = (USBD_STATUS_t)device.Driver->EndpointConfigure((uint8_t)0,XMC_USBD_ENDPOINT_TYPE_CONTROL,
 8026116:	6823      	ldr	r3, [r4, #0]
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8026118:	f44f 6100 	mov.w	r1, #2048	; 0x800
 802611c:	2000      	movs	r0, #0
 802611e:	f8c2 118c 	str.w	r1, [r2, #396]	; 0x18c
 8026122:	69db      	ldr	r3, [r3, #28]
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8026124:	60d1      	str	r1, [r2, #12]
 8026126:	4601      	mov	r1, r0
 8026128:	2240      	movs	r2, #64	; 0x40
 802612a:	4798      	blx	r3
	       (uint16_t)XMC_USBD_MAX_PACKET_SIZE);
	  }

	  if (USBD_STATUS_SUCCESS != status)
 802612c:	4605      	mov	r5, r0
 802612e:	2800      	cmp	r0, #0
 8026130:	d1c7      	bne.n	80260c2 <USBD_Init+0x76>
	  }
	}


	return status;
}
 8026132:	4628      	mov	r0, r5
 8026134:	bd70      	pop	{r4, r5, r6, pc}
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8026136:	461a      	mov	r2, r3
 8026138:	e7e4      	b.n	8026104 <USBD_Init+0xb8>
 802613a:	bf00      	nop
 802613c:	1fffad60 	.word	0x1fffad60
 8026140:	1fffab55 	.word	0x1fffab55
 8026144:	0802ac6c 	.word	0x0802ac6c
 8026148:	1fffac60 	.word	0x1fffac60
 802614c:	1fffab60 	.word	0x1fffab60
 8026150:	0802582d 	.word	0x0802582d
 8026154:	08025e75 	.word	0x08025e75
 8026158:	e000e100 	.word	0xe000e100
 802615c:	e000ed00 	.word	0xe000ed00

08026160 <USBD_Connect>:
 * Tell the USB device controller driver to connect to the bus. Successful connection will be shown
 * through update of the device status ( USB_DeviceState) and a firing of the USB device connect event.
 */
USBD_STATUS_t USBD_Connect(void)
{
  return (USBD_STATUS_t)device.Driver->DeviceConnect();
 8026160:	4b01      	ldr	r3, [pc, #4]	; (8026168 <USBD_Connect+0x8>)
 8026162:	681b      	ldr	r3, [r3, #0]
 8026164:	68db      	ldr	r3, [r3, #12]
 8026166:	4718      	bx	r3
 8026168:	1fffad60 	.word	0x1fffad60

0802616c <USBD_IsEnumDone>:
 * Check with the USB device controller driver if the enumeration is done.
 * Returns 1 on completion of enumeration.
 */
uint32_t USBD_IsEnumDone(void)
{
  return device.Driver->IsEnumDone();
 802616c:	4b01      	ldr	r3, [pc, #4]	; (8026174 <USBD_IsEnumDone+0x8>)
 802616e:	681b      	ldr	r3, [r3, #0]
 8026170:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8026172:	4718      	bx	r3
 8026174:	1fffad60 	.word	0x1fffad60

08026178 <USBD_SetEndpointBuffer>:
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid buffer", (buf != NULL));

  number = (uint32_t)addr & (uint32_t)ENDPOINT_EPNUM_MASK;
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid ep address", (number < (uint8_t)USBD_MAX_NUM_EPS));

  if (addr & (uint8_t)ENDPOINT_DIR_MASK)
 8026178:	f010 0f80 	tst.w	r0, #128	; 0x80
 *
 * The user has to ensure that an endpoint has a valid buffer for proper data transfer.
 *
 */
void USBD_SetEndpointBuffer(uint8_t addr, uint8_t *buf, uint16_t len)
{
 802617c:	b410      	push	{r4}
  number = (uint32_t)addr & (uint32_t)ENDPOINT_EPNUM_MASK;
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid ep address", (number < (uint8_t)USBD_MAX_NUM_EPS));

  if (addr & (uint8_t)ENDPOINT_DIR_MASK)
  {
    device.Endpoints[number].InBuffer = buf;
 802617e:	4b0a      	ldr	r3, [pc, #40]	; (80261a8 <USBD_SetEndpointBuffer+0x30>)
void USBD_SetEndpointBuffer(uint8_t addr, uint8_t *buf, uint16_t len)
{
  uint32_t number;
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid buffer", (buf != NULL));

  number = (uint32_t)addr & (uint32_t)ENDPOINT_EPNUM_MASK;
 8026180:	f000 040f 	and.w	r4, r0, #15
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid ep address", (number < (uint8_t)USBD_MAX_NUM_EPS));

  if (addr & (uint8_t)ENDPOINT_DIR_MASK)
  {
    device.Endpoints[number].InBuffer = buf;
 8026184:	f04f 002c 	mov.w	r0, #44	; 0x2c
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid buffer", (buf != NULL));

  number = (uint32_t)addr & (uint32_t)ENDPOINT_EPNUM_MASK;
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid ep address", (number < (uint8_t)USBD_MAX_NUM_EPS));

  if (addr & (uint8_t)ENDPOINT_DIR_MASK)
 8026188:	d106      	bne.n	8026198 <USBD_SetEndpointBuffer+0x20>
    device.Endpoints[number].InBuffer = buf;
    device.Endpoints[number].InBufferLength = len;
  }
  else
  {
    device.Endpoints[number].OutBuffer = buf;
 802618a:	fb00 3304 	mla	r3, r0, r4, r3
    device.Endpoints[number].OutBufferLength = len;
  }

}
 802618e:	f85d 4b04 	ldr.w	r4, [sp], #4
    device.Endpoints[number].InBuffer = buf;
    device.Endpoints[number].InBufferLength = len;
  }
  else
  {
    device.Endpoints[number].OutBuffer = buf;
 8026192:	6159      	str	r1, [r3, #20]
    device.Endpoints[number].OutBufferLength = len;
 8026194:	619a      	str	r2, [r3, #24]
  }

}
 8026196:	4770      	bx	lr
  number = (uint32_t)addr & (uint32_t)ENDPOINT_EPNUM_MASK;
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid ep address", (number < (uint8_t)USBD_MAX_NUM_EPS));

  if (addr & (uint8_t)ENDPOINT_DIR_MASK)
  {
    device.Endpoints[number].InBuffer = buf;
 8026198:	fb00 3404 	mla	r4, r0, r4, r3
 802619c:	6221      	str	r1, [r4, #32]
    device.Endpoints[number].InBufferLength = len;
 802619e:	6262      	str	r2, [r4, #36]	; 0x24
  {
    device.Endpoints[number].OutBuffer = buf;
    device.Endpoints[number].OutBufferLength = len;
  }

}
 80261a0:	f85d 4b04 	ldr.w	r4, [sp], #4
 80261a4:	4770      	bx	lr
 80261a6:	bf00      	nop
 80261a8:	1fffad60 	.word	0x1fffad60

080261ac <USB0_0_IRQHandler>:
 * This function gets called, if a USB exception (interrupt) was thrown and
 * dispatches it to XMC_USBD_IRQHandler.
 */
void USB0_0_IRQHandler(void)
{
  XMC_USBD_IRQHandler(&(USBD_handle->usb_init));
 80261ac:	4b01      	ldr	r3, [pc, #4]	; (80261b4 <USB0_0_IRQHandler+0x8>)
 80261ae:	6818      	ldr	r0, [r3, #0]
 80261b0:	f7fc bd0a 	b.w	8022bc8 <XMC_USBD_IRQHandler>
 80261b4:	1ffe8874 	.word	0x1ffe8874

080261b8 <TIMER_Init>:
/*
 * This function initializes a TIMER APP based on user configuration.
 *
 */
TIMER_STATUS_t TIMER_Init(TIMER_t* const handle_ptr)
{
 80261b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  XMC_ASSERT("TIMER_Init:handle_ptr NULL" , (handle_ptr != NULL));

  status = TIMER_STATUS_SUCCESS;
  /* Check for APP instance is initialized or not */
  if (false == handle_ptr->initialized)
 80261ba:	f890 303a 	ldrb.w	r3, [r0, #58]	; 0x3a
 80261be:	b943      	cbnz	r3, 80261d2 <TIMER_Init+0x1a>
  {
#ifdef TIMER_CCU4_USED
    if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 80261c0:	f890 5035 	ldrb.w	r5, [r0, #53]	; 0x35
 80261c4:	4604      	mov	r4, r0
 80261c6:	b13d      	cbz	r5, 80261d8 <TIMER_Init+0x20>
      status = TIMER_CCU4_lInit(handle_ptr);
    }
#endif

#ifdef TIMER_CCU8_USED
    if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
 80261c8:	2d01      	cmp	r5, #1
{
  TIMER_STATUS_t status;

  XMC_ASSERT("TIMER_Init:handle_ptr NULL" , (handle_ptr != NULL));

  status = TIMER_STATUS_SUCCESS;
 80261ca:	461e      	mov	r6, r3
      status = TIMER_CCU4_lInit(handle_ptr);
    }
#endif

#ifdef TIMER_CCU8_USED
    if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
 80261cc:	d02f      	beq.n	802622e <TIMER_Init+0x76>
    }
#endif
  }

  return (status);
}
 80261ce:	4630      	mov	r0, r6
 80261d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
{
  TIMER_STATUS_t status;

  XMC_ASSERT("TIMER_Init:handle_ptr NULL" , (handle_ptr != NULL));

  status = TIMER_STATUS_SUCCESS;
 80261d2:	2600      	movs	r6, #0
    }
#endif
  }

  return (status);
}
 80261d4:	4630      	mov	r0, r6
 80261d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
TIMER_STATUS_t TIMER_CCU4_lInit(TIMER_t* const handle_ptr)
{
  TIMER_STATUS_t status;
  /* Initialize the global registers */
  status = (TIMER_STATUS_t)GLOBAL_CCU4_Init(handle_ptr->global_ccu4_handler);
 80261d8:	6900      	ldr	r0, [r0, #16]
 80261da:	f000 fbdd 	bl	8026998 <GLOBAL_CCU4_Init>

  /* Enable the clock for selected timer */
  XMC_CCU4_EnableClock(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->ccu4_slice_number);
 80261de:	6923      	ldr	r3, [r4, #16]
__STATIC_INLINE void XMC_CCU4_EnableClock(XMC_CCU4_MODULE_t *const module, const uint8_t slice_number)
{
  XMC_ASSERT("XMC_CCU4_EnableClock:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  XMC_ASSERT("XMC_CCU4_EnableClock:Invalid Slice Number", (slice_number < 4U));

  module->GIDLC |= ((uint32_t) 1) << slice_number;
 80261e0:	f894 e018 	ldrb.w	lr, [r4, #24]
 80261e4:	689f      	ldr	r7, [r3, #8]
  /* Configure the timer with required settings */
  XMC_CCU4_SLICE_CompareInit(handle_ptr->ccu4_slice_ptr, handle_ptr->ccu4_slice_config_ptr);
 80261e6:	69e1      	ldr	r1, [r4, #28]
 80261e8:	68fa      	ldr	r2, [r7, #12]
 80261ea:	2301      	movs	r3, #1
 80261ec:	fa03 f30e 	lsl.w	r3, r3, lr
 80261f0:	4313      	orrs	r3, r2
 */
TIMER_STATUS_t TIMER_CCU4_lInit(TIMER_t* const handle_ptr)
{
  TIMER_STATUS_t status;
  /* Initialize the global registers */
  status = (TIMER_STATUS_t)GLOBAL_CCU4_Init(handle_ptr->global_ccu4_handler);
 80261f2:	4606      	mov	r6, r0

  /* Enable the clock for selected timer */
  XMC_CCU4_EnableClock(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->ccu4_slice_number);
  /* Configure the timer with required settings */
  XMC_CCU4_SLICE_CompareInit(handle_ptr->ccu4_slice_ptr, handle_ptr->ccu4_slice_config_ptr);
 80261f4:	6960      	ldr	r0, [r4, #20]
 80261f6:	60fb      	str	r3, [r7, #12]
 80261f8:	f7fb fc02 	bl	8021a00 <XMC_CCU4_SLICE_CompareInit>
  /* programs the timer period register according to time interval value */
  XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr, handle_ptr->period_value);
  /* programs the timer compare register for 50% duty cycle */
  XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr, TIMER_CMP_100_DUTY);
  /* Transfers value from shadow timer registers to actual timer registers */
  XMC_CCU4_EnableShadowTransfer(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->shadow_mask);
 80261fc:	6923      	ldr	r3, [r4, #16]
 * This function configures timer period and compare values and triggers the shadow transfer operation
 */
void TIMER_CCU4_lShadowTransfer(TIMER_t* const handle_ptr)
{
  /* programs the timer period register according to time interval value */
  XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr, handle_ptr->period_value);
 80261fe:	6960      	ldr	r0, [r4, #20]
  /* programs the timer compare register for 50% duty cycle */
  XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr, TIMER_CMP_100_DUTY);
  /* Transfers value from shadow timer registers to actual timer registers */
  XMC_CCU4_EnableShadowTransfer(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->shadow_mask);
 8026200:	689a      	ldr	r2, [r3, #8]
  XMC_CCU4_SLICE_CompareInit(handle_ptr->ccu4_slice_ptr, handle_ptr->ccu4_slice_config_ptr);
  /* programs the timer period and compare register according to time interval value and do the shadow transfer */
  TIMER_CCU4_lShadowTransfer(handle_ptr);

#ifdef  TIMER_INTERRUPT
  if (true == handle_ptr->period_match_enable)
 8026202:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerPeriodMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t period_val)
{
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->PRS = (uint32_t) period_val;
 8026206:	8ee7      	ldrh	r7, [r4, #54]	; 0x36
  /* programs the timer period register according to time interval value */
  XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr, handle_ptr->period_value);
  /* programs the timer compare register for 50% duty cycle */
  XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr, TIMER_CMP_100_DUTY);
  /* Transfers value from shadow timer registers to actual timer registers */
  XMC_CCU4_EnableShadowTransfer(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->shadow_mask);
 8026208:	68e1      	ldr	r1, [r4, #12]
 802620a:	6347      	str	r7, [r0, #52]	; 0x34
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerCompareMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t compare_val)
{
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->CRS = (uint32_t) compare_val;
 802620c:	63c5      	str	r5, [r0, #60]	; 0x3c
 *  None.
 */
__STATIC_INLINE void XMC_CCU4_EnableShadowTransfer(XMC_CCU4_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
  XMC_ASSERT("XMC_CCU4_EnableShadowTransfer:Invalid Slice Pointer", XMC_CCU4_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;  
 802620e:	6111      	str	r1, [r2, #16]
  XMC_CCU4_SLICE_CompareInit(handle_ptr->ccu4_slice_ptr, handle_ptr->ccu4_slice_config_ptr);
  /* programs the timer period and compare register according to time interval value and do the shadow transfer */
  TIMER_CCU4_lShadowTransfer(handle_ptr);

#ifdef  TIMER_INTERRUPT
  if (true == handle_ptr->period_match_enable)
 8026210:	2b00      	cmp	r3, #0
 8026212:	d138      	bne.n	8026286 <TIMER_Init+0xce>

  /* update the initialization flag as true for particular instance*/
  handle_ptr->initialized = true;

  /* Check whether the start of the timer is enabled during initialization or not */
  if (handle_ptr->start_control == true)
 8026214:	f894 2038 	ldrb.w	r2, [r4, #56]	; 0x38
 *  XMC_CCU4_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_ClearTimer(XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_ClearTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TCC_Msk;
 8026218:	2102      	movs	r1, #2
#endif
  /* Clears the timer register */
  XMC_CCU4_SLICE_ClearTimer(handle_ptr->ccu4_slice_ptr);

  /* update the initialization flag as true for particular instance*/
  handle_ptr->initialized = true;
 802621a:	2301      	movs	r3, #1
 802621c:	6101      	str	r1, [r0, #16]
 802621e:	f884 303a 	strb.w	r3, [r4, #58]	; 0x3a

  /* Check whether the start of the timer is enabled during initialization or not */
  if (handle_ptr->start_control == true)
 8026222:	b102      	cbz	r2, 8026226 <TIMER_Init+0x6e>
 *  XMC_CCU4_SLICE_StopTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_StartTimer(XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_StartTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCSET = CCU4_CC4_TCSET_TRBS_Msk;
 8026224:	60c3      	str	r3, [r0, #12]
 8026226:	f894 5035 	ldrb.w	r5, [r4, #53]	; 0x35
      status = TIMER_CCU4_lInit(handle_ptr);
    }
#endif

#ifdef TIMER_CCU8_USED
    if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
 802622a:	2d01      	cmp	r5, #1
 802622c:	d1cf      	bne.n	80261ce <TIMER_Init+0x16>
 */
TIMER_STATUS_t TIMER_CCU8_lInit(TIMER_t* const handle_ptr)
{
  TIMER_STATUS_t status;
  /* Initialize the global registers */
  status = (TIMER_STATUS_t)GLOBAL_CCU8_Init(handle_ptr->global_ccu8_handler);
 802622e:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8026230:	f000 fb9e 	bl	8026970 <GLOBAL_CCU8_Init>

  /* Enable the clock for selected timer */
  XMC_CCU8_EnableClock(handle_ptr->global_ccu8_handler->module_ptr, handle_ptr->ccu8_slice_number);
 8026234:	6a63      	ldr	r3, [r4, #36]	; 0x24
__STATIC_INLINE void XMC_CCU8_EnableClock(XMC_CCU8_MODULE_t *const module, const uint8_t slice_number)
{
  XMC_ASSERT("XMC_CCU8_EnableClock:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));
  XMC_ASSERT("XMC_CCU8_EnableClock:Invalid Slice Number", (slice_number < 4U));

  module->GIDLC |= ((uint32_t) 1 << slice_number);
 8026236:	f894 702c 	ldrb.w	r7, [r4, #44]	; 0x2c
 802623a:	689a      	ldr	r2, [r3, #8]
  /* Configure the timer with required settings */
  XMC_CCU8_SLICE_CompareInit(handle_ptr->ccu8_slice_ptr, handle_ptr->ccu8_slice_config_ptr);
 802623c:	6b21      	ldr	r1, [r4, #48]	; 0x30
 802623e:	68d3      	ldr	r3, [r2, #12]
 8026240:	40bd      	lsls	r5, r7
 8026242:	431d      	orrs	r5, r3
 */
TIMER_STATUS_t TIMER_CCU8_lInit(TIMER_t* const handle_ptr)
{
  TIMER_STATUS_t status;
  /* Initialize the global registers */
  status = (TIMER_STATUS_t)GLOBAL_CCU8_Init(handle_ptr->global_ccu8_handler);
 8026244:	4606      	mov	r6, r0

  /* Enable the clock for selected timer */
  XMC_CCU8_EnableClock(handle_ptr->global_ccu8_handler->module_ptr, handle_ptr->ccu8_slice_number);
  /* Configure the timer with required settings */
  XMC_CCU8_SLICE_CompareInit(handle_ptr->ccu8_slice_ptr, handle_ptr->ccu8_slice_config_ptr);
 8026246:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8026248:	60d5      	str	r5, [r2, #12]
 802624a:	f7fb fc9b 	bl	8021b84 <XMC_CCU8_SLICE_CompareInit>
 * This function configures timer period and compare values and triggers the shadow transfer operation
 */
void TIMER_CCU8_lShadowTransfer(TIMER_t* const handle_ptr)
{
  /* programs the timer period register according to time interval value */
  XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, handle_ptr->period_value);
 802624e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8026250:	8ee1      	ldrh	r1, [r4, #54]	; 0x36
 8026252:	f7fb fcb5 	bl	8021bc0 <XMC_CCU8_SLICE_SetTimerPeriodMatch>
  /* programs the timer compare register for 50% duty cycle in compare channel 1*/
  XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr,
 8026256:	2100      	movs	r1, #0
 8026258:	460a      	mov	r2, r1
 802625a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 802625c:	f7fb fcba 	bl	8021bd4 <XMC_CCU8_SLICE_SetTimerCompareMatch>
                                      XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
                                      TIMER_CMP_100_DUTY);
  /* Transfers value from shadow timer registers to actual timer registers */
  XMC_CCU8_EnableShadowTransfer(handle_ptr->global_ccu8_handler->module_ptr, handle_ptr->shadow_mask);
 8026260:	6a62      	ldr	r2, [r4, #36]	; 0x24
  XMC_CCU8_SLICE_CompareInit(handle_ptr->ccu8_slice_ptr, handle_ptr->ccu8_slice_config_ptr);
  /* programs the timer period and compare register according to time interval value and do the shadow transfer */
  TIMER_CCU8_lShadowTransfer(handle_ptr);

#ifdef  TIMER_INTERRUPT
  if (true == handle_ptr->period_match_enable)
 8026262:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
  /* programs the timer compare register for 50% duty cycle in compare channel 1*/
  XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr,
                                      XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
                                      TIMER_CMP_100_DUTY);
  /* Transfers value from shadow timer registers to actual timer registers */
  XMC_CCU8_EnableShadowTransfer(handle_ptr->global_ccu8_handler->module_ptr, handle_ptr->shadow_mask);
 8026266:	6892      	ldr	r2, [r2, #8]
 8026268:	68e1      	ldr	r1, [r4, #12]
 *  None.
 */
__STATIC_INLINE void XMC_CCU8_EnableShadowTransfer(XMC_CCU8_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
  XMC_ASSERT("XMC_CCU8_EnableShadowTransfer:Invalid module Pointer", XMC_CCU8_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;  
 802626a:	6111      	str	r1, [r2, #16]
  XMC_CCU8_SLICE_CompareInit(handle_ptr->ccu8_slice_ptr, handle_ptr->ccu8_slice_config_ptr);
  /* programs the timer period and compare register according to time interval value and do the shadow transfer */
  TIMER_CCU8_lShadowTransfer(handle_ptr);

#ifdef  TIMER_INTERRUPT
  if (true == handle_ptr->period_match_enable)
 802626c:	b9c3      	cbnz	r3, 80262a0 <TIMER_Init+0xe8>
 802626e:	6aa3      	ldr	r3, [r4, #40]	; 0x28

  /* update the initialization flag as true for particular instance*/
  handle_ptr->initialized = true;

  /* Check whether the start of the timer is enabled during initialization or not */
  if (handle_ptr->start_control == true)
 8026270:	f894 1038 	ldrb.w	r1, [r4, #56]	; 0x38
 *  XMC_CCU8_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_ClearTimer(XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_ClearTimer:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU8_CC8_TCCLR_TCC_Msk;
 8026274:	2002      	movs	r0, #2
#endif
  /* Clears the timer register */
  XMC_CCU8_SLICE_ClearTimer(handle_ptr->ccu8_slice_ptr);

  /* update the initialization flag as true for particular instance*/
  handle_ptr->initialized = true;
 8026276:	2201      	movs	r2, #1
 8026278:	6118      	str	r0, [r3, #16]
 802627a:	f884 203a 	strb.w	r2, [r4, #58]	; 0x3a

  /* Check whether the start of the timer is enabled during initialization or not */
  if (handle_ptr->start_control == true)
 802627e:	2900      	cmp	r1, #0
 8026280:	d0a5      	beq.n	80261ce <TIMER_Init+0x16>
 *  XMC_CCU8_SLICE_StopTimer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_StartTimer(XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_StartTimer:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TCSET = CCU8_CC8_TCSET_TRBS_Msk;
 8026282:	60da      	str	r2, [r3, #12]
 8026284:	e7a3      	b.n	80261ce <TIMER_Init+0x16>

#ifdef  TIMER_INTERRUPT
  if (true == handle_ptr->period_match_enable)
  {
    /* Binds a period match event to an NVIC node  */
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH,
 8026286:	4629      	mov	r1, r5
 8026288:	f894 2020 	ldrb.w	r2, [r4, #32]
 802628c:	f7fb fc32 	bl	8021af4 <XMC_CCU4_SLICE_SetInterruptNode>
                                    handle_ptr->ccu4_period_match_node);
    /* Enables a timer(period match) event  */
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
 8026290:	6960      	ldr	r0, [r4, #20]
__STATIC_INLINE void XMC_CCU4_SLICE_EnableEvent(XMC_CCU4_SLICE_t *const slice,
                                                const XMC_CCU4_SLICE_IRQ_ID_t event)
{
  XMC_ASSERT("XMC_CCU4_SLICE_EnableEvent:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_EnableEvent:Invalid SR event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  slice->INTE |= ((uint32_t) 1) << ((uint32_t) event);
 8026292:	f8d0 30a4 	ldr.w	r3, [r0, #164]	; 0xa4
 8026296:	f043 0301 	orr.w	r3, r3, #1
 802629a:	f8c0 30a4 	str.w	r3, [r0, #164]	; 0xa4
 802629e:	e7b9      	b.n	8026214 <TIMER_Init+0x5c>

#ifdef  TIMER_INTERRUPT
  if (true == handle_ptr->period_match_enable)
  {
    /* Binds a period match event to an NVIC node  */
    XMC_CCU8_SLICE_SetInterruptNode(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH,
 80262a0:	f894 2034 	ldrb.w	r2, [r4, #52]	; 0x34
 80262a4:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80262a6:	2100      	movs	r1, #0
 80262a8:	f7fb fc9a 	bl	8021be0 <XMC_CCU8_SLICE_SetInterruptNode>
                                    handle_ptr->ccu8_period_match_node);
    /* Enables a timer(period match) event  */
    XMC_CCU8_SLICE_EnableEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH);
 80262ac:	6aa3      	ldr	r3, [r4, #40]	; 0x28
__STATIC_INLINE void XMC_CCU8_SLICE_EnableEvent(XMC_CCU8_SLICE_t *const slice, const XMC_CCU8_SLICE_IRQ_ID_t event)
{
  XMC_ASSERT("XMC_CCU8_SLICE_EnableEvent:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_EnableEvent:Invalid SR event", XMC_CCU8_SLICE_CHECK_INTERRUPT(event));

  slice->INTE |= ((uint32_t) 1) << ((uint32_t) event);
 80262ae:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
 80262b2:	f042 0201 	orr.w	r2, r2, #1
 80262b6:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
 80262ba:	e7d9      	b.n	8026270 <TIMER_Init+0xb8>

080262bc <TIMER_Start>:
  TIMER_STATUS_t status;

  XMC_ASSERT("TIMER_Start:handle_ptr NULL" , (handle_ptr != NULL));

  /* Check for APP instance is initialized or not */
  if (true == handle_ptr->initialized)
 80262bc:	f890 303a 	ldrb.w	r3, [r0, #58]	; 0x3a
 80262c0:	b16b      	cbz	r3, 80262de <TIMER_Start+0x22>
  {
#ifdef TIMER_CCU4_USED
    if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 80262c2:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 80262c6:	b12b      	cbz	r3, 80262d4 <TIMER_Start+0x18>
      XMC_CCU4_SLICE_StartTimer(handle_ptr->ccu4_slice_ptr);
    }
#endif

#ifdef TIMER_CCU8_USED
    if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
 80262c8:	2b01      	cmp	r3, #1
 80262ca:	d10a      	bne.n	80262e2 <TIMER_Start+0x26>
       {
      /* Start the timer manually */
      XMC_CCU8_SLICE_StartTimer(handle_ptr->ccu8_slice_ptr);
 80262cc:	6a82      	ldr	r2, [r0, #40]	; 0x28
       }
#endif
    status = TIMER_STATUS_SUCCESS;
 80262ce:	2000      	movs	r0, #0
 *  XMC_CCU8_SLICE_StopTimer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_StartTimer(XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_StartTimer:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TCSET = CCU8_CC8_TCSET_TRBS_Msk;
 80262d0:	60d3      	str	r3, [r2, #12]
 80262d2:	4770      	bx	lr
  {
#ifdef TIMER_CCU4_USED
    if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
    {
      /* Start the timer manually */
      XMC_CCU4_SLICE_StartTimer(handle_ptr->ccu4_slice_ptr);
 80262d4:	6942      	ldr	r2, [r0, #20]
 *  XMC_CCU4_SLICE_StopTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_StartTimer(XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_StartTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCSET = CCU4_CC4_TCSET_TRBS_Msk;
 80262d6:	2101      	movs	r1, #1
       {
      /* Start the timer manually */
      XMC_CCU8_SLICE_StartTimer(handle_ptr->ccu8_slice_ptr);
       }
#endif
    status = TIMER_STATUS_SUCCESS;
 80262d8:	4618      	mov	r0, r3
 80262da:	60d1      	str	r1, [r2, #12]
 80262dc:	4770      	bx	lr
  }
  else
  {
    status = TIMER_STATUS_FAILURE;
 80262de:	2001      	movs	r0, #1
 80262e0:	4770      	bx	lr
       {
      /* Start the timer manually */
      XMC_CCU8_SLICE_StartTimer(handle_ptr->ccu8_slice_ptr);
       }
#endif
    status = TIMER_STATUS_SUCCESS;
 80262e2:	2000      	movs	r0, #0
  {
    status = TIMER_STATUS_FAILURE;
  }

  return (status);
}
 80262e4:	4770      	bx	lr
 80262e6:	bf00      	nop

080262e8 <TIMER_Stop>:
  XMC_ASSERT("TIMER_GetTimerStatus:handle_ptr NULL" , (handle_ptr != NULL));

  status = false;

#ifdef TIMER_CCU4_USED
  if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 80262e8:	f890 2035 	ldrb.w	r2, [r0, #53]	; 0x35
 80262ec:	b972      	cbnz	r2, 802630c <TIMER_Stop+0x24>
  {
    /* Returns the current status of the timer */
    status = XMC_CCU4_SLICE_IsTimerRunning(handle_ptr->ccu4_slice_ptr);
 80262ee:	6943      	ldr	r3, [r0, #20]
 *  XMC_CCU4_SLICE_StartTimer()<BR> XMC_CCU4_SLICE_StopTimer().
 */
__STATIC_INLINE bool XMC_CCU4_SLICE_IsTimerRunning(const XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_GetTimerStatus:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  return (bool)(((slice->TCST) & CCU4_CC4_TCST_TRB_Msk) == CCU4_CC4_TCST_TRB_Msk);
 80262f0:	689b      	ldr	r3, [r3, #8]
 80262f2:	f003 0301 	and.w	r3, r3, #1
  TIMER_STATUS_t status;

  XMC_ASSERT("TIMER_Stop:handle_ptr NULL" , (handle_ptr != NULL));

  /* Check whether timer is initialized and in running state */
  if ((TIMER_GetTimerStatus(handle_ptr)) && (true == handle_ptr->initialized))
 80262f6:	b15b      	cbz	r3, 8026310 <TIMER_Stop+0x28>
 80262f8:	f890 303a 	ldrb.w	r3, [r0, #58]	; 0x3a
 80262fc:	b143      	cbz	r3, 8026310 <TIMER_Stop+0x28>
  {
#ifdef TIMER_CCU4_USED
    if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 80262fe:	b172      	cbz	r2, 802631e <TIMER_Stop+0x36>
      XMC_CCU4_SLICE_StopTimer(handle_ptr->ccu4_slice_ptr);
    }
#endif

#ifdef TIMER_CCU8_USED
    if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
 8026300:	2a01      	cmp	r2, #1
 8026302:	d111      	bne.n	8026328 <TIMER_Stop+0x40>
       {
      /* Stops the timer */
      XMC_CCU8_SLICE_StopTimer(handle_ptr->ccu8_slice_ptr);
 8026304:	6a83      	ldr	r3, [r0, #40]	; 0x28
       }
#endif
    status = TIMER_STATUS_SUCCESS;
 8026306:	2000      	movs	r0, #0
 *  XMC_CCU8_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_StopTimer(XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_StopTimer:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU8_CC8_TCCLR_TRBC_Msk;
 8026308:	611a      	str	r2, [r3, #16]
 802630a:	4770      	bx	lr
    status = XMC_CCU4_SLICE_IsTimerRunning(handle_ptr->ccu4_slice_ptr);
  }
#endif

#ifdef TIMER_CCU8_USED
  if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
 802630c:	2a01      	cmp	r2, #1
 802630e:	d001      	beq.n	8026314 <TIMER_Stop+0x2c>
#endif
    status = TIMER_STATUS_SUCCESS;
  }
  else
  {
    status = TIMER_STATUS_FAILURE;
 8026310:	2001      	movs	r0, #1
 8026312:	4770      	bx	lr

#ifdef TIMER_CCU8_USED
  if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
  {
    /* Returns the current status of the timer */
    status = XMC_CCU8_SLICE_IsTimerRunning(handle_ptr->ccu8_slice_ptr);
 8026314:	6a83      	ldr	r3, [r0, #40]	; 0x28
 *  XMC_CCU8_SLICE_StartTimer()<BR>  XMC_CCU8_SLICE_StopTimer().
 */
__STATIC_INLINE bool XMC_CCU8_SLICE_IsTimerRunning(const XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_GetTimerStatus:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  return(bool)(((slice->TCST) & CCU8_CC8_TCST_TRB_Msk) == (uint32_t)CCU8_CC8_TCST_TRB_Msk);
 8026316:	689b      	ldr	r3, [r3, #8]
 8026318:	f003 0301 	and.w	r3, r3, #1
 802631c:	e7eb      	b.n	80262f6 <TIMER_Stop+0xe>
  {
#ifdef TIMER_CCU4_USED
    if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
    {
      /* Stops the timer */
      XMC_CCU4_SLICE_StopTimer(handle_ptr->ccu4_slice_ptr);
 802631e:	6943      	ldr	r3, [r0, #20]
 *  XMC_CCU4_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_StopTimer(XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_StopTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TRBC_Msk;
 8026320:	2101      	movs	r1, #1
       {
      /* Stops the timer */
      XMC_CCU8_SLICE_StopTimer(handle_ptr->ccu8_slice_ptr);
       }
#endif
    status = TIMER_STATUS_SUCCESS;
 8026322:	4610      	mov	r0, r2
 8026324:	6119      	str	r1, [r3, #16]
 8026326:	4770      	bx	lr
 8026328:	2000      	movs	r0, #0
  {
    status = TIMER_STATUS_FAILURE;
  }

  return (status);
}
 802632a:	4770      	bx	lr

0802632c <TIMER_GetTimerStatus>:
  XMC_ASSERT("TIMER_GetTimerStatus:handle_ptr NULL" , (handle_ptr != NULL));

  status = false;

#ifdef TIMER_CCU4_USED
  if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 802632c:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 8026330:	b923      	cbnz	r3, 802633c <TIMER_GetTimerStatus+0x10>
  {
    /* Returns the current status of the timer */
    status = XMC_CCU4_SLICE_IsTimerRunning(handle_ptr->ccu4_slice_ptr);
 8026332:	6943      	ldr	r3, [r0, #20]
 *  XMC_CCU4_SLICE_StartTimer()<BR> XMC_CCU4_SLICE_StopTimer().
 */
__STATIC_INLINE bool XMC_CCU4_SLICE_IsTimerRunning(const XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_GetTimerStatus:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  return (bool)(((slice->TCST) & CCU4_CC4_TCST_TRB_Msk) == CCU4_CC4_TCST_TRB_Msk);
 8026334:	6898      	ldr	r0, [r3, #8]
 8026336:	f000 0001 	and.w	r0, r0, #1
 802633a:	4770      	bx	lr
  }
#endif

#ifdef TIMER_CCU8_USED
  if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
 802633c:	2b01      	cmp	r3, #1
  {
    /* Returns the current status of the timer */
    status = XMC_CCU8_SLICE_IsTimerRunning(handle_ptr->ccu8_slice_ptr);
 802633e:	bf03      	ittte	eq
 8026340:	6a83      	ldreq	r3, [r0, #40]	; 0x28
 8026342:	6898      	ldreq	r0, [r3, #8]
 8026344:	f000 0001 	andeq.w	r0, r0, #1
{
  bool status;

  XMC_ASSERT("TIMER_GetTimerStatus:handle_ptr NULL" , (handle_ptr != NULL));

  status = false;
 8026348:	2000      	movne	r0, #0
    status = XMC_CCU8_SLICE_IsTimerRunning(handle_ptr->ccu8_slice_ptr);
  }
#endif

  return (status);
}
 802634a:	4770      	bx	lr
 802634c:	0000      	movs	r0, r0
	...

08026350 <TIMER_SetTimeInterval>:
/*
 * This function changes the PWM period which in turn changes the time tick interval value by checking that
 * the given time tick value is within supported range.
 */
TIMER_STATUS_t TIMER_SetTimeInterval(TIMER_t  *const handle_ptr, uint32_t time_interval)
{
 8026350:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  XMC_ASSERT("TIMER_GetTimerStatus:handle_ptr NULL" , (handle_ptr != NULL));

  status = false;

#ifdef TIMER_CCU4_USED
  if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8026354:	f890 6035 	ldrb.w	r6, [r0, #53]	; 0x35
 8026358:	2e00      	cmp	r6, #0
 802635a:	d15f      	bne.n	802641c <TIMER_SetTimeInterval+0xcc>
  {
    /* Returns the current status of the timer */
    status = XMC_CCU4_SLICE_IsTimerRunning(handle_ptr->ccu4_slice_ptr);
 802635c:	6943      	ldr	r3, [r0, #20]
 802635e:	689b      	ldr	r3, [r3, #8]
 8026360:	f003 0301 	and.w	r3, r3, #1

  XMC_ASSERT("TIMER_SetTimeInterval:handle_ptr NULL" , (handle_ptr != NULL));

  status = TIMER_STATUS_FAILURE;

  if (false == TIMER_GetTimerStatus(handle_ptr))
 8026364:	2b00      	cmp	r3, #0
 8026366:	d156      	bne.n	8026416 <TIMER_SetTimeInterval+0xc6>
  {
    /* check for time_interval range */
    if ((time_interval >= handle_ptr->timer_min_value_us) && (time_interval <= handle_ptr->timer_max_value_us))
 8026368:	6883      	ldr	r3, [r0, #8]
 802636a:	428b      	cmp	r3, r1
 802636c:	d853      	bhi.n	8026416 <TIMER_SetTimeInterval+0xc6>
 802636e:	6845      	ldr	r5, [r0, #4]
 8026370:	42a9      	cmp	r1, r5
 8026372:	d850      	bhi.n	8026416 <TIMER_SetTimeInterval+0xc6>
    {
      /* Initialize the prescaler */
      lprescaler = 0U;
      while (time_interval > (handle_ptr->timer_max_value_us >> (TIMER_PRESCALER_MAX - lprescaler)))
 8026374:	ebb1 3fd5 	cmp.w	r1, r5, lsr #15
 8026378:	f240 8091 	bls.w	802649e <TIMER_SetTimeInterval+0x14e>
 802637c:	2300      	movs	r3, #0
 802637e:	f1c3 020e 	rsb	r2, r3, #14
 8026382:	fa25 f202 	lsr.w	r2, r5, r2
      {
        lprescaler++;
 8026386:	1c5c      	adds	r4, r3, #1
    /* check for time_interval range */
    if ((time_interval >= handle_ptr->timer_min_value_us) && (time_interval <= handle_ptr->timer_max_value_us))
    {
      /* Initialize the prescaler */
      lprescaler = 0U;
      while (time_interval > (handle_ptr->timer_max_value_us >> (TIMER_PRESCALER_MAX - lprescaler)))
 8026388:	4291      	cmp	r1, r2
      {
        lprescaler++;
 802638a:	4623      	mov	r3, r4
    /* check for time_interval range */
    if ((time_interval >= handle_ptr->timer_min_value_us) && (time_interval <= handle_ptr->timer_max_value_us))
    {
      /* Initialize the prescaler */
      lprescaler = 0U;
      while (time_interval > (handle_ptr->timer_max_value_us >> (TIMER_PRESCALER_MAX - lprescaler)))
 802638c:	d8f7      	bhi.n	802637e <TIMER_SetTimeInterval+0x2e>
 802638e:	460d      	mov	r5, r1
 8026390:	4607      	mov	r7, r0
      {
        lprescaler++;
      }
#ifdef TIMER_CCU4_USED
      if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8026392:	2e00      	cmp	r6, #0
 8026394:	d04b      	beq.n	802642e <TIMER_SetTimeInterval+0xde>
  uint32_t lfrequency;
  uint32_t lprescaler;

  XMC_ASSERT("TIMER_SetTimeInterval:handle_ptr NULL" , (handle_ptr != NULL));

  status = TIMER_STATUS_FAILURE;
 8026396:	2001      	movs	r0, #1
        status = TIMER_STATUS_SUCCESS;
      }
#endif

#ifdef TIMER_CCU8_USED
      if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
 8026398:	2e01      	cmp	r6, #1
 802639a:	d13d      	bne.n	8026418 <TIMER_SetTimeInterval+0xc8>
      {
        handle_ptr->ccu8_slice_config_ptr->prescaler_initval = lprescaler;
        lfrequency = handle_ptr->global_ccu8_handler->module_frequency;
 802639c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
#endif

#ifdef TIMER_CCU8_USED
      if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
      {
        handle_ptr->ccu8_slice_config_ptr->prescaler_initval = lprescaler;
 802639e:	f8d7 e030 	ldr.w	lr, [r7, #48]	; 0x30
        lfrequency = handle_ptr->global_ccu8_handler->module_frequency;
 80263a2:	681a      	ldr	r2, [r3, #0]
#endif

#ifdef TIMER_CCU8_USED
      if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
      {
        handle_ptr->ccu8_slice_config_ptr->prescaler_initval = lprescaler;
 80263a4:	f89e c00c 	ldrb.w	ip, [lr, #12]
 80263a8:	f004 060f 	and.w	r6, r4, #15
        lfrequency = handle_ptr->global_ccu8_handler->module_frequency;
        /* Calculate the period register for the required time_interval value */
        handle_ptr->period_value = (uint16_t)((((uint64_t)time_interval * lfrequency) >> \
 80263ac:	fba5 2302 	umull	r2, r3, r5, r2
 80263b0:	f1c6 0120 	rsb	r1, r6, #32
 80263b4:	fa22 f006 	lsr.w	r0, r2, r6
 80263b8:	fa03 f101 	lsl.w	r1, r3, r1
 80263bc:	f1a6 0220 	sub.w	r2, r6, #32
#endif

#ifdef TIMER_CCU8_USED
      if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
      {
        handle_ptr->ccu8_slice_config_ptr->prescaler_initval = lprescaler;
 80263c0:	f364 0c03 	bfi	ip, r4, #0, #4
        lfrequency = handle_ptr->global_ccu8_handler->module_frequency;
        /* Calculate the period register for the required time_interval value */
        handle_ptr->period_value = (uint16_t)((((uint64_t)time_interval * lfrequency) >> \
 80263c4:	4308      	orrs	r0, r1
 80263c6:	fa23 f202 	lsr.w	r2, r3, r2
#endif

#ifdef TIMER_CCU8_USED
      if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
      {
        handle_ptr->ccu8_slice_config_ptr->prescaler_initval = lprescaler;
 80263ca:	f88e c00c 	strb.w	ip, [lr, #12]
        lfrequency = handle_ptr->global_ccu8_handler->module_frequency;
        /* Calculate the period register for the required time_interval value */
        handle_ptr->period_value = (uint16_t)((((uint64_t)time_interval * lfrequency) >> \
                                               handle_ptr->ccu8_slice_config_ptr->prescaler_initval) / \
 80263ce:	fa23 f106 	lsr.w	r1, r3, r6
 80263d2:	4310      	orrs	r0, r2
 80263d4:	a334      	add	r3, pc, #208	; (adr r3, 80264a8 <TIMER_SetTimeInterval+0x158>)
 80263d6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80263da:	f004 f85d 	bl	802a498 <__aeabi_uldivmod>
      if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
      {
        handle_ptr->ccu8_slice_config_ptr->prescaler_initval = lprescaler;
        lfrequency = handle_ptr->global_ccu8_handler->module_frequency;
        /* Calculate the period register for the required time_interval value */
        handle_ptr->period_value = (uint16_t)((((uint64_t)time_interval * lfrequency) >> \
 80263de:	b280      	uxth	r0, r0
                                               handle_ptr->ccu8_slice_config_ptr->prescaler_initval) / \
                                              TIMER_RESOLUTION_SEC_TO_MICRO);
        /* Actual timer period values is Period_reg_val+1U */
        if (handle_ptr->period_value > TIMER_PERIOD_MIN)
 80263e0:	2801      	cmp	r0, #1
        {
          (handle_ptr->period_value)--;
 80263e2:	bf88      	it	hi
 80263e4:	f100 30ff 	addhi.w	r0, r0, #4294967295
#endif

#ifdef TIMER_CCU8_USED
      if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
      {
        handle_ptr->ccu8_slice_config_ptr->prescaler_initval = lprescaler;
 80263e8:	b2e1      	uxtb	r1, r4
                                               handle_ptr->ccu8_slice_config_ptr->prescaler_initval) / \
                                              TIMER_RESOLUTION_SEC_TO_MICRO);
        /* Actual timer period values is Period_reg_val+1U */
        if (handle_ptr->period_value > TIMER_PERIOD_MIN)
        {
          (handle_ptr->period_value)--;
 80263ea:	86f8      	strh	r0, [r7, #54]	; 0x36
        }
        /* Update the prescaler */
        XMC_CCU8_SLICE_SetPrescaler(handle_ptr->ccu8_slice_ptr, handle_ptr->ccu8_slice_config_ptr->prescaler_initval);
 80263ec:	f001 010f 	and.w	r1, r1, #15
 80263f0:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80263f2:	f7fb fbe7 	bl	8021bc4 <XMC_CCU8_SLICE_SetPrescaler>
 * This function configures timer period and compare values and triggers the shadow transfer operation
 */
void TIMER_CCU8_lShadowTransfer(TIMER_t* const handle_ptr)
{
  /* programs the timer period register according to time interval value */
  XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, handle_ptr->period_value);
 80263f6:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80263f8:	8ef9      	ldrh	r1, [r7, #54]	; 0x36
 80263fa:	f7fb fbe1 	bl	8021bc0 <XMC_CCU8_SLICE_SetTimerPeriodMatch>
  /* programs the timer compare register for 50% duty cycle in compare channel 1*/
  XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr,
 80263fe:	2100      	movs	r1, #0
 8026400:	460a      	mov	r2, r1
 8026402:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8026404:	f7fb fbe6 	bl	8021bd4 <XMC_CCU8_SLICE_SetTimerCompareMatch>
                                      XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
                                      TIMER_CMP_100_DUTY);
  /* Transfers value from shadow timer registers to actual timer registers */
  XMC_CCU8_EnableShadowTransfer(handle_ptr->global_ccu8_handler->module_ptr, handle_ptr->shadow_mask);
 8026408:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802640a:	68fa      	ldr	r2, [r7, #12]
 802640c:	689b      	ldr	r3, [r3, #8]
        /* Update the prescaler */
        XMC_CCU8_SLICE_SetPrescaler(handle_ptr->ccu8_slice_ptr, handle_ptr->ccu8_slice_config_ptr->prescaler_initval);
        /* update period, compare and prescaler values */
        TIMER_CCU8_lShadowTransfer(handle_ptr);
        /* Update the status */
        status = TIMER_STATUS_SUCCESS;
 802640e:	2000      	movs	r0, #0
 *  None.
 */
__STATIC_INLINE void XMC_CCU8_EnableShadowTransfer(XMC_CCU8_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
  XMC_ASSERT("XMC_CCU8_EnableShadowTransfer:Invalid module Pointer", XMC_CCU8_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;  
 8026410:	611a      	str	r2, [r3, #16]
 8026412:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  uint32_t lfrequency;
  uint32_t lprescaler;

  XMC_ASSERT("TIMER_SetTimeInterval:handle_ptr NULL" , (handle_ptr != NULL));

  status = TIMER_STATUS_FAILURE;
 8026416:	2001      	movs	r0, #1
      }
#endif
    }
  }
  return (status);
}
 8026418:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    status = XMC_CCU4_SLICE_IsTimerRunning(handle_ptr->ccu4_slice_ptr);
  }
#endif

#ifdef TIMER_CCU8_USED
  if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
 802641c:	2e01      	cmp	r6, #1
 802641e:	d1a3      	bne.n	8026368 <TIMER_SetTimeInterval+0x18>
  {
    /* Returns the current status of the timer */
    status = XMC_CCU8_SLICE_IsTimerRunning(handle_ptr->ccu8_slice_ptr);
 8026420:	6a83      	ldr	r3, [r0, #40]	; 0x28
 *  XMC_CCU8_SLICE_StartTimer()<BR>  XMC_CCU8_SLICE_StopTimer().
 */
__STATIC_INLINE bool XMC_CCU8_SLICE_IsTimerRunning(const XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_GetTimerStatus:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  return(bool)(((slice->TCST) & CCU8_CC8_TCST_TRB_Msk) == (uint32_t)CCU8_CC8_TCST_TRB_Msk);
 8026422:	689b      	ldr	r3, [r3, #8]
 8026424:	f003 0301 	and.w	r3, r3, #1

  XMC_ASSERT("TIMER_SetTimeInterval:handle_ptr NULL" , (handle_ptr != NULL));

  status = TIMER_STATUS_FAILURE;

  if (false == TIMER_GetTimerStatus(handle_ptr))
 8026428:	2b00      	cmp	r3, #0
 802642a:	d09d      	beq.n	8026368 <TIMER_SetTimeInterval+0x18>
 802642c:	e7f3      	b.n	8026416 <TIMER_SetTimeInterval+0xc6>
        lprescaler++;
      }
#ifdef TIMER_CCU4_USED
      if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
      {
        lfrequency = handle_ptr->global_ccu4_handler->module_frequency;
 802642e:	6903      	ldr	r3, [r0, #16]
        handle_ptr->ccu4_slice_config_ptr->prescaler_initval = lprescaler;
 8026430:	69c6      	ldr	r6, [r0, #28]
        lprescaler++;
      }
#ifdef TIMER_CCU4_USED
      if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
      {
        lfrequency = handle_ptr->global_ccu4_handler->module_frequency;
 8026432:	681a      	ldr	r2, [r3, #0]
        handle_ptr->ccu4_slice_config_ptr->prescaler_initval = lprescaler;
 8026434:	f896 e004 	ldrb.w	lr, [r6, #4]
 8026438:	f004 030f 	and.w	r3, r4, #15
        /* Calculate the period register for the required time_interval value */
        handle_ptr->period_value = (uint16_t)((((uint64_t)time_interval * lfrequency) >> \
 802643c:	fba1 8902 	umull	r8, r9, r1, r2
 8026440:	f1c3 0120 	rsb	r1, r3, #32
 8026444:	fa28 f003 	lsr.w	r0, r8, r3
 8026448:	fa09 f101 	lsl.w	r1, r9, r1
 802644c:	f1a3 0220 	sub.w	r2, r3, #32
      }
#ifdef TIMER_CCU4_USED
      if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
      {
        lfrequency = handle_ptr->global_ccu4_handler->module_frequency;
        handle_ptr->ccu4_slice_config_ptr->prescaler_initval = lprescaler;
 8026450:	f364 0e03 	bfi	lr, r4, #0, #4
        /* Calculate the period register for the required time_interval value */
        handle_ptr->period_value = (uint16_t)((((uint64_t)time_interval * lfrequency) >> \
 8026454:	4308      	orrs	r0, r1
 8026456:	fa29 f202 	lsr.w	r2, r9, r2
      }
#ifdef TIMER_CCU4_USED
      if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
      {
        lfrequency = handle_ptr->global_ccu4_handler->module_frequency;
        handle_ptr->ccu4_slice_config_ptr->prescaler_initval = lprescaler;
 802645a:	f886 e004 	strb.w	lr, [r6, #4]
        /* Calculate the period register for the required time_interval value */
        handle_ptr->period_value = (uint16_t)((((uint64_t)time_interval * lfrequency) >> \
                                               handle_ptr->ccu4_slice_config_ptr->prescaler_initval) / \
 802645e:	4310      	orrs	r0, r2
 8026460:	fa29 f103 	lsr.w	r1, r9, r3
 8026464:	a310      	add	r3, pc, #64	; (adr r3, 80264a8 <TIMER_SetTimeInterval+0x158>)
 8026466:	e9d3 2300 	ldrd	r2, r3, [r3]
 802646a:	f004 f815 	bl	802a498 <__aeabi_uldivmod>
      if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
      {
        lfrequency = handle_ptr->global_ccu4_handler->module_frequency;
        handle_ptr->ccu4_slice_config_ptr->prescaler_initval = lprescaler;
        /* Calculate the period register for the required time_interval value */
        handle_ptr->period_value = (uint16_t)((((uint64_t)time_interval * lfrequency) >> \
 802646e:	b280      	uxth	r0, r0
                                               handle_ptr->ccu4_slice_config_ptr->prescaler_initval) / \
                                              TIMER_RESOLUTION_SEC_TO_MICRO);
        /* Actual timer period values is Period_reg_val+1U */
        if (handle_ptr->period_value > TIMER_PERIOD_MIN)
 8026470:	2801      	cmp	r0, #1
        {
          (handle_ptr->period_value)--;
 8026472:	bf88      	it	hi
 8026474:	f100 30ff 	addhi.w	r0, r0, #4294967295
      }
#ifdef TIMER_CCU4_USED
      if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
      {
        lfrequency = handle_ptr->global_ccu4_handler->module_frequency;
        handle_ptr->ccu4_slice_config_ptr->prescaler_initval = lprescaler;
 8026478:	b2e1      	uxtb	r1, r4
                                               handle_ptr->ccu4_slice_config_ptr->prescaler_initval) / \
                                              TIMER_RESOLUTION_SEC_TO_MICRO);
        /* Actual timer period values is Period_reg_val+1U */
        if (handle_ptr->period_value > TIMER_PERIOD_MIN)
        {
          (handle_ptr->period_value)--;
 802647a:	86f8      	strh	r0, [r7, #54]	; 0x36
        }
        /* Update the prescaler */
        XMC_CCU4_SLICE_SetPrescaler(handle_ptr->ccu4_slice_ptr, handle_ptr->ccu4_slice_config_ptr->prescaler_initval);
 802647c:	f001 010f 	and.w	r1, r1, #15
 8026480:	6978      	ldr	r0, [r7, #20]
 8026482:	f7fb fb2f 	bl	8021ae4 <XMC_CCU4_SLICE_SetPrescaler>
  /* programs the timer period register according to time interval value */
  XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr, handle_ptr->period_value);
  /* programs the timer compare register for 50% duty cycle */
  XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr, TIMER_CMP_100_DUTY);
  /* Transfers value from shadow timer registers to actual timer registers */
  XMC_CCU4_EnableShadowTransfer(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->shadow_mask);
 8026486:	693a      	ldr	r2, [r7, #16]
 * This function configures timer period and compare values and triggers the shadow transfer operation
 */
void TIMER_CCU4_lShadowTransfer(TIMER_t* const handle_ptr)
{
  /* programs the timer period register according to time interval value */
  XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr, handle_ptr->period_value);
 8026488:	697b      	ldr	r3, [r7, #20]
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerPeriodMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t period_val)
{
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->PRS = (uint32_t) period_val;
 802648a:	8ef8      	ldrh	r0, [r7, #54]	; 0x36
  /* programs the timer compare register for 50% duty cycle */
  XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr, TIMER_CMP_100_DUTY);
  /* Transfers value from shadow timer registers to actual timer registers */
  XMC_CCU4_EnableShadowTransfer(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->shadow_mask);
 802648c:	6892      	ldr	r2, [r2, #8]
 802648e:	68f9      	ldr	r1, [r7, #12]
 8026490:	6358      	str	r0, [r3, #52]	; 0x34
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerCompareMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t compare_val)
{
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->CRS = (uint32_t) compare_val;
 8026492:	2000      	movs	r0, #0
 8026494:	63d8      	str	r0, [r3, #60]	; 0x3c
 8026496:	f897 6035 	ldrb.w	r6, [r7, #53]	; 0x35
 *  None.
 */
__STATIC_INLINE void XMC_CCU4_EnableShadowTransfer(XMC_CCU4_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
  XMC_ASSERT("XMC_CCU4_EnableShadowTransfer:Invalid Slice Pointer", XMC_CCU4_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;  
 802649a:	6111      	str	r1, [r2, #16]
 802649c:	e77c      	b.n	8026398 <TIMER_SetTimeInterval+0x48>
    /* check for time_interval range */
    if ((time_interval >= handle_ptr->timer_min_value_us) && (time_interval <= handle_ptr->timer_max_value_us))
    {
      /* Initialize the prescaler */
      lprescaler = 0U;
      while (time_interval > (handle_ptr->timer_max_value_us >> (TIMER_PRESCALER_MAX - lprescaler)))
 802649e:	2400      	movs	r4, #0
 80264a0:	e775      	b.n	802638e <TIMER_SetTimeInterval+0x3e>
 80264a2:	bf00      	nop
 80264a4:	f3af 8000 	nop.w
 80264a8:	05f5e100 	.word	0x05f5e100
 80264ac:	00000000 	.word	0x00000000

080264b0 <TIMER_GetInterruptStatus>:
{
  bool status;
  XMC_ASSERT("TIMER_GetInterruptStatus:handle_ptr NULL" , (handle_ptr != NULL));
  status = false;
#ifdef TIMER_CCU4_USED
  if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 80264b0:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 80264b4:	b92b      	cbnz	r3, 80264c2 <TIMER_GetInterruptStatus+0x12>
  {
    /* Reads the interrupt status */
    status = XMC_CCU4_SLICE_GetEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
 80264b6:	6943      	ldr	r3, [r0, #20]
__STATIC_INLINE bool XMC_CCU4_SLICE_GetEvent(const XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_IRQ_ID_t event)
{
  XMC_ASSERT("XMC_CCU4_SLICE_GetEvent:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_GetEvent:Invalid SR event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));

  return(((uint32_t)(slice->INTS & ((uint32_t)1 << (uint32_t)event))) != 0U);
 80264b8:	f8d3 00a0 	ldr.w	r0, [r3, #160]	; 0xa0
 80264bc:	f000 0001 	and.w	r0, r0, #1
 80264c0:	4770      	bx	lr
  }
#endif

#ifdef TIMER_CCU8_USED
  if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
 80264c2:	2b01      	cmp	r3, #1
  {
    /* Reads the interrupt status */
    status = XMC_CCU8_SLICE_GetEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH);
 80264c4:	bf03      	ittte	eq
 80264c6:	6a83      	ldreq	r3, [r0, #40]	; 0x28
 */
__STATIC_INLINE bool XMC_CCU8_SLICE_GetEvent(const XMC_CCU8_SLICE_t *const slice, const XMC_CCU8_SLICE_IRQ_ID_t event)
{
  XMC_ASSERT("XMC_CCU8_SLICE_GetEvent:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_GetEvent:Invalid SR event", XMC_CCU8_SLICE_CHECK_INTERRUPT(event));
  return(((uint32_t)(slice->INTS & ((uint32_t)1 << event))) != 0U);
 80264c8:	f8d3 00a0 	ldreq.w	r0, [r3, #160]	; 0xa0
 80264cc:	f000 0001 	andeq.w	r0, r0, #1
 */
bool TIMER_GetInterruptStatus(TIMER_t * const handle_ptr)
{
  bool status;
  XMC_ASSERT("TIMER_GetInterruptStatus:handle_ptr NULL" , (handle_ptr != NULL));
  status = false;
 80264d0:	2000      	movne	r0, #0
    /* Reads the interrupt status */
    status = XMC_CCU8_SLICE_GetEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH);
  }
#endif
  return (status);
}
 80264d2:	4770      	bx	lr

080264d4 <TIMER_ClearEvent>:
void TIMER_ClearEvent(TIMER_t *const handle_ptr)
{
  XMC_ASSERT("TIME_CCU_AcknowledgeInterrupt:handle_ptr NULL" , (handle_ptr != NULL));

#ifdef TIMER_CCU4_USED
  if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 80264d4:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 80264d8:	b93b      	cbnz	r3, 80264ea <TIMER_ClearEvent+0x16>
  {
    /* clears the timer event(period match interrupt) */
    XMC_CCU4_SLICE_ClearEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
 80264da:	6942      	ldr	r2, [r0, #20]
 */
__STATIC_INLINE void XMC_CCU4_SLICE_ClearEvent(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_IRQ_ID_t event)
{
  XMC_ASSERT("XMC_CCU4_SLICE_ClearEvent:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_ClearEvent:Invalid SR event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  slice->SWR |= ((uint32_t) 1) << ((uint32_t) event);
 80264dc:	f8d2 30b0 	ldr.w	r3, [r2, #176]	; 0xb0
 80264e0:	f043 0301 	orr.w	r3, r3, #1
 80264e4:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
 80264e8:	4770      	bx	lr
  }
#endif

#ifdef TIMER_CCU8_USED
  if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
 80264ea:	2b01      	cmp	r3, #1
 80264ec:	d106      	bne.n	80264fc <TIMER_ClearEvent+0x28>
  {
    /* clears the timer event(period match interrupt) */
    XMC_CCU8_SLICE_ClearEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH);
 80264ee:	6a82      	ldr	r2, [r0, #40]	; 0x28
 */
__STATIC_INLINE void XMC_CCU8_SLICE_ClearEvent(XMC_CCU8_SLICE_t *const slice, const XMC_CCU8_SLICE_IRQ_ID_t event)
{
  XMC_ASSERT("XMC_CCU8_SLICE_ClearEvent:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_ClearEvent:Invalid SR event", XMC_CCU8_SLICE_CHECK_INTERRUPT(event));
  slice->SWR |= ((uint32_t) 1) << ((uint32_t) event);
 80264f0:	f8d2 30b0 	ldr.w	r3, [r2, #176]	; 0xb0
 80264f4:	f043 0301 	orr.w	r3, r3, #1
 80264f8:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
 80264fc:	4770      	bx	lr
 80264fe:	bf00      	nop

08026500 <TIMER_Clear>:
  TIMER_STATUS_t status;

  XMC_ASSERT("TIMER_Clear:handle_ptr NULL" , (handle_ptr != NULL));

  /* Check for APP instance is initialized or not */
  if (true == handle_ptr->initialized)
 8026500:	f890 303a 	ldrb.w	r3, [r0, #58]	; 0x3a
 8026504:	b173      	cbz	r3, 8026524 <TIMER_Clear+0x24>
  {
#ifdef TIMER_CCU4_USED
    if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8026506:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 802650a:	b133      	cbz	r3, 802651a <TIMER_Clear+0x1a>
      XMC_CCU4_SLICE_ClearTimer(handle_ptr->ccu4_slice_ptr);
    }
#endif

#ifdef TIMER_CCU8_USED
    if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
 802650c:	2b01      	cmp	r3, #1
 802650e:	d10b      	bne.n	8026528 <TIMER_Clear+0x28>
    {
      /* Clear the timer register */
      XMC_CCU8_SLICE_ClearTimer(handle_ptr->ccu8_slice_ptr);
 8026510:	6a83      	ldr	r3, [r0, #40]	; 0x28
 *  XMC_CCU8_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_ClearTimer(XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_ClearTimer:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU8_CC8_TCCLR_TCC_Msk;
 8026512:	2202      	movs	r2, #2
 8026514:	611a      	str	r2, [r3, #16]
    }
#endif
    status = TIMER_STATUS_SUCCESS;
 8026516:	2000      	movs	r0, #0
 8026518:	4770      	bx	lr
  {
#ifdef TIMER_CCU4_USED
    if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
    {
      /* Clear the timer register */
      XMC_CCU4_SLICE_ClearTimer(handle_ptr->ccu4_slice_ptr);
 802651a:	6942      	ldr	r2, [r0, #20]
 *  XMC_CCU4_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_ClearTimer(XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_ClearTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TCC_Msk;
 802651c:	2102      	movs	r1, #2
    {
      /* Clear the timer register */
      XMC_CCU8_SLICE_ClearTimer(handle_ptr->ccu8_slice_ptr);
    }
#endif
    status = TIMER_STATUS_SUCCESS;
 802651e:	4618      	mov	r0, r3
 8026520:	6111      	str	r1, [r2, #16]
 8026522:	4770      	bx	lr
  }
  else
  {
    status = TIMER_STATUS_FAILURE;
 8026524:	2001      	movs	r0, #1
 8026526:	4770      	bx	lr
    {
      /* Clear the timer register */
      XMC_CCU8_SLICE_ClearTimer(handle_ptr->ccu8_slice_ptr);
    }
#endif
    status = TIMER_STATUS_SUCCESS;
 8026528:	2000      	movs	r0, #0
  {
    status = TIMER_STATUS_FAILURE;
  }

  return (status);
}
 802652a:	4770      	bx	lr

0802652c <SysTick_Handler>:
 */
void SysTick_Handler(void)
{
  SYSTIMER_OBJECT_t *object_ptr;
  object_ptr = g_timer_list;
  g_systick_count++;
 802652c:	4999      	ldr	r1, [pc, #612]	; (8026794 <SysTick_Handler+0x268>)

/*
 *  SysTick Event Handler.
 */
void SysTick_Handler(void)
{
 802652e:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  SYSTIMER_OBJECT_t *object_ptr;
  object_ptr = g_timer_list;
 8026532:	4d99      	ldr	r5, [pc, #612]	; (8026798 <SysTick_Handler+0x26c>)
  g_systick_count++;
 8026534:	680a      	ldr	r2, [r1, #0]
 *  SysTick Event Handler.
 */
void SysTick_Handler(void)
{
  SYSTIMER_OBJECT_t *object_ptr;
  object_ptr = g_timer_list;
 8026536:	682b      	ldr	r3, [r5, #0]
  g_systick_count++;
 8026538:	3201      	adds	r2, #1
 802653a:	600a      	str	r2, [r1, #0]

  if (NULL != object_ptr)
 802653c:	b133      	cbz	r3, 802654c <SysTick_Handler+0x20>
  {
    if (object_ptr->count > 1UL)
 802653e:	699a      	ldr	r2, [r3, #24]
 8026540:	2a01      	cmp	r2, #1
 8026542:	d905      	bls.n	8026550 <SysTick_Handler+0x24>
    {
      object_ptr->count--;
 8026544:	3a01      	subs	r2, #1
 8026546:	619a      	str	r2, [r3, #24]
 8026548:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802654c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    }
    else
    {
      object_ptr->count = 0U;
 8026550:	2200      	movs	r2, #0
static void SYSTIMER_lRemoveTimerList(uint32_t tbl_index)
{
  SYSTIMER_OBJECT_t *object_ptr;
  object_ptr = &g_timer_tbl[tbl_index];
  /* Check whether only one timer available */
  if ((NULL == object_ptr->prev) && (NULL == object_ptr->next ))
 8026552:	4c92      	ldr	r4, [pc, #584]	; (802679c <SysTick_Handler+0x270>)
    {
      object_ptr->count--;
    }
    else
    {
      object_ptr->count = 0U;
 8026554:	619a      	str	r2, [r3, #24]
 8026556:	e007      	b.n	8026568 <SysTick_Handler+0x3c>
      g_timer_tracker &= ~(1U << object_ptr->id);
    }
    /* Check whether timer is a one shot timer */
    else if (SYSTIMER_MODE_ONE_SHOT == object_ptr->mode)
    {
      if (SYSTIMER_STATE_RUNNING == object_ptr->state)
 8026558:	7b5a      	ldrb	r2, [r3, #13]
 802655a:	2a01      	cmp	r2, #1
 802655c:	f000 80a1 	beq.w	80266a2 <SysTick_Handler+0x176>
static void SYSTIMER_lTimerHandler(void)
{
  SYSTIMER_OBJECT_t *object_ptr;
  /* Get first item of timer list */
  object_ptr = g_timer_list;
  while ((NULL != object_ptr) && (0U == object_ptr->count))
 8026560:	699a      	ldr	r2, [r3, #24]
 8026562:	2a00      	cmp	r2, #0
 8026564:	f040 80d4 	bne.w	8026710 <SysTick_Handler+0x1e4>
  {
    if (true == object_ptr->delete_swtmr)
 8026568:	f893 2020 	ldrb.w	r2, [r3, #32]
 802656c:	2a00      	cmp	r2, #0
 802656e:	d16d      	bne.n	802664c <SysTick_Handler+0x120>
      object_ptr->state = SYSTIMER_STATE_NOT_INITIALIZED;
      /* Release resource which are hold by this timer */
      g_timer_tracker &= ~(1U << object_ptr->id);
    }
    /* Check whether timer is a one shot timer */
    else if (SYSTIMER_MODE_ONE_SHOT == object_ptr->mode)
 8026570:	7b19      	ldrb	r1, [r3, #12]
 8026572:	2900      	cmp	r1, #0
 8026574:	d0f0      	beq.n	8026558 <SysTick_Handler+0x2c>
        /* Call timer callback function */
        (object_ptr->callback)(object_ptr->args);
      }
    }
    /* Check whether timer is periodic timer */
    else if (SYSTIMER_MODE_PERIODIC == object_ptr->mode)
 8026576:	2901      	cmp	r1, #1
 8026578:	d1e8      	bne.n	802654c <SysTick_Handler+0x20>
    {
      if (SYSTIMER_STATE_RUNNING == object_ptr->state)
 802657a:	7b59      	ldrb	r1, [r3, #13]
 802657c:	2901      	cmp	r1, #1
 802657e:	d1ef      	bne.n	8026560 <SysTick_Handler+0x34>
      {
        /* Yes, remove this timer from timer list */
        SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
 8026580:	6959      	ldr	r1, [r3, #20]
static void SYSTIMER_lRemoveTimerList(uint32_t tbl_index)
{
  SYSTIMER_OBJECT_t *object_ptr;
  object_ptr = &g_timer_tbl[tbl_index];
  /* Check whether only one timer available */
  if ((NULL == object_ptr->prev) && (NULL == object_ptr->next ))
 8026582:	ea4f 0ec1 	mov.w	lr, r1, lsl #3
 8026586:	eb0e 0901 	add.w	r9, lr, r1
 802658a:	eb04 0889 	add.w	r8, r4, r9, lsl #2
 802658e:	f8d8 a004 	ldr.w	sl, [r8, #4]
 8026592:	f1ba 0f00 	cmp.w	sl, #0
 8026596:	f000 80d6 	beq.w	8026746 <SysTick_Handler+0x21a>
    g_timer_list->prev = NULL;
    g_timer_list->count += object_ptr->count;
    object_ptr->next    = NULL;
  }
  /* Check if the last item in timer list */
  else if (NULL == object_ptr->next)
 802659a:	f854 0029 	ldr.w	r0, [r4, r9, lsl #2]
  {
    /* Remove timer from list */
    object_ptr->prev->next = NULL;
 802659e:	f8ca 0000 	str.w	r0, [sl]
    g_timer_list->prev = NULL;
    g_timer_list->count += object_ptr->count;
    object_ptr->next    = NULL;
  }
  /* Check if the last item in timer list */
  else if (NULL == object_ptr->next)
 80265a2:	2800      	cmp	r0, #0
 80265a4:	f000 80f0 	beq.w	8026788 <SysTick_Handler+0x25c>
  else                       
  {
    /* Remove timer from list */
    object_ptr->prev->next  =  object_ptr->next;
    object_ptr->next->prev  =  object_ptr->prev;
    object_ptr->next->count += object_ptr->count;
 80265a8:	f854 e029 	ldr.w	lr, [r4, r9, lsl #2]
 80265ac:	f8d8 0018 	ldr.w	r0, [r8, #24]
 80265b0:	f8de b018 	ldr.w	fp, [lr, #24]
  }
  else                       
  {
    /* Remove timer from list */
    object_ptr->prev->next  =  object_ptr->next;
    object_ptr->next->prev  =  object_ptr->prev;
 80265b4:	f8ce a004 	str.w	sl, [lr, #4]
    object_ptr->next->count += object_ptr->count;
 80265b8:	4458      	add	r0, fp
 80265ba:	f8ce 0018 	str.w	r0, [lr, #24]
 80265be:	682f      	ldr	r7, [r5, #0]
    object_ptr->next = NULL;
 80265c0:	f844 2029 	str.w	r2, [r4, r9, lsl #2]
    object_ptr->prev = NULL;
 80265c4:	f8c8 2004 	str.w	r2, [r8, #4]
  SYSTIMER_OBJECT_t *object_ptr;
  int32_t delta_ticks;
  int32_t timer_count;
  bool found_flag = false;
   /* Get timer time */
  timer_count = (int32_t)g_timer_tbl[tbl_index].count;
 80265c8:	ea4f 0ec1 	mov.w	lr, r1, lsl #3
 80265cc:	eb0e 0001 	add.w	r0, lr, r1
 80265d0:	eb04 0080 	add.w	r0, r4, r0, lsl #2
      if (SYSTIMER_STATE_RUNNING == object_ptr->state)
      {
        /* Yes, remove this timer from timer list */
        SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
        /* Reset timer tick */
        object_ptr->count = object_ptr->reload;
 80265d4:	69da      	ldr	r2, [r3, #28]
 80265d6:	619a      	str	r2, [r3, #24]
  SYSTIMER_OBJECT_t *object_ptr;
  int32_t delta_ticks;
  int32_t timer_count;
  bool found_flag = false;
   /* Get timer time */
  timer_count = (int32_t)g_timer_tbl[tbl_index].count;
 80265d8:	6980      	ldr	r0, [r0, #24]
  /* Check if Timer list is NULL */
  if (NULL == g_timer_list)
 80265da:	2f00      	cmp	r7, #0
 80265dc:	f000 80ca 	beq.w	8026774 <SysTick_Handler+0x248>
 80265e0:	f8d5 c000 	ldr.w	ip, [r5]
 80265e4:	463a      	mov	r2, r7
    delta_ticks = timer_count;
    /* Find correct place for inserting the timer */
    while ((NULL != object_ptr) && (false == found_flag))
    {
      /* Get timer Count Difference */
      delta_ticks -= (int32_t)object_ptr->count;
 80265e6:	6997      	ldr	r7, [r2, #24]
 80265e8:	1bc0      	subs	r0, r0, r7
      /* Check for delta ticks < 0 */
      if (delta_ticks <= 0)
 80265ea:	2800      	cmp	r0, #0
 80265ec:	dd08      	ble.n	8026600 <SysTick_Handler+0xd4>
        found_flag = true;
      }
      /* Check for last item in list */
      else
      {
        if ((delta_ticks > 0) && (NULL == object_ptr->next))
 80265ee:	6817      	ldr	r7, [r2, #0]
 80265f0:	2f00      	cmp	r7, #0
 80265f2:	f000 8086 	beq.w	8026702 <SysTick_Handler+0x1d6>
 80265f6:	463a      	mov	r2, r7
    delta_ticks = timer_count;
    /* Find correct place for inserting the timer */
    while ((NULL != object_ptr) && (false == found_flag))
    {
      /* Get timer Count Difference */
      delta_ticks -= (int32_t)object_ptr->count;
 80265f8:	6997      	ldr	r7, [r2, #24]
 80265fa:	1bc0      	subs	r0, r0, r7
      /* Check for delta ticks < 0 */
      if (delta_ticks <= 0)
 80265fc:	2800      	cmp	r0, #0
 80265fe:	dcf6      	bgt.n	80265ee <SysTick_Handler+0xc2>
      {
        /* Check If head item */
        if (NULL != object_ptr->prev)
 8026600:	6857      	ldr	r7, [r2, #4]
 8026602:	2f00      	cmp	r7, #0
 8026604:	f000 808a 	beq.w	802671c <SysTick_Handler+0x1f0>
        {
          /* If Insert to list */
          object_ptr->prev->next = &g_timer_tbl[tbl_index];
 8026608:	eb0e 0901 	add.w	r9, lr, r1
 802660c:	eb04 0889 	add.w	r8, r4, r9, lsl #2
 8026610:	f8c7 8000 	str.w	r8, [r7]
          g_timer_tbl[tbl_index].prev = object_ptr->prev;
 8026614:	f8c8 7004 	str.w	r7, [r8, #4]
          g_timer_tbl[tbl_index].next = object_ptr;
 8026618:	f844 2029 	str.w	r2, [r4, r9, lsl #2]
          object_ptr->prev = &g_timer_tbl[tbl_index];
 802661c:	f8c2 8004 	str.w	r8, [r2, #4]
          /* Set Timer as first item */
          g_timer_tbl[tbl_index].next = g_timer_list;
          g_timer_list->prev = &g_timer_tbl[tbl_index];
          g_timer_list = &g_timer_tbl[tbl_index];
        }
        g_timer_tbl[tbl_index].count = g_timer_tbl[tbl_index].next->count + (uint32_t)delta_ticks;
 8026620:	4471      	add	r1, lr
 8026622:	eb04 0e81 	add.w	lr, r4, r1, lsl #2
 8026626:	f854 1021 	ldr.w	r1, [r4, r1, lsl #2]
 802662a:	698a      	ldr	r2, [r1, #24]
 802662c:	4410      	add	r0, r2
 802662e:	f8ce 0018 	str.w	r0, [lr, #24]
        g_timer_tbl[tbl_index].next->count  -= g_timer_tbl[tbl_index].count;
 8026632:	698a      	ldr	r2, [r1, #24]
 8026634:	1a10      	subs	r0, r2, r0
 8026636:	6188      	str	r0, [r1, #24]
 8026638:	f8c5 c000 	str.w	ip, [r5]
        /* Reset timer tick */
        object_ptr->count = object_ptr->reload;
        /* Insert timer into timer list */
        SYSTIMER_lInsertTimerList((uint32_t)object_ptr->id);
        /* Call timer callback function */
        (object_ptr->callback)(object_ptr->args);
 802663c:	689a      	ldr	r2, [r3, #8]
 802663e:	6918      	ldr	r0, [r3, #16]
 8026640:	4790      	blx	r2
 8026642:	682a      	ldr	r2, [r5, #0]
static void SYSTIMER_lTimerHandler(void)
{
  SYSTIMER_OBJECT_t *object_ptr;
  /* Get first item of timer list */
  object_ptr = g_timer_list;
  while ((NULL != object_ptr) && (0U == object_ptr->count))
 8026644:	2a00      	cmp	r2, #0
 8026646:	d081      	beq.n	802654c <SysTick_Handler+0x20>
 8026648:	4613      	mov	r3, r2
 802664a:	e789      	b.n	8026560 <SysTick_Handler+0x34>
  {
    if (true == object_ptr->delete_swtmr)
    {
      /* Yes, remove this timer from timer list */
      SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
 802664c:	6959      	ldr	r1, [r3, #20]
static void SYSTIMER_lRemoveTimerList(uint32_t tbl_index)
{
  SYSTIMER_OBJECT_t *object_ptr;
  object_ptr = &g_timer_tbl[tbl_index];
  /* Check whether only one timer available */
  if ((NULL == object_ptr->prev) && (NULL == object_ptr->next ))
 802664e:	eb01 0ec1 	add.w	lr, r1, r1, lsl #3
 8026652:	eb04 088e 	add.w	r8, r4, lr, lsl #2
 8026656:	f8d8 c004 	ldr.w	ip, [r8, #4]
 802665a:	f1bc 0f00 	cmp.w	ip, #0
 802665e:	d041      	beq.n	80266e4 <SysTick_Handler+0x1b8>
    g_timer_list->prev = NULL;
    g_timer_list->count += object_ptr->count;
    object_ptr->next    = NULL;
  }
  /* Check if the last item in timer list */
  else if (NULL == object_ptr->next)
 8026660:	f854 002e 	ldr.w	r0, [r4, lr, lsl #2]
  {
    /* Remove timer from list */
    object_ptr->prev->next = NULL;
 8026664:	f8cc 0000 	str.w	r0, [ip]
    g_timer_list->prev = NULL;
    g_timer_list->count += object_ptr->count;
    object_ptr->next    = NULL;
  }
  /* Check if the last item in timer list */
  else if (NULL == object_ptr->next)
 8026668:	2800      	cmp	r0, #0
 802666a:	d053      	beq.n	8026714 <SysTick_Handler+0x1e8>
  else                       
  {
    /* Remove timer from list */
    object_ptr->prev->next  =  object_ptr->next;
    object_ptr->next->prev  =  object_ptr->prev;
    object_ptr->next->count += object_ptr->count;
 802666c:	f854 002e 	ldr.w	r0, [r4, lr, lsl #2]
 8026670:	f8d8 2018 	ldr.w	r2, [r8, #24]
 8026674:	6987      	ldr	r7, [r0, #24]
  }
  else                       
  {
    /* Remove timer from list */
    object_ptr->prev->next  =  object_ptr->next;
    object_ptr->next->prev  =  object_ptr->prev;
 8026676:	f8c0 c004 	str.w	ip, [r0, #4]
    object_ptr->next->count += object_ptr->count;
 802667a:	443a      	add	r2, r7
    object_ptr->next = NULL;
 802667c:	2700      	movs	r7, #0
  else                       
  {
    /* Remove timer from list */
    object_ptr->prev->next  =  object_ptr->next;
    object_ptr->next->prev  =  object_ptr->prev;
    object_ptr->next->count += object_ptr->count;
 802667e:	6182      	str	r2, [r0, #24]
    object_ptr->next = NULL;
 8026680:	f844 702e 	str.w	r7, [r4, lr, lsl #2]
    object_ptr->prev = NULL;
 8026684:	f8c8 7004 	str.w	r7, [r8, #4]
 8026688:	461a      	mov	r2, r3
      /* Yes, remove this timer from timer list */
      SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
      /* Set timer status as SYSTIMER_STATE_NOT_INITIALIZED */
      object_ptr->state = SYSTIMER_STATE_NOT_INITIALIZED;
      /* Release resource which are hold by this timer */
      g_timer_tracker &= ~(1U << object_ptr->id);
 802668a:	4845      	ldr	r0, [pc, #276]	; (80267a0 <SysTick_Handler+0x274>)
 802668c:	4e44      	ldr	r6, [pc, #272]	; (80267a0 <SysTick_Handler+0x274>)
 802668e:	6800      	ldr	r0, [r0, #0]
 8026690:	2701      	movs	r7, #1
 8026692:	fa07 f101 	lsl.w	r1, r7, r1
 8026696:	ea20 0001 	bic.w	r0, r0, r1
    if (true == object_ptr->delete_swtmr)
    {
      /* Yes, remove this timer from timer list */
      SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
      /* Set timer status as SYSTIMER_STATE_NOT_INITIALIZED */
      object_ptr->state = SYSTIMER_STATE_NOT_INITIALIZED;
 802669a:	2100      	movs	r1, #0
      /* Release resource which are hold by this timer */
      g_timer_tracker &= ~(1U << object_ptr->id);
 802669c:	6030      	str	r0, [r6, #0]
    if (true == object_ptr->delete_swtmr)
    {
      /* Yes, remove this timer from timer list */
      SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
      /* Set timer status as SYSTIMER_STATE_NOT_INITIALIZED */
      object_ptr->state = SYSTIMER_STATE_NOT_INITIALIZED;
 802669e:	7359      	strb	r1, [r3, #13]
 80266a0:	e7d0      	b.n	8026644 <SysTick_Handler+0x118>
    else if (SYSTIMER_MODE_ONE_SHOT == object_ptr->mode)
    {
      if (SYSTIMER_STATE_RUNNING == object_ptr->state)
      {
        /* Yes, remove this timer from timer list */
        SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
 80266a2:	695a      	ldr	r2, [r3, #20]
static void SYSTIMER_lRemoveTimerList(uint32_t tbl_index)
{
  SYSTIMER_OBJECT_t *object_ptr;
  object_ptr = &g_timer_tbl[tbl_index];
  /* Check whether only one timer available */
  if ((NULL == object_ptr->prev) && (NULL == object_ptr->next ))
 80266a4:	eb02 0ec2 	add.w	lr, r2, r2, lsl #3
 80266a8:	eb04 088e 	add.w	r8, r4, lr, lsl #2
 80266ac:	f854 202e 	ldr.w	r2, [r4, lr, lsl #2]
 80266b0:	f8d8 7004 	ldr.w	r7, [r8, #4]
 80266b4:	2f00      	cmp	r7, #0
 80266b6:	d03b      	beq.n	8026730 <SysTick_Handler+0x204>
  }
  /* Check if the last item in timer list */
  else if (NULL == object_ptr->next)
  {
    /* Remove timer from list */
    object_ptr->prev->next = NULL;
 80266b8:	603a      	str	r2, [r7, #0]
    g_timer_list->prev = NULL;
    g_timer_list->count += object_ptr->count;
    object_ptr->next    = NULL;
  }
  /* Check if the last item in timer list */
  else if (NULL == object_ptr->next)
 80266ba:	2a00      	cmp	r2, #0
 80266bc:	d061      	beq.n	8026782 <SysTick_Handler+0x256>
  else                       
  {
    /* Remove timer from list */
    object_ptr->prev->next  =  object_ptr->next;
    object_ptr->next->prev  =  object_ptr->prev;
    object_ptr->next->count += object_ptr->count;
 80266be:	f854 002e 	ldr.w	r0, [r4, lr, lsl #2]
 80266c2:	f8d8 2018 	ldr.w	r2, [r8, #24]
 80266c6:	6986      	ldr	r6, [r0, #24]
  }
  else                       
  {
    /* Remove timer from list */
    object_ptr->prev->next  =  object_ptr->next;
    object_ptr->next->prev  =  object_ptr->prev;
 80266c8:	6047      	str	r7, [r0, #4]
    object_ptr->next->count += object_ptr->count;
 80266ca:	4432      	add	r2, r6
 80266cc:	6182      	str	r2, [r0, #24]
    object_ptr->next = NULL;
 80266ce:	f844 102e 	str.w	r1, [r4, lr, lsl #2]
    object_ptr->prev = NULL;
 80266d2:	f8c8 1004 	str.w	r1, [r8, #4]
      if (SYSTIMER_STATE_RUNNING == object_ptr->state)
      {
        /* Yes, remove this timer from timer list */
        SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
        /* Set timer status as SYSTIMER_STATE_STOPPED */
        object_ptr->state = SYSTIMER_STATE_STOPPED;
 80266d6:	2202      	movs	r2, #2
 80266d8:	735a      	strb	r2, [r3, #13]
        /* Call timer callback function */
        (object_ptr->callback)(object_ptr->args);
 80266da:	6918      	ldr	r0, [r3, #16]
 80266dc:	689a      	ldr	r2, [r3, #8]
 80266de:	4790      	blx	r2
 80266e0:	682a      	ldr	r2, [r5, #0]
 80266e2:	e7af      	b.n	8026644 <SysTick_Handler+0x118>
static void SYSTIMER_lRemoveTimerList(uint32_t tbl_index)
{
  SYSTIMER_OBJECT_t *object_ptr;
  object_ptr = &g_timer_tbl[tbl_index];
  /* Check whether only one timer available */
  if ((NULL == object_ptr->prev) && (NULL == object_ptr->next ))
 80266e4:	f854 202e 	ldr.w	r2, [r4, lr, lsl #2]
 80266e8:	2a00      	cmp	r2, #0
 80266ea:	d048      	beq.n	802677e <SysTick_Handler+0x252>
  else if (NULL == object_ptr->prev)
  {
    /* Remove timer from list, and reset timer list */
    g_timer_list  = object_ptr->next;
    g_timer_list->prev = NULL;
    g_timer_list->count += object_ptr->count;
 80266ec:	f8d8 7018 	ldr.w	r7, [r8, #24]
 80266f0:	6990      	ldr	r0, [r2, #24]
  /* Check if the first item in timer list */
  else if (NULL == object_ptr->prev)
  {
    /* Remove timer from list, and reset timer list */
    g_timer_list  = object_ptr->next;
    g_timer_list->prev = NULL;
 80266f2:	f8c2 c004 	str.w	ip, [r2, #4]
    g_timer_list->count += object_ptr->count;
 80266f6:	4438      	add	r0, r7
 80266f8:	6190      	str	r0, [r2, #24]
  }
  /* Check if the first item in timer list */
  else if (NULL == object_ptr->prev)
  {
    /* Remove timer from list, and reset timer list */
    g_timer_list  = object_ptr->next;
 80266fa:	602a      	str	r2, [r5, #0]
    g_timer_list->prev = NULL;
    g_timer_list->count += object_ptr->count;
    object_ptr->next    = NULL;
 80266fc:	f844 c02e 	str.w	ip, [r4, lr, lsl #2]
 8026700:	e7c3      	b.n	802668a <SysTick_Handler+0x15e>
      else
      {
        if ((delta_ticks > 0) && (NULL == object_ptr->next))
        {
          /* Yes, insert into */
          g_timer_tbl[tbl_index].prev = object_ptr;
 8026702:	4471      	add	r1, lr
 8026704:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 8026708:	604a      	str	r2, [r1, #4]
          object_ptr->next = &g_timer_tbl[tbl_index];
 802670a:	6011      	str	r1, [r2, #0]
          g_timer_tbl[tbl_index].count = (uint32_t)delta_ticks;
 802670c:	6188      	str	r0, [r1, #24]
 802670e:	e793      	b.n	8026638 <SysTick_Handler+0x10c>
 8026710:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8026714:	682a      	ldr	r2, [r5, #0]
  /* Check if the last item in timer list */
  else if (NULL == object_ptr->next)
  {
    /* Remove timer from list */
    object_ptr->prev->next = NULL;
    object_ptr->prev = NULL;
 8026716:	f8c8 0004 	str.w	r0, [r8, #4]
 802671a:	e7b6      	b.n	802668a <SysTick_Handler+0x15e>
          object_ptr->prev = &g_timer_tbl[tbl_index];
        }
        else
        {
          /* Set Timer as first item */
          g_timer_tbl[tbl_index].next = g_timer_list;
 802671c:	eb0e 0801 	add.w	r8, lr, r1
 8026720:	eb04 0788 	add.w	r7, r4, r8, lsl #2
 8026724:	f844 c028 	str.w	ip, [r4, r8, lsl #2]
          g_timer_list->prev = &g_timer_tbl[tbl_index];
 8026728:	f8cc 7004 	str.w	r7, [ip, #4]
          g_timer_list = &g_timer_tbl[tbl_index];
 802672c:	46bc      	mov	ip, r7
 802672e:	e777      	b.n	8026620 <SysTick_Handler+0xf4>
static void SYSTIMER_lRemoveTimerList(uint32_t tbl_index)
{
  SYSTIMER_OBJECT_t *object_ptr;
  object_ptr = &g_timer_tbl[tbl_index];
  /* Check whether only one timer available */
  if ((NULL == object_ptr->prev) && (NULL == object_ptr->next ))
 8026730:	b372      	cbz	r2, 8026790 <SysTick_Handler+0x264>
  else if (NULL == object_ptr->prev)
  {
    /* Remove timer from list, and reset timer list */
    g_timer_list  = object_ptr->next;
    g_timer_list->prev = NULL;
    g_timer_list->count += object_ptr->count;
 8026732:	f8d8 0018 	ldr.w	r0, [r8, #24]
 8026736:	6991      	ldr	r1, [r2, #24]
  /* Check if the first item in timer list */
  else if (NULL == object_ptr->prev)
  {
    /* Remove timer from list, and reset timer list */
    g_timer_list  = object_ptr->next;
    g_timer_list->prev = NULL;
 8026738:	6057      	str	r7, [r2, #4]
    g_timer_list->count += object_ptr->count;
 802673a:	4401      	add	r1, r0
 802673c:	6191      	str	r1, [r2, #24]
  }
  /* Check if the first item in timer list */
  else if (NULL == object_ptr->prev)
  {
    /* Remove timer from list, and reset timer list */
    g_timer_list  = object_ptr->next;
 802673e:	602a      	str	r2, [r5, #0]
    g_timer_list->prev = NULL;
    g_timer_list->count += object_ptr->count;
    object_ptr->next    = NULL;
 8026740:	f844 702e 	str.w	r7, [r4, lr, lsl #2]
 8026744:	e7c7      	b.n	80266d6 <SysTick_Handler+0x1aa>
static void SYSTIMER_lRemoveTimerList(uint32_t tbl_index)
{
  SYSTIMER_OBJECT_t *object_ptr;
  object_ptr = &g_timer_tbl[tbl_index];
  /* Check whether only one timer available */
  if ((NULL == object_ptr->prev) && (NULL == object_ptr->next ))
 8026746:	f854 2029 	ldr.w	r2, [r4, r9, lsl #2]
 802674a:	b18a      	cbz	r2, 8026770 <SysTick_Handler+0x244>
  else if (NULL == object_ptr->prev)
  {
    /* Remove timer from list, and reset timer list */
    g_timer_list  = object_ptr->next;
    g_timer_list->prev = NULL;
    g_timer_list->count += object_ptr->count;
 802674c:	6990      	ldr	r0, [r2, #24]
 802674e:	f8d8 7018 	ldr.w	r7, [r8, #24]
      if (SYSTIMER_STATE_RUNNING == object_ptr->state)
      {
        /* Yes, remove this timer from timer list */
        SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
        /* Reset timer tick */
        object_ptr->count = object_ptr->reload;
 8026752:	f8d3 c01c 	ldr.w	ip, [r3, #28]
  /* Check if the first item in timer list */
  else if (NULL == object_ptr->prev)
  {
    /* Remove timer from list, and reset timer list */
    g_timer_list  = object_ptr->next;
    g_timer_list->prev = NULL;
 8026756:	f8c2 a004 	str.w	sl, [r2, #4]
    g_timer_list->count += object_ptr->count;
 802675a:	4438      	add	r0, r7
 802675c:	6190      	str	r0, [r2, #24]
    object_ptr->next    = NULL;
 802675e:	f844 a029 	str.w	sl, [r4, r9, lsl #2]
      if (SYSTIMER_STATE_RUNNING == object_ptr->state)
      {
        /* Yes, remove this timer from timer list */
        SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
        /* Reset timer tick */
        object_ptr->count = object_ptr->reload;
 8026762:	f8c3 c018 	str.w	ip, [r3, #24]
  }
  /* Check if the first item in timer list */
  else if (NULL == object_ptr->prev)
  {
    /* Remove timer from list, and reset timer list */
    g_timer_list  = object_ptr->next;
 8026766:	602a      	str	r2, [r5, #0]
  SYSTIMER_OBJECT_t *object_ptr;
  int32_t delta_ticks;
  int32_t timer_count;
  bool found_flag = false;
   /* Get timer time */
  timer_count = (int32_t)g_timer_tbl[tbl_index].count;
 8026768:	f8d8 0018 	ldr.w	r0, [r8, #24]
 802676c:	4694      	mov	ip, r2
 802676e:	e73a      	b.n	80265e6 <SysTick_Handler+0xba>
      if (SYSTIMER_STATE_RUNNING == object_ptr->state)
      {
        /* Yes, remove this timer from timer list */
        SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
        /* Reset timer tick */
        object_ptr->count = object_ptr->reload;
 8026770:	69da      	ldr	r2, [r3, #28]
 8026772:	619a      	str	r2, [r3, #24]
  timer_count = (int32_t)g_timer_tbl[tbl_index].count;
  /* Check if Timer list is NULL */
  if (NULL == g_timer_list)
  {
    /* Set this as first Timer */
    g_timer_list = &g_timer_tbl[tbl_index];
 8026774:	4471      	add	r1, lr
 8026776:	eb04 0281 	add.w	r2, r4, r1, lsl #2
 802677a:	602a      	str	r2, [r5, #0]
 802677c:	e75e      	b.n	802663c <SysTick_Handler+0x110>
  object_ptr = &g_timer_tbl[tbl_index];
  /* Check whether only one timer available */
  if ((NULL == object_ptr->prev) && (NULL == object_ptr->next ))
  {
    /* set timer list as NULL */ 
    g_timer_list = NULL;                  
 802677e:	602a      	str	r2, [r5, #0]
 8026780:	e783      	b.n	802668a <SysTick_Handler+0x15e>
  /* Check if the last item in timer list */
  else if (NULL == object_ptr->next)
  {
    /* Remove timer from list */
    object_ptr->prev->next = NULL;
    object_ptr->prev = NULL;
 8026782:	f8c8 2004 	str.w	r2, [r8, #4]
 8026786:	e7a6      	b.n	80266d6 <SysTick_Handler+0x1aa>
 8026788:	682f      	ldr	r7, [r5, #0]
 802678a:	f8c8 0004 	str.w	r0, [r8, #4]
 802678e:	e71b      	b.n	80265c8 <SysTick_Handler+0x9c>
  object_ptr = &g_timer_tbl[tbl_index];
  /* Check whether only one timer available */
  if ((NULL == object_ptr->prev) && (NULL == object_ptr->next ))
  {
    /* set timer list as NULL */ 
    g_timer_list = NULL;                  
 8026790:	602a      	str	r2, [r5, #0]
 8026792:	e7a0      	b.n	80266d6 <SysTick_Handler+0x1aa>
 8026794:	1fff0f74 	.word	0x1fff0f74
 8026798:	1fff0f7c 	.word	0x1fff0f7c
 802679c:	1fffaea4 	.word	0x1fffaea4
 80267a0:	1fff0f78 	.word	0x1fff0f78

080267a4 <SYSTIMER_Init>:
  XMC_ASSERT("SYSTIMER_Init: SYSTIMER APP handle pointer uninitialized", (handle != NULL));

  /* Check APP initialization status to ensure whether SYSTIMER_Init called or not, initialize SYSTIMER if
   * SYSTIMER_Init called first time.
   */
  if (false == handle->init_status)
 80267a4:	7803      	ldrb	r3, [r0, #0]
 80267a6:	bb43      	cbnz	r3, 80267fa <SYSTIMER_Init+0x56>

/*
 * Initialization function which initializes the SYSTIMER APP, configures SysTick timer and SysTick exception.
 */
SYSTIMER_STATUS_t SYSTIMER_Init(SYSTIMER_t *handle)
{
 80267a8:	b470      	push	{r4, r5, r6}
   * SYSTIMER_Init called first time.
   */
  if (false == handle->init_status)
  {
    /* Initialize the header of the list */
    g_timer_list = NULL;
 80267aa:	4c15      	ldr	r4, [pc, #84]	; (8026800 <SYSTIMER_Init+0x5c>)
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80267ac:	4a15      	ldr	r2, [pc, #84]	; (8026804 <SYSTIMER_Init+0x60>)
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80267ae:	4916      	ldr	r1, [pc, #88]	; (8026808 <SYSTIMER_Init+0x64>)
 80267b0:	6023      	str	r3, [r4, #0]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80267b2:	4e16      	ldr	r6, [pc, #88]	; (802680c <SYSTIMER_Init+0x68>)
 80267b4:	6056      	str	r6, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80267b6:	2407      	movs	r4, #7
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80267b8:	25fc      	movs	r5, #252	; 0xfc
 80267ba:	f881 5023 	strb.w	r5, [r1, #35]	; 0x23
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80267be:	6093      	str	r3, [r2, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80267c0:	6014      	str	r4, [r2, #0]
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80267c2:	68cb      	ldr	r3, [r1, #12]
 80267c4:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80267c8:	1ae1      	subs	r1, r4, r3
 80267ca:	2906      	cmp	r1, #6
 80267cc:	bf28      	it	cs
 80267ce:	2106      	movcs	r1, #6
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80267d0:	b98b      	cbnz	r3, 80267f6 <SYSTIMER_Init+0x52>
 80267d2:	461a      	mov	r2, r3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80267d4:	2401      	movs	r4, #1
 80267d6:	fa04 f301 	lsl.w	r3, r4, r1
 80267da:	3b01      	subs	r3, #1
 80267dc:	4093      	lsls	r3, r2
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80267de:	4d0a      	ldr	r5, [pc, #40]	; (8026808 <SYSTIMER_Init+0x64>)
      NVIC_GetPriorityGrouping(), SYSTIMER_PRIORITY, SYSTIMER_SUBPRIORITY));
#elif (UC_FAMILY == XMC1)
      /* setting of priority value for XMC1000 devices */
      NVIC_SetPriority(SysTick_IRQn, SYSTIMER_PRIORITY);
#endif      
      g_timer_tracker = 0U;
 80267e0:	4a0b      	ldr	r2, [pc, #44]	; (8026810 <SYSTIMER_Init+0x6c>)
 80267e2:	009b      	lsls	r3, r3, #2
 80267e4:	b2db      	uxtb	r3, r3
 80267e6:	f885 3023 	strb.w	r3, [r5, #35]	; 0x23
 80267ea:	2100      	movs	r1, #0
 80267ec:	6011      	str	r1, [r2, #0]
      /* Update the Initialization status of the SYSTIMER APP instance */
      handle->init_status = true;
 80267ee:	7004      	strb	r4, [r0, #0]
      status = SYSTIMER_STATUS_SUCCESS;
    }
  }

  return (status);
}
 80267f0:	2000      	movs	r0, #0
 80267f2:	bc70      	pop	{r4, r5, r6}
 80267f4:	4770      	bx	lr
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80267f6:	1e5a      	subs	r2, r3, #1
 80267f8:	e7ec      	b.n	80267d4 <SYSTIMER_Init+0x30>
 80267fa:	2000      	movs	r0, #0
 80267fc:	4770      	bx	lr
 80267fe:	bf00      	nop
 8026800:	1fff0f7c 	.word	0x1fff0f7c
 8026804:	e000e010 	.word	0xe000e010
 8026808:	e000ed00 	.word	0xe000ed00
 802680c:	000222df 	.word	0x000222df
 8026810:	1fff0f78 	.word	0x1fff0f78

08026814 <SYSTIMER_GetTime>:
/*
 *  API to get the current SysTick time in microsecond.
 */
uint32_t SYSTIMER_GetTime(void)
{
  return (g_systick_count * SYSTIMER_TICK_PERIOD_US);
 8026814:	4b03      	ldr	r3, [pc, #12]	; (8026824 <SYSTIMER_GetTime+0x10>)
 8026816:	681b      	ldr	r3, [r3, #0]
 8026818:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
}
 802681c:	fb00 f003 	mul.w	r0, r0, r3
 8026820:	4770      	bx	lr
 8026822:	bf00      	nop
 8026824:	1fff0f74 	.word	0x1fff0f74

08026828 <INTERRUPT_Init>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8026828:	4b20      	ldr	r3, [pc, #128]	; (80268ac <INTERRUPT_Init+0x84>)

/*
 * API to initialize the INTERRUPT APP
 */
INTERRUPT_STATUS_t INTERRUPT_Init(const INTERRUPT_t *const handler)
{
 802682a:	b4f0      	push	{r4, r5, r6, r7}
 802682c:	68db      	ldr	r3, [r3, #12]
  XMC_ASSERT("INTERRUPT_Init:HandlePtr NULL", (handler != NULL));
  
#if(UC_FAMILY == XMC4)

  NVIC_SetPriority(handler->node,
 802682e:	7804      	ldrb	r4, [r0, #0]
 8026830:	7841      	ldrb	r1, [r0, #1]
                   NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
                                       handler->priority,
                                       handler->subpriority));
 8026832:	7887      	ldrb	r7, [r0, #2]
 8026834:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8026838:	f1c3 0507 	rsb	r5, r3, #7
 802683c:	2d06      	cmp	r5, #6
 802683e:	bf28      	it	cs
 8026840:	2506      	movcs	r5, #6
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8026842:	b34b      	cbz	r3, 8026898 <INTERRUPT_Init+0x70>
 8026844:	1e5e      	subs	r6, r3, #1
 8026846:	2201      	movs	r2, #1
 8026848:	40b2      	lsls	r2, r6
 802684a:	3a01      	subs	r2, #1
 802684c:	ea02 0307 	and.w	r3, r2, r7

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8026850:	2201      	movs	r2, #1
 8026852:	40aa      	lsls	r2, r5
 8026854:	3a01      	subs	r2, #1
 8026856:	400a      	ands	r2, r1
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8026858:	b261      	sxtb	r1, r4

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 802685a:	40b2      	lsls	r2, r6
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 802685c:	2900      	cmp	r1, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 802685e:	ea43 0302 	orr.w	r3, r3, r2
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8026862:	db1b      	blt.n	802689c <INTERRUPT_Init+0x74>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8026864:	f101 4260 	add.w	r2, r1, #3758096384	; 0xe0000000
 8026868:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 802686c:	009b      	lsls	r3, r3, #2
 802686e:	b2db      	uxtb	r3, r3
 8026870:	f882 3300 	strb.w	r3, [r2, #768]	; 0x300
  if (handler->enable_at_init == true)
 8026874:	78c3      	ldrb	r3, [r0, #3]
 8026876:	b163      	cbz	r3, 8026892 <INTERRUPT_Init+0x6a>
 8026878:	7802      	ldrb	r2, [r0, #0]
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
 802687a:	b253      	sxtb	r3, r2
 802687c:	2b00      	cmp	r3, #0
 802687e:	db08      	blt.n	8026892 <INTERRUPT_Init+0x6a>
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8026880:	f002 021f 	and.w	r2, r2, #31
 8026884:	095b      	lsrs	r3, r3, #5
 8026886:	2101      	movs	r1, #1
 8026888:	4809      	ldr	r0, [pc, #36]	; (80268b0 <INTERRUPT_Init+0x88>)
 802688a:	fa01 f202 	lsl.w	r2, r1, r2
 802688e:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
    INTERRUPT_Enable(handler);
  }
#endif

  return (INTERRUPT_STATUS_SUCCESS);
}
 8026892:	2000      	movs	r0, #0
 8026894:	bcf0      	pop	{r4, r5, r6, r7}
 8026896:	4770      	bx	lr
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8026898:	461e      	mov	r6, r3
 802689a:	e7d9      	b.n	8026850 <INTERRUPT_Init+0x28>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802689c:	4a05      	ldr	r2, [pc, #20]	; (80268b4 <INTERRUPT_Init+0x8c>)
 802689e:	f004 040f 	and.w	r4, r4, #15
 80268a2:	009b      	lsls	r3, r3, #2
 80268a4:	4422      	add	r2, r4
 80268a6:	b2db      	uxtb	r3, r3
 80268a8:	7613      	strb	r3, [r2, #24]
 80268aa:	e7e3      	b.n	8026874 <INTERRUPT_Init+0x4c>
 80268ac:	e000ed00 	.word	0xe000ed00
 80268b0:	e000e100 	.word	0xe000e100
 80268b4:	e000ecfc 	.word	0xe000ecfc

080268b8 <GLOBAL_DMA_Init>:
  return version;
}

/* GLOBAL_DMA initialization function */
GLOBAL_DMA_STATUS_t GLOBAL_DMA_Init(GLOBAL_DMA_t *const obj)
{
 80268b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  XMC_ASSERT("DMA_GLOBAL_Init: NULL DMA_GLOBAL_t object", (obj != NULL));

  if (obj->initialized == false)
 80268ba:	7a03      	ldrb	r3, [r0, #8]
 80268bc:	b10b      	cbz	r3, 80268c2 <GLOBAL_DMA_Init+0xa>
    NVIC_EnableIRQ(obj->irq_node);
    obj->initialized = true;
  }

  return GLOBAL_DMA_STATUS_SUCCESS;
}
 80268be:	2000      	movs	r0, #0
 80268c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80268c2:	4604      	mov	r4, r0
  XMC_ASSERT("DMA_GLOBAL_Init: NULL DMA_GLOBAL_t object", (obj != NULL));

  if (obj->initialized == false)
  {
    /* Enable DMA module */
    XMC_DMA_Init(obj->dma);
 80268c4:	6800      	ldr	r0, [r0, #0]
 80268c6:	f7fb f9a7 	bl	8021c18 <XMC_DMA_Init>
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80268ca:	4a20      	ldr	r2, [pc, #128]	; (802694c <GLOBAL_DMA_Init+0x94>)

    /* Enable DMA event handling */
    NVIC_SetPriority(obj->irq_node, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
                                                        obj->config->priority,
 80268cc:	6863      	ldr	r3, [r4, #4]
 80268ce:	68d2      	ldr	r2, [r2, #12]
  {
    /* Enable DMA module */
    XMC_DMA_Init(obj->dma);

    /* Enable DMA event handling */
    NVIC_SetPriority(obj->irq_node, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
 80268d0:	7819      	ldrb	r1, [r3, #0]
                                                        obj->config->priority,
                                                        obj->config->sub_priority));
 80268d2:	785f      	ldrb	r7, [r3, #1]
  {
    /* Enable DMA module */
    XMC_DMA_Init(obj->dma);

    /* Enable DMA event handling */
    NVIC_SetPriority(obj->irq_node, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
 80268d4:	7a60      	ldrb	r0, [r4, #9]
 80268d6:	f3c2 2302 	ubfx	r3, r2, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80268da:	f1c3 0507 	rsb	r5, r3, #7
 80268de:	2d06      	cmp	r5, #6
 80268e0:	bf28      	it	cs
 80268e2:	2506      	movcs	r5, #6
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80268e4:	bb1b      	cbnz	r3, 802692e <GLOBAL_DMA_Init+0x76>
 80268e6:	461e      	mov	r6, r3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80268e8:	2201      	movs	r2, #1
 80268ea:	40aa      	lsls	r2, r5
 80268ec:	3a01      	subs	r2, #1
 80268ee:	400a      	ands	r2, r1
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 80268f0:	b241      	sxtb	r1, r0

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80268f2:	40b2      	lsls	r2, r6
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 80268f4:	2900      	cmp	r1, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 80268f6:	ea43 0302 	orr.w	r3, r3, r2
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 80268fa:	db1f      	blt.n	802693c <GLOBAL_DMA_Init+0x84>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80268fc:	f101 4260 	add.w	r2, r1, #3758096384	; 0xe0000000
 8026900:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 8026904:	009b      	lsls	r3, r3, #2
 8026906:	b2db      	uxtb	r3, r3
 8026908:	f882 3300 	strb.w	r3, [r2, #768]	; 0x300
                                                        obj->config->priority,
                                                        obj->config->sub_priority));
    NVIC_EnableIRQ(obj->irq_node);
 802690c:	7a62      	ldrb	r2, [r4, #9]
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
 802690e:	b253      	sxtb	r3, r2
 8026910:	2b00      	cmp	r3, #0
 8026912:	db08      	blt.n	8026926 <GLOBAL_DMA_Init+0x6e>
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8026914:	f002 021f 	and.w	r2, r2, #31
 8026918:	095b      	lsrs	r3, r3, #5
 802691a:	2101      	movs	r1, #1
 802691c:	480c      	ldr	r0, [pc, #48]	; (8026950 <GLOBAL_DMA_Init+0x98>)
 802691e:	fa01 f202 	lsl.w	r2, r1, r2
 8026922:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
    obj->initialized = true;
 8026926:	2301      	movs	r3, #1
 8026928:	7223      	strb	r3, [r4, #8]
  }

  return GLOBAL_DMA_STATUS_SUCCESS;
}
 802692a:	2000      	movs	r0, #0
 802692c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 802692e:	1e5e      	subs	r6, r3, #1
 8026930:	2201      	movs	r2, #1
 8026932:	40b2      	lsls	r2, r6
 8026934:	3a01      	subs	r2, #1
 8026936:	ea02 0307 	and.w	r3, r2, r7
 802693a:	e7d5      	b.n	80268e8 <GLOBAL_DMA_Init+0x30>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802693c:	4a05      	ldr	r2, [pc, #20]	; (8026954 <GLOBAL_DMA_Init+0x9c>)
 802693e:	f000 000f 	and.w	r0, r0, #15
 8026942:	009b      	lsls	r3, r3, #2
 8026944:	4402      	add	r2, r0
 8026946:	b2db      	uxtb	r3, r3
 8026948:	7613      	strb	r3, [r2, #24]
 802694a:	e7df      	b.n	802690c <GLOBAL_DMA_Init+0x54>
 802694c:	e000ed00 	.word	0xe000ed00
 8026950:	e000e100 	.word	0xe000e100
 8026954:	e000ecfc 	.word	0xe000ecfc

08026958 <GPDMA0_0_IRQHandler>:
  .irq_node = (IRQn_Type)110U /* Allotted DMA IRQ node */
};

void GPDMA0_0_IRQHandler(void)
{
  XMC_DMA_IRQHandler(XMC_DMA0);
 8026958:	4801      	ldr	r0, [pc, #4]	; (8026960 <GPDMA0_0_IRQHandler+0x8>)
 802695a:	f7fb bb17 	b.w	8021f8c <XMC_DMA_IRQHandler>
 802695e:	bf00      	nop
 8026960:	50014000 	.word	0x50014000

08026964 <GPDMA1_0_IRQHandler>:
}

#ifdef XMC_DMA1
void GPDMA1_0_IRQHandler(void)
{
  XMC_DMA_IRQHandler(XMC_DMA1);
 8026964:	4801      	ldr	r0, [pc, #4]	; (802696c <GPDMA1_0_IRQHandler+0x8>)
 8026966:	f7fb bb11 	b.w	8021f8c <XMC_DMA_IRQHandler>
 802696a:	bf00      	nop
 802696c:	50018000 	.word	0x50018000

08026970 <GLOBAL_CCU8_Init>:
/* Initializes the slice with the generated configuration */
GLOBAL_CCU8_STATUS_t GLOBAL_CCU8_Init(GLOBAL_CCU8_t* handle)
{
  XMC_ASSERT("GLOBAL_CCU8_Init:NULL handler", (NULL != handle));

  if (false == handle->is_initialized)
 8026970:	7b43      	ldrb	r3, [r0, #13]
 8026972:	b10b      	cbz	r3, 8026978 <GLOBAL_CCU8_Init+0x8>
    /* Restricts multiple initializations */
    handle->is_initialized = true;
  }

  return (GLOBAL_CCU8_STATUS_SUCCESS);
}
 8026974:	2000      	movs	r0, #0
 8026976:	4770      	bx	lr
  return version;
}

/* Initializes the slice with the generated configuration */
GLOBAL_CCU8_STATUS_t GLOBAL_CCU8_Init(GLOBAL_CCU8_t* handle)
{
 8026978:	b510      	push	{r4, lr}
 802697a:	4604      	mov	r4, r0
  XMC_ASSERT("GLOBAL_CCU8_Init:NULL handler", (NULL != handle));

  if (false == handle->is_initialized)
  {
    /* Enable CCU8 module */
    XMC_CCU8_Init(handle->module_ptr,handle->mcs_action);
 802697c:	6880      	ldr	r0, [r0, #8]
 802697e:	7b21      	ldrb	r1, [r4, #12]
 8026980:	f7fb f8d4 	bl	8021b2c <XMC_CCU8_Init>
    /* Start the prescaler */
    XMC_CCU8_StartPrescaler(handle->module_ptr);
 8026984:	68a2      	ldr	r2, [r4, #8]
 *  XMC_CCU8_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU8_StartPrescaler(XMC_CCU8_MODULE_t *const module)
{
  XMC_ASSERT("XMC_CCU8_StartPrescaler:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));
  module->GIDLC |= (uint32_t) CCU8_GIDLC_SPRB_Msk;
 8026986:	68d3      	ldr	r3, [r2, #12]
    /* Restricts multiple initializations */
    handle->is_initialized = true;
 8026988:	2101      	movs	r1, #1
 802698a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 802698e:	60d3      	str	r3, [r2, #12]
  }

  return (GLOBAL_CCU8_STATUS_SUCCESS);
}
 8026990:	2000      	movs	r0, #0
    /* Enable CCU8 module */
    XMC_CCU8_Init(handle->module_ptr,handle->mcs_action);
    /* Start the prescaler */
    XMC_CCU8_StartPrescaler(handle->module_ptr);
    /* Restricts multiple initializations */
    handle->is_initialized = true;
 8026992:	7361      	strb	r1, [r4, #13]
  }

  return (GLOBAL_CCU8_STATUS_SUCCESS);
}
 8026994:	bd10      	pop	{r4, pc}
 8026996:	bf00      	nop

08026998 <GLOBAL_CCU4_Init>:
/* Initializes the slice with the generated configuration */
GLOBAL_CCU4_STATUS_t GLOBAL_CCU4_Init(GLOBAL_CCU4_t* handle)
{
  XMC_ASSERT("GLOBAL_CCU4_Init:NULL handler", (NULL != handle));

  if (false == handle->is_initialized)
 8026998:	7b43      	ldrb	r3, [r0, #13]
 802699a:	b10b      	cbz	r3, 80269a0 <GLOBAL_CCU4_Init+0x8>
    /* Restricts multiple initializations */
    handle->is_initialized = true;
  }

  return (GLOBAL_CCU4_STATUS_SUCCESS);
}
 802699c:	2000      	movs	r0, #0
 802699e:	4770      	bx	lr
  return version;
}

/* Initializes the slice with the generated configuration */
GLOBAL_CCU4_STATUS_t GLOBAL_CCU4_Init(GLOBAL_CCU4_t* handle)
{
 80269a0:	b510      	push	{r4, lr}
 80269a2:	4604      	mov	r4, r0
  XMC_ASSERT("GLOBAL_CCU4_Init:NULL handler", (NULL != handle));

  if (false == handle->is_initialized)
  {
    /* Enable CCU4 module */
    XMC_CCU4_Init(handle->module_ptr,handle->mcs_action);
 80269a4:	6880      	ldr	r0, [r0, #8]
 80269a6:	7b21      	ldrb	r1, [r4, #12]
 80269a8:	f7fa ffde 	bl	8021968 <XMC_CCU4_Init>
    /* Start the prescaler */
    XMC_CCU4_StartPrescaler(handle->module_ptr);
 80269ac:	68a2      	ldr	r2, [r4, #8]
 * XMC_CCU4_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU4_StartPrescaler(XMC_CCU4_MODULE_t *const module)
{
  XMC_ASSERT("XMC_CCU4_StartPrescaler:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  module->GIDLC |= (uint32_t) CCU4_GIDLC_SPRB_Msk;
 80269ae:	68d3      	ldr	r3, [r2, #12]
    /* Restricts multiple initializations */
    handle->is_initialized = true;
 80269b0:	2101      	movs	r1, #1
 80269b2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80269b6:	60d3      	str	r3, [r2, #12]
  }

  return (GLOBAL_CCU4_STATUS_SUCCESS);
}
 80269b8:	2000      	movs	r0, #0
    /* Enable CCU4 module */
    XMC_CCU4_Init(handle->module_ptr,handle->mcs_action);
    /* Start the prescaler */
    XMC_CCU4_StartPrescaler(handle->module_ptr);
    /* Restricts multiple initializations */
    handle->is_initialized = true;
 80269ba:	7361      	strb	r1, [r4, #13]
  }

  return (GLOBAL_CCU4_STATUS_SUCCESS);
}
 80269bc:	bd10      	pop	{r4, pc}
 80269be:	bf00      	nop

080269c0 <GLOBAL_ADC_Init>:
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/**
 * This function initializes all instances of the ADC Global APP and low level app.
 */
GLOBAL_ADC_STATUS_t GLOBAL_ADC_Init(GLOBAL_ADC_t *const handle_ptr)
{
 80269c0:	4603      	mov	r3, r0
  XMC_ASSERT("GLOBAL_ADC_Init:Invalid handle_ptr", (handle_ptr != NULL))
#if (XMC_VADC_GROUP_AVAILABLE == 1U)
  uint32_t group_index;
#endif

  if (GLOBAL_ADC_UNINITIALIZED == handle_ptr->init_state)
 80269c2:	7e00      	ldrb	r0, [r0, #24]
 80269c4:	2802      	cmp	r0, #2
 80269c6:	d000      	beq.n	80269ca <GLOBAL_ADC_Init+0xa>
    	XMC_VADC_GLOBAL_StartupCalibration(handle_ptr->module_ptr);
    }
    handle_ptr->init_state = GLOBAL_ADC_SUCCESS;
  }
  return (handle_ptr->init_state);
}
 80269c8:	4770      	bx	lr
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/**
 * This function initializes all instances of the ADC Global APP and low level app.
 */
GLOBAL_ADC_STATUS_t GLOBAL_ADC_Init(GLOBAL_ADC_t *const handle_ptr)
{
 80269ca:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
#endif

  if (GLOBAL_ADC_UNINITIALIZED == handle_ptr->init_state)
  {  
    /* Initialize an instance of Global hardware */
    XMC_VADC_GLOBAL_Init(handle_ptr->module_ptr, handle_ptr->global_config_handle);
 80269ce:	6958      	ldr	r0, [r3, #20]
 80269d0:	6919      	ldr	r1, [r3, #16]
 80269d2:	461e      	mov	r6, r3
 80269d4:	f7fc fd72 	bl	80234bc <XMC_VADC_GLOBAL_Init>
 80269d8:	4634      	mov	r4, r6
 80269da:	2510      	movs	r5, #16

__STATIC_INLINE void XMC_VADC_GLOBAL_DisablePostCalibration(XMC_VADC_GLOBAL_t *const global_ptr, uint32_t group_number)
{
  XMC_ASSERT("XMC_VADC_GLOBAL_DisablePostCalibration:Wrong Module Pointer", (global_ptr == VADC))

  global_ptr->GLOBCFG |= (uint32_t)((uint32_t)1 << ((uint32_t)VADC_GLOBCFG_DPCAL0_Pos + group_number));
 80269dc:	f04f 0801 	mov.w	r8, #1

#if(XMC_VADC_SHS_AVAILABLE == 1U)
      XMC_VADC_GLOBAL_SHS_EnableAcceleratedMode(handle_ptr->global_shs_ptr, (XMC_VADC_GROUP_INDEX_t)group_index);
#endif

      handle_ptr->group_ptrs_array[group_index]->state = GLOBAL_ADC_SUCCESS;
 80269e0:	2700      	movs	r7, #0
    /* Initialize all the Groups */
#if (XMC_VADC_GROUP_AVAILABLE == 1U)
    for(group_index = (uint32_t)0; group_index < XMC_VADC_MAXIMUM_NUM_GROUPS; group_index++)
    {
      /*Initialize Group*/
      XMC_VADC_GROUP_Init(handle_ptr->group_ptrs_array[group_index]->group_handle,
 80269e2:	6823      	ldr	r3, [r4, #0]
 80269e4:	e893 0003 	ldmia.w	r3, {r0, r1}
 80269e8:	f7fc fdb4 	bl	8023554 <XMC_VADC_GROUP_Init>
    		            handle_ptr->group_ptrs_array[group_index]->group_config_handle);

      /* Switch on the converter of the Group[group_index]*/
      XMC_VADC_GROUP_SetPowerMode(handle_ptr->group_ptrs_array[group_index]->group_handle,
 80269ec:	6823      	ldr	r3, [r4, #0]
 80269ee:	2103      	movs	r1, #3
 80269f0:	6818      	ldr	r0, [r3, #0]
 80269f2:	f7fc fe4d 	bl	8023690 <XMC_VADC_GROUP_SetPowerMode>
                                  XMC_VADC_GROUP_POWERMODE_NORMAL);

      /* Disable the post calibration option for the respective group*/
      if ((bool)false == handle_ptr->group_ptrs_array[group_index]->post_calibration)
 80269f6:	f854 3b04 	ldr.w	r3, [r4], #4
 80269fa:	7a1a      	ldrb	r2, [r3, #8]
 80269fc:	b93a      	cbnz	r2, 8026a0e <GLOBAL_ADC_Init+0x4e>
      {
        XMC_VADC_GLOBAL_DisablePostCalibration(handle_ptr->module_ptr,group_index);
 80269fe:	6971      	ldr	r1, [r6, #20]
 8026a00:	f8d1 2080 	ldr.w	r2, [r1, #128]	; 0x80
 8026a04:	fa08 f005 	lsl.w	r0, r8, r5
 8026a08:	4302      	orrs	r2, r0
 8026a0a:	f8c1 2080 	str.w	r2, [r1, #128]	; 0x80
 8026a0e:	3501      	adds	r5, #1
    /* Initialize an instance of Global hardware */
    XMC_VADC_GLOBAL_Init(handle_ptr->module_ptr, handle_ptr->global_config_handle);

    /* Initialize all the Groups */
#if (XMC_VADC_GROUP_AVAILABLE == 1U)
    for(group_index = (uint32_t)0; group_index < XMC_VADC_MAXIMUM_NUM_GROUPS; group_index++)
 8026a10:	2d14      	cmp	r5, #20

#if(XMC_VADC_SHS_AVAILABLE == 1U)
      XMC_VADC_GLOBAL_SHS_EnableAcceleratedMode(handle_ptr->global_shs_ptr, (XMC_VADC_GROUP_INDEX_t)group_index);
#endif

      handle_ptr->group_ptrs_array[group_index]->state = GLOBAL_ADC_SUCCESS;
 8026a12:	725f      	strb	r7, [r3, #9]
    /* Initialize an instance of Global hardware */
    XMC_VADC_GLOBAL_Init(handle_ptr->module_ptr, handle_ptr->global_config_handle);

    /* Initialize all the Groups */
#if (XMC_VADC_GROUP_AVAILABLE == 1U)
    for(group_index = (uint32_t)0; group_index < XMC_VADC_MAXIMUM_NUM_GROUPS; group_index++)
 8026a14:	d1e5      	bne.n	80269e2 <GLOBAL_ADC_Init+0x22>
#endif
#endif /* _XMC_VADC_GROUP_AVAILABLE_ */
#if(XMC_VADC_SHS_AVAILABLE == 1U)
    XMC_VADC_GLOBAL_SHS_SetAnalogReference(handle_ptr->global_shs_ptr, GLOBAL_ADC_AREF_VALUE);
#endif
    if((bool)true == handle_ptr->enable_startup_calibration)
 8026a16:	7e73      	ldrb	r3, [r6, #25]
 8026a18:	b91b      	cbnz	r3, 8026a22 <GLOBAL_ADC_Init+0x62>
    {
    	XMC_VADC_GLOBAL_StartupCalibration(handle_ptr->module_ptr);
    }
    handle_ptr->init_state = GLOBAL_ADC_SUCCESS;
 8026a1a:	2000      	movs	r0, #0
 8026a1c:	7630      	strb	r0, [r6, #24]
  }
  return (handle_ptr->init_state);
}
 8026a1e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
#if(XMC_VADC_SHS_AVAILABLE == 1U)
    XMC_VADC_GLOBAL_SHS_SetAnalogReference(handle_ptr->global_shs_ptr, GLOBAL_ADC_AREF_VALUE);
#endif
    if((bool)true == handle_ptr->enable_startup_calibration)
    {
    	XMC_VADC_GLOBAL_StartupCalibration(handle_ptr->module_ptr);
 8026a22:	6970      	ldr	r0, [r6, #20]
 8026a24:	f7fc fd78 	bl	8023518 <XMC_VADC_GLOBAL_StartupCalibration>
 8026a28:	e7f7      	b.n	8026a1a <GLOBAL_ADC_Init+0x5a>
 8026a2a:	bf00      	nop

08026a2c <E_EEPROM_XMC4_Init>:

  return (version);
}

E_EEPROM_XMC4_STATUS_t E_EEPROM_XMC4_Init(E_EEPROM_XMC4_t *const handle)
{
 8026a2c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  XMC_ASSERT("E_EEPROM_XMC4_Init:Invalid handle Pointer", (handle != NULL))

  status = E_EEPROM_XMC4_STATUS_OK;
  
  if (handle->initialized == (bool)false)
 8026a30:	7804      	ldrb	r4, [r0, #0]

  return (version);
}

E_EEPROM_XMC4_STATUS_t E_EEPROM_XMC4_Init(E_EEPROM_XMC4_t *const handle)
{
 8026a32:	b085      	sub	sp, #20

  XMC_ASSERT("E_EEPROM_XMC4_Init:Invalid handle Pointer", (handle != NULL))

  status = E_EEPROM_XMC4_STATUS_OK;
  
  if (handle->initialized == (bool)false)
 8026a34:	b11c      	cbz	r4, 8026a3e <E_EEPROM_XMC4_Init+0x12>
  uint32_t sector_count;
  E_EEPROM_XMC4_STATUS_t status ;

  XMC_ASSERT("E_EEPROM_XMC4_Init:Invalid handle Pointer", (handle != NULL))

  status = E_EEPROM_XMC4_STATUS_OK;
 8026a36:	2000      	movs	r0, #0

    handle->initialized = (bool)true;
  }

  return (status);
}
 8026a38:	b005      	add	sp, #20
 8026a3a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

  status = E_EEPROM_XMC4_STATUS_OK;
  
  if (handle->initialized == (bool)false)
  {
    e_eeprom_xmc4_data_buffer.block_cycle_count = 0U;
 8026a3e:	4b7a      	ldr	r3, [pc, #488]	; (8026c28 <E_EEPROM_XMC4_Init+0x1fc>)
    e_eeprom_xmc4_sector_info.flash_data_addr = E_EEPROM_XMC4_EMPTY;
 8026a40:	f8df 81f4 	ldr.w	r8, [pc, #500]	; 8026c38 <E_EEPROM_XMC4_Init+0x20c>
 * \par<b>Related APIs:</b><BR>
 * None
 */
__STATIC_INLINE void XMC_FLASH_SetMargin(const XMC_FLASH_MARGIN_t margin)
{
  FLASH0->MARP = (FLASH0->MARP & (uint32_t)~FLASH_MARP_MARGIN_Msk) | margin;
 8026a44:	4979      	ldr	r1, [pc, #484]	; (8026c2c <E_EEPROM_XMC4_Init+0x200>)

  status = E_EEPROM_XMC4_STATUS_OK;
  
  if (handle->initialized == (bool)false)
  {
    e_eeprom_xmc4_data_buffer.block_cycle_count = 0U;
 8026a46:	605c      	str	r4, [r3, #4]
 8026a48:	f241 0218 	movw	r2, #4120	; 0x1018
    e_eeprom_xmc4_sector_info.flash_data_addr = E_EEPROM_XMC4_EMPTY;
 8026a4c:	f8c8 4004 	str.w	r4, [r8, #4]
 8026a50:	588b      	ldr	r3, [r1, r2]
 8026a52:	9001      	str	r0, [sp, #4]
 8026a54:	f023 030f 	bic.w	r3, r3, #15
 8026a58:	f043 0301 	orr.w	r3, r3, #1
 8026a5c:	508b      	str	r3, [r1, r2]
 * \par<b>Related APIs:</b><BR>
 * None
 */
__STATIC_INLINE void XMC_FLASH_DisableDoubleBitErrorTrap(void)
{
  FLASH0->MARP |= FLASH_MARP_TRAPDIS_Msk;
 8026a5e:	588b      	ldr	r3, [r1, r2]
    XMC_FLASH_DisableDoubleBitErrorTrap();
  
    XMC_FCE_Enable();

    /* Initialize FCE module for Hardware calculations */
    (void)XMC_FCE_Init(&e_eeprom_xmc4_fce);
 8026a60:	4f73      	ldr	r7, [pc, #460]	; (8026c30 <E_EEPROM_XMC4_Init+0x204>)
 * \par
 * The function sets the initial CRC (seed) value in the CRC register.
 */
__STATIC_INLINE void XMC_FCE_InitializeSeedValue(const XMC_FCE_t *const engine, uint32_t seedvalue)
{
  engine->kernel_ptr->CRC = seedvalue;
 8026a62:	f8df b1ec 	ldr.w	fp, [pc, #492]	; 8026c50 <E_EEPROM_XMC4_Init+0x224>
 8026a66:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8026a6a:	508b      	str	r3, [r1, r2]
    e_eeprom_xmc4_sector_info.flash_data_addr = E_EEPROM_XMC4_EMPTY;
  
    XMC_FLASH_SetMargin(XMC_FLASH_MARGIN_TIGHT0);
    XMC_FLASH_DisableDoubleBitErrorTrap();
  
    XMC_FCE_Enable();
 8026a6c:	f7fb fb74 	bl	8022158 <XMC_FCE_Enable>

    /* Initialize FCE module for Hardware calculations */
    (void)XMC_FCE_Init(&e_eeprom_xmc4_fce);
 8026a70:	4870      	ldr	r0, [pc, #448]	; (8026c34 <E_EEPROM_XMC4_Init+0x208>)
 8026a72:	f7fb fb69 	bl	8022148 <XMC_FCE_Init>
  
    /* Iterate all 4 sectors to find out which is the active sector having the latest data block*/
    for (sector_count = 0U; sector_count < E_EEPROM_XMC4_MAX_SECTORS ; sector_count++)
 8026a76:	9400      	str	r4, [sp, #0]
 8026a78:	4623      	mov	r3, r4
  uint32_t calculated_crc;

  /* Initialize starting address and last block address of the sector. */
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR + (E_EEPROM_XMC4_SECTOR_SIZE * (uint32_t)sector);
  block_read_addr = (sector_start_addr + E_EEPROM_XMC4_SECTOR_SIZE) - E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;
  free_block_addr = E_EEPROM_XMC4_EMPTY;
 8026a7a:	f04f 0900 	mov.w	r9, #0

    /* Check if block cycle count is a non zero value*/
    if (block_cycle_count != E_EEPROM_XMC4_EMPTY)
    {
      /* Mark sector as non-empty sector*/
      e_eeprom_xmc4_sector_info.erase_state |= ((uint32_t)1U << sector);
 8026a7e:	f04f 0a01 	mov.w	sl, #1
 8026a82:	fa0a fa03 	lsl.w	sl, sl, r3
  uint32_t calculated_crc;

  /* Initialize starting address and last block address of the sector. */
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR + (E_EEPROM_XMC4_SECTOR_SIZE * (uint32_t)sector);
  block_read_addr = (sector_start_addr + E_EEPROM_XMC4_SECTOR_SIZE) - E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;
  free_block_addr = E_EEPROM_XMC4_EMPTY;
 8026a86:	464b      	mov	r3, r9
  uint32_t written_crc;
  uint32_t calculated_crc;

  /* Initialize starting address and last block address of the sector. */
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR + (E_EEPROM_XMC4_SECTOR_SIZE * (uint32_t)sector);
  block_read_addr = (sector_start_addr + E_EEPROM_XMC4_SECTOR_SIZE) - E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;
 8026a88:	f507 5440 	add.w	r4, r7, #12288	; 0x3000
  free_block_addr = E_EEPROM_XMC4_EMPTY;
 8026a8c:	46b9      	mov	r9, r7
 8026a8e:	461f      	mov	r7, r3
 8026a90:	e003      	b.n	8026a9a <E_EEPROM_XMC4_Init+0x6e>
          break;
        }
      }
    }
    /* Move the block read address to one block size up starting from the bottom of sector */
    block_read_addr -= E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;
 8026a92:	f5a4 5480 	sub.w	r4, r4, #4096	; 0x1000

  /* Iterate the read process until the block read address crosses sector start address or a
   * latest valid block is identified.
   */
  } while ( block_read_addr >= sector_start_addr );
 8026a96:	454c      	cmp	r4, r9
 8026a98:	d32c      	bcc.n	8026af4 <E_EEPROM_XMC4_Init+0xc8>

  do
  {
    /* Read first 32 bit data from the block which indicates the block cycle counter. */
    data_ptr = (uint32_t*)block_read_addr;
    block_cycle_count = *(data_ptr + E_EEPROM_XMC4_BCC_OFFSET);
 8026a9a:	6865      	ldr	r5, [r4, #4]
  uint32_t result;

  /* Reset the CRC result register before new CRC calculation */
  XMC_FCE_InitializeSeedValue(&e_eeprom_xmc4_fce, 0U);

  (void)XMC_FCE_CalculateCRC32(&e_eeprom_xmc4_fce, data_start_addr, E_EEPROM_XMC4_DATA_SIZE_FOR_CRC, &result);
 8026a9c:	4865      	ldr	r0, [pc, #404]	; (8026c34 <E_EEPROM_XMC4_Init+0x208>)
      {
        free_block_addr = block_read_addr + E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;
      }

      /* Read the second 32bit data which indicates the CRC */
      written_crc = *data_ptr;
 8026a9e:	4621      	mov	r1, r4
 8026aa0:	f04f 0e00 	mov.w	lr, #0
  uint32_t result;

  /* Reset the CRC result register before new CRC calculation */
  XMC_FCE_InitializeSeedValue(&e_eeprom_xmc4_fce, 0U);

  (void)XMC_FCE_CalculateCRC32(&e_eeprom_xmc4_fce, data_start_addr, E_EEPROM_XMC4_DATA_SIZE_FOR_CRC, &result);
 8026aa4:	f640 72fc 	movw	r2, #4092	; 0xffc
 8026aa8:	ab03      	add	r3, sp, #12
    /* Read first 32 bit data from the block which indicates the block cycle counter. */
    data_ptr = (uint32_t*)block_read_addr;
    block_cycle_count = *(data_ptr + E_EEPROM_XMC4_BCC_OFFSET);

    /* Check if block cycle count is a non zero value*/
    if (block_cycle_count != E_EEPROM_XMC4_EMPTY)
 8026aaa:	2d00      	cmp	r5, #0
 8026aac:	d0f1      	beq.n	8026a92 <E_EEPROM_XMC4_Init+0x66>
    {
      /* Mark sector as non-empty sector*/
      e_eeprom_xmc4_sector_info.erase_state |= ((uint32_t)1U << sector);
 8026aae:	f8d8 600c 	ldr.w	r6, [r8, #12]
 8026ab2:	ea4a 0606 	orr.w	r6, sl, r6
 8026ab6:	f8c8 600c 	str.w	r6, [r8, #12]

      /* If this is the first non empty block identified, then store the address as next free address */
      if (free_block_addr == E_EEPROM_XMC4_EMPTY)
 8026aba:	b90f      	cbnz	r7, 8026ac0 <E_EEPROM_XMC4_Init+0x94>
      {
        free_block_addr = block_read_addr + E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;
 8026abc:	f504 5780 	add.w	r7, r4, #4096	; 0x1000
      }

      /* Read the second 32bit data which indicates the CRC */
      written_crc = *data_ptr;
 8026ac0:	f851 6b04 	ldr.w	r6, [r1], #4
 8026ac4:	f8cb e018 	str.w	lr, [fp, #24]
  uint32_t result;

  /* Reset the CRC result register before new CRC calculation */
  XMC_FCE_InitializeSeedValue(&e_eeprom_xmc4_fce, 0U);

  (void)XMC_FCE_CalculateCRC32(&e_eeprom_xmc4_fce, data_start_addr, E_EEPROM_XMC4_DATA_SIZE_FOR_CRC, &result);
 8026ac8:	f7fb fb58 	bl	802217c <XMC_FCE_CalculateCRC32>

  return (result);
 8026acc:	9b03      	ldr	r3, [sp, #12]
      /* Read the second 32bit data which indicates the CRC */
      written_crc = *data_ptr;
      /* Calculate the CRC for the written data in flash (3rd word to the last word)*/
      calculated_crc = E_EEPROM_XMC4_lCalculateCRC(data_ptr + E_EEPROM_XMC4_BCC_OFFSET);

      if (calculated_crc == written_crc)
 8026ace:	429e      	cmp	r6, r3
 8026ad0:	d1df      	bne.n	8026a92 <E_EEPROM_XMC4_Init+0x66>
      {
        /* If both CRC matches and the current block cycle counter is greater than the previous recorded value,
         * Update the Data structure with the current block as the "latest" one and the current sector as "active".
         * Exit from the function.
         */
        if (block_cycle_count > e_eeprom_xmc4_data_buffer.block_cycle_count)
 8026ad2:	4b55      	ldr	r3, [pc, #340]	; (8026c28 <E_EEPROM_XMC4_Init+0x1fc>)
 8026ad4:	685b      	ldr	r3, [r3, #4]
 8026ad6:	429d      	cmp	r5, r3
 8026ad8:	d9db      	bls.n	8026a92 <E_EEPROM_XMC4_Init+0x66>
 8026ada:	463b      	mov	r3, r7
 8026adc:	464f      	mov	r7, r9
 8026ade:	4699      	mov	r9, r3
        {
          e_eeprom_xmc4_data_buffer.block_cycle_count = block_cycle_count;
 8026ae0:	4b51      	ldr	r3, [pc, #324]	; (8026c28 <E_EEPROM_XMC4_Init+0x1fc>)
          e_eeprom_xmc4_sector_info.current_sector = sector;
          e_eeprom_xmc4_sector_info.flash_data_addr = block_read_addr;
 8026ae2:	f8c8 4004 	str.w	r4, [r8, #4]
         * Update the Data structure with the current block as the "latest" one and the current sector as "active".
         * Exit from the function.
         */
        if (block_cycle_count > e_eeprom_xmc4_data_buffer.block_cycle_count)
        {
          e_eeprom_xmc4_data_buffer.block_cycle_count = block_cycle_count;
 8026ae6:	605d      	str	r5, [r3, #4]
          e_eeprom_xmc4_sector_info.current_sector = sector;
 8026ae8:	9b00      	ldr	r3, [sp, #0]
 8026aea:	f8c8 3008 	str.w	r3, [r8, #8]
          e_eeprom_xmc4_sector_info.flash_data_addr = block_read_addr;
          e_eeprom_xmc4_sector_info.next_free_start_addr = free_block_addr;
 8026aee:	f8c8 9000 	str.w	r9, [r8]
 8026af2:	e001      	b.n	8026af8 <E_EEPROM_XMC4_Init+0xcc>
 8026af4:	9b00      	ldr	r3, [sp, #0]
 8026af6:	464f      	mov	r7, r9

    /* Initialize FCE module for Hardware calculations */
    (void)XMC_FCE_Init(&e_eeprom_xmc4_fce);
  
    /* Iterate all 4 sectors to find out which is the active sector having the latest data block*/
    for (sector_count = 0U; sector_count < E_EEPROM_XMC4_MAX_SECTORS ; sector_count++)
 8026af8:	3301      	adds	r3, #1
 8026afa:	2b04      	cmp	r3, #4
 8026afc:	9300      	str	r3, [sp, #0]
 8026afe:	f507 4780 	add.w	r7, r7, #16384	; 0x4000
 8026b02:	d1ba      	bne.n	8026a7a <E_EEPROM_XMC4_Init+0x4e>
 * \par<b>Related APIs:</b><BR>
 * None
 */
__STATIC_INLINE void XMC_FLASH_SetMargin(const XMC_FLASH_MARGIN_t margin)
{
  FLASH0->MARP = (FLASH0->MARP & (uint32_t)~FLASH_MARP_MARGIN_Msk) | margin;
 8026b04:	4949      	ldr	r1, [pc, #292]	; (8026c2c <E_EEPROM_XMC4_Init+0x200>)
  sector_count = 0U;

  do
  {
    /* If the non empty sector is the current active sector, then do not erase it*/
    if (e_eeprom_xmc4_sector_info.current_sector != sector_count)
 8026b06:	f8d8 0008 	ldr.w	r0, [r8, #8]
 8026b0a:	4c4b      	ldr	r4, [pc, #300]	; (8026c38 <E_EEPROM_XMC4_Init+0x20c>)
 8026b0c:	f241 0218 	movw	r2, #4120	; 0x1018
 8026b10:	588b      	ldr	r3, [r1, r2]
 8026b12:	f023 030f 	bic.w	r3, r3, #15
 8026b16:	508b      	str	r3, [r1, r2]
 8026b18:	b130      	cbz	r0, 8026b28 <E_EEPROM_XMC4_Init+0xfc>
    {
      /* Check if the sector was previously identified as non-empty. i.e It is having old data or corrupted data
       * If so erase the sector and mark it as erase attempted.
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
 8026b1a:	68e3      	ldr	r3, [r4, #12]
 8026b1c:	07d8      	lsls	r0, r3, #31
 8026b1e:	d462      	bmi.n	8026be6 <E_EEPROM_XMC4_Init+0x1ba>
  sector_count = 0U;

  do
  {
    /* If the non empty sector is the current active sector, then do not erase it*/
    if (e_eeprom_xmc4_sector_info.current_sector != sector_count)
 8026b20:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8026b24:	2b01      	cmp	r3, #1
 8026b26:	d008      	beq.n	8026b3a <E_EEPROM_XMC4_Init+0x10e>
    {
      /* Check if the sector was previously identified as non-empty. i.e It is having old data or corrupted data
       * If so erase the sector and mark it as erase attempted.
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
 8026b28:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8026b2c:	4c42      	ldr	r4, [pc, #264]	; (8026c38 <E_EEPROM_XMC4_Init+0x20c>)
 8026b2e:	0799      	lsls	r1, r3, #30
 8026b30:	d44b      	bmi.n	8026bca <E_EEPROM_XMC4_Init+0x19e>
  sector_count = 0U;

  do
  {
    /* If the non empty sector is the current active sector, then do not erase it*/
    if (e_eeprom_xmc4_sector_info.current_sector != sector_count)
 8026b32:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8026b36:	2b02      	cmp	r3, #2
 8026b38:	d008      	beq.n	8026b4c <E_EEPROM_XMC4_Init+0x120>
    {
      /* Check if the sector was previously identified as non-empty. i.e It is having old data or corrupted data
       * If so erase the sector and mark it as erase attempted.
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
 8026b3a:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8026b3e:	4c3e      	ldr	r4, [pc, #248]	; (8026c38 <E_EEPROM_XMC4_Init+0x20c>)
 8026b40:	075a      	lsls	r2, r3, #29
 8026b42:	d45e      	bmi.n	8026c02 <E_EEPROM_XMC4_Init+0x1d6>
  sector_count = 0U;

  do
  {
    /* If the non empty sector is the current active sector, then do not erase it*/
    if (e_eeprom_xmc4_sector_info.current_sector != sector_count)
 8026b44:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8026b48:	2b03      	cmp	r3, #3
 8026b4a:	d004      	beq.n	8026b56 <E_EEPROM_XMC4_Init+0x12a>
    {
      /* Check if the sector was previously identified as non-empty. i.e It is having old data or corrupted data
       * If so erase the sector and mark it as erase attempted.
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
 8026b4c:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8026b50:	4c39      	ldr	r4, [pc, #228]	; (8026c38 <E_EEPROM_XMC4_Init+0x20c>)
 8026b52:	071b      	lsls	r3, r3, #28
 8026b54:	d42b      	bmi.n	8026bae <E_EEPROM_XMC4_Init+0x182>
      {
  
        /* If a valid latest block were not detected, we shall assume that all sectors may be empty.
         * Then make Sector-0 as current sector and next free address as Sector0 start address
         */
        if (e_eeprom_xmc4_sector_info.flash_data_addr == E_EEPROM_XMC4_EMPTY)
 8026b56:	f8d8 0004 	ldr.w	r0, [r8, #4]
 8026b5a:	4b37      	ldr	r3, [pc, #220]	; (8026c38 <E_EEPROM_XMC4_Init+0x20c>)
 8026b5c:	b978      	cbnz	r0, 8026b7e <E_EEPROM_XMC4_Init+0x152>
        {
          e_eeprom_xmc4_sector_info.current_sector = E_EEPROM_XMC4_SECTOR_0;
          e_eeprom_xmc4_sector_info.next_free_start_addr =  E_EEPROM_XMC4_SECTOR0_START_ADDR;
 8026b5e:	4a34      	ldr	r2, [pc, #208]	; (8026c30 <E_EEPROM_XMC4_Init+0x204>)
        /* If a valid latest block were not detected, we shall assume that all sectors may be empty.
         * Then make Sector-0 as current sector and next free address as Sector0 start address
         */
        if (e_eeprom_xmc4_sector_info.flash_data_addr == E_EEPROM_XMC4_EMPTY)
        {
          e_eeprom_xmc4_sector_info.current_sector = E_EEPROM_XMC4_SECTOR_0;
 8026b60:	6098      	str	r0, [r3, #8]
          e_eeprom_xmc4_sector_info.next_free_start_addr =  E_EEPROM_XMC4_SECTOR0_START_ADDR;
 8026b62:	601a      	str	r2, [r3, #0]
 * \par<b>Related APIs:</b><BR>
 * None
 */
__STATIC_INLINE void XMC_FLASH_EnableDoubleBitErrorTrap(void)
{
  FLASH0->MARP &= (uint32_t)~FLASH_MARP_TRAPDIS_Msk;
 8026b64:	4931      	ldr	r1, [pc, #196]	; (8026c2c <E_EEPROM_XMC4_Init+0x200>)
 8026b66:	f241 0218 	movw	r2, #4120	; 0x1018
      }
    }

    XMC_FLASH_EnableDoubleBitErrorTrap();

    handle->initialized = (bool)true;
 8026b6a:	2401      	movs	r4, #1
 8026b6c:	588b      	ldr	r3, [r1, r2]
 8026b6e:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8026b72:	508b      	str	r3, [r1, r2]
 8026b74:	9b01      	ldr	r3, [sp, #4]
 8026b76:	701c      	strb	r4, [r3, #0]
  }

  return (status);
}
 8026b78:	b005      	add	sp, #20
 8026b7a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8026b7e:	4a2f      	ldr	r2, [pc, #188]	; (8026c3c <E_EEPROM_XMC4_Init+0x210>)
 8026b80:	1f03      	subs	r3, r0, #4
 8026b82:	f600 74fc 	addw	r4, r0, #4092	; 0xffc
  flash_addr_ptr = (uint32_t*)e_eeprom_xmc4_sector_info.flash_data_addr;
  ram_addr_ptr = (uint32_t*)(void*)&e_eeprom_xmc4_data_buffer;

  for(byte_index = 0U ; byte_index < E_EEPROM_XMC4_MAX_WORDS; byte_index++)
  {
    *(ram_addr_ptr + byte_index) = *(flash_addr_ptr + byte_index);
 8026b86:	f853 1f04 	ldr.w	r1, [r3, #4]!
 8026b8a:	f842 1f04 	str.w	r1, [r2, #4]!
  uint32_t byte_index;

  flash_addr_ptr = (uint32_t*)e_eeprom_xmc4_sector_info.flash_data_addr;
  ram_addr_ptr = (uint32_t*)(void*)&e_eeprom_xmc4_data_buffer;

  for(byte_index = 0U ; byte_index < E_EEPROM_XMC4_MAX_WORDS; byte_index++)
 8026b8e:	42a3      	cmp	r3, r4
 8026b90:	d1f9      	bne.n	8026b86 <E_EEPROM_XMC4_Init+0x15a>
        else
        {
          /* If a valid latest block was detected, copy the valid block from flash to RAM. */
          E_EEPROM_XMC4_lCopyFlashToRam();
  
          if ((e_eeprom_xmc4_sector_info.next_free_start_addr - e_eeprom_xmc4_sector_info.flash_data_addr) !=
 8026b92:	f8d8 3000 	ldr.w	r3, [r8]
              E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE)
          {
            status = E_EEPROM_XMC4_STATUS_ERROR_OLD_DATA;
          }
  
          if (e_eeprom_xmc4_sector_info.next_free_start_addr >= E_EEPROM_XMC4_SECTOR4_START_ADDR)
 8026b96:	4a2a      	ldr	r2, [pc, #168]	; (8026c40 <E_EEPROM_XMC4_Init+0x214>)
        else
        {
          /* If a valid latest block was detected, copy the valid block from flash to RAM. */
          E_EEPROM_XMC4_lCopyFlashToRam();
  
          if ((e_eeprom_xmc4_sector_info.next_free_start_addr - e_eeprom_xmc4_sector_info.flash_data_addr) !=
 8026b98:	4927      	ldr	r1, [pc, #156]	; (8026c38 <E_EEPROM_XMC4_Init+0x20c>)
 8026b9a:	1a18      	subs	r0, r3, r0
              E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE)
          {
            status = E_EEPROM_XMC4_STATUS_ERROR_OLD_DATA;
 8026b9c:	f5b0 5080 	subs.w	r0, r0, #4096	; 0x1000
 8026ba0:	bf18      	it	ne
 8026ba2:	2001      	movne	r0, #1
          }
  
          if (e_eeprom_xmc4_sector_info.next_free_start_addr >= E_EEPROM_XMC4_SECTOR4_START_ADDR)
 8026ba4:	4293      	cmp	r3, r2
 8026ba6:	d9dd      	bls.n	8026b64 <E_EEPROM_XMC4_Init+0x138>
          {
            e_eeprom_xmc4_sector_info.next_free_start_addr =  E_EEPROM_XMC4_SECTOR0_START_ADDR;
 8026ba8:	4b21      	ldr	r3, [pc, #132]	; (8026c30 <E_EEPROM_XMC4_Init+0x204>)
 8026baa:	600b      	str	r3, [r1, #0]
 8026bac:	e7da      	b.n	8026b64 <E_EEPROM_XMC4_Init+0x138>
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
      {
        sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR + (E_EEPROM_XMC4_SECTOR_SIZE * (uint32_t)sector_count);

        XMC_FLASH_ClearStatus();
 8026bae:	f7fa fb93 	bl	80212d8 <XMC_FLASH_ClearStatus>
        XMC_FLASH_EraseSector((uint32_t*)sector_start_addr);
 8026bb2:	4824      	ldr	r0, [pc, #144]	; (8026c44 <E_EEPROM_XMC4_Init+0x218>)
 8026bb4:	f7fa fbc8 	bl	8021348 <XMC_FLASH_EraseSector>

        if (XMC_FLASH_GetStatus() != (uint32_t)XMC_FLASH_STATUS_ERASE_STATE)
 8026bb8:	f7fa fb94 	bl	80212e4 <XMC_FLASH_GetStatus>
 8026bbc:	2820      	cmp	r0, #32
 8026bbe:	d12e      	bne.n	8026c1e <E_EEPROM_XMC4_Init+0x1f2>
        {
          status = E_EEPROM_XMC4_STATUS_ERASE_ERROR;
          break;
        }
        e_eeprom_xmc4_sector_info.erase_state &= ~(((uint32_t)1U << sector_count));
 8026bc0:	68e3      	ldr	r3, [r4, #12]
 8026bc2:	f023 0308 	bic.w	r3, r3, #8
 8026bc6:	60e3      	str	r3, [r4, #12]
 8026bc8:	e7c5      	b.n	8026b56 <E_EEPROM_XMC4_Init+0x12a>
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
      {
        sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR + (E_EEPROM_XMC4_SECTOR_SIZE * (uint32_t)sector_count);

        XMC_FLASH_ClearStatus();
 8026bca:	f7fa fb85 	bl	80212d8 <XMC_FLASH_ClearStatus>
        XMC_FLASH_EraseSector((uint32_t*)sector_start_addr);
 8026bce:	481e      	ldr	r0, [pc, #120]	; (8026c48 <E_EEPROM_XMC4_Init+0x21c>)
 8026bd0:	f7fa fbba 	bl	8021348 <XMC_FLASH_EraseSector>

        if (XMC_FLASH_GetStatus() != (uint32_t)XMC_FLASH_STATUS_ERASE_STATE)
 8026bd4:	f7fa fb86 	bl	80212e4 <XMC_FLASH_GetStatus>
 8026bd8:	2820      	cmp	r0, #32
 8026bda:	d120      	bne.n	8026c1e <E_EEPROM_XMC4_Init+0x1f2>
        {
          status = E_EEPROM_XMC4_STATUS_ERASE_ERROR;
          break;
        }
        e_eeprom_xmc4_sector_info.erase_state &= ~(((uint32_t)1U << sector_count));
 8026bdc:	68e3      	ldr	r3, [r4, #12]
 8026bde:	f023 0302 	bic.w	r3, r3, #2
 8026be2:	60e3      	str	r3, [r4, #12]
 8026be4:	e7a5      	b.n	8026b32 <E_EEPROM_XMC4_Init+0x106>
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
      {
        sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR + (E_EEPROM_XMC4_SECTOR_SIZE * (uint32_t)sector_count);

        XMC_FLASH_ClearStatus();
 8026be6:	f7fa fb77 	bl	80212d8 <XMC_FLASH_ClearStatus>
        XMC_FLASH_EraseSector((uint32_t*)sector_start_addr);
 8026bea:	4811      	ldr	r0, [pc, #68]	; (8026c30 <E_EEPROM_XMC4_Init+0x204>)
 8026bec:	f7fa fbac 	bl	8021348 <XMC_FLASH_EraseSector>

        if (XMC_FLASH_GetStatus() != (uint32_t)XMC_FLASH_STATUS_ERASE_STATE)
 8026bf0:	f7fa fb78 	bl	80212e4 <XMC_FLASH_GetStatus>
 8026bf4:	2820      	cmp	r0, #32
 8026bf6:	d114      	bne.n	8026c22 <E_EEPROM_XMC4_Init+0x1f6>
        {
          status = E_EEPROM_XMC4_STATUS_ERASE_ERROR;
          break;
        }
        e_eeprom_xmc4_sector_info.erase_state &= ~(((uint32_t)1U << sector_count));
 8026bf8:	68e3      	ldr	r3, [r4, #12]
 8026bfa:	f023 0301 	bic.w	r3, r3, #1
 8026bfe:	60e3      	str	r3, [r4, #12]
 8026c00:	e78e      	b.n	8026b20 <E_EEPROM_XMC4_Init+0xf4>
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
      {
        sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR + (E_EEPROM_XMC4_SECTOR_SIZE * (uint32_t)sector_count);

        XMC_FLASH_ClearStatus();
 8026c02:	f7fa fb69 	bl	80212d8 <XMC_FLASH_ClearStatus>
        XMC_FLASH_EraseSector((uint32_t*)sector_start_addr);
 8026c06:	4811      	ldr	r0, [pc, #68]	; (8026c4c <E_EEPROM_XMC4_Init+0x220>)
 8026c08:	f7fa fb9e 	bl	8021348 <XMC_FLASH_EraseSector>

        if (XMC_FLASH_GetStatus() != (uint32_t)XMC_FLASH_STATUS_ERASE_STATE)
 8026c0c:	f7fa fb6a 	bl	80212e4 <XMC_FLASH_GetStatus>
 8026c10:	2820      	cmp	r0, #32
 8026c12:	d104      	bne.n	8026c1e <E_EEPROM_XMC4_Init+0x1f2>
        {
          status = E_EEPROM_XMC4_STATUS_ERASE_ERROR;
          break;
        }
        e_eeprom_xmc4_sector_info.erase_state &= ~(((uint32_t)1U << sector_count));
 8026c14:	68e3      	ldr	r3, [r4, #12]
 8026c16:	f023 0304 	bic.w	r3, r3, #4
 8026c1a:	60e3      	str	r3, [r4, #12]
 8026c1c:	e792      	b.n	8026b44 <E_EEPROM_XMC4_Init+0x118>
        XMC_FLASH_ClearStatus();
        XMC_FLASH_EraseSector((uint32_t*)sector_start_addr);

        if (XMC_FLASH_GetStatus() != (uint32_t)XMC_FLASH_STATUS_ERASE_STATE)
        {
          status = E_EEPROM_XMC4_STATUS_ERASE_ERROR;
 8026c1e:	2004      	movs	r0, #4
 8026c20:	e7a0      	b.n	8026b64 <E_EEPROM_XMC4_Init+0x138>
 8026c22:	9800      	ldr	r0, [sp, #0]
 8026c24:	e79e      	b.n	8026b64 <E_EEPROM_XMC4_Init+0x138>
 8026c26:	bf00      	nop
 8026c28:	1fff0f84 	.word	0x1fff0f84
 8026c2c:	58001000 	.word	0x58001000
 8026c30:	0c010000 	.word	0x0c010000
 8026c34:	0802aecc 	.word	0x0802aecc
 8026c38:	1ffe89cc 	.word	0x1ffe89cc
 8026c3c:	1fff0f80 	.word	0x1fff0f80
 8026c40:	0c01ffff 	.word	0x0c01ffff
 8026c44:	0c01c000 	.word	0x0c01c000
 8026c48:	0c014000 	.word	0x0c014000
 8026c4c:	0c018000 	.word	0x0c018000
 8026c50:	50020020 	.word	0x50020020

08026c54 <E_EEPROM_XMC4_WriteArray>:



/* Update a set of bytes to RAM buffer*/
bool E_EEPROM_XMC4_WriteArray(const uint16_t offset_address, const uint8_t *const data, const uint16_t length)
{
 8026c54:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  XMC_ASSERT("E_EEPROM_XMC4_WriteArray: Wrong offset address", (offset_address  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))
  XMC_ASSERT("E_EEPROM_XMC4_WriteArray: Wrong length",
                                                    ((offset_address + length)  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))

  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;
 8026c58:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 8026d04 <E_EEPROM_XMC4_WriteArray+0xb0>
 8026c5c:	f100 0408 	add.w	r4, r0, #8
 8026c60:	4444      	add	r4, r8



/* Update a set of bytes to RAM buffer*/
bool E_EEPROM_XMC4_WriteArray(const uint16_t offset_address, const uint8_t *const data, const uint16_t length)
{
 8026c62:	4607      	mov	r7, r0
  XMC_ASSERT("E_EEPROM_XMC4_WriteArray: Wrong offset address", (offset_address  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))
  XMC_ASSERT("E_EEPROM_XMC4_WriteArray: Wrong length",
                                                    ((offset_address + length)  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))

  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;
  status = (memcmp(address_ptr, data, length) != 0);
 8026c64:	4620      	mov	r0, r4



/* Update a set of bytes to RAM buffer*/
bool E_EEPROM_XMC4_WriteArray(const uint16_t offset_address, const uint8_t *const data, const uint16_t length)
{
 8026c66:	460d      	mov	r5, r1
 8026c68:	4616      	mov	r6, r2
  XMC_ASSERT("E_EEPROM_XMC4_WriteArray: Wrong offset address", (offset_address  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))
  XMC_ASSERT("E_EEPROM_XMC4_WriteArray: Wrong length",
                                                    ((offset_address + length)  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))

  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;
  status = (memcmp(address_ptr, data, length) != 0);
 8026c6a:	f003 ff49 	bl	802ab00 <memcmp>
 8026c6e:	3000      	adds	r0, #0
 8026c70:	bf18      	it	ne
 8026c72:	2001      	movne	r0, #1

  for (i = 0U; i < length; i++)
 8026c74:	2e00      	cmp	r6, #0
 8026c76:	d041      	beq.n	8026cfc <E_EEPROM_XMC4_WriteArray+0xa8>
 8026c78:	370c      	adds	r7, #12
 8026c7a:	4447      	add	r7, r8
 8026c7c:	1d2b      	adds	r3, r5, #4
 8026c7e:	42bd      	cmp	r5, r7
 8026c80:	bf38      	it	cc
 8026c82:	429c      	cmpcc	r4, r3
 8026c84:	bf2c      	ite	cs
 8026c86:	2701      	movcs	r7, #1
 8026c88:	2700      	movcc	r7, #0
 8026c8a:	2e09      	cmp	r6, #9
 8026c8c:	bf94      	ite	ls
 8026c8e:	2700      	movls	r7, #0
 8026c90:	f007 0701 	andhi.w	r7, r7, #1
 8026c94:	46a6      	mov	lr, r4
 8026c96:	b337      	cbz	r7, 8026ce6 <E_EEPROM_XMC4_WriteArray+0x92>
 8026c98:	ea44 0305 	orr.w	r3, r4, r5
 8026c9c:	079b      	lsls	r3, r3, #30
 8026c9e:	d122      	bne.n	8026ce6 <E_EEPROM_XMC4_WriteArray+0x92>
 8026ca0:	1f32      	subs	r2, r6, #4
 8026ca2:	f3c2 028d 	ubfx	r2, r2, #2, #14
 8026ca6:	3201      	adds	r2, #1
 8026ca8:	0093      	lsls	r3, r2, #2
 8026caa:	b29b      	uxth	r3, r3
 8026cac:	1f2f      	subs	r7, r5, #4
 8026cae:	2100      	movs	r1, #0
 8026cb0:	3101      	adds	r1, #1
 8026cb2:	fa1f fc81 	uxth.w	ip, r1
  {
      *(address_ptr + i) = *(data + i);
 8026cb6:	f857 8f04 	ldr.w	r8, [r7, #4]!
 8026cba:	f84e 8b04 	str.w	r8, [lr], #4
 8026cbe:	4562      	cmp	r2, ip
 8026cc0:	d8f6      	bhi.n	8026cb0 <E_EEPROM_XMC4_WriteArray+0x5c>
 8026cc2:	429e      	cmp	r6, r3
 8026cc4:	d01a      	beq.n	8026cfc <E_EEPROM_XMC4_WriteArray+0xa8>
                                                    ((offset_address + length)  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))

  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;
  status = (memcmp(address_ptr, data, length) != 0);

  for (i = 0U; i < length; i++)
 8026cc6:	1c5a      	adds	r2, r3, #1
 8026cc8:	b292      	uxth	r2, r2
  {
      *(address_ptr + i) = *(data + i);
 8026cca:	5ce9      	ldrb	r1, [r5, r3]
 8026ccc:	54e1      	strb	r1, [r4, r3]
                                                    ((offset_address + length)  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))

  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;
  status = (memcmp(address_ptr, data, length) != 0);

  for (i = 0U; i < length; i++)
 8026cce:	4296      	cmp	r6, r2
 8026cd0:	d914      	bls.n	8026cfc <E_EEPROM_XMC4_WriteArray+0xa8>
 8026cd2:	3302      	adds	r3, #2
 8026cd4:	b29b      	uxth	r3, r3
  {
      *(address_ptr + i) = *(data + i);
 8026cd6:	5ca9      	ldrb	r1, [r5, r2]
 8026cd8:	54a1      	strb	r1, [r4, r2]
                                                    ((offset_address + length)  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))

  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;
  status = (memcmp(address_ptr, data, length) != 0);

  for (i = 0U; i < length; i++)
 8026cda:	429e      	cmp	r6, r3
 8026cdc:	d910      	bls.n	8026d00 <E_EEPROM_XMC4_WriteArray+0xac>
  {
      *(address_ptr + i) = *(data + i);
 8026cde:	5cea      	ldrb	r2, [r5, r3]
 8026ce0:	54e2      	strb	r2, [r4, r3]
 8026ce2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8026ce6:	3e01      	subs	r6, #1
 8026ce8:	fa15 f686 	uxtah	r6, r5, r6
 8026cec:	3c01      	subs	r4, #1
 8026cee:	3d01      	subs	r5, #1
 8026cf0:	f815 3f01 	ldrb.w	r3, [r5, #1]!
 8026cf4:	f804 3f01 	strb.w	r3, [r4, #1]!
                                                    ((offset_address + length)  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))

  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;
  status = (memcmp(address_ptr, data, length) != 0);

  for (i = 0U; i < length; i++)
 8026cf8:	42b5      	cmp	r5, r6
 8026cfa:	d1f9      	bne.n	8026cf0 <E_EEPROM_XMC4_WriteArray+0x9c>
  {
      *(address_ptr + i) = *(data + i);
  }

  return status;
}
 8026cfc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8026d00:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8026d04:	1fff0f84 	.word	0x1fff0f84

08026d08 <E_EEPROM_XMC4_ReadArray>:



/* Read a set of bytes from RAM Buffer */
void E_EEPROM_XMC4_ReadArray(const uint16_t offset_address, uint8_t *const data, const uint16_t length)
{
 8026d08:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint16_t i;
  uint8_t  *address_ptr;
  XMC_ASSERT("E_EEPROM_XMC4_ReadArray: Wrong offset address", (offset_address  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))
  XMC_ASSERT("E_EEPROM_XMC4_ReadArray: Wrong length",
                                                    ((offset_address + length)  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))
  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;
 8026d0a:	4c24      	ldr	r4, [pc, #144]	; (8026d9c <E_EEPROM_XMC4_ReadArray+0x94>)
 8026d0c:	f100 0308 	add.w	r3, r0, #8
 8026d10:	4423      	add	r3, r4

  for (i=0U; i<length; i++)
 8026d12:	2a00      	cmp	r2, #0
 8026d14:	d040      	beq.n	8026d98 <E_EEPROM_XMC4_ReadArray+0x90>
 8026d16:	300c      	adds	r0, #12
 8026d18:	4420      	add	r0, r4
 8026d1a:	1d0c      	adds	r4, r1, #4
 8026d1c:	4281      	cmp	r1, r0
 8026d1e:	bf38      	it	cc
 8026d20:	42a3      	cmpcc	r3, r4
 8026d22:	bf2c      	ite	cs
 8026d24:	2001      	movcs	r0, #1
 8026d26:	2000      	movcc	r0, #0
 8026d28:	2a09      	cmp	r2, #9
 8026d2a:	bf94      	ite	ls
 8026d2c:	2000      	movls	r0, #0
 8026d2e:	f000 0001 	andhi.w	r0, r0, #1
 8026d32:	b330      	cbz	r0, 8026d82 <E_EEPROM_XMC4_ReadArray+0x7a>
 8026d34:	ea43 0001 	orr.w	r0, r3, r1
 8026d38:	0780      	lsls	r0, r0, #30
 8026d3a:	d122      	bne.n	8026d82 <E_EEPROM_XMC4_ReadArray+0x7a>
 8026d3c:	1f14      	subs	r4, r2, #4
 8026d3e:	f3c4 048d 	ubfx	r4, r4, #2, #14
 8026d42:	3401      	adds	r4, #1
 8026d44:	00a0      	lsls	r0, r4, #2
 8026d46:	b280      	uxth	r0, r0
 8026d48:	1f1f      	subs	r7, r3, #4
 8026d4a:	460e      	mov	r6, r1
 8026d4c:	2500      	movs	r5, #0
 8026d4e:	3501      	adds	r5, #1
 8026d50:	fa1f fe85 	uxth.w	lr, r5
  {
    *(data + i) = *(address_ptr + i);
 8026d54:	f857 cf04 	ldr.w	ip, [r7, #4]!
 8026d58:	f846 cb04 	str.w	ip, [r6], #4
 8026d5c:	4574      	cmp	r4, lr
 8026d5e:	d8f6      	bhi.n	8026d4e <E_EEPROM_XMC4_ReadArray+0x46>
 8026d60:	4282      	cmp	r2, r0
 8026d62:	d019      	beq.n	8026d98 <E_EEPROM_XMC4_ReadArray+0x90>
  XMC_ASSERT("E_EEPROM_XMC4_ReadArray: Wrong offset address", (offset_address  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))
  XMC_ASSERT("E_EEPROM_XMC4_ReadArray: Wrong length",
                                                    ((offset_address + length)  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))
  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;

  for (i=0U; i<length; i++)
 8026d64:	1c44      	adds	r4, r0, #1
 8026d66:	b2a4      	uxth	r4, r4
  {
    *(data + i) = *(address_ptr + i);
 8026d68:	5c1d      	ldrb	r5, [r3, r0]
 8026d6a:	540d      	strb	r5, [r1, r0]
  XMC_ASSERT("E_EEPROM_XMC4_ReadArray: Wrong offset address", (offset_address  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))
  XMC_ASSERT("E_EEPROM_XMC4_ReadArray: Wrong length",
                                                    ((offset_address + length)  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))
  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;

  for (i=0U; i<length; i++)
 8026d6c:	42a2      	cmp	r2, r4
 8026d6e:	d913      	bls.n	8026d98 <E_EEPROM_XMC4_ReadArray+0x90>
 8026d70:	3002      	adds	r0, #2
 8026d72:	b280      	uxth	r0, r0
  {
    *(data + i) = *(address_ptr + i);
 8026d74:	5d1d      	ldrb	r5, [r3, r4]
 8026d76:	550d      	strb	r5, [r1, r4]
  XMC_ASSERT("E_EEPROM_XMC4_ReadArray: Wrong offset address", (offset_address  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))
  XMC_ASSERT("E_EEPROM_XMC4_ReadArray: Wrong length",
                                                    ((offset_address + length)  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))
  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;

  for (i=0U; i<length; i++)
 8026d78:	4282      	cmp	r2, r0
 8026d7a:	d90e      	bls.n	8026d9a <E_EEPROM_XMC4_ReadArray+0x92>
  {
    *(data + i) = *(address_ptr + i);
 8026d7c:	5c1b      	ldrb	r3, [r3, r0]
 8026d7e:	540b      	strb	r3, [r1, r0]
 8026d80:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8026d82:	3a01      	subs	r2, #1
 8026d84:	fa13 f282 	uxtah	r2, r3, r2
 8026d88:	3901      	subs	r1, #1
 8026d8a:	3b01      	subs	r3, #1
 8026d8c:	f813 0f01 	ldrb.w	r0, [r3, #1]!
 8026d90:	f801 0f01 	strb.w	r0, [r1, #1]!
  XMC_ASSERT("E_EEPROM_XMC4_ReadArray: Wrong offset address", (offset_address  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))
  XMC_ASSERT("E_EEPROM_XMC4_ReadArray: Wrong length",
                                                    ((offset_address + length)  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))
  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;

  for (i=0U; i<length; i++)
 8026d94:	4293      	cmp	r3, r2
 8026d96:	d1f9      	bne.n	8026d8c <E_EEPROM_XMC4_ReadArray+0x84>
 8026d98:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8026d9a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8026d9c:	1fff0f84 	.word	0x1fff0f84

08026da0 <E_EEPROM_XMC4_UpdateFlashContents>:



/* Copy data blocks from RAM to FLASH */
E_EEPROM_XMC4_STATUS_t E_EEPROM_XMC4_UpdateFlashContents(void)
{
 8026da0:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Calculate the starting address of the active sector from where the first write started for the current cycle*/
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR +
                     (E_EEPROM_XMC4_SECTOR_SIZE * e_eeprom_xmc4_sector_info.current_sector);

  /* If the next free address crosses current active sector starting address, then all the sectors are fully written*/
  if ((e_eeprom_xmc4_sector_info.next_free_start_addr == sector_start_addr) &&
 8026da2:	4e4c      	ldr	r6, [pc, #304]	; (8026ed4 <E_EEPROM_XMC4_UpdateFlashContents+0x134>)
     (e_eeprom_xmc4_data_buffer.block_cycle_count != 0U))
 8026da4:	4f4c      	ldr	r7, [pc, #304]	; (8026ed8 <E_EEPROM_XMC4_UpdateFlashContents+0x138>)
  uint32_t sector_start_addr;

  status = E_EEPROM_XMC4_STATUS_OK;

  /* Calculate the starting address of the active sector from where the first write started for the current cycle*/
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR +
 8026da6:	68b3      	ldr	r3, [r6, #8]
                     (E_EEPROM_XMC4_SECTOR_SIZE * e_eeprom_xmc4_sector_info.current_sector);

  /* If the next free address crosses current active sector starting address, then all the sectors are fully written*/
  if ((e_eeprom_xmc4_sector_info.next_free_start_addr == sector_start_addr) &&
 8026da8:	6834      	ldr	r4, [r6, #0]
  uint32_t sector_start_addr;

  status = E_EEPROM_XMC4_STATUS_OK;

  /* Calculate the starting address of the active sector from where the first write started for the current cycle*/
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR +
 8026daa:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8026dae:	3304      	adds	r3, #4
                     (E_EEPROM_XMC4_SECTOR_SIZE * e_eeprom_xmc4_sector_info.current_sector);

  /* If the next free address crosses current active sector starting address, then all the sectors are fully written*/
  if ((e_eeprom_xmc4_sector_info.next_free_start_addr == sector_start_addr) &&
 8026db0:	ebb4 3f83 	cmp.w	r4, r3, lsl #14



/* Copy data blocks from RAM to FLASH */
E_EEPROM_XMC4_STATUS_t E_EEPROM_XMC4_UpdateFlashContents(void)
{
 8026db4:	b083      	sub	sp, #12
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR +
                     (E_EEPROM_XMC4_SECTOR_SIZE * e_eeprom_xmc4_sector_info.current_sector);

  /* If the next free address crosses current active sector starting address, then all the sectors are fully written*/
  if ((e_eeprom_xmc4_sector_info.next_free_start_addr == sector_start_addr) &&
     (e_eeprom_xmc4_data_buffer.block_cycle_count != 0U))
 8026db6:	687b      	ldr	r3, [r7, #4]
  /* Calculate the starting address of the active sector from where the first write started for the current cycle*/
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR +
                     (E_EEPROM_XMC4_SECTOR_SIZE * e_eeprom_xmc4_sector_info.current_sector);

  /* If the next free address crosses current active sector starting address, then all the sectors are fully written*/
  if ((e_eeprom_xmc4_sector_info.next_free_start_addr == sector_start_addr) &&
 8026db8:	d030      	beq.n	8026e1c <E_EEPROM_XMC4_UpdateFlashContents+0x7c>
 8026dba:	f8df e13c 	ldr.w	lr, [pc, #316]	; 8026ef8 <E_EEPROM_XMC4_UpdateFlashContents+0x158>
  uint32_t result;

  /* Reset the CRC result register before new CRC calculation */
  XMC_FCE_InitializeSeedValue(&e_eeprom_xmc4_fce, 0U);

  (void)XMC_FCE_CalculateCRC32(&e_eeprom_xmc4_fce, data_start_addr, E_EEPROM_XMC4_DATA_SIZE_FOR_CRC, &result);
 8026dbe:	4947      	ldr	r1, [pc, #284]	; (8026edc <E_EEPROM_XMC4_UpdateFlashContents+0x13c>)
 8026dc0:	4847      	ldr	r0, [pc, #284]	; (8026ee0 <E_EEPROM_XMC4_UpdateFlashContents+0x140>)
    status = E_EEPROM_XMC4_lInitEraseStateMachine();
  }

  if (status ==  E_EEPROM_XMC4_STATUS_OK)
  {
    e_eeprom_xmc4_data_buffer.block_cycle_count++;
 8026dc2:	3301      	adds	r3, #1
 8026dc4:	f04f 0c00 	mov.w	ip, #0
 8026dc8:	607b      	str	r3, [r7, #4]
  uint32_t result;

  /* Reset the CRC result register before new CRC calculation */
  XMC_FCE_InitializeSeedValue(&e_eeprom_xmc4_fce, 0U);

  (void)XMC_FCE_CalculateCRC32(&e_eeprom_xmc4_fce, data_start_addr, E_EEPROM_XMC4_DATA_SIZE_FOR_CRC, &result);
 8026dca:	f640 72fc 	movw	r2, #4092	; 0xffc
 8026dce:	ab01      	add	r3, sp, #4
 8026dd0:	f8ce c018 	str.w	ip, [lr, #24]
  uint32_t  page_index;
  E_EEPROM_XMC4_STATUS_t status;

  status = E_EEPROM_XMC4_STATUS_OK;
  flash_addr_ptr = (uint32_t*)e_eeprom_xmc4_sector_info.next_free_start_addr;
  ram_addr_ptr   = (uint32_t*)(void*)&e_eeprom_xmc4_data_buffer;
 8026dd4:	1f0d      	subs	r5, r1, #4
  uint32_t result;

  /* Reset the CRC result register before new CRC calculation */
  XMC_FCE_InitializeSeedValue(&e_eeprom_xmc4_fce, 0U);

  (void)XMC_FCE_CalculateCRC32(&e_eeprom_xmc4_fce, data_start_addr, E_EEPROM_XMC4_DATA_SIZE_FOR_CRC, &result);
 8026dd6:	f7fb f9d1 	bl	802217c <XMC_FCE_CalculateCRC32>

  return (result);
 8026dda:	9b01      	ldr	r3, [sp, #4]

  status = E_EEPROM_XMC4_STATUS_OK;
  flash_addr_ptr = (uint32_t*)e_eeprom_xmc4_sector_info.next_free_start_addr;
  ram_addr_ptr   = (uint32_t*)(void*)&e_eeprom_xmc4_data_buffer;

  e_eeprom_xmc4_data_buffer.crc = E_EEPROM_XMC4_lCalculateCRC((uint32_t*)(void*)
 8026ddc:	603b      	str	r3, [r7, #0]
 8026dde:	f504 5780 	add.w	r7, r4, #4096	; 0x1000
                                                             (&(e_eeprom_xmc4_data_buffer.block_cycle_count)));

  for (page_index = 0U ; page_index < E_EEPROM_XMC4_MAX_PAGES; page_index++)
  {
    XMC_FLASH_ClearStatus();
 8026de2:	f7fa fa79 	bl	80212d8 <XMC_FLASH_ClearStatus>

    XMC_FLASH_ProgramPage(flash_addr_ptr,ram_addr_ptr);
 8026de6:	4620      	mov	r0, r4
 8026de8:	4629      	mov	r1, r5
 8026dea:	f7fa fa83 	bl	80212f4 <XMC_FLASH_ProgramPage>

    if (XMC_FLASH_GetStatus() == (uint32_t)XMC_FLASH_STATUS_VERIFY_ERROR)
 8026dee:	f7fa fa79 	bl	80212e4 <XMC_FLASH_GetStatus>
 8026df2:	f1b0 4f00 	cmp.w	r0, #2147483648	; 0x80000000
    {
      status = E_EEPROM_XMC4_STATUS_WRITE_ERROR;
      break;
    }
    ram_addr_ptr   += E_EEPROM_XMC4_MIN_WORDS_PER_PAGE ;
    flash_addr_ptr += E_EEPROM_XMC4_MIN_WORDS_PER_PAGE ;
 8026df6:	f504 7480 	add.w	r4, r4, #256	; 0x100
    if (XMC_FLASH_GetStatus() == (uint32_t)XMC_FLASH_STATUS_VERIFY_ERROR)
    {
      status = E_EEPROM_XMC4_STATUS_WRITE_ERROR;
      break;
    }
    ram_addr_ptr   += E_EEPROM_XMC4_MIN_WORDS_PER_PAGE ;
 8026dfa:	f505 7580 	add.w	r5, r5, #256	; 0x100
  {
    XMC_FLASH_ClearStatus();

    XMC_FLASH_ProgramPage(flash_addr_ptr,ram_addr_ptr);

    if (XMC_FLASH_GetStatus() == (uint32_t)XMC_FLASH_STATUS_VERIFY_ERROR)
 8026dfe:	d039      	beq.n	8026e74 <E_EEPROM_XMC4_UpdateFlashContents+0xd4>
  ram_addr_ptr   = (uint32_t*)(void*)&e_eeprom_xmc4_data_buffer;

  e_eeprom_xmc4_data_buffer.crc = E_EEPROM_XMC4_lCalculateCRC((uint32_t*)(void*)
                                                             (&(e_eeprom_xmc4_data_buffer.block_cycle_count)));

  for (page_index = 0U ; page_index < E_EEPROM_XMC4_MAX_PAGES; page_index++)
 8026e00:	42bc      	cmp	r4, r7
 8026e02:	d1ee      	bne.n	8026de2 <E_EEPROM_XMC4_UpdateFlashContents+0x42>
    status = E_EEPROM_XMC4_lWriteToFlash();

    /* If the flash write succeeds, update the latest flash data location in RAM for reference */
    if (status == E_EEPROM_XMC4_STATUS_OK)
    {
      e_eeprom_xmc4_sector_info.flash_data_addr = e_eeprom_xmc4_sector_info.next_free_start_addr;
 8026e04:	6833      	ldr	r3, [r6, #0]
 8026e06:	6073      	str	r3, [r6, #4]
  uint32_t *flash_addr_ptr;
  uint32_t *ram_addr_ptr;
  uint32_t  page_index;
  E_EEPROM_XMC4_STATUS_t status;

  status = E_EEPROM_XMC4_STATUS_OK;
 8026e08:	2000      	movs	r0, #0

    /* Update the next free address to write the new data block*/
    e_eeprom_xmc4_sector_info.next_free_start_addr += E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;

    /* If the next free address crosses 3rd sector end address relocate the address to 0th sector starting address*/
    if (e_eeprom_xmc4_sector_info.next_free_start_addr >= E_EEPROM_XMC4_SECTOR4_START_ADDR)
 8026e0a:	4a36      	ldr	r2, [pc, #216]	; (8026ee4 <E_EEPROM_XMC4_UpdateFlashContents+0x144>)
    {
      e_eeprom_xmc4_sector_info.flash_data_addr = e_eeprom_xmc4_sector_info.next_free_start_addr;
    }

    /* Update the next free address to write the new data block*/
    e_eeprom_xmc4_sector_info.next_free_start_addr += E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;
 8026e0c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000

    /* If the next free address crosses 3rd sector end address relocate the address to 0th sector starting address*/
    if (e_eeprom_xmc4_sector_info.next_free_start_addr >= E_EEPROM_XMC4_SECTOR4_START_ADDR)
 8026e10:	4293      	cmp	r3, r2
    {
      e_eeprom_xmc4_sector_info.next_free_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR;
 8026e12:	bf88      	it	hi
 8026e14:	4b34      	ldrhi	r3, [pc, #208]	; (8026ee8 <E_EEPROM_XMC4_UpdateFlashContents+0x148>)
 8026e16:	6033      	str	r3, [r6, #0]
    }
  }

  return (status);
}
 8026e18:	b003      	add	sp, #12
 8026e1a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  /* Calculate the starting address of the active sector from where the first write started for the current cycle*/
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR +
                     (E_EEPROM_XMC4_SECTOR_SIZE * e_eeprom_xmc4_sector_info.current_sector);

  /* If the next free address crosses current active sector starting address, then all the sectors are fully written*/
  if ((e_eeprom_xmc4_sector_info.next_free_start_addr == sector_start_addr) &&
 8026e1c:	2b00      	cmp	r3, #0
 8026e1e:	d0cc      	beq.n	8026dba <E_EEPROM_XMC4_UpdateFlashContents+0x1a>
     (e_eeprom_xmc4_data_buffer.block_cycle_count != 0U))
  {
    /* Update the current sector to the latest sector on which the last write was executed. */
    e_eeprom_xmc4_sector_info.current_sector =  ((e_eeprom_xmc4_sector_info.flash_data_addr &
 8026e20:	6873      	ldr	r3, [r6, #4]
                                                E_EEPROM_XMC4_SECTOR_POSITION_MASK) >>
                                                E_EEPROM_XMC4_SECTOR_POSITION);

    /* Mark all the sectors as filled with data */
    e_eeprom_xmc4_sector_info.erase_state = E_EEPROM_XMC4_ALL_SECTORS_FILLED ;
 8026e22:	220f      	movs	r2, #15
  if ((e_eeprom_xmc4_sector_info.next_free_start_addr == sector_start_addr) &&
     (e_eeprom_xmc4_data_buffer.block_cycle_count != 0U))
  {
    /* Update the current sector to the latest sector on which the last write was executed. */
    e_eeprom_xmc4_sector_info.current_sector =  ((e_eeprom_xmc4_sector_info.flash_data_addr &
                                                E_EEPROM_XMC4_SECTOR_POSITION_MASK) >>
 8026e24:	f3c3 3381 	ubfx	r3, r3, #14, #2
  /* If the next free address crosses current active sector starting address, then all the sectors are fully written*/
  if ((e_eeprom_xmc4_sector_info.next_free_start_addr == sector_start_addr) &&
     (e_eeprom_xmc4_data_buffer.block_cycle_count != 0U))
  {
    /* Update the current sector to the latest sector on which the last write was executed. */
    e_eeprom_xmc4_sector_info.current_sector =  ((e_eeprom_xmc4_sector_info.flash_data_addr &
 8026e28:	60b3      	str	r3, [r6, #8]
                                                E_EEPROM_XMC4_SECTOR_POSITION_MASK) >>
                                                E_EEPROM_XMC4_SECTOR_POSITION);

    /* Mark all the sectors as filled with data */
    e_eeprom_xmc4_sector_info.erase_state = E_EEPROM_XMC4_ALL_SECTORS_FILLED ;
 8026e2a:	60f2      	str	r2, [r6, #12]
  sector_count = 0U;

  do
  {
    /* If the non empty sector is the current active sector, then do not erase it*/
    if (e_eeprom_xmc4_sector_info.current_sector != sector_count)
 8026e2c:	b32b      	cbz	r3, 8026e7a <E_EEPROM_XMC4_UpdateFlashContents+0xda>
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
      {
        sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR + (E_EEPROM_XMC4_SECTOR_SIZE * (uint32_t)sector_count);

        XMC_FLASH_ClearStatus();
 8026e2e:	f7fa fa53 	bl	80212d8 <XMC_FLASH_ClearStatus>
        XMC_FLASH_EraseSector((uint32_t*)sector_start_addr);
 8026e32:	482d      	ldr	r0, [pc, #180]	; (8026ee8 <E_EEPROM_XMC4_UpdateFlashContents+0x148>)
 8026e34:	f7fa fa88 	bl	8021348 <XMC_FLASH_EraseSector>

        if (XMC_FLASH_GetStatus() != (uint32_t)XMC_FLASH_STATUS_ERASE_STATE)
 8026e38:	f7fa fa54 	bl	80212e4 <XMC_FLASH_GetStatus>
 8026e3c:	2820      	cmp	r0, #32
 8026e3e:	d146      	bne.n	8026ece <E_EEPROM_XMC4_UpdateFlashContents+0x12e>
        {
          status = E_EEPROM_XMC4_STATUS_ERASE_ERROR;
          break;
        }
        e_eeprom_xmc4_sector_info.erase_state &= ~(((uint32_t)1U << sector_count));
 8026e40:	68f3      	ldr	r3, [r6, #12]
  sector_count = 0U;

  do
  {
    /* If the non empty sector is the current active sector, then do not erase it*/
    if (e_eeprom_xmc4_sector_info.current_sector != sector_count)
 8026e42:	68b2      	ldr	r2, [r6, #8]
        if (XMC_FLASH_GetStatus() != (uint32_t)XMC_FLASH_STATUS_ERASE_STATE)
        {
          status = E_EEPROM_XMC4_STATUS_ERASE_ERROR;
          break;
        }
        e_eeprom_xmc4_sector_info.erase_state &= ~(((uint32_t)1U << sector_count));
 8026e44:	f023 0301 	bic.w	r3, r3, #1
  sector_count = 0U;

  do
  {
    /* If the non empty sector is the current active sector, then do not erase it*/
    if (e_eeprom_xmc4_sector_info.current_sector != sector_count)
 8026e48:	2a01      	cmp	r2, #1
        if (XMC_FLASH_GetStatus() != (uint32_t)XMC_FLASH_STATUS_ERASE_STATE)
        {
          status = E_EEPROM_XMC4_STATUS_ERASE_ERROR;
          break;
        }
        e_eeprom_xmc4_sector_info.erase_state &= ~(((uint32_t)1U << sector_count));
 8026e4a:	60f3      	str	r3, [r6, #12]
  sector_count = 0U;

  do
  {
    /* If the non empty sector is the current active sector, then do not erase it*/
    if (e_eeprom_xmc4_sector_info.current_sector != sector_count)
 8026e4c:	d004      	beq.n	8026e58 <E_EEPROM_XMC4_UpdateFlashContents+0xb8>
    {
      /* Check if the sector was previously identified as non-empty. i.e It is having old data or corrupted data
       * If so erase the sector and mark it as erase attempted.
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
 8026e4e:	0799      	lsls	r1, r3, #30
 8026e50:	d413      	bmi.n	8026e7a <E_EEPROM_XMC4_UpdateFlashContents+0xda>
  sector_count = 0U;

  do
  {
    /* If the non empty sector is the current active sector, then do not erase it*/
    if (e_eeprom_xmc4_sector_info.current_sector != sector_count)
 8026e52:	68b3      	ldr	r3, [r6, #8]
 8026e54:	2b02      	cmp	r3, #2
 8026e56:	d006      	beq.n	8026e66 <E_EEPROM_XMC4_UpdateFlashContents+0xc6>
    {
      /* Check if the sector was previously identified as non-empty. i.e It is having old data or corrupted data
       * If so erase the sector and mark it as erase attempted.
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
 8026e58:	68f3      	ldr	r3, [r6, #12]
 8026e5a:	4c1e      	ldr	r4, [pc, #120]	; (8026ed4 <E_EEPROM_XMC4_UpdateFlashContents+0x134>)
 8026e5c:	075a      	lsls	r2, r3, #29
 8026e5e:	d428      	bmi.n	8026eb2 <E_EEPROM_XMC4_UpdateFlashContents+0x112>
  sector_count = 0U;

  do
  {
    /* If the non empty sector is the current active sector, then do not erase it*/
    if (e_eeprom_xmc4_sector_info.current_sector != sector_count)
 8026e60:	68b3      	ldr	r3, [r6, #8]
 8026e62:	2b03      	cmp	r3, #3
 8026e64:	d003      	beq.n	8026e6e <E_EEPROM_XMC4_UpdateFlashContents+0xce>
    {
      /* Check if the sector was previously identified as non-empty. i.e It is having old data or corrupted data
       * If so erase the sector and mark it as erase attempted.
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
 8026e66:	68f3      	ldr	r3, [r6, #12]
 8026e68:	4c1a      	ldr	r4, [pc, #104]	; (8026ed4 <E_EEPROM_XMC4_UpdateFlashContents+0x134>)
 8026e6a:	071b      	lsls	r3, r3, #28
 8026e6c:	d413      	bmi.n	8026e96 <E_EEPROM_XMC4_UpdateFlashContents+0xf6>
 8026e6e:	6834      	ldr	r4, [r6, #0]
 8026e70:	687b      	ldr	r3, [r7, #4]
 8026e72:	e7a2      	b.n	8026dba <E_EEPROM_XMC4_UpdateFlashContents+0x1a>
 8026e74:	6833      	ldr	r3, [r6, #0]

    XMC_FLASH_ProgramPage(flash_addr_ptr,ram_addr_ptr);

    if (XMC_FLASH_GetStatus() == (uint32_t)XMC_FLASH_STATUS_VERIFY_ERROR)
    {
      status = E_EEPROM_XMC4_STATUS_WRITE_ERROR;
 8026e76:	2003      	movs	r0, #3
 8026e78:	e7c7      	b.n	8026e0a <E_EEPROM_XMC4_UpdateFlashContents+0x6a>
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
      {
        sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR + (E_EEPROM_XMC4_SECTOR_SIZE * (uint32_t)sector_count);

        XMC_FLASH_ClearStatus();
 8026e7a:	f7fa fa2d 	bl	80212d8 <XMC_FLASH_ClearStatus>
        XMC_FLASH_EraseSector((uint32_t*)sector_start_addr);
 8026e7e:	481b      	ldr	r0, [pc, #108]	; (8026eec <E_EEPROM_XMC4_UpdateFlashContents+0x14c>)
 8026e80:	f7fa fa62 	bl	8021348 <XMC_FLASH_EraseSector>

        if (XMC_FLASH_GetStatus() != (uint32_t)XMC_FLASH_STATUS_ERASE_STATE)
 8026e84:	f7fa fa2e 	bl	80212e4 <XMC_FLASH_GetStatus>
 8026e88:	2820      	cmp	r0, #32
 8026e8a:	d120      	bne.n	8026ece <E_EEPROM_XMC4_UpdateFlashContents+0x12e>
        {
          status = E_EEPROM_XMC4_STATUS_ERASE_ERROR;
          break;
        }
        e_eeprom_xmc4_sector_info.erase_state &= ~(((uint32_t)1U << sector_count));
 8026e8c:	68f3      	ldr	r3, [r6, #12]
 8026e8e:	f023 0302 	bic.w	r3, r3, #2
 8026e92:	60f3      	str	r3, [r6, #12]
 8026e94:	e7dd      	b.n	8026e52 <E_EEPROM_XMC4_UpdateFlashContents+0xb2>
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
      {
        sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR + (E_EEPROM_XMC4_SECTOR_SIZE * (uint32_t)sector_count);

        XMC_FLASH_ClearStatus();
 8026e96:	f7fa fa1f 	bl	80212d8 <XMC_FLASH_ClearStatus>
        XMC_FLASH_EraseSector((uint32_t*)sector_start_addr);
 8026e9a:	4815      	ldr	r0, [pc, #84]	; (8026ef0 <E_EEPROM_XMC4_UpdateFlashContents+0x150>)
 8026e9c:	f7fa fa54 	bl	8021348 <XMC_FLASH_EraseSector>

        if (XMC_FLASH_GetStatus() != (uint32_t)XMC_FLASH_STATUS_ERASE_STATE)
 8026ea0:	f7fa fa20 	bl	80212e4 <XMC_FLASH_GetStatus>
 8026ea4:	2820      	cmp	r0, #32
 8026ea6:	d112      	bne.n	8026ece <E_EEPROM_XMC4_UpdateFlashContents+0x12e>
        {
          status = E_EEPROM_XMC4_STATUS_ERASE_ERROR;
          break;
        }
        e_eeprom_xmc4_sector_info.erase_state &= ~(((uint32_t)1U << sector_count));
 8026ea8:	68e3      	ldr	r3, [r4, #12]
 8026eaa:	f023 0308 	bic.w	r3, r3, #8
 8026eae:	60e3      	str	r3, [r4, #12]
 8026eb0:	e7dd      	b.n	8026e6e <E_EEPROM_XMC4_UpdateFlashContents+0xce>
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
      {
        sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR + (E_EEPROM_XMC4_SECTOR_SIZE * (uint32_t)sector_count);

        XMC_FLASH_ClearStatus();
 8026eb2:	f7fa fa11 	bl	80212d8 <XMC_FLASH_ClearStatus>
        XMC_FLASH_EraseSector((uint32_t*)sector_start_addr);
 8026eb6:	480f      	ldr	r0, [pc, #60]	; (8026ef4 <E_EEPROM_XMC4_UpdateFlashContents+0x154>)
 8026eb8:	f7fa fa46 	bl	8021348 <XMC_FLASH_EraseSector>

        if (XMC_FLASH_GetStatus() != (uint32_t)XMC_FLASH_STATUS_ERASE_STATE)
 8026ebc:	f7fa fa12 	bl	80212e4 <XMC_FLASH_GetStatus>
 8026ec0:	2820      	cmp	r0, #32
 8026ec2:	d104      	bne.n	8026ece <E_EEPROM_XMC4_UpdateFlashContents+0x12e>
        {
          status = E_EEPROM_XMC4_STATUS_ERASE_ERROR;
          break;
        }
        e_eeprom_xmc4_sector_info.erase_state &= ~(((uint32_t)1U << sector_count));
 8026ec4:	68e3      	ldr	r3, [r4, #12]
 8026ec6:	f023 0304 	bic.w	r3, r3, #4
 8026eca:	60e3      	str	r3, [r4, #12]
 8026ecc:	e7c8      	b.n	8026e60 <E_EEPROM_XMC4_UpdateFlashContents+0xc0>
        XMC_FLASH_ClearStatus();
        XMC_FLASH_EraseSector((uint32_t*)sector_start_addr);

        if (XMC_FLASH_GetStatus() != (uint32_t)XMC_FLASH_STATUS_ERASE_STATE)
        {
          status = E_EEPROM_XMC4_STATUS_ERASE_ERROR;
 8026ece:	2004      	movs	r0, #4
 8026ed0:	e7a2      	b.n	8026e18 <E_EEPROM_XMC4_UpdateFlashContents+0x78>
 8026ed2:	bf00      	nop
 8026ed4:	1ffe89cc 	.word	0x1ffe89cc
 8026ed8:	1fff0f84 	.word	0x1fff0f84
 8026edc:	1fff0f88 	.word	0x1fff0f88
 8026ee0:	0802aecc 	.word	0x0802aecc
 8026ee4:	0c01ffff 	.word	0x0c01ffff
 8026ee8:	0c010000 	.word	0x0c010000
 8026eec:	0c014000 	.word	0x0c014000
 8026ef0:	0c01c000 	.word	0x0c01c000
 8026ef4:	0c018000 	.word	0x0c018000
 8026ef8:	50020020 	.word	0x50020020

08026efc <E_EEPROM_XMC4_IsFlashEmpty>:
bool E_EEPROM_XMC4_IsFlashEmpty(void)
{
  bool status = false;

  /* If data available flash_data_addr will have a valid address*/
  if (e_eeprom_xmc4_sector_info.flash_data_addr == 0U)
 8026efc:	4b02      	ldr	r3, [pc, #8]	; (8026f08 <E_EEPROM_XMC4_IsFlashEmpty+0xc>)
 8026efe:	6858      	ldr	r0, [r3, #4]
  {
    status = true;
  }
  return (status);
}
 8026f00:	fab0 f080 	clz	r0, r0
 8026f04:	0940      	lsrs	r0, r0, #5
 8026f06:	4770      	bx	lr
 8026f08:	1ffe89cc 	.word	0x1ffe89cc

08026f0c <EVENT_GENERATOR_Init>:
{
  /* Checking for null handle */
  XMC_ASSERT("EVENT_GENERATOR_Init:handle NULL" , (handle != NULL));
  
  /* Checking for initialization state of the instance */
  if (false == handle->init_status)
 8026f0c:	7b43      	ldrb	r3, [r0, #13]
 8026f0e:	b10b      	cbz	r3, 8026f14 <EVENT_GENERATOR_Init+0x8>
    /* Update the init status of the instance */
    handle->init_status = true;
  }
  
  return EVENT_GENERATOR_STATUS_SUCCESS;
}
 8026f10:	2000      	movs	r0, #0
 8026f12:	4770      	bx	lr

/*
 * This function Initializes a EVENT_GENERATOR APP instances based on user configuration.
 */
EVENT_GENERATOR_STATUS_t EVENT_GENERATOR_Init(EVENT_GENERATOR_t *const handle)
{
 8026f14:	b510      	push	{r4, lr}
 8026f16:	4604      	mov	r4, r0
  
  /* Checking for initialization state of the instance */
  if (false == handle->init_status)
  {
    /* Hardware initialization based on UI */
    XMC_ERU_OGU_Init(handle->eru, handle->channel, handle->config);
 8026f18:	6800      	ldr	r0, [r0, #0]
 8026f1a:	7b21      	ldrb	r1, [r4, #12]
 8026f1c:	6862      	ldr	r2, [r4, #4]
 8026f1e:	f7fb f907 	bl	8022130 <XMC_ERU_OGU_Init>
    #if (EVENT_GENERATOR_NMI_SUPPORTED == 1U)
    /* Promote the eru event as NMI, Applicable only for XMC4000 devices */
    XMC_SCU_INTERRUPT_EnableNmiRequest(handle->nmi_eru_msk);
 8026f22:	68a0      	ldr	r0, [r4, #8]
 8026f24:	f7fa fa70 	bl	8021408 <XMC_SCU_INTERRUPT_EnableNmiRequest>
    #endif
    /* Update the init status of the instance */
    handle->init_status = true;
 8026f28:	2301      	movs	r3, #1
 8026f2a:	7363      	strb	r3, [r4, #13]
  }
  
  return EVENT_GENERATOR_STATUS_SUCCESS;
}
 8026f2c:	2000      	movs	r0, #0
 8026f2e:	bd10      	pop	{r4, pc}

08026f30 <EVENT_DETECTOR_Init>:
{
  /* Checking for null handle */
  XMC_ASSERT("EVENT_DETECTOR_Init:handle NULL" , (handle != NULL));

  /* Checking for initialization state of the instance */
  if (false == handle->init_status)
 8026f30:	7b03      	ldrb	r3, [r0, #12]
 8026f32:	b10b      	cbz	r3, 8026f38 <EVENT_DETECTOR_Init+0x8>
    /* Update the init status of the instance */
    handle->init_status = true;
  }
  
  return EVENT_DETECTOR_STATUS_SUCCESS;
}
 8026f34:	2000      	movs	r0, #0
 8026f36:	4770      	bx	lr

/*
 * This function Initializes a EVENT_DETECTOR APP instances (ERSx+ETLx) based on user configuration.
 */
EVENT_DETECTOR_STATUS_t EVENT_DETECTOR_Init(EVENT_DETECTOR_t *const handle)
{
 8026f38:	b510      	push	{r4, lr}
 8026f3a:	4604      	mov	r4, r0

  /* Checking for initialization state of the instance */
  if (false == handle->init_status)
  {
    /* Hardware initialization based on UI */
    XMC_ERU_ETL_Init(handle->eru, handle->channel, handle->config);
 8026f3c:	6800      	ldr	r0, [r0, #0]
 8026f3e:	7921      	ldrb	r1, [r4, #4]
 8026f40:	68a2      	ldr	r2, [r4, #8]
 8026f42:	f7fb f8df 	bl	8022104 <XMC_ERU_ETL_Init>
    /* Update the init status of the instance */
    handle->init_status = true;
 8026f46:	2301      	movs	r3, #1
 8026f48:	7323      	strb	r3, [r4, #12]
  }
  
  return EVENT_DETECTOR_STATUS_SUCCESS;
}
 8026f4a:	2000      	movs	r0, #0
 8026f4c:	bd10      	pop	{r4, pc}
 8026f4e:	bf00      	nop

08026f50 <DMA_CH_Init>:
  return version;
}

/* DMA_CH initialization function */
DMA_CH_STATUS_t DMA_CH_Init(DMA_CH_t *const obj)
{
 8026f50:	b510      	push	{r4, lr}
 8026f52:	4604      	mov	r4, r0
  DMA_CH_STATUS_t status;

  XMC_ASSERT("DMA_CH_Init: NULL DMA_CH_t object", (obj != NULL));

  /* This cannot possibly fail! */
  GLOBAL_DMA_Init(obj->dma_global);
 8026f54:	6800      	ldr	r0, [r0, #0]
 8026f56:	f7ff fcaf 	bl	80268b8 <GLOBAL_DMA_Init>

  if (XMC_DMA_CH_Init(obj->dma_global->dma, obj->ch_num, &obj->config->ch_config) == XMC_DMA_CH_STATUS_OK)
 8026f5a:	6823      	ldr	r3, [r4, #0]
 8026f5c:	7b21      	ldrb	r1, [r4, #12]
 8026f5e:	6818      	ldr	r0, [r3, #0]
 8026f60:	6862      	ldr	r2, [r4, #4]
 8026f62:	f7fa fe85 	bl	8021c70 <XMC_DMA_CH_Init>
 8026f66:	b938      	cbnz	r0, 8026f78 <DMA_CH_Init+0x28>
  {
	if(obj->config->events)
 8026f68:	6863      	ldr	r3, [r4, #4]
 8026f6a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8026f6c:	b932      	cbnz	r2, 8026f7c <DMA_CH_Init+0x2c>
	{
		XMC_DMA_CH_EnableEvent(obj->dma_global->dma, obj->ch_num, obj->config->events);
		XMC_DMA_CH_SetEventHandler(obj->dma_global->dma, obj->ch_num, obj->config->callback);
	}
    obj->reload(obj);
 8026f6e:	4620      	mov	r0, r4
 8026f70:	68a3      	ldr	r3, [r4, #8]
 8026f72:	4798      	blx	r3
    status = DMA_CH_STATUS_SUCCESS;
 8026f74:	2000      	movs	r0, #0
 8026f76:	bd10      	pop	{r4, pc}
  }
  else
  {
    status = DMA_CH_STATUS_FAILURE;
 8026f78:	2001      	movs	r0, #1
  }

  return status;
}
 8026f7a:	bd10      	pop	{r4, pc}

  if (XMC_DMA_CH_Init(obj->dma_global->dma, obj->ch_num, &obj->config->ch_config) == XMC_DMA_CH_STATUS_OK)
  {
	if(obj->config->events)
	{
		XMC_DMA_CH_EnableEvent(obj->dma_global->dma, obj->ch_num, obj->config->events);
 8026f7c:	6823      	ldr	r3, [r4, #0]
 8026f7e:	7b21      	ldrb	r1, [r4, #12]
 8026f80:	6818      	ldr	r0, [r3, #0]
 8026f82:	f7fa ffc1 	bl	8021f08 <XMC_DMA_CH_EnableEvent>
		XMC_DMA_CH_SetEventHandler(obj->dma_global->dma, obj->ch_num, obj->config->callback);
 8026f86:	e894 000c 	ldmia.w	r4, {r2, r3}
 8026f8a:	7b21      	ldrb	r1, [r4, #12]
 8026f8c:	6810      	ldr	r0, [r2, #0]
 8026f8e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8026f90:	f7fa ffd2 	bl	8021f38 <XMC_DMA_CH_SetEventHandler>
 8026f94:	e7eb      	b.n	8026f6e <DMA_CH_Init+0x1e>
 8026f96:	bf00      	nop

08026f98 <DMA_CH_I1_reload>:

extern uint32_t* pDMA_dst_I1; /* Destination address symbol */

void DMA_CH_I1_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
 8026f98:	6802      	ldr	r2, [r0, #0]
 * see ::XMC_DMA_CH_Enable() for more information.
 *
 */
__STATIC_INLINE void XMC_DMA_CH_SetBlockSize(XMC_DMA_t *const dma, const uint8_t channel, uint32_t block_size)
{
  dma->CH[channel].CTLH = block_size;
 8026f9a:	7b03      	ldrb	r3, [r0, #12]
 8026f9c:	6811      	ldr	r1, [r2, #0]
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_I1);
 8026f9e:	4a0a      	ldr	r2, [pc, #40]	; (8026fc8 <DMA_CH_I1_reload+0x30>)
extern uint32_t* pDMA_src_I1; /* Source address symbol */

extern uint32_t* pDMA_dst_I1; /* Destination address symbol */

void DMA_CH_I1_reload(DMA_CH_t *obj)
{
 8026fa0:	b470      	push	{r4, r5, r6}
 8026fa2:	2458      	movs	r4, #88	; 0x58
 8026fa4:	fb04 1303 	mla	r3, r4, r3, r1
 8026fa8:	f44f 7680 	mov.w	r6, #256	; 0x100
 8026fac:	61de      	str	r6, [r3, #28]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetDestinationAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetSourceAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].SAR = addr;
 8026fae:	7b03      	ldrb	r3, [r0, #12]
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_I1);
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_I1);
 8026fb0:	4d06      	ldr	r5, [pc, #24]	; (8026fcc <DMA_CH_I1_reload+0x34>)
extern uint32_t* pDMA_dst_I1; /* Destination address symbol */

void DMA_CH_I1_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_I1);
 8026fb2:	6812      	ldr	r2, [r2, #0]
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_I1);
 8026fb4:	682d      	ldr	r5, [r5, #0]
 8026fb6:	fb04 f303 	mul.w	r3, r4, r3
 8026fba:	50ca      	str	r2, [r1, r3]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetSourceAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetDestinationAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].DAR = addr;
 8026fbc:	7b02      	ldrb	r2, [r0, #12]
 8026fbe:	fb04 1302 	mla	r3, r4, r2, r1
 8026fc2:	609d      	str	r5, [r3, #8]
}
 8026fc4:	bc70      	pop	{r4, r5, r6}
 8026fc6:	4770      	bx	lr
 8026fc8:	1fff1f9c 	.word	0x1fff1f9c
 8026fcc:	1fff1fb4 	.word	0x1fff1fb4

08026fd0 <DMA_CH_Q1_reload>:

extern uint32_t* pDMA_dst_Q1; /* Destination address symbol */

void DMA_CH_Q1_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
 8026fd0:	6802      	ldr	r2, [r0, #0]
 * see ::XMC_DMA_CH_Enable() for more information.
 *
 */
__STATIC_INLINE void XMC_DMA_CH_SetBlockSize(XMC_DMA_t *const dma, const uint8_t channel, uint32_t block_size)
{
  dma->CH[channel].CTLH = block_size;
 8026fd2:	7b03      	ldrb	r3, [r0, #12]
 8026fd4:	6811      	ldr	r1, [r2, #0]
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_Q1);
 8026fd6:	4a0a      	ldr	r2, [pc, #40]	; (8027000 <DMA_CH_Q1_reload+0x30>)
extern uint32_t* pDMA_src_Q1; /* Source address symbol */

extern uint32_t* pDMA_dst_Q1; /* Destination address symbol */

void DMA_CH_Q1_reload(DMA_CH_t *obj)
{
 8026fd8:	b470      	push	{r4, r5, r6}
 8026fda:	2458      	movs	r4, #88	; 0x58
 8026fdc:	fb04 1303 	mla	r3, r4, r3, r1
 8026fe0:	f44f 7680 	mov.w	r6, #256	; 0x100
 8026fe4:	61de      	str	r6, [r3, #28]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetDestinationAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetSourceAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].SAR = addr;
 8026fe6:	7b03      	ldrb	r3, [r0, #12]
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_Q1);
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_Q1);
 8026fe8:	4d06      	ldr	r5, [pc, #24]	; (8027004 <DMA_CH_Q1_reload+0x34>)
extern uint32_t* pDMA_dst_Q1; /* Destination address symbol */

void DMA_CH_Q1_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_Q1);
 8026fea:	6812      	ldr	r2, [r2, #0]
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_Q1);
 8026fec:	682d      	ldr	r5, [r5, #0]
 8026fee:	fb04 f303 	mul.w	r3, r4, r3
 8026ff2:	50ca      	str	r2, [r1, r3]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetSourceAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetDestinationAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].DAR = addr;
 8026ff4:	7b02      	ldrb	r2, [r0, #12]
 8026ff6:	fb04 1302 	mla	r3, r4, r2, r1
 8026ffa:	609d      	str	r5, [r3, #8]
}
 8026ffc:	bc70      	pop	{r4, r5, r6}
 8026ffe:	4770      	bx	lr
 8027000:	1fff1fb8 	.word	0x1fff1fb8
 8027004:	1fff1fd8 	.word	0x1fff1fd8

08027008 <DMA_CH_I2_reload>:

extern uint32_t* pDMA_dst_I2; /* Destination address symbol */

void DMA_CH_I2_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
 8027008:	6802      	ldr	r2, [r0, #0]
 * see ::XMC_DMA_CH_Enable() for more information.
 *
 */
__STATIC_INLINE void XMC_DMA_CH_SetBlockSize(XMC_DMA_t *const dma, const uint8_t channel, uint32_t block_size)
{
  dma->CH[channel].CTLH = block_size;
 802700a:	7b03      	ldrb	r3, [r0, #12]
 802700c:	6811      	ldr	r1, [r2, #0]
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_I2);
 802700e:	4a0a      	ldr	r2, [pc, #40]	; (8027038 <DMA_CH_I2_reload+0x30>)
extern uint32_t* pDMA_src_I2; /* Source address symbol */

extern uint32_t* pDMA_dst_I2; /* Destination address symbol */

void DMA_CH_I2_reload(DMA_CH_t *obj)
{
 8027010:	b470      	push	{r4, r5, r6}
 8027012:	2458      	movs	r4, #88	; 0x58
 8027014:	fb04 1303 	mla	r3, r4, r3, r1
 8027018:	f44f 7680 	mov.w	r6, #256	; 0x100
 802701c:	61de      	str	r6, [r3, #28]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetDestinationAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetSourceAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].SAR = addr;
 802701e:	7b03      	ldrb	r3, [r0, #12]
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_I2);
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_I2);
 8027020:	4d06      	ldr	r5, [pc, #24]	; (802703c <DMA_CH_I2_reload+0x34>)
extern uint32_t* pDMA_dst_I2; /* Destination address symbol */

void DMA_CH_I2_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_I2);
 8027022:	6812      	ldr	r2, [r2, #0]
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_I2);
 8027024:	682d      	ldr	r5, [r5, #0]
 8027026:	fb04 f303 	mul.w	r3, r4, r3
 802702a:	50ca      	str	r2, [r1, r3]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetSourceAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetDestinationAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].DAR = addr;
 802702c:	7b02      	ldrb	r2, [r0, #12]
 802702e:	fb04 1302 	mla	r3, r4, r2, r1
 8027032:	609d      	str	r5, [r3, #8]
}
 8027034:	bc70      	pop	{r4, r5, r6}
 8027036:	4770      	bx	lr
 8027038:	1fff1fa0 	.word	0x1fff1fa0
 802703c:	1fff1fac 	.word	0x1fff1fac

08027040 <DMA_CH_Q2_reload>:

extern uint32_t* pDMA_dst_Q2; /* Destination address symbol */

void DMA_CH_Q2_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
 8027040:	6802      	ldr	r2, [r0, #0]
 * see ::XMC_DMA_CH_Enable() for more information.
 *
 */
__STATIC_INLINE void XMC_DMA_CH_SetBlockSize(XMC_DMA_t *const dma, const uint8_t channel, uint32_t block_size)
{
  dma->CH[channel].CTLH = block_size;
 8027042:	7b03      	ldrb	r3, [r0, #12]
 8027044:	6811      	ldr	r1, [r2, #0]
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_Q2);
 8027046:	4a0a      	ldr	r2, [pc, #40]	; (8027070 <DMA_CH_Q2_reload+0x30>)
extern uint32_t* pDMA_src_Q2; /* Source address symbol */

extern uint32_t* pDMA_dst_Q2; /* Destination address symbol */

void DMA_CH_Q2_reload(DMA_CH_t *obj)
{
 8027048:	b470      	push	{r4, r5, r6}
 802704a:	2458      	movs	r4, #88	; 0x58
 802704c:	fb04 1303 	mla	r3, r4, r3, r1
 8027050:	f44f 7680 	mov.w	r6, #256	; 0x100
 8027054:	61de      	str	r6, [r3, #28]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetDestinationAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetSourceAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].SAR = addr;
 8027056:	7b03      	ldrb	r3, [r0, #12]
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_Q2);
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_Q2);
 8027058:	4d06      	ldr	r5, [pc, #24]	; (8027074 <DMA_CH_Q2_reload+0x34>)
extern uint32_t* pDMA_dst_Q2; /* Destination address symbol */

void DMA_CH_Q2_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_Q2);
 802705a:	6812      	ldr	r2, [r2, #0]
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_Q2);
 802705c:	682d      	ldr	r5, [r5, #0]
 802705e:	fb04 f303 	mul.w	r3, r4, r3
 8027062:	50ca      	str	r2, [r1, r3]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetSourceAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetDestinationAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].DAR = addr;
 8027064:	7b02      	ldrb	r2, [r0, #12]
 8027066:	fb04 1302 	mla	r3, r4, r2, r1
 802706a:	609d      	str	r5, [r3, #8]
}
 802706c:	bc70      	pop	{r4, r5, r6}
 802706e:	4770      	bx	lr
 8027070:	1fff1fbc 	.word	0x1fff1fbc
 8027074:	1fff1fd4 	.word	0x1fff1fd4

08027078 <DIGITAL_IO_Init>:
* @param handler Pointer pointing to APP data structure.
* @return DIGITAL_IO_STATUS_t DIGITAL_IO APP status.
*/

DIGITAL_IO_STATUS_t DIGITAL_IO_Init(const DIGITAL_IO_t *const handler)
{
 8027078:	b510      	push	{r4, lr}
 802707a:	4604      	mov	r4, r0
  XMC_ASSERT("DIGITAL_IO_Init: handler null pointer", handler != NULL);

  /* Initializes input / output characteristics */
  XMC_GPIO_Init(handler->gpio_port, handler->gpio_pin, &handler->gpio_config);
 802707c:	1d02      	adds	r2, r0, #4
 802707e:	7c21      	ldrb	r1, [r4, #16]
 8027080:	6800      	ldr	r0, [r0, #0]
 8027082:	f7fa f97d 	bl	8021380 <XMC_GPIO_Init>

  /*Configure hardware port control*/
  XMC_GPIO_SetHardwareControl(handler->gpio_port, handler->gpio_pin, handler->hwctrl);
 8027086:	6820      	ldr	r0, [r4, #0]
 8027088:	7c21      	ldrb	r1, [r4, #16]
 802708a:	7c62      	ldrb	r2, [r4, #17]
 802708c:	f7fb f88a 	bl	80221a4 <XMC_GPIO_SetHardwareControl>

  return (DIGITAL_IO_STATUS_OK);
}
 8027090:	2000      	movs	r0, #0
 8027092:	bd10      	pop	{r4, pc}

08027094 <SystemCoreSetup>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8027094:	4b18      	ldr	r3, [pc, #96]	; (80270f8 <SystemCoreSetup+0x64>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8027096:	4a19      	ldr	r2, [pc, #100]	; (80270fc <SystemCoreSetup+0x68>)
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8027098:	68d8      	ldr	r0, [r3, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 802709a:	f64f 01ff 	movw	r1, #63743	; 0xf8ff
 802709e:	4001      	ands	r1, r0
  reg_value  =  (reg_value                                   |
 80270a0:	430a      	orrs	r2, r1
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 80270a2:	60da      	str	r2, [r3, #12]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80270a4:	b672      	cpsid	i
	
  /* relocate vector table */
  __disable_irq();

#if !defined(__TASKING__)
  SCB->VTOR = (uint32_t)(&__Vectors);
 80270a6:	4a16      	ldr	r2, [pc, #88]	; (8027100 <SystemCoreSetup+0x6c>)
 80270a8:	609a      	str	r2, [r3, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 80270aa:	f3bf 8f4f 	dsb	sy
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80270ae:	b662      	cpsie	i

  __DSB();
  __enable_irq();
	
#if ((__FPU_PRESENT == 1) && (__FPU_USED == 1))
  SCB->CPACR |= ((3UL << 10*2) |                 /* set CP10 Full Access */
 80270b0:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
				 (3UL << 11*2)  );               /* set CP11 Full Access */
#endif
  /* Set flash wait states */
  temp = FLASH0->FCON;
 80270b4:	4813      	ldr	r0, [pc, #76]	; (8027104 <SystemCoreSetup+0x70>)

  __DSB();
  __enable_irq();
	
#if ((__FPU_PRESENT == 1) && (__FPU_USED == 1))
  SCB->CPACR |= ((3UL << 10*2) |                 /* set CP10 Full Access */
 80270b6:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
				 (3UL << 11*2)  );               /* set CP11 Full Access */
#endif
  /* Set flash wait states */
  temp = FLASH0->FCON;
 80270ba:	f241 0114 	movw	r1, #4116	; 0x1014

  __DSB();
  __enable_irq();
	
#if ((__FPU_PRESENT == 1) && (__FPU_USED == 1))
  SCB->CPACR |= ((3UL << 10*2) |                 /* set CP10 Full Access */
 80270be:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
				 (3UL << 11*2)  );               /* set CP11 Full Access */
#endif
  /* Set flash wait states */
  temp = FLASH0->FCON;
 80270c2:	5842      	ldr	r2, [r0, r1]
  temp &= ~FLASH_FCON_WSPFLASH_Msk;
 80270c4:	f022 020f 	bic.w	r2, r2, #15
  temp |= PMU_FLASH_WS;
 80270c8:	f042 0204 	orr.w	r2, r2, #4
  FLASH0->FCON = temp;
 80270cc:	5042      	str	r2, [r0, r1]


  /* Disable divide by zero trap */
  SCB->CCR &= ~SCB_CCR_DIV_0_TRP_Msk; 
 80270ce:	695a      	ldr	r2, [r3, #20]
 80270d0:	f022 0210 	bic.w	r2, r2, #16
 80270d4:	615a      	str	r2, [r3, #20]

  /* Disable unaligned memory access trap */
  SCB->CCR &= ~SCB_CCR_UNALIGN_TRP_Msk; 
 80270d6:	695a      	ldr	r2, [r3, #20]
 80270d8:	f022 0208 	bic.w	r2, r2, #8
 80270dc:	615a      	str	r2, [r3, #20]

  /* Disable memory management fault */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 80270de:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80270e0:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80270e4:	625a      	str	r2, [r3, #36]	; 0x24

  /* Disable bus fault */
  SCB->SHCSR &= ~SCB_SHCSR_BUSFAULTENA_Msk;
 80270e6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80270e8:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 80270ec:	625a      	str	r2, [r3, #36]	; 0x24

  /* Disable usage fault */
  SCB->SHCSR &= ~SCB_SHCSR_USGFAULTENA_Msk;
 80270ee:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80270f0:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80270f4:	625a      	str	r2, [r3, #36]	; 0x24
 80270f6:	4770      	bx	lr
 80270f8:	e000ed00 	.word	0xe000ed00
 80270fc:	05fa0100 	.word	0x05fa0100
 8027100:	08000000 	.word	0x08000000
 8027104:	58001000 	.word	0x58001000

08027108 <CLOCK_XMC4_Init>:
{
  CLOCK_XMC4_STATUS_t status = CLOCK_XMC4_STATUS_SUCCESS;

  XMC_ASSERT("CLOCK_XMC4 APP handle function pointer uninitialized", (handle != NULL));

  handle->init_status = true;
 8027108:	2301      	movs	r3, #1
 802710a:	7003      	strb	r3, [r0, #0]

  return (status);
}
 802710c:	2000      	movs	r0, #0
 802710e:	4770      	bx	lr

08027110 <OSCHP_GetFrequency>:
#ifdef CLOCK_XMC4_OSCHP_ENABLED
/*  API to retrieve high precision external oscillator frequency */
uint32_t OSCHP_GetFrequency(void)
{
  return (CLOCK_XMC4_OSCHP_FREQUENCY);
}
 8027110:	4800      	ldr	r0, [pc, #0]	; (8027114 <OSCHP_GetFrequency+0x4>)
 8027112:	4770      	bx	lr
 8027114:	02625a00 	.word	0x02625a00

08027118 <SystemCoreClockSetup>:
* @note   -
* @param  None
* @retval None
*/
void SystemCoreClockSetup(void)
{
 8027118:	b530      	push	{r4, r5, lr}
  /* Local data structure for initializing the clock functional block */
  const XMC_SCU_CLOCK_CONFIG_t CLOCK_XMC4_0_CONFIG =
 802711a:	4d11      	ldr	r5, [pc, #68]	; (8027160 <SystemCoreClockSetup+0x48>)
 802711c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
* @note   -
* @param  None
* @retval None
*/
void SystemCoreClockSetup(void)
{
 802711e:	b087      	sub	sp, #28
  /* Local data structure for initializing the clock functional block */
  const XMC_SCU_CLOCK_CONFIG_t CLOCK_XMC4_0_CONFIG =
 8027120:	ac01      	add	r4, sp, #4
 8027122:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8027124:	682b      	ldr	r3, [r5, #0]
 8027126:	6023      	str	r3, [r4, #0]
#endif
    /* Peripheral Clock Divider Value */
    .fperipheral_clkdiv = 1U
  };
  /* Initialize the SCU clock */
  XMC_SCU_CLOCK_Init(&CLOCK_XMC4_0_CONFIG);
 8027128:	a801      	add	r0, sp, #4
 802712a:	f7fa fb19 	bl	8021760 <XMC_SCU_CLOCK_Init>
  /* RTC source clock */
  XMC_SCU_HIB_SetRtcClockSource(XMC_SCU_HIB_RTCCLKSRC_OSI);
 802712e:	2000      	movs	r0, #0
 8027130:	f7fa f9ae 	bl	8021490 <XMC_SCU_HIB_SetRtcClockSource>
  
#ifdef CLOCK_XMC4_USBCLK_ENABLED  
  /* USB/SDMMC source clock */
  XMC_SCU_CLOCK_SetUsbClockSource(XMC_SCU_CLOCK_USBCLKSRC_USBPLL);
 8027134:	2000      	movs	r0, #0
 8027136:	f7fa f997 	bl	8021468 <XMC_SCU_CLOCK_SetUsbClockSource>
  /* USB/SDMMC divider setting */
  XMC_SCU_CLOCK_SetUsbClockDivider(4U);
 802713a:	2004      	movs	r0, #4
 802713c:	f7fa f9b8 	bl	80214b0 <XMC_SCU_CLOCK_SetUsbClockDivider>
#endif
  /* Start USB PLL */
  XMC_SCU_CLOCK_StartUsbPll(5U, 48U);
 8027140:	2130      	movs	r1, #48	; 0x30
 8027142:	2005      	movs	r0, #5
 8027144:	f7fa fa00 	bl	8021548 <XMC_SCU_CLOCK_StartUsbPll>

#ifdef CLOCK_XMC4_WDTCLK_ENABLED    
  /* WDT source clock */
  XMC_SCU_CLOCK_SetWdtClockSource(XMC_SCU_CLOCK_WDTCLKSRC_OFI);
 8027148:	2000      	movs	r0, #0
 802714a:	f7fa f997 	bl	802147c <XMC_SCU_CLOCK_SetWdtClockSource>
  /* WDT divider setting */
  XMC_SCU_CLOCK_SetWdtClockDivider(1U);
 802714e:	2001      	movs	r0, #1
 8027150:	f7fa f9c2 	bl	80214d8 <XMC_SCU_CLOCK_SetWdtClockDivider>
#endif

#ifdef CLOCK_XMC4_EBUCLK_ENABLED 
  /* EBU divider setting */
  XMC_SCU_CLOCK_SetEbuClockDivider(1U);
 8027154:	2001      	movs	r0, #1
 8027156:	f7fa f9b5 	bl	80214c4 <XMC_SCU_CLOCK_SetEbuClockDivider>
#endif

}
 802715a:	b007      	add	sp, #28
 802715c:	bd30      	pop	{r4, r5, pc}
 802715e:	bf00      	nop
 8027160:	0802b010 	.word	0x0802b010

08027164 <CCU4_SLICE_CONFIG_Init>:
}

/* API to initialize the CCU4 slice */
CCU4_SLICE_CONFIG_STATUS_t CCU4_SLICE_CONFIG_Init(const CCU4_SLICE_CONFIG_t *const handle_ptr)
{
  return handle_ptr->init();
 8027164:	6803      	ldr	r3, [r0, #0]
 8027166:	4718      	bx	r3

08027168 <CCU4_SLICE_CONFIG_ADC_TRIG_lInit>:
  .level               = XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_HIGH,
  .duration            = XMC_CCU4_SLICE_EVENT_FILTER_DISABLED                               
 };
            /* Channel initialization function */
CCU4_SLICE_CONFIG_STATUS_t CCU4_SLICE_CONFIG_ADC_TRIG_lInit(void)
{
 8027168:	b570      	push	{r4, r5, r6, lr}
  GLOBAL_CCU4_Init(&GLOBAL_CCU4_0);
  /* Configure CCU4x_CC4y slice as timer unit */
  XMC_CCU4_SLICE_CompareInit(CCU43_CC43, &CCU4_SLICE_CONFIG_ADC_TRIG_compare_config);
 802716a:	4c21      	ldr	r4, [pc, #132]	; (80271f0 <CCU4_SLICE_CONFIG_ADC_TRIG_lInit+0x88>)
  .duration            = XMC_CCU4_SLICE_EVENT_FILTER_DISABLED                               
 };
            /* Channel initialization function */
CCU4_SLICE_CONFIG_STATUS_t CCU4_SLICE_CONFIG_ADC_TRIG_lInit(void)
{
  GLOBAL_CCU4_Init(&GLOBAL_CCU4_0);
 802716c:	4821      	ldr	r0, [pc, #132]	; (80271f4 <CCU4_SLICE_CONFIG_ADC_TRIG_lInit+0x8c>)
  /* Set timer compare register value */
  XMC_CCU4_SLICE_SetTimerCompareMatch(CCU43_CC43, (uint16_t)32768U);
  /* Set timer period register value */
  XMC_CCU4_SLICE_SetTimerPeriodMatch(CCU43_CC43, (uint16_t)65535U);	
  /* Register value update settings */
  XMC_CCU4_SetMultiChannelShadowTransferMode(CCU43, (uint32_t)XMC_CCU4_MULTI_CHANNEL_SHADOW_TRANSFER_SW_SLICE3);
 802716e:	4d22      	ldr	r5, [pc, #136]	; (80271f8 <CCU4_SLICE_CONFIG_ADC_TRIG_lInit+0x90>)
  .duration            = XMC_CCU4_SLICE_EVENT_FILTER_DISABLED                               
 };
            /* Channel initialization function */
CCU4_SLICE_CONFIG_STATUS_t CCU4_SLICE_CONFIG_ADC_TRIG_lInit(void)
{
  GLOBAL_CCU4_Init(&GLOBAL_CCU4_0);
 8027170:	f7ff fc12 	bl	8026998 <GLOBAL_CCU4_Init>
  /* Configure CCU4x_CC4y slice as timer unit */
  XMC_CCU4_SLICE_CompareInit(CCU43_CC43, &CCU4_SLICE_CONFIG_ADC_TRIG_compare_config);
 8027174:	4620      	mov	r0, r4
 8027176:	4921      	ldr	r1, [pc, #132]	; (80271fc <CCU4_SLICE_CONFIG_ADC_TRIG_lInit+0x94>)
 8027178:	f7fa fc42 	bl	8021a00 <XMC_CCU4_SLICE_CompareInit>
 *  XMC_CCU4_SLICE_GetTimerValue().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerValue(XMC_CCU4_SLICE_t *const slice, const uint16_t timer_val)
{
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerValue:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TIMER = (uint32_t) timer_val;
 802717c:	2600      	movs	r6, #0
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerCompareMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t compare_val)
{
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->CRS = (uint32_t) compare_val;
 802717e:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerPeriodMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t period_val)
{
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->PRS = (uint32_t) period_val;
 8027182:	f64f 73ff 	movw	r3, #65535	; 0xffff
 *  XMC_CCU4_SLICE_GetTimerValue().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerValue(XMC_CCU4_SLICE_t *const slice, const uint16_t timer_val)
{
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerValue:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TIMER = (uint32_t) timer_val;
 8027186:	6726      	str	r6, [r4, #112]	; 0x70
  /* Set timer compare register value */
  XMC_CCU4_SLICE_SetTimerCompareMatch(CCU43_CC43, (uint16_t)32768U);
  /* Set timer period register value */
  XMC_CCU4_SLICE_SetTimerPeriodMatch(CCU43_CC43, (uint16_t)65535U);	
  /* Register value update settings */
  XMC_CCU4_SetMultiChannelShadowTransferMode(CCU43, (uint32_t)XMC_CCU4_MULTI_CHANNEL_SHADOW_TRANSFER_SW_SLICE3);
 8027188:	4628      	mov	r0, r5
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerCompareMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t compare_val)
{
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->CRS = (uint32_t) compare_val;
 802718a:	63e2      	str	r2, [r4, #60]	; 0x3c
 802718c:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerPeriodMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t period_val)
{
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->PRS = (uint32_t) period_val;
 8027190:	6363      	str	r3, [r4, #52]	; 0x34
 8027192:	f7fa fc2d 	bl	80219f0 <XMC_CCU4_SetMultiChannelShadowTransferMode>
 *  None.
 */
__STATIC_INLINE void XMC_CCU4_EnableShadowTransfer(XMC_CCU4_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
  XMC_ASSERT("XMC_CCU4_EnableShadowTransfer:Invalid Slice Pointer", XMC_CCU4_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;  
 8027196:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 802719a:	612b      	str	r3, [r5, #16]
  /* Transfer value from shadow registers to actual timer registers */
  XMC_CCU4_EnableShadowTransfer(CCU43, (uint32_t)XMC_CCU4_SHADOW_TRANSFER_SLICE_3 |
                                               (uint32_t)XMC_CCU4_SHADOW_TRANSFER_DITHER_SLICE_3 |
                                               (uint32_t)XMC_CCU4_SHADOW_TRANSFER_PRESCALER_SLICE_3);
  /* Events and function settings */
  XMC_CCU4_SLICE_ConfigureEvent(CCU43_CC43, XMC_CCU4_SLICE_EVENT_0, &CCU4_SLICE_CONFIG_ADC_TRIG_event0_config);
 802719c:	4620      	mov	r0, r4
 802719e:	2101      	movs	r1, #1
 80271a0:	4a17      	ldr	r2, [pc, #92]	; (8027200 <CCU4_SLICE_CONFIG_ADC_TRIG_lInit+0x98>)
 80271a2:	f7fa fc63 	bl	8021a6c <XMC_CCU4_SLICE_ConfigureEvent>
  XMC_CCU4_SLICE_ConfigureEvent(CCU43_CC43, XMC_CCU4_SLICE_EVENT_1, &CCU4_SLICE_CONFIG_ADC_TRIG_event1_config);
 80271a6:	4620      	mov	r0, r4
 80271a8:	2102      	movs	r1, #2
 80271aa:	4a16      	ldr	r2, [pc, #88]	; (8027204 <CCU4_SLICE_CONFIG_ADC_TRIG_lInit+0x9c>)
 80271ac:	f7fa fc5e 	bl	8021a6c <XMC_CCU4_SLICE_ConfigureEvent>
  XMC_CCU4_SLICE_ConfigureEvent(CCU43_CC43, XMC_CCU4_SLICE_EVENT_2, &CCU4_SLICE_CONFIG_ADC_TRIG_event2_config);
 80271b0:	4620      	mov	r0, r4
 80271b2:	2103      	movs	r1, #3
 80271b4:	4a14      	ldr	r2, [pc, #80]	; (8027208 <CCU4_SLICE_CONFIG_ADC_TRIG_lInit+0xa0>)
 80271b6:	f7fa fc59 	bl	8021a6c <XMC_CCU4_SLICE_ConfigureEvent>
  XMC_CCU4_SLICE_StartConfig(CCU43_CC43, XMC_CCU4_SLICE_EVENT_0, XMC_CCU4_SLICE_START_MODE_TIMER_START);
 80271ba:	4620      	mov	r0, r4
 80271bc:	4632      	mov	r2, r6
 80271be:	2101      	movs	r1, #1
 80271c0:	f7fa fc38 	bl	8021a34 <XMC_CCU4_SLICE_StartConfig>
  XMC_CCU4_SLICE_StopConfig(CCU43_CC43, XMC_CCU4_SLICE_EVENT_1, XMC_CCU4_SLICE_END_MODE_TIMER_STOP_CLEAR);
 80271c4:	2102      	movs	r1, #2
 80271c6:	4620      	mov	r0, r4
 80271c8:	460a      	mov	r2, r1
 80271ca:	f7fa fc41 	bl	8021a50 <XMC_CCU4_SLICE_StopConfig>
  XMC_CCU4_SLICE_SetInterruptNode(CCU43_CC43, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH, XMC_CCU4_SLICE_SR_ID_3);
 80271ce:	4620      	mov	r0, r4
 80271d0:	4631      	mov	r1, r6
 80271d2:	2203      	movs	r2, #3
 80271d4:	f7fa fc8e 	bl	8021af4 <XMC_CCU4_SLICE_SetInterruptNode>
 *  XMC_CCU4_SLICE_DisableMultipleEvents().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_EnableMultipleEvents(XMC_CCU4_SLICE_t *const slice, const uint16_t intr_mask)
{
  XMC_ASSERT("XMC_CCU4_SLICE_EnableMultipleEvents:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->INTE |= (uint32_t)intr_mask;
 80271d8:	f8d4 30a4 	ldr.w	r3, [r4, #164]	; 0xa4
 80271dc:	f043 0301 	orr.w	r3, r3, #1
 80271e0:	f8c4 30a4 	str.w	r3, [r4, #164]	; 0xa4
__STATIC_INLINE void XMC_CCU4_EnableClock(XMC_CCU4_MODULE_t *const module, const uint8_t slice_number)
{
  XMC_ASSERT("XMC_CCU4_EnableClock:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  XMC_ASSERT("XMC_CCU4_EnableClock:Invalid Slice Number", (slice_number < 4U));

  module->GIDLC |= ((uint32_t) 1) << slice_number;
 80271e4:	68eb      	ldr	r3, [r5, #12]
 80271e6:	f043 0308 	orr.w	r3, r3, #8
  XMC_CCU4_SLICE_EnableMultipleEvents(CCU43_CC43, XMC_CCU4_SLICE_MULTI_IRQ_ID_PERIOD_MATCH);
  /* clear IDLE mode for the slice*/
  XMC_CCU4_EnableClock(CCU43, (uint8_t)3);	
  return CCU4_SLICE_CONFIG_STATUS_SUCCESS;
}
 80271ea:	4630      	mov	r0, r6
 80271ec:	60eb      	str	r3, [r5, #12]
 80271ee:	bd70      	pop	{r4, r5, r6, pc}
 80271f0:	48004400 	.word	0x48004400
 80271f4:	1ffe8970 	.word	0x1ffe8970
 80271f8:	48004000 	.word	0x48004000
 80271fc:	0802b03c 	.word	0x0802b03c
 8027200:	0802b044 	.word	0x0802b044
 8027204:	0802b024 	.word	0x0802b024
 8027208:	0802b028 	.word	0x0802b028

0802720c <ADC_MEASUREMENT_ADV_SoftwareTrigger>:
{
  XMC_ASSERT("ADC_MEASUREMENT_ADV_StartConversion:Invalid handle_ptr", (handle_ptr != NULL))

#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 802720c:	7d03      	ldrb	r3, [r0, #20]
  #endif
    {
      XMC_VADC_GROUP_ScanTriggerConversion(group_ptrs[handle_ptr->group_index]);
 802720e:	7d82      	ldrb	r2, [r0, #22]
{
  XMC_ASSERT("ADC_MEASUREMENT_ADV_StartConversion:Invalid handle_ptr", (handle_ptr != NULL))

#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8027210:	2b01      	cmp	r3, #1
  #endif
    {
      XMC_VADC_GROUP_ScanTriggerConversion(group_ptrs[handle_ptr->group_index]);
 8027212:	4b09      	ldr	r3, [pc, #36]	; (8027238 <ADC_MEASUREMENT_ADV_SoftwareTrigger+0x2c>)
 8027214:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
{
  XMC_ASSERT("ADC_MEASUREMENT_ADV_StartConversion:Invalid handle_ptr", (handle_ptr != NULL))

#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8027218:	d906      	bls.n	8027228 <ADC_MEASUREMENT_ADV_SoftwareTrigger+0x1c>
 *  XMC_VADC_GROUP_QueueInsertChannel()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_QueueTriggerConversion(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueTriggerConversion:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->QMR0 |= (uint32_t)((uint32_t)1 << VADC_G_QMR0_TREV_Pos);
 802721a:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
 802721e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8027222:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
 8027226:	4770      	bx	lr
 *  None.
 */
__STATIC_INLINE void XMC_VADC_GROUP_ScanTriggerConversion(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanTriggerConversion:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->ASMR |= (uint32_t)VADC_G_ASMR_LDEV_Msk;
 8027228:	f8d2 3124 	ldr.w	r3, [r2, #292]	; 0x124
 802722c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8027230:	f8c2 3124 	str.w	r3, [r2, #292]	; 0x124
 8027234:	4770      	bx	lr
 8027236:	bf00      	nop
 8027238:	0802b048 	.word	0x0802b048

0802723c <ADC_MEASUREMENT_ADV_Init>:
#ifdef ADC_MEASUREMENT_ADV_SHS_GAIN_NON_DEFAULT
  uint8_t channel_number;
#endif
  bool arbitration_status = (bool)false;

  if (ADC_MEASUREMENT_ADV_STATUS_UNINITIALIZED == *handle_ptr->init_state)
 802723c:	6903      	ldr	r3, [r0, #16]
 802723e:	781b      	ldrb	r3, [r3, #0]
 8027240:	2b02      	cmp	r3, #2
 8027242:	d001      	beq.n	8027248 <ADC_MEASUREMENT_ADV_Init+0xc>
#endif

    *handle_ptr->init_state = status;
  }
  return (*handle_ptr->init_state);
}
 8027244:	4618      	mov	r0, r3
 8027246:	4770      	bx	lr
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Initialization routine to call ADC LLD API's */
ADC_MEASUREMENT_ADV_STATUS_t ADC_MEASUREMENT_ADV_Init(const ADC_MEASUREMENT_ADV_t *const handle_ptr)
{
 8027248:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802724c:	4605      	mov	r5, r0
  /* To check if the arbiter is already enabled. Before checking this ensure that clock and reset states are correct */
#if defined(CLOCK_GATING_SUPPORTED) && defined(ADC_MEASUREMENT_ADV_CHECK_CLOCK_GATING)
  clock_reset_check = !XMC_SCU_CLOCK_IsPeripheralClockGated(XMC_SCU_PERIPHERAL_CLOCK_VADC);
#endif
#ifdef PERIPHERAL_RESET_SUPPORTED
  clock_reset_check |= !XMC_SCU_RESET_IsPeripheralResetAsserted(XMC_SCU_PERIPHERAL_RESET_VADC);
 802724e:	2001      	movs	r0, #1
 8027250:	f7fa f8fa 	bl	8021448 <XMC_SCU_RESET_IsPeripheralResetAsserted>
#endif
  if(clock_reset_check != (bool)false)
 8027254:	2800      	cmp	r0, #0
 8027256:	f040 80c8 	bne.w	80273ea <ADC_MEASUREMENT_ADV_Init+0x1ae>
  {
#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 802725a:	7d2b      	ldrb	r3, [r5, #20]
  #endif
      {
        arbitration_status = XMC_VADC_GROUP_ScanIsArbitrationSlotEnabled(group_ptrs[handle_ptr->group_index]);
 802725c:	4e94      	ldr	r6, [pc, #592]	; (80274b0 <ADC_MEASUREMENT_ADV_Init+0x274>)
#endif
  if(clock_reset_check != (bool)false)
  {
#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 802725e:	2b01      	cmp	r3, #1
  #endif
      {
        arbitration_status = XMC_VADC_GROUP_ScanIsArbitrationSlotEnabled(group_ptrs[handle_ptr->group_index]);
 8027260:	7dab      	ldrb	r3, [r5, #22]
 8027262:	f856 4023 	ldr.w	r4, [r6, r3, lsl #2]
 */
__STATIC_INLINE bool XMC_VADC_GROUP_ScanIsArbitrationSlotEnabled(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanIsArbitrationSlotEnabled:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  return ((group_ptr->ARBPR & (uint32_t)VADC_G_ARBPR_ASEN1_Msk) >> VADC_G_ARBPR_ASEN1_Pos);
 8027266:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
#endif
  if(clock_reset_check != (bool)false)
  {
#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 802726a:	f240 81fb 	bls.w	8027664 <ADC_MEASUREMENT_ADV_Init+0x428>
 */
__STATIC_INLINE bool XMC_VADC_GROUP_QueueIsArbitrationSlotEnabled(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueIsArbitrationSlotEnabled:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  return ((group_ptr->ARBPR & (uint32_t)VADC_G_ARBPR_ASEN0_Msk) >> VADC_G_ARBPR_ASEN0_Pos);
 802726e:	f3c3 6900 	ubfx	r9, r3, #24, #1
                                                           uint8_t group_index)
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

  /*Initialization of APP 'GLOBAL_ADC'*/
  status = (ADC_MEASUREMENT_ADV_STATUS_t) GLOBAL_ADC_Init(ADC_MEASUREMENT_ADV_GLOBAL_HANDLE);
 8027272:	4890      	ldr	r0, [pc, #576]	; (80274b4 <ADC_MEASUREMENT_ADV_Init+0x278>)
#ifdef ADC_MEASUREMENT_ADV_LOCAL_QUEUE_USED
  #ifdef ADC_MEASUREMENT_ADV_ADC_QUEUE_USED
      if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_QUEUE != handle_ptr->req_src)
  #endif
      {
        status = ADC_MEASUREMENT_ADV_lQueueInit(handle_ptr->local_queue_handle,handle_ptr->group_index);
 8027274:	68ef      	ldr	r7, [r5, #12]
                                                           uint8_t group_index)
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

  /*Initialization of APP 'GLOBAL_ADC'*/
  status = (ADC_MEASUREMENT_ADV_STATUS_t) GLOBAL_ADC_Init(ADC_MEASUREMENT_ADV_GLOBAL_HANDLE);
 8027276:	f7ff fba3 	bl	80269c0 <GLOBAL_ADC_Init>

  /*Class Configuration*/
  XMC_VADC_GROUP_InputClassInit(group_ptrs[group_index],handle_ptr->iclass_config_handle,
 802727a:	7ebb      	ldrb	r3, [r7, #26]
 802727c:	6939      	ldr	r1, [r7, #16]
 802727e:	2200      	movs	r2, #0
                                                           uint8_t group_index)
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

  /*Initialization of APP 'GLOBAL_ADC'*/
  status = (ADC_MEASUREMENT_ADV_STATUS_t) GLOBAL_ADC_Init(ADC_MEASUREMENT_ADV_GLOBAL_HANDLE);
 8027280:	4680      	mov	r8, r0

  /*Class Configuration*/
  XMC_VADC_GROUP_InputClassInit(group_ptrs[group_index],handle_ptr->iclass_config_handle,
 8027282:	4620      	mov	r0, r4
 8027284:	f7fc f9de 	bl	8023644 <XMC_VADC_GROUP_InputClassInit>
                                XMC_VADC_GROUP_CONV_STD,handle_ptr->iclass_num);

  /* Initialize the Queue hardware */
  XMC_VADC_GROUP_QueueInit(group_ptrs[group_index],handle_ptr->queue_config_handle);
 8027288:	4620      	mov	r0, r4
 802728a:	6979      	ldr	r1, [r7, #20]
 802728c:	f7fc fa96 	bl	80237bc <XMC_VADC_GROUP_QueueInit>
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueSetGatingMode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_QueueSetGatingMode:Wrong mode selected", (mode_sel <= XMC_VADC_GATEMODE_ACTIVELOW))

  /* Clear the existing gate configuration */
  group_ptr->QMR0 &= (uint32_t)(~((uint32_t) VADC_G_QMR0_ENGT_Msk));
 8027290:	f8d4 2104 	ldr.w	r2, [r4, #260]	; 0x104

  /* Configure the gating mode for queue*/
  XMC_VADC_GROUP_QueueSetGatingMode(group_ptrs[group_index], handle_ptr->gating_mode);
 8027294:	7e38      	ldrb	r0, [r7, #24]

  /*Interrupt Configuration*/
  if ((bool)true == handle_ptr->rs_intr_handle.interrupt_enable)
 8027296:	7b39      	ldrb	r1, [r7, #12]
 8027298:	f022 0203 	bic.w	r2, r2, #3
 802729c:	f8c4 2104 	str.w	r2, [r4, #260]	; 0x104
  /* Set the new gating mode */
  group_ptr->QMR0 |= (uint32_t)((uint32_t)mode_sel << VADC_G_QMR0_ENGT_Pos);
 80272a0:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
 80272a4:	4303      	orrs	r3, r0
 80272a6:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
 80272aa:	b389      	cbz	r1, 8027310 <ADC_MEASUREMENT_ADV_Init+0xd4>
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80272ac:	4b82      	ldr	r3, [pc, #520]	; (80274b8 <ADC_MEASUREMENT_ADV_Init+0x27c>)
  {
#if (UC_FAMILY == XMC1)
    NVIC_SetPriority((IRQn_Type)handle_ptr->rs_intr_handle.node_id, handle_ptr->rs_intr_handle.priority);
#else
    NVIC_SetPriority((IRQn_Type)handle_ptr->rs_intr_handle.node_id,
 80272ae:	f8d7 e000 	ldr.w	lr, [r7]
 80272b2:	68db      	ldr	r3, [r3, #12]
 80272b4:	6878      	ldr	r0, [r7, #4]
 80272b6:	f8d7 c008 	ldr.w	ip, [r7, #8]
 80272ba:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80272be:	f1c3 0a07 	rsb	sl, r3, #7
 80272c2:	f1ba 0f06 	cmp.w	sl, #6
 80272c6:	bf28      	it	cs
 80272c8:	f04f 0a06 	movcs.w	sl, #6
 80272cc:	fa5f f18e 	uxtb.w	r1, lr
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80272d0:	2b00      	cmp	r3, #0
 80272d2:	f040 818d 	bne.w	80275f0 <ADC_MEASUREMENT_ADV_Init+0x3b4>
 80272d6:	461a      	mov	r2, r3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80272d8:	f04f 0c01 	mov.w	ip, #1
 80272dc:	fa0c fc0a 	lsl.w	ip, ip, sl
 80272e0:	f10c 3cff 	add.w	ip, ip, #4294967295
 80272e4:	ea0c 0000 	and.w	r0, ip, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 80272e8:	b249      	sxtb	r1, r1

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80272ea:	fa00 f202 	lsl.w	r2, r0, r2
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 80272ee:	2900      	cmp	r1, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 80272f0:	ea43 0302 	orr.w	r3, r3, r2
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 80272f4:	f2c0 81ae 	blt.w	8027654 <ADC_MEASUREMENT_ADV_Init+0x418>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80272f8:	f101 4260 	add.w	r2, r1, #3758096384	; 0xe0000000
 80272fc:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 8027300:	009b      	lsls	r3, r3, #2
 8027302:	b2db      	uxtb	r3, r3
 8027304:	f882 3300 	strb.w	r3, [r2, #768]	; 0x300
    XMC_SCU_SetInterruptControl(handle_ptr->rs_intr_handle.node_id,
                                ((handle_ptr->rs_intr_handle.node_id << 8) | handle_ptr->rs_intr_handle.irqctrl));
#endif

    /* Connect RS Events to NVIC nodes */
    XMC_VADC_GROUP_QueueSetReqSrcEventInterruptNode(group_ptrs[group_index], (XMC_VADC_SR_t)handle_ptr->srv_req_node);
 8027308:	4620      	mov	r0, r4
 802730a:	7e79      	ldrb	r1, [r7, #25]
 802730c:	f7fc fa9a 	bl	8023844 <XMC_VADC_GROUP_QueueSetReqSrcEventInterruptNode>

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
__STATIC_INLINE void ADC_MEASUREMENT_ADV_lDisableArbitration(const ADC_MEASUREMENT_ADV_t *const handle_ptr,
                                                             bool arbitration_status)
{
  if(arbitration_status == (bool)false)
 8027310:	f1b9 0f00 	cmp.w	r9, #0
 8027314:	d10d      	bne.n	8027332 <ADC_MEASUREMENT_ADV_Init+0xf6>
  {
#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
      if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8027316:	7d2b      	ldrb	r3, [r5, #20]
 8027318:	2b01      	cmp	r3, #1
  #endif
      {
        XMC_VADC_GROUP_ScanDisableArbitrationSlot(group_ptrs[handle_ptr->group_index]);
 802731a:	7dab      	ldrb	r3, [r5, #22]
 802731c:	f856 2023 	ldr.w	r2, [r6, r3, lsl #2]
 *  XMC_VADC_GROUP_ScanEnableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_ScanDisableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanDisableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->ARBPR &= ~((uint32_t)VADC_G_ARBPR_ASEN1_Msk);
 8027320:	f8d2 3084 	ldr.w	r3, [r2, #132]	; 0x84
 8027324:	bf94      	ite	ls
 8027326:	f023 7300 	bicls.w	r3, r3, #33554432	; 0x2000000
 *  XMC_VADC_GROUP_QueueEnableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_QueueDisableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueDisableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr));
  group_ptr->ARBPR &= ~((uint32_t)VADC_G_ARBPR_ASEN0_Msk);
 802732a:	f023 7380 	bichi.w	r3, r3, #16777216	; 0x1000000
 802732e:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
   /* Disable the Arbitration if no other instance has enabled it*/
   ADC_MEASUREMENT_ADV_lDisableArbitration(handle_ptr,arbitration_status);

#ifdef ADC_MEASUREMENT_ADV_SYNC_USED
  #ifdef ADC_MEASUREMENT_ADV_SYNC_NOT_ALL_USED
    if ((uint32_t)0 != handle_ptr->sync_slaves)
 8027332:	7d6b      	ldrb	r3, [r5, #21]
 8027334:	2b00      	cmp	r3, #0
 8027336:	f040 80c1 	bne.w	80274bc <ADC_MEASUREMENT_ADV_Init+0x280>
#endif

    /* Initialize the SR lines for the Channel event and the Result event, if required*/
#ifdef ADC_MEASUREMENT_ADV_MUX_USED
  #ifdef ADC_MEASUREMENT_ADV_MUX_NOT_ALL_USED
    if (handle_ptr->event_config != NULL)
 802733a:	68ab      	ldr	r3, [r5, #8]
 802733c:	b103      	cbz	r3, 8027340 <ADC_MEASUREMENT_ADV_Init+0x104>
  #endif
    {
      (handle_ptr->event_config)();
 802733e:	4798      	blx	r3
    }
#endif

    total_number_of_channels = (uint8_t)handle_ptr->total_number_of_channels;
 8027340:	7e2b      	ldrb	r3, [r5, #24]
    for (ch_num = (uint8_t)0; ch_num < (uint8_t)total_number_of_channels; ch_num++)
 8027342:	b1fb      	cbz	r3, 8027384 <ADC_MEASUREMENT_ADV_Init+0x148>
 8027344:	1e5f      	subs	r7, r3, #1
 8027346:	b2ff      	uxtb	r7, r7
 8027348:	3701      	adds	r7, #1
 802734a:	00bf      	lsls	r7, r7, #2
 802734c:	f04f 0900 	mov.w	r9, #0
    {
      indexed = handle_ptr->channel_array[ch_num];
 8027350:	682b      	ldr	r3, [r5, #0]
 8027352:	f853 4009 	ldr.w	r4, [r3, r9]

      /* Initialize for configured channels*/
      XMC_VADC_GROUP_ChannelInit(group_ptrs[indexed->group_index],(uint32_t)indexed->ch_num, indexed->ch_handle);
 8027356:	7a23      	ldrb	r3, [r4, #8]
 8027358:	7a61      	ldrb	r1, [r4, #9]
 802735a:	f856 0023 	ldr.w	r0, [r6, r3, lsl #2]
 802735e:	6822      	ldr	r2, [r4, #0]
 8027360:	f7fc fa78 	bl	8023854 <XMC_VADC_GROUP_ChannelInit>
      XMC_VADC_GROUP_ResultInit(group_ptrs[indexed->group_index], (uint32_t)indexed->result_fifo_tail_number,
                                indexed->res_handle[ADC_MEASUREMENT_ADV_TAIL_RESULT_REG_CONFIG]);
  }
#endif
      /* Initialize for configured result registers For FIFO Head configuration*/
      XMC_VADC_GROUP_ResultInit(group_ptrs[indexed->group_index], (uint32_t)indexed->ch_handle->result_reg_number,
 8027364:	6823      	ldr	r3, [r4, #0]
 8027366:	7a22      	ldrb	r2, [r4, #8]
 8027368:	789b      	ldrb	r3, [r3, #2]
__STATIC_INLINE void XMC_VADC_GROUP_ResultInit(XMC_VADC_GROUP_t *const group_ptr,
                                               const uint32_t res_reg_num,
                                               const XMC_VADC_RESULT_CONFIG_t *config)
{
  XMC_ASSERT("XMC_VADC_GROUP_ResultInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->RCR[res_reg_num] = config->g_rcr;
 802736a:	6861      	ldr	r1, [r4, #4]
 802736c:	f856 2022 	ldr.w	r2, [r6, r2, lsl #2]
 8027370:	6809      	ldr	r1, [r1, #0]
 8027372:	f003 030f 	and.w	r3, r3, #15
 8027376:	33a0      	adds	r3, #160	; 0xa0
 8027378:	f109 0904 	add.w	r9, r9, #4
      (handle_ptr->event_config)();
    }
#endif

    total_number_of_channels = (uint8_t)handle_ptr->total_number_of_channels;
    for (ch_num = (uint8_t)0; ch_num < (uint8_t)total_number_of_channels; ch_num++)
 802737c:	45b9      	cmp	r9, r7
 802737e:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
 8027382:	d1e5      	bne.n	8027350 <ADC_MEASUREMENT_ADV_Init+0x114>
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Enables the NVIC(if needed) when scan/queue request source is consumed internally in the APP. */
void ADC_MEASUREMENT_ADC_lNvicEnable(const ADC_MEASUREMENT_ADV_t *const handle_ptr)
{
#ifdef ADC_MEASUREMENT_ADV_LOCAL_SCAN_USED
    if (((bool)true == handle_ptr->local_scan_handle->rs_intr_handle.interrupt_enable) &&
 8027384:	68ea      	ldr	r2, [r5, #12]
 8027386:	7b13      	ldrb	r3, [r2, #12]
 8027388:	b36b      	cbz	r3, 80273e6 <ADC_MEASUREMENT_ADV_Init+0x1aa>
        (ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN == handle_ptr->req_src))
 802738a:	7d2b      	ldrb	r3, [r5, #20]
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Enables the NVIC(if needed) when scan/queue request source is consumed internally in the APP. */
void ADC_MEASUREMENT_ADC_lNvicEnable(const ADC_MEASUREMENT_ADV_t *const handle_ptr)
{
#ifdef ADC_MEASUREMENT_ADV_LOCAL_SCAN_USED
    if (((bool)true == handle_ptr->local_scan_handle->rs_intr_handle.interrupt_enable) &&
 802738c:	2b01      	cmp	r3, #1
 802738e:	f000 8145 	beq.w	802761c <ADC_MEASUREMENT_ADV_Init+0x3e0>
    {
      NVIC_EnableIRQ((IRQn_Type)handle_ptr->local_scan_handle->rs_intr_handle.node_id);
    }
#endif
#ifdef ADC_MEASUREMENT_ADV_LOCAL_QUEUE_USED
    if (((bool)true == handle_ptr->local_queue_handle->rs_intr_handle.interrupt_enable) &&
 8027392:	2b03      	cmp	r3, #3
 8027394:	f000 8133 	beq.w	80275fe <ADC_MEASUREMENT_ADV_Init+0x3c2>
{
  XMC_ASSERT("ADC_MEASUREMENT_ADV_InsertChannels:Invalid handle_ptr", (handle_ptr != NULL))

#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8027398:	2b01      	cmp	r3, #1
 802739a:	f240 814b 	bls.w	8027634 <ADC_MEASUREMENT_ADV_Init+0x3f8>
/* Local function to insert the queue entries into the hardware.*/
__STATIC_INLINE void ADC_MEASUREMENT_ADV_lQueueInsertEntries(const ADC_MEASUREMENT_ADV_t *const handle_ptr)
{
  uint32_t entry_index;

  XMC_VADC_GROUP_t *queue_group_ptr = group_ptrs[handle_ptr->group_index];
 802739e:	7daa      	ldrb	r2, [r5, #22]
  const XMC_VADC_QUEUE_ENTRY_t **const entries_array = handle_ptr->local_queue_entries;

  for(entry_index = 0; entry_index < handle_ptr->total_number_of_entries; entry_index++)
 80273a0:	7deb      	ldrb	r3, [r5, #23]
/* Local function to insert the queue entries into the hardware.*/
__STATIC_INLINE void ADC_MEASUREMENT_ADV_lQueueInsertEntries(const ADC_MEASUREMENT_ADV_t *const handle_ptr)
{
  uint32_t entry_index;

  XMC_VADC_GROUP_t *queue_group_ptr = group_ptrs[handle_ptr->group_index];
 80273a2:	f856 0022 	ldr.w	r0, [r6, r2, lsl #2]
  const XMC_VADC_QUEUE_ENTRY_t **const entries_array = handle_ptr->local_queue_entries;
 80273a6:	686a      	ldr	r2, [r5, #4]

  for(entry_index = 0; entry_index < handle_ptr->total_number_of_entries; entry_index++)
 80273a8:	b18b      	cbz	r3, 80273ce <ADC_MEASUREMENT_ADV_Init+0x192>
 80273aa:	3a04      	subs	r2, #4
 80273ac:	2300      	movs	r3, #0
 80273ae:	f852 1f04 	ldr.w	r1, [r2, #4]!
 80273b2:	6809      	ldr	r1, [r1, #0]
__STATIC_INLINE void XMC_VADC_GROUP_QueueInsertChannel(XMC_VADC_GROUP_t *const group_ptr,
                                                       const XMC_VADC_QUEUE_ENTRY_t entry)
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueInsertChannel:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  /* Insert the channel physically and get the length of the queue*/
  group_ptr->QINR0 = entry.qinr0;
 80273b4:	f8c0 1110 	str.w	r1, [r0, #272]	; 0x110
 80273b8:	7de9      	ldrb	r1, [r5, #23]
 80273ba:	3301      	adds	r3, #1
 80273bc:	428b      	cmp	r3, r1
 80273be:	d3f6      	bcc.n	80273ae <ADC_MEASUREMENT_ADV_Init+0x172>
/* Enables the arbiter of the selected request source*/
void ADC_MEASUREMENT_ADV_StartADC(const ADC_MEASUREMENT_ADV_t *const handle_ptr)
{
#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 80273c0:	7d2b      	ldrb	r3, [r5, #20]
 80273c2:	2b01      	cmp	r3, #1
 80273c4:	f240 813c 	bls.w	8027640 <ADC_MEASUREMENT_ADV_Init+0x404>
 80273c8:	7dab      	ldrb	r3, [r5, #22]
 80273ca:	f856 0023 	ldr.w	r0, [r6, r3, lsl #2]
 *  XMC_VADC_GROUP_QueueDisableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_QueueEnableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueEnableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr));
  group_ptr->ARBPR |= (uint32_t)((uint32_t)1 << VADC_G_ARBPR_ASEN0_Pos);
 80273ce:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
 80273d2:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80273d6:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
    {
      ADC_MEASUREMENT_ADV_StartADC(handle_ptr);
    }
#endif

    *handle_ptr->init_state = status;
 80273da:	692a      	ldr	r2, [r5, #16]
  }
  return (*handle_ptr->init_state);
}
 80273dc:	4640      	mov	r0, r8
    {
      ADC_MEASUREMENT_ADV_StartADC(handle_ptr);
    }
#endif

    *handle_ptr->init_state = status;
 80273de:	f882 8000 	strb.w	r8, [r2]
  }
  return (*handle_ptr->init_state);
}
 80273e2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80273e6:	7d2b      	ldrb	r3, [r5, #20]
 80273e8:	e7d6      	b.n	8027398 <ADC_MEASUREMENT_ADV_Init+0x15c>
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 80273ea:	7d2b      	ldrb	r3, [r5, #20]
 80273ec:	4e30      	ldr	r6, [pc, #192]	; (80274b0 <ADC_MEASUREMENT_ADV_Init+0x274>)
 80273ee:	7daa      	ldrb	r2, [r5, #22]
 80273f0:	2b01      	cmp	r3, #1
 80273f2:	f856 4022 	ldr.w	r4, [r6, r2, lsl #2]
  bool arbitration_status;

#if !defined(CLOCK_GATING_SUPPORTED) || !defined(ADC_MEASUREMENT_ADV_CHECK_CLOCK_GATING)
  clock_reset_check = (bool)false;
#endif
  arbitration_status = (bool)false;
 80273f6:	f04f 0900 	mov.w	r9, #0
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 80273fa:	f63f af3a 	bhi.w	8027272 <ADC_MEASUREMENT_ADV_Init+0x36>
                                                           uint8_t group_index)
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

  /*Initialization of APP 'ADCGroup'*/
  status = (ADC_MEASUREMENT_ADV_STATUS_t) GLOBAL_ADC_Init(ADC_MEASUREMENT_ADV_GLOBAL_HANDLE);
 80273fe:	482d      	ldr	r0, [pc, #180]	; (80274b4 <ADC_MEASUREMENT_ADV_Init+0x278>)
#ifdef ADC_MEASUREMENT_ADV_LOCAL_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_ADC_SCAN_USED
      if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_SCAN != handle_ptr->req_src)
  #endif
      {
        status = ADC_MEASUREMENT_ADV_lScanInit(handle_ptr->local_scan_handle,handle_ptr->group_index);
 8027400:	68ef      	ldr	r7, [r5, #12]
                                                           uint8_t group_index)
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

  /*Initialization of APP 'ADCGroup'*/
  status = (ADC_MEASUREMENT_ADV_STATUS_t) GLOBAL_ADC_Init(ADC_MEASUREMENT_ADV_GLOBAL_HANDLE);
 8027402:	f7ff fadd 	bl	80269c0 <GLOBAL_ADC_Init>

  XMC_VADC_GROUP_InputClassInit(group_ptrs[group_index], handle_ptr->iclass_config_handle,
 8027406:	f897 3020 	ldrb.w	r3, [r7, #32]
 802740a:	6939      	ldr	r1, [r7, #16]
 802740c:	2200      	movs	r2, #0
                                                           uint8_t group_index)
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

  /*Initialization of APP 'ADCGroup'*/
  status = (ADC_MEASUREMENT_ADV_STATUS_t) GLOBAL_ADC_Init(ADC_MEASUREMENT_ADV_GLOBAL_HANDLE);
 802740e:	4680      	mov	r8, r0

  XMC_VADC_GROUP_InputClassInit(group_ptrs[group_index], handle_ptr->iclass_config_handle,
 8027410:	4620      	mov	r0, r4
 8027412:	f7fc f917 	bl	8023644 <XMC_VADC_GROUP_InputClassInit>
                                XMC_VADC_GROUP_CONV_STD, (uint32_t)handle_ptr->iclass_num);


  /*Initialization of scan request source*/
  XMC_VADC_GROUP_ScanInit(group_ptrs[group_index], handle_ptr->scan_config_handle);
 8027416:	4620      	mov	r0, r4
 8027418:	6979      	ldr	r1, [r7, #20]
 802741a:	f7fc f981 	bl	8023720 <XMC_VADC_GROUP_ScanInit>
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanSetGatingMode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_ScanSetGatingMode:Wrong mode selected", (mode_sel <= XMC_VADC_GATEMODE_ACTIVELOW))

  /* Clear the existing gate configuration */
  group_ptr->ASMR &= (uint32_t) (~((uint32_t)VADC_G_ASMR_ENGT_Msk));
 802741e:	f8d4 2124 	ldr.w	r2, [r4, #292]	; 0x124

  /* Configure the gating mode for Scan*/
  XMC_VADC_GROUP_ScanSetGatingMode(group_ptrs[group_index], handle_ptr->gating_mode);
 8027422:	7e38      	ldrb	r0, [r7, #24]

  /*Interrupt Configuration*/
  if ((bool)true == handle_ptr->rs_intr_handle.interrupt_enable)
 8027424:	7b39      	ldrb	r1, [r7, #12]
 8027426:	f022 0203 	bic.w	r2, r2, #3
 802742a:	f8c4 2124 	str.w	r2, [r4, #292]	; 0x124
  /* Set the new gating mode */
  group_ptr->ASMR |= (uint32_t)((uint32_t)mode_sel << VADC_G_ASMR_ENGT_Pos);
 802742e:	f8d4 3124 	ldr.w	r3, [r4, #292]	; 0x124
 8027432:	4303      	orrs	r3, r0
 8027434:	f8c4 3124 	str.w	r3, [r4, #292]	; 0x124
 8027438:	2900      	cmp	r1, #0
 802743a:	f43f af69 	beq.w	8027310 <ADC_MEASUREMENT_ADV_Init+0xd4>
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 802743e:	4b1e      	ldr	r3, [pc, #120]	; (80274b8 <ADC_MEASUREMENT_ADV_Init+0x27c>)
  {
#if (UC_FAMILY == XMC1)
    NVIC_SetPriority((IRQn_Type)handle_ptr->rs_intr_handle.node_id, handle_ptr->rs_intr_handle.priority);
#else
    NVIC_SetPriority((IRQn_Type)handle_ptr->rs_intr_handle.node_id,
 8027440:	f8d7 e000 	ldr.w	lr, [r7]
 8027444:	68db      	ldr	r3, [r3, #12]
 8027446:	6878      	ldr	r0, [r7, #4]
 8027448:	f8d7 c008 	ldr.w	ip, [r7, #8]
 802744c:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8027450:	f1c3 0a07 	rsb	sl, r3, #7
 8027454:	f1ba 0f06 	cmp.w	sl, #6
 8027458:	bf28      	it	cs
 802745a:	f04f 0a06 	movcs.w	sl, #6
 802745e:	fa5f f18e 	uxtb.w	r1, lr
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8027462:	2b00      	cmp	r3, #0
 8027464:	f000 8101 	beq.w	802766a <ADC_MEASUREMENT_ADV_Init+0x42e>
 8027468:	1e5a      	subs	r2, r3, #1
 802746a:	2301      	movs	r3, #1
 802746c:	4093      	lsls	r3, r2
 802746e:	3b01      	subs	r3, #1
 8027470:	ea03 030c 	and.w	r3, r3, ip

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8027474:	f04f 0c01 	mov.w	ip, #1
 8027478:	fa0c fc0a 	lsl.w	ip, ip, sl
 802747c:	f10c 3cff 	add.w	ip, ip, #4294967295
 8027480:	ea0c 0000 	and.w	r0, ip, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8027484:	b249      	sxtb	r1, r1

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8027486:	fa00 f202 	lsl.w	r2, r0, r2
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 802748a:	2900      	cmp	r1, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 802748c:	ea43 0302 	orr.w	r3, r3, r2
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8027490:	f2c0 811c 	blt.w	80276cc <ADC_MEASUREMENT_ADV_Init+0x490>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8027494:	f101 4260 	add.w	r2, r1, #3758096384	; 0xe0000000
 8027498:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 802749c:	009b      	lsls	r3, r3, #2
 802749e:	b2db      	uxtb	r3, r3
 80274a0:	f882 3300 	strb.w	r3, [r2, #768]	; 0x300
    XMC_SCU_SetInterruptControl(handle_ptr->rs_intr_handle.node_id,
                                ((handle_ptr->rs_intr_handle.node_id << 8) | handle_ptr->rs_intr_handle.irqctrl));
#endif

    /* Connect RS Events to NVIC nodes */
    XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode(group_ptrs[group_index], handle_ptr->srv_req_node);
 80274a4:	4620      	mov	r0, r4
 80274a6:	7e79      	ldrb	r1, [r7, #25]
 80274a8:	f7fc f97e 	bl	80237a8 <XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode>
 80274ac:	e730      	b.n	8027310 <ADC_MEASUREMENT_ADV_Init+0xd4>
 80274ae:	bf00      	nop
 80274b0:	0802b048 	.word	0x0802b048
 80274b4:	1ffe898c 	.word	0x1ffe898c
 80274b8:	e000ed00 	.word	0xe000ed00
__STATIC_INLINE void ADC_MEASUREMENT_ADV_lSyncInit(const ADC_MEASUREMENT_ADV_t *const handle_ptr)
{
  uint8_t sync_group;

  /* shift to get the 4 bit position needed to or it with the slave groups */
  sync_group = handle_ptr->sync_slaves | ( 1 << handle_ptr->group_index);
 80274bc:	7daa      	ldrb	r2, [r5, #22]
 80274be:	2701      	movs	r7, #1
 80274c0:	4097      	lsls	r7, r2
 80274c2:	433b      	orrs	r3, r7
  ADC_MEASUREMENT_ADV_lSyncSequencer(handle_ptr, sync_group, ADC_MEASUREMENT_ADV_SYNC_SEQ_POWER_DOWN);
 80274c4:	b2df      	uxtb	r7, r3
 80274c6:	2403      	movs	r4, #3
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 80274c8:	fa27 f304 	lsr.w	r3, r7, r4
 80274cc:	f013 0f01 	tst.w	r3, #1
    {
      switch( sequence)
      {
        case ADC_MEASUREMENT_ADV_SYNC_SEQ_POWER_DOWN:
             XMC_VADC_GROUP_SetPowerMode(group_ptrs[group_index],XMC_VADC_GROUP_POWERMODE_OFF);
 80274d0:	f04f 0100 	mov.w	r1, #0
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 80274d4:	d003      	beq.n	80274de <ADC_MEASUREMENT_ADV_Init+0x2a2>
    {
      switch( sequence)
      {
        case ADC_MEASUREMENT_ADV_SYNC_SEQ_POWER_DOWN:
             XMC_VADC_GROUP_SetPowerMode(group_ptrs[group_index],XMC_VADC_GROUP_POWERMODE_OFF);
 80274d6:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
 80274da:	f7fc f8d9 	bl	8023690 <XMC_VADC_GROUP_SetPowerMode>
void ADC_MEASUREMENT_ADV_lSyncSequencer(const ADC_MEASUREMENT_ADV_t *const handle_ptr,
                                        uint32_t sync_group,
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
 80274de:	f114 34ff 	adds.w	r4, r4, #4294967295
 80274e2:	d2f1      	bcs.n	80274c8 <ADC_MEASUREMENT_ADV_Init+0x28c>

  /* shift to get the 4 bit position needed to or it with the slave groups */
  sync_group = handle_ptr->sync_slaves | ( 1 << handle_ptr->group_index);
  ADC_MEASUREMENT_ADV_lSyncSequencer(handle_ptr, sync_group, ADC_MEASUREMENT_ADV_SYNC_SEQ_POWER_DOWN);

  sync_group = handle_ptr->sync_slaves;
 80274e4:	7d6f      	ldrb	r7, [r5, #21]
  ADC_MEASUREMENT_ADV_lSyncSequencer(handle_ptr, sync_group, ADC_MEASUREMENT_ADV_SYNC_SEQ_STSEL_CONFIG);
 80274e6:	2403      	movs	r4, #3
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 80274e8:	fa27 f304 	lsr.w	r3, r7, r4
 80274ec:	07d8      	lsls	r0, r3, #31
      {
        case ADC_MEASUREMENT_ADV_SYNC_SEQ_POWER_DOWN:
             XMC_VADC_GROUP_SetPowerMode(group_ptrs[group_index],XMC_VADC_GROUP_POWERMODE_OFF);
             break;
        case ADC_MEASUREMENT_ADV_SYNC_SEQ_STSEL_CONFIG:
             XMC_VADC_GROUP_SetSyncSlave(group_ptrs[group_index], handle_ptr->group_index, group_index);
 80274ee:	4622      	mov	r2, r4
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 80274f0:	d50a      	bpl.n	8027508 <ADC_MEASUREMENT_ADV_Init+0x2cc>
      {
        case ADC_MEASUREMENT_ADV_SYNC_SEQ_POWER_DOWN:
             XMC_VADC_GROUP_SetPowerMode(group_ptrs[group_index],XMC_VADC_GROUP_POWERMODE_OFF);
             break;
        case ADC_MEASUREMENT_ADV_SYNC_SEQ_STSEL_CONFIG:
             XMC_VADC_GROUP_SetSyncSlave(group_ptrs[group_index], handle_ptr->group_index, group_index);
 80274f2:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
 80274f6:	7da9      	ldrb	r1, [r5, #22]
 80274f8:	f7fc f8d2 	bl	80236a0 <XMC_VADC_GROUP_SetSyncSlave>
             XMC_VADC_GROUP_CheckSlaveReadiness(group_ptrs[handle_ptr->group_index],group_index);
 80274fc:	7dab      	ldrb	r3, [r5, #22]
 80274fe:	4621      	mov	r1, r4
 8027500:	f856 0023 	ldr.w	r0, [r6, r3, lsl #2]
 8027504:	f7fc f8e0 	bl	80236c8 <XMC_VADC_GROUP_CheckSlaveReadiness>
void ADC_MEASUREMENT_ADV_lSyncSequencer(const ADC_MEASUREMENT_ADV_t *const handle_ptr,
                                        uint32_t sync_group,
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
 8027508:	f114 34ff 	adds.w	r4, r4, #4294967295
 802750c:	d2ec      	bcs.n	80274e8 <ADC_MEASUREMENT_ADV_Init+0x2ac>
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 802750e:	0739      	lsls	r1, r7, #28
 8027510:	d510      	bpl.n	8027534 <ADC_MEASUREMENT_ADV_Init+0x2f8>
/* Helper function to configure the eval bits in the slave*/
void ADC_MEASUREMENT_ADV_lSyncEvalConfig(uint32_t master_group, uint32_t slave_selected,
                                         uint32_t sync_group)
{
  int8_t group_index;
  sync_group |= (1U << master_group);
 8027512:	7dab      	ldrb	r3, [r5, #22]
 8027514:	2401      	movs	r4, #1
 8027516:	409c      	lsls	r4, r3
 8027518:	433c      	orrs	r4, r7
  sync_group &= ~(1U << slave_selected);
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 802751a:	0762      	lsls	r2, r4, #29
 802751c:	f100 80b8 	bmi.w	8027690 <ADC_MEASUREMENT_ADV_Init+0x454>
 8027520:	07a3      	lsls	r3, r4, #30
 8027522:	f100 80af 	bmi.w	8027684 <ADC_MEASUREMENT_ADV_Init+0x448>
 8027526:	07e0      	lsls	r0, r4, #31
 8027528:	d504      	bpl.n	8027534 <ADC_MEASUREMENT_ADV_Init+0x2f8>
    {
      XMC_VADC_GROUP_SetSyncSlaveReadySignal(group_ptrs[slave_selected], slave_selected, group_index);
 802752a:	486c      	ldr	r0, [pc, #432]	; (80276dc <ADC_MEASUREMENT_ADV_Init+0x4a0>)
 802752c:	2103      	movs	r1, #3
 802752e:	2200      	movs	r2, #0
 8027530:	f7fc f8ea 	bl	8023708 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8027534:	0779      	lsls	r1, r7, #29
 8027536:	d510      	bpl.n	802755a <ADC_MEASUREMENT_ADV_Init+0x31e>
/* Helper function to configure the eval bits in the slave*/
void ADC_MEASUREMENT_ADV_lSyncEvalConfig(uint32_t master_group, uint32_t slave_selected,
                                         uint32_t sync_group)
{
  int8_t group_index;
  sync_group |= (1U << master_group);
 8027538:	7dab      	ldrb	r3, [r5, #22]
 802753a:	2401      	movs	r4, #1
 802753c:	409c      	lsls	r4, r3
 802753e:	433c      	orrs	r4, r7
  sync_group &= ~(1U << slave_selected);
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8027540:	0722      	lsls	r2, r4, #28
 8027542:	f100 80bd 	bmi.w	80276c0 <ADC_MEASUREMENT_ADV_Init+0x484>
 8027546:	07a3      	lsls	r3, r4, #30
 8027548:	f100 80b4 	bmi.w	80276b4 <ADC_MEASUREMENT_ADV_Init+0x478>
 802754c:	07e0      	lsls	r0, r4, #31
 802754e:	d504      	bpl.n	802755a <ADC_MEASUREMENT_ADV_Init+0x31e>
    {
      XMC_VADC_GROUP_SetSyncSlaveReadySignal(group_ptrs[slave_selected], slave_selected, group_index);
 8027550:	4863      	ldr	r0, [pc, #396]	; (80276e0 <ADC_MEASUREMENT_ADV_Init+0x4a4>)
 8027552:	2102      	movs	r1, #2
 8027554:	2200      	movs	r2, #0
 8027556:	f7fc f8d7 	bl	8023708 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 802755a:	07b9      	lsls	r1, r7, #30
 802755c:	d510      	bpl.n	8027580 <ADC_MEASUREMENT_ADV_Init+0x344>
/* Helper function to configure the eval bits in the slave*/
void ADC_MEASUREMENT_ADV_lSyncEvalConfig(uint32_t master_group, uint32_t slave_selected,
                                         uint32_t sync_group)
{
  int8_t group_index;
  sync_group |= (1U << master_group);
 802755e:	7dab      	ldrb	r3, [r5, #22]
 8027560:	2101      	movs	r1, #1
 8027562:	fa01 f403 	lsl.w	r4, r1, r3
 8027566:	433c      	orrs	r4, r7
  sync_group &= ~(1U << slave_selected);
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8027568:	0722      	lsls	r2, r4, #28
 802756a:	f100 8086 	bmi.w	802767a <ADC_MEASUREMENT_ADV_Init+0x43e>
 802756e:	0763      	lsls	r3, r4, #29
 8027570:	d47d      	bmi.n	802766e <ADC_MEASUREMENT_ADV_Init+0x432>
 8027572:	07e4      	lsls	r4, r4, #31
 8027574:	d504      	bpl.n	8027580 <ADC_MEASUREMENT_ADV_Init+0x344>
    {
      XMC_VADC_GROUP_SetSyncSlaveReadySignal(group_ptrs[slave_selected], slave_selected, group_index);
 8027576:	485b      	ldr	r0, [pc, #364]	; (80276e4 <ADC_MEASUREMENT_ADV_Init+0x4a8>)
 8027578:	2101      	movs	r1, #1
 802757a:	2200      	movs	r2, #0
 802757c:	f7fc f8c4 	bl	8023708 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8027580:	07f8      	lsls	r0, r7, #31
 8027582:	d510      	bpl.n	80275a6 <ADC_MEASUREMENT_ADV_Init+0x36a>
/* Helper function to configure the eval bits in the slave*/
void ADC_MEASUREMENT_ADV_lSyncEvalConfig(uint32_t master_group, uint32_t slave_selected,
                                         uint32_t sync_group)
{
  int8_t group_index;
  sync_group |= (1U << master_group);
 8027584:	7daa      	ldrb	r2, [r5, #22]
 8027586:	2301      	movs	r3, #1
 8027588:	4093      	lsls	r3, r2
 802758a:	431f      	orrs	r7, r3
  sync_group &= ~(1U << slave_selected);
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 802758c:	0739      	lsls	r1, r7, #28
 802758e:	f100 808b 	bmi.w	80276a8 <ADC_MEASUREMENT_ADV_Init+0x46c>
 8027592:	077a      	lsls	r2, r7, #29
 8027594:	f100 8082 	bmi.w	802769c <ADC_MEASUREMENT_ADV_Init+0x460>
 8027598:	07bb      	lsls	r3, r7, #30
 802759a:	d504      	bpl.n	80275a6 <ADC_MEASUREMENT_ADV_Init+0x36a>
    {
      XMC_VADC_GROUP_SetSyncSlaveReadySignal(group_ptrs[slave_selected], slave_selected, group_index);
 802759c:	4852      	ldr	r0, [pc, #328]	; (80276e8 <ADC_MEASUREMENT_ADV_Init+0x4ac>)
 802759e:	2100      	movs	r1, #0
 80275a0:	2201      	movs	r2, #1
 80275a2:	f7fc f8b1 	bl	8023708 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
  sync_group = handle_ptr->sync_slaves;
  ADC_MEASUREMENT_ADV_lSyncSequencer(handle_ptr, sync_group, ADC_MEASUREMENT_ADV_SYNC_SEQ_STSEL_CONFIG);
  ADC_MEASUREMENT_ADV_lSyncSequencer(handle_ptr, sync_group, ADC_MEASUREMENT_ADV_SYNC_SEQ_EVAL_CONFIG);

  /* Configure the iclass settings needed for the sync slaves*/
  if( (bool) false != handle_ptr->configure_globiclass1)
 80275a6:	7eab      	ldrb	r3, [r5, #26]
 80275a8:	b1b3      	cbz	r3, 80275d8 <ADC_MEASUREMENT_ADV_Init+0x39c>
{
  XMC_VADC_CHANNEL_CONV_t req_iclass;

#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 80275aa:	7d2b      	ldrb	r3, [r5, #20]
  XMC_VADC_GLOBAL_CLASS_t conv_class_global;

  XMC_ASSERT("ADC_MEASUREMENT_ADV_SetIclass:Invalid handle_ptr", (handle_ptr != NULL))

  req_iclass = ADC_MEASUREMENT_ADV_lGetIclass(handle_ptr);
  conv_class = XMC_VADC_GROUP_GetInputClass(group_ptrs[handle_ptr->group_index], req_iclass);
 80275ac:	7daa      	ldrb	r2, [r5, #22]
{
  XMC_VADC_CHANNEL_CONV_t req_iclass;

#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 80275ae:	2b01      	cmp	r3, #1
#ifdef ADC_MEASUREMENT_ADV_LOCAL_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_ADC_SCAN_USED
      if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_SCAN != handle_ptr->req_src)
  #endif
      {
        req_iclass = (XMC_VADC_CHANNEL_CONV_t)handle_ptr->local_scan_handle->iclass_num;
 80275b0:	68eb      	ldr	r3, [r5, #12]
  XMC_VADC_GLOBAL_CLASS_t conv_class_global;

  XMC_ASSERT("ADC_MEASUREMENT_ADV_SetIclass:Invalid handle_ptr", (handle_ptr != NULL))

  req_iclass = ADC_MEASUREMENT_ADV_lGetIclass(handle_ptr);
  conv_class = XMC_VADC_GROUP_GetInputClass(group_ptrs[handle_ptr->group_index], req_iclass);
 80275b2:	f856 2022 	ldr.w	r2, [r6, r2, lsl #2]
#ifdef ADC_MEASUREMENT_ADV_LOCAL_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_ADC_SCAN_USED
      if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_SCAN != handle_ptr->req_src)
  #endif
      {
        req_iclass = (XMC_VADC_CHANNEL_CONV_t)handle_ptr->local_scan_handle->iclass_num;
 80275b6:	bf94      	ite	ls
 80275b8:	f893 3020 	ldrbls.w	r3, [r3, #32]
#ifdef ADC_MEASUREMENT_ADV_LOCAL_QUEUE_USED
  #ifdef ADC_MEASUREMENT_ADV_ADC_QUEUE_USED
      if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_QUEUE != handle_ptr->req_src)
  #endif
      {
        req_iclass = (XMC_VADC_CHANNEL_CONV_t)handle_ptr->local_queue_handle->iclass_num;
 80275bc:	7e9b      	ldrbhi	r3, [r3, #26]
  XMC_ASSERT("XMC_VADC_GROUP_GetInputClass:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_GetInputClass:Wrong conv_class selected", 
             (XMC_VADC_CHANNEL_CONV_GROUP_CLASS0 == conv_class) || (XMC_VADC_CHANNEL_CONV_GROUP_CLASS1 == conv_class))

  input_value.g_iclass0 = (uint32_t) 0xFFFFFFFF;
  if ((XMC_VADC_CHANNEL_CONV_GROUP_CLASS0 == conv_class) || (XMC_VADC_CHANNEL_CONV_GROUP_CLASS1 == conv_class))
 80275be:	2b01      	cmp	r3, #1
  {
    input_value.g_iclass0 = group_ptr->ICLASS[(uint32_t)conv_class];
 80275c0:	bf96      	itet	ls
 80275c2:	3328      	addls	r3, #40	; 0x28
  XMC_VADC_GROUP_CLASS_t input_value;
  XMC_ASSERT("XMC_VADC_GROUP_GetInputClass:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_GetInputClass:Wrong conv_class selected", 
             (XMC_VADC_CHANNEL_CONV_GROUP_CLASS0 == conv_class) || (XMC_VADC_CHANNEL_CONV_GROUP_CLASS1 == conv_class))

  input_value.g_iclass0 = (uint32_t) 0xFFFFFFFF;
 80275c4:	f04f 31ff 	movhi.w	r1, #4294967295
  if ((XMC_VADC_CHANNEL_CONV_GROUP_CLASS0 == conv_class) || (XMC_VADC_CHANNEL_CONV_GROUP_CLASS1 == conv_class))
  {
    input_value.g_iclass0 = group_ptr->ICLASS[(uint32_t)conv_class];
 80275c8:	f852 1023 	ldrls.w	r1, [r2, r3, lsl #2]
  XMC_ASSERT("ADC_MEASUREMENT_ADV_SetIclass:Invalid handle_ptr", (handle_ptr != NULL))

  req_iclass = ADC_MEASUREMENT_ADV_lGetIclass(handle_ptr);
  conv_class = XMC_VADC_GROUP_GetInputClass(group_ptrs[handle_ptr->group_index], req_iclass);
  conv_class_global.globiclass = conv_class.g_iclass0;
  XMC_VADC_GLOBAL_InputClassInit(ADC_MEASUREMENT_ADV_GLOBAL_PTR, conv_class_global,
 80275cc:	f04f 2040 	mov.w	r0, #1073758208	; 0x40004000
 80275d0:	2200      	movs	r2, #0
 80275d2:	2301      	movs	r3, #1
 80275d4:	f7fb ff90 	bl	80234f8 <XMC_VADC_GLOBAL_InputClassInit>
  if( (bool) false != handle_ptr->configure_globiclass1)
  {
    ADC_MEASUREMENT_ADV_SetIclass(handle_ptr);
  }

  XMC_VADC_GROUP_SetSyncMaster(group_ptrs[handle_ptr->group_index]);
 80275d8:	7dab      	ldrb	r3, [r5, #22]
 80275da:	f856 0023 	ldr.w	r0, [r6, r3, lsl #2]
 80275de:	f7fc f86b 	bl	80236b8 <XMC_VADC_GROUP_SetSyncMaster>

  XMC_VADC_GROUP_SetPowerMode(group_ptrs[handle_ptr->group_index],XMC_VADC_GROUP_POWERMODE_NORMAL);
 80275e2:	7dab      	ldrb	r3, [r5, #22]
 80275e4:	2103      	movs	r1, #3
 80275e6:	f856 0023 	ldr.w	r0, [r6, r3, lsl #2]
 80275ea:	f7fc f851 	bl	8023690 <XMC_VADC_GROUP_SetPowerMode>
 80275ee:	e6a4      	b.n	802733a <ADC_MEASUREMENT_ADV_Init+0xfe>
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80275f0:	1e5a      	subs	r2, r3, #1
 80275f2:	2301      	movs	r3, #1
 80275f4:	4093      	lsls	r3, r2
 80275f6:	3b01      	subs	r3, #1
 80275f8:	ea03 030c 	and.w	r3, r3, ip
 80275fc:	e66c      	b.n	80272d8 <ADC_MEASUREMENT_ADV_Init+0x9c>
#endif
#ifdef ADC_MEASUREMENT_ADV_LOCAL_QUEUE_USED
    if (((bool)true == handle_ptr->local_queue_handle->rs_intr_handle.interrupt_enable) &&
        (ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_QUEUE == handle_ptr->req_src))
    {
      NVIC_EnableIRQ((IRQn_Type)handle_ptr->local_queue_handle->rs_intr_handle.node_id);
 80275fe:	6812      	ldr	r2, [r2, #0]
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
 8027600:	b253      	sxtb	r3, r2
 8027602:	2b00      	cmp	r3, #0
 8027604:	f6ff aecb 	blt.w	802739e <ADC_MEASUREMENT_ADV_Init+0x162>
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8027608:	f002 021f 	and.w	r2, r2, #31
 802760c:	095b      	lsrs	r3, r3, #5
 802760e:	2101      	movs	r1, #1
 8027610:	4836      	ldr	r0, [pc, #216]	; (80276ec <ADC_MEASUREMENT_ADV_Init+0x4b0>)
 8027612:	fa01 f202 	lsl.w	r2, r1, r2
 8027616:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
 802761a:	e6c0      	b.n	802739e <ADC_MEASUREMENT_ADV_Init+0x162>
{
#ifdef ADC_MEASUREMENT_ADV_LOCAL_SCAN_USED
    if (((bool)true == handle_ptr->local_scan_handle->rs_intr_handle.interrupt_enable) &&
        (ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN == handle_ptr->req_src))
    {
      NVIC_EnableIRQ((IRQn_Type)handle_ptr->local_scan_handle->rs_intr_handle.node_id);
 802761c:	6810      	ldr	r0, [r2, #0]
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
 802761e:	b241      	sxtb	r1, r0
 8027620:	2900      	cmp	r1, #0
 8027622:	db07      	blt.n	8027634 <ADC_MEASUREMENT_ADV_Init+0x3f8>
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8027624:	4a31      	ldr	r2, [pc, #196]	; (80276ec <ADC_MEASUREMENT_ADV_Init+0x4b0>)
 8027626:	f000 001f 	and.w	r0, r0, #31
 802762a:	0949      	lsrs	r1, r1, #5
 802762c:	4083      	lsls	r3, r0
 802762e:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
 8027632:	68ea      	ldr	r2, [r5, #12]
#ifdef ADC_MEASUREMENT_ADV_LOCAL_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_ADC_SCAN_USED
      if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_SCAN != handle_ptr->req_src)
  #endif
      {
        XMC_VADC_GROUP_ScanAddMultipleChannels(group_ptrs[handle_ptr->group_index], handle_ptr->local_scan_handle->insert_mask);
 8027634:	7dab      	ldrb	r3, [r5, #22]
 8027636:	69d2      	ldr	r2, [r2, #28]
 8027638:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
 *  XMC_VADC_GROUP_ScanAddChannelToSequence()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_ScanAddMultipleChannels(XMC_VADC_GROUP_t *const group_ptr, const uint32_t ch_mask)
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanAddMultipleChannels:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->ASSEL = ch_mask;
 802763c:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
  #endif
      {
        XMC_VADC_GROUP_ScanEnableArbitrationSlot(group_ptrs[handle_ptr->group_index]);
 8027640:	7dab      	ldrb	r3, [r5, #22]
 8027642:	f856 2023 	ldr.w	r2, [r6, r3, lsl #2]
 *  XMC_VADC_GROUP_ScanDisableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_ScanEnableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanEnableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->ARBPR |= (uint32_t)VADC_G_ARBPR_ASEN1_Msk;
 8027646:	f8d2 3084 	ldr.w	r3, [r2, #132]	; 0x84
 802764a:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 802764e:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
 8027652:	e6c2      	b.n	80273da <ADC_MEASUREMENT_ADV_Init+0x19e>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8027654:	4a26      	ldr	r2, [pc, #152]	; (80276f0 <ADC_MEASUREMENT_ADV_Init+0x4b4>)
 8027656:	f00e 0e0f 	and.w	lr, lr, #15
 802765a:	009b      	lsls	r3, r3, #2
 802765c:	4472      	add	r2, lr
 802765e:	b2db      	uxtb	r3, r3
 8027660:	7613      	strb	r3, [r2, #24]
 8027662:	e651      	b.n	8027308 <ADC_MEASUREMENT_ADV_Init+0xcc>
 */
__STATIC_INLINE bool XMC_VADC_GROUP_ScanIsArbitrationSlotEnabled(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanIsArbitrationSlotEnabled:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  return ((group_ptr->ARBPR & (uint32_t)VADC_G_ARBPR_ASEN1_Msk) >> VADC_G_ARBPR_ASEN1_Pos);
 8027664:	f3c3 6940 	ubfx	r9, r3, #25, #1
 8027668:	e6c9      	b.n	80273fe <ADC_MEASUREMENT_ADV_Init+0x1c2>
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 802766a:	461a      	mov	r2, r3
 802766c:	e702      	b.n	8027474 <ADC_MEASUREMENT_ADV_Init+0x238>
  sync_group &= ~(1U << slave_selected);
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
    {
      XMC_VADC_GROUP_SetSyncSlaveReadySignal(group_ptrs[slave_selected], slave_selected, group_index);
 802766e:	481d      	ldr	r0, [pc, #116]	; (80276e4 <ADC_MEASUREMENT_ADV_Init+0x4a8>)
 8027670:	2101      	movs	r1, #1
 8027672:	2202      	movs	r2, #2
 8027674:	f7fc f848 	bl	8023708 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 8027678:	e77b      	b.n	8027572 <ADC_MEASUREMENT_ADV_Init+0x336>
 802767a:	481a      	ldr	r0, [pc, #104]	; (80276e4 <ADC_MEASUREMENT_ADV_Init+0x4a8>)
 802767c:	2203      	movs	r2, #3
 802767e:	f7fc f843 	bl	8023708 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 8027682:	e774      	b.n	802756e <ADC_MEASUREMENT_ADV_Init+0x332>
 8027684:	4815      	ldr	r0, [pc, #84]	; (80276dc <ADC_MEASUREMENT_ADV_Init+0x4a0>)
 8027686:	2103      	movs	r1, #3
 8027688:	2201      	movs	r2, #1
 802768a:	f7fc f83d 	bl	8023708 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 802768e:	e74a      	b.n	8027526 <ADC_MEASUREMENT_ADV_Init+0x2ea>
 8027690:	4812      	ldr	r0, [pc, #72]	; (80276dc <ADC_MEASUREMENT_ADV_Init+0x4a0>)
 8027692:	2103      	movs	r1, #3
 8027694:	2202      	movs	r2, #2
 8027696:	f7fc f837 	bl	8023708 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 802769a:	e741      	b.n	8027520 <ADC_MEASUREMENT_ADV_Init+0x2e4>
 802769c:	4812      	ldr	r0, [pc, #72]	; (80276e8 <ADC_MEASUREMENT_ADV_Init+0x4ac>)
 802769e:	2100      	movs	r1, #0
 80276a0:	2202      	movs	r2, #2
 80276a2:	f7fc f831 	bl	8023708 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 80276a6:	e777      	b.n	8027598 <ADC_MEASUREMENT_ADV_Init+0x35c>
 80276a8:	480f      	ldr	r0, [pc, #60]	; (80276e8 <ADC_MEASUREMENT_ADV_Init+0x4ac>)
 80276aa:	2100      	movs	r1, #0
 80276ac:	2203      	movs	r2, #3
 80276ae:	f7fc f82b 	bl	8023708 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 80276b2:	e76e      	b.n	8027592 <ADC_MEASUREMENT_ADV_Init+0x356>
 80276b4:	480a      	ldr	r0, [pc, #40]	; (80276e0 <ADC_MEASUREMENT_ADV_Init+0x4a4>)
 80276b6:	2102      	movs	r1, #2
 80276b8:	2201      	movs	r2, #1
 80276ba:	f7fc f825 	bl	8023708 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 80276be:	e745      	b.n	802754c <ADC_MEASUREMENT_ADV_Init+0x310>
 80276c0:	4807      	ldr	r0, [pc, #28]	; (80276e0 <ADC_MEASUREMENT_ADV_Init+0x4a4>)
 80276c2:	2102      	movs	r1, #2
 80276c4:	2203      	movs	r2, #3
 80276c6:	f7fc f81f 	bl	8023708 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 80276ca:	e73c      	b.n	8027546 <ADC_MEASUREMENT_ADV_Init+0x30a>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80276cc:	4a08      	ldr	r2, [pc, #32]	; (80276f0 <ADC_MEASUREMENT_ADV_Init+0x4b4>)
 80276ce:	f00e 0e0f 	and.w	lr, lr, #15
 80276d2:	009b      	lsls	r3, r3, #2
 80276d4:	4472      	add	r2, lr
 80276d6:	b2db      	uxtb	r3, r3
 80276d8:	7613      	strb	r3, [r2, #24]
 80276da:	e6e3      	b.n	80274a4 <ADC_MEASUREMENT_ADV_Init+0x268>
 80276dc:	40005000 	.word	0x40005000
 80276e0:	40004c00 	.word	0x40004c00
 80276e4:	40004800 	.word	0x40004800
 80276e8:	40004400 	.word	0x40004400
 80276ec:	e000e100 	.word	0xe000e100
 80276f0:	e000ecfc 	.word	0xe000ecfc

080276f4 <ADC_MEASUREMENT_ADV_G1_event_config>:
 */
static void ADC_MEASUREMENT_ADV_G1_event_config(void)
{

	/* Result Event Node Mux Configuration for IF1_I (Group-0 channel-4 Result_Register-15)*/
	XMC_VADC_GROUP_SetResultInterruptNode(VADC_G0, 15U, XMC_VADC_SR_SHARED_SR1);
 80276f4:	4802      	ldr	r0, [pc, #8]	; (8027700 <ADC_MEASUREMENT_ADV_G1_event_config+0xc>)
 80276f6:	210f      	movs	r1, #15
 80276f8:	2205      	movs	r2, #5
 80276fa:	f7fc b8e9 	b.w	80238d0 <XMC_VADC_GROUP_SetResultInterruptNode>
 80276fe:	bf00      	nop
 8027700:	40004400 	.word	0x40004400

08027704 <ADC_MEASUREMENT_ADV_G2_event_config>:
 */
static void ADC_MEASUREMENT_ADV_G2_event_config(void)
{

	/* Result Event Node Mux Configuration for IF1_Q (Group-1 channel-6 Result_Register-3)*/
	XMC_VADC_GROUP_SetResultInterruptNode(VADC_G1, 3U, XMC_VADC_SR_SHARED_SR0);
 8027704:	4802      	ldr	r0, [pc, #8]	; (8027710 <ADC_MEASUREMENT_ADV_G2_event_config+0xc>)
 8027706:	2103      	movs	r1, #3
 8027708:	2204      	movs	r2, #4
 802770a:	f7fc b8e1 	b.w	80238d0 <XMC_VADC_GROUP_SetResultInterruptNode>
 802770e:	bf00      	nop
 8027710:	40004800 	.word	0x40004800

08027714 <ADC_MEASUREMENT_ADV_G3_event_config>:
 */
static void ADC_MEASUREMENT_ADV_G3_event_config(void)
{

	/* Result Event Node Mux Configuration for IF2_I (Group-2 channel-3 Result_Register-0)*/
	XMC_VADC_GROUP_SetResultInterruptNode(VADC_G2, 0U, XMC_VADC_SR_SHARED_SR3);
 8027714:	4802      	ldr	r0, [pc, #8]	; (8027720 <ADC_MEASUREMENT_ADV_G3_event_config+0xc>)
 8027716:	2100      	movs	r1, #0
 8027718:	2207      	movs	r2, #7
 802771a:	f7fc b8d9 	b.w	80238d0 <XMC_VADC_GROUP_SetResultInterruptNode>
 802771e:	bf00      	nop
 8027720:	40004c00 	.word	0x40004c00

08027724 <ADC_MEASUREMENT_ADV_G4_event_config>:
 */
static void ADC_MEASUREMENT_ADV_G4_event_config(void)
{

	/* Result Event Node Mux Configuration for IF2_Q (Group-3 channel-0 Result_Register-4)*/
	XMC_VADC_GROUP_SetResultInterruptNode(VADC_G3, 4U, XMC_VADC_SR_GROUP_SR2);
 8027724:	4802      	ldr	r0, [pc, #8]	; (8027730 <ADC_MEASUREMENT_ADV_G4_event_config+0xc>)
 8027726:	2104      	movs	r1, #4
 8027728:	2202      	movs	r2, #2
 802772a:	f7fc b8d1 	b.w	80238d0 <XMC_VADC_GROUP_SetResultInterruptNode>
 802772e:	bf00      	nop
 8027730:	40005000 	.word	0x40005000

08027734 <DAVE_Init>:
 * @param[in]  None
 *
 * @return  DAVE_STATUS_t <BR>
 ******************************************************************************/
DAVE_STATUS_t DAVE_Init(void)
{
 8027734:	b508      	push	{r3, lr}
  DAVE_STATUS_t init_status;
  
  init_status = DAVE_STATUS_SUCCESS;
     /** @Initialization of APPs Init Functions */
     init_status = (DAVE_STATUS_t)CLOCK_XMC4_Init(&CLOCK_XMC4_0);
 8027736:	485e      	ldr	r0, [pc, #376]	; (80278b0 <DAVE_Init+0x17c>)
 8027738:	f7ff fce6 	bl	8027108 <CLOCK_XMC4_Init>

  if (init_status == DAVE_STATUS_SUCCESS)
 802773c:	b100      	cbz	r0, 8027740 <DAVE_Init+0xc>
  {
	 /**  Initialization of INTERRUPT APP instance INTERRUPT_WATCHDOG */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&INTERRUPT_WATCHDOG); 
   }  
  return init_status;
} /**  End of function DAVE_Init */
 802773e:	bd08      	pop	{r3, pc}
     init_status = (DAVE_STATUS_t)CLOCK_XMC4_Init(&CLOCK_XMC4_0);

  if (init_status == DAVE_STATUS_SUCCESS)
  {
	 /**  Initialization of ADC_MEASUREMENT_ADV APP instance ADC_MEASUREMENT_ADV_G1 */
	 init_status = (DAVE_STATUS_t)ADC_MEASUREMENT_ADV_Init(&ADC_MEASUREMENT_ADV_G1); 
 8027740:	485c      	ldr	r0, [pc, #368]	; (80278b4 <DAVE_Init+0x180>)
 8027742:	f7ff fd7b 	bl	802723c <ADC_MEASUREMENT_ADV_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027746:	2800      	cmp	r0, #0
 8027748:	d1f9      	bne.n	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_BGT_POWER_ENABLE */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_BGT_POWER_ENABLE); 
 802774a:	485b      	ldr	r0, [pc, #364]	; (80278b8 <DAVE_Init+0x184>)
 802774c:	f7ff fc94 	bl	8027078 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027750:	2800      	cmp	r0, #0
 8027752:	d1f4      	bne.n	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_PLL_CE */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_PLL_CE); 
 8027754:	4859      	ldr	r0, [pc, #356]	; (80278bc <DAVE_Init+0x188>)
 8027756:	f7ff fc8f 	bl	8027078 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802775a:	2800      	cmp	r0, #0
 802775c:	d1ef      	bne.n	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_PLL_MOD */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_PLL_MOD); 
 802775e:	4858      	ldr	r0, [pc, #352]	; (80278c0 <DAVE_Init+0x18c>)
 8027760:	f7ff fc8a 	bl	8027078 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027764:	2800      	cmp	r0, #0
 8027766:	d1ea      	bne.n	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_SPI_M_CLK */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_SPI_M_CLK); 
 8027768:	4856      	ldr	r0, [pc, #344]	; (80278c4 <DAVE_Init+0x190>)
 802776a:	f7ff fc85 	bl	8027078 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802776e:	2800      	cmp	r0, #0
 8027770:	d1e5      	bne.n	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_SPI_M_CS_BGT24 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_SPI_M_CS_BGT24); 
 8027772:	4855      	ldr	r0, [pc, #340]	; (80278c8 <DAVE_Init+0x194>)
 8027774:	f7ff fc80 	bl	8027078 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027778:	2800      	cmp	r0, #0
 802777a:	d1e0      	bne.n	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_SPI_M_CS_PLL */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_SPI_M_CS_PLL); 
 802777c:	4853      	ldr	r0, [pc, #332]	; (80278cc <DAVE_Init+0x198>)
 802777e:	f7ff fc7b 	bl	8027078 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027782:	2800      	cmp	r0, #0
 8027784:	d1db      	bne.n	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_SPI_M_DATA */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_SPI_M_DATA); 
 8027786:	4852      	ldr	r0, [pc, #328]	; (80278d0 <DAVE_Init+0x19c>)
 8027788:	f7ff fc76 	bl	8027078 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802778c:	2800      	cmp	r0, #0
 802778e:	d1d6      	bne.n	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_PLL_TRIG1 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_PLL_TRIG1); 
 8027790:	4850      	ldr	r0, [pc, #320]	; (80278d4 <DAVE_Init+0x1a0>)
 8027792:	f7ff fc71 	bl	8027078 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027796:	2800      	cmp	r0, #0
 8027798:	d1d1      	bne.n	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_PLL_TRIG2 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_PLL_TRIG2); 
 802779a:	484f      	ldr	r0, [pc, #316]	; (80278d8 <DAVE_Init+0x1a4>)
 802779c:	f7ff fc6c 	bl	8027078 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80277a0:	2800      	cmp	r0, #0
 80277a2:	d1cc      	bne.n	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of E_EEPROM_XMC4 APP instance E_EEPROM_XMC4 */
	 init_status = (DAVE_STATUS_t)E_EEPROM_XMC4_Init(&E_EEPROM_XMC4); 
 80277a4:	484d      	ldr	r0, [pc, #308]	; (80278dc <DAVE_Init+0x1a8>)
 80277a6:	f7ff f941 	bl	8026a2c <E_EEPROM_XMC4_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80277aa:	2800      	cmp	r0, #0
 80277ac:	d1c7      	bne.n	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of INTERRUPT APP instance INTERRUPT_FRAME */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&INTERRUPT_FRAME); 
 80277ae:	484c      	ldr	r0, [pc, #304]	; (80278e0 <DAVE_Init+0x1ac>)
 80277b0:	f7ff f83a 	bl	8026828 <INTERRUPT_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80277b4:	2800      	cmp	r0, #0
 80277b6:	d1c2      	bne.n	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of SYSTIMER APP instance SYSTIMER_0 */
	 init_status = (DAVE_STATUS_t)SYSTIMER_Init(&SYSTIMER_0); 
 80277b8:	484a      	ldr	r0, [pc, #296]	; (80278e4 <DAVE_Init+0x1b0>)
 80277ba:	f7fe fff3 	bl	80267a4 <SYSTIMER_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80277be:	2800      	cmp	r0, #0
 80277c0:	d1bd      	bne.n	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of TIMER APP instance TIMER_DELAY */
	 init_status = (DAVE_STATUS_t)TIMER_Init(&TIMER_DELAY); 
 80277c2:	4849      	ldr	r0, [pc, #292]	; (80278e8 <DAVE_Init+0x1b4>)
 80277c4:	f7fe fcf8 	bl	80261b8 <TIMER_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80277c8:	2800      	cmp	r0, #0
 80277ca:	d1b8      	bne.n	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of TIMER APP instance TIMER_FRAME_TRIG */
	 init_status = (DAVE_STATUS_t)TIMER_Init(&TIMER_FRAME_TRIG); 
 80277cc:	4847      	ldr	r0, [pc, #284]	; (80278ec <DAVE_Init+0x1b8>)
 80277ce:	f7fe fcf3 	bl	80261b8 <TIMER_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80277d2:	2800      	cmp	r0, #0
 80277d4:	d1b3      	bne.n	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of USBD_VCOM APP instance USBD_VCOM_0 */
	 init_status = (DAVE_STATUS_t)USBD_VCOM_Init(&USBD_VCOM_0); 
 80277d6:	4846      	ldr	r0, [pc, #280]	; (80278f0 <DAVE_Init+0x1bc>)
 80277d8:	f7fd fd68 	bl	80252ac <USBD_VCOM_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80277dc:	2800      	cmp	r0, #0
 80277de:	d1ae      	bne.n	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_BGT_LDO_ENABLE */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_BGT_LDO_ENABLE); 
 80277e0:	4844      	ldr	r0, [pc, #272]	; (80278f4 <DAVE_Init+0x1c0>)
 80277e2:	f7ff fc49 	bl	8027078 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80277e6:	2800      	cmp	r0, #0
 80277e8:	d1a9      	bne.n	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_SPI_DATA_PGA */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_SPI_DATA_PGA); 
 80277ea:	4843      	ldr	r0, [pc, #268]	; (80278f8 <DAVE_Init+0x1c4>)
 80277ec:	f7ff fc44 	bl	8027078 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80277f0:	2800      	cmp	r0, #0
 80277f2:	d1a4      	bne.n	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_SPI_M_CS_PGA */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_SPI_M_CS_PGA); 
 80277f4:	4841      	ldr	r0, [pc, #260]	; (80278fc <DAVE_Init+0x1c8>)
 80277f6:	f7ff fc3f 	bl	8027078 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80277fa:	2800      	cmp	r0, #0
 80277fc:	d19f      	bne.n	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_PGA_LDO_ENABLE */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_PGA_LDO_ENABLE); 
 80277fe:	4840      	ldr	r0, [pc, #256]	; (8027900 <DAVE_Init+0x1cc>)
 8027800:	f7ff fc3a 	bl	8027078 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027804:	2800      	cmp	r0, #0
 8027806:	d19a      	bne.n	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of ADC_MEASUREMENT_ADV APP instance ADC_MEASUREMENT_ADV_G2 */
	 init_status = (DAVE_STATUS_t)ADC_MEASUREMENT_ADV_Init(&ADC_MEASUREMENT_ADV_G2); 
 8027808:	483e      	ldr	r0, [pc, #248]	; (8027904 <DAVE_Init+0x1d0>)
 802780a:	f7ff fd17 	bl	802723c <ADC_MEASUREMENT_ADV_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802780e:	2800      	cmp	r0, #0
 8027810:	d195      	bne.n	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of ADC_MEASUREMENT_ADV APP instance ADC_MEASUREMENT_ADV_G3 */
	 init_status = (DAVE_STATUS_t)ADC_MEASUREMENT_ADV_Init(&ADC_MEASUREMENT_ADV_G3); 
 8027812:	483d      	ldr	r0, [pc, #244]	; (8027908 <DAVE_Init+0x1d4>)
 8027814:	f7ff fd12 	bl	802723c <ADC_MEASUREMENT_ADV_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027818:	2800      	cmp	r0, #0
 802781a:	d190      	bne.n	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of ADC_MEASUREMENT_ADV APP instance ADC_MEASUREMENT_ADV_G4 */
	 init_status = (DAVE_STATUS_t)ADC_MEASUREMENT_ADV_Init(&ADC_MEASUREMENT_ADV_G4); 
 802781c:	483b      	ldr	r0, [pc, #236]	; (802790c <DAVE_Init+0x1d8>)
 802781e:	f7ff fd0d 	bl	802723c <ADC_MEASUREMENT_ADV_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027822:	2800      	cmp	r0, #0
 8027824:	d18b      	bne.n	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of DMA_CH APP instance DMA_CH_I1 */
	 init_status = (DAVE_STATUS_t)DMA_CH_Init(&DMA_CH_I1); 
 8027826:	483a      	ldr	r0, [pc, #232]	; (8027910 <DAVE_Init+0x1dc>)
 8027828:	f7ff fb92 	bl	8026f50 <DMA_CH_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802782c:	2800      	cmp	r0, #0
 802782e:	d186      	bne.n	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of DMA_CH APP instance DMA_CH_Q1 */
	 init_status = (DAVE_STATUS_t)DMA_CH_Init(&DMA_CH_Q1); 
 8027830:	4838      	ldr	r0, [pc, #224]	; (8027914 <DAVE_Init+0x1e0>)
 8027832:	f7ff fb8d 	bl	8026f50 <DMA_CH_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027836:	2800      	cmp	r0, #0
 8027838:	d181      	bne.n	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of DMA_CH APP instance DMA_CH_I2 */
	 init_status = (DAVE_STATUS_t)DMA_CH_Init(&DMA_CH_I2); 
 802783a:	4837      	ldr	r0, [pc, #220]	; (8027918 <DAVE_Init+0x1e4>)
 802783c:	f7ff fb88 	bl	8026f50 <DMA_CH_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027840:	2800      	cmp	r0, #0
 8027842:	f47f af7c 	bne.w	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of DMA_CH APP instance DMA_CH_Q2 */
	 init_status = (DAVE_STATUS_t)DMA_CH_Init(&DMA_CH_Q2); 
 8027846:	4835      	ldr	r0, [pc, #212]	; (802791c <DAVE_Init+0x1e8>)
 8027848:	f7ff fb82 	bl	8026f50 <DMA_CH_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802784c:	2800      	cmp	r0, #0
 802784e:	f47f af76 	bne.w	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of ADC_MEASUREMENT_ADV APP instance ADC_MEASUREMENT_SCAN */
	 init_status = (DAVE_STATUS_t)ADC_MEASUREMENT_ADV_Init(&ADC_MEASUREMENT_SCAN); 
 8027852:	4833      	ldr	r0, [pc, #204]	; (8027920 <DAVE_Init+0x1ec>)
 8027854:	f7ff fcf2 	bl	802723c <ADC_MEASUREMENT_ADV_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027858:	2800      	cmp	r0, #0
 802785a:	f47f af70 	bne.w	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of EVENT_DETECTOR APP instance EVENT_DETECTOR_PLL_TRIG1 */
	 init_status = (DAVE_STATUS_t)EVENT_DETECTOR_Init(&EVENT_DETECTOR_PLL_TRIG1); 
 802785e:	4831      	ldr	r0, [pc, #196]	; (8027924 <DAVE_Init+0x1f0>)
 8027860:	f7ff fb66 	bl	8026f30 <EVENT_DETECTOR_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027864:	2800      	cmp	r0, #0
 8027866:	f47f af6a 	bne.w	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of EVENT_GENERATOR APP instance EVENT_GENERATOR_CCU4 */
	 init_status = (DAVE_STATUS_t)EVENT_GENERATOR_Init(&EVENT_GENERATOR_CCU4); 
 802786a:	482f      	ldr	r0, [pc, #188]	; (8027928 <DAVE_Init+0x1f4>)
 802786c:	f7ff fb4e 	bl	8026f0c <EVENT_GENERATOR_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027870:	2800      	cmp	r0, #0
 8027872:	f47f af64 	bne.w	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of CCU4_SLICE_CONFIG APP instance CCU4_SLICE_CONFIG_ADC_TRIG */
	 init_status = (DAVE_STATUS_t)CCU4_SLICE_CONFIG_Init(&CCU4_SLICE_CONFIG_ADC_TRIG); 
 8027876:	482d      	ldr	r0, [pc, #180]	; (802792c <DAVE_Init+0x1f8>)
 8027878:	f7ff fc74 	bl	8027164 <CCU4_SLICE_CONFIG_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802787c:	2800      	cmp	r0, #0
 802787e:	f47f af5e 	bne.w	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_PLL_MUXIN */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_PLL_MUXIN); 
 8027882:	482b      	ldr	r0, [pc, #172]	; (8027930 <DAVE_Init+0x1fc>)
 8027884:	f7ff fbf8 	bl	8027078 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027888:	2800      	cmp	r0, #0
 802788a:	f47f af58 	bne.w	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_LED1 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_LED1); 
 802788e:	4829      	ldr	r0, [pc, #164]	; (8027934 <DAVE_Init+0x200>)
 8027890:	f7ff fbf2 	bl	8027078 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027894:	2800      	cmp	r0, #0
 8027896:	f47f af52 	bne.w	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of TIMER APP instance TIMER_WATCHDOG */
	 init_status = (DAVE_STATUS_t)TIMER_Init(&TIMER_WATCHDOG); 
 802789a:	4827      	ldr	r0, [pc, #156]	; (8027938 <DAVE_Init+0x204>)
 802789c:	f7fe fc8c 	bl	80261b8 <TIMER_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80278a0:	2800      	cmp	r0, #0
 80278a2:	f47f af4c 	bne.w	802773e <DAVE_Init+0xa>
  {
	 /**  Initialization of INTERRUPT APP instance INTERRUPT_WATCHDOG */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&INTERRUPT_WATCHDOG); 
 80278a6:	4825      	ldr	r0, [pc, #148]	; (802793c <DAVE_Init+0x208>)
   }  
  return init_status;
} /**  End of function DAVE_Init */
 80278a8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	 init_status = (DAVE_STATUS_t)TIMER_Init(&TIMER_WATCHDOG); 
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
  {
	 /**  Initialization of INTERRUPT APP instance INTERRUPT_WATCHDOG */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&INTERRUPT_WATCHDOG); 
 80278ac:	f7fe bfbc 	b.w	8026828 <INTERRUPT_Init>
 80278b0:	1fff1f88 	.word	0x1fff1f88
 80278b4:	0802b1b0 	.word	0x0802b1b0
 80278b8:	0802affc 	.word	0x0802affc
 80278bc:	0802aef8 	.word	0x0802aef8
 80278c0:	0802af70 	.word	0x0802af70
 80278c4:	0802af20 	.word	0x0802af20
 80278c8:	0802afac 	.word	0x0802afac
 80278cc:	0802af84 	.word	0x0802af84
 80278d0:	0802afe8 	.word	0x0802afe8
 80278d4:	0802af48 	.word	0x0802af48
 80278d8:	0802af5c 	.word	0x0802af5c
 80278dc:	1fff1f84 	.word	0x1fff1f84
 80278e0:	0802ae60 	.word	0x0802ae60
 80278e4:	1fff0f80 	.word	0x1fff0f80
 80278e8:	1ffe888c 	.word	0x1ffe888c
 80278ec:	1ffe890c 	.word	0x1ffe890c
 80278f0:	1fff0f38 	.word	0x1fff0f38
 80278f4:	0802aee4 	.word	0x0802aee4
 80278f8:	0802af0c 	.word	0x0802af0c
 80278fc:	0802af34 	.word	0x0802af34
 8027900:	0802afd4 	.word	0x0802afd4
 8027904:	0802b1cc 	.word	0x0802b1cc
 8027908:	0802b1e8 	.word	0x0802b1e8
 802790c:	0802b204 	.word	0x0802b204
 8027910:	1ffe8a74 	.word	0x1ffe8a74
 8027914:	1ffe89fc 	.word	0x1ffe89fc
 8027918:	1ffe8adc 	.word	0x1ffe8adc
 802791c:	1ffe8a0c 	.word	0x1ffe8a0c
 8027920:	0802b0c4 	.word	0x0802b0c4
 8027924:	1ffe89ec 	.word	0x1ffe89ec
 8027928:	1ffe89dc 	.word	0x1ffe89dc
 802792c:	0802b02c 	.word	0x0802b02c
 8027930:	0802af98 	.word	0x0802af98
 8027934:	0802afc0 	.word	0x0802afc0
 8027938:	1ffe88d0 	.word	0x1ffe88d0
 802793c:	0802ae5c 	.word	0x0802ae5c

08027940 <bgt_init>:
   3. EXPORTED FUNCTIONS
==============================================================================
 */

void bgt_init(uint32_t lna_gain, uint32_t power_level)
{
 8027940:	b538      	push	{r3, r4, r5, lr}
  /* Set the digital IOs used by SPI interface */
  bgt24mtr1x_spi_pins.spi_device    = BGT_DEVICE;
 8027942:	4b08      	ldr	r3, [pc, #32]	; (8027964 <bgt_init+0x24>)
  bgt24mtr1x_spi_pins.gpio_cs_pin   = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_BGT24;
 8027944:	4d08      	ldr	r5, [pc, #32]	; (8027968 <bgt_init+0x28>)
 8027946:	605d      	str	r5, [r3, #4]
  bgt24mtr1x_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_DATA;
 8027948:	4c08      	ldr	r4, [pc, #32]	; (802796c <bgt_init+0x2c>)
  bgt24mtr1x_spi_pins.gpio_clk_pin  = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;
 802794a:	4a09      	ldr	r2, [pc, #36]	; (8027970 <bgt_init+0x30>)
void bgt_init(uint32_t lna_gain, uint32_t power_level)
{
  /* Set the digital IOs used by SPI interface */
  bgt24mtr1x_spi_pins.spi_device    = BGT_DEVICE;
  bgt24mtr1x_spi_pins.gpio_cs_pin   = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_BGT24;
  bgt24mtr1x_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_DATA;
 802794c:	609c      	str	r4, [r3, #8]
 */

void bgt_init(uint32_t lna_gain, uint32_t power_level)
{
  /* Set the digital IOs used by SPI interface */
  bgt24mtr1x_spi_pins.spi_device    = BGT_DEVICE;
 802794e:	2500      	movs	r5, #0
  bgt24mtr1x_spi_pins.gpio_cs_pin   = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_BGT24;
  bgt24mtr1x_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_DATA;
  bgt24mtr1x_spi_pins.gpio_clk_pin  = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;
  
  bgt24mtr1x_init((Bgt24mtr1x_LNAgain_t)lna_gain, (Bgt24mtr1x_Power_t)power_level);
 8027950:	b2c0      	uxtb	r0, r0
 8027952:	b2c9      	uxtb	r1, r1
 */

void bgt_init(uint32_t lna_gain, uint32_t power_level)
{
  /* Set the digital IOs used by SPI interface */
  bgt24mtr1x_spi_pins.spi_device    = BGT_DEVICE;
 8027954:	701d      	strb	r5, [r3, #0]
  bgt24mtr1x_spi_pins.gpio_cs_pin   = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_BGT24;
  bgt24mtr1x_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_DATA;
  bgt24mtr1x_spi_pins.gpio_clk_pin  = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;
 8027956:	60da      	str	r2, [r3, #12]
  
  bgt24mtr1x_init((Bgt24mtr1x_LNAgain_t)lna_gain, (Bgt24mtr1x_Power_t)power_level);
 8027958:	f001 fc90 	bl	802927c <bgt24mtr1x_init>
  
  bgt24mtr1x_ana_vref_tx();
}
 802795c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  bgt24mtr1x_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_DATA;
  bgt24mtr1x_spi_pins.gpio_clk_pin  = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;
  
  bgt24mtr1x_init((Bgt24mtr1x_LNAgain_t)lna_gain, (Bgt24mtr1x_Power_t)power_level);
  
  bgt24mtr1x_ana_vref_tx();
 8027960:	f001 bdd2 	b.w	8029508 <bgt24mtr1x_ana_vref_tx>
 8027964:	1fff1f8c 	.word	0x1fff1f8c
 8027968:	0802afac 	.word	0x0802afac
 802796c:	0802afe8 	.word	0x0802afe8
 8027970:	0802af20 	.word	0x0802af20

08027974 <bgt_start_tx>:

//============================================================================

void bgt_start_tx(void)
{
  bgt24mtr1x_start_tx();
 8027974:	f001 bcfc 	b.w	8029370 <bgt24mtr1x_start_tx>

08027978 <bgt_stop_tx>:

//============================================================================

void bgt_stop_tx(void)
{
  bgt24mtr1x_stop_tx();
 8027978:	f001 bd16 	b.w	80293a8 <bgt24mtr1x_stop_tx>

0802797c <bgt_power_up>:
}

//============================================================================

void bgt_power_up(void)
{
 802797c:	b430      	push	{r4, r5}
 802797e:	4a07      	ldr	r2, [pc, #28]	; (802799c <bgt_power_up+0x20>)
 8027980:	4b07      	ldr	r3, [pc, #28]	; (80279a0 <bgt_power_up+0x24>)

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 8027982:	7c15      	ldrb	r5, [r2, #16]

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 8027984:	7c1c      	ldrb	r4, [r3, #16]
 8027986:	6810      	ldr	r0, [r2, #0]
 8027988:	6819      	ldr	r1, [r3, #0]

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 802798a:	2201      	movs	r2, #1

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 802798c:	f44f 3380 	mov.w	r3, #65536	; 0x10000

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 8027990:	40aa      	lsls	r2, r5

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 8027992:	40a3      	lsls	r3, r4

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 8027994:	6042      	str	r2, [r0, #4]
  /* Before turning on BGT, we should keep CE pin high.
   * CE pin is active low, so it should keep high until it is activated.
   */
  DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_SPI_M_CS_BGT24);
  DIGITAL_IO_SetOutputLow(&DIGITAL_IO_BGT_POWER_ENABLE);
}
 8027996:	bc30      	pop	{r4, r5}

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 8027998:	604b      	str	r3, [r1, #4]
 802799a:	4770      	bx	lr
 802799c:	0802afac 	.word	0x0802afac
 80279a0:	0802affc 	.word	0x0802affc

080279a4 <bgt_power_down>:

//============================================================================

void bgt_power_down(void)
{
 80279a4:	b4f0      	push	{r4, r5, r6, r7}
 80279a6:	490a      	ldr	r1, [pc, #40]	; (80279d0 <bgt_power_down+0x2c>)
 80279a8:	4a0a      	ldr	r2, [pc, #40]	; (80279d4 <bgt_power_down+0x30>)
 80279aa:	4b0b      	ldr	r3, [pc, #44]	; (80279d8 <bgt_power_down+0x34>)

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 80279ac:	7c0f      	ldrb	r7, [r1, #16]

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 80279ae:	7c1e      	ldrb	r6, [r3, #16]
 80279b0:	7c14      	ldrb	r4, [r2, #16]
 80279b2:	680d      	ldr	r5, [r1, #0]
 80279b4:	6810      	ldr	r0, [r2, #0]
 80279b6:	6819      	ldr	r1, [r3, #0]

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 80279b8:	2201      	movs	r2, #1

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 80279ba:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80279be:	fa03 f404 	lsl.w	r4, r3, r4

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 80279c2:	40ba      	lsls	r2, r7

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 80279c4:	40b3      	lsls	r3, r6

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 80279c6:	606a      	str	r2, [r5, #4]

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 80279c8:	6044      	str	r4, [r0, #4]
 80279ca:	604b      	str	r3, [r1, #4]
   * It makes offset voltage at BGT's VCC.
   */
  DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_BGT_POWER_ENABLE);
  DIGITAL_IO_SetOutputLow(&DIGITAL_IO_SPI_M_CS_BGT24);
  DIGITAL_IO_SetOutputLow(&DIGITAL_IO_SPI_M_DATA);
}
 80279cc:	bcf0      	pop	{r4, r5, r6, r7}
 80279ce:	4770      	bx	lr
 80279d0:	0802affc 	.word	0x0802affc
 80279d4:	0802afac 	.word	0x0802afac
 80279d8:	0802afe8 	.word	0x0802afe8

080279dc <bgt_set_tx_power>:

//============================================================================

void bgt_set_tx_power(uint8_t power_level)
{
  bgt24mtr1x_set_tx_power((Bgt24mtr1x_Power_t)power_level);
 80279dc:	f001 bd00 	b.w	80293e0 <bgt24mtr1x_set_tx_power>

080279e0 <bgt_lna_gain_enable>:

//============================================================================

void bgt_lna_gain_enable(void)
{
  bgt24mtr1x_lna_gain_enable();
 80279e0:	f001 bd48 	b.w	8029474 <bgt24mtr1x_lna_gain_enable>

080279e4 <bgt_lna_gain_disable>:

//============================================================================

void bgt_lna_gain_disable(void)
{
  bgt24mtr1x_lna_gain_disable();
 80279e4:	f001 bd4e 	b.w	8029484 <bgt24mtr1x_lna_gain_disable>

080279e8 <bgt_ana_temp>:

//============================================================================

void bgt_ana_temp(void)
{
  bgt24mtr1x_ana_temp();
 80279e8:	f001 bd6a 	b.w	80294c0 <bgt24mtr1x_ana_temp>

080279ec <bgt_ana_vout_tx>:

//============================================================================

void bgt_ana_vout_tx(void)
{
  bgt24mtr1x_ana_vout_tx();
 80279ec:	f001 bd7c 	b.w	80294e8 <bgt24mtr1x_ana_vout_tx>

080279f0 <bgt_ana_vref_tx>:

//============================================================================

void bgt_ana_vref_tx(void)
{
  bgt24mtr1x_ana_vref_tx();
 80279f0:	f001 bd8a 	b.w	8029508 <bgt24mtr1x_ana_vref_tx>

080279f4 <bgt_get_ana_config>:

//============================================================================

uint16_t bgt_get_ana_config(void)
{
  return bgt24mtr1x_get_ana_config();
 80279f4:	f001 bd9c 	b.w	8029530 <bgt24mtr1x_get_ana_config>

080279f8 <bgt_lowest_power_with_q2_disable>:

//============================================================================

void bgt_lowest_power_with_q2_disable(void)
{
  bgt24mtr1x_set_config((uint16_t)BGT24MTR1X_POWER_CONF);
 80279f8:	f241 0047 	movw	r0, #4167	; 0x1047
 80279fc:	f001 bd4e 	b.w	802949c <bgt24mtr1x_set_config>

08027a00 <bgt_ldo_enable>:
}

//============================================================================

void bgt_ldo_enable(void)
{
 8027a00:	4b03      	ldr	r3, [pc, #12]	; (8027a10 <bgt_ldo_enable+0x10>)

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 8027a02:	7c19      	ldrb	r1, [r3, #16]
 8027a04:	681a      	ldr	r2, [r3, #0]
 8027a06:	2301      	movs	r3, #1
 8027a08:	408b      	lsls	r3, r1
 8027a0a:	6053      	str	r3, [r2, #4]
 8027a0c:	4770      	bx	lr
 8027a0e:	bf00      	nop
 8027a10:	0802aee4 	.word	0x0802aee4

08027a14 <bsp_init>:
   4. EXPORTED FUNCTIONS
==============================================================================
 */

uint8_t bsp_init(void)
{
 8027a14:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  pDMA_src_Q1 = (uint32_t*)&ADC_MEASUREMENT_ADV_G1_IF1_I_RES;
  pDMA_src_I2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G4_IF2_Q_RES;
  pDMA_src_Q2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G3_IF2_I_RES;
  
  /* Set the source address pointers for each DMA transfer */
  XMC_DMA_CH_SetSourceAddress(DMA_CH_I1.dma_global->dma, DMA_CH_I1.ch_num, (uint32_t)pDMA_src_I1);
 8027a18:	4fa3      	ldr	r7, [pc, #652]	; (8027ca8 <bsp_init+0x294>)
//============================================================================

void bsp_dma_set_source_addr(void)
{
  /* DMA Source/Destination Address setup */
  pDMA_src_I1 = (uint32_t*)&ADC_MEASUREMENT_ADV_G2_IF1_Q_RES;
 8027a1a:	4ba4      	ldr	r3, [pc, #656]	; (8027cac <bsp_init+0x298>)
  pDMA_src_Q1 = (uint32_t*)&ADC_MEASUREMENT_ADV_G1_IF1_I_RES;
  pDMA_src_I2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G4_IF2_Q_RES;
  pDMA_src_Q2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G3_IF2_I_RES;
  
  /* Set the source address pointers for each DMA transfer */
  XMC_DMA_CH_SetSourceAddress(DMA_CH_I1.dma_global->dma, DMA_CH_I1.ch_num, (uint32_t)pDMA_src_I1);
 8027a1c:	6839      	ldr	r1, [r7, #0]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetDestinationAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetSourceAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].SAR = addr;
 8027a1e:	7b3a      	ldrb	r2, [r7, #12]
 8027a20:	6808      	ldr	r0, [r1, #0]
//============================================================================

void bsp_dma_set_source_addr(void)
{
  /* DMA Source/Destination Address setup */
  pDMA_src_I1 = (uint32_t*)&ADC_MEASUREMENT_ADV_G2_IF1_Q_RES;
 8027a22:	49a3      	ldr	r1, [pc, #652]	; (8027cb0 <bsp_init+0x29c>)
 8027a24:	6019      	str	r1, [r3, #0]
 8027a26:	2358      	movs	r3, #88	; 0x58
 8027a28:	fb03 f202 	mul.w	r2, r3, r2
  pDMA_src_Q1 = (uint32_t*)&ADC_MEASUREMENT_ADV_G1_IF1_I_RES;
 8027a2c:	4ea1      	ldr	r6, [pc, #644]	; (8027cb4 <bsp_init+0x2a0>)
  pDMA_src_I2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G4_IF2_Q_RES;
 8027a2e:	4da2      	ldr	r5, [pc, #648]	; (8027cb8 <bsp_init+0x2a4>)
  pDMA_src_Q2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G3_IF2_I_RES;
 8027a30:	4ca2      	ldr	r4, [pc, #648]	; (8027cbc <bsp_init+0x2a8>)
void bsp_dma_set_source_addr(void)
{
  /* DMA Source/Destination Address setup */
  pDMA_src_I1 = (uint32_t*)&ADC_MEASUREMENT_ADV_G2_IF1_Q_RES;
  pDMA_src_Q1 = (uint32_t*)&ADC_MEASUREMENT_ADV_G1_IF1_I_RES;
  pDMA_src_I2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G4_IF2_Q_RES;
 8027a32:	f8df c2a8 	ldr.w	ip, [pc, #680]	; 8027cdc <bsp_init+0x2c8>
  pDMA_src_Q2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G3_IF2_I_RES;
 8027a36:	f8df e2a8 	ldr.w	lr, [pc, #680]	; 8027ce0 <bsp_init+0x2cc>

void bsp_dma_set_source_addr(void)
{
  /* DMA Source/Destination Address setup */
  pDMA_src_I1 = (uint32_t*)&ADC_MEASUREMENT_ADV_G2_IF1_Q_RES;
  pDMA_src_Q1 = (uint32_t*)&ADC_MEASUREMENT_ADV_G1_IF1_I_RES;
 8027a3a:	f8df 82a8 	ldr.w	r8, [pc, #680]	; 8027ce4 <bsp_init+0x2d0>
  pDMA_src_I2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G4_IF2_Q_RES;
 8027a3e:	f8c5 c000 	str.w	ip, [r5]
  pDMA_src_Q2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G3_IF2_I_RES;
 8027a42:	f8c4 e000 	str.w	lr, [r4]

void bsp_dma_set_source_addr(void)
{
  /* DMA Source/Destination Address setup */
  pDMA_src_I1 = (uint32_t*)&ADC_MEASUREMENT_ADV_G2_IF1_Q_RES;
  pDMA_src_Q1 = (uint32_t*)&ADC_MEASUREMENT_ADV_G1_IF1_I_RES;
 8027a46:	f8c6 8000 	str.w	r8, [r6]
 8027a4a:	5081      	str	r1, [r0, r2]
  pDMA_src_I2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G4_IF2_Q_RES;
  pDMA_src_Q2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G3_IF2_I_RES;
  
  /* Set the source address pointers for each DMA transfer */
  XMC_DMA_CH_SetSourceAddress(DMA_CH_I1.dma_global->dma, DMA_CH_I1.ch_num, (uint32_t)pDMA_src_I1);
  XMC_DMA_CH_SetSourceAddress(DMA_CH_Q1.dma_global->dma, DMA_CH_Q1.ch_num, (uint32_t)pDMA_src_Q1);
 8027a4c:	4e9c      	ldr	r6, [pc, #624]	; (8027cc0 <bsp_init+0x2ac>)
  XMC_DMA_CH_SetSourceAddress(DMA_CH_I2.dma_global->dma, DMA_CH_I2.ch_num, (uint32_t)pDMA_src_I2);
 8027a4e:	4d9d      	ldr	r5, [pc, #628]	; (8027cc4 <bsp_init+0x2b0>)
  pDMA_src_I2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G4_IF2_Q_RES;
  pDMA_src_Q2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G3_IF2_I_RES;
  
  /* Set the source address pointers for each DMA transfer */
  XMC_DMA_CH_SetSourceAddress(DMA_CH_I1.dma_global->dma, DMA_CH_I1.ch_num, (uint32_t)pDMA_src_I1);
  XMC_DMA_CH_SetSourceAddress(DMA_CH_Q1.dma_global->dma, DMA_CH_Q1.ch_num, (uint32_t)pDMA_src_Q1);
 8027a50:	6831      	ldr	r1, [r6, #0]
 8027a52:	7b32      	ldrb	r2, [r6, #12]
  XMC_DMA_CH_SetSourceAddress(DMA_CH_I2.dma_global->dma, DMA_CH_I2.ch_num, (uint32_t)pDMA_src_I2);
  XMC_DMA_CH_SetSourceAddress(DMA_CH_Q2.dma_global->dma, DMA_CH_Q2.ch_num, (uint32_t)pDMA_src_Q2);
 8027a54:	4c9c      	ldr	r4, [pc, #624]	; (8027cc8 <bsp_init+0x2b4>)
  pDMA_src_I2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G4_IF2_Q_RES;
  pDMA_src_Q2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G3_IF2_I_RES;
  
  /* Set the source address pointers for each DMA transfer */
  XMC_DMA_CH_SetSourceAddress(DMA_CH_I1.dma_global->dma, DMA_CH_I1.ch_num, (uint32_t)pDMA_src_I1);
  XMC_DMA_CH_SetSourceAddress(DMA_CH_Q1.dma_global->dma, DMA_CH_Q1.ch_num, (uint32_t)pDMA_src_Q1);
 8027a56:	f8d1 9000 	ldr.w	r9, [r1]
  XMC_DMA_CH_SetSourceAddress(DMA_CH_I2.dma_global->dma, DMA_CH_I2.ch_num, (uint32_t)pDMA_src_I2);
 8027a5a:	6828      	ldr	r0, [r5, #0]
  XMC_DMA_CH_SetSourceAddress(DMA_CH_Q2.dma_global->dma, DMA_CH_Q2.ch_num, (uint32_t)pDMA_src_Q2);
 8027a5c:	6821      	ldr	r1, [r4, #0]
  pDMA_src_Q2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G3_IF2_I_RES;
  
  /* Set the source address pointers for each DMA transfer */
  XMC_DMA_CH_SetSourceAddress(DMA_CH_I1.dma_global->dma, DMA_CH_I1.ch_num, (uint32_t)pDMA_src_I1);
  XMC_DMA_CH_SetSourceAddress(DMA_CH_Q1.dma_global->dma, DMA_CH_Q1.ch_num, (uint32_t)pDMA_src_Q1);
  XMC_DMA_CH_SetSourceAddress(DMA_CH_I2.dma_global->dma, DMA_CH_I2.ch_num, (uint32_t)pDMA_src_I2);
 8027a5e:	6800      	ldr	r0, [r0, #0]
  XMC_DMA_CH_SetSourceAddress(DMA_CH_Q2.dma_global->dma, DMA_CH_Q2.ch_num, (uint32_t)pDMA_src_Q2);
 8027a60:	6809      	ldr	r1, [r1, #0]
uint8_t bsp_init(void)
{
  Pga_Status_t status;
  
  /* Set all data acquisition functions callback to NULL */
  bsp_cb.bsp_acq_started_cb = NULL;
 8027a62:	f8df a284 	ldr.w	sl, [pc, #644]	; 8027ce8 <bsp_init+0x2d4>
 8027a66:	fb03 f202 	mul.w	r2, r3, r2
 8027a6a:	f04f 0b00 	mov.w	fp, #0
 8027a6e:	f849 8002 	str.w	r8, [r9, r2]
 8027a72:	7b2a      	ldrb	r2, [r5, #12]
 8027a74:	f8ca b000 	str.w	fp, [sl]
 8027a78:	fb03 f202 	mul.w	r2, r3, r2
  bsp_cb.bsp_acq_done_cb = NULL;
 8027a7c:	f8ca b004 	str.w	fp, [sl, #4]
 8027a80:	f840 c002 	str.w	ip, [r0, r2]
 8027a84:	7b22      	ldrb	r2, [r4, #12]
 8027a86:	fb03 f302 	mul.w	r3, r3, r2
 8027a8a:	f841 e003 	str.w	lr, [r1, r3]
  
  /* Set memory sections to DMA source pointers */
  bsp_dma_set_source_addr();
  
  /* Enable LDO for BGT */
  bgt_ldo_enable();
 8027a8e:	f7ff ffb7 	bl	8027a00 <bgt_ldo_enable>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 8027a92:	488e      	ldr	r0, [pc, #568]	; (8027ccc <bsp_init+0x2b8>)
 8027a94:	f7fe fd1e 	bl	80264d4 <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 8027a98:	488c      	ldr	r0, [pc, #560]	; (8027ccc <bsp_init+0x2b8>)
 8027a9a:	498d      	ldr	r1, [pc, #564]	; (8027cd0 <bsp_init+0x2bc>)
 8027a9c:	f7fe fc58 	bl	8026350 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8027aa0:	488a      	ldr	r0, [pc, #552]	; (8027ccc <bsp_init+0x2b8>)
 8027aa2:	f7fe fc0b 	bl	80262bc <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 8027aa6:	4889      	ldr	r0, [pc, #548]	; (8027ccc <bsp_init+0x2b8>)
 8027aa8:	f7fe fd02 	bl	80264b0 <TIMER_GetInterruptStatus>
 8027aac:	2800      	cmp	r0, #0
 8027aae:	d0fa      	beq.n	8027aa6 <bsp_init+0x92>
  
  TIMER_Stop(&TIMER_DELAY);
 8027ab0:	4886      	ldr	r0, [pc, #536]	; (8027ccc <bsp_init+0x2b8>)
 8027ab2:	f7fe fc19 	bl	80262e8 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 8027ab6:	4885      	ldr	r0, [pc, #532]	; (8027ccc <bsp_init+0x2b8>)
 8027ab8:	f7fe fd22 	bl	8026500 <TIMER_Clear>
  /* Enable LDO for BGT */
  bgt_ldo_enable();
  bsp_time_delay_usec(1000U);
  
  /* Enable LDO for PGA */
  pga_ldo_enable();
 8027abc:	f000 fcf2 	bl	80284a4 <pga_ldo_enable>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 8027ac0:	4882      	ldr	r0, [pc, #520]	; (8027ccc <bsp_init+0x2b8>)
 8027ac2:	f7fe fd07 	bl	80264d4 <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 8027ac6:	4881      	ldr	r0, [pc, #516]	; (8027ccc <bsp_init+0x2b8>)
 8027ac8:	4981      	ldr	r1, [pc, #516]	; (8027cd0 <bsp_init+0x2bc>)
 8027aca:	f7fe fc41 	bl	8026350 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8027ace:	487f      	ldr	r0, [pc, #508]	; (8027ccc <bsp_init+0x2b8>)
 8027ad0:	f7fe fbf4 	bl	80262bc <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 8027ad4:	487d      	ldr	r0, [pc, #500]	; (8027ccc <bsp_init+0x2b8>)
 8027ad6:	f7fe fceb 	bl	80264b0 <TIMER_GetInterruptStatus>
 8027ada:	2800      	cmp	r0, #0
 8027adc:	d0fa      	beq.n	8027ad4 <bsp_init+0xc0>
  
  TIMER_Stop(&TIMER_DELAY);
 8027ade:	487b      	ldr	r0, [pc, #492]	; (8027ccc <bsp_init+0x2b8>)
 8027ae0:	f7fe fc02 	bl	80262e8 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 8027ae4:	4879      	ldr	r0, [pc, #484]	; (8027ccc <bsp_init+0x2b8>)
 8027ae6:	f7fe fd0b 	bl	8026500 <TIMER_Clear>
  /* Enable LDO for PGA */
  pga_ldo_enable();
  bsp_time_delay_usec(1000U);
  
  /* Power-up BGT */
  bgt_power_up();
 8027aea:	f7ff ff47 	bl	802797c <bgt_power_up>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 8027aee:	4877      	ldr	r0, [pc, #476]	; (8027ccc <bsp_init+0x2b8>)
 8027af0:	f7fe fcf0 	bl	80264d4 <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 8027af4:	4875      	ldr	r0, [pc, #468]	; (8027ccc <bsp_init+0x2b8>)
 8027af6:	f242 7110 	movw	r1, #10000	; 0x2710
 8027afa:	f7fe fc29 	bl	8026350 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8027afe:	4873      	ldr	r0, [pc, #460]	; (8027ccc <bsp_init+0x2b8>)
 8027b00:	f7fe fbdc 	bl	80262bc <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 8027b04:	4871      	ldr	r0, [pc, #452]	; (8027ccc <bsp_init+0x2b8>)
 8027b06:	f7fe fcd3 	bl	80264b0 <TIMER_GetInterruptStatus>
 8027b0a:	2800      	cmp	r0, #0
 8027b0c:	d0fa      	beq.n	8027b04 <bsp_init+0xf0>
  
  TIMER_Stop(&TIMER_DELAY);
 8027b0e:	486f      	ldr	r0, [pc, #444]	; (8027ccc <bsp_init+0x2b8>)
 8027b10:	f7fe fbea 	bl	80262e8 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 8027b14:	486d      	ldr	r0, [pc, #436]	; (8027ccc <bsp_init+0x2b8>)
 8027b16:	f7fe fcf3 	bl	8026500 <TIMER_Clear>
  
  /* Power-up BGT */
  bgt_power_up();
  bsp_time_delay_usec(100U); /* Delay for BGT power-up */
  
  bgt_lowest_power_with_q2_disable(); /* To avoid out of band spurs */
 8027b1a:	f7ff ff6d 	bl	80279f8 <bgt_lowest_power_with_q2_disable>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 8027b1e:	486b      	ldr	r0, [pc, #428]	; (8027ccc <bsp_init+0x2b8>)
 8027b20:	f7fe fcd8 	bl	80264d4 <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 8027b24:	4869      	ldr	r0, [pc, #420]	; (8027ccc <bsp_init+0x2b8>)
 8027b26:	f241 3188 	movw	r1, #5000	; 0x1388
 8027b2a:	f7fe fc11 	bl	8026350 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8027b2e:	4867      	ldr	r0, [pc, #412]	; (8027ccc <bsp_init+0x2b8>)
 8027b30:	f7fe fbc4 	bl	80262bc <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 8027b34:	4865      	ldr	r0, [pc, #404]	; (8027ccc <bsp_init+0x2b8>)
 8027b36:	f7fe fcbb 	bl	80264b0 <TIMER_GetInterruptStatus>
 8027b3a:	2800      	cmp	r0, #0
 8027b3c:	d0fa      	beq.n	8027b34 <bsp_init+0x120>
  
  TIMER_Stop(&TIMER_DELAY);
 8027b3e:	4863      	ldr	r0, [pc, #396]	; (8027ccc <bsp_init+0x2b8>)
 8027b40:	f7fe fbd2 	bl	80262e8 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 8027b44:	4861      	ldr	r0, [pc, #388]	; (8027ccc <bsp_init+0x2b8>)
 8027b46:	f7fe fcdb 	bl	8026500 <TIMER_Clear>
  
  bgt_lowest_power_with_q2_disable(); /* To avoid out of band spurs */
  bsp_time_delay_usec(50U); /* Delay for BGT Power down SPI settings */
  
  /* Enable PLL power supply */
  pll_power_up();
 8027b4a:	f000 fe19 	bl	8028780 <pll_power_up>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 8027b4e:	485f      	ldr	r0, [pc, #380]	; (8027ccc <bsp_init+0x2b8>)
 8027b50:	f7fe fcc0 	bl	80264d4 <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 8027b54:	485d      	ldr	r0, [pc, #372]	; (8027ccc <bsp_init+0x2b8>)
 8027b56:	f242 7110 	movw	r1, #10000	; 0x2710
 8027b5a:	f7fe fbf9 	bl	8026350 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8027b5e:	485b      	ldr	r0, [pc, #364]	; (8027ccc <bsp_init+0x2b8>)
 8027b60:	f7fe fbac 	bl	80262bc <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 8027b64:	4859      	ldr	r0, [pc, #356]	; (8027ccc <bsp_init+0x2b8>)
 8027b66:	f7fe fca3 	bl	80264b0 <TIMER_GetInterruptStatus>
 8027b6a:	2800      	cmp	r0, #0
 8027b6c:	d0fa      	beq.n	8027b64 <bsp_init+0x150>
  
  TIMER_Stop(&TIMER_DELAY);
 8027b6e:	4857      	ldr	r0, [pc, #348]	; (8027ccc <bsp_init+0x2b8>)
  
  /* Initialize BGT */
  bgt_init(LNA_GAIN_ENABLE, BGT_TX_POWER);
  
  /* Initialize PLL */
  pll_init(pll_handle);
 8027b70:	f8df 8178 	ldr.w	r8, [pc, #376]	; 8027cec <bsp_init+0x2d8>
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
  
  TIMER_Stop(&TIMER_DELAY);
 8027b74:	f7fe fbb8 	bl	80262e8 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 8027b78:	4854      	ldr	r0, [pc, #336]	; (8027ccc <bsp_init+0x2b8>)
 8027b7a:	f7fe fcc1 	bl	8026500 <TIMER_Clear>
  /* Enable PLL power supply */
  pll_power_up();
  bsp_time_delay_usec(100U); /* Delay for PLL power-up */
  
  /* Initialize BGT */
  bgt_init(LNA_GAIN_ENABLE, BGT_TX_POWER);
 8027b7e:	2107      	movs	r1, #7
 8027b80:	2001      	movs	r0, #1
 8027b82:	f7ff fedd 	bl	8027940 <bgt_init>
  
  /* Initialize PLL */
  pll_init(pll_handle);
 8027b86:	f8d8 0000 	ldr.w	r0, [r8]
 8027b8a:	f000 fca1 	bl	80284d0 <pll_init>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 8027b8e:	484f      	ldr	r0, [pc, #316]	; (8027ccc <bsp_init+0x2b8>)
 8027b90:	f7fe fca0 	bl	80264d4 <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 8027b94:	484d      	ldr	r0, [pc, #308]	; (8027ccc <bsp_init+0x2b8>)
 8027b96:	f242 7110 	movw	r1, #10000	; 0x2710
 8027b9a:	f7fe fbd9 	bl	8026350 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8027b9e:	484b      	ldr	r0, [pc, #300]	; (8027ccc <bsp_init+0x2b8>)
 8027ba0:	f7fe fb8c 	bl	80262bc <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 8027ba4:	4849      	ldr	r0, [pc, #292]	; (8027ccc <bsp_init+0x2b8>)
 8027ba6:	f7fe fc83 	bl	80264b0 <TIMER_GetInterruptStatus>
 8027baa:	2800      	cmp	r0, #0
 8027bac:	d0fa      	beq.n	8027ba4 <bsp_init+0x190>
  
  TIMER_Stop(&TIMER_DELAY);
 8027bae:	4847      	ldr	r0, [pc, #284]	; (8027ccc <bsp_init+0x2b8>)
 8027bb0:	f7fe fb9a 	bl	80262e8 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 8027bb4:	4845      	ldr	r0, [pc, #276]	; (8027ccc <bsp_init+0x2b8>)
 8027bb6:	f7fe fca3 	bl	8026500 <TIMER_Clear>
  /* Update PLL configuration */
#if (FW_MODULATION_TYPE == 0U) /* Doppler modulation */
  pll_update_configuration(pll_handle, DOPPLER_MODULATION);
  
#elif (FW_MODULATION_TYPE == 1U) /* FMCW modulation */
  pll_update_configuration(pll_handle, FMCW_MODULATION);
 8027bba:	2101      	movs	r1, #1
 8027bbc:	f8d8 0000 	ldr.w	r0, [r8]
 8027bc0:	f000 fde2 	bl	8028788 <pll_update_configuration>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 8027bc4:	4841      	ldr	r0, [pc, #260]	; (8027ccc <bsp_init+0x2b8>)
 8027bc6:	f7fe fc85 	bl	80264d4 <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 8027bca:	4840      	ldr	r0, [pc, #256]	; (8027ccc <bsp_init+0x2b8>)
 8027bcc:	f242 7110 	movw	r1, #10000	; 0x2710
 8027bd0:	f7fe fbbe 	bl	8026350 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8027bd4:	483d      	ldr	r0, [pc, #244]	; (8027ccc <bsp_init+0x2b8>)
 8027bd6:	f7fe fb71 	bl	80262bc <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 8027bda:	483c      	ldr	r0, [pc, #240]	; (8027ccc <bsp_init+0x2b8>)
 8027bdc:	f7fe fc68 	bl	80264b0 <TIMER_GetInterruptStatus>
 8027be0:	2800      	cmp	r0, #0
 8027be2:	d0fa      	beq.n	8027bda <bsp_init+0x1c6>
  
  TIMER_Stop(&TIMER_DELAY);
 8027be4:	4839      	ldr	r0, [pc, #228]	; (8027ccc <bsp_init+0x2b8>)
 8027be6:	f7fe fb7f 	bl	80262e8 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 8027bea:	4838      	ldr	r0, [pc, #224]	; (8027ccc <bsp_init+0x2b8>)
 8027bec:	f7fe fc88 	bl	8026500 <TIMER_Clear>
#endif
  
  bsp_time_delay_usec(100U);
  
  /* Initialize PGA and set its gain */
  status = pga_init(PGA_GAIN);
 8027bf0:	2004      	movs	r0, #4
 8027bf2:	f000 fc53 	bl	802849c <pga_init>
 8027bf6:	4681      	mov	r9, r0

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 8027bf8:	4834      	ldr	r0, [pc, #208]	; (8027ccc <bsp_init+0x2b8>)
 8027bfa:	f7fe fc6b 	bl	80264d4 <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 8027bfe:	4833      	ldr	r0, [pc, #204]	; (8027ccc <bsp_init+0x2b8>)
 8027c00:	f241 3188 	movw	r1, #5000	; 0x1388
 8027c04:	f7fe fba4 	bl	8026350 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8027c08:	4830      	ldr	r0, [pc, #192]	; (8027ccc <bsp_init+0x2b8>)
 8027c0a:	f7fe fb57 	bl	80262bc <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 8027c0e:	482f      	ldr	r0, [pc, #188]	; (8027ccc <bsp_init+0x2b8>)
 8027c10:	f7fe fc4e 	bl	80264b0 <TIMER_GetInterruptStatus>
 8027c14:	2800      	cmp	r0, #0
 8027c16:	d0fa      	beq.n	8027c0e <bsp_init+0x1fa>
  
  TIMER_Stop(&TIMER_DELAY);
 8027c18:	482c      	ldr	r0, [pc, #176]	; (8027ccc <bsp_init+0x2b8>)
 8027c1a:	f7fe fb65 	bl	80262e8 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 8027c1e:	482b      	ldr	r0, [pc, #172]	; (8027ccc <bsp_init+0x2b8>)
 8027c20:	f7fe fc6e 	bl	8026500 <TIMER_Clear>
 */
__STATIC_INLINE void DMA_CH_Disable(DMA_CH_t *const obj)
{
  XMC_ASSERT("DMA_CH_Disable: NULL DMA_CH_t object", (obj != NULL));

  XMC_DMA_CH_Disable(obj->dma_global->dma, obj->ch_num);
 8027c24:	683b      	ldr	r3, [r7, #0]
 8027c26:	7b39      	ldrb	r1, [r7, #12]
 8027c28:	6818      	ldr	r0, [r3, #0]
 8027c2a:	f7fa f815 	bl	8021c58 <XMC_DMA_CH_Disable>
 8027c2e:	6833      	ldr	r3, [r6, #0]
 8027c30:	7b31      	ldrb	r1, [r6, #12]
 8027c32:	6818      	ldr	r0, [r3, #0]
 8027c34:	f7fa f810 	bl	8021c58 <XMC_DMA_CH_Disable>
 8027c38:	682b      	ldr	r3, [r5, #0]
 8027c3a:	7b29      	ldrb	r1, [r5, #12]
 8027c3c:	6818      	ldr	r0, [r3, #0]
 8027c3e:	f7fa f80b 	bl	8021c58 <XMC_DMA_CH_Disable>
 8027c42:	6823      	ldr	r3, [r4, #0]
 8027c44:	7b21      	ldrb	r1, [r4, #12]
 8027c46:	6818      	ldr	r0, [r3, #0]
 8027c48:	f7fa f806 	bl	8021c58 <XMC_DMA_CH_Disable>
  
  /* Disable DMA */
  dma_disable();
  
  /* Check if duty cycle is enabled */
  if(bsp_duty_cycle_enable == ENABLED)
 8027c4c:	4b21      	ldr	r3, [pc, #132]	; (8027cd4 <bsp_init+0x2c0>)
 8027c4e:	781b      	ldrb	r3, [r3, #0]
 8027c50:	2b01      	cmp	r3, #1
 8027c52:	d007      	beq.n	8027c64 <bsp_init+0x250>
  {
    bsp_components_power_down();
  }
  else	/* duty cycle disabled */
  {
    bgt_start_tx();
 8027c54:	f7ff fe8e 	bl	8027974 <bgt_start_tx>

//============================================================================

void bsp_reset_frame_counter(void)
{
  bsp_frame_counter = 0;
 8027c58:	4b1f      	ldr	r3, [pc, #124]	; (8027cd8 <bsp_init+0x2c4>)
 8027c5a:	2200      	movs	r2, #0
  
  /* Reset the current frame counter */
  bsp_reset_frame_counter();
  
  return (status);
}
 8027c5c:	4648      	mov	r0, r9

//============================================================================

void bsp_reset_frame_counter(void)
{
  bsp_frame_counter = 0;
 8027c5e:	801a      	strh	r2, [r3, #0]
  
  /* Reset the current frame counter */
  bsp_reset_frame_counter();
  
  return (status);
}
 8027c60:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

//============================================================================

void bsp_components_power_down(void)
{
  pll_disable_ramps(pll_handle);
 8027c64:	f8d8 0000 	ldr.w	r0, [r8]
 8027c68:	f000 fd82 	bl	8028770 <pll_disable_ramps>
  
  /* To avoid out of band spurs */
  bgt_lowest_power_with_q2_disable();
 8027c6c:	f7ff fec4 	bl	80279f8 <bgt_lowest_power_with_q2_disable>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 8027c70:	4816      	ldr	r0, [pc, #88]	; (8027ccc <bsp_init+0x2b8>)
 8027c72:	f7fe fc2f 	bl	80264d4 <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 8027c76:	4815      	ldr	r0, [pc, #84]	; (8027ccc <bsp_init+0x2b8>)
 8027c78:	f241 3188 	movw	r1, #5000	; 0x1388
 8027c7c:	f7fe fb68 	bl	8026350 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8027c80:	4812      	ldr	r0, [pc, #72]	; (8027ccc <bsp_init+0x2b8>)
 8027c82:	f7fe fb1b 	bl	80262bc <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 8027c86:	4811      	ldr	r0, [pc, #68]	; (8027ccc <bsp_init+0x2b8>)
 8027c88:	f7fe fc12 	bl	80264b0 <TIMER_GetInterruptStatus>
 8027c8c:	2800      	cmp	r0, #0
 8027c8e:	d0fa      	beq.n	8027c86 <bsp_init+0x272>
  
  TIMER_Stop(&TIMER_DELAY);
 8027c90:	480e      	ldr	r0, [pc, #56]	; (8027ccc <bsp_init+0x2b8>)
 8027c92:	f7fe fb29 	bl	80262e8 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 8027c96:	480d      	ldr	r0, [pc, #52]	; (8027ccc <bsp_init+0x2b8>)
 8027c98:	f7fe fc32 	bl	8026500 <TIMER_Clear>
  /* To avoid out of band spurs */
  bgt_lowest_power_with_q2_disable();
  bsp_time_delay_usec(50U);           /* Delay for BGT Power down SPI settings */
  
  /* Power-down BGT */
  bgt_power_down();
 8027c9c:	f7ff fe82 	bl	80279a4 <bgt_power_down>
  
  /* Disable PLL */
  pll_power_down();
 8027ca0:	f000 fd70 	bl	8028784 <pll_power_down>
 8027ca4:	e7d8      	b.n	8027c58 <bsp_init+0x244>
 8027ca6:	bf00      	nop
 8027ca8:	1ffe8a74 	.word	0x1ffe8a74
 8027cac:	1fff1f9c 	.word	0x1fff1f9c
 8027cb0:	40004b0c 	.word	0x40004b0c
 8027cb4:	1fff1fb8 	.word	0x1fff1fb8
 8027cb8:	1fff1fa0 	.word	0x1fff1fa0
 8027cbc:	1fff1fbc 	.word	0x1fff1fbc
 8027cc0:	1ffe89fc 	.word	0x1ffe89fc
 8027cc4:	1ffe8adc 	.word	0x1ffe8adc
 8027cc8:	1ffe8a0c 	.word	0x1ffe8a0c
 8027ccc:	1ffe888c 	.word	0x1ffe888c
 8027cd0:	000186a0 	.word	0x000186a0
 8027cd4:	1ffe8b54 	.word	0x1ffe8b54
 8027cd8:	1fff1fb0 	.word	0x1fff1fb0
 8027cdc:	40005310 	.word	0x40005310
 8027ce0:	40004f00 	.word	0x40004f00
 8027ce4:	4000473c 	.word	0x4000473c
 8027ce8:	1fff1fdc 	.word	0x1fff1fdc
 8027cec:	1ffe8b58 	.word	0x1ffe8b58

08027cf0 <bsp_components_power_up>:
}

//============================================================================

void bsp_components_power_up(void)
{
 8027cf0:	b508      	push	{r3, lr}
  /* Power-up BGT */
  bgt_power_up();
 8027cf2:	f7ff fe43 	bl	802797c <bgt_power_up>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 8027cf6:	4852      	ldr	r0, [pc, #328]	; (8027e40 <bsp_components_power_up+0x150>)
 8027cf8:	f7fe fbec 	bl	80264d4 <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 8027cfc:	4850      	ldr	r0, [pc, #320]	; (8027e40 <bsp_components_power_up+0x150>)
 8027cfe:	f242 7110 	movw	r1, #10000	; 0x2710
 8027d02:	f7fe fb25 	bl	8026350 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8027d06:	484e      	ldr	r0, [pc, #312]	; (8027e40 <bsp_components_power_up+0x150>)
 8027d08:	f7fe fad8 	bl	80262bc <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 8027d0c:	484c      	ldr	r0, [pc, #304]	; (8027e40 <bsp_components_power_up+0x150>)
 8027d0e:	f7fe fbcf 	bl	80264b0 <TIMER_GetInterruptStatus>
 8027d12:	2800      	cmp	r0, #0
 8027d14:	d0fa      	beq.n	8027d0c <bsp_components_power_up+0x1c>
  
  TIMER_Stop(&TIMER_DELAY);
 8027d16:	484a      	ldr	r0, [pc, #296]	; (8027e40 <bsp_components_power_up+0x150>)
 8027d18:	f7fe fae6 	bl	80262e8 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 8027d1c:	4848      	ldr	r0, [pc, #288]	; (8027e40 <bsp_components_power_up+0x150>)
 8027d1e:	f7fe fbef 	bl	8026500 <TIMER_Clear>
  bgt_power_up();
  
  /* Delay for BGT power-up */
  bsp_time_delay_usec(100U);
  
  bgt_lowest_power_with_q2_disable();
 8027d22:	f7ff fe69 	bl	80279f8 <bgt_lowest_power_with_q2_disable>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 8027d26:	4846      	ldr	r0, [pc, #280]	; (8027e40 <bsp_components_power_up+0x150>)
 8027d28:	f7fe fbd4 	bl	80264d4 <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 8027d2c:	4844      	ldr	r0, [pc, #272]	; (8027e40 <bsp_components_power_up+0x150>)
 8027d2e:	f649 4140 	movw	r1, #40000	; 0x9c40
 8027d32:	f7fe fb0d 	bl	8026350 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8027d36:	4842      	ldr	r0, [pc, #264]	; (8027e40 <bsp_components_power_up+0x150>)
 8027d38:	f7fe fac0 	bl	80262bc <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 8027d3c:	4840      	ldr	r0, [pc, #256]	; (8027e40 <bsp_components_power_up+0x150>)
 8027d3e:	f7fe fbb7 	bl	80264b0 <TIMER_GetInterruptStatus>
 8027d42:	2800      	cmp	r0, #0
 8027d44:	d0fa      	beq.n	8027d3c <bsp_components_power_up+0x4c>
  
  TIMER_Stop(&TIMER_DELAY);
 8027d46:	483e      	ldr	r0, [pc, #248]	; (8027e40 <bsp_components_power_up+0x150>)
 8027d48:	f7fe face 	bl	80262e8 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 8027d4c:	483c      	ldr	r0, [pc, #240]	; (8027e40 <bsp_components_power_up+0x150>)
 8027d4e:	f7fe fbd7 	bl	8026500 <TIMER_Clear>
  
  bgt_lowest_power_with_q2_disable();
  bsp_time_delay_usec(400U); /* 400us based on PLL pre-charging slope, dependent on board loop filter */
  
  /* Enable PLL */
  pll_power_up();
 8027d52:	f000 fd15 	bl	8028780 <pll_power_up>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 8027d56:	483a      	ldr	r0, [pc, #232]	; (8027e40 <bsp_components_power_up+0x150>)
 8027d58:	f7fe fbbc 	bl	80264d4 <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 8027d5c:	4838      	ldr	r0, [pc, #224]	; (8027e40 <bsp_components_power_up+0x150>)
 8027d5e:	f242 7110 	movw	r1, #10000	; 0x2710
 8027d62:	f7fe faf5 	bl	8026350 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8027d66:	4836      	ldr	r0, [pc, #216]	; (8027e40 <bsp_components_power_up+0x150>)
 8027d68:	f7fe faa8 	bl	80262bc <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 8027d6c:	4834      	ldr	r0, [pc, #208]	; (8027e40 <bsp_components_power_up+0x150>)
 8027d6e:	f7fe fb9f 	bl	80264b0 <TIMER_GetInterruptStatus>
 8027d72:	2800      	cmp	r0, #0
 8027d74:	d0fa      	beq.n	8027d6c <bsp_components_power_up+0x7c>
  
  TIMER_Stop(&TIMER_DELAY);
 8027d76:	4832      	ldr	r0, [pc, #200]	; (8027e40 <bsp_components_power_up+0x150>)
 8027d78:	f7fe fab6 	bl	80262e8 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 8027d7c:	4830      	ldr	r0, [pc, #192]	; (8027e40 <bsp_components_power_up+0x150>)
 8027d7e:	f7fe fbbf 	bl	8026500 <TIMER_Clear>
  
  /* Delay for PLL power-up.
   * This delay depends upon the Charge pump voltage for locking time (linked with first BGT power-up delay) */
  bsp_time_delay_usec(100U);

  if (pll_get_update_config_flag() == ENABLED)
 8027d82:	f000 fd2f 	bl	80287e4 <pll_get_update_config_flag>
 8027d86:	2801      	cmp	r0, #1
  {
#if (FW_MODULATION_TYPE == 0U) /* Doppler modulation */
    pll_update_configuration(pll_handle, DOPPLER_MODULATION);
    
#elif (FW_MODULATION_TYPE == 1U) /* FMCW modulation */
    pll_update_configuration(pll_handle, FMCW_MODULATION);
 8027d88:	4b2e      	ldr	r3, [pc, #184]	; (8027e44 <bsp_components_power_up+0x154>)
  
  /* Delay for PLL power-up.
   * This delay depends upon the Charge pump voltage for locking time (linked with first BGT power-up delay) */
  bsp_time_delay_usec(100U);

  if (pll_get_update_config_flag() == ENABLED)
 8027d8a:	d054      	beq.n	8027e36 <bsp_components_power_up+0x146>
  }
  
#if (FW_MODULATION_TYPE == 1U) /* FMCW modulation */
  else
  {
    pll_enable_ramps(pll_handle); /* Enable PLL's ramps */
 8027d8c:	6818      	ldr	r0, [r3, #0]
 8027d8e:	f000 fceb 	bl	8028768 <pll_enable_ramps>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 8027d92:	482b      	ldr	r0, [pc, #172]	; (8027e40 <bsp_components_power_up+0x150>)
 8027d94:	f7fe fb9e 	bl	80264d4 <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 8027d98:	4829      	ldr	r0, [pc, #164]	; (8027e40 <bsp_components_power_up+0x150>)
 8027d9a:	f24c 3150 	movw	r1, #50000	; 0xc350
 8027d9e:	f7fe fad7 	bl	8026350 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8027da2:	4827      	ldr	r0, [pc, #156]	; (8027e40 <bsp_components_power_up+0x150>)
 8027da4:	f7fe fa8a 	bl	80262bc <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 8027da8:	4825      	ldr	r0, [pc, #148]	; (8027e40 <bsp_components_power_up+0x150>)
 8027daa:	f7fe fb81 	bl	80264b0 <TIMER_GetInterruptStatus>
 8027dae:	2800      	cmp	r0, #0
 8027db0:	d0fa      	beq.n	8027da8 <bsp_components_power_up+0xb8>
  
  TIMER_Stop(&TIMER_DELAY);
 8027db2:	4823      	ldr	r0, [pc, #140]	; (8027e40 <bsp_components_power_up+0x150>)
 8027db4:	f7fe fa98 	bl	80262e8 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 8027db8:	4821      	ldr	r0, [pc, #132]	; (8027e40 <bsp_components_power_up+0x150>)
 8027dba:	f7fe fba1 	bl	8026500 <TIMER_Clear>
#endif
  
  bsp_time_delay_usec(500U);

  /* Set the new PGA gain level */
  if(ds_device_get_settings()->isGainlevelUpdated)
 8027dbe:	f7f8 f923 	bl	8020008 <ds_device_get_settings>
 8027dc2:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8027dc4:	b143      	cbz	r3, 8027dd8 <bsp_components_power_up+0xe8>
  {
    pga_set_gain(ds_device_get_settings()->pga_rx_gain_level);
 8027dc6:	f7f8 f91f 	bl	8020008 <ds_device_get_settings>
 8027dca:	8c40      	ldrh	r0, [r0, #34]	; 0x22
 8027dcc:	f000 fb68 	bl	80284a0 <pga_set_gain>
    ds_device_get_settings()->isGainlevelUpdated = 0;
 8027dd0:	f7f8 f91a 	bl	8020008 <ds_device_get_settings>
 8027dd4:	2300      	movs	r3, #0
 8027dd6:	6343      	str	r3, [r0, #52]	; 0x34

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 8027dd8:	4819      	ldr	r0, [pc, #100]	; (8027e40 <bsp_components_power_up+0x150>)
 8027dda:	f7fe fb7b 	bl	80264d4 <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 8027dde:	4818      	ldr	r0, [pc, #96]	; (8027e40 <bsp_components_power_up+0x150>)
 8027de0:	f241 3188 	movw	r1, #5000	; 0x1388
 8027de4:	f7fe fab4 	bl	8026350 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8027de8:	4815      	ldr	r0, [pc, #84]	; (8027e40 <bsp_components_power_up+0x150>)
 8027dea:	f7fe fa67 	bl	80262bc <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 8027dee:	4814      	ldr	r0, [pc, #80]	; (8027e40 <bsp_components_power_up+0x150>)
 8027df0:	f7fe fb5e 	bl	80264b0 <TIMER_GetInterruptStatus>
 8027df4:	2800      	cmp	r0, #0
 8027df6:	d0fa      	beq.n	8027dee <bsp_components_power_up+0xfe>
  
  TIMER_Stop(&TIMER_DELAY);
 8027df8:	4811      	ldr	r0, [pc, #68]	; (8027e40 <bsp_components_power_up+0x150>)
 8027dfa:	f7fe fa75 	bl	80262e8 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 8027dfe:	4810      	ldr	r0, [pc, #64]	; (8027e40 <bsp_components_power_up+0x150>)
 8027e00:	f7fe fb7e 	bl	8026500 <TIMER_Clear>
  }

  bsp_time_delay_usec(PLL_LOCK_TIME_USEC); /* Delay for PLL Lock */
  
  /* Enable BGT TX Power amplifier */
  bgt_start_tx();
 8027e04:	f7ff fdb6 	bl	8027974 <bgt_start_tx>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 8027e08:	480d      	ldr	r0, [pc, #52]	; (8027e40 <bsp_components_power_up+0x150>)
 8027e0a:	f7fe fb63 	bl	80264d4 <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 8027e0e:	480c      	ldr	r0, [pc, #48]	; (8027e40 <bsp_components_power_up+0x150>)
 8027e10:	490d      	ldr	r1, [pc, #52]	; (8027e48 <bsp_components_power_up+0x158>)
 8027e12:	f7fe fa9d 	bl	8026350 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8027e16:	480a      	ldr	r0, [pc, #40]	; (8027e40 <bsp_components_power_up+0x150>)
 8027e18:	f7fe fa50 	bl	80262bc <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 8027e1c:	4808      	ldr	r0, [pc, #32]	; (8027e40 <bsp_components_power_up+0x150>)
 8027e1e:	f7fe fb47 	bl	80264b0 <TIMER_GetInterruptStatus>
 8027e22:	2800      	cmp	r0, #0
 8027e24:	d0fa      	beq.n	8027e1c <bsp_components_power_up+0x12c>
  
  TIMER_Stop(&TIMER_DELAY);
 8027e26:	4806      	ldr	r0, [pc, #24]	; (8027e40 <bsp_components_power_up+0x150>)
 8027e28:	f7fe fa5e 	bl	80262e8 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 8027e2c:	4804      	ldr	r0, [pc, #16]	; (8027e40 <bsp_components_power_up+0x150>)
  /* Enable BGT TX Power amplifier */
  bgt_start_tx();
  
  /* Delay for BGT Q2 divider to be zero and VCO to be settled after SPI setting transmitted */
  bsp_time_delay_usec(BGT_VCO_LOCK_TIME_USEC); /* 1ms delay for IQ voltage at ADC close to reference 1.65V */
}
 8027e2e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
  
  TIMER_Stop(&TIMER_DELAY);
  
  TIMER_Clear(&TIMER_DELAY);
 8027e32:	f7fe bb65 	b.w	8026500 <TIMER_Clear>
  {
#if (FW_MODULATION_TYPE == 0U) /* Doppler modulation */
    pll_update_configuration(pll_handle, DOPPLER_MODULATION);
    
#elif (FW_MODULATION_TYPE == 1U) /* FMCW modulation */
    pll_update_configuration(pll_handle, FMCW_MODULATION);
 8027e36:	4601      	mov	r1, r0
 8027e38:	6818      	ldr	r0, [r3, #0]
 8027e3a:	f000 fca5 	bl	8028788 <pll_update_configuration>
 8027e3e:	e7a8      	b.n	8027d92 <bsp_components_power_up+0xa2>
 8027e40:	1ffe888c 	.word	0x1ffe888c
 8027e44:	1ffe8b58 	.word	0x1ffe8b58
 8027e48:	000186a0 	.word	0x000186a0

08027e4c <bsp_components_power_down>:
}

//============================================================================

void bsp_components_power_down(void)
{
 8027e4c:	b508      	push	{r3, lr}
  pll_disable_ramps(pll_handle);
 8027e4e:	4b11      	ldr	r3, [pc, #68]	; (8027e94 <bsp_components_power_down+0x48>)
 8027e50:	6818      	ldr	r0, [r3, #0]
 8027e52:	f000 fc8d 	bl	8028770 <pll_disable_ramps>
  
  /* To avoid out of band spurs */
  bgt_lowest_power_with_q2_disable();
 8027e56:	f7ff fdcf 	bl	80279f8 <bgt_lowest_power_with_q2_disable>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 8027e5a:	480f      	ldr	r0, [pc, #60]	; (8027e98 <bsp_components_power_down+0x4c>)
 8027e5c:	f7fe fb3a 	bl	80264d4 <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 8027e60:	480d      	ldr	r0, [pc, #52]	; (8027e98 <bsp_components_power_down+0x4c>)
 8027e62:	f241 3188 	movw	r1, #5000	; 0x1388
 8027e66:	f7fe fa73 	bl	8026350 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8027e6a:	480b      	ldr	r0, [pc, #44]	; (8027e98 <bsp_components_power_down+0x4c>)
 8027e6c:	f7fe fa26 	bl	80262bc <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 8027e70:	4809      	ldr	r0, [pc, #36]	; (8027e98 <bsp_components_power_down+0x4c>)
 8027e72:	f7fe fb1d 	bl	80264b0 <TIMER_GetInterruptStatus>
 8027e76:	2800      	cmp	r0, #0
 8027e78:	d0fa      	beq.n	8027e70 <bsp_components_power_down+0x24>
  
  TIMER_Stop(&TIMER_DELAY);
 8027e7a:	4807      	ldr	r0, [pc, #28]	; (8027e98 <bsp_components_power_down+0x4c>)
 8027e7c:	f7fe fa34 	bl	80262e8 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 8027e80:	4805      	ldr	r0, [pc, #20]	; (8027e98 <bsp_components_power_down+0x4c>)
 8027e82:	f7fe fb3d 	bl	8026500 <TIMER_Clear>
  /* To avoid out of band spurs */
  bgt_lowest_power_with_q2_disable();
  bsp_time_delay_usec(50U);           /* Delay for BGT Power down SPI settings */
  
  /* Power-down BGT */
  bgt_power_down();
 8027e86:	f7ff fd8d 	bl	80279a4 <bgt_power_down>
  
  /* Disable PLL */
  pll_power_down();
}
 8027e8a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  
  /* Power-down BGT */
  bgt_power_down();
  
  /* Disable PLL */
  pll_power_down();
 8027e8e:	f000 bc79 	b.w	8028784 <pll_power_down>
 8027e92:	bf00      	nop
 8027e94:	1ffe8b58 	.word	0x1ffe8b58
 8027e98:	1ffe888c 	.word	0x1ffe888c

08027e9c <bsp_flash_write_data>:

//============================================================================

void bsp_flash_write_data(const uint16_t offset_address, const uint8_t* data_ptr, uint16_t num_of_bytes)
{
  E_EEPROM_XMC4_WriteArray(offset_address, data_ptr, num_of_bytes);
 8027e9c:	f7fe beda 	b.w	8026c54 <E_EEPROM_XMC4_WriteArray>

08027ea0 <bsp_flash_read_data>:

//============================================================================

void bsp_flash_read_data(const uint16_t offset_address, const uint8_t* data_ptr, uint16_t num_of_bytes)
{
  E_EEPROM_XMC4_ReadArray(offset_address, (uint8_t*)data_ptr, num_of_bytes);
 8027ea0:	f7fe bf32 	b.w	8026d08 <E_EEPROM_XMC4_ReadArray>

08027ea4 <bsp_flash_flush_data>:

//============================================================================

void bsp_flash_flush_data(void)
{
  E_EEPROM_XMC4_UpdateFlashContents();
 8027ea4:	f7fe bf7c 	b.w	8026da0 <E_EEPROM_XMC4_UpdateFlashContents>

08027ea8 <bsp_flash_is_empty>:

//============================================================================

bool bsp_flash_is_empty(void)
{
  return (E_EEPROM_XMC4_IsFlashEmpty());
 8027ea8:	f7ff b828 	b.w	8026efc <E_EEPROM_XMC4_IsFlashEmpty>

08027eac <bsp_timer_stop_clear>:
}

//============================================================================

TIMER_STATUS_t bsp_timer_stop_clear(TIMER_t* const handle_timer)
{
 8027eac:	b538      	push	{r3, r4, r5, lr}
 8027eae:	4605      	mov	r5, r0
  TIMER_STATUS_t  status;
  
  status = TIMER_Stop(handle_timer);
 8027eb0:	f7fe fa1a 	bl	80262e8 <TIMER_Stop>
 8027eb4:	4604      	mov	r4, r0
  
  status |= TIMER_Clear(handle_timer);
 8027eb6:	4628      	mov	r0, r5
 8027eb8:	f7fe fb22 	bl	8026500 <TIMER_Clear>
 8027ebc:	4320      	orrs	r0, r4
  
  return (status);
}
 8027ebe:	b2c0      	uxtb	r0, r0
 8027ec0:	bd38      	pop	{r3, r4, r5, pc}
 8027ec2:	bf00      	nop

08027ec4 <bsp_timer_start>:

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8027ec4:	f7fe b9fa 	b.w	80262bc <TIMER_Start>

08027ec8 <bsp_dma_set_destination_addr_from_acq_buf_obj>:
}

//============================================================================

void bsp_dma_set_destination_addr_from_acq_buf_obj(acq_buf_obj *acq_buf, uint32_t chirp_cnt)
{
 8027ec8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  pDMA_dst_I1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 0, chirp_cnt);
 8027ecc:	460a      	mov	r2, r1
}

//============================================================================

void bsp_dma_set_destination_addr_from_acq_buf_obj(acq_buf_obj *acq_buf, uint32_t chirp_cnt)
{
 8027ece:	460c      	mov	r4, r1
  pDMA_dst_I1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 0, chirp_cnt);
 8027ed0:	2100      	movs	r1, #0
}

//============================================================================

void bsp_dma_set_destination_addr_from_acq_buf_obj(acq_buf_obj *acq_buf, uint32_t chirp_cnt)
{
 8027ed2:	4605      	mov	r5, r0
  pDMA_dst_I1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 0, chirp_cnt);
 8027ed4:	f7f8 fa0a 	bl	80202ec <get_buffer_address_by_chirp>
 8027ed8:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 8027f7c <bsp_dma_set_destination_addr_from_acq_buf_obj+0xb4>
  pDMA_dst_Q1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 1, chirp_cnt);
 8027edc:	4f20      	ldr	r7, [pc, #128]	; (8027f60 <bsp_dma_set_destination_addr_from_acq_buf_obj+0x98>)

//============================================================================

void bsp_dma_set_destination_addr_from_acq_buf_obj(acq_buf_obj *acq_buf, uint32_t chirp_cnt)
{
  pDMA_dst_I1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 0, chirp_cnt);
 8027ede:	f8c8 0000 	str.w	r0, [r8]
  pDMA_dst_Q1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 1, chirp_cnt);
 8027ee2:	4622      	mov	r2, r4
 8027ee4:	4628      	mov	r0, r5
 8027ee6:	2101      	movs	r1, #1
 8027ee8:	f7f8 fa00 	bl	80202ec <get_buffer_address_by_chirp>
  pDMA_dst_I2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 2, chirp_cnt);
 8027eec:	4622      	mov	r2, r4
//============================================================================

void bsp_dma_set_destination_addr_from_acq_buf_obj(acq_buf_obj *acq_buf, uint32_t chirp_cnt)
{
  pDMA_dst_I1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 0, chirp_cnt);
  pDMA_dst_Q1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 1, chirp_cnt);
 8027eee:	6038      	str	r0, [r7, #0]
  pDMA_dst_I2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 2, chirp_cnt);
 8027ef0:	2102      	movs	r1, #2
 8027ef2:	4628      	mov	r0, r5
 8027ef4:	f7f8 f9fa 	bl	80202ec <get_buffer_address_by_chirp>
 8027ef8:	4e1a      	ldr	r6, [pc, #104]	; (8027f64 <bsp_dma_set_destination_addr_from_acq_buf_obj+0x9c>)
  pDMA_dst_Q2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 3, chirp_cnt);
 8027efa:	4622      	mov	r2, r4

void bsp_dma_set_destination_addr_from_acq_buf_obj(acq_buf_obj *acq_buf, uint32_t chirp_cnt)
{
  pDMA_dst_I1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 0, chirp_cnt);
  pDMA_dst_Q1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 1, chirp_cnt);
  pDMA_dst_I2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 2, chirp_cnt);
 8027efc:	6030      	str	r0, [r6, #0]
  pDMA_dst_Q2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 3, chirp_cnt);
 8027efe:	2103      	movs	r1, #3
 8027f00:	4628      	mov	r0, r5
 8027f02:	f7f8 f9f3 	bl	80202ec <get_buffer_address_by_chirp>
  
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_I1.dma_global->dma, DMA_CH_I1.ch_num, (uint32_t) pDMA_dst_I1);
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_Q1.dma_global->dma, DMA_CH_Q1.ch_num, (uint32_t) pDMA_dst_Q1);
 8027f06:	4d18      	ldr	r5, [pc, #96]	; (8027f68 <bsp_dma_set_destination_addr_from_acq_buf_obj+0xa0>)
  pDMA_dst_I1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 0, chirp_cnt);
  pDMA_dst_Q1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 1, chirp_cnt);
  pDMA_dst_I2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 2, chirp_cnt);
  pDMA_dst_Q2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 3, chirp_cnt);
  
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_I1.dma_global->dma, DMA_CH_I1.ch_num, (uint32_t) pDMA_dst_I1);
 8027f08:	4b18      	ldr	r3, [pc, #96]	; (8027f6c <bsp_dma_set_destination_addr_from_acq_buf_obj+0xa4>)
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_Q1.dma_global->dma, DMA_CH_Q1.ch_num, (uint32_t) pDMA_dst_Q1);
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_I2.dma_global->dma, DMA_CH_I2.ch_num, (uint32_t) pDMA_dst_I2);
 8027f0a:	4c19      	ldr	r4, [pc, #100]	; (8027f70 <bsp_dma_set_destination_addr_from_acq_buf_obj+0xa8>)
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetSourceAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetDestinationAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].DAR = addr;
 8027f0c:	7b1a      	ldrb	r2, [r3, #12]
  pDMA_dst_I1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 0, chirp_cnt);
  pDMA_dst_Q1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 1, chirp_cnt);
  pDMA_dst_I2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 2, chirp_cnt);
  pDMA_dst_Q2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 3, chirp_cnt);
  
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_I1.dma_global->dma, DMA_CH_I1.ch_num, (uint32_t) pDMA_dst_I1);
 8027f0e:	6819      	ldr	r1, [r3, #0]
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_Q1.dma_global->dma, DMA_CH_Q1.ch_num, (uint32_t) pDMA_dst_Q1);
 8027f10:	682b      	ldr	r3, [r5, #0]
  pDMA_dst_I1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 0, chirp_cnt);
  pDMA_dst_Q1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 1, chirp_cnt);
  pDMA_dst_I2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 2, chirp_cnt);
  pDMA_dst_Q2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 3, chirp_cnt);
  
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_I1.dma_global->dma, DMA_CH_I1.ch_num, (uint32_t) pDMA_dst_I1);
 8027f12:	f8d1 c000 	ldr.w	ip, [r1]
 8027f16:	f8d8 e000 	ldr.w	lr, [r8]
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_Q1.dma_global->dma, DMA_CH_Q1.ch_num, (uint32_t) pDMA_dst_Q1);
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_I2.dma_global->dma, DMA_CH_I2.ch_num, (uint32_t) pDMA_dst_I2);
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_Q2.dma_global->dma, DMA_CH_Q2.ch_num, (uint32_t) pDMA_dst_Q2);
 8027f1a:	4916      	ldr	r1, [pc, #88]	; (8027f74 <bsp_dma_set_destination_addr_from_acq_buf_obj+0xac>)
  pDMA_dst_Q1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 1, chirp_cnt);
  pDMA_dst_I2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 2, chirp_cnt);
  pDMA_dst_Q2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 3, chirp_cnt);
  
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_I1.dma_global->dma, DMA_CH_I1.ch_num, (uint32_t) pDMA_dst_I1);
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_Q1.dma_global->dma, DMA_CH_Q1.ch_num, (uint32_t) pDMA_dst_Q1);
 8027f1c:	f8d3 8000 	ldr.w	r8, [r3]
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_I2.dma_global->dma, DMA_CH_I2.ch_num, (uint32_t) pDMA_dst_I2);
 8027f20:	6823      	ldr	r3, [r4, #0]
 8027f22:	f8d6 a000 	ldr.w	sl, [r6]
 8027f26:	f8d3 9000 	ldr.w	r9, [r3]
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_Q2.dma_global->dma, DMA_CH_Q2.ch_num, (uint32_t) pDMA_dst_Q2);
 8027f2a:	680e      	ldr	r6, [r1, #0]
void bsp_dma_set_destination_addr_from_acq_buf_obj(acq_buf_obj *acq_buf, uint32_t chirp_cnt)
{
  pDMA_dst_I1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 0, chirp_cnt);
  pDMA_dst_Q1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 1, chirp_cnt);
  pDMA_dst_I2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 2, chirp_cnt);
  pDMA_dst_Q2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 3, chirp_cnt);
 8027f2c:	4b12      	ldr	r3, [pc, #72]	; (8027f78 <bsp_dma_set_destination_addr_from_acq_buf_obj+0xb0>)
  
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_I1.dma_global->dma, DMA_CH_I1.ch_num, (uint32_t) pDMA_dst_I1);
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_Q1.dma_global->dma, DMA_CH_Q1.ch_num, (uint32_t) pDMA_dst_Q1);
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_I2.dma_global->dma, DMA_CH_I2.ch_num, (uint32_t) pDMA_dst_I2);
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_Q2.dma_global->dma, DMA_CH_Q2.ch_num, (uint32_t) pDMA_dst_Q2);
 8027f2e:	6836      	ldr	r6, [r6, #0]
void bsp_dma_set_destination_addr_from_acq_buf_obj(acq_buf_obj *acq_buf, uint32_t chirp_cnt)
{
  pDMA_dst_I1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 0, chirp_cnt);
  pDMA_dst_Q1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 1, chirp_cnt);
  pDMA_dst_I2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 2, chirp_cnt);
  pDMA_dst_Q2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 3, chirp_cnt);
 8027f30:	6018      	str	r0, [r3, #0]
 8027f32:	2358      	movs	r3, #88	; 0x58
 8027f34:	fb03 c202 	mla	r2, r3, r2, ip
  
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_I1.dma_global->dma, DMA_CH_I1.ch_num, (uint32_t) pDMA_dst_I1);
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_Q1.dma_global->dma, DMA_CH_Q1.ch_num, (uint32_t) pDMA_dst_Q1);
 8027f38:	683f      	ldr	r7, [r7, #0]
 8027f3a:	f8c2 e008 	str.w	lr, [r2, #8]
 8027f3e:	7b2a      	ldrb	r2, [r5, #12]
 8027f40:	fb03 8802 	mla	r8, r3, r2, r8
 8027f44:	f8c8 7008 	str.w	r7, [r8, #8]
 8027f48:	7b22      	ldrb	r2, [r4, #12]
 8027f4a:	fb03 9902 	mla	r9, r3, r2, r9
 8027f4e:	f8c9 a008 	str.w	sl, [r9, #8]
 8027f52:	7b0a      	ldrb	r2, [r1, #12]
 8027f54:	fb03 6302 	mla	r3, r3, r2, r6
 8027f58:	6098      	str	r0, [r3, #8]
 8027f5a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8027f5e:	bf00      	nop
 8027f60:	1fff1fd8 	.word	0x1fff1fd8
 8027f64:	1fff1fac 	.word	0x1fff1fac
 8027f68:	1ffe89fc 	.word	0x1ffe89fc
 8027f6c:	1ffe8a74 	.word	0x1ffe8a74
 8027f70:	1ffe8adc 	.word	0x1ffe8adc
 8027f74:	1ffe8a0c 	.word	0x1ffe8a0c
 8027f78:	1fff1fd4 	.word	0x1fff1fd4
 8027f7c:	1fff1fb4 	.word	0x1fff1fb4

08027f80 <bsp_trigger_new_frame>:
}

//============================================================================

void bsp_trigger_new_frame(void)
{
 8027f80:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  /* Stop ADC timer if ADC is still running */
  if (TIMER_GetTimerStatus(&TIMER_ADC_TRIG))
 8027f84:	4866      	ldr	r0, [pc, #408]	; (8028120 <bsp_trigger_new_frame+0x1a0>)
}

//============================================================================

void bsp_trigger_new_frame(void)
{
 8027f86:	b083      	sub	sp, #12
  /* Stop ADC timer if ADC is still running */
  if (TIMER_GetTimerStatus(&TIMER_ADC_TRIG))
 8027f88:	f7fe f9d0 	bl	802632c <TIMER_GetTimerStatus>
 8027f8c:	2800      	cmp	r0, #0
 8027f8e:	f040 80b5 	bne.w	80280fc <bsp_trigger_new_frame+0x17c>
 8027f92:	4f64      	ldr	r7, [pc, #400]	; (8028124 <bsp_trigger_new_frame+0x1a4>)
 8027f94:	4e64      	ldr	r6, [pc, #400]	; (8028128 <bsp_trigger_new_frame+0x1a8>)
 8027f96:	683a      	ldr	r2, [r7, #0]
==============================================================================
 */

static void get_raw_data(void)
{
  watchdog_status = 0;
 8027f98:	4b64      	ldr	r3, [pc, #400]	; (802812c <bsp_trigger_new_frame+0x1ac>)
 8027f9a:	6810      	ldr	r0, [r2, #0]
 8027f9c:	7b39      	ldrb	r1, [r7, #12]
 8027f9e:	4d64      	ldr	r5, [pc, #400]	; (8028130 <bsp_trigger_new_frame+0x1b0>)
 8027fa0:	4c64      	ldr	r4, [pc, #400]	; (8028134 <bsp_trigger_new_frame+0x1b4>)
 8027fa2:	f04f 0800 	mov.w	r8, #0
 8027fa6:	f883 8000 	strb.w	r8, [r3]
 8027faa:	f7f9 fe55 	bl	8021c58 <XMC_DMA_CH_Disable>
 8027fae:	6833      	ldr	r3, [r6, #0]
 8027fb0:	7b31      	ldrb	r1, [r6, #12]
 8027fb2:	6818      	ldr	r0, [r3, #0]
 8027fb4:	f7f9 fe50 	bl	8021c58 <XMC_DMA_CH_Disable>
 8027fb8:	682b      	ldr	r3, [r5, #0]
 8027fba:	7b29      	ldrb	r1, [r5, #12]
 8027fbc:	6818      	ldr	r0, [r3, #0]
 8027fbe:	f7f9 fe4b 	bl	8021c58 <XMC_DMA_CH_Disable>
 8027fc2:	6823      	ldr	r3, [r4, #0]
 8027fc4:	7b21      	ldrb	r1, [r4, #12]
 8027fc6:	6818      	ldr	r0, [r3, #0]
 8027fc8:	f7f9 fe46 	bl	8021c58 <XMC_DMA_CH_Disable>
 * }
 * @endcode<BR> </p>
 */
__STATIC_INLINE void DMA_CH_SetBlockSize(DMA_CH_t *const obj, uint32_t block_size)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, block_size);
 8027fcc:	6823      	ldr	r3, [r4, #0]
  
  /* DMA Reconfiguration */
  dma_disable();
  dma_set_block_size(bsp_num_samples_per_dma_transfer);
 8027fce:	f8df c17c 	ldr.w	ip, [pc, #380]	; 802814c <bsp_trigger_new_frame+0x1cc>
 8027fd2:	f8d3 b000 	ldr.w	fp, [r3]
 * see ::XMC_DMA_CH_Enable() for more information.
 *
 */
__STATIC_INLINE void XMC_DMA_CH_SetBlockSize(XMC_DMA_t *const dma, const uint8_t channel, uint32_t block_size)
{
  dma->CH[channel].CTLH = block_size;
 8027fd6:	7b23      	ldrb	r3, [r4, #12]
 8027fd8:	6838      	ldr	r0, [r7, #0]
 8027fda:	9300      	str	r3, [sp, #0]
//============================================================================

static void dma_set_block_size(uint32_t block_size)
{
  /* The maximum block size defined by DMA is 4095 */
  block_size = (block_size > BSP_MAX_DMA_BLOCK_SIZE) ? BSP_MAX_DMA_BLOCK_SIZE : block_size;
 8027fdc:	f8dc 3000 	ldr.w	r3, [ip]
 8027fe0:	682a      	ldr	r2, [r5, #0]
 8027fe2:	6831      	ldr	r1, [r6, #0]
 8027fe4:	9301      	str	r3, [sp, #4]
 8027fe6:	9b00      	ldr	r3, [sp, #0]
 8027fe8:	6800      	ldr	r0, [r0, #0]
 8027fea:	f897 e00c 	ldrb.w	lr, [r7, #12]
 8027fee:	f8d2 a000 	ldr.w	sl, [r2]
 8027ff2:	6809      	ldr	r1, [r1, #0]
 8027ff4:	f896 900c 	ldrb.w	r9, [r6, #12]
 8027ff8:	7b2a      	ldrb	r2, [r5, #12]
 8027ffa:	f04f 0c58 	mov.w	ip, #88	; 0x58
 8027ffe:	fb0c bb03 	mla	fp, ip, r3, fp
 8028002:	9b01      	ldr	r3, [sp, #4]
 8028004:	fb0c 000e 	mla	r0, ip, lr, r0
 8028008:	f640 7eff 	movw	lr, #4095	; 0xfff
 802800c:	fb0c 1109 	mla	r1, ip, r9, r1
 8028010:	4573      	cmp	r3, lr
 8028012:	fb0c a202 	mla	r2, ip, r2, sl
 8028016:	bf28      	it	cs
 8028018:	4673      	movcs	r3, lr
 802801a:	61c3      	str	r3, [r0, #28]
 802801c:	61cb      	str	r3, [r1, #28]
 802801e:	61d3      	str	r3, [r2, #28]
 8028020:	f8cb 301c 	str.w	r3, [fp, #28]
  
  /* DMA Reconfiguration */
  dma_disable();
  dma_set_block_size(bsp_num_samples_per_dma_transfer);
  
  acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 8028024:	f7f8 f85a 	bl	80200dc <ds_get_active_acq_buf>
  
  bsp_dma_set_destination_addr_from_acq_buf_obj(p_acq_buf, 0 );
 8028028:	4641      	mov	r1, r8
 802802a:	f7ff ff4d 	bl	8027ec8 <bsp_dma_set_destination_addr_from_acq_buf_obj>
 */
__STATIC_INLINE void DMA_CH_Enable(DMA_CH_t *const obj)
{
  XMC_ASSERT("DMA_CH_Enable: NULL DMA_CH_t object", (obj != NULL));

  XMC_DMA_CH_Enable(obj->dma_global->dma, obj->ch_num);
 802802e:	6830      	ldr	r0, [r6, #0]
 8028030:	6829      	ldr	r1, [r5, #0]
 8028032:	6822      	ldr	r2, [r4, #0]
  
  dma_enable();
  
  /* BGT and PLL Power-up */
  if(bsp_duty_cycle_enable == ENABLED)
 8028034:	4b40      	ldr	r3, [pc, #256]	; (8028138 <bsp_trigger_new_frame+0x1b8>)
 8028036:	f8d7 9000 	ldr.w	r9, [r7]
 * ensure that the GPDMA module itself is enabled before calling this function.
 * See ::XMC_DMA_Enable() for details.
 */
__STATIC_INLINE void XMC_DMA_CH_Enable(XMC_DMA_t *const dma, const uint8_t channel)
{
  dma->CHENREG = (uint32_t)(0x101UL << channel);   
 802803a:	f897 e00c 	ldrb.w	lr, [r7, #12]
 802803e:	f895 800c 	ldrb.w	r8, [r5, #12]
 8028042:	f894 c00c 	ldrb.w	ip, [r4, #12]
 8028046:	6805      	ldr	r5, [r0, #0]
 8028048:	7b36      	ldrb	r6, [r6, #12]
 802804a:	6808      	ldr	r0, [r1, #0]
 802804c:	6811      	ldr	r1, [r2, #0]
 802804e:	781a      	ldrb	r2, [r3, #0]
 8028050:	f8d9 7000 	ldr.w	r7, [r9]
 8028054:	f240 1301 	movw	r3, #257	; 0x101
 8028058:	fa03 fe0e 	lsl.w	lr, r3, lr
 802805c:	fa03 f606 	lsl.w	r6, r3, r6
 8028060:	fa03 f408 	lsl.w	r4, r3, r8
 8028064:	2a01      	cmp	r2, #1
 8028066:	fa03 f30c 	lsl.w	r3, r3, ip
 802806a:	f8c7 e3a0 	str.w	lr, [r7, #928]	; 0x3a0
 802806e:	f8c5 63a0 	str.w	r6, [r5, #928]	; 0x3a0
 8028072:	f8c0 43a0 	str.w	r4, [r0, #928]	; 0x3a0
 8028076:	f8c1 33a0 	str.w	r3, [r1, #928]	; 0x3a0
 802807a:	d04e      	beq.n	802811a <bsp_trigger_new_frame+0x19a>
  {
    bsp_components_power_up();
  }
  else
  {
    if (pll_get_update_config_flag() == ENABLED)
 802807c:	f000 fbb2 	bl	80287e4 <pll_get_update_config_flag>
 8028080:	2801      	cmp	r0, #1
    {
#if (FW_MODULATION_TYPE == 0U) /* Doppler modulation */
      pll_update_configuration(pll_handle, DOPPLER_MODULATION);
      
#elif (FW_MODULATION_TYPE == 1U) /* FMCW modulation */
      pll_update_configuration(pll_handle, FMCW_MODULATION);
 8028082:	4b2e      	ldr	r3, [pc, #184]	; (802813c <bsp_trigger_new_frame+0x1bc>)
  {
    bsp_components_power_up();
  }
  else
  {
    if (pll_get_update_config_flag() == ENABLED)
 8028084:	d041      	beq.n	802810a <bsp_trigger_new_frame+0x18a>
    } /* Doppler modulation */
    
#if (FW_MODULATION_TYPE == 1U) /* FMCW modulation */
    else
    {
      pll_enable_ramps(pll_handle); /* Enable PLL's ramps */
 8028086:	6818      	ldr	r0, [r3, #0]
 8028088:	f000 fb6e 	bl	8028768 <pll_enable_ramps>
    }
#endif /* FMCW modulation */
    
    bgt_start_tx();
 802808c:	f7ff fc72 	bl	8027974 <bgt_start_tx>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 8028090:	482b      	ldr	r0, [pc, #172]	; (8028140 <bsp_trigger_new_frame+0x1c0>)
 8028092:	f7fe fa1f 	bl	80264d4 <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 8028096:	482a      	ldr	r0, [pc, #168]	; (8028140 <bsp_trigger_new_frame+0x1c0>)
 8028098:	f241 3188 	movw	r1, #5000	; 0x1388
 802809c:	f7fe f958 	bl	8026350 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 80280a0:	4827      	ldr	r0, [pc, #156]	; (8028140 <bsp_trigger_new_frame+0x1c0>)
 80280a2:	f7fe f90b 	bl	80262bc <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 80280a6:	4826      	ldr	r0, [pc, #152]	; (8028140 <bsp_trigger_new_frame+0x1c0>)
 80280a8:	f7fe fa02 	bl	80264b0 <TIMER_GetInterruptStatus>
 80280ac:	2800      	cmp	r0, #0
 80280ae:	d0fa      	beq.n	80280a6 <bsp_trigger_new_frame+0x126>
  
  TIMER_Stop(&TIMER_DELAY);
 80280b0:	4823      	ldr	r0, [pc, #140]	; (8028140 <bsp_trigger_new_frame+0x1c0>)
 80280b2:	f7fe f919 	bl	80262e8 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 80280b6:	4822      	ldr	r0, [pc, #136]	; (8028140 <bsp_trigger_new_frame+0x1c0>)
 80280b8:	f7fe fa22 	bl	8026500 <TIMER_Clear>
    bgt_start_tx();
    bsp_time_delay_usec(50);
  }
  
  /* Set WatchDog Timer Period */
  TIMER_SetTimeInterval(&TIMER_WATCHDOG, ds_device_get_settings()->pll_num_of_chirps_per_frame * (ds_device_get_settings()->pll_chirp_time_usec + PLL_RAMP_DOWM_TIME_USEC + PLL_STEADY_STATE_USEC) * 100U);
 80280bc:	f7f7 ffa4 	bl	8020008 <ds_device_get_settings>
 80280c0:	6944      	ldr	r4, [r0, #20]
 80280c2:	f7f7 ffa1 	bl	8020008 <ds_device_get_settings>
 80280c6:	6801      	ldr	r1, [r0, #0]
 80280c8:	481e      	ldr	r0, [pc, #120]	; (8028144 <bsp_trigger_new_frame+0x1c4>)
 80280ca:	2364      	movs	r3, #100	; 0x64
 80280cc:	fb03 f301 	mul.w	r3, r3, r1
 80280d0:	f503 419c 	add.w	r1, r3, #19968	; 0x4e00
 80280d4:	3120      	adds	r1, #32
 80280d6:	fb04 f101 	mul.w	r1, r4, r1
 80280da:	f7fe f939 	bl	8026350 <TIMER_SetTimeInterval>
  
  /* PLL Chirp Trigger */
#if (FW_MODULATION_TYPE == 1U) /* FMCW modulation */
  pll_trigger_ramp();
 80280de:	f000 fb4b 	bl	8028778 <pll_trigger_ramp>
  
#if (FW_MODULATION_TYPE == 0U) /* Doppler modulation */
  /* Start ADC Timer manually as no PLL output signals as no ramps */
  bsp_timer_start(&TIMER_ADC_TRIG);
#else
  pll_release_ramp_trigger();
 80280e2:	f000 fb4b 	bl	802877c <pll_release_ramp_trigger>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 80280e6:	4817      	ldr	r0, [pc, #92]	; (8028144 <bsp_trigger_new_frame+0x1c4>)
 80280e8:	f7fe f8e8 	bl	80262bc <TIMER_Start>
  
  /* Get the raw ADC data */
  get_raw_data();
  
  /* This callback is used to inform upper layers about the beginning of data acquisition process */
  if(bsp_cb.bsp_acq_started_cb != NULL)
 80280ec:	4b16      	ldr	r3, [pc, #88]	; (8028148 <bsp_trigger_new_frame+0x1c8>)
 80280ee:	681b      	ldr	r3, [r3, #0]
 80280f0:	b183      	cbz	r3, 8028114 <bsp_trigger_new_frame+0x194>
  {
    bsp_cb.bsp_acq_started_cb(NULL);
 80280f2:	2000      	movs	r0, #0
  }
}
 80280f4:	b003      	add	sp, #12
 80280f6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  get_raw_data();
  
  /* This callback is used to inform upper layers about the beginning of data acquisition process */
  if(bsp_cb.bsp_acq_started_cb != NULL)
  {
    bsp_cb.bsp_acq_started_cb(NULL);
 80280fa:	4718      	bx	r3

TIMER_STATUS_t bsp_timer_stop_clear(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Stop(handle_timer);
 80280fc:	4808      	ldr	r0, [pc, #32]	; (8028120 <bsp_trigger_new_frame+0x1a0>)
 80280fe:	f7fe f8f3 	bl	80262e8 <TIMER_Stop>
  
  status |= TIMER_Clear(handle_timer);
 8028102:	4807      	ldr	r0, [pc, #28]	; (8028120 <bsp_trigger_new_frame+0x1a0>)
 8028104:	f7fe f9fc 	bl	8026500 <TIMER_Clear>
 8028108:	e743      	b.n	8027f92 <bsp_trigger_new_frame+0x12>
    {
#if (FW_MODULATION_TYPE == 0U) /* Doppler modulation */
      pll_update_configuration(pll_handle, DOPPLER_MODULATION);
      
#elif (FW_MODULATION_TYPE == 1U) /* FMCW modulation */
      pll_update_configuration(pll_handle, FMCW_MODULATION);
 802810a:	4601      	mov	r1, r0
 802810c:	6818      	ldr	r0, [r3, #0]
 802810e:	f000 fb3b 	bl	8028788 <pll_update_configuration>
 8028112:	e7bb      	b.n	802808c <bsp_trigger_new_frame+0x10c>
  /* This callback is used to inform upper layers about the beginning of data acquisition process */
  if(bsp_cb.bsp_acq_started_cb != NULL)
  {
    bsp_cb.bsp_acq_started_cb(NULL);
  }
}
 8028114:	b003      	add	sp, #12
 8028116:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  dma_enable();
  
  /* BGT and PLL Power-up */
  if(bsp_duty_cycle_enable == ENABLED)
  {
    bsp_components_power_up();
 802811a:	f7ff fde9 	bl	8027cf0 <bsp_components_power_up>
 802811e:	e7cd      	b.n	80280bc <bsp_trigger_new_frame+0x13c>
 8028120:	1ffe8b18 	.word	0x1ffe8b18
 8028124:	1ffe8a74 	.word	0x1ffe8a74
 8028128:	1ffe89fc 	.word	0x1ffe89fc
 802812c:	1fff1fa4 	.word	0x1fff1fa4
 8028130:	1ffe8adc 	.word	0x1ffe8adc
 8028134:	1ffe8a0c 	.word	0x1ffe8a0c
 8028138:	1ffe8b54 	.word	0x1ffe8b54
 802813c:	1ffe8b58 	.word	0x1ffe8b58
 8028140:	1ffe888c 	.word	0x1ffe888c
 8028144:	1ffe88d0 	.word	0x1ffe88d0
 8028148:	1fff1fdc 	.word	0x1fff1fdc
 802814c:	1fff1fc0 	.word	0x1fff1fc0

08028150 <CCU43_0_IRQHandler>:

//============================================================================

void triggerFrameISR(void)
{
  bsp_trigger_new_frame();
 8028150:	f7ff bf16 	b.w	8027f80 <bsp_trigger_new_frame>

08028154 <DMA_Event_Handler>:

//============================================================================

void DMA_Event_Handler(XMC_DMA_CH_EVENT_t dma_event)
{
  if((dma_event & XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE) != 0)
 8028154:	0783      	lsls	r3, r0, #30
 8028156:	d400      	bmi.n	802815a <DMA_Event_Handler+0x6>
 8028158:	4770      	bx	lr
}

//============================================================================

void DMA_Event_Handler(XMC_DMA_CH_EVENT_t dma_event)
{
 802815a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

TIMER_STATUS_t bsp_timer_stop_clear(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Stop(handle_timer);
 802815e:	4879      	ldr	r0, [pc, #484]	; (8028344 <DMA_Event_Handler+0x1f0>)
 8028160:	4f79      	ldr	r7, [pc, #484]	; (8028348 <DMA_Event_Handler+0x1f4>)
    * we don't need to care which interrupts are triggered by DMA.
    * this timer is source peripheral's trigger to request DMA transaction.
    * Even though DMA error interrupt, we'd better stop the this timer. */
    bsp_timer_stop_clear(&TIMER_ADC_TRIG);
    
    chirp_count++;
 8028162:	f8df 8240 	ldr.w	r8, [pc, #576]	; 80283a4 <DMA_Event_Handler+0x250>
 8028166:	4e79      	ldr	r6, [pc, #484]	; (802834c <DMA_Event_Handler+0x1f8>)
 8028168:	4d79      	ldr	r5, [pc, #484]	; (8028350 <DMA_Event_Handler+0x1fc>)
 802816a:	4c7a      	ldr	r4, [pc, #488]	; (8028354 <DMA_Event_Handler+0x200>)

TIMER_STATUS_t bsp_timer_stop_clear(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Stop(handle_timer);
 802816c:	f7fe f8bc 	bl	80262e8 <TIMER_Stop>
  
  status |= TIMER_Clear(handle_timer);
 8028170:	4874      	ldr	r0, [pc, #464]	; (8028344 <DMA_Event_Handler+0x1f0>)
 8028172:	f7fe f9c5 	bl	8026500 <TIMER_Clear>
 */
__STATIC_INLINE void DMA_CH_Disable(DMA_CH_t *const obj)
{
  XMC_ASSERT("DMA_CH_Disable: NULL DMA_CH_t object", (obj != NULL));

  XMC_DMA_CH_Disable(obj->dma_global->dma, obj->ch_num);
 8028176:	683a      	ldr	r2, [r7, #0]
    * we don't need to care which interrupts are triggered by DMA.
    * this timer is source peripheral's trigger to request DMA transaction.
    * Even though DMA error interrupt, we'd better stop the this timer. */
    bsp_timer_stop_clear(&TIMER_ADC_TRIG);
    
    chirp_count++;
 8028178:	f8d8 3000 	ldr.w	r3, [r8]
 802817c:	6810      	ldr	r0, [r2, #0]
 802817e:	7b39      	ldrb	r1, [r7, #12]
 8028180:	3301      	adds	r3, #1
 8028182:	f8c8 3000 	str.w	r3, [r8]
 8028186:	f7f9 fd67 	bl	8021c58 <XMC_DMA_CH_Disable>
 802818a:	6833      	ldr	r3, [r6, #0]
 802818c:	7b31      	ldrb	r1, [r6, #12]
 802818e:	6818      	ldr	r0, [r3, #0]
 8028190:	f7f9 fd62 	bl	8021c58 <XMC_DMA_CH_Disable>
 8028194:	682b      	ldr	r3, [r5, #0]
 8028196:	7b29      	ldrb	r1, [r5, #12]
 8028198:	6818      	ldr	r0, [r3, #0]
 802819a:	f7f9 fd5d 	bl	8021c58 <XMC_DMA_CH_Disable>
 802819e:	6823      	ldr	r3, [r4, #0]
 80281a0:	7b21      	ldrb	r1, [r4, #12]
 80281a2:	6818      	ldr	r0, [r3, #0]
 80281a4:	f7f9 fd58 	bl	8021c58 <XMC_DMA_CH_Disable>

//============================================================================

static void dma_reset_dlr(void)
{
  XMC_DMA_CH_ClearSourcePeripheralRequest(DMA_CH_I1.dma_global->dma, DMA_CH_I1.ch_num);
 80281a8:	683b      	ldr	r3, [r7, #0]
 80281aa:	7b39      	ldrb	r1, [r7, #12]
 80281ac:	6818      	ldr	r0, [r3, #0]
 80281ae:	f7f9 fed1 	bl	8021f54 <XMC_DMA_CH_ClearSourcePeripheralRequest>
  XMC_DMA_CH_ClearSourcePeripheralRequest(DMA_CH_Q1.dma_global->dma, DMA_CH_Q1.ch_num);
 80281b2:	6833      	ldr	r3, [r6, #0]
 80281b4:	7b31      	ldrb	r1, [r6, #12]
 80281b6:	6818      	ldr	r0, [r3, #0]
 80281b8:	f7f9 fecc 	bl	8021f54 <XMC_DMA_CH_ClearSourcePeripheralRequest>
  XMC_DMA_CH_ClearSourcePeripheralRequest(DMA_CH_I2.dma_global->dma, DMA_CH_I2.ch_num);
 80281bc:	682b      	ldr	r3, [r5, #0]
 80281be:	7b29      	ldrb	r1, [r5, #12]
 80281c0:	6818      	ldr	r0, [r3, #0]
 80281c2:	f7f9 fec7 	bl	8021f54 <XMC_DMA_CH_ClearSourcePeripheralRequest>
  XMC_DMA_CH_ClearSourcePeripheralRequest(DMA_CH_Q2.dma_global->dma, DMA_CH_Q2.ch_num);
 80281c6:	6823      	ldr	r3, [r4, #0]
 80281c8:	7b21      	ldrb	r1, [r4, #12]
 80281ca:	6818      	ldr	r0, [r3, #0]
 80281cc:	f7f9 fec2 	bl	8021f54 <XMC_DMA_CH_ClearSourcePeripheralRequest>
    * We should consider the pending request from external peripheral. */
    dma_reset_dlr();
    
#if (FW_MODULATION_TYPE == 1U) /* FMCW modulation */
    
    acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 80281d0:	f7f7 ff84 	bl	80200dc <ds_get_active_acq_buf>
    
    if (chirp_count < p_acq_buf->params.num_of_chirps_per_frame)
 80281d4:	f8d8 1000 	ldr.w	r1, [r8]
 80281d8:	8883      	ldrh	r3, [r0, #4]
 80281da:	428b      	cmp	r3, r1
 80281dc:	d867      	bhi.n	80282ae <DMA_Event_Handler+0x15a>
      dma_enable();
    }
    else
#endif
    {
      ADC_MEASUREMENT_ADV_SoftwareTrigger(&ADC_MEASUREMENT_SCAN);
 80281de:	485e      	ldr	r0, [pc, #376]	; (8028358 <DMA_Event_Handler+0x204>)
 80281e0:	f7ff f814 	bl	802720c <ADC_MEASUREMENT_ADV_SoftwareTrigger>
      
      bsp_frame_counter++;
 80281e4:	4a5d      	ldr	r2, [pc, #372]	; (802835c <DMA_Event_Handler+0x208>)

static void done_sampling(void)
{
  uint16_t  lbgt_ana_command = 0;
  
  if(bsp_duty_cycle_enable == ENABLED)
 80281e6:	495e      	ldr	r1, [pc, #376]	; (8028360 <DMA_Event_Handler+0x20c>)
    else
#endif
    {
      ADC_MEASUREMENT_ADV_SoftwareTrigger(&ADC_MEASUREMENT_SCAN);
      
      bsp_frame_counter++;
 80281e8:	8813      	ldrh	r3, [r2, #0]

static void done_sampling(void)
{
  uint16_t  lbgt_ana_command = 0;
  
  if(bsp_duty_cycle_enable == ENABLED)
 80281ea:	7809      	ldrb	r1, [r1, #0]
    else
#endif
    {
      ADC_MEASUREMENT_ADV_SoftwareTrigger(&ADC_MEASUREMENT_SCAN);
      
      bsp_frame_counter++;
 80281ec:	3301      	adds	r3, #1
 80281ee:	b29b      	uxth	r3, r3
      
      chirp_count = 0;
 80281f0:	2000      	movs	r0, #0

static void done_sampling(void)
{
  uint16_t  lbgt_ana_command = 0;
  
  if(bsp_duty_cycle_enable == ENABLED)
 80281f2:	2901      	cmp	r1, #1
    else
#endif
    {
      ADC_MEASUREMENT_ADV_SoftwareTrigger(&ADC_MEASUREMENT_SCAN);
      
      bsp_frame_counter++;
 80281f4:	8013      	strh	r3, [r2, #0]
      
      chirp_count = 0;
 80281f6:	f8c8 0000 	str.w	r0, [r8]

static void done_sampling(void)
{
  uint16_t  lbgt_ana_command = 0;
  
  if(bsp_duty_cycle_enable == ENABLED)
 80281fa:	f000 8081 	beq.w	8028300 <DMA_Event_Handler+0x1ac>
  {
    bsp_components_power_down();
  }
  
  lbgt_ana_command = bgt_get_ana_config();
 80281fe:	f7ff fbf9 	bl	80279f4 <bgt_get_ana_config>
 8028202:	4b58      	ldr	r3, [pc, #352]	; (8028364 <DMA_Event_Handler+0x210>)
{
  uint16_t result;
  extern XMC_VADC_GROUP_t *const group_ptrs[XMC_VADC_MAXIMUM_NUM_GROUPS];
  XMC_ASSERT("ADC_MEASUREMENT_ADV_GetResult:Invalid handle_ptr", (handle_ptr != NULL))

  result = XMC_VADC_GROUP_GetResult(group_ptrs[handle_ptr->group_index],
 8028204:	4a58      	ldr	r2, [pc, #352]	; (8028368 <DMA_Event_Handler+0x214>)
                                    (uint32_t) handle_ptr->ch_handle->result_reg_number);
 8028206:	681c      	ldr	r4, [r3, #0]
{
  uint16_t result;
  extern XMC_VADC_GROUP_t *const group_ptrs[XMC_VADC_MAXIMUM_NUM_GROUPS];
  XMC_ASSERT("ADC_MEASUREMENT_ADV_GetResult:Invalid handle_ptr", (handle_ptr != NULL))

  result = XMC_VADC_GROUP_GetResult(group_ptrs[handle_ptr->group_index],
 8028208:	7a19      	ldrb	r1, [r3, #8]
                                    (uint32_t) handle_ptr->ch_handle->result_reg_number);
 802820a:	78a3      	ldrb	r3, [r4, #2]
{
  uint16_t result;
  extern XMC_VADC_GROUP_t *const group_ptrs[XMC_VADC_MAXIMUM_NUM_GROUPS];
  XMC_ASSERT("ADC_MEASUREMENT_ADV_GetResult:Invalid handle_ptr", (handle_ptr != NULL))

  result = XMC_VADC_GROUP_GetResult(group_ptrs[handle_ptr->group_index],
 802820c:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
  bsp_bgt_ana_out[lbgt_ana_command] = (ADC_MEASUREMENT_ADV_GetResult(&ADC_MEASUREMENT_SCAN_BGT24_ANA_handle));
 8028210:	4c56      	ldr	r4, [pc, #344]	; (802836c <DMA_Event_Handler+0x218>)
 8028212:	f003 030f 	and.w	r3, r3, #15
                                                                const uint32_t res_reg)
{
  XMC_ASSERT("XMC_VADC_GROUP_GetResult:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_GetResult:Wrong Result Register", ((res_reg) < XMC_VADC_NUM_RESULT_REGISTERS))

  return ((XMC_VADC_RESULT_SIZE_t)group_ptr->RES[res_reg]);
 8028216:	33c0      	adds	r3, #192	; 0xc0
 8028218:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 802821c:	f824 3010 	strh.w	r3, [r4, r0, lsl #1]
  
  if (bsp_bgt_ana_out[2] == 0)
 8028220:	88a3      	ldrh	r3, [r4, #4]
 8028222:	2b00      	cmp	r3, #0
 8028224:	d03e      	beq.n	80282a4 <DMA_Event_Handler+0x150>
  {
    bgt_ana_vref_tx();
  }
  else if (lbgt_ana_command == 2)
 8028226:	2802      	cmp	r0, #2
 8028228:	d067      	beq.n	80282fa <DMA_Event_Handler+0x1a6>
  {
    bgt_ana_vout_tx();
  }
  else
  {
    bgt_ana_temp();
 802822a:	f7ff fbdd 	bl	80279e8 <bgt_ana_temp>
  }
  
  /* Calculate the BGT temperature and output power based on the BGT ANA MUX pin ADC sampled values */
  bsp_bgt_temperature_C = (0.2629f * (1000 * 3.3f * bsp_bgt_ana_out[0] / 4095.0f) - 364.32f);
 802822e:	8823      	ldrh	r3, [r4, #0]
 8028230:	ed9f 5a4f 	vldr	s10, [pc, #316]	; 8028370 <DMA_Event_Handler+0x21c>
 8028234:	eddf 5a4f 	vldr	s11, [pc, #316]	; 8028374 <DMA_Event_Handler+0x220>
 8028238:	ed9f 6a4f 	vldr	s12, [pc, #316]	; 8028378 <DMA_Event_Handler+0x224>
 802823c:	eddf 6a4f 	vldr	s13, [pc, #316]	; 802837c <DMA_Event_Handler+0x228>
  
  if((bsp_bgt_ana_out[1] - bsp_bgt_ana_out[2]) >= 0)
 8028240:	88a2      	ldrh	r2, [r4, #4]
  {
    bgt_ana_temp();
  }
  
  /* Calculate the BGT temperature and output power based on the BGT ANA MUX pin ADC sampled values */
  bsp_bgt_temperature_C = (0.2629f * (1000 * 3.3f * bsp_bgt_ana_out[0] / 4095.0f) - 364.32f);
 8028242:	494f      	ldr	r1, [pc, #316]	; (8028380 <DMA_Event_Handler+0x22c>)
 8028244:	ee07 3a90 	vmov	s15, r3
 8028248:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  
  if((bsp_bgt_ana_out[1] - bsp_bgt_ana_out[2]) >= 0)
 802824c:	8863      	ldrh	r3, [r4, #2]
  {
    bgt_ana_temp();
  }
  
  /* Calculate the BGT temperature and output power based on the BGT ANA MUX pin ADC sampled values */
  bsp_bgt_temperature_C = (0.2629f * (1000 * 3.3f * bsp_bgt_ana_out[0] / 4095.0f) - 364.32f);
 802824e:	ee67 7a05 	vmul.f32	s15, s14, s10
  
  if((bsp_bgt_ana_out[1] - bsp_bgt_ana_out[2]) >= 0)
 8028252:	1a9b      	subs	r3, r3, r2
  {
    bgt_ana_temp();
  }
  
  /* Calculate the BGT temperature and output power based on the BGT ANA MUX pin ADC sampled values */
  bsp_bgt_temperature_C = (0.2629f * (1000 * 3.3f * bsp_bgt_ana_out[0] / 4095.0f) - 364.32f);
 8028254:	eec7 7aa5 	vdiv.f32	s15, s15, s11
 8028258:	eee7 6a86 	vfma.f32	s13, s15, s12
 802825c:	edc1 6a00 	vstr	s13, [r1]
  
  if((bsp_bgt_ana_out[1] - bsp_bgt_ana_out[2]) >= 0)
 8028260:	d416      	bmi.n	8028290 <DMA_Event_Handler+0x13c>
  {
    bsp_bgt_vout_tx_power_dBm = 5.24f * logf(1000 * 3.3f / 4095.0f * (bsp_bgt_ana_out[1] - bsp_bgt_ana_out[2])) - 23.74f;
 8028262:	ee07 3a90 	vmov	s15, r3
 8028266:	ed9f 7a47 	vldr	s14, [pc, #284]	; 8028384 <DMA_Event_Handler+0x230>
 802826a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802826e:	ee67 7a87 	vmul.f32	s15, s15, s14
 8028272:	ee17 0a90 	vmov	r0, s15
 8028276:	f001 fa73 	bl	8029760 <logf>
 802827a:	ed9f 7a43 	vldr	s14, [pc, #268]	; 8028388 <DMA_Event_Handler+0x234>
 802827e:	eddf 7a43 	vldr	s15, [pc, #268]	; 802838c <DMA_Event_Handler+0x238>
 8028282:	4b43      	ldr	r3, [pc, #268]	; (8028390 <DMA_Event_Handler+0x23c>)
 8028284:	ee06 0a90 	vmov	s13, r0
 8028288:	eee6 7a87 	vfma.f32	s15, s13, s14
 802828c:	edc3 7a00 	vstr	s15, [r3]
  }
  
  /* This callback is used to inform upper layers that a valid data is available and ADC sampling is completed */
  if((bsp_cb.bsp_acq_done_cb != NULL) & (watchdog_status == 0))
 8028290:	4a40      	ldr	r2, [pc, #256]	; (8028394 <DMA_Event_Handler+0x240>)
 8028292:	4b41      	ldr	r3, [pc, #260]	; (8028398 <DMA_Event_Handler+0x244>)
 8028294:	7812      	ldrb	r2, [r2, #0]
 8028296:	685b      	ldr	r3, [r3, #4]
 8028298:	b93a      	cbnz	r2, 80282aa <DMA_Event_Handler+0x156>
 802829a:	b133      	cbz	r3, 80282aa <DMA_Event_Handler+0x156>
  {
    bsp_cb.bsp_acq_done_cb(NULL);
 802829c:	2000      	movs	r0, #0
      chirp_count = 0;
      
      done_sampling();
    }
  }
}
 802829e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  }
  
  /* This callback is used to inform upper layers that a valid data is available and ADC sampling is completed */
  if((bsp_cb.bsp_acq_done_cb != NULL) & (watchdog_status == 0))
  {
    bsp_cb.bsp_acq_done_cb(NULL);
 80282a2:	4718      	bx	r3
  lbgt_ana_command = bgt_get_ana_config();
  bsp_bgt_ana_out[lbgt_ana_command] = (ADC_MEASUREMENT_ADV_GetResult(&ADC_MEASUREMENT_SCAN_BGT24_ANA_handle));
  
  if (bsp_bgt_ana_out[2] == 0)
  {
    bgt_ana_vref_tx();
 80282a4:	f7ff fba4 	bl	80279f0 <bgt_ana_vref_tx>
 80282a8:	e7c1      	b.n	802822e <DMA_Event_Handler+0xda>
 80282aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
    
    if (chirp_count < p_acq_buf->params.num_of_chirps_per_frame)
    {
      /* Reconfiguration of DMA destination offset */
      bsp_dma_set_destination_addr_from_acq_buf_obj(p_acq_buf, chirp_count);
 80282ae:	f7ff fe0b 	bl	8027ec8 <bsp_dma_set_destination_addr_from_acq_buf_obj>
 */
__STATIC_INLINE void DMA_CH_Enable(DMA_CH_t *const obj)
{
  XMC_ASSERT("DMA_CH_Enable: NULL DMA_CH_t object", (obj != NULL));

  XMC_DMA_CH_Enable(obj->dma_global->dma, obj->ch_num);
 80282b2:	6831      	ldr	r1, [r6, #0]
 80282b4:	682a      	ldr	r2, [r5, #0]
 80282b6:	6823      	ldr	r3, [r4, #0]
 80282b8:	f8d7 8000 	ldr.w	r8, [r7]
 80282bc:	f896 c00c 	ldrb.w	ip, [r6, #12]
 80282c0:	7b28      	ldrb	r0, [r5, #12]
 80282c2:	f894 e00c 	ldrb.w	lr, [r4, #12]
 80282c6:	7b3f      	ldrb	r7, [r7, #12]
 80282c8:	f8d8 6000 	ldr.w	r6, [r8]
 80282cc:	680c      	ldr	r4, [r1, #0]
 80282ce:	6811      	ldr	r1, [r2, #0]
 80282d0:	681a      	ldr	r2, [r3, #0]
 80282d2:	f240 1301 	movw	r3, #257	; 0x101
 80282d6:	fa03 f707 	lsl.w	r7, r3, r7
 80282da:	fa03 f50c 	lsl.w	r5, r3, ip
 80282de:	fa03 f000 	lsl.w	r0, r3, r0
 80282e2:	fa03 f30e 	lsl.w	r3, r3, lr
 80282e6:	f8c6 73a0 	str.w	r7, [r6, #928]	; 0x3a0
 80282ea:	f8c4 53a0 	str.w	r5, [r4, #928]	; 0x3a0
 80282ee:	f8c1 03a0 	str.w	r0, [r1, #928]	; 0x3a0
 80282f2:	f8c2 33a0 	str.w	r3, [r2, #928]	; 0x3a0
 80282f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  {
    bgt_ana_vref_tx();
  }
  else if (lbgt_ana_command == 2)
  {
    bgt_ana_vout_tx();
 80282fa:	f7ff fb77 	bl	80279ec <bgt_ana_vout_tx>
 80282fe:	e796      	b.n	802822e <DMA_Event_Handler+0xda>

//============================================================================

void bsp_components_power_down(void)
{
  pll_disable_ramps(pll_handle);
 8028300:	4b26      	ldr	r3, [pc, #152]	; (802839c <DMA_Event_Handler+0x248>)
 8028302:	6818      	ldr	r0, [r3, #0]
 8028304:	f000 fa34 	bl	8028770 <pll_disable_ramps>
  
  /* To avoid out of band spurs */
  bgt_lowest_power_with_q2_disable();
 8028308:	f7ff fb76 	bl	80279f8 <bgt_lowest_power_with_q2_disable>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 802830c:	4824      	ldr	r0, [pc, #144]	; (80283a0 <DMA_Event_Handler+0x24c>)
 802830e:	f7fe f8e1 	bl	80264d4 <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 8028312:	4823      	ldr	r0, [pc, #140]	; (80283a0 <DMA_Event_Handler+0x24c>)
 8028314:	f241 3188 	movw	r1, #5000	; 0x1388
 8028318:	f7fe f81a 	bl	8026350 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 802831c:	4820      	ldr	r0, [pc, #128]	; (80283a0 <DMA_Event_Handler+0x24c>)
 802831e:	f7fd ffcd 	bl	80262bc <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 8028322:	481f      	ldr	r0, [pc, #124]	; (80283a0 <DMA_Event_Handler+0x24c>)
 8028324:	f7fe f8c4 	bl	80264b0 <TIMER_GetInterruptStatus>
 8028328:	2800      	cmp	r0, #0
 802832a:	d0fa      	beq.n	8028322 <DMA_Event_Handler+0x1ce>
  
  TIMER_Stop(&TIMER_DELAY);
 802832c:	481c      	ldr	r0, [pc, #112]	; (80283a0 <DMA_Event_Handler+0x24c>)
 802832e:	f7fd ffdb 	bl	80262e8 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 8028332:	481b      	ldr	r0, [pc, #108]	; (80283a0 <DMA_Event_Handler+0x24c>)
 8028334:	f7fe f8e4 	bl	8026500 <TIMER_Clear>
  /* To avoid out of band spurs */
  bgt_lowest_power_with_q2_disable();
  bsp_time_delay_usec(50U);           /* Delay for BGT Power down SPI settings */
  
  /* Power-down BGT */
  bgt_power_down();
 8028338:	f7ff fb34 	bl	80279a4 <bgt_power_down>
  
  /* Disable PLL */
  pll_power_down();
 802833c:	f000 fa22 	bl	8028784 <pll_power_down>
 8028340:	e75d      	b.n	80281fe <DMA_Event_Handler+0xaa>
 8028342:	bf00      	nop
 8028344:	1ffe8b18 	.word	0x1ffe8b18
 8028348:	1ffe8a74 	.word	0x1ffe8a74
 802834c:	1ffe89fc 	.word	0x1ffe89fc
 8028350:	1ffe8adc 	.word	0x1ffe8adc
 8028354:	1ffe8a0c 	.word	0x1ffe8a0c
 8028358:	0802b0c4 	.word	0x0802b0c4
 802835c:	1fff1fb0 	.word	0x1fff1fb0
 8028360:	1ffe8b54 	.word	0x1ffe8b54
 8028364:	0802b13c 	.word	0x0802b13c
 8028368:	0802b048 	.word	0x0802b048
 802836c:	1fff1fc8 	.word	0x1fff1fc8
 8028370:	454e4000 	.word	0x454e4000
 8028374:	457ff000 	.word	0x457ff000
 8028378:	3e869ad4 	.word	0x3e869ad4
 802837c:	c3b628f6 	.word	0xc3b628f6
 8028380:	1fff1fd0 	.word	0x1fff1fd0
 8028384:	3f4e4ce5 	.word	0x3f4e4ce5
 8028388:	40a7ae14 	.word	0x40a7ae14
 802838c:	c1bdeb85 	.word	0xc1bdeb85
 8028390:	1fff1fc4 	.word	0x1fff1fc4
 8028394:	1fff1fa4 	.word	0x1fff1fa4
 8028398:	1fff1fdc 	.word	0x1fff1fdc
 802839c:	1ffe8b58 	.word	0x1ffe8b58
 80283a0:	1ffe888c 	.word	0x1ffe888c
 80283a4:	1fff1fa8 	.word	0x1fff1fa8

080283a8 <bsp_usb_init>:
}

//============================================================================

uint8_t bsp_usb_init(uint32_t timeout_delay)
{
 80283a8:	b538      	push	{r3, r4, r5, lr}
 80283aa:	4605      	mov	r5, r0
  uint32_t time_out_cnt = 0;
  
  if (USBD_VCOM_Connect() != USBD_VCOM_STATUS_SUCCESS)
 80283ac:	f7fd f832 	bl	8025414 <USBD_VCOM_Connect>
 80283b0:	b958      	cbnz	r0, 80283ca <bsp_usb_init+0x22>
  {
    return (1); /* Fail */
  }
  
  while (time_out_cnt < timeout_delay)
 80283b2:	b155      	cbz	r5, 80283ca <bsp_usb_init+0x22>
 80283b4:	4604      	mov	r4, r0
 80283b6:	e001      	b.n	80283bc <bsp_usb_init+0x14>
 80283b8:	42ac      	cmp	r4, r5
 80283ba:	d006      	beq.n	80283ca <bsp_usb_init+0x22>
  {
    if (USBD_VCOM_IsEnumDone())
 80283bc:	f7fc ffca 	bl	8025354 <USBD_VCOM_IsEnumDone>
    {
      return (0); /* Success */
    }
    
    time_out_cnt++;
 80283c0:	3401      	adds	r4, #1
    return (1); /* Fail */
  }
  
  while (time_out_cnt < timeout_delay)
  {
    if (USBD_VCOM_IsEnumDone())
 80283c2:	2800      	cmp	r0, #0
 80283c4:	d0f8      	beq.n	80283b8 <bsp_usb_init+0x10>
    {
      return (0); /* Success */
 80283c6:	2000      	movs	r0, #0
    
    time_out_cnt++;
  }
  
  return (1); /* Fail */
}
 80283c8:	bd38      	pop	{r3, r4, r5, pc}
{
  uint32_t time_out_cnt = 0;
  
  if (USBD_VCOM_Connect() != USBD_VCOM_STATUS_SUCCESS)
  {
    return (1); /* Fail */
 80283ca:	2001      	movs	r0, #1
 80283cc:	bd38      	pop	{r3, r4, r5, pc}
 80283ce:	bf00      	nop

080283d0 <bsp_bgt_get_temp_value>:

//============================================================================

float32_t bsp_bgt_get_temp_value(void)
{
  return (bsp_bgt_temperature_C);
 80283d0:	4b01      	ldr	r3, [pc, #4]	; (80283d8 <bsp_bgt_get_temp_value+0x8>)
}
 80283d2:	6818      	ldr	r0, [r3, #0]
 80283d4:	4770      	bx	lr
 80283d6:	bf00      	nop
 80283d8:	1fff1fd0 	.word	0x1fff1fd0

080283dc <bsp_bgt_get_txpower_value>:

//============================================================================

float32_t bsp_bgt_get_txpower_value(void)
{
  return (bsp_bgt_vout_tx_power_dBm);
 80283dc:	4b01      	ldr	r3, [pc, #4]	; (80283e4 <bsp_bgt_get_txpower_value+0x8>)
}
 80283de:	6818      	ldr	r0, [r3, #0]
 80283e0:	4770      	bx	lr
 80283e2:	bf00      	nop
 80283e4:	1fff1fc4 	.word	0x1fff1fc4

080283e8 <bsp_set_num_samples_per_dma_transfer>:

//============================================================================

void bsp_set_num_samples_per_dma_transfer(uint32_t num_samples_per_dma_transfer)
{
  bsp_num_samples_per_dma_transfer = num_samples_per_dma_transfer;
 80283e8:	4b01      	ldr	r3, [pc, #4]	; (80283f0 <bsp_set_num_samples_per_dma_transfer+0x8>)
 80283ea:	6018      	str	r0, [r3, #0]
 80283ec:	4770      	bx	lr
 80283ee:	bf00      	nop
 80283f0:	1fff1fc0 	.word	0x1fff1fc0

080283f4 <bsp_set_num_chirps_per_frame>:

//============================================================================

void bsp_set_num_chirps_per_frame(uint32_t num_chirps_per_frame)
{
  pll_set_num_chirps_per_frame(num_chirps_per_frame);
 80283f4:	f000 ba64 	b.w	80288c0 <pll_set_num_chirps_per_frame>

080283f8 <bsp_get_frame_counter>:

//============================================================================

uint16_t bsp_get_frame_counter(void)
{
  return (bsp_frame_counter);
 80283f8:	4b01      	ldr	r3, [pc, #4]	; (8028400 <bsp_get_frame_counter+0x8>)
 80283fa:	8818      	ldrh	r0, [r3, #0]
}
 80283fc:	b280      	uxth	r0, r0
 80283fe:	4770      	bx	lr
 8028400:	1fff1fb0 	.word	0x1fff1fb0

08028404 <bsp_reset_frame_counter>:

//============================================================================

void bsp_reset_frame_counter(void)
{
  bsp_frame_counter = 0;
 8028404:	4b01      	ldr	r3, [pc, #4]	; (802840c <bsp_reset_frame_counter+0x8>)
 8028406:	2200      	movs	r2, #0
 8028408:	801a      	strh	r2, [r3, #0]
 802840a:	4770      	bx	lr
 802840c:	1fff1fb0 	.word	0x1fff1fb0

08028410 <bsp_set_duty_cycle_enable_flag>:

//============================================================================

void bsp_set_duty_cycle_enable_flag(const uint8_t flag)
{
  bsp_duty_cycle_enable = flag;
 8028410:	4b01      	ldr	r3, [pc, #4]	; (8028418 <bsp_set_duty_cycle_enable_flag+0x8>)
 8028412:	7018      	strb	r0, [r3, #0]
 8028414:	4770      	bx	lr
 8028416:	bf00      	nop
 8028418:	1ffe8b54 	.word	0x1ffe8b54

0802841c <bsp_register_callback>:
uint8_t bsp_register_callback(Bsp_Callback_ID_t cb_id, void (*pcallback)(void *parameter))
{
  uint8_t status = 0;
  
  /* Check if he callback function is valid */
  if(pcallback == NULL)
 802841c:	b139      	cbz	r1, 802842e <bsp_register_callback+0x12>
  {
    return(1);
  }
  
  /* Register user callback function based on callback ID */
  switch (cb_id)
 802841e:	2801      	cmp	r0, #1
 8028420:	d007      	beq.n	8028432 <bsp_register_callback+0x16>
 8028422:	2802      	cmp	r0, #2
 8028424:	d103      	bne.n	802842e <bsp_register_callback+0x12>
  case BSP_ACQUISITION_STARTED_CB_ID:
    bsp_cb.bsp_acq_started_cb = pcallback;
    break;
    
  case BSP_ACQUISITION_DONE_CB_ID:
    bsp_cb.bsp_acq_done_cb = pcallback;
 8028426:	4b05      	ldr	r3, [pc, #20]	; (802843c <bsp_register_callback+0x20>)

//============================================================================

uint8_t bsp_register_callback(Bsp_Callback_ID_t cb_id, void (*pcallback)(void *parameter))
{
  uint8_t status = 0;
 8028428:	2000      	movs	r0, #0
  case BSP_ACQUISITION_STARTED_CB_ID:
    bsp_cb.bsp_acq_started_cb = pcallback;
    break;
    
  case BSP_ACQUISITION_DONE_CB_ID:
    bsp_cb.bsp_acq_done_cb = pcallback;
 802842a:	6059      	str	r1, [r3, #4]
    break;
 802842c:	4770      	bx	lr
    
  default:
    /* Return error status */
    status =  1;
 802842e:	2001      	movs	r0, #1
    break;
  }
  
  return (status);
}
 8028430:	4770      	bx	lr
  
  /* Register user callback function based on callback ID */
  switch (cb_id)
  {
  case BSP_ACQUISITION_STARTED_CB_ID:
    bsp_cb.bsp_acq_started_cb = pcallback;
 8028432:	4b02      	ldr	r3, [pc, #8]	; (802843c <bsp_register_callback+0x20>)

//============================================================================

uint8_t bsp_register_callback(Bsp_Callback_ID_t cb_id, void (*pcallback)(void *parameter))
{
  uint8_t status = 0;
 8028434:	2000      	movs	r0, #0
  
  /* Register user callback function based on callback ID */
  switch (cb_id)
  {
  case BSP_ACQUISITION_STARTED_CB_ID:
    bsp_cb.bsp_acq_started_cb = pcallback;
 8028436:	6019      	str	r1, [r3, #0]
    break;
 8028438:	4770      	bx	lr
 802843a:	bf00      	nop
 802843c:	1fff1fdc 	.word	0x1fff1fdc

08028440 <bsp_led_on>:
}

//============================================================================

void bsp_led_on(void)
{
 8028440:	4b03      	ldr	r3, [pc, #12]	; (8028450 <bsp_led_on+0x10>)
 8028442:	7c19      	ldrb	r1, [r3, #16]
 8028444:	681a      	ldr	r2, [r3, #0]
 8028446:	2301      	movs	r3, #1
 8028448:	408b      	lsls	r3, r1
 802844a:	6053      	str	r3, [r2, #4]
 802844c:	4770      	bx	lr
 802844e:	bf00      	nop
 8028450:	0802afc0 	.word	0x0802afc0

08028454 <bsp_led_off>:
}

//============================================================================

void bsp_led_off(void)
{
 8028454:	4b03      	ldr	r3, [pc, #12]	; (8028464 <bsp_led_off+0x10>)

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 8028456:	7c19      	ldrb	r1, [r3, #16]
 8028458:	681a      	ldr	r2, [r3, #0]
 802845a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 802845e:	408b      	lsls	r3, r1
 8028460:	6053      	str	r3, [r2, #4]
 8028462:	4770      	bx	lr
 8028464:	0802afc0 	.word	0x0802afc0

08028468 <CCU43_1_IRQHandler>:
}

//============================================================================

void watchdog_isr(void)
{
 8028468:	b508      	push	{r3, lr}
  if(chirp_count < (ds_device_get_settings()->pll_num_of_chirps_per_frame-1))
 802846a:	f7f7 fdcd 	bl	8020008 <ds_device_get_settings>
 802846e:	4a08      	ldr	r2, [pc, #32]	; (8028490 <CCU43_1_IRQHandler+0x28>)
 8028470:	6943      	ldr	r3, [r0, #20]
 8028472:	6812      	ldr	r2, [r2, #0]
 8028474:	3b01      	subs	r3, #1
 8028476:	4293      	cmp	r3, r2
 8028478:	d902      	bls.n	8028480 <CCU43_1_IRQHandler+0x18>
  {
    watchdog_status = 1;
 802847a:	4b06      	ldr	r3, [pc, #24]	; (8028494 <CCU43_1_IRQHandler+0x2c>)
 802847c:	2201      	movs	r2, #1
 802847e:	701a      	strb	r2, [r3, #0]

TIMER_STATUS_t timer_stop_clear(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Stop(handle_timer);
 8028480:	4805      	ldr	r0, [pc, #20]	; (8028498 <CCU43_1_IRQHandler+0x30>)
 8028482:	f7fd ff31 	bl	80262e8 <TIMER_Stop>
  
  status |= TIMER_Clear(handle_timer);
 8028486:	4804      	ldr	r0, [pc, #16]	; (8028498 <CCU43_1_IRQHandler+0x30>)
  {
    watchdog_status = 1;
  }
  
  timer_stop_clear(&TIMER_WATCHDOG);
}
 8028488:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Stop(handle_timer);
  
  status |= TIMER_Clear(handle_timer);
 802848c:	f7fe b838 	b.w	8026500 <TIMER_Clear>
 8028490:	1fff1fa8 	.word	0x1fff1fa8
 8028494:	1fff1fa4 	.word	0x1fff1fa4
 8028498:	1ffe88d0 	.word	0x1ffe88d0

0802849c <pga_init>:
 */

Pga_Status_t pga_init(uint16_t gain_level)
{
  /* Initialize the PGA112 device */
  return pga112_init(gain_level);
 802849c:	f000 ba92 	b.w	80289c4 <pga112_init>

080284a0 <pga_set_gain>:
//============================================================================

Pga_Status_t pga_set_gain(uint16_t gain_level)
{
  /* Updates the PGA112 gain */
  return pga112_set_gain(gain_level);
 80284a0:	f000 baca 	b.w	8028a38 <pga112_set_gain>

080284a4 <pga_ldo_enable>:
}

//============================================================================

void pga_ldo_enable(void)
{
 80284a4:	4a07      	ldr	r2, [pc, #28]	; (80284c4 <pga_ldo_enable+0x20>)
 80284a6:	4b08      	ldr	r3, [pc, #32]	; (80284c8 <pga_ldo_enable+0x24>)

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 80284a8:	7c10      	ldrb	r0, [r2, #16]
 80284aa:	6811      	ldr	r1, [r2, #0]
 80284ac:	681a      	ldr	r2, [r3, #0]
 80284ae:	b410      	push	{r4}
 80284b0:	7c1c      	ldrb	r4, [r3, #16]
 80284b2:	2301      	movs	r3, #1
 80284b4:	fa03 f000 	lsl.w	r0, r3, r0
 80284b8:	40a3      	lsls	r3, r4
 80284ba:	6048      	str	r0, [r1, #4]
  DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_SPI_M_CS_PGA);
  DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_PGA_LDO_ENABLE);
}
 80284bc:	f85d 4b04 	ldr.w	r4, [sp], #4
 80284c0:	6053      	str	r3, [r2, #4]
 80284c2:	4770      	bx	lr
 80284c4:	0802af34 	.word	0x0802af34
 80284c8:	0802afd4 	.word	0x0802afd4
 80284cc:	00000000 	.word	0x00000000

080284d0 <pll_init>:
   3. EXPORTED FUNCTIONS
==============================================================================
 */

void pll_init(void* pll_handle)
{
 80284d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  Lmx249x_Object_t* lmx249x_pll = (Lmx249x_Object_t*)pll_handle;
  Lmx249x_Hardware_Setup_t s_sPLLHardwareSetup;
  
  /* Send general configuration to PLL */
  /* --------------------------------- */
  s_sPLLHardwareSetup.dReferenceFreq         = 40.0;
 80284d4:	ed9f 7b30 	vldr	d7, [pc, #192]	; 8028598 <pll_init+0xc8>
   3. EXPORTED FUNCTIONS
==============================================================================
 */

void pll_init(void* pll_handle)
{
 80284d8:	b08b      	sub	sp, #44	; 0x2c
  s_sPLLHardwareSetup.uLockDetectNumGoodEdge = 32;
  s_sPLLHardwareSetup.uLockDetectNumBadEdge  = 4;
  s_sPLLHardwareSetup.eLockDetectWindow      = LMX249x_DLD_TOL_10NS;
  
  /* Set the digital IOs used by SPI interface */
  lmx249x_spi_pins.spi_device = LMX_DEVICE;
 80284da:	f8df e0cc 	ldr.w	lr, [pc, #204]	; 80285a8 <pll_init+0xd8>
  lmx249x_spi_pins.gpio_cs_pin 	 = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_PLL;
 80284de:	4b30      	ldr	r3, [pc, #192]	; (80285a0 <pll_init+0xd0>)
  lmx249x_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_DATA;
 80284e0:	f8df 80c8 	ldr.w	r8, [pc, #200]	; 80285ac <pll_init+0xdc>
  lmx249x_spi_pins.gpio_clk_pin  = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;
 80284e4:	f8df c0c8 	ldr.w	ip, [pc, #200]	; 80285b0 <pll_init+0xe0>
  
  lmx249x_init(lmx249x_pll, &s_sPLLHardwareSetup, spi_transmit_data, (void*)&lmx249x_spi_pins);
 80284e8:	4a2e      	ldr	r2, [pc, #184]	; (80285a4 <pll_init+0xd4>)
  s_sPLLHardwareSetup.uLockDetectNumBadEdge  = 4;
  s_sPLLHardwareSetup.eLockDetectWindow      = LMX249x_DLD_TOL_10NS;
  
  /* Set the digital IOs used by SPI interface */
  lmx249x_spi_pins.spi_device = LMX_DEVICE;
  lmx249x_spi_pins.gpio_cs_pin 	 = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_PLL;
 80284ea:	f8ce 3004 	str.w	r3, [lr, #4]
  
  /* Send general configuration to PLL */
  /* --------------------------------- */
  s_sPLLHardwareSetup.dReferenceFreq         = 40.0;
  s_sPLLHardwareSetup.uReferenceDivider      = 1;
  s_sPLLHardwareSetup.eReferenceDoubler      = LMX249x_OSCIN_DOUBLER_OFF;
 80284ee:	2700      	movs	r7, #0
  Lmx249x_Hardware_Setup_t s_sPLLHardwareSetup;
  
  /* Send general configuration to PLL */
  /* --------------------------------- */
  s_sPLLHardwareSetup.dReferenceFreq         = 40.0;
  s_sPLLHardwareSetup.uReferenceDivider      = 1;
 80284f0:	2501      	movs	r5, #1
  s_sPLLHardwareSetup.eReferenceDoubler      = LMX249x_OSCIN_DOUBLER_OFF;
  s_sPLLHardwareSetup.eOscInMode             = LMX249x_OSCIN_SINGLE_ENDED;
  s_sPLLHardwareSetup.uExternalDivider       = 16;
 80284f2:	2110      	movs	r1, #16
  s_sPLLHardwareSetup.eTrig1PinFunction      = LMX249x_MUX_OUT_FLAG0_FROM_RAMP;
  s_sPLLHardwareSetup.eTrig1PinDriveMode     = LMX249x_PIN_FCN_PULLUPDN_OUT;
 80284f4:	2402      	movs	r4, #2
  lmx249x_spi_pins.spi_device = LMX_DEVICE;
  lmx249x_spi_pins.gpio_cs_pin 	 = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_PLL;
  lmx249x_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_DATA;
  lmx249x_spi_pins.gpio_clk_pin  = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;
  
  lmx249x_init(lmx249x_pll, &s_sPLLHardwareSetup, spi_transmit_data, (void*)&lmx249x_spi_pins);
 80284f6:	4673      	mov	r3, lr
  s_sPLLHardwareSetup.eOscInMode             = LMX249x_OSCIN_SINGLE_ENDED;
  s_sPLLHardwareSetup.uExternalDivider       = 16;
  s_sPLLHardwareSetup.eTrig1PinFunction      = LMX249x_MUX_OUT_FLAG0_FROM_RAMP;
  s_sPLLHardwareSetup.eTrig1PinDriveMode     = LMX249x_PIN_FCN_PULLUPDN_OUT;
  s_sPLLHardwareSetup.eTrig2PinFunction      = LMX249x_MUX_IN_TRIG2;
  s_sPLLHardwareSetup.eTrig2PinDriveMode     = LMX249x_PIN_FCN_INPUT;
 80284f8:	2607      	movs	r6, #7
  s_sPLLHardwareSetup.eLockDetectWindow      = LMX249x_DLD_TOL_10NS;
  
  /* Set the digital IOs used by SPI interface */
  lmx249x_spi_pins.spi_device = LMX_DEVICE;
  lmx249x_spi_pins.gpio_cs_pin 	 = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_PLL;
  lmx249x_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_DATA;
 80284fa:	f8ce 8008 	str.w	r8, [lr, #8]
  lmx249x_spi_pins.gpio_clk_pin  = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;
 80284fe:	f8ce c00c 	str.w	ip, [lr, #12]
  s_sPLLHardwareSetup.uLockDetectNumGoodEdge = 32;
  s_sPLLHardwareSetup.uLockDetectNumBadEdge  = 4;
  s_sPLLHardwareSetup.eLockDetectWindow      = LMX249x_DLD_TOL_10NS;
  
  /* Set the digital IOs used by SPI interface */
  lmx249x_spi_pins.spi_device = LMX_DEVICE;
 8028502:	f88e 5000 	strb.w	r5, [lr]
  s_sPLLHardwareSetup.eMUXoutPinDriveMode    = LMX249x_PIN_FCN_PULLUPDN_OUT;
  s_sPLLHardwareSetup.eChargePumpPolarity    = LMX249x_CPPOL_NEGATIVE;
  s_sPLLHardwareSetup.uChargePumpCurrent     = 20;
  s_sPLLHardwareSetup.uChargePumpCurrentFS   = 0;
  s_sPLLHardwareSetup.uChargePumpThresholdLo = 6;
  s_sPLLHardwareSetup.uChargePumpThresholdHi = 42;
 8028506:	f04f 0c2a 	mov.w	ip, #42	; 0x2a
  s_sPLLHardwareSetup.eChargePumpPulseWidth  = LMX249x_CP_PULSE_860PS;
  s_sPLLHardwareSetup.eCycleSlipReduction    = LMX249x_CSR_DISABLED;
  s_sPLLHardwareSetup.uFastLockTimer         = 0;
  s_sPLLHardwareSetup.uLockDetectNumGoodEdge = 32;
 802850a:	f04f 0e20 	mov.w	lr, #32
  Lmx249x_Hardware_Setup_t s_sPLLHardwareSetup;
  
  /* Send general configuration to PLL */
  /* --------------------------------- */
  s_sPLLHardwareSetup.dReferenceFreq         = 40.0;
  s_sPLLHardwareSetup.uReferenceDivider      = 1;
 802850e:	f8ad 5008 	strh.w	r5, [sp, #8]
  s_sPLLHardwareSetup.eChargePumpPolarity    = LMX249x_CPPOL_NEGATIVE;
  s_sPLLHardwareSetup.uChargePumpCurrent     = 20;
  s_sPLLHardwareSetup.uChargePumpCurrentFS   = 0;
  s_sPLLHardwareSetup.uChargePumpThresholdLo = 6;
  s_sPLLHardwareSetup.uChargePumpThresholdHi = 42;
  s_sPLLHardwareSetup.eChargePumpPulseWidth  = LMX249x_CP_PULSE_860PS;
 8028512:	f88d 501d 	strb.w	r5, [sp, #29]
  
  /* Send general configuration to PLL */
  /* --------------------------------- */
  s_sPLLHardwareSetup.dReferenceFreq         = 40.0;
  s_sPLLHardwareSetup.uReferenceDivider      = 1;
  s_sPLLHardwareSetup.eReferenceDoubler      = LMX249x_OSCIN_DOUBLER_OFF;
 8028516:	f88d 700a 	strb.w	r7, [sp, #10]
  s_sPLLHardwareSetup.uChargePumpThresholdHi = 42;
  s_sPLLHardwareSetup.eChargePumpPulseWidth  = LMX249x_CP_PULSE_860PS;
  s_sPLLHardwareSetup.eCycleSlipReduction    = LMX249x_CSR_DISABLED;
  s_sPLLHardwareSetup.uFastLockTimer         = 0;
  s_sPLLHardwareSetup.uLockDetectNumGoodEdge = 32;
  s_sPLLHardwareSetup.uLockDetectNumBadEdge  = 4;
 802851a:	2504      	movs	r5, #4
  /* Send general configuration to PLL */
  /* --------------------------------- */
  s_sPLLHardwareSetup.dReferenceFreq         = 40.0;
  s_sPLLHardwareSetup.uReferenceDivider      = 1;
  s_sPLLHardwareSetup.eReferenceDoubler      = LMX249x_OSCIN_DOUBLER_OFF;
  s_sPLLHardwareSetup.eOscInMode             = LMX249x_OSCIN_SINGLE_ENDED;
 802851c:	f88d 700b 	strb.w	r7, [sp, #11]
  s_sPLLHardwareSetup.eTrig2PinDriveMode     = LMX249x_PIN_FCN_INPUT;
  s_sPLLHardwareSetup.eModPinFunction        = LMX249x_MUX_OUT_FLAG1_FROM_RAMP;
  s_sPLLHardwareSetup.eModPinDriveMode       = LMX249x_PIN_FCN_PULLUPDN_OUT;
  s_sPLLHardwareSetup.eMUXoutPinFunction     = LMX249x_MUX_OUT_READ_BACK;
  s_sPLLHardwareSetup.eMUXoutPinDriveMode    = LMX249x_PIN_FCN_PULLUPDN_OUT;
  s_sPLLHardwareSetup.eChargePumpPolarity    = LMX249x_CPPOL_NEGATIVE;
 8028520:	f88d 7018 	strb.w	r7, [sp, #24]
  s_sPLLHardwareSetup.uChargePumpCurrent     = 20;
  s_sPLLHardwareSetup.uChargePumpCurrentFS   = 0;
 8028524:	f88d 701a 	strb.w	r7, [sp, #26]
  s_sPLLHardwareSetup.uChargePumpThresholdLo = 6;
  s_sPLLHardwareSetup.uChargePumpThresholdHi = 42;
  s_sPLLHardwareSetup.eChargePumpPulseWidth  = LMX249x_CP_PULSE_860PS;
  s_sPLLHardwareSetup.eCycleSlipReduction    = LMX249x_CSR_DISABLED;
 8028528:	f88d 701e 	strb.w	r7, [sp, #30]
  s_sPLLHardwareSetup.uFastLockTimer         = 0;
 802852c:	f8ad 7020 	strh.w	r7, [sp, #32]
  /* --------------------------------- */
  s_sPLLHardwareSetup.dReferenceFreq         = 40.0;
  s_sPLLHardwareSetup.uReferenceDivider      = 1;
  s_sPLLHardwareSetup.eReferenceDoubler      = LMX249x_OSCIN_DOUBLER_OFF;
  s_sPLLHardwareSetup.eOscInMode             = LMX249x_OSCIN_SINGLE_ENDED;
  s_sPLLHardwareSetup.uExternalDivider       = 16;
 8028530:	9103      	str	r1, [sp, #12]
   3. EXPORTED FUNCTIONS
==============================================================================
 */

void pll_init(void* pll_handle)
{
 8028532:	4607      	mov	r7, r0
  lmx249x_spi_pins.spi_device = LMX_DEVICE;
  lmx249x_spi_pins.gpio_cs_pin 	 = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_PLL;
  lmx249x_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_DATA;
  lmx249x_spi_pins.gpio_clk_pin  = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;
  
  lmx249x_init(lmx249x_pll, &s_sPLLHardwareSetup, spi_transmit_data, (void*)&lmx249x_spi_pins);
 8028534:	4669      	mov	r1, sp
  s_sPLLHardwareSetup.dReferenceFreq         = 40.0;
  s_sPLLHardwareSetup.uReferenceDivider      = 1;
  s_sPLLHardwareSetup.eReferenceDoubler      = LMX249x_OSCIN_DOUBLER_OFF;
  s_sPLLHardwareSetup.eOscInMode             = LMX249x_OSCIN_SINGLE_ENDED;
  s_sPLLHardwareSetup.uExternalDivider       = 16;
  s_sPLLHardwareSetup.eTrig1PinFunction      = LMX249x_MUX_OUT_FLAG0_FROM_RAMP;
 8028536:	f04f 0b1e 	mov.w	fp, #30
  s_sPLLHardwareSetup.eTrig1PinDriveMode     = LMX249x_PIN_FCN_PULLUPDN_OUT;
  s_sPLLHardwareSetup.eTrig2PinFunction      = LMX249x_MUX_IN_TRIG2;
  s_sPLLHardwareSetup.eTrig2PinDriveMode     = LMX249x_PIN_FCN_INPUT;
  s_sPLLHardwareSetup.eModPinFunction        = LMX249x_MUX_OUT_FLAG1_FROM_RAMP;
 802853a:	f04f 0a1f 	mov.w	sl, #31
  s_sPLLHardwareSetup.eModPinDriveMode       = LMX249x_PIN_FCN_PULLUPDN_OUT;
  s_sPLLHardwareSetup.eMUXoutPinFunction     = LMX249x_MUX_OUT_READ_BACK;
  s_sPLLHardwareSetup.eMUXoutPinDriveMode    = LMX249x_PIN_FCN_PULLUPDN_OUT;
  s_sPLLHardwareSetup.eChargePumpPolarity    = LMX249x_CPPOL_NEGATIVE;
  s_sPLLHardwareSetup.uChargePumpCurrent     = 20;
 802853e:	f04f 0914 	mov.w	r9, #20
  s_sPLLHardwareSetup.uChargePumpCurrentFS   = 0;
  s_sPLLHardwareSetup.uChargePumpThresholdLo = 6;
 8028542:	f04f 0806 	mov.w	r8, #6
  Lmx249x_Object_t* lmx249x_pll = (Lmx249x_Object_t*)pll_handle;
  Lmx249x_Hardware_Setup_t s_sPLLHardwareSetup;
  
  /* Send general configuration to PLL */
  /* --------------------------------- */
  s_sPLLHardwareSetup.dReferenceFreq         = 40.0;
 8028546:	ed8d 7b00 	vstr	d7, [sp]
  s_sPLLHardwareSetup.eMUXoutPinDriveMode    = LMX249x_PIN_FCN_PULLUPDN_OUT;
  s_sPLLHardwareSetup.eChargePumpPolarity    = LMX249x_CPPOL_NEGATIVE;
  s_sPLLHardwareSetup.uChargePumpCurrent     = 20;
  s_sPLLHardwareSetup.uChargePumpCurrentFS   = 0;
  s_sPLLHardwareSetup.uChargePumpThresholdLo = 6;
  s_sPLLHardwareSetup.uChargePumpThresholdHi = 42;
 802854a:	f88d c01c 	strb.w	ip, [sp, #28]
  s_sPLLHardwareSetup.eChargePumpPulseWidth  = LMX249x_CP_PULSE_860PS;
  s_sPLLHardwareSetup.eCycleSlipReduction    = LMX249x_CSR_DISABLED;
  s_sPLLHardwareSetup.uFastLockTimer         = 0;
  s_sPLLHardwareSetup.uLockDetectNumGoodEdge = 32;
 802854e:	f88d e022 	strb.w	lr, [sp, #34]	; 0x22
  s_sPLLHardwareSetup.dReferenceFreq         = 40.0;
  s_sPLLHardwareSetup.uReferenceDivider      = 1;
  s_sPLLHardwareSetup.eReferenceDoubler      = LMX249x_OSCIN_DOUBLER_OFF;
  s_sPLLHardwareSetup.eOscInMode             = LMX249x_OSCIN_SINGLE_ENDED;
  s_sPLLHardwareSetup.uExternalDivider       = 16;
  s_sPLLHardwareSetup.eTrig1PinFunction      = LMX249x_MUX_OUT_FLAG0_FROM_RAMP;
 8028552:	f88d b010 	strb.w	fp, [sp, #16]
  s_sPLLHardwareSetup.eTrig1PinDriveMode     = LMX249x_PIN_FCN_PULLUPDN_OUT;
 8028556:	f88d 4011 	strb.w	r4, [sp, #17]
  s_sPLLHardwareSetup.eTrig2PinFunction      = LMX249x_MUX_IN_TRIG2;
 802855a:	f88d 4012 	strb.w	r4, [sp, #18]
  s_sPLLHardwareSetup.eTrig2PinDriveMode     = LMX249x_PIN_FCN_INPUT;
  s_sPLLHardwareSetup.eModPinFunction        = LMX249x_MUX_OUT_FLAG1_FROM_RAMP;
  s_sPLLHardwareSetup.eModPinDriveMode       = LMX249x_PIN_FCN_PULLUPDN_OUT;
 802855e:	f88d 4015 	strb.w	r4, [sp, #21]
  s_sPLLHardwareSetup.eMUXoutPinFunction     = LMX249x_MUX_OUT_READ_BACK;
  s_sPLLHardwareSetup.eMUXoutPinDriveMode    = LMX249x_PIN_FCN_PULLUPDN_OUT;
 8028562:	f88d 4017 	strb.w	r4, [sp, #23]
  s_sPLLHardwareSetup.eOscInMode             = LMX249x_OSCIN_SINGLE_ENDED;
  s_sPLLHardwareSetup.uExternalDivider       = 16;
  s_sPLLHardwareSetup.eTrig1PinFunction      = LMX249x_MUX_OUT_FLAG0_FROM_RAMP;
  s_sPLLHardwareSetup.eTrig1PinDriveMode     = LMX249x_PIN_FCN_PULLUPDN_OUT;
  s_sPLLHardwareSetup.eTrig2PinFunction      = LMX249x_MUX_IN_TRIG2;
  s_sPLLHardwareSetup.eTrig2PinDriveMode     = LMX249x_PIN_FCN_INPUT;
 8028566:	f88d 6013 	strb.w	r6, [sp, #19]
  s_sPLLHardwareSetup.eModPinFunction        = LMX249x_MUX_OUT_FLAG1_FROM_RAMP;
  s_sPLLHardwareSetup.eModPinDriveMode       = LMX249x_PIN_FCN_PULLUPDN_OUT;
  s_sPLLHardwareSetup.eMUXoutPinFunction     = LMX249x_MUX_OUT_READ_BACK;
 802856a:	f88d 6016 	strb.w	r6, [sp, #22]
  s_sPLLHardwareSetup.uExternalDivider       = 16;
  s_sPLLHardwareSetup.eTrig1PinFunction      = LMX249x_MUX_OUT_FLAG0_FROM_RAMP;
  s_sPLLHardwareSetup.eTrig1PinDriveMode     = LMX249x_PIN_FCN_PULLUPDN_OUT;
  s_sPLLHardwareSetup.eTrig2PinFunction      = LMX249x_MUX_IN_TRIG2;
  s_sPLLHardwareSetup.eTrig2PinDriveMode     = LMX249x_PIN_FCN_INPUT;
  s_sPLLHardwareSetup.eModPinFunction        = LMX249x_MUX_OUT_FLAG1_FROM_RAMP;
 802856e:	f88d a014 	strb.w	sl, [sp, #20]
  s_sPLLHardwareSetup.eModPinDriveMode       = LMX249x_PIN_FCN_PULLUPDN_OUT;
  s_sPLLHardwareSetup.eMUXoutPinFunction     = LMX249x_MUX_OUT_READ_BACK;
  s_sPLLHardwareSetup.eMUXoutPinDriveMode    = LMX249x_PIN_FCN_PULLUPDN_OUT;
  s_sPLLHardwareSetup.eChargePumpPolarity    = LMX249x_CPPOL_NEGATIVE;
  s_sPLLHardwareSetup.uChargePumpCurrent     = 20;
 8028572:	f88d 9019 	strb.w	r9, [sp, #25]
  s_sPLLHardwareSetup.uChargePumpCurrentFS   = 0;
  s_sPLLHardwareSetup.uChargePumpThresholdLo = 6;
 8028576:	f88d 801b 	strb.w	r8, [sp, #27]
  s_sPLLHardwareSetup.uChargePumpThresholdHi = 42;
  s_sPLLHardwareSetup.eChargePumpPulseWidth  = LMX249x_CP_PULSE_860PS;
  s_sPLLHardwareSetup.eCycleSlipReduction    = LMX249x_CSR_DISABLED;
  s_sPLLHardwareSetup.uFastLockTimer         = 0;
  s_sPLLHardwareSetup.uLockDetectNumGoodEdge = 32;
  s_sPLLHardwareSetup.uLockDetectNumBadEdge  = 4;
 802857a:	f88d 5023 	strb.w	r5, [sp, #35]	; 0x23
  s_sPLLHardwareSetup.eLockDetectWindow      = LMX249x_DLD_TOL_10NS;
 802857e:	f88d 5024 	strb.w	r5, [sp, #36]	; 0x24
  lmx249x_spi_pins.spi_device = LMX_DEVICE;
  lmx249x_spi_pins.gpio_cs_pin 	 = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_PLL;
  lmx249x_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_DATA;
  lmx249x_spi_pins.gpio_clk_pin  = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;
  
  lmx249x_init(lmx249x_pll, &s_sPLLHardwareSetup, spi_transmit_data, (void*)&lmx249x_spi_pins);
 8028582:	f000 fa87 	bl	8028a94 <lmx249x_init>
  
  lmx249x_set_power_state(lmx249x_pll, LMX249x_POWER_CE);
 8028586:	4638      	mov	r0, r7
 8028588:	4621      	mov	r1, r4
 802858a:	f000 fb51 	bl	8028c30 <lmx249x_set_power_state>
}
 802858e:	b00b      	add	sp, #44	; 0x2c
 8028590:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8028594:	f3af 8000 	nop.w
 8028598:	00000000 	.word	0x00000000
 802859c:	40440000 	.word	0x40440000
 80285a0:	0802af84 	.word	0x0802af84
 80285a4:	080288e5 	.word	0x080288e5
 80285a8:	1fff1ff4 	.word	0x1fff1ff4
 80285ac:	0802afe8 	.word	0x0802afe8
 80285b0:	0802af20 	.word	0x0802af20
 80285b4:	f3af 8000 	nop.w

080285b8 <pll_configure_ramps>:

//============================================================================

void pll_configure_ramps(void* pll_handle)
{
 80285b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80285bc:	ed2d 8b04 	vpush	{d8-d9}
  
  Lmx249x_Ramp_Global_t pllGlobalRampSetup;
  
  Lmx249x_Ramp_Section_t pllRampSections[5];
  
  pllGlobalRampSetup.dBaseFrequency = (double)s_pll_base_freq_MHz; /*!< base frequency */
 80285c0:	4b63      	ldr	r3, [pc, #396]	; (8028750 <pll_configure_ramps+0x198>)
  pllGlobalRampSetup.eDevTrigger = LMX249x_TRIGGER_A;				 /*!< Defines the deviation trigger for FSK operation */
  pllGlobalRampSetup.eDitherMode = LMX249x_FRAC_DITHER_DISABLED;                 /*!< Defines the fractional dithering */
  pllGlobalRampSetup.eFracOrder  = LMX249x_FRAC_ORD_SECOND;                      /*!< Defines the fractional order */
  
  /* Calculate real frequency shift based on PLL clock */
  double bandwidth_MHz = lmx249x_get_real_frequency_shift(lmx249x_pll, s_pll_bandwidth_MHz, s_pll_chirp_time_usec);
 80285c2:	f8df 91a0 	ldr.w	r9, [pc, #416]	; 8028764 <pll_configure_ramps+0x1ac>
}

//============================================================================

void pll_configure_ramps(void* pll_handle)
{
 80285c6:	b0bb      	sub	sp, #236	; 0xec
 80285c8:	4680      	mov	r8, r0
  
  Lmx249x_Ramp_Global_t pllGlobalRampSetup;
  
  Lmx249x_Ramp_Section_t pllRampSections[5];
  
  pllGlobalRampSetup.dBaseFrequency = (double)s_pll_base_freq_MHz; /*!< base frequency */
 80285ca:	6818      	ldr	r0, [r3, #0]
 80285cc:	f001 fbde 	bl	8029d8c <__aeabi_f2d>
  
  pllGlobalRampSetup.dMinFrequency  = (double)(s_pll_lower_freq_MHz - (float)PLL_RAMP_GUARD_FREQ_MHZ); /*!< Minimum frequency that can't be underrun by a ramp */
 80285d0:	4b60      	ldr	r3, [pc, #384]	; (8028754 <pll_configure_ramps+0x19c>)
 80285d2:	edd3 8a00 	vldr	s17, [r3]
 80285d6:	eeb6 9a00 	vmov.f32	s18, #96	; 0x60
 80285da:	ee78 7ac9 	vsub.f32	s15, s17, s18
  
  Lmx249x_Ramp_Global_t pllGlobalRampSetup;
  
  Lmx249x_Ramp_Section_t pllRampSections[5];
  
  pllGlobalRampSetup.dBaseFrequency = (double)s_pll_base_freq_MHz; /*!< base frequency */
 80285de:	e9cd 0102 	strd	r0, r1, [sp, #8]
  
  pllGlobalRampSetup.dMinFrequency  = (double)(s_pll_lower_freq_MHz - (float)PLL_RAMP_GUARD_FREQ_MHZ); /*!< Minimum frequency that can't be underrun by a ramp */
 80285e2:	ee17 0a90 	vmov	r0, s15
 80285e6:	f001 fbd1 	bl	8029d8c <__aeabi_f2d>
  pllGlobalRampSetup.dMaxFrequency  = (double)(s_pll_upper_freq_MHz + (float)PLL_RAMP_GUARD_FREQ_MHZ); /*!< Maximum frequency that can't be overrun by a ramp */
 80285ea:	4b5b      	ldr	r3, [pc, #364]	; (8028758 <pll_configure_ramps+0x1a0>)
 80285ec:	ed93 8a00 	vldr	s16, [r3]
 80285f0:	ee78 7a09 	vadd.f32	s15, s16, s18
  
  Lmx249x_Ramp_Section_t pllRampSections[5];
  
  pllGlobalRampSetup.dBaseFrequency = (double)s_pll_base_freq_MHz; /*!< base frequency */
  
  pllGlobalRampSetup.dMinFrequency  = (double)(s_pll_lower_freq_MHz - (float)PLL_RAMP_GUARD_FREQ_MHZ); /*!< Minimum frequency that can't be underrun by a ramp */
 80285f4:	e9cd 0106 	strd	r0, r1, [sp, #24]
  pllGlobalRampSetup.dMaxFrequency  = (double)(s_pll_upper_freq_MHz + (float)PLL_RAMP_GUARD_FREQ_MHZ); /*!< Maximum frequency that can't be overrun by a ramp */
 80285f8:	ee17 0a90 	vmov	r0, s15
 80285fc:	f001 fbc6 	bl	8029d8c <__aeabi_f2d>
 8028600:	e9cd 0108 	strd	r0, r1, [sp, #32]
  pllGlobalRampSetup.dComp0Freq     = (double)s_pll_lower_freq_MHz; /*!< Frequency that is used by Comparator 0 to compare the ramp with. */
 8028604:	ee18 0a90 	vmov	r0, s17
 8028608:	f001 fbc0 	bl	8029d8c <__aeabi_f2d>
 802860c:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
  pllGlobalRampSetup.dComp1Freq     = (double)s_pll_upper_freq_MHz; /*!< Frequency that is used by Comparator 0 to compare the ramp with. */
 8028610:	ee18 0a10 	vmov	r0, s16
 8028614:	f001 fbba 	bl	8029d8c <__aeabi_f2d>
  pllGlobalRampSetup.dDeviationFrequency = 0;  			    /*!< FSK deviation frequency */
  
  pllGlobalRampSetup.uNumRamps = s_pll_num_of_chirps * 4 + 1;	    /*!< Number of ramps to do before ramp is disabled (set to 0 for infinite number of ramps) */
 8028618:	4b50      	ldr	r3, [pc, #320]	; (802875c <pll_configure_ramps+0x1a4>)
  pllGlobalRampSetup.eDevTrigger = LMX249x_TRIGGER_A;				 /*!< Defines the deviation trigger for FSK operation */
  pllGlobalRampSetup.eDitherMode = LMX249x_FRAC_DITHER_DISABLED;                 /*!< Defines the fractional dithering */
  pllGlobalRampSetup.eFracOrder  = LMX249x_FRAC_ORD_SECOND;                      /*!< Defines the fractional order */
  
  /* Calculate real frequency shift based on PLL clock */
  double bandwidth_MHz = lmx249x_get_real_frequency_shift(lmx249x_pll, s_pll_bandwidth_MHz, s_pll_chirp_time_usec);
 802861a:	4a51      	ldr	r2, [pc, #324]	; (8028760 <pll_configure_ramps+0x1a8>)
  pllGlobalRampSetup.dMaxFrequency  = (double)(s_pll_upper_freq_MHz + (float)PLL_RAMP_GUARD_FREQ_MHZ); /*!< Maximum frequency that can't be overrun by a ramp */
  pllGlobalRampSetup.dComp0Freq     = (double)s_pll_lower_freq_MHz; /*!< Frequency that is used by Comparator 0 to compare the ramp with. */
  pllGlobalRampSetup.dComp1Freq     = (double)s_pll_upper_freq_MHz; /*!< Frequency that is used by Comparator 0 to compare the ramp with. */
  pllGlobalRampSetup.dDeviationFrequency = 0;  			    /*!< FSK deviation frequency */
  
  pllGlobalRampSetup.uNumRamps = s_pll_num_of_chirps * 4 + 1;	    /*!< Number of ramps to do before ramp is disabled (set to 0 for infinite number of ramps) */
 802861c:	681b      	ldr	r3, [r3, #0]
 802861e:	009b      	lsls	r3, r3, #2
  
  pllGlobalRampSetup.eTriggerA   = LMX249x_RAMP_TRIG_NEVER_TRIGGERS;             /*!< Define the source for Trigger A */
 8028620:	2400      	movs	r4, #0
  
  pllGlobalRampSetup.dMinFrequency  = (double)(s_pll_lower_freq_MHz - (float)PLL_RAMP_GUARD_FREQ_MHZ); /*!< Minimum frequency that can't be underrun by a ramp */
  pllGlobalRampSetup.dMaxFrequency  = (double)(s_pll_upper_freq_MHz + (float)PLL_RAMP_GUARD_FREQ_MHZ); /*!< Maximum frequency that can't be overrun by a ramp */
  pllGlobalRampSetup.dComp0Freq     = (double)s_pll_lower_freq_MHz; /*!< Frequency that is used by Comparator 0 to compare the ramp with. */
  pllGlobalRampSetup.dComp1Freq     = (double)s_pll_upper_freq_MHz; /*!< Frequency that is used by Comparator 0 to compare the ramp with. */
  pllGlobalRampSetup.dDeviationFrequency = 0;  			    /*!< FSK deviation frequency */
 8028622:	f04f 0a00 	mov.w	sl, #0
 8028626:	f04f 0b00 	mov.w	fp, #0
  pllGlobalRampSetup.eTriggerA   = LMX249x_RAMP_TRIG_NEVER_TRIGGERS;             /*!< Define the source for Trigger A */
  pllGlobalRampSetup.eTriggerB   = LMX249x_RAMP_TRIG_TRIG2_TERMINAL_RISING_EDGE; /*!< Define the source for Trigger B */
  pllGlobalRampSetup.eTriggerC   = LMX249x_RAMP_TRIG_NEVER_TRIGGERS;             /*!< Define the source for Trigger C */
  pllGlobalRampSetup.eRampClock  = LMX249x_RAMP_CLOCK_INTERNAL;         	 /*!< determines if internal or external clock for ramp timing is used */
  pllGlobalRampSetup.eModulation = LMX249x_RAMP_MODULATION_FM;        		 /*!< Kind of modulation */
  pllGlobalRampSetup.eAutoOff    = LMX249x_RAMP_AUTO_OFF_ENABLE;           	 /*!< Defines, if the Ramp should be turned off after a certain amount of ramps */
 802862a:	2501      	movs	r5, #1
  pllGlobalRampSetup.dDeviationFrequency = 0;  			    /*!< FSK deviation frequency */
  
  pllGlobalRampSetup.uNumRamps = s_pll_num_of_chirps * 4 + 1;	    /*!< Number of ramps to do before ramp is disabled (set to 0 for infinite number of ramps) */
  
  pllGlobalRampSetup.eTriggerA   = LMX249x_RAMP_TRIG_NEVER_TRIGGERS;             /*!< Define the source for Trigger A */
  pllGlobalRampSetup.eTriggerB   = LMX249x_RAMP_TRIG_TRIG2_TERMINAL_RISING_EDGE; /*!< Define the source for Trigger B */
 802862c:	2602      	movs	r6, #2
  pllGlobalRampSetup.eRampClock  = LMX249x_RAMP_CLOCK_INTERNAL;         	 /*!< determines if internal or external clock for ramp timing is used */
  pllGlobalRampSetup.eModulation = LMX249x_RAMP_MODULATION_FM;        		 /*!< Kind of modulation */
  pllGlobalRampSetup.eAutoOff    = LMX249x_RAMP_AUTO_OFF_ENABLE;           	 /*!< Defines, if the Ramp should be turned off after a certain amount of ramps */
  pllGlobalRampSetup.eRampCountTrigger = LMX249x_RAMP_COUNT_INCREMENT_SEGMENT_TRANSITION; /*!< Defines the increment trigger for the ramp counter */
  pllGlobalRampSetup.eDevTrigger = LMX249x_TRIGGER_A;				 /*!< Defines the deviation trigger for FSK operation */
  pllGlobalRampSetup.eDitherMode = LMX249x_FRAC_DITHER_DISABLED;                 /*!< Defines the fractional dithering */
 802862e:	2703      	movs	r7, #3
  pllGlobalRampSetup.dBaseFrequency = (double)s_pll_base_freq_MHz; /*!< base frequency */
  
  pllGlobalRampSetup.dMinFrequency  = (double)(s_pll_lower_freq_MHz - (float)PLL_RAMP_GUARD_FREQ_MHZ); /*!< Minimum frequency that can't be underrun by a ramp */
  pllGlobalRampSetup.dMaxFrequency  = (double)(s_pll_upper_freq_MHz + (float)PLL_RAMP_GUARD_FREQ_MHZ); /*!< Maximum frequency that can't be overrun by a ramp */
  pllGlobalRampSetup.dComp0Freq     = (double)s_pll_lower_freq_MHz; /*!< Frequency that is used by Comparator 0 to compare the ramp with. */
  pllGlobalRampSetup.dComp1Freq     = (double)s_pll_upper_freq_MHz; /*!< Frequency that is used by Comparator 0 to compare the ramp with. */
 8028630:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
  pllGlobalRampSetup.dDeviationFrequency = 0;  			    /*!< FSK deviation frequency */
  
  pllGlobalRampSetup.uNumRamps = s_pll_num_of_chirps * 4 + 1;	    /*!< Number of ramps to do before ramp is disabled (set to 0 for infinite number of ramps) */
 8028634:	3301      	adds	r3, #1
  pllGlobalRampSetup.eDevTrigger = LMX249x_TRIGGER_A;				 /*!< Defines the deviation trigger for FSK operation */
  pllGlobalRampSetup.eDitherMode = LMX249x_FRAC_DITHER_DISABLED;                 /*!< Defines the fractional dithering */
  pllGlobalRampSetup.eFracOrder  = LMX249x_FRAC_ORD_SECOND;                      /*!< Defines the fractional order */
  
  /* Calculate real frequency shift based on PLL clock */
  double bandwidth_MHz = lmx249x_get_real_frequency_shift(lmx249x_pll, s_pll_bandwidth_MHz, s_pll_chirp_time_usec);
 8028636:	6810      	ldr	r0, [r2, #0]
  pllGlobalRampSetup.dMaxFrequency  = (double)(s_pll_upper_freq_MHz + (float)PLL_RAMP_GUARD_FREQ_MHZ); /*!< Maximum frequency that can't be overrun by a ramp */
  pllGlobalRampSetup.dComp0Freq     = (double)s_pll_lower_freq_MHz; /*!< Frequency that is used by Comparator 0 to compare the ramp with. */
  pllGlobalRampSetup.dComp1Freq     = (double)s_pll_upper_freq_MHz; /*!< Frequency that is used by Comparator 0 to compare the ramp with. */
  pllGlobalRampSetup.dDeviationFrequency = 0;  			    /*!< FSK deviation frequency */
  
  pllGlobalRampSetup.uNumRamps = s_pll_num_of_chirps * 4 + 1;	    /*!< Number of ramps to do before ramp is disabled (set to 0 for infinite number of ramps) */
 8028638:	f8ad 303e 	strh.w	r3, [sp, #62]	; 0x3e
  
  pllGlobalRampSetup.eTriggerA   = LMX249x_RAMP_TRIG_NEVER_TRIGGERS;             /*!< Define the source for Trigger A */
  pllGlobalRampSetup.eTriggerB   = LMX249x_RAMP_TRIG_TRIG2_TERMINAL_RISING_EDGE; /*!< Define the source for Trigger B */
 802863c:	f88d 6039 	strb.w	r6, [sp, #57]	; 0x39
  pllGlobalRampSetup.eModulation = LMX249x_RAMP_MODULATION_FM;        		 /*!< Kind of modulation */
  pllGlobalRampSetup.eAutoOff    = LMX249x_RAMP_AUTO_OFF_ENABLE;           	 /*!< Defines, if the Ramp should be turned off after a certain amount of ramps */
  pllGlobalRampSetup.eRampCountTrigger = LMX249x_RAMP_COUNT_INCREMENT_SEGMENT_TRANSITION; /*!< Defines the increment trigger for the ramp counter */
  pllGlobalRampSetup.eDevTrigger = LMX249x_TRIGGER_A;				 /*!< Defines the deviation trigger for FSK operation */
  pllGlobalRampSetup.eDitherMode = LMX249x_FRAC_DITHER_DISABLED;                 /*!< Defines the fractional dithering */
  pllGlobalRampSetup.eFracOrder  = LMX249x_FRAC_ORD_SECOND;                      /*!< Defines the fractional order */
 8028640:	f88d 6042 	strb.w	r6, [sp, #66]	; 0x42
  
  pllGlobalRampSetup.dMinFrequency  = (double)(s_pll_lower_freq_MHz - (float)PLL_RAMP_GUARD_FREQ_MHZ); /*!< Minimum frequency that can't be underrun by a ramp */
  pllGlobalRampSetup.dMaxFrequency  = (double)(s_pll_upper_freq_MHz + (float)PLL_RAMP_GUARD_FREQ_MHZ); /*!< Maximum frequency that can't be overrun by a ramp */
  pllGlobalRampSetup.dComp0Freq     = (double)s_pll_lower_freq_MHz; /*!< Frequency that is used by Comparator 0 to compare the ramp with. */
  pllGlobalRampSetup.dComp1Freq     = (double)s_pll_upper_freq_MHz; /*!< Frequency that is used by Comparator 0 to compare the ramp with. */
  pllGlobalRampSetup.dDeviationFrequency = 0;  			    /*!< FSK deviation frequency */
 8028644:	e9cd ab04 	strd	sl, fp, [sp, #16]
  
  pllGlobalRampSetup.uNumRamps = s_pll_num_of_chirps * 4 + 1;	    /*!< Number of ramps to do before ramp is disabled (set to 0 for infinite number of ramps) */
  
  pllGlobalRampSetup.eTriggerA   = LMX249x_RAMP_TRIG_NEVER_TRIGGERS;             /*!< Define the source for Trigger A */
 8028648:	f88d 4038 	strb.w	r4, [sp, #56]	; 0x38
  pllGlobalRampSetup.eTriggerB   = LMX249x_RAMP_TRIG_TRIG2_TERMINAL_RISING_EDGE; /*!< Define the source for Trigger B */
  pllGlobalRampSetup.eTriggerC   = LMX249x_RAMP_TRIG_NEVER_TRIGGERS;             /*!< Define the source for Trigger C */
 802864c:	f88d 403a 	strb.w	r4, [sp, #58]	; 0x3a
  pllGlobalRampSetup.eRampClock  = LMX249x_RAMP_CLOCK_INTERNAL;         	 /*!< determines if internal or external clock for ramp timing is used */
 8028650:	f88d 403b 	strb.w	r4, [sp, #59]	; 0x3b
  pllGlobalRampSetup.eModulation = LMX249x_RAMP_MODULATION_FM;        		 /*!< Kind of modulation */
 8028654:	f88d 403c 	strb.w	r4, [sp, #60]	; 0x3c
  pllGlobalRampSetup.eAutoOff    = LMX249x_RAMP_AUTO_OFF_ENABLE;           	 /*!< Defines, if the Ramp should be turned off after a certain amount of ramps */
  pllGlobalRampSetup.eRampCountTrigger = LMX249x_RAMP_COUNT_INCREMENT_SEGMENT_TRANSITION; /*!< Defines the increment trigger for the ramp counter */
 8028658:	f88d 4040 	strb.w	r4, [sp, #64]	; 0x40
  pllGlobalRampSetup.eTriggerA   = LMX249x_RAMP_TRIG_NEVER_TRIGGERS;             /*!< Define the source for Trigger A */
  pllGlobalRampSetup.eTriggerB   = LMX249x_RAMP_TRIG_TRIG2_TERMINAL_RISING_EDGE; /*!< Define the source for Trigger B */
  pllGlobalRampSetup.eTriggerC   = LMX249x_RAMP_TRIG_NEVER_TRIGGERS;             /*!< Define the source for Trigger C */
  pllGlobalRampSetup.eRampClock  = LMX249x_RAMP_CLOCK_INTERNAL;         	 /*!< determines if internal or external clock for ramp timing is used */
  pllGlobalRampSetup.eModulation = LMX249x_RAMP_MODULATION_FM;        		 /*!< Kind of modulation */
  pllGlobalRampSetup.eAutoOff    = LMX249x_RAMP_AUTO_OFF_ENABLE;           	 /*!< Defines, if the Ramp should be turned off after a certain amount of ramps */
 802865c:	f88d 503d 	strb.w	r5, [sp, #61]	; 0x3d
  pllGlobalRampSetup.eRampCountTrigger = LMX249x_RAMP_COUNT_INCREMENT_SEGMENT_TRANSITION; /*!< Defines the increment trigger for the ramp counter */
  pllGlobalRampSetup.eDevTrigger = LMX249x_TRIGGER_A;				 /*!< Defines the deviation trigger for FSK operation */
 8028660:	f88d 5041 	strb.w	r5, [sp, #65]	; 0x41
  pllGlobalRampSetup.eDitherMode = LMX249x_FRAC_DITHER_DISABLED;                 /*!< Defines the fractional dithering */
 8028664:	f88d 7043 	strb.w	r7, [sp, #67]	; 0x43
  pllGlobalRampSetup.eFracOrder  = LMX249x_FRAC_ORD_SECOND;                      /*!< Defines the fractional order */
  
  /* Calculate real frequency shift based on PLL clock */
  double bandwidth_MHz = lmx249x_get_real_frequency_shift(lmx249x_pll, s_pll_bandwidth_MHz, s_pll_chirp_time_usec);
 8028668:	f001 fb90 	bl	8029d8c <__aeabi_f2d>
 802866c:	460b      	mov	r3, r1
 802866e:	f8d9 1000 	ldr.w	r1, [r9]
 8028672:	9100      	str	r1, [sp, #0]
 8028674:	4602      	mov	r2, r0
 8028676:	4640      	mov	r0, r8
 8028678:	f000 fd88 	bl	802918c <lmx249x_get_real_frequency_shift>
  pllRampSections[0].eComparators = LMX249x_RAMP_NO_COMPARATOR;
  
  /* Ramp down to lower frequency */
  pllRampSections[1].dFreqShift   = -bandwidth_MHz;
  pllRampSections[1].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
  pllRampSections[1].dTramp       = (double)PLL_RAMP_DOWM_TIME_USEC;
 802867c:	ed9f 7b32 	vldr	d7, [pc, #200]	; 8028748 <pll_configure_ramps+0x190>
  pllGlobalRampSetup.eDevTrigger = LMX249x_TRIGGER_A;				 /*!< Defines the deviation trigger for FSK operation */
  pllGlobalRampSetup.eDitherMode = LMX249x_FRAC_DITHER_DISABLED;                 /*!< Defines the fractional dithering */
  pllGlobalRampSetup.eFracOrder  = LMX249x_FRAC_ORD_SECOND;                      /*!< Defines the fractional order */
  
  /* Calculate real frequency shift based on PLL clock */
  double bandwidth_MHz = lmx249x_get_real_frequency_shift(lmx249x_pll, s_pll_bandwidth_MHz, s_pll_chirp_time_usec);
 8028680:	4602      	mov	r2, r0
 8028682:	460b      	mov	r3, r1
  pllRampSections[2].eComparators = LMX249x_RAMP_NO_COMPARATOR;
  
  /* Ramp up and trigger ADC sampling */
  pllRampSections[3].dFreqShift   = bandwidth_MHz;
  pllRampSections[3].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
  pllRampSections[3].dTramp       = (double)s_pll_chirp_time_usec;
 8028684:	f8d9 0000 	ldr.w	r0, [r9]
  pllRampSections[0].dFreqShift   = 0.0;
  pllRampSections[0].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
  pllRampSections[0].dTramp       = 0;
  pllRampSections[0].eFlag        = LMX249x_RAMP_FLAG_CLR_BOTH;
  pllRampSections[0].eReset       = LMX249x_RAMP_RST_ENABLE;
  pllRampSections[0].eNextTrig    = LMX249x_RAMP_NEXT_TRIG_TRIGB;
 8028688:	f88d 6062 	strb.w	r6, [sp, #98]	; 0x62
  pllRampSections[0].uNext        = 1;
  pllRampSections[0].eComparators = LMX249x_RAMP_NO_COMPARATOR;
  
  /* Ramp down to lower frequency */
  pllRampSections[1].dFreqShift   = -bandwidth_MHz;
 802868c:	f101 4100 	add.w	r1, r1, #2147483648	; 0x80000000
  pllRampSections[2].eNextTrig    = LMX249x_RAMP_NEXT_TRIG_RAMPX_LEN;
  pllRampSections[2].uNext        = 3;
  pllRampSections[2].eComparators = LMX249x_RAMP_NO_COMPARATOR;
  
  /* Ramp up and trigger ADC sampling */
  pllRampSections[3].dFreqShift   = bandwidth_MHz;
 8028690:	e9cd 232a 	strd	r2, r3, [sp, #168]	; 0xa8
  pllRampSections[1].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
  pllRampSections[1].dTramp       = (double)PLL_RAMP_DOWM_TIME_USEC;
  pllRampSections[1].eFlag        = LMX249x_RAMP_FLAG_CLR_BOTH;
  pllRampSections[1].eReset       = LMX249x_RAMP_RST_DISABLE; /* first ramp resets counters */
  pllRampSections[1].eNextTrig    = LMX249x_RAMP_NEXT_TRIG_RAMPX_LEN;
  pllRampSections[1].uNext        = 2;
 8028694:	f88d 6083 	strb.w	r6, [sp, #131]	; 0x83
  pllRampSections[0].eNextTrig    = LMX249x_RAMP_NEXT_TRIG_TRIGB;
  pllRampSections[0].uNext        = 1;
  pllRampSections[0].eComparators = LMX249x_RAMP_NO_COMPARATOR;
  
  /* Ramp down to lower frequency */
  pllRampSections[1].dFreqShift   = -bandwidth_MHz;
 8028698:	921a      	str	r2, [sp, #104]	; 0x68
  pllRampSections[1].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
  pllRampSections[1].dTramp       = (double)PLL_RAMP_DOWM_TIME_USEC;
 802869a:	ed8d 7b1e 	vstr	d7, [sp, #120]	; 0x78
  pllRampSections[1].eComparators = LMX249x_RAMP_NO_COMPARATOR;
  
  /* Wait time between ramps */
  pllRampSections[2].dFreqShift   = 0;
  pllRampSections[2].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
  pllRampSections[2].dTramp       = (double)PLL_STEADY_STATE_USEC;
 802869e:	ed8d 7b26 	vstr	d7, [sp, #152]	; 0x98
  /* Calculate real frequency shift based on PLL clock */
  double bandwidth_MHz = lmx249x_get_real_frequency_shift(lmx249x_pll, s_pll_bandwidth_MHz, s_pll_chirp_time_usec);
  
  /* reset ramp  */
  pllRampSections[0].dFreqShift   = 0.0;
  pllRampSections[0].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
 80286a2:	f88d 4050 	strb.w	r4, [sp, #80]	; 0x50
  
  /* Calculate real frequency shift based on PLL clock */
  double bandwidth_MHz = lmx249x_get_real_frequency_shift(lmx249x_pll, s_pll_bandwidth_MHz, s_pll_chirp_time_usec);
  
  /* reset ramp  */
  pllRampSections[0].dFreqShift   = 0.0;
 80286a6:	e9cd ab12 	strd	sl, fp, [sp, #72]	; 0x48
  pllRampSections[0].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
  pllRampSections[0].dTramp       = 0;
 80286aa:	e9cd ab16 	strd	sl, fp, [sp, #88]	; 0x58
  pllRampSections[0].eFlag        = LMX249x_RAMP_FLAG_CLR_BOTH;
 80286ae:	f88d 4060 	strb.w	r4, [sp, #96]	; 0x60
  pllRampSections[0].eReset       = LMX249x_RAMP_RST_ENABLE;
 80286b2:	f88d 5061 	strb.w	r5, [sp, #97]	; 0x61
  pllRampSections[0].eNextTrig    = LMX249x_RAMP_NEXT_TRIG_TRIGB;
  pllRampSections[0].uNext        = 1;
 80286b6:	f88d 5063 	strb.w	r5, [sp, #99]	; 0x63
  pllRampSections[0].eComparators = LMX249x_RAMP_NO_COMPARATOR;
 80286ba:	f88d 4064 	strb.w	r4, [sp, #100]	; 0x64
  
  /* Ramp down to lower frequency */
  pllRampSections[1].dFreqShift   = -bandwidth_MHz;
  pllRampSections[1].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
 80286be:	f88d 4070 	strb.w	r4, [sp, #112]	; 0x70
  pllRampSections[1].dTramp       = (double)PLL_RAMP_DOWM_TIME_USEC;
  pllRampSections[1].eFlag        = LMX249x_RAMP_FLAG_CLR_BOTH;
 80286c2:	f88d 4080 	strb.w	r4, [sp, #128]	; 0x80
  pllRampSections[1].eReset       = LMX249x_RAMP_RST_DISABLE; /* first ramp resets counters */
 80286c6:	f88d 4081 	strb.w	r4, [sp, #129]	; 0x81
  pllRampSections[1].eNextTrig    = LMX249x_RAMP_NEXT_TRIG_RAMPX_LEN;
 80286ca:	f88d 4082 	strb.w	r4, [sp, #130]	; 0x82
  pllRampSections[1].uNext        = 2;
  pllRampSections[1].eComparators = LMX249x_RAMP_NO_COMPARATOR;
 80286ce:	f88d 4084 	strb.w	r4, [sp, #132]	; 0x84
  
  /* Wait time between ramps */
  pllRampSections[2].dFreqShift   = 0;
 80286d2:	e9cd ab22 	strd	sl, fp, [sp, #136]	; 0x88
  pllRampSections[2].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
 80286d6:	f88d 4090 	strb.w	r4, [sp, #144]	; 0x90
  pllRampSections[2].dTramp       = (double)PLL_STEADY_STATE_USEC;
  pllRampSections[2].eFlag        = LMX249x_RAMP_FLAG_CLR_BOTH;
 80286da:	f88d 40a0 	strb.w	r4, [sp, #160]	; 0xa0
  pllRampSections[2].eReset       = LMX249x_RAMP_RST_DISABLE;
 80286de:	f88d 40a1 	strb.w	r4, [sp, #161]	; 0xa1
  pllRampSections[2].eNextTrig    = LMX249x_RAMP_NEXT_TRIG_RAMPX_LEN;
 80286e2:	f88d 40a2 	strb.w	r4, [sp, #162]	; 0xa2
  pllRampSections[2].uNext        = 3;
 80286e6:	f88d 70a3 	strb.w	r7, [sp, #163]	; 0xa3
  pllRampSections[2].eComparators = LMX249x_RAMP_NO_COMPARATOR;
 80286ea:	f88d 40a4 	strb.w	r4, [sp, #164]	; 0xa4
  
  /* Ramp up and trigger ADC sampling */
  pllRampSections[3].dFreqShift   = bandwidth_MHz;
  pllRampSections[3].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
 80286ee:	f88d 40b0 	strb.w	r4, [sp, #176]	; 0xb0
  pllRampSections[0].eNextTrig    = LMX249x_RAMP_NEXT_TRIG_TRIGB;
  pllRampSections[0].uNext        = 1;
  pllRampSections[0].eComparators = LMX249x_RAMP_NO_COMPARATOR;
  
  /* Ramp down to lower frequency */
  pllRampSections[1].dFreqShift   = -bandwidth_MHz;
 80286f2:	911b      	str	r1, [sp, #108]	; 0x6c
  pllRampSections[2].eComparators = LMX249x_RAMP_NO_COMPARATOR;
  
  /* Ramp up and trigger ADC sampling */
  pllRampSections[3].dFreqShift   = bandwidth_MHz;
  pllRampSections[3].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
  pllRampSections[3].dTramp       = (double)s_pll_chirp_time_usec;
 80286f4:	f001 fb28 	bl	8029d48 <__aeabi_ui2d>
  pllRampSections[3].eFlag        = LMX249x_RAMP_FLAG_SET_BOTH;
  pllRampSections[3].eReset       = LMX249x_RAMP_RST_DISABLE;
  pllRampSections[3].eNextTrig    = LMX249x_RAMP_NEXT_TRIG_RAMPX_LEN;
  pllRampSections[3].uNext        = 4;
 80286f8:	2604      	movs	r6, #4
  pllRampSections[2].eComparators = LMX249x_RAMP_NO_COMPARATOR;
  
  /* Ramp up and trigger ADC sampling */
  pllRampSections[3].dFreqShift   = bandwidth_MHz;
  pllRampSections[3].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
  pllRampSections[3].dTramp       = (double)s_pll_chirp_time_usec;
 80286fa:	e9cd 012e 	strd	r0, r1, [sp, #184]	; 0xb8
  pllRampSections[4].eReset       = LMX249x_RAMP_RST_ENABLE;
  pllRampSections[4].eNextTrig    = LMX249x_RAMP_NEXT_TRIG_RAMPX_LEN;
  pllRampSections[4].uNext        = 1;
  pllRampSections[4].eComparators = LMX249x_RAMP_NO_COMPARATOR;
  
  lmx249x_configure_ramps(lmx249x_pll, &pllGlobalRampSetup, pllRampSections, 5);
 80286fe:	aa12      	add	r2, sp, #72	; 0x48
 8028700:	4640      	mov	r0, r8
 8028702:	a902      	add	r1, sp, #8
 8028704:	2305      	movs	r3, #5
  
  /* Ramp up and trigger ADC sampling */
  pllRampSections[3].dFreqShift   = bandwidth_MHz;
  pllRampSections[3].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
  pllRampSections[3].dTramp       = (double)s_pll_chirp_time_usec;
  pllRampSections[3].eFlag        = LMX249x_RAMP_FLAG_SET_BOTH;
 8028706:	f88d 70c0 	strb.w	r7, [sp, #192]	; 0xc0
  pllRampSections[3].eReset       = LMX249x_RAMP_RST_DISABLE;
 802870a:	f88d 40c1 	strb.w	r4, [sp, #193]	; 0xc1
  pllRampSections[3].eNextTrig    = LMX249x_RAMP_NEXT_TRIG_RAMPX_LEN;
 802870e:	f88d 40c2 	strb.w	r4, [sp, #194]	; 0xc2
  pllRampSections[3].uNext        = 4;
  pllRampSections[3].eComparators = LMX249x_RAMP_NO_COMPARATOR;
 8028712:	f88d 40c4 	strb.w	r4, [sp, #196]	; 0xc4
  
  /* Clear ADC sampling flags */
  pllRampSections[4].dFreqShift   = 0;
 8028716:	e9cd ab32 	strd	sl, fp, [sp, #200]	; 0xc8
  pllRampSections[4].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
 802871a:	f88d 40d0 	strb.w	r4, [sp, #208]	; 0xd0
  pllRampSections[4].dTramp       = 0;
 802871e:	e9cd ab36 	strd	sl, fp, [sp, #216]	; 0xd8
  pllRampSections[4].eFlag        = LMX249x_RAMP_FLAG_CLR_BOTH;
 8028722:	f88d 40e0 	strb.w	r4, [sp, #224]	; 0xe0
  pllRampSections[4].eReset       = LMX249x_RAMP_RST_ENABLE;
 8028726:	f88d 50e1 	strb.w	r5, [sp, #225]	; 0xe1
  pllRampSections[4].eNextTrig    = LMX249x_RAMP_NEXT_TRIG_RAMPX_LEN;
 802872a:	f88d 40e2 	strb.w	r4, [sp, #226]	; 0xe2
  pllRampSections[4].uNext        = 1;
 802872e:	f88d 50e3 	strb.w	r5, [sp, #227]	; 0xe3
  pllRampSections[4].eComparators = LMX249x_RAMP_NO_COMPARATOR;
 8028732:	f88d 40e4 	strb.w	r4, [sp, #228]	; 0xe4
  pllRampSections[3].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
  pllRampSections[3].dTramp       = (double)s_pll_chirp_time_usec;
  pllRampSections[3].eFlag        = LMX249x_RAMP_FLAG_SET_BOTH;
  pllRampSections[3].eReset       = LMX249x_RAMP_RST_DISABLE;
  pllRampSections[3].eNextTrig    = LMX249x_RAMP_NEXT_TRIG_RAMPX_LEN;
  pllRampSections[3].uNext        = 4;
 8028736:	f88d 60c3 	strb.w	r6, [sp, #195]	; 0xc3
  pllRampSections[4].eReset       = LMX249x_RAMP_RST_ENABLE;
  pllRampSections[4].eNextTrig    = LMX249x_RAMP_NEXT_TRIG_RAMPX_LEN;
  pllRampSections[4].uNext        = 1;
  pllRampSections[4].eComparators = LMX249x_RAMP_NO_COMPARATOR;
  
  lmx249x_configure_ramps(lmx249x_pll, &pllGlobalRampSetup, pllRampSections, 5);
 802873a:	f000 faf3 	bl	8028d24 <lmx249x_configure_ramps>
}
 802873e:	b03b      	add	sp, #236	; 0xec
 8028740:	ecbd 8b04 	vpop	{d8-d9}
 8028744:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8028748:	00000000 	.word	0x00000000
 802874c:	40590000 	.word	0x40590000
 8028750:	1fff2004 	.word	0x1fff2004
 8028754:	1fff1fec 	.word	0x1fff1fec
 8028758:	1fff1fe8 	.word	0x1fff1fe8
 802875c:	1fff1ff0 	.word	0x1fff1ff0
 8028760:	1ffe8b60 	.word	0x1ffe8b60
 8028764:	1ffe8b5c 	.word	0x1ffe8b5c

08028768 <pll_enable_ramps>:
//============================================================================

void pll_enable_ramps(void* pll_handle)
{
  Lmx249x_Object_t* lmx249x_pll = (Lmx249x_Object_t*)pll_handle;
  lmx249x_enable_ramps(lmx249x_pll, true);
 8028768:	2101      	movs	r1, #1
 802876a:	f000 bcf7 	b.w	802915c <lmx249x_enable_ramps>
 802876e:	bf00      	nop

08028770 <pll_disable_ramps>:
//============================================================================

void pll_disable_ramps(void* pll_handle)
{
  Lmx249x_Object_t* lmx249x_pll = (Lmx249x_Object_t*)pll_handle;
  lmx249x_enable_ramps(lmx249x_pll, false);
 8028770:	2100      	movs	r1, #0
 8028772:	f000 bcf3 	b.w	802915c <lmx249x_enable_ramps>
 8028776:	bf00      	nop

08028778 <pll_trigger_ramp>:
//============================================================================

void pll_trigger_ramp(void)
{
  /* Start ramps generation */
  lmx249x_trigger_ramp();
 8028778:	f000 bd4e 	b.w	8029218 <lmx249x_trigger_ramp>

0802877c <pll_release_ramp_trigger>:
//============================================================================

void pll_release_ramp_trigger(void)
{
  /* Bring PLL trigger to down state */
  lmx249x_release_ramp_trigger();
 802877c:	f000 bd60 	b.w	8029240 <lmx249x_release_ramp_trigger>

08028780 <pll_power_up>:
//============================================================================

void pll_power_up(void)
{
  /* PLL power-up */
  lmx249x_power_up();
 8028780:	f000 bd68 	b.w	8029254 <lmx249x_power_up>

08028784 <pll_power_down>:
//============================================================================

void pll_power_down(void)
{
  /* PLL power-down */
  lmx249x_power_down();
 8028784:	f000 bd70 	b.w	8029268 <lmx249x_power_down>

08028788 <pll_update_configuration>:
}

//============================================================================

void pll_update_configuration(void* pll_handle, uint8_t modulation_type)
{
 8028788:	b530      	push	{r4, r5, lr}
 802878a:	460c      	mov	r4, r1
 802878c:	b083      	sub	sp, #12
 802878e:	4605      	mov	r5, r0
  Lmx249x_Object_t* lmx249x_pll = (Lmx249x_Object_t*)pll_handle;
  
  pll_configure_ramps(lmx249x_pll);
 8028790:	f7ff ff12 	bl	80285b8 <pll_configure_ramps>
  
  if (modulation_type == 1) /* FMCW modulation */
 8028794:	2c01      	cmp	r4, #1
 8028796:	d011      	beq.n	80287bc <pll_update_configuration+0x34>
  {
    lmx249x_enable_ramps(lmx249x_pll, true);
  }
  else
  {
    lmx249x_set_frequency(lmx249x_pll, s_pll_base_freq_MHz, LMX249x_FRAC_ORD_THIRD, LMX249x_FRAC_DITHER_WEAK);
 8028798:	4b0b      	ldr	r3, [pc, #44]	; (80287c8 <pll_update_configuration+0x40>)
 802879a:	6818      	ldr	r0, [r3, #0]
 802879c:	f001 faf6 	bl	8029d8c <__aeabi_f2d>
 80287a0:	2403      	movs	r4, #3
 80287a2:	460b      	mov	r3, r1
 80287a4:	2100      	movs	r1, #0
 80287a6:	4602      	mov	r2, r0
 80287a8:	9400      	str	r4, [sp, #0]
 80287aa:	4628      	mov	r0, r5
 80287ac:	9101      	str	r1, [sp, #4]
 80287ae:	f000 fa51 	bl	8028c54 <lmx249x_set_frequency>
  }
  
  s_update_pll_config_flag = false;
 80287b2:	4b06      	ldr	r3, [pc, #24]	; (80287cc <pll_update_configuration+0x44>)
 80287b4:	2200      	movs	r2, #0
 80287b6:	701a      	strb	r2, [r3, #0]
}
 80287b8:	b003      	add	sp, #12
 80287ba:	bd30      	pop	{r4, r5, pc}
  
  pll_configure_ramps(lmx249x_pll);
  
  if (modulation_type == 1) /* FMCW modulation */
  {
    lmx249x_enable_ramps(lmx249x_pll, true);
 80287bc:	4628      	mov	r0, r5
 80287be:	4621      	mov	r1, r4
 80287c0:	f000 fccc 	bl	802915c <lmx249x_enable_ramps>
 80287c4:	e7f5      	b.n	80287b2 <pll_update_configuration+0x2a>
 80287c6:	bf00      	nop
 80287c8:	1fff2004 	.word	0x1fff2004
 80287cc:	1fff1fe4 	.word	0x1fff1fe4

080287d0 <pll_set_update_config_flag>:

void pll_set_update_config_flag(uint8_t flag)
{
  if (flag == 0)
  {
    s_update_pll_config_flag = false;
 80287d0:	4b03      	ldr	r3, [pc, #12]	; (80287e0 <pll_set_update_config_flag+0x10>)

//============================================================================

void pll_set_update_config_flag(uint8_t flag)
{
  if (flag == 0)
 80287d2:	b110      	cbz	r0, 80287da <pll_set_update_config_flag+0xa>
  {
    s_update_pll_config_flag = false;
  }
  else
  {
    s_update_pll_config_flag = true;
 80287d4:	2201      	movs	r2, #1
 80287d6:	701a      	strb	r2, [r3, #0]
 80287d8:	4770      	bx	lr

void pll_set_update_config_flag(uint8_t flag)
{
  if (flag == 0)
  {
    s_update_pll_config_flag = false;
 80287da:	7018      	strb	r0, [r3, #0]
 80287dc:	4770      	bx	lr
 80287de:	bf00      	nop
 80287e0:	1fff1fe4 	.word	0x1fff1fe4

080287e4 <pll_get_update_config_flag>:

//============================================================================

uint8_t pll_get_update_config_flag(void)
{
  return (s_update_pll_config_flag);
 80287e4:	4b01      	ldr	r3, [pc, #4]	; (80287ec <pll_get_update_config_flag+0x8>)
 80287e6:	7818      	ldrb	r0, [r3, #0]
}
 80287e8:	4770      	bx	lr
 80287ea:	bf00      	nop
 80287ec:	1fff1fe4 	.word	0x1fff1fe4

080287f0 <pll_set_frequency>:

//============================================================================

void pll_set_frequency(double freq_MHz)
{
 80287f0:	b538      	push	{r3, r4, r5, lr}
	/* This check ensures, that the RF Frequency is not set out-side of the 24GHz- ISM band,
	 * do not circumvent it would understanding the consequences. Emitting outside ISM band is forbidden.
	 */

	if( freq_MHz < (double) ISM_MIN_RF_FREQUENCY_KHZ / 1000.0 )
 80287f2:	a312      	add	r3, pc, #72	; (adr r3, 802883c <pll_set_frequency+0x4c>)
 80287f4:	e9d3 2300 	ldrd	r2, r3, [r3]
}

//============================================================================

void pll_set_frequency(double freq_MHz)
{
 80287f8:	4604      	mov	r4, r0
 80287fa:	460d      	mov	r5, r1
	/* This check ensures, that the RF Frequency is not set out-side of the 24GHz- ISM band,
	 * do not circumvent it would understanding the consequences. Emitting outside ISM band is forbidden.
	 */

	if( freq_MHz < (double) ISM_MIN_RF_FREQUENCY_KHZ / 1000.0 )
 80287fc:	f001 fd8c 	bl	802a318 <__aeabi_dcmplt>
 8028800:	b990      	cbnz	r0, 8028828 <pll_set_frequency+0x38>
		freq_MHz = (double) ISM_MIN_RF_FREQUENCY_KHZ / 1000.0;

	else if( freq_MHz > (double) ISM_MAX_RF_FREQUENCY_KHZ / 1000.0 )
 8028802:	4620      	mov	r0, r4
 8028804:	4629      	mov	r1, r5
 8028806:	a30f      	add	r3, pc, #60	; (adr r3, 8028844 <pll_set_frequency+0x54>)
 8028808:	e9d3 2300 	ldrd	r2, r3, [r3]
 802880c:	f001 fda2 	bl	802a354 <__aeabi_dcmpgt>
 8028810:	b118      	cbz	r0, 802881a <pll_set_frequency+0x2a>
		freq_MHz = (double) ISM_MAX_RF_FREQUENCY_KHZ / 1000.0;

	s_pll_base_freq_MHz = freq_MHz;
 8028812:	4b07      	ldr	r3, [pc, #28]	; (8028830 <pll_set_frequency+0x40>)
 8028814:	4807      	ldr	r0, [pc, #28]	; (8028834 <pll_set_frequency+0x44>)
 8028816:	6018      	str	r0, [r3, #0]
 8028818:	bd38      	pop	{r3, r4, r5, pc}
 802881a:	4620      	mov	r0, r4
 802881c:	4629      	mov	r1, r5
 802881e:	f001 fdeb 	bl	802a3f8 <__aeabi_d2f>
 8028822:	4b03      	ldr	r3, [pc, #12]	; (8028830 <pll_set_frequency+0x40>)
 8028824:	6018      	str	r0, [r3, #0]
 8028826:	bd38      	pop	{r3, r4, r5, pc}
 8028828:	4b01      	ldr	r3, [pc, #4]	; (8028830 <pll_set_frequency+0x40>)
 802882a:	4803      	ldr	r0, [pc, #12]	; (8028838 <pll_set_frequency+0x48>)
 802882c:	6018      	str	r0, [r3, #0]
 802882e:	bd38      	pop	{r3, r4, r5, pc}
 8028830:	1fff2004 	.word	0x1fff2004
 8028834:	46bd4200 	.word	0x46bd4200
 8028838:	46bbb200 	.word	0x46bbb200
 802883c:	00000000 	.word	0x00000000
 8028840:	40d77640 	.word	0x40d77640
 8028844:	00000000 	.word	0x00000000
 8028848:	40d7a840 	.word	0x40d7a840
 802884c:	f3af 8000 	nop.w

08028850 <pll_set_upper_lower_frequency>:
}

//============================================================================

void pll_set_upper_lower_frequency(double lower_freq_MHz, double upper_freq_MHz)
{
 8028850:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8028852:	4614      	mov	r4, r2
 8028854:	461d      	mov	r5, r3
	/* This check ensures, that the RF Frequency is not set out-side of the 24GHz- ISM band,
	 * do not circumvent it would understanding the consequences. Emitting outside ISM band is forbidden.
	 */
	if( lower_freq_MHz < (double) ISM_MIN_RF_FREQUENCY_KHZ / 1000.0 )
 8028856:	a316      	add	r3, pc, #88	; (adr r3, 80288b0 <pll_set_upper_lower_frequency+0x60>)
 8028858:	e9d3 2300 	ldrd	r2, r3, [r3]
}

//============================================================================

void pll_set_upper_lower_frequency(double lower_freq_MHz, double upper_freq_MHz)
{
 802885c:	4606      	mov	r6, r0
 802885e:	460f      	mov	r7, r1
	/* This check ensures, that the RF Frequency is not set out-side of the 24GHz- ISM band,
	 * do not circumvent it would understanding the consequences. Emitting outside ISM band is forbidden.
	 */
	if( lower_freq_MHz < (double) ISM_MIN_RF_FREQUENCY_KHZ / 1000.0 )
 8028860:	f001 fd5a 	bl	802a318 <__aeabi_dcmplt>
 8028864:	b990      	cbnz	r0, 802888c <pll_set_upper_lower_frequency+0x3c>
 8028866:	4630      	mov	r0, r6
 8028868:	4639      	mov	r1, r7
 802886a:	f001 fdc5 	bl	802a3f8 <__aeabi_d2f>
 802886e:	4606      	mov	r6, r0
		lower_freq_MHz = (double) ISM_MIN_RF_FREQUENCY_KHZ / 1000.0;

	if( upper_freq_MHz > (double) ISM_MAX_RF_FREQUENCY_KHZ / 1000.0 )
 8028870:	4620      	mov	r0, r4
 8028872:	4629      	mov	r1, r5
 8028874:	a310      	add	r3, pc, #64	; (adr r3, 80288b8 <pll_set_upper_lower_frequency+0x68>)
 8028876:	e9d3 2300 	ldrd	r2, r3, [r3]
 802887a:	f001 fd6b 	bl	802a354 <__aeabi_dcmpgt>
 802887e:	b138      	cbz	r0, 8028890 <pll_set_upper_lower_frequency+0x40>
 8028880:	4807      	ldr	r0, [pc, #28]	; (80288a0 <pll_set_upper_lower_frequency+0x50>)
		upper_freq_MHz = (double) ISM_MAX_RF_FREQUENCY_KHZ / 1000.0;

  s_pll_lower_freq_MHz = lower_freq_MHz;
 8028882:	4a08      	ldr	r2, [pc, #32]	; (80288a4 <pll_set_upper_lower_frequency+0x54>)
  s_pll_upper_freq_MHz = upper_freq_MHz;
 8028884:	4b08      	ldr	r3, [pc, #32]	; (80288a8 <pll_set_upper_lower_frequency+0x58>)
		lower_freq_MHz = (double) ISM_MIN_RF_FREQUENCY_KHZ / 1000.0;

	if( upper_freq_MHz > (double) ISM_MAX_RF_FREQUENCY_KHZ / 1000.0 )
		upper_freq_MHz = (double) ISM_MAX_RF_FREQUENCY_KHZ / 1000.0;

  s_pll_lower_freq_MHz = lower_freq_MHz;
 8028886:	6016      	str	r6, [r2, #0]
  s_pll_upper_freq_MHz = upper_freq_MHz;
 8028888:	6018      	str	r0, [r3, #0]
 802888a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802888c:	4e07      	ldr	r6, [pc, #28]	; (80288ac <pll_set_upper_lower_frequency+0x5c>)
 802888e:	e7ef      	b.n	8028870 <pll_set_upper_lower_frequency+0x20>
 8028890:	4620      	mov	r0, r4
 8028892:	4629      	mov	r1, r5
 8028894:	f001 fdb0 	bl	802a3f8 <__aeabi_d2f>
 8028898:	e7f3      	b.n	8028882 <pll_set_upper_lower_frequency+0x32>
 802889a:	bf00      	nop
 802889c:	f3af 8000 	nop.w
 80288a0:	46bd4200 	.word	0x46bd4200
 80288a4:	1fff1fec 	.word	0x1fff1fec
 80288a8:	1fff1fe8 	.word	0x1fff1fe8
 80288ac:	46bbb200 	.word	0x46bbb200
 80288b0:	00000000 	.word	0x00000000
 80288b4:	40d77640 	.word	0x40d77640
 80288b8:	00000000 	.word	0x00000000
 80288bc:	40d7a840 	.word	0x40d7a840

080288c0 <pll_set_num_chirps_per_frame>:

//============================================================================

void pll_set_num_chirps_per_frame(uint32_t num_chirps_per_frame)
{
  s_pll_num_of_chirps = num_chirps_per_frame;
 80288c0:	4b01      	ldr	r3, [pc, #4]	; (80288c8 <pll_set_num_chirps_per_frame+0x8>)
 80288c2:	6018      	str	r0, [r3, #0]
 80288c4:	4770      	bx	lr
 80288c6:	bf00      	nop
 80288c8:	1fff1ff0 	.word	0x1fff1ff0

080288cc <pll_set_bandwidth>:

//============================================================================

void pll_set_bandwidth(float bandwidth_MHz)
{
  s_pll_bandwidth_MHz = bandwidth_MHz;
 80288cc:	4b01      	ldr	r3, [pc, #4]	; (80288d4 <pll_set_bandwidth+0x8>)
 80288ce:	6018      	str	r0, [r3, #0]
 80288d0:	4770      	bx	lr
 80288d2:	bf00      	nop
 80288d4:	1ffe8b60 	.word	0x1ffe8b60

080288d8 <pll_set_chirp_time>:

//============================================================================

void pll_set_chirp_time(uint32_t chirp_time_usec)
{
  s_pll_chirp_time_usec = chirp_time_usec;
 80288d8:	4b01      	ldr	r3, [pc, #4]	; (80288e0 <pll_set_chirp_time+0x8>)
 80288da:	6018      	str	r0, [r3, #0]
 80288dc:	4770      	bx	lr
 80288de:	bf00      	nop
 80288e0:	1ffe8b5c 	.word	0x1ffe8b5c

080288e4 <spi_transmit_data>:
   2. EXPORTED FUNCTIONS
==============================================================================
 */

void spi_transmit_data(uint8_t* data_ptr, uint8_t num_of_bytes, void* peripheral_ptr)
{
 80288e4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  SPI_DIGITAL_IOs_t spi_pins = *(SPI_DIGITAL_IOs_t*)peripheral_ptr;
 80288e8:	f8d2 e004 	ldr.w	lr, [r2, #4]
 80288ec:	6896      	ldr	r6, [r2, #8]

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 80288ee:	f89e 5010 	ldrb.w	r5, [lr, #16]
 80288f2:	f8de c000 	ldr.w	ip, [lr]
 80288f6:	68d4      	ldr	r4, [r2, #12]
 80288f8:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80288fc:	fa03 f205 	lsl.w	r2, r3, r5
 8028900:	f8cc 2004 	str.w	r2, [ip, #4]
  uint8_t index, data;
  
  DIGITAL_IO_SetOutputLow((DIGITAL_IO_t*)spi_pins.gpio_cs_pin);
  __NOP(); __NOP(); __NOP(); __NOP();
 8028904:	bf00      	nop
 8028906:	bf00      	nop
 8028908:	bf00      	nop
 802890a:	bf00      	nop
  
  for (uint8_t count = 0U; count < num_of_bytes; count++)
 802890c:	b399      	cbz	r1, 8028976 <spi_transmit_data+0x92>
 802890e:	f101 39ff 	add.w	r9, r1, #4294967295
 8028912:	6837      	ldr	r7, [r6, #0]
 8028914:	6821      	ldr	r1, [r4, #0]
 8028916:	fa50 f989 	uxtab	r9, r0, r9
 802891a:	f100 38ff 	add.w	r8, r0, #4294967295

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 802891e:	2501      	movs	r5, #1

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 8028920:	4618      	mov	r0, r3
  {
    data = *data_ptr++;
 8028922:	f818 2f01 	ldrb.w	r2, [r8, #1]!
 8028926:	2308      	movs	r3, #8

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 8028928:	f896 a010 	ldrb.w	sl, [r6, #16]
    
    for (index =0 ; index < 8U; index++)
    {
      if (data & 0x80)
 802892c:	f012 0f80 	tst.w	r2, #128	; 0x80
 8028930:	bf14      	ite	ne
 8028932:	fa05 fa0a 	lslne.w	sl, r5, sl

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 8028936:	fa00 fa0a 	lsleq.w	sl, r0, sl
 802893a:	f8c7 a004 	str.w	sl, [r7, #4]
      }
      else
      {
        DIGITAL_IO_SetOutputLow((DIGITAL_IO_t*)spi_pins.gpio_data_pin);
      }
      __NOP(); __NOP();
 802893e:	bf00      	nop
 8028940:	bf00      	nop

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 8028942:	f894 a010 	ldrb.w	sl, [r4, #16]
 8028946:	fa05 fa0a 	lsl.w	sl, r5, sl
 802894a:	f8c1 a004 	str.w	sl, [r1, #4]
      
      DIGITAL_IO_SetOutputHigh((DIGITAL_IO_t*)spi_pins.gpio_clk_pin);
      __NOP(); __NOP(); __NOP(); __NOP();
 802894e:	bf00      	nop
 8028950:	bf00      	nop
 8028952:	bf00      	nop
 8028954:	bf00      	nop

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 8028956:	f894 a010 	ldrb.w	sl, [r4, #16]
 802895a:	fa00 fa0a 	lsl.w	sl, r0, sl
 802895e:	f8c1 a004 	str.w	sl, [r1, #4]
      
      DIGITAL_IO_SetOutputLow((DIGITAL_IO_t*)spi_pins.gpio_clk_pin);
      __NOP(); __NOP();
 8028962:	bf00      	nop
 8028964:	bf00      	nop
 8028966:	3b01      	subs	r3, #1
      
      data <<= 1;
 8028968:	0052      	lsls	r2, r2, #1
  
  for (uint8_t count = 0U; count < num_of_bytes; count++)
  {
    data = *data_ptr++;
    
    for (index =0 ; index < 8U; index++)
 802896a:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
      __NOP(); __NOP(); __NOP(); __NOP();
      
      DIGITAL_IO_SetOutputLow((DIGITAL_IO_t*)spi_pins.gpio_clk_pin);
      __NOP(); __NOP();
      
      data <<= 1;
 802896e:	b2d2      	uxtb	r2, r2
  
  for (uint8_t count = 0U; count < num_of_bytes; count++)
  {
    data = *data_ptr++;
    
    for (index =0 ; index < 8U; index++)
 8028970:	d1da      	bne.n	8028928 <spi_transmit_data+0x44>
  uint8_t index, data;
  
  DIGITAL_IO_SetOutputLow((DIGITAL_IO_t*)spi_pins.gpio_cs_pin);
  __NOP(); __NOP(); __NOP(); __NOP();
  
  for (uint8_t count = 0U; count < num_of_bytes; count++)
 8028972:	45c8      	cmp	r8, r9
 8028974:	d1d5      	bne.n	8028922 <spi_transmit_data+0x3e>

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 8028976:	f89e 2010 	ldrb.w	r2, [lr, #16]
 802897a:	2301      	movs	r3, #1
 802897c:	4093      	lsls	r3, r2
 802897e:	f8cc 3004 	str.w	r3, [ip, #4]
      data <<= 1;
    }
  }
  
  DIGITAL_IO_SetOutputHigh((DIGITAL_IO_t*)spi_pins.gpio_cs_pin);
  __NOP(); __NOP(); __NOP(); __NOP();
 8028982:	bf00      	nop
 8028984:	bf00      	nop
 8028986:	bf00      	nop
 8028988:	bf00      	nop
 802898a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802898e:	bf00      	nop

08028990 <com_init>:
   2. EXPORTED FUNCTIONS
==============================================================================
 */
   
void com_init(void)
{
 8028990:	4770      	bx	lr
 8028992:	bf00      	nop

08028994 <com_send_data>:

//============================================================================

void com_send_data(const void* pData, uint16_t uNumBytes)
{
  USBD_VCOM_SendData(pData,uNumBytes);
 8028994:	f7fc bcec 	b.w	8025370 <USBD_VCOM_SendData>

08028998 <com_get_data>:
}

//============================================================================

uint16_t com_get_data(void* pData, uint16_t uNumBytes)
{
 8028998:	b538      	push	{r3, r4, r5, lr}
 802899a:	460c      	mov	r4, r1
 802899c:	4605      	mov	r5, r0
  uint16_t bytes = 0;
  
  bytes = USBD_VCOM_BytesReceived();
 802899e:	f7fc fd25 	bl	80253ec <USBD_VCOM_BytesReceived>
  
  bytes = (bytes > uNumBytes) ? uNumBytes : bytes;
 80289a2:	42a0      	cmp	r0, r4
 80289a4:	bf28      	it	cs
 80289a6:	4620      	movcs	r0, r4
 80289a8:	b284      	uxth	r4, r0
  
  if (bytes)
 80289aa:	b11c      	cbz	r4, 80289b4 <com_get_data+0x1c>
  {
    USBD_VCOM_ReceiveData((int8_t*)pData, bytes);
 80289ac:	4628      	mov	r0, r5
 80289ae:	4621      	mov	r1, r4
 80289b0:	f7fc fcf8 	bl	80253a4 <USBD_VCOM_ReceiveData>
  }
  
  return (bytes);
}
 80289b4:	4620      	mov	r0, r4
 80289b6:	bd38      	pop	{r3, r4, r5, pc}

080289b8 <com_flush>:

//============================================================================

void com_flush(void)
{
  CDC_Device_USBTask(&USBD_VCOM_cdc_interface);	/* Do nothing as USBD VCOM already flushes the data that is sent */
 80289b8:	4801      	ldr	r0, [pc, #4]	; (80289c0 <com_flush+0x8>)
 80289ba:	f7fc bb21 	b.w	8025000 <CDC_Device_USBTask>
 80289be:	bf00      	nop
 80289c0:	1fffab34 	.word	0x1fffab34

080289c4 <pga112_init>:
   4. EXPORTED FUNCTIONS
==============================================================================
 */

Pga_Status_t pga112_init(uint16_t gain_level)
{
 80289c4:	b570      	push	{r4, r5, r6, lr}
  /* Set the digital IOs used by SPI interface */
  pga112_spi_pins.spi_device = PGA_DEVICE;
 80289c6:	4a15      	ldr	r2, [pc, #84]	; (8028a1c <pga112_init+0x58>)
  pga112_spi_pins.gpio_cs_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_PGA;
 80289c8:	4915      	ldr	r1, [pc, #84]	; (8028a20 <pga112_init+0x5c>)
  pga112_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_DATA_PGA;
 80289ca:	4d16      	ldr	r5, [pc, #88]	; (8028a24 <pga112_init+0x60>)
  pga112_spi_pins.gpio_clk_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;
 80289cc:	4b16      	ldr	r3, [pc, #88]	; (8028a28 <pga112_init+0x64>)

Pga_Status_t pga112_init(uint16_t gain_level)
{
  /* Set the digital IOs used by SPI interface */
  pga112_spi_pins.spi_device = PGA_DEVICE;
  pga112_spi_pins.gpio_cs_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_PGA;
 80289ce:	6051      	str	r1, [r2, #4]
   4. EXPORTED FUNCTIONS
==============================================================================
 */

Pga_Status_t pga112_init(uint16_t gain_level)
{
 80289d0:	b082      	sub	sp, #8
  /* Set the digital IOs used by SPI interface */
  pga112_spi_pins.spi_device = PGA_DEVICE;
 80289d2:	2102      	movs	r1, #2
//============================================================================

Pga_Status_t pga112_set_gain(uint16_t gain_level)
{
  Pga112_Binary_Gain_t  gain_val;
  uint16_t shuffled_data = 0;
 80289d4:	2400      	movs	r4, #0

  if(gain_level > PGA112_MAX_NUMBER_SUPPORTED_GAIN)
 80289d6:	2807      	cmp	r0, #7
Pga_Status_t pga112_init(uint16_t gain_level)
{
  /* Set the digital IOs used by SPI interface */
  pga112_spi_pins.spi_device = PGA_DEVICE;
  pga112_spi_pins.gpio_cs_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_PGA;
  pga112_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_DATA_PGA;
 80289d8:	6095      	str	r5, [r2, #8]
  pga112_spi_pins.gpio_clk_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;
 80289da:	60d3      	str	r3, [r2, #12]
 */

Pga_Status_t pga112_init(uint16_t gain_level)
{
  /* Set the digital IOs used by SPI interface */
  pga112_spi_pins.spi_device = PGA_DEVICE;
 80289dc:	7011      	strb	r1, [r2, #0]
//============================================================================

Pga_Status_t pga112_set_gain(uint16_t gain_level)
{
  Pga112_Binary_Gain_t  gain_val;
  uint16_t shuffled_data = 0;
 80289de:	f8ad 4006 	strh.w	r4, [sp, #6]

  if(gain_level > PGA112_MAX_NUMBER_SUPPORTED_GAIN)
 80289e2:	d818      	bhi.n	8028a16 <pga112_init+0x52>
 80289e4:	4b11      	ldr	r3, [pc, #68]	; (8028a2c <pga112_init+0x68>)

  /* Get PGA112 gain value from the selected index */
  pga112_global_gain = gain_level;
  gain_val = pga112_get_binary_gain(gain_level);

  pga112_global_config = (PGA112_CMD_WRITE | gain_val | PGA112_CH1);
 80289e6:	4e12      	ldr	r6, [pc, #72]	; (8028a30 <pga112_init+0x6c>)
 80289e8:	5c1b      	ldrb	r3, [r3, r0]
  {
    return (PGA_STATUS_FAIL);
  }

  /* Get PGA112 gain value from the selected index */
  pga112_global_gain = gain_level;
 80289ea:	4d12      	ldr	r5, [pc, #72]	; (8028a34 <pga112_init+0x70>)
  gain_val = pga112_get_binary_gain(gain_level);

  pga112_global_config = (PGA112_CMD_WRITE | gain_val | PGA112_CH1);
 80289ec:	f443 5328 	orr.w	r3, r3, #10752	; 0x2a00
 80289f0:	f043 0301 	orr.w	r3, r3, #1
  {
    return (PGA_STATUS_FAIL);
  }

  /* Get PGA112 gain value from the selected index */
  pga112_global_gain = gain_level;
 80289f4:	8028      	strh	r0, [r5, #0]
  gain_val = pga112_get_binary_gain(gain_level);

  pga112_global_config = (PGA112_CMD_WRITE | gain_val | PGA112_CH1);
 80289f6:	8033      	strh	r3, [r6, #0]

  /* Lower byte goes to upper byte position */
  shuffled_data  = ((pga112_global_config & 0x00FF) << 8);
 80289f8:	8835      	ldrh	r5, [r6, #0]

  /* Upper byte goes to lower byte position */
  shuffled_data |= ((pga112_global_config & 0xFF00) >> 8);
 80289fa:	8833      	ldrh	r3, [r6, #0]
 80289fc:	a802      	add	r0, sp, #8
  gain_val = pga112_get_binary_gain(gain_level);

  pga112_global_config = (PGA112_CMD_WRITE | gain_val | PGA112_CH1);

  /* Lower byte goes to upper byte position */
  shuffled_data  = ((pga112_global_config & 0x00FF) << 8);
 80289fe:	b2ad      	uxth	r5, r5

  /* Upper byte goes to lower byte position */
  shuffled_data |= ((pga112_global_config & 0xFF00) >> 8);
 8028a00:	f3c3 2307 	ubfx	r3, r3, #8, #8
 8028a04:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
 8028a08:	f820 3d02 	strh.w	r3, [r0, #-2]!

  /* Send command to PGA112 */
  spi_transmit_data((uint8_t *)&shuffled_data, 2, (void*) &pga112_spi_pins);
 8028a0c:	f7ff ff6a 	bl	80288e4 <spi_transmit_data>

  return (PGA_STATUS_SUCCESS);
 8028a10:	4620      	mov	r0, r4
  pga112_spi_pins.gpio_cs_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_PGA;
  pga112_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_DATA_PGA;
  pga112_spi_pins.gpio_clk_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;

  return (pga112_set_gain(gain_level));
}
 8028a12:	b002      	add	sp, #8
 8028a14:	bd70      	pop	{r4, r5, r6, pc}
  Pga112_Binary_Gain_t  gain_val;
  uint16_t shuffled_data = 0;

  if(gain_level > PGA112_MAX_NUMBER_SUPPORTED_GAIN)
  {
    return (PGA_STATUS_FAIL);
 8028a16:	2001      	movs	r0, #1
  pga112_spi_pins.gpio_cs_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_PGA;
  pga112_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_DATA_PGA;
  pga112_spi_pins.gpio_clk_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;

  return (pga112_set_gain(gain_level));
}
 8028a18:	b002      	add	sp, #8
 8028a1a:	bd70      	pop	{r4, r5, r6, pc}
 8028a1c:	1fff2008 	.word	0x1fff2008
 8028a20:	0802af34 	.word	0x0802af34
 8028a24:	0802af0c 	.word	0x0802af0c
 8028a28:	0802af20 	.word	0x0802af20
 8028a2c:	0802b264 	.word	0x0802b264
 8028a30:	1ffe8b64 	.word	0x1ffe8b64
 8028a34:	1fff2018 	.word	0x1fff2018

08028a38 <pga112_set_gain>:
}

//============================================================================

Pga_Status_t pga112_set_gain(uint16_t gain_level)
{
 8028a38:	b510      	push	{r4, lr}
 8028a3a:	b082      	sub	sp, #8
  Pga112_Binary_Gain_t  gain_val;
  uint16_t shuffled_data = 0;
 8028a3c:	2400      	movs	r4, #0

  if(gain_level > PGA112_MAX_NUMBER_SUPPORTED_GAIN)
 8028a3e:	2807      	cmp	r0, #7
//============================================================================

Pga_Status_t pga112_set_gain(uint16_t gain_level)
{
  Pga112_Binary_Gain_t  gain_val;
  uint16_t shuffled_data = 0;
 8028a40:	f8ad 4006 	strh.w	r4, [sp, #6]

  if(gain_level > PGA112_MAX_NUMBER_SUPPORTED_GAIN)
 8028a44:	d81a      	bhi.n	8028a7c <pga112_set_gain+0x44>
 8028a46:	4b0f      	ldr	r3, [pc, #60]	; (8028a84 <pga112_set_gain+0x4c>)

  /* Get PGA112 gain value from the selected index */
  pga112_global_gain = gain_level;
  gain_val = pga112_get_binary_gain(gain_level);

  pga112_global_config = (PGA112_CMD_WRITE | gain_val | PGA112_CH1);
 8028a48:	4a0f      	ldr	r2, [pc, #60]	; (8028a88 <pga112_set_gain+0x50>)
 8028a4a:	5c1b      	ldrb	r3, [r3, r0]
  {
    return (PGA_STATUS_FAIL);
  }

  /* Get PGA112 gain value from the selected index */
  pga112_global_gain = gain_level;
 8028a4c:	490f      	ldr	r1, [pc, #60]	; (8028a8c <pga112_set_gain+0x54>)
  gain_val = pga112_get_binary_gain(gain_level);

  pga112_global_config = (PGA112_CMD_WRITE | gain_val | PGA112_CH1);
 8028a4e:	f443 5328 	orr.w	r3, r3, #10752	; 0x2a00
 8028a52:	f043 0301 	orr.w	r3, r3, #1
  {
    return (PGA_STATUS_FAIL);
  }

  /* Get PGA112 gain value from the selected index */
  pga112_global_gain = gain_level;
 8028a56:	8008      	strh	r0, [r1, #0]
  gain_val = pga112_get_binary_gain(gain_level);

  pga112_global_config = (PGA112_CMD_WRITE | gain_val | PGA112_CH1);
 8028a58:	8013      	strh	r3, [r2, #0]

  /* Lower byte goes to upper byte position */
  shuffled_data  = ((pga112_global_config & 0x00FF) << 8);
 8028a5a:	8811      	ldrh	r1, [r2, #0]

  /* Upper byte goes to lower byte position */
  shuffled_data |= ((pga112_global_config & 0xFF00) >> 8);
 8028a5c:	8813      	ldrh	r3, [r2, #0]

  /* Send command to PGA112 */
  spi_transmit_data((uint8_t *)&shuffled_data, 2, (void*) &pga112_spi_pins);
 8028a5e:	4a0c      	ldr	r2, [pc, #48]	; (8028a90 <pga112_set_gain+0x58>)

  /* Lower byte goes to upper byte position */
  shuffled_data  = ((pga112_global_config & 0x00FF) << 8);

  /* Upper byte goes to lower byte position */
  shuffled_data |= ((pga112_global_config & 0xFF00) >> 8);
 8028a60:	a802      	add	r0, sp, #8
  gain_val = pga112_get_binary_gain(gain_level);

  pga112_global_config = (PGA112_CMD_WRITE | gain_val | PGA112_CH1);

  /* Lower byte goes to upper byte position */
  shuffled_data  = ((pga112_global_config & 0x00FF) << 8);
 8028a62:	b289      	uxth	r1, r1

  /* Upper byte goes to lower byte position */
  shuffled_data |= ((pga112_global_config & 0xFF00) >> 8);
 8028a64:	f3c3 2307 	ubfx	r3, r3, #8, #8
 8028a68:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8028a6c:	f820 3d02 	strh.w	r3, [r0, #-2]!

  /* Send command to PGA112 */
  spi_transmit_data((uint8_t *)&shuffled_data, 2, (void*) &pga112_spi_pins);
 8028a70:	2102      	movs	r1, #2
 8028a72:	f7ff ff37 	bl	80288e4 <spi_transmit_data>

  return (PGA_STATUS_SUCCESS);
 8028a76:	4620      	mov	r0, r4
}
 8028a78:	b002      	add	sp, #8
 8028a7a:	bd10      	pop	{r4, pc}
  Pga112_Binary_Gain_t  gain_val;
  uint16_t shuffled_data = 0;

  if(gain_level > PGA112_MAX_NUMBER_SUPPORTED_GAIN)
  {
    return (PGA_STATUS_FAIL);
 8028a7c:	2001      	movs	r0, #1

  /* Send command to PGA112 */
  spi_transmit_data((uint8_t *)&shuffled_data, 2, (void*) &pga112_spi_pins);

  return (PGA_STATUS_SUCCESS);
}
 8028a7e:	b002      	add	sp, #8
 8028a80:	bd10      	pop	{r4, pc}
 8028a82:	bf00      	nop
 8028a84:	0802b264 	.word	0x0802b264
 8028a88:	1ffe8b64 	.word	0x1ffe8b64
 8028a8c:	1fff2018 	.word	0x1fff2018
 8028a90:	1fff2008 	.word	0x1fff2008

08028a94 <lmx249x_init>:
==============================================================================
 */

void lmx249x_init(Lmx249x_Object_t* pThis, const Lmx249x_Hardware_Setup_t* pSetup,
                  sendSPIFunction sendSPI, void* pDataForSendSPI)
{
 8028a94:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8028a98:	4605      	mov	r5, r0
 8028a9a:	b087      	sub	sp, #28
  uint8_t uSPIData[17];
  
  /* Set Internal Parameters */
  pThis->dExternalDivideFactor = (1.0 / pSetup->uExternalDivider); /* inverse RF-divider within the BGT chip */
 8028a9c:	68c8      	ldr	r0, [r1, #12]
==============================================================================
 */

void lmx249x_init(Lmx249x_Object_t* pThis, const Lmx249x_Hardware_Setup_t* pSetup,
                  sendSPIFunction sendSPI, void* pDataForSendSPI)
{
 8028a9e:	460c      	mov	r4, r1
 8028aa0:	4616      	mov	r6, r2
 8028aa2:	461f      	mov	r7, r3
  uint8_t uSPIData[17];
  
  /* Set Internal Parameters */
  pThis->dExternalDivideFactor = (1.0 / pSetup->uExternalDivider); /* inverse RF-divider within the BGT chip */
 8028aa4:	f001 f950 	bl	8029d48 <__aeabi_ui2d>
 8028aa8:	4602      	mov	r2, r0
 8028aaa:	460b      	mov	r3, r1
 8028aac:	2000      	movs	r0, #0
 8028aae:	495f      	ldr	r1, [pc, #380]	; (8028c2c <lmx249x_init+0x198>)
 8028ab0:	f001 faea 	bl	802a088 <__aeabi_ddiv>
  pThis->dPFDCycleTime = 1.0f / (pSetup->dReferenceFreq * (pSetup->eReferenceDoubler ? 2.0 : 1.0) / pSetup->uReferenceDivider );
 8028ab4:	7aa3      	ldrb	r3, [r4, #10]
 8028ab6:	2200      	movs	r2, #0
                  sendSPIFunction sendSPI, void* pDataForSendSPI)
{
  uint8_t uSPIData[17];
  
  /* Set Internal Parameters */
  pThis->dExternalDivideFactor = (1.0 / pSetup->uExternalDivider); /* inverse RF-divider within the BGT chip */
 8028ab8:	e9c5 0100 	strd	r0, r1, [r5]
  pThis->dPFDCycleTime = 1.0f / (pSetup->dReferenceFreq * (pSetup->eReferenceDoubler ? 2.0 : 1.0) / pSetup->uReferenceDivider );
 8028abc:	e9d4 0100 	ldrd	r0, r1, [r4]
 8028ac0:	2b00      	cmp	r3, #0
 8028ac2:	f040 80b0 	bne.w	8028c26 <lmx249x_init+0x192>
 8028ac6:	4b59      	ldr	r3, [pc, #356]	; (8028c2c <lmx249x_init+0x198>)
 8028ac8:	f001 f9b4 	bl	8029e34 <__aeabi_dmul>
 8028acc:	4680      	mov	r8, r0
 8028ace:	8920      	ldrh	r0, [r4, #8]
 8028ad0:	4689      	mov	r9, r1
 8028ad2:	f001 f949 	bl	8029d68 <__aeabi_i2d>
 8028ad6:	4602      	mov	r2, r0
 8028ad8:	460b      	mov	r3, r1
 8028ada:	4640      	mov	r0, r8
 8028adc:	4649      	mov	r1, r9
 8028ade:	f001 fad3 	bl	802a088 <__aeabi_ddiv>
 8028ae2:	4602      	mov	r2, r0
 8028ae4:	460b      	mov	r3, r1
 8028ae6:	2000      	movs	r0, #0
 8028ae8:	4950      	ldr	r1, [pc, #320]	; (8028c2c <lmx249x_init+0x198>)
 8028aea:	f001 facd 	bl	802a088 <__aeabi_ddiv>
  pThis->uReg58 = 0;
 8028aee:	f04f 0800 	mov.w	r8, #0
  pThis->sendSPI = sendSPI;
  pThis->pDataForSendSPI = pDataForSendSPI;
 8028af2:	61af      	str	r7, [r5, #24]
  
  /* Do a Power on Reset and set all PLL registers to the default value */
  uSPIData[0] = 0;
  uSPIData[1] = 2;
  uSPIData[2] = (1 << 2);
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
 8028af4:	463a      	mov	r2, r7
  pThis->pDataForSendSPI = pDataForSendSPI;
  
  /* Do a Power on Reset and set all PLL registers to the default value */
  uSPIData[0] = 0;
  uSPIData[1] = 2;
  uSPIData[2] = (1 << 2);
 8028af6:	2304      	movs	r3, #4
  pThis->sendSPI = sendSPI;
  pThis->pDataForSendSPI = pDataForSendSPI;
  
  /* Do a Power on Reset and set all PLL registers to the default value */
  uSPIData[0] = 0;
  uSPIData[1] = 2;
 8028af8:	2702      	movs	r7, #2
{
  uint8_t uSPIData[17];
  
  /* Set Internal Parameters */
  pThis->dExternalDivideFactor = (1.0 / pSetup->uExternalDivider); /* inverse RF-divider within the BGT chip */
  pThis->dPFDCycleTime = 1.0f / (pSetup->dReferenceFreq * (pSetup->eReferenceDoubler ? 2.0 : 1.0) / pSetup->uReferenceDivider );
 8028afa:	e9c5 0102 	strd	r0, r1, [r5, #8]
  pThis->uReg58 = 0;
  pThis->sendSPI = sendSPI;
 8028afe:	616e      	str	r6, [r5, #20]
  
  /* Do a Power on Reset and set all PLL registers to the default value */
  uSPIData[0] = 0;
  uSPIData[1] = 2;
  uSPIData[2] = (1 << 2);
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
 8028b00:	a801      	add	r0, sp, #4
  pThis->sendSPI = sendSPI;
  pThis->pDataForSendSPI = pDataForSendSPI;
  
  /* Do a Power on Reset and set all PLL registers to the default value */
  uSPIData[0] = 0;
  uSPIData[1] = 2;
 8028b02:	f88d 7005 	strb.w	r7, [sp, #5]
  uSPIData[2] = (1 << 2);
 8028b06:	f88d 3006 	strb.w	r3, [sp, #6]
  uint8_t uSPIData[17];
  
  /* Set Internal Parameters */
  pThis->dExternalDivideFactor = (1.0 / pSetup->uExternalDivider); /* inverse RF-divider within the BGT chip */
  pThis->dPFDCycleTime = 1.0f / (pSetup->dReferenceFreq * (pSetup->eReferenceDoubler ? 2.0 : 1.0) / pSetup->uReferenceDivider );
  pThis->uReg58 = 0;
 8028b0a:	f885 8010 	strb.w	r8, [r5, #16]
  
  /* Do a Power on Reset and set all PLL registers to the default value */
  uSPIData[0] = 0;
  uSPIData[1] = 2;
  uSPIData[2] = (1 << 2);
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
 8028b0e:	2103      	movs	r1, #3
  pThis->uReg58 = 0;
  pThis->sendSPI = sendSPI;
  pThis->pDataForSendSPI = pDataForSendSPI;
  
  /* Do a Power on Reset and set all PLL registers to the default value */
  uSPIData[0] = 0;
 8028b10:	f88d 8004 	strb.w	r8, [sp, #4]
  uSPIData[1] = 2;
  uSPIData[2] = (1 << 2);
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
 8028b14:	47b0      	blx	r6
  
  /* Setup Routing and Drive for Pins TRIG1, TRIG2, MOD and MUXout */
  uSPIData[LMX249x_REG_IDX(25, 15, 35)] = 0x41 | /* these bits must be set */
    ((pSetup->eTrig1PinFunction   >> 2) & 0x08) | /* TRIG1_MUX[5] shifted to bit 3 */
 8028b16:	f894 9010 	ldrb.w	r9, [r4, #16]
      ((pSetup->eTrig2PinFunction   >> 1) & 0x10) | /* TRIG2_MUX[5] shifted to bit 4 */
        ((pSetup->eMUXoutPinFunction  >> 0) & 0x20) | /* MUXout_MUX[5] stays at bit 5 */
 8028b1a:	7da7      	ldrb	r7, [r4, #22]
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
  
  /* Setup Routing and Drive for Pins TRIG1, TRIG2, MOD and MUXout */
  uSPIData[LMX249x_REG_IDX(25, 15, 35)] = 0x41 | /* these bits must be set */
    ((pSetup->eTrig1PinFunction   >> 2) & 0x08) | /* TRIG1_MUX[5] shifted to bit 3 */
      ((pSetup->eTrig2PinFunction   >> 1) & 0x10) | /* TRIG2_MUX[5] shifted to bit 4 */
 8028b1c:	f894 c012 	ldrb.w	ip, [r4, #18]
  uSPIData[LMX249x_REG_IDX(25, 15, 26)] = (pSetup->uReferenceDivider >> 8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] =  pSetup->eReferenceDoubler |
    (pSetup->eOscInMode << 2);
  
  /* Setup Charge Pump configuration */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eChargePumpPulseWidth << 3);
 8028b20:	7f61      	ldrb	r1, [r4, #29]
  
  /* Setup Reference Scaling */
  uSPIData[LMX249x_REG_IDX(25, 15, 25)] = (pSetup->uReferenceDivider >> 0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(25, 15, 26)] = (pSetup->uReferenceDivider >> 8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] =  pSetup->eReferenceDoubler |
    (pSetup->eOscInMode << 2);
 8028b22:	7ae6      	ldrb	r6, [r4, #11]
  /* Setup Routing and Drive for Pins TRIG1, TRIG2, MOD and MUXout */
  uSPIData[LMX249x_REG_IDX(25, 15, 35)] = 0x41 | /* these bits must be set */
    ((pSetup->eTrig1PinFunction   >> 2) & 0x08) | /* TRIG1_MUX[5] shifted to bit 3 */
      ((pSetup->eTrig2PinFunction   >> 1) & 0x10) | /* TRIG2_MUX[5] shifted to bit 4 */
        ((pSetup->eMUXoutPinFunction  >> 0) & 0x20) | /* MUXout_MUX[5] stays at bit 5 */
          ((pSetup->eModPinFunction     << 2) & 0x80);  /* MOD_MUX[5] shifted to at bit 7 */
 8028b24:	f894 e014 	ldrb.w	lr, [r4, #20]
  uSPIData[LMX249x_REG_IDX(25, 15, 26)] = (pSetup->uReferenceDivider >> 8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] =  pSetup->eReferenceDoubler |
    (pSetup->eOscInMode << 2);
  
  /* Setup Charge Pump configuration */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eChargePumpPulseWidth << 3);
 8028b28:	f894 b00a 	ldrb.w	fp, [r4, #10]
    (pSetup->uChargePumpCurrent & 0x1F);
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] =  (pSetup->uChargePumpCurrentFS & 0x1F);
  
  /* Setup speed up settings */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eCycleSlipReduction << 5);
  uSPIData[LMX249x_REG_IDX(25, 15, 32)]  = (pSetup->uFastLockTimer & 0xFF);
 8028b2c:	8c23      	ldrh	r3, [r4, #32]
 8028b2e:	f88d 300d 	strb.w	r3, [sp, #13]
  uSPIData[1] = 2;
  uSPIData[2] = (1 << 2);
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
  
  /* Setup Routing and Drive for Pins TRIG1, TRIG2, MOD and MUXout */
  uSPIData[LMX249x_REG_IDX(25, 15, 35)] = 0x41 | /* these bits must be set */
 8028b32:	ea4f 0099 	mov.w	r0, r9, lsr #2
 8028b36:	f007 0220 	and.w	r2, r7, #32
 8028b3a:	f000 0008 	and.w	r0, r0, #8
 8028b3e:	ea4f 0a5c 	mov.w	sl, ip, lsr #1
 8028b42:	f042 0241 	orr.w	r2, r2, #65	; 0x41
 8028b46:	4302      	orrs	r2, r0
 8028b48:	f00a 0a10 	and.w	sl, sl, #16
  uSPIData[LMX249x_REG_IDX(25, 15, 26)] = (pSetup->uReferenceDivider >> 8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] =  pSetup->eReferenceDoubler |
    (pSetup->eOscInMode << 2);
  
  /* Setup Charge Pump configuration */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eChargePumpPulseWidth << 3);
 8028b4c:	00c9      	lsls	r1, r1, #3
 8028b4e:	ea41 0186 	orr.w	r1, r1, r6, lsl #2
  uSPIData[1] = 2;
  uSPIData[2] = (1 << 2);
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
  
  /* Setup Routing and Drive for Pins TRIG1, TRIG2, MOD and MUXout */
  uSPIData[LMX249x_REG_IDX(25, 15, 35)] = 0x41 | /* these bits must be set */
 8028b52:	ea42 020a 	orr.w	r2, r2, sl
    ((pSetup->eTrig1PinFunction   >> 2) & 0x08) | /* TRIG1_MUX[5] shifted to bit 3 */
      ((pSetup->eTrig2PinFunction   >> 1) & 0x10) | /* TRIG2_MUX[5] shifted to bit 4 */
        ((pSetup->eMUXoutPinFunction  >> 0) & 0x20) | /* MUXout_MUX[5] stays at bit 5 */
          ((pSetup->eModPinFunction     << 2) & 0x80);  /* MOD_MUX[5] shifted to at bit 7 */
 8028b56:	ea4f 0a8e 	mov.w	sl, lr, lsl #2
  uSPIData[LMX249x_REG_IDX(25, 15, 26)] = (pSetup->uReferenceDivider >> 8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] =  pSetup->eReferenceDoubler |
    (pSetup->eOscInMode << 2);
  
  /* Setup Charge Pump configuration */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eChargePumpPulseWidth << 3);
 8028b5a:	ea41 010b 	orr.w	r1, r1, fp
  uSPIData[1] = 2;
  uSPIData[2] = (1 << 2);
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
  
  /* Setup Routing and Drive for Pins TRIG1, TRIG2, MOD and MUXout */
  uSPIData[LMX249x_REG_IDX(25, 15, 35)] = 0x41 | /* these bits must be set */
 8028b5e:	f02a 0a7f 	bic.w	sl, sl, #127	; 0x7f
    ((pSetup->eTrig1PinFunction   >> 2) & 0x08) | /* TRIG1_MUX[5] shifted to bit 3 */
      ((pSetup->eTrig2PinFunction   >> 1) & 0x10) | /* TRIG2_MUX[5] shifted to bit 4 */
        ((pSetup->eMUXoutPinFunction  >> 0) & 0x20) | /* MUXout_MUX[5] stays at bit 5 */
          ((pSetup->eModPinFunction     << 2) & 0x80);  /* MOD_MUX[5] shifted to at bit 7 */
  
  uSPIData[LMX249x_REG_IDX(25, 15, 36)] = ((pSetup->eTrig1PinFunction & 0x1F) << 3) |
 8028b62:	f894 b011 	ldrb.w	fp, [r4, #17]
  
  /* Setup Charge Pump configuration */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eChargePumpPulseWidth << 3);
  uSPIData[LMX249x_REG_IDX(25, 15, 28)] = ((pSetup->eChargePumpPolarity) << 5) |
    (pSetup->uChargePumpCurrent & 0x1F);
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] =  (pSetup->uChargePumpCurrentFS & 0x1F);
 8028b66:	7ea6      	ldrb	r6, [r4, #26]
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] =  pSetup->eReferenceDoubler |
    (pSetup->eOscInMode << 2);
  
  /* Setup Charge Pump configuration */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eChargePumpPulseWidth << 3);
  uSPIData[LMX249x_REG_IDX(25, 15, 28)] = ((pSetup->eChargePumpPolarity) << 5) |
 8028b68:	7e60      	ldrb	r0, [r4, #25]
  uSPIData[1] = 2;
  uSPIData[2] = (1 << 2);
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
  
  /* Setup Routing and Drive for Pins TRIG1, TRIG2, MOD and MUXout */
  uSPIData[LMX249x_REG_IDX(25, 15, 35)] = 0x41 | /* these bits must be set */
 8028b6a:	ea42 020a 	orr.w	r2, r2, sl
          ((pSetup->eModPinFunction     << 2) & 0x80);  /* MOD_MUX[5] shifted to at bit 7 */
  
  uSPIData[LMX249x_REG_IDX(25, 15, 36)] = ((pSetup->eTrig1PinFunction & 0x1F) << 3) |
    pSetup->eTrig1PinDriveMode;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 37)] = ((pSetup->eTrig2PinFunction & 0x1F) << 3) |
 8028b6e:	f894 a013 	ldrb.w	sl, [r4, #19]
  uSPIData[1] = 2;
  uSPIData[2] = (1 << 2);
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
  
  /* Setup Routing and Drive for Pins TRIG1, TRIG2, MOD and MUXout */
  uSPIData[LMX249x_REG_IDX(25, 15, 35)] = 0x41 | /* these bits must be set */
 8028b72:	f88d 200a 	strb.w	r2, [sp, #10]
    ((pSetup->eTrig1PinFunction   >> 2) & 0x08) | /* TRIG1_MUX[5] shifted to bit 3 */
      ((pSetup->eTrig2PinFunction   >> 1) & 0x10) | /* TRIG2_MUX[5] shifted to bit 4 */
        ((pSetup->eMUXoutPinFunction  >> 0) & 0x20) | /* MUXout_MUX[5] stays at bit 5 */
          ((pSetup->eModPinFunction     << 2) & 0x80);  /* MOD_MUX[5] shifted to at bit 7 */
  
  uSPIData[LMX249x_REG_IDX(25, 15, 36)] = ((pSetup->eTrig1PinFunction & 0x1F) << 3) |
 8028b76:	ea4b 09c9 	orr.w	r9, fp, r9, lsl #3
    pSetup->eTrig2PinDriveMode;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 38)] = ((pSetup->eModPinFunction & 0x1F) << 3) |
    pSetup->eModPinDriveMode;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 39)] = ((pSetup->eMUXoutPinFunction & 0x1F) << 3) |
 8028b7a:	7de2      	ldrb	r2, [r4, #23]
    pSetup->eTrig1PinDriveMode;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 37)] = ((pSetup->eTrig2PinFunction & 0x1F) << 3) |
    pSetup->eTrig2PinDriveMode;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 38)] = ((pSetup->eModPinFunction & 0x1F) << 3) |
 8028b7c:	f894 b015 	ldrb.w	fp, [r4, #21]
    ((pSetup->eTrig1PinFunction   >> 2) & 0x08) | /* TRIG1_MUX[5] shifted to bit 3 */
      ((pSetup->eTrig2PinFunction   >> 1) & 0x10) | /* TRIG2_MUX[5] shifted to bit 4 */
        ((pSetup->eMUXoutPinFunction  >> 0) & 0x20) | /* MUXout_MUX[5] stays at bit 5 */
          ((pSetup->eModPinFunction     << 2) & 0x80);  /* MOD_MUX[5] shifted to at bit 7 */
  
  uSPIData[LMX249x_REG_IDX(25, 15, 36)] = ((pSetup->eTrig1PinFunction & 0x1F) << 3) |
 8028b80:	f88d 9009 	strb.w	r9, [sp, #9]
    pSetup->eTrig1PinDriveMode;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 37)] = ((pSetup->eTrig2PinFunction & 0x1F) << 3) |
 8028b84:	ea4a 0ccc 	orr.w	ip, sl, ip, lsl #3
  uSPIData[LMX249x_REG_IDX(25, 15, 28)] = ((pSetup->eChargePumpPolarity) << 5) |
    (pSetup->uChargePumpCurrent & 0x1F);
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] =  (pSetup->uChargePumpCurrentFS & 0x1F);
  
  /* Setup speed up settings */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eCycleSlipReduction << 5);
 8028b88:	f894 901e 	ldrb.w	r9, [r4, #30]
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] =  pSetup->eReferenceDoubler |
    (pSetup->eOscInMode << 2);
  
  /* Setup Charge Pump configuration */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eChargePumpPulseWidth << 3);
  uSPIData[LMX249x_REG_IDX(25, 15, 28)] = ((pSetup->eChargePumpPolarity) << 5) |
 8028b8c:	f894 a018 	ldrb.w	sl, [r4, #24]
          ((pSetup->eModPinFunction     << 2) & 0x80);  /* MOD_MUX[5] shifted to at bit 7 */
  
  uSPIData[LMX249x_REG_IDX(25, 15, 36)] = ((pSetup->eTrig1PinFunction & 0x1F) << 3) |
    pSetup->eTrig1PinDriveMode;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 37)] = ((pSetup->eTrig2PinFunction & 0x1F) << 3) |
 8028b90:	f88d c008 	strb.w	ip, [sp, #8]
    pSetup->eTrig2PinDriveMode;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 38)] = ((pSetup->eModPinFunction & 0x1F) << 3) |
 8028b94:	ea4b 0ece 	orr.w	lr, fp, lr, lsl #3
  
  uSPIData[LMX249x_REG_IDX(25, 15, 39)] = ((pSetup->eMUXoutPinFunction & 0x1F) << 3) |
    pSetup->eMUXoutPinDriveMode;
  
  /* Setup Reference Scaling */
  uSPIData[LMX249x_REG_IDX(25, 15, 25)] = (pSetup->uReferenceDivider >> 0) & 0xFF;
 8028b98:	f8b4 c008 	ldrh.w	ip, [r4, #8]
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eCycleSlipReduction << 5);
  uSPIData[LMX249x_REG_IDX(25, 15, 32)]  = (pSetup->uFastLockTimer & 0xFF);
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] |= (pSetup->uFastLockTimer >> 3) & 0xE0;
  
  /* Setup lock detection */
  uSPIData[LMX249x_REG_IDX(25, 15, 30)] =  pSetup->uChargePumpThresholdLo & 0x3F;
 8028b9c:	f894 b01b 	ldrb.w	fp, [r4, #27]
    pSetup->eTrig1PinDriveMode;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 37)] = ((pSetup->eTrig2PinFunction & 0x1F) << 3) |
    pSetup->eTrig2PinDriveMode;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 38)] = ((pSetup->eModPinFunction & 0x1F) << 3) |
 8028ba0:	f88d e007 	strb.w	lr, [sp, #7]
    pSetup->eModPinDriveMode;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 39)] = ((pSetup->eMUXoutPinFunction & 0x1F) << 3) |
 8028ba4:	ea42 07c7 	orr.w	r7, r2, r7, lsl #3
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] =  (pSetup->uChargePumpCurrentFS & 0x1F);
  
  /* Setup speed up settings */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eCycleSlipReduction << 5);
  uSPIData[LMX249x_REG_IDX(25, 15, 32)]  = (pSetup->uFastLockTimer & 0xFF);
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] |= (pSetup->uFastLockTimer >> 3) & 0xE0;
 8028ba8:	08db      	lsrs	r3, r3, #3
  
  /* Setup lock detection */
  uSPIData[LMX249x_REG_IDX(25, 15, 30)] =  pSetup->uChargePumpThresholdLo & 0x3F;
  uSPIData[LMX249x_REG_IDX(25, 15, 31)] =  pSetup->uChargePumpThresholdHi & 0x3F;
 8028baa:	7f22      	ldrb	r2, [r4, #28]
    pSetup->eTrig2PinDriveMode;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 38)] = ((pSetup->eModPinFunction & 0x1F) << 3) |
    pSetup->eModPinDriveMode;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 39)] = ((pSetup->eMUXoutPinFunction & 0x1F) << 3) |
 8028bac:	f88d 7006 	strb.w	r7, [sp, #6]
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] =  (pSetup->uChargePumpCurrentFS & 0x1F);
  
  /* Setup speed up settings */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eCycleSlipReduction << 5);
  uSPIData[LMX249x_REG_IDX(25, 15, 32)]  = (pSetup->uFastLockTimer & 0xFF);
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] |= (pSetup->uFastLockTimer >> 3) & 0xE0;
 8028bb0:	f023 031f 	bic.w	r3, r3, #31
  uSPIData[LMX249x_REG_IDX(25, 15, 26)] = (pSetup->uReferenceDivider >> 8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] =  pSetup->eReferenceDoubler |
    (pSetup->eOscInMode << 2);
  
  /* Setup Charge Pump configuration */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eChargePumpPulseWidth << 3);
 8028bb4:	b2c9      	uxtb	r1, r1
  uSPIData[LMX249x_REG_IDX(25, 15, 28)] = ((pSetup->eChargePumpPolarity) << 5) |
    (pSetup->uChargePumpCurrent & 0x1F);
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] =  (pSetup->uChargePumpCurrentFS & 0x1F);
 8028bb6:	f006 061f 	and.w	r6, r6, #31
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] =  pSetup->eReferenceDoubler |
    (pSetup->eOscInMode << 2);
  
  /* Setup Charge Pump configuration */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eChargePumpPulseWidth << 3);
  uSPIData[LMX249x_REG_IDX(25, 15, 28)] = ((pSetup->eChargePumpPolarity) << 5) |
 8028bba:	f000 001f 	and.w	r0, r0, #31
    (pSetup->uChargePumpCurrent & 0x1F);
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] =  (pSetup->uChargePumpCurrentFS & 0x1F);
  
  /* Setup speed up settings */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eCycleSlipReduction << 5);
 8028bbe:	ea41 1149 	orr.w	r1, r1, r9, lsl #5
  uSPIData[LMX249x_REG_IDX(25, 15, 32)]  = (pSetup->uFastLockTimer & 0xFF);
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] |= (pSetup->uFastLockTimer >> 3) & 0xE0;
 8028bc2:	431e      	orrs	r6, r3
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] =  pSetup->eReferenceDoubler |
    (pSetup->eOscInMode << 2);
  
  /* Setup Charge Pump configuration */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eChargePumpPulseWidth << 3);
  uSPIData[LMX249x_REG_IDX(25, 15, 28)] = ((pSetup->eChargePumpPolarity) << 5) |
 8028bc4:	ea40 104a 	orr.w	r0, r0, sl, lsl #5
  uSPIData[LMX249x_REG_IDX(25, 15, 39)] = ((pSetup->eMUXoutPinFunction & 0x1F) << 3) |
    pSetup->eMUXoutPinDriveMode;
  
  /* Setup Reference Scaling */
  uSPIData[LMX249x_REG_IDX(25, 15, 25)] = (pSetup->uReferenceDivider >> 0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(25, 15, 26)] = (pSetup->uReferenceDivider >> 8) & 0xFF;
 8028bc8:	ea4f 231c 	mov.w	r3, ip, lsr #8
  
  /* Setup lock detection */
  uSPIData[LMX249x_REG_IDX(25, 15, 30)] =  pSetup->uChargePumpThresholdLo & 0x3F;
  uSPIData[LMX249x_REG_IDX(25, 15, 31)] =  pSetup->uChargePumpThresholdHi & 0x3F;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 33)] =  pSetup->uLockDetectNumGoodEdge;
 8028bcc:	f894 e022 	ldrb.w	lr, [r4, #34]	; 0x22
  uSPIData[LMX249x_REG_IDX(25, 15, 28)] = ((pSetup->eChargePumpPolarity) << 5) |
    (pSetup->uChargePumpCurrent & 0x1F);
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] =  (pSetup->uChargePumpCurrentFS & 0x1F);
  
  /* Setup speed up settings */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eCycleSlipReduction << 5);
 8028bd0:	f88d 1012 	strb.w	r1, [sp, #18]
  uSPIData[LMX249x_REG_IDX(25, 15, 32)]  = (pSetup->uFastLockTimer & 0xFF);
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] |= (pSetup->uFastLockTimer >> 3) & 0xE0;
  
  /* Setup lock detection */
  uSPIData[LMX249x_REG_IDX(25, 15, 30)] =  pSetup->uChargePumpThresholdLo & 0x3F;
 8028bd4:	f00b 073f 	and.w	r7, fp, #63	; 0x3f
  uSPIData[LMX249x_REG_IDX(25, 15, 31)] =  pSetup->uChargePumpThresholdHi & 0x3F;
 8028bd8:	f002 023f 	and.w	r2, r2, #63	; 0x3f
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] =  pSetup->eReferenceDoubler |
    (pSetup->eOscInMode << 2);
  
  /* Setup Charge Pump configuration */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eChargePumpPulseWidth << 3);
  uSPIData[LMX249x_REG_IDX(25, 15, 28)] = ((pSetup->eChargePumpPolarity) << 5) |
 8028bdc:	f88d 0011 	strb.w	r0, [sp, #17]
  
  uSPIData[LMX249x_REG_IDX(25, 15, 39)] = ((pSetup->eMUXoutPinFunction & 0x1F) << 3) |
    pSetup->eMUXoutPinDriveMode;
  
  /* Setup Reference Scaling */
  uSPIData[LMX249x_REG_IDX(25, 15, 25)] = (pSetup->uReferenceDivider >> 0) & 0xFF;
 8028be0:	f88d c014 	strb.w	ip, [sp, #20]
  uSPIData[LMX249x_REG_IDX(25, 15, 26)] = (pSetup->uReferenceDivider >> 8) & 0xFF;
 8028be4:	f88d 3013 	strb.w	r3, [sp, #19]
  uSPIData[LMX249x_REG_IDX(25, 15, 32)]  = (pSetup->uFastLockTimer & 0xFF);
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] |= (pSetup->uFastLockTimer >> 3) & 0xE0;
  
  /* Setup lock detection */
  uSPIData[LMX249x_REG_IDX(25, 15, 30)] =  pSetup->uChargePumpThresholdLo & 0x3F;
  uSPIData[LMX249x_REG_IDX(25, 15, 31)] =  pSetup->uChargePumpThresholdHi & 0x3F;
 8028be8:	f88d 200e 	strb.w	r2, [sp, #14]
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] =  (pSetup->uChargePumpCurrentFS & 0x1F);
  
  /* Setup speed up settings */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eCycleSlipReduction << 5);
  uSPIData[LMX249x_REG_IDX(25, 15, 32)]  = (pSetup->uFastLockTimer & 0xFF);
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] |= (pSetup->uFastLockTimer >> 3) & 0xE0;
 8028bec:	f88d 6010 	strb.w	r6, [sp, #16]
  
  /* Setup lock detection */
  uSPIData[LMX249x_REG_IDX(25, 15, 30)] =  pSetup->uChargePumpThresholdLo & 0x3F;
 8028bf0:	f88d 700f 	strb.w	r7, [sp, #15]
  uSPIData[LMX249x_REG_IDX(25, 15, 31)] =  pSetup->uChargePumpThresholdHi & 0x3F;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 33)] =  pSetup->uLockDetectNumGoodEdge;
 8028bf4:	f88d e00c 	strb.w	lr, [sp, #12]
  uSPIData[LMX249x_REG_IDX(25, 15, 34)] = (pSetup->uLockDetectNumBadEdge & 0x1F) |
 8028bf8:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
    (pSetup->eLockDetectWindow << 5);
 8028bfc:	f894 2024 	ldrb.w	r2, [r4, #36]	; 0x24
  
  uSPIData[0] = 0;
 8028c00:	f88d 8004 	strb.w	r8, [sp, #4]
  /* Setup lock detection */
  uSPIData[LMX249x_REG_IDX(25, 15, 30)] =  pSetup->uChargePumpThresholdLo & 0x3F;
  uSPIData[LMX249x_REG_IDX(25, 15, 31)] =  pSetup->uChargePumpThresholdHi & 0x3F;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 33)] =  pSetup->uLockDetectNumGoodEdge;
  uSPIData[LMX249x_REG_IDX(25, 15, 34)] = (pSetup->uLockDetectNumBadEdge & 0x1F) |
 8028c04:	f003 031f 	and.w	r3, r3, #31
 8028c08:	ea43 1342 	orr.w	r3, r3, r2, lsl #5
    (pSetup->eLockDetectWindow << 5);
  
  uSPIData[0] = 0;
  uSPIData[1] = 25 + 15 - 1;
 8028c0c:	2227      	movs	r2, #39	; 0x27
  /* Setup lock detection */
  uSPIData[LMX249x_REG_IDX(25, 15, 30)] =  pSetup->uChargePumpThresholdLo & 0x3F;
  uSPIData[LMX249x_REG_IDX(25, 15, 31)] =  pSetup->uChargePumpThresholdHi & 0x3F;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 33)] =  pSetup->uLockDetectNumGoodEdge;
  uSPIData[LMX249x_REG_IDX(25, 15, 34)] = (pSetup->uLockDetectNumBadEdge & 0x1F) |
 8028c0e:	f88d 300b 	strb.w	r3, [sp, #11]
    (pSetup->eLockDetectWindow << 5);
  
  uSPIData[0] = 0;
  uSPIData[1] = 25 + 15 - 1;
 8028c12:	f88d 2005 	strb.w	r2, [sp, #5]
  pThis->sendSPI(uSPIData, 15 + 2, pThis->pDataForSendSPI);
 8028c16:	a801      	add	r0, sp, #4
 8028c18:	696b      	ldr	r3, [r5, #20]
 8028c1a:	69aa      	ldr	r2, [r5, #24]
 8028c1c:	2111      	movs	r1, #17
 8028c1e:	4798      	blx	r3
}
 8028c20:	b007      	add	sp, #28
 8028c22:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
{
  uint8_t uSPIData[17];
  
  /* Set Internal Parameters */
  pThis->dExternalDivideFactor = (1.0 / pSetup->uExternalDivider); /* inverse RF-divider within the BGT chip */
  pThis->dPFDCycleTime = 1.0f / (pSetup->dReferenceFreq * (pSetup->eReferenceDoubler ? 2.0 : 1.0) / pSetup->uReferenceDivider );
 8028c26:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8028c2a:	e74d      	b.n	8028ac8 <lmx249x_init+0x34>
 8028c2c:	3ff00000 	.word	0x3ff00000

08028c30 <lmx249x_set_power_state>:
}

//============================================================================

void lmx249x_set_power_state(Lmx249x_Object_t* pThis, Lmx249x_Power_State_t eState)
{
 8028c30:	b530      	push	{r4, r5, lr}
 8028c32:	b083      	sub	sp, #12
  uint8_t uSPIData[3];
  uSPIData[0] = 0;
 8028c34:	2500      	movs	r5, #0
  uSPIData[1] = 2;
 8028c36:	2402      	movs	r4, #2
  uSPIData[2] = eState;
 8028c38:	f88d 1006 	strb.w	r1, [sp, #6]
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
 8028c3c:	6943      	ldr	r3, [r0, #20]
 8028c3e:	6982      	ldr	r2, [r0, #24]
//============================================================================

void lmx249x_set_power_state(Lmx249x_Object_t* pThis, Lmx249x_Power_State_t eState)
{
  uint8_t uSPIData[3];
  uSPIData[0] = 0;
 8028c40:	f88d 5004 	strb.w	r5, [sp, #4]
  uSPIData[1] = 2;
 8028c44:	f88d 4005 	strb.w	r4, [sp, #5]
  uSPIData[2] = eState;
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
 8028c48:	a801      	add	r0, sp, #4
 8028c4a:	2103      	movs	r1, #3
 8028c4c:	4798      	blx	r3
}
 8028c4e:	b003      	add	sp, #12
 8028c50:	bd30      	pop	{r4, r5, pc}
 8028c52:	bf00      	nop

08028c54 <lmx249x_set_frequency>:
//============================================================================

Lmx249x_Error_Code_t lmx249x_set_frequency(Lmx249x_Object_t* pThis, double dBaseFrequency,
                                           Lmx249x_Frac_Order_t eFracOrder,
                                           Lmx249x_Frac_Dither_t eDitherMode)
{
 8028c54:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8028c58:	b084      	sub	sp, #16
  uint32_t iFactorN;
  int32_t iFracDenominator;
  int32_t iFracNumarator;
  
  /* Disable ramp (just in case a ramp is currently in progress) */
  uSPIData[0] = 0;
 8028c5a:	2600      	movs	r6, #0
  uSPIData[1] = 58;
 8028c5c:	213a      	movs	r1, #58	; 0x3a
//============================================================================

Lmx249x_Error_Code_t lmx249x_set_frequency(Lmx249x_Object_t* pThis, double dBaseFrequency,
                                           Lmx249x_Frac_Order_t eFracOrder,
                                           Lmx249x_Frac_Dither_t eDitherMode)
{
 8028c5e:	4604      	mov	r4, r0
 8028c60:	4690      	mov	r8, r2
 8028c62:	4699      	mov	r9, r3
  
  /* Disable ramp (just in case a ramp is currently in progress) */
  uSPIData[0] = 0;
  uSPIData[1] = 58;
  uSPIData[2] = 0;
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
 8028c64:	6982      	ldr	r2, [r0, #24]
 8028c66:	6943      	ldr	r3, [r0, #20]
  int32_t iFracDenominator;
  int32_t iFracNumarator;
  
  /* Disable ramp (just in case a ramp is currently in progress) */
  uSPIData[0] = 0;
  uSPIData[1] = 58;
 8028c68:	f88d 1005 	strb.w	r1, [sp, #5]
  uSPIData[2] = 0;
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
 8028c6c:	a801      	add	r0, sp, #4
  uint32_t iFactorN;
  int32_t iFracDenominator;
  int32_t iFracNumarator;
  
  /* Disable ramp (just in case a ramp is currently in progress) */
  uSPIData[0] = 0;
 8028c6e:	f88d 6004 	strb.w	r6, [sp, #4]
  uSPIData[1] = 58;
  uSPIData[2] = 0;
 8028c72:	f88d 6006 	strb.w	r6, [sp, #6]
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
 8028c76:	2103      	movs	r1, #3
//============================================================================

Lmx249x_Error_Code_t lmx249x_set_frequency(Lmx249x_Object_t* pThis, double dBaseFrequency,
                                           Lmx249x_Frac_Order_t eFracOrder,
                                           Lmx249x_Frac_Dither_t eDitherMode)
{
 8028c78:	f89d 7030 	ldrb.w	r7, [sp, #48]	; 0x30
 8028c7c:	f89d 5034 	ldrb.w	r5, [sp, #52]	; 0x34
  
  /* Disable ramp (just in case a ramp is currently in progress) */
  uSPIData[0] = 0;
  uSPIData[1] = 58;
  uSPIData[2] = 0;
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
 8028c80:	4798      	blx	r3
  
  /* Setup frequency */
  dRelFrequency = dBaseFrequency * pThis->dExternalDivideFactor * pThis->dPFDCycleTime;  /* divider ratio between PLL-RF-in and PFD-frequency */
 8028c82:	e9d4 2300 	ldrd	r2, r3, [r4]
 8028c86:	4640      	mov	r0, r8
 8028c88:	4649      	mov	r1, r9
 8028c8a:	f001 f8d3 	bl	8029e34 <__aeabi_dmul>
 8028c8e:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 8028c92:	f001 f8cf 	bl	8029e34 <__aeabi_dmul>
 8028c96:	4689      	mov	r9, r1
 8028c98:	4680      	mov	r8, r0
  
  iFactorN = (int32_t)dRelFrequency;
 8028c9a:	f001 fb65 	bl	802a368 <__aeabi_d2iz>
 8028c9e:	4682      	mov	sl, r0
  dRelFrequency -= iFactorN;
 8028ca0:	f001 f852 	bl	8029d48 <__aeabi_ui2d>
 8028ca4:	4602      	mov	r2, r0
 8028ca6:	460b      	mov	r3, r1
 8028ca8:	4640      	mov	r0, r8
 8028caa:	4649      	mov	r1, r9
 8028cac:	f000 ff0e 	bl	8029acc <__aeabi_dsub>
  iFracDenominator = 1<<24;
  iFracNumarator = (uint32_t)(dRelFrequency * iFracDenominator + 0.5);
 8028cb0:	2200      	movs	r2, #0
 8028cb2:	4b1a      	ldr	r3, [pc, #104]	; (8028d1c <lmx249x_set_frequency+0xc8>)
 8028cb4:	f001 f8be 	bl	8029e34 <__aeabi_dmul>
 8028cb8:	2200      	movs	r2, #0
 8028cba:	4b19      	ldr	r3, [pc, #100]	; (8028d20 <lmx249x_set_frequency+0xcc>)
 8028cbc:	f000 ff08 	bl	8029ad0 <__adddf3>
 8028cc0:	f001 fb7a 	bl	802a3b8 <__aeabi_d2uiz>
  
  uSPIData[LMX249x_REG_IDX(16, 9, 16)] = (int8_t) ((iFactorN >>  0) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 17)] = (int8_t) ((iFactorN >>  8) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 18)] = (int8_t) ((iFactorN >> 16) & 0x03) |
    (eFracOrder << 4)        |
      (eDitherMode << 2);
 8028cc4:	00ad      	lsls	r5, r5, #2
 8028cc6:	ea45 1707 	orr.w	r7, r5, r7, lsl #4
  iFracDenominator = 1<<24;
  iFracNumarator = (uint32_t)(dRelFrequency * iFracDenominator + 0.5);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 16)] = (int8_t) ((iFactorN >>  0) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 17)] = (int8_t) ((iFactorN >>  8) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 18)] = (int8_t) ((iFactorN >> 16) & 0x03) |
 8028cca:	f3ca 4501 	ubfx	r5, sl, #16, #2
  uSPIData[LMX249x_REG_IDX(16, 9, 19)] = (iFracNumarator >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 20)] = (iFracNumarator >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 21)] = (iFracNumarator >> 16) & 0xFF;
  
  iFracDenominator -= 1;
  uSPIData[LMX249x_REG_IDX(16, 9, 22)] = (iFracDenominator >>  0) & 0xFF;
 8028cce:	23ff      	movs	r3, #255	; 0xff
  iFracDenominator = 1<<24;
  iFracNumarator = (uint32_t)(dRelFrequency * iFracDenominator + 0.5);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 16)] = (int8_t) ((iFactorN >>  0) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 17)] = (int8_t) ((iFactorN >>  8) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 18)] = (int8_t) ((iFactorN >> 16) & 0x03) |
 8028cd0:	432f      	orrs	r7, r5
  dRelFrequency -= iFactorN;
  iFracDenominator = 1<<24;
  iFracNumarator = (uint32_t)(dRelFrequency * iFracDenominator + 0.5);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 16)] = (int8_t) ((iFactorN >>  0) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 17)] = (int8_t) ((iFactorN >>  8) & 0xFF);
 8028cd2:	ea4f 2e1a 	mov.w	lr, sl, lsr #8
  uSPIData[LMX249x_REG_IDX(16, 9, 18)] = (int8_t) ((iFactorN >> 16) & 0x03) |
    (eFracOrder << 4)        |
      (eDitherMode << 2);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 19)] = (iFracNumarator >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 20)] = (iFracNumarator >>  8) & 0xFF;
 8028cd6:	1205      	asrs	r5, r0, #8
  uSPIData[LMX249x_REG_IDX(16, 9, 21)] = (iFracNumarator >> 16) & 0xFF;
 8028cd8:	1402      	asrs	r2, r0, #16
  uSPIData[LMX249x_REG_IDX(16, 9, 23)] = (iFracDenominator >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 24)] = (iFracDenominator >> 16) & 0xFF;
  
  /* Send register sequence to PLL */
  uSPIData[0] = 0;
  uSPIData[1] = 16 + 9 - 1;
 8028cda:	2118      	movs	r1, #24
  uSPIData[LMX249x_REG_IDX(16, 9, 17)] = (int8_t) ((iFactorN >>  8) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 18)] = (int8_t) ((iFactorN >> 16) & 0x03) |
    (eFracOrder << 4)        |
      (eDitherMode << 2);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 19)] = (iFracNumarator >>  0) & 0xFF;
 8028cdc:	f88d 000b 	strb.w	r0, [sp, #11]
  uSPIData[LMX249x_REG_IDX(16, 9, 20)] = (iFracNumarator >>  8) & 0xFF;
 8028ce0:	f88d 500a 	strb.w	r5, [sp, #10]
  uSPIData[LMX249x_REG_IDX(16, 9, 24)] = (iFracDenominator >> 16) & 0xFF;
  
  /* Send register sequence to PLL */
  uSPIData[0] = 0;
  uSPIData[1] = 16 + 9 - 1;
  pThis->sendSPI(uSPIData, 9 + 2, pThis->pDataForSendSPI);
 8028ce4:	a801      	add	r0, sp, #4
    (eFracOrder << 4)        |
      (eDitherMode << 2);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 19)] = (iFracNumarator >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 20)] = (iFracNumarator >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 21)] = (iFracNumarator >> 16) & 0xFF;
 8028ce6:	f88d 2009 	strb.w	r2, [sp, #9]
  uSPIData[LMX249x_REG_IDX(16, 9, 23)] = (iFracDenominator >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 24)] = (iFracDenominator >> 16) & 0xFF;
  
  /* Send register sequence to PLL */
  uSPIData[0] = 0;
  uSPIData[1] = 16 + 9 - 1;
 8028cea:	f88d 1005 	strb.w	r1, [sp, #5]
  iFactorN = (int32_t)dRelFrequency;
  dRelFrequency -= iFactorN;
  iFracDenominator = 1<<24;
  iFracNumarator = (uint32_t)(dRelFrequency * iFracDenominator + 0.5);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 16)] = (int8_t) ((iFactorN >>  0) & 0xFF);
 8028cee:	f88d a00e 	strb.w	sl, [sp, #14]
  uSPIData[LMX249x_REG_IDX(16, 9, 22)] = (iFracDenominator >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 23)] = (iFracDenominator >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 24)] = (iFracDenominator >> 16) & 0xFF;
  
  /* Send register sequence to PLL */
  uSPIData[0] = 0;
 8028cf2:	f88d 6004 	strb.w	r6, [sp, #4]
  iFracDenominator = 1<<24;
  iFracNumarator = (uint32_t)(dRelFrequency * iFracDenominator + 0.5);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 16)] = (int8_t) ((iFactorN >>  0) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 17)] = (int8_t) ((iFactorN >>  8) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 18)] = (int8_t) ((iFactorN >> 16) & 0x03) |
 8028cf6:	f88d 700c 	strb.w	r7, [sp, #12]
  dRelFrequency -= iFactorN;
  iFracDenominator = 1<<24;
  iFracNumarator = (uint32_t)(dRelFrequency * iFracDenominator + 0.5);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 16)] = (int8_t) ((iFactorN >>  0) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 17)] = (int8_t) ((iFactorN >>  8) & 0xFF);
 8028cfa:	f88d e00d 	strb.w	lr, [sp, #13]
  uSPIData[LMX249x_REG_IDX(16, 9, 24)] = (iFracDenominator >> 16) & 0xFF;
  
  /* Send register sequence to PLL */
  uSPIData[0] = 0;
  uSPIData[1] = 16 + 9 - 1;
  pThis->sendSPI(uSPIData, 9 + 2, pThis->pDataForSendSPI);
 8028cfe:	6965      	ldr	r5, [r4, #20]
 8028d00:	69a2      	ldr	r2, [r4, #24]
  uSPIData[LMX249x_REG_IDX(16, 9, 19)] = (iFracNumarator >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 20)] = (iFracNumarator >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 21)] = (iFracNumarator >> 16) & 0xFF;
  
  iFracDenominator -= 1;
  uSPIData[LMX249x_REG_IDX(16, 9, 22)] = (iFracDenominator >>  0) & 0xFF;
 8028d02:	f88d 3008 	strb.w	r3, [sp, #8]
  uSPIData[LMX249x_REG_IDX(16, 9, 23)] = (iFracDenominator >>  8) & 0xFF;
 8028d06:	f88d 3007 	strb.w	r3, [sp, #7]
  uSPIData[LMX249x_REG_IDX(16, 9, 24)] = (iFracDenominator >> 16) & 0xFF;
 8028d0a:	f88d 3006 	strb.w	r3, [sp, #6]
  
  /* Send register sequence to PLL */
  uSPIData[0] = 0;
  uSPIData[1] = 16 + 9 - 1;
  pThis->sendSPI(uSPIData, 9 + 2, pThis->pDataForSendSPI);
 8028d0e:	210b      	movs	r1, #11
 8028d10:	47a8      	blx	r5
  
  return (LMX249x_ERROR_CODE_OK);
}
 8028d12:	4630      	mov	r0, r6
 8028d14:	b004      	add	sp, #16
 8028d16:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8028d1a:	bf00      	nop
 8028d1c:	41700000 	.word	0x41700000
 8028d20:	3fe00000 	.word	0x3fe00000

08028d24 <lmx249x_configure_ramps>:

Lmx249x_Error_Code_t lmx249x_configure_ramps(Lmx249x_Object_t* pThis,
                                             const Lmx249x_Ramp_Global_t* pGlobalSettings,
                                             const Lmx249x_Ramp_Section_t* pRampSections,
                                             uint8_t uNumSections)
{
 8028d24:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int64_t iRampLimitLow;
  int64_t iRampLimitHigh;
  int64_t iFSKDev;
  
  /* Check if the number of range is in a valid range */
  if ((uNumSections < 1) || (uNumSections > 8))
 8028d28:	f103 3eff 	add.w	lr, r3, #4294967295
 8028d2c:	f1be 0f07 	cmp.w	lr, #7

Lmx249x_Error_Code_t lmx249x_configure_ramps(Lmx249x_Object_t* pThis,
                                             const Lmx249x_Ramp_Global_t* pGlobalSettings,
                                             const Lmx249x_Ramp_Section_t* pRampSections,
                                             uint8_t uNumSections)
{
 8028d30:	b095      	sub	sp, #84	; 0x54
  uint8_t uSPIData[29];  /* Data buffer that will be passed to the SPI interface */
  const double dFrequencyToNFactor = pThis->dExternalDivideFactor * pThis->dPFDCycleTime;
 8028d32:	e9d0 6700 	ldrd	r6, r7, [r0]
 8028d36:	e9d0 4502 	ldrd	r4, r5, [r0, #8]
  int64_t iRampLimitLow;
  int64_t iRampLimitHigh;
  int64_t iFSKDev;
  
  /* Check if the number of range is in a valid range */
  if ((uNumSections < 1) || (uNumSections > 8))
 8028d3a:	d903      	bls.n	8028d44 <lmx249x_configure_ramps+0x20>
    return (LMX249x_ERROR_CODE_INVALID_NUMBER_OF_RAMPS);
 8028d3c:	2001      	movs	r0, #1
  uSPIData[0] = 0;
  uSPIData[1] = 58 + 27 - 1;
  pThis->sendSPI(uSPIData, 27 + 2, pThis->pDataForSendSPI);
  
  return (LMX249x_ERROR_CODE_OK);
}
 8028d3e:	b015      	add	sp, #84	; 0x54
 8028d40:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8028d44:	4683      	mov	fp, r0
 8028d46:	920a      	str	r2, [sp, #40]	; 0x28
 8028d48:	910b      	str	r1, [sp, #44]	; 0x2c
 8028d4a:	9309      	str	r3, [sp, #36]	; 0x24
                                             const Lmx249x_Ramp_Global_t* pGlobalSettings,
                                             const Lmx249x_Ramp_Section_t* pRampSections,
                                             uint8_t uNumSections)
{
  uint8_t uSPIData[29];  /* Data buffer that will be passed to the SPI interface */
  const double dFrequencyToNFactor = pThis->dExternalDivideFactor * pThis->dPFDCycleTime;
 8028d4c:	4639      	mov	r1, r7
 8028d4e:	462b      	mov	r3, r5
 8028d50:	4622      	mov	r2, r4
 8028d52:	4630      	mov	r0, r6
 8028d54:	f001 f86e 	bl	8029e34 <__aeabi_dmul>
  /* Check if the number of range is in a valid range */
  if ((uNumSections < 1) || (uNumSections > 8))
    return (LMX249x_ERROR_CODE_INVALID_NUMBER_OF_RAMPS);
  
  /* Disable ramp (just in case a ramp is currently in progress) */
  uSPIData[0] = 0;
 8028d58:	2700      	movs	r7, #0
  uSPIData[1] = 58;
 8028d5a:	233a      	movs	r3, #58	; 0x3a
                                             const Lmx249x_Ramp_Global_t* pGlobalSettings,
                                             const Lmx249x_Ramp_Section_t* pRampSections,
                                             uint8_t uNumSections)
{
  uint8_t uSPIData[29];  /* Data buffer that will be passed to the SPI interface */
  const double dFrequencyToNFactor = pThis->dExternalDivideFactor * pThis->dPFDCycleTime;
 8028d5c:	e9cd 0104 	strd	r0, r1, [sp, #16]
  if ((uNumSections < 1) || (uNumSections > 8))
    return (LMX249x_ERROR_CODE_INVALID_NUMBER_OF_RAMPS);
  
  /* Disable ramp (just in case a ramp is currently in progress) */
  uSPIData[0] = 0;
  uSPIData[1] = 58;
 8028d60:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
  /* Check if the number of range is in a valid range */
  if ((uNumSections < 1) || (uNumSections > 8))
    return (LMX249x_ERROR_CODE_INVALID_NUMBER_OF_RAMPS);
  
  /* Disable ramp (just in case a ramp is currently in progress) */
  uSPIData[0] = 0;
 8028d64:	f88d 7030 	strb.w	r7, [sp, #48]	; 0x30
  uSPIData[1] = 58;
  uSPIData[2] = 0;
 8028d68:	f88d 7032 	strb.w	r7, [sp, #50]	; 0x32
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
 8028d6c:	a80c      	add	r0, sp, #48	; 0x30
 8028d6e:	f8db 3014 	ldr.w	r3, [fp, #20]
 8028d72:	f8db 2018 	ldr.w	r2, [fp, #24]
 8028d76:	2103      	movs	r1, #3
  
  /* Setup up the ramp sections */
  for (uIdx = 0; uIdx < uNumSections; ++uIdx)
 8028d78:	46b8      	mov	r8, r7
  
  /* Disable ramp (just in case a ramp is currently in progress) */
  uSPIData[0] = 0;
  uSPIData[1] = 58;
  uSPIData[2] = 0;
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
 8028d7a:	4798      	blx	r3
 8028d7c:	463d      	mov	r5, r7
  
  /* Setup up the ramp sections */
  for (uIdx = 0; uIdx < uNumSections; ++uIdx)
 8028d7e:	9707      	str	r7, [sp, #28]
 8028d80:	9708      	str	r7, [sp, #32]
 8028d82:	9700      	str	r7, [sp, #0]
 8028d84:	46c2      	mov	sl, r8
 8028d86:	e066      	b.n	8028e56 <lmx249x_configure_ramps+0x132>
    uRampLength =  (int32_t) ((pThisSection->dTramp) / pThis->dPFDCycleTime);
    if (uRampLength > 0xFFFF)
    {
      /* If the ramp is too long, divide ramp length by two and set the delay flag which doubles the ramp time */
      uRampLength >>= 1;
      uDelayFlag = 0x80;
 8028d88:	2380      	movs	r3, #128	; 0x80
 8028d8a:	f894 901a 	ldrb.w	r9, [r4, #26]
 8028d8e:	9307      	str	r3, [sp, #28]
    /* Convert given ramp parameters to counter values */
    uRampLength =  (int32_t) ((pThisSection->dTramp) / pThis->dPFDCycleTime);
    if (uRampLength > 0xFFFF)
    {
      /* If the ramp is too long, divide ramp length by two and set the delay flag which doubles the ramp time */
      uRampLength >>= 1;
 8028d90:	0845      	lsrs	r5, r0, #1
    * at least 1, otherwise the counter seems to wrap around and the section will be longer than expected.
    */
    if ((uRampLength == 0) && (pThisSection->eNextTrig == LMX249x_RAMP_NEXT_TRIG_RAMPX_LEN))
      uRampLength = 1;
    
    uCounterInc =  (int32_t) (pThisSection->dFreqShift * dFrequencyToNFactor * dFracDenominator / (double)uRampLength);
 8028d92:	e9d4 2300 	ldrd	r2, r3, [r4]
 8028d96:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8028d9a:	f001 f84b 	bl	8029e34 <__aeabi_dmul>
 8028d9e:	2200      	movs	r2, #0
 8028da0:	4b3b      	ldr	r3, [pc, #236]	; (8028e90 <lmx249x_configure_ramps+0x16c>)
 8028da2:	f001 f847 	bl	8029e34 <__aeabi_dmul>
 8028da6:	4606      	mov	r6, r0
 8028da8:	4628      	mov	r0, r5
 8028daa:	460f      	mov	r7, r1
 8028dac:	f000 ffcc 	bl	8029d48 <__aeabi_ui2d>
 8028db0:	4602      	mov	r2, r0
 8028db2:	460b      	mov	r3, r1
 8028db4:	4630      	mov	r0, r6
 8028db6:	4639      	mov	r1, r7
 8028db8:	f001 f966 	bl	802a088 <__aeabi_ddiv>
 8028dbc:	f001 fad4 	bl	802a368 <__aeabi_d2iz>
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 5)] = ((uRampLength >> 8) & 0xFF);
    
    /* Set flags */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 6)] = ((int8_t) ((pThisSection->uNext &0x07)  << 5)) |
      ((int8_t)  (pThisSection->eNextTrig << 3)) |
        ((int8_t)  (pThisSection->eReset    << 2)) |
 8028dc0:	7e63      	ldrb	r3, [r4, #25]
    /* Set ramp_length */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 4)] = ((uRampLength >> 0) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 5)] = ((uRampLength >> 8) & 0xFF);
    
    /* Set flags */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 6)] = ((int8_t) ((pThisSection->uNext &0x07)  << 5)) |
 8028dc2:	7ee6      	ldrb	r6, [r4, #27]
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 1)] = (uint8_t) ((uCounterInc >>  8) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 2)] = (uint8_t) ((uCounterInc >> 16) & 0xFF);
    
    /* Set flags and increment */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 3)] = uDelayFlag |
      (uint8_t) ((pThisSection->eFastlock) << 6) |
 8028dc4:	7a22      	ldrb	r2, [r4, #8]
 8028dc6:	7e21      	ldrb	r1, [r4, #24]
        ((int8_t)  (pThisSection->eReset    << 2)) |
          ((int8_t)  (pThisSection->eFlag   << 0));
    
    /* Set comparator enable bit */
    uCompEnMask = 1 << uIdx;
    uComparator0Enable |= (pThisSection->eComparators & LMX249x_RAMP_USE_COMPARATOR_1) ? uCompEnMask : 0;
 8028dc8:	7f24      	ldrb	r4, [r4, #28]
      uRampLength = 1;
    
    uCounterInc =  (int32_t) (pThisSection->dFreqShift * dFrequencyToNFactor * dFracDenominator / (double)uRampLength);
    
    /* Set ramp_increment */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 0)] = (uint8_t) ((uCounterInc >>  0) & 0xFF);
 8028dca:	f88d 0038 	strb.w	r0, [sp, #56]	; 0x38
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 5)] = ((uRampLength >> 8) & 0xFF);
    
    /* Set flags */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 6)] = ((int8_t) ((pThisSection->uNext &0x07)  << 5)) |
      ((int8_t)  (pThisSection->eNextTrig << 3)) |
        ((int8_t)  (pThisSection->eReset    << 2)) |
 8028dce:	009b      	lsls	r3, r3, #2
 8028dd0:	ea43 1646 	orr.w	r6, r3, r6, lsl #5
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 0)] = (uint8_t) ((uCounterInc >>  0) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 1)] = (uint8_t) ((uCounterInc >>  8) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 2)] = (uint8_t) ((uCounterInc >> 16) & 0xFF);
    
    /* Set flags and increment */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 3)] = uDelayFlag |
 8028dd4:	9b07      	ldr	r3, [sp, #28]
      (uint8_t) ((pThisSection->eFastlock) << 6) |
        (uint8_t) ((uCounterInc >> 24) & 0x3F);
    
    /* Set ramp_length */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 4)] = ((uRampLength >> 0) & 0xFF);
 8028dd6:	f88d 5034 	strb.w	r5, [sp, #52]	; 0x34
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 0)] = (uint8_t) ((uCounterInc >>  0) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 1)] = (uint8_t) ((uCounterInc >>  8) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 2)] = (uint8_t) ((uCounterInc >> 16) & 0xFF);
    
    /* Set flags and increment */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 3)] = uDelayFlag |
 8028dda:	ea43 1282 	orr.w	r2, r3, r2, lsl #6
      ((int8_t)  (pThisSection->eNextTrig << 3)) |
        ((int8_t)  (pThisSection->eReset    << 2)) |
          ((int8_t)  (pThisSection->eFlag   << 0));
    
    /* Set comparator enable bit */
    uCompEnMask = 1 << uIdx;
 8028dde:	9b00      	ldr	r3, [sp, #0]
 8028de0:	4331      	orrs	r1, r6
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 0)] = (uint8_t) ((uCounterInc >>  0) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 1)] = (uint8_t) ((uCounterInc >>  8) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 2)] = (uint8_t) ((uCounterInc >> 16) & 0xFF);
    
    /* Set flags and increment */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 3)] = uDelayFlag |
 8028de2:	f3c0 6e05 	ubfx	lr, r0, #24, #6
      ((int8_t)  (pThisSection->eNextTrig << 3)) |
        ((int8_t)  (pThisSection->eReset    << 2)) |
          ((int8_t)  (pThisSection->eFlag   << 0));
    
    /* Set comparator enable bit */
    uCompEnMask = 1 << uIdx;
 8028de6:	2701      	movs	r7, #1
 8028de8:	409f      	lsls	r7, r3
    
    uCounterInc =  (int32_t) (pThisSection->dFreqShift * dFrequencyToNFactor * dFracDenominator / (double)uRampLength);
    
    /* Set ramp_increment */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 0)] = (uint8_t) ((uCounterInc >>  0) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 1)] = (uint8_t) ((uCounterInc >>  8) & 0xFF);
 8028dea:	1206      	asrs	r6, r0, #8
      (uint8_t) ((pThisSection->eFastlock) << 6) |
        (uint8_t) ((uCounterInc >> 24) & 0x3F);
    
    /* Set ramp_length */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 4)] = ((uRampLength >> 0) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 5)] = ((uRampLength >> 8) & 0xFF);
 8028dec:	0a2b      	lsrs	r3, r5, #8
    
    /* Set flags */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 6)] = ((int8_t) ((pThisSection->uNext &0x07)  << 5)) |
 8028dee:	ea41 01c9 	orr.w	r1, r1, r9, lsl #3
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 0)] = (uint8_t) ((uCounterInc >>  0) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 1)] = (uint8_t) ((uCounterInc >>  8) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 2)] = (uint8_t) ((uCounterInc >> 16) & 0xFF);
    
    /* Set flags and increment */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 3)] = uDelayFlag |
 8028df2:	ea4e 0202 	orr.w	r2, lr, r2
        ((int8_t)  (pThisSection->eReset    << 2)) |
          ((int8_t)  (pThisSection->eFlag   << 0));
    
    /* Set comparator enable bit */
    uCompEnMask = 1 << uIdx;
    uComparator0Enable |= (pThisSection->eComparators & LMX249x_RAMP_USE_COMPARATOR_1) ? uCompEnMask : 0;
 8028df6:	f004 0402 	and.w	r4, r4, #2
    uCounterInc =  (int32_t) (pThisSection->dFreqShift * dFrequencyToNFactor * dFracDenominator / (double)uRampLength);
    
    /* Set ramp_increment */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 0)] = (uint8_t) ((uCounterInc >>  0) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 1)] = (uint8_t) ((uCounterInc >>  8) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 2)] = (uint8_t) ((uCounterInc >> 16) & 0xFF);
 8028dfa:	1400      	asrs	r0, r0, #16
      (uint8_t) ((pThisSection->eFastlock) << 6) |
        (uint8_t) ((uCounterInc >> 24) & 0x3F);
    
    /* Set ramp_length */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 4)] = ((uRampLength >> 0) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 5)] = ((uRampLength >> 8) & 0xFF);
 8028dfc:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
        ((int8_t)  (pThisSection->eReset    << 2)) |
          ((int8_t)  (pThisSection->eFlag   << 0));
    
    /* Set comparator enable bit */
    uCompEnMask = 1 << uIdx;
    uComparator0Enable |= (pThisSection->eComparators & LMX249x_RAMP_USE_COMPARATOR_1) ? uCompEnMask : 0;
 8028e00:	b2ff      	uxtb	r7, r7
    /* Set ramp_length */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 4)] = ((uRampLength >> 0) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 5)] = ((uRampLength >> 8) & 0xFF);
    
    /* Set flags */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 6)] = ((int8_t) ((pThisSection->uNext &0x07)  << 5)) |
 8028e02:	f88d 1032 	strb.w	r1, [sp, #50]	; 0x32
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 0)] = (uint8_t) ((uCounterInc >>  0) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 1)] = (uint8_t) ((uCounterInc >>  8) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 2)] = (uint8_t) ((uCounterInc >> 16) & 0xFF);
    
    /* Set flags and increment */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 3)] = uDelayFlag |
 8028e06:	f88d 2035 	strb.w	r2, [sp, #53]	; 0x35
        ((int8_t)  (pThisSection->eReset    << 2)) |
          ((int8_t)  (pThisSection->eFlag   << 0));
    
    /* Set comparator enable bit */
    uCompEnMask = 1 << uIdx;
    uComparator0Enable |= (pThisSection->eComparators & LMX249x_RAMP_USE_COMPARATOR_1) ? uCompEnMask : 0;
 8028e0a:	f004 03ff 	and.w	r3, r4, #255	; 0xff
    
    uCounterInc =  (int32_t) (pThisSection->dFreqShift * dFrequencyToNFactor * dFracDenominator / (double)uRampLength);
    
    /* Set ramp_increment */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 0)] = (uint8_t) ((uCounterInc >>  0) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 1)] = (uint8_t) ((uCounterInc >>  8) & 0xFF);
 8028e0e:	f88d 6037 	strb.w	r6, [sp, #55]	; 0x37
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 2)] = (uint8_t) ((uCounterInc >> 16) & 0xFF);
 8028e12:	f88d 0036 	strb.w	r0, [sp, #54]	; 0x36
        ((int8_t)  (pThisSection->eReset    << 2)) |
          ((int8_t)  (pThisSection->eFlag   << 0));
    
    /* Set comparator enable bit */
    uCompEnMask = 1 << uIdx;
    uComparator0Enable |= (pThisSection->eComparators & LMX249x_RAMP_USE_COMPARATOR_1) ? uCompEnMask : 0;
 8028e16:	2c00      	cmp	r4, #0
 8028e18:	d038      	beq.n	8028e8c <lmx249x_configure_ramps+0x168>
 8028e1a:	9b08      	ldr	r3, [sp, #32]
 8028e1c:	433b      	orrs	r3, r7
 8028e1e:	9308      	str	r3, [sp, #32]
    uComparator1Enable |= (pThisSection->eComparators & LMX249x_RAMP_USE_COMPARATOR_1) ? uCompEnMask : 0;
    
    /* Write the register data to the chip, write highest address (the one of the register written first) at the
    * beginning of the data buffer.
    */
    uBaseRegister += uNumRegs - 1;
 8028e20:	9b02      	ldr	r3, [sp, #8]
 8028e22:	335c      	adds	r3, #92	; 0x5c
 8028e24:	b29b      	uxth	r3, r3
    uSPIData[0] = (uint8_t)((uBaseRegister >> 8) & 0xFF);
 8028e26:	0a1a      	lsrs	r2, r3, #8
    uSPIData[1] = (uint8_t)((uBaseRegister >> 0) & 0xFF);
 8028e28:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    
    /* Write the register data to the chip, write highest address (the one of the register written first) at the
    * beginning of the data buffer.
    */
    uBaseRegister += uNumRegs - 1;
    uSPIData[0] = (uint8_t)((uBaseRegister >> 8) & 0xFF);
 8028e2c:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
    uSPIData[1] = (uint8_t)((uBaseRegister >> 0) & 0xFF);
    pThis->sendSPI(uSPIData, uNumRegs + 2, pThis->pDataForSendSPI);
 8028e30:	f8db 3014 	ldr.w	r3, [fp, #20]
 8028e34:	f8db 2018 	ldr.w	r2, [fp, #24]
 8028e38:	2109      	movs	r1, #9
 8028e3a:	a80c      	add	r0, sp, #48	; 0x30
 8028e3c:	f108 0801 	add.w	r8, r8, #1
 8028e40:	4798      	blx	r3
 8028e42:	fa5f f888 	uxtb.w	r8, r8
  uSPIData[1] = 58;
  uSPIData[2] = 0;
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
  
  /* Setup up the ramp sections */
  for (uIdx = 0; uIdx < uNumSections; ++uIdx)
 8028e46:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8028e48:	fa4f f588 	sxtb.w	r5, r8
 8028e4c:	429d      	cmp	r5, r3
          ((int8_t)  (pThisSection->eFlag   << 0));
    
    /* Set comparator enable bit */
    uCompEnMask = 1 << uIdx;
    uComparator0Enable |= (pThisSection->eComparators & LMX249x_RAMP_USE_COMPARATOR_1) ? uCompEnMask : 0;
    uComparator1Enable |= (pThisSection->eComparators & LMX249x_RAMP_USE_COMPARATOR_1) ? uCompEnMask : 0;
 8028e4e:	ea47 0a0a 	orr.w	sl, r7, sl
  uSPIData[1] = 58;
  uSPIData[2] = 0;
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
  
  /* Setup up the ramp sections */
  for (uIdx = 0; uIdx < uNumSections; ++uIdx)
 8028e52:	9500      	str	r5, [sp, #0]
 8028e54:	da1e      	bge.n	8028e94 <lmx249x_configure_ramps+0x170>
  {
    /* Setup register buffer */
    uBaseRegister = (86 + uIdx * 7);
    pThisSection = &pRampSections[uIdx];
 8028e56:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8028e58:	eb03 1445 	add.w	r4, r3, r5, lsl #5
  
  /* Setup up the ramp sections */
  for (uIdx = 0; uIdx < uNumSections; ++uIdx)
  {
    /* Setup register buffer */
    uBaseRegister = (86 + uIdx * 7);
 8028e5c:	ebc5 05c5 	rsb	r5, r5, r5, lsl #3
    pThisSection = &pRampSections[uIdx];
    
    /* Convert given ramp parameters to counter values */
    uRampLength =  (int32_t) ((pThisSection->dTramp) / pThis->dPFDCycleTime);
 8028e60:	e9db 2302 	ldrd	r2, r3, [fp, #8]
  
  /* Setup up the ramp sections */
  for (uIdx = 0; uIdx < uNumSections; ++uIdx)
  {
    /* Setup register buffer */
    uBaseRegister = (86 + uIdx * 7);
 8028e64:	b2ad      	uxth	r5, r5
    pThisSection = &pRampSections[uIdx];
    
    /* Convert given ramp parameters to counter values */
    uRampLength =  (int32_t) ((pThisSection->dTramp) / pThis->dPFDCycleTime);
 8028e66:	e9d4 0104 	ldrd	r0, r1, [r4, #16]
  
  /* Setup up the ramp sections */
  for (uIdx = 0; uIdx < uNumSections; ++uIdx)
  {
    /* Setup register buffer */
    uBaseRegister = (86 + uIdx * 7);
 8028e6a:	9502      	str	r5, [sp, #8]
    pThisSection = &pRampSections[uIdx];
    
    /* Convert given ramp parameters to counter values */
    uRampLength =  (int32_t) ((pThisSection->dTramp) / pThis->dPFDCycleTime);
 8028e6c:	f001 f90c 	bl	802a088 <__aeabi_ddiv>
 8028e70:	f001 fa7a 	bl	802a368 <__aeabi_d2iz>
    if (uRampLength > 0xFFFF)
 8028e74:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
    /* Setup register buffer */
    uBaseRegister = (86 + uIdx * 7);
    pThisSection = &pRampSections[uIdx];
    
    /* Convert given ramp parameters to counter values */
    uRampLength =  (int32_t) ((pThisSection->dTramp) / pThis->dPFDCycleTime);
 8028e78:	4605      	mov	r5, r0
    if (uRampLength > 0xFFFF)
 8028e7a:	d285      	bcs.n	8028d88 <lmx249x_configure_ramps+0x64>
    }
    
    /* If the transition to the next sections is triggered by the length of this section, the length must be
    * at least 1, otherwise the counter seems to wrap around and the section will be longer than expected.
    */
    if ((uRampLength == 0) && (pThisSection->eNextTrig == LMX249x_RAMP_NEXT_TRIG_RAMPX_LEN))
 8028e7c:	f894 901a 	ldrb.w	r9, [r4, #26]
 8028e80:	2800      	cmp	r0, #0
 8028e82:	d186      	bne.n	8028d92 <lmx249x_configure_ramps+0x6e>
 8028e84:	fab9 f589 	clz	r5, r9
 8028e88:	096d      	lsrs	r5, r5, #5
 8028e8a:	e782      	b.n	8028d92 <lmx249x_configure_ramps+0x6e>
          ((int8_t)  (pThisSection->eFlag   << 0));
    
    /* Set comparator enable bit */
    uCompEnMask = 1 << uIdx;
    uComparator0Enable |= (pThisSection->eComparators & LMX249x_RAMP_USE_COMPARATOR_1) ? uCompEnMask : 0;
    uComparator1Enable |= (pThisSection->eComparators & LMX249x_RAMP_USE_COMPARATOR_1) ? uCompEnMask : 0;
 8028e8c:	461f      	mov	r7, r3
 8028e8e:	e7c7      	b.n	8028e20 <lmx249x_configure_ramps+0xfc>
 8028e90:	41700000 	.word	0x41700000
  /* Wet comparator enable bits */
  uSPIData[LMX249x_REG_IDX(58, 27, 64)] = uComparator0Enable;
  uSPIData[LMX249x_REG_IDX(58, 27, 69)] = uComparator1Enable;
  
  /* Setup base frequency */
  dRelFrequency = pGlobalSettings->dBaseFrequency * dFrequencyToNFactor;  /* divider ratio between PLL-RF-in and PFD-frequency */
 8028e94:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    uSPIData[1] = (uint8_t)((uBaseRegister >> 0) & 0xFF);
    pThis->sendSPI(uSPIData, uNumRegs + 2, pThis->pDataForSendSPI);
  }
  
  /* Wet comparator enable bits */
  uSPIData[LMX249x_REG_IDX(58, 27, 64)] = uComparator0Enable;
 8028e96:	f89d 4020 	ldrb.w	r4, [sp, #32]
 8028e9a:	f88d 4046 	strb.w	r4, [sp, #70]	; 0x46
  uSPIData[LMX249x_REG_IDX(58, 27, 69)] = uComparator1Enable;
  
  /* Setup base frequency */
  dRelFrequency = pGlobalSettings->dBaseFrequency * dFrequencyToNFactor;  /* divider ratio between PLL-RF-in and PFD-frequency */
 8028e9e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8028ea2:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    pThis->sendSPI(uSPIData, uNumRegs + 2, pThis->pDataForSendSPI);
  }
  
  /* Wet comparator enable bits */
  uSPIData[LMX249x_REG_IDX(58, 27, 64)] = uComparator0Enable;
  uSPIData[LMX249x_REG_IDX(58, 27, 69)] = uComparator1Enable;
 8028ea6:	f88d a041 	strb.w	sl, [sp, #65]	; 0x41
  
  /* Setup base frequency */
  dRelFrequency = pGlobalSettings->dBaseFrequency * dFrequencyToNFactor;  /* divider ratio between PLL-RF-in and PFD-frequency */
 8028eaa:	f000 ffc3 	bl	8029e34 <__aeabi_dmul>
 8028eae:	460f      	mov	r7, r1
 8028eb0:	4606      	mov	r6, r0
  
  iFactorN = (int32_t)dRelFrequency;
 8028eb2:	f001 fa59 	bl	802a368 <__aeabi_d2iz>
 8028eb6:	4680      	mov	r8, r0
  dRelFrequency -= iFactorN;
 8028eb8:	f000 ff46 	bl	8029d48 <__aeabi_ui2d>
 8028ebc:	4604      	mov	r4, r0
 8028ebe:	460d      	mov	r5, r1
 8028ec0:	4622      	mov	r2, r4
 8028ec2:	462b      	mov	r3, r5
 8028ec4:	4630      	mov	r0, r6
 8028ec6:	4639      	mov	r1, r7
 8028ec8:	f000 fe00 	bl	8029acc <__aeabi_dsub>
  iFracNumarator = (uint32_t) (dRelFrequency * dFracDenominator);
 8028ecc:	2200      	movs	r2, #0
 8028ece:	4ba2      	ldr	r3, [pc, #648]	; (8029158 <lmx249x_configure_ramps+0x434>)
 8028ed0:	f000 ffb0 	bl	8029e34 <__aeabi_dmul>
 8028ed4:	f001 fa70 	bl	802a3b8 <__aeabi_d2uiz>
  
  uSPIData[LMX249x_REG_IDX(16, 9, 16)] = (int8_t) ((iFactorN >>  0) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 17)] = (int8_t) ((iFactorN >>  8) & 0xFF);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 18)] = (int8_t) (((iFactorN >> 16) & 0x03) | (pGlobalSettings->eFracOrder << 4) | (pGlobalSettings->eDitherMode << 2));
 8028ed8:	990b      	ldr	r1, [sp, #44]	; 0x2c
  
  iFactorN = (int32_t)dRelFrequency;
  dRelFrequency -= iFactorN;
  iFracNumarator = (uint32_t) (dRelFrequency * dFracDenominator);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 16)] = (int8_t) ((iFactorN >>  0) & 0xFF);
 8028eda:	f88d 803a 	strb.w	r8, [sp, #58]	; 0x3a
  uSPIData[LMX249x_REG_IDX(16, 9, 17)] = (int8_t) ((iFactorN >>  8) & 0xFF);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 18)] = (int8_t) (((iFactorN >> 16) & 0x03) | (pGlobalSettings->eFracOrder << 4) | (pGlobalSettings->eDitherMode << 2));
 8028ede:	f891 303a 	ldrb.w	r3, [r1, #58]	; 0x3a
 8028ee2:	f891 203b 	ldrb.w	r2, [r1, #59]	; 0x3b
  
  uSPIData[LMX249x_REG_IDX(16, 9, 19)] = (iFracNumarator >>  0) & 0xFF;
 8028ee6:	f88d 0037 	strb.w	r0, [sp, #55]	; 0x37
  iFracNumarator = (uint32_t) (dRelFrequency * dFracDenominator);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 16)] = (int8_t) ((iFactorN >>  0) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 17)] = (int8_t) ((iFactorN >>  8) & 0xFF);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 18)] = (int8_t) (((iFactorN >> 16) & 0x03) | (pGlobalSettings->eFracOrder << 4) | (pGlobalSettings->eDitherMode << 2));
 8028eea:	011b      	lsls	r3, r3, #4
 8028eec:	ea43 0382 	orr.w	r3, r3, r2, lsl #2
 8028ef0:	f3c8 4101 	ubfx	r1, r8, #16, #2
  
  uSPIData[LMX249x_REG_IDX(16, 9, 19)] = (iFracNumarator >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 20)] = (iFracNumarator >>  8) & 0xFF;
 8028ef4:	ea4f 2e20 	mov.w	lr, r0, asr #8
  uSPIData[LMX249x_REG_IDX(16, 9, 21)] = (iFracNumarator >> 16) & 0xFF;
  
  /* Fractional denominator is always 0xFFFFFF when ramp generator is active */
  uSPIData[LMX249x_REG_IDX(16, 9, 22)] = 0xFF;
 8028ef8:	22ff      	movs	r2, #255	; 0xff
  iFracNumarator = (uint32_t) (dRelFrequency * dFracDenominator);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 16)] = (int8_t) ((iFactorN >>  0) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 17)] = (int8_t) ((iFactorN >>  8) & 0xFF);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 18)] = (int8_t) (((iFactorN >> 16) & 0x03) | (pGlobalSettings->eFracOrder << 4) | (pGlobalSettings->eDitherMode << 2));
 8028efa:	4319      	orrs	r1, r3
  
  uSPIData[LMX249x_REG_IDX(16, 9, 19)] = (iFracNumarator >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 20)] = (iFracNumarator >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 21)] = (iFracNumarator >> 16) & 0xFF;
 8028efc:	1407      	asrs	r7, r0, #16
  iFactorN = (int32_t)dRelFrequency;
  dRelFrequency -= iFactorN;
  iFracNumarator = (uint32_t) (dRelFrequency * dFracDenominator);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 16)] = (int8_t) ((iFactorN >>  0) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 17)] = (int8_t) ((iFactorN >>  8) & 0xFF);
 8028efe:	ea4f 2318 	mov.w	r3, r8, lsr #8
  uSPIData[LMX249x_REG_IDX(16, 9, 23)] = 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 24)] = 0xFF;
  
  /*Send register sequence to PLL */
  uSPIData[0] = 0;
  uSPIData[1] = 16 + 9 - 1;
 8028f02:	2618      	movs	r6, #24
  uSPIData[LMX249x_REG_IDX(16, 9, 22)] = 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 23)] = 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 24)] = 0xFF;
  
  /*Send register sequence to PLL */
  uSPIData[0] = 0;
 8028f04:	f04f 0800 	mov.w	r8, #0
  uSPIData[LMX249x_REG_IDX(16, 9, 17)] = (int8_t) ((iFactorN >>  8) & 0xFF);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 18)] = (int8_t) (((iFactorN >> 16) & 0x03) | (pGlobalSettings->eFracOrder << 4) | (pGlobalSettings->eDitherMode << 2));
  
  uSPIData[LMX249x_REG_IDX(16, 9, 19)] = (iFracNumarator >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 20)] = (iFracNumarator >>  8) & 0xFF;
 8028f08:	f88d e036 	strb.w	lr, [sp, #54]	; 0x36
  iFracNumarator = (uint32_t) (dRelFrequency * dFracDenominator);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 16)] = (int8_t) ((iFactorN >>  0) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 17)] = (int8_t) ((iFactorN >>  8) & 0xFF);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 18)] = (int8_t) (((iFactorN >> 16) & 0x03) | (pGlobalSettings->eFracOrder << 4) | (pGlobalSettings->eDitherMode << 2));
 8028f0c:	f88d 1038 	strb.w	r1, [sp, #56]	; 0x38
  iFactorN = (int32_t)dRelFrequency;
  dRelFrequency -= iFactorN;
  iFracNumarator = (uint32_t) (dRelFrequency * dFracDenominator);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 16)] = (int8_t) ((iFactorN >>  0) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 17)] = (int8_t) ((iFactorN >>  8) & 0xFF);
 8028f10:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
  
  uSPIData[LMX249x_REG_IDX(16, 9, 18)] = (int8_t) (((iFactorN >> 16) & 0x03) | (pGlobalSettings->eFracOrder << 4) | (pGlobalSettings->eDitherMode << 2));
  
  uSPIData[LMX249x_REG_IDX(16, 9, 19)] = (iFracNumarator >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 20)] = (iFracNumarator >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 21)] = (iFracNumarator >> 16) & 0xFF;
 8028f14:	f88d 7035 	strb.w	r7, [sp, #53]	; 0x35
  
  /* Fractional denominator is always 0xFFFFFF when ramp generator is active */
  uSPIData[LMX249x_REG_IDX(16, 9, 22)] = 0xFF;
 8028f18:	f88d 2034 	strb.w	r2, [sp, #52]	; 0x34
  uSPIData[LMX249x_REG_IDX(16, 9, 23)] = 0xFF;
 8028f1c:	f88d 2033 	strb.w	r2, [sp, #51]	; 0x33
  uSPIData[LMX249x_REG_IDX(16, 9, 24)] = 0xFF;
 8028f20:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
  
  /*Send register sequence to PLL */
  uSPIData[0] = 0;
  uSPIData[1] = 16 + 9 - 1;
 8028f24:	f88d 6031 	strb.w	r6, [sp, #49]	; 0x31
  pThis->sendSPI(uSPIData, 9 + 2, pThis->pDataForSendSPI);
 8028f28:	f8db 3014 	ldr.w	r3, [fp, #20]
 8028f2c:	f8db 2018 	ldr.w	r2, [fp, #24]
  uSPIData[LMX249x_REG_IDX(16, 9, 22)] = 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 23)] = 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 24)] = 0xFF;
  
  /*Send register sequence to PLL */
  uSPIData[0] = 0;
 8028f30:	f88d 8030 	strb.w	r8, [sp, #48]	; 0x30
  uSPIData[1] = 16 + 9 - 1;
  pThis->sendSPI(uSPIData, 9 + 2, pThis->pDataForSendSPI);
 8028f34:	a80c      	add	r0, sp, #48	; 0x30
 8028f36:	210b      	movs	r1, #11
 8028f38:	4798      	blx	r3
  /* Setup ramp range and comparator values */
  /* The formula in the LMX249x data sheet for the following settings is very misleading. The used formular was
  * found by debugging. The essence here is to specify the limits as the difference (limFreq - baseFreq), while
  * limFreq is the N factor with fractional part, but baseFreq must be the integer N factor (no rounding, just truncating).
  */
  iRampComp0     = (int64_t) ((pGlobalSettings->dComp0Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
 8028f3a:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 8028f3c:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8028f40:	e9d6 2308 	ldrd	r2, r3, [r6, #32]
 8028f44:	f000 ff76 	bl	8029e34 <__aeabi_dmul>
 8028f48:	4622      	mov	r2, r4
 8028f4a:	462b      	mov	r3, r5
 8028f4c:	f000 fdbe 	bl	8029acc <__aeabi_dsub>
 8028f50:	2200      	movs	r2, #0
 8028f52:	4b81      	ldr	r3, [pc, #516]	; (8029158 <lmx249x_configure_ramps+0x434>)
 8028f54:	f000 ff6e 	bl	8029e34 <__aeabi_dmul>
 8028f58:	f001 fab4 	bl	802a4c4 <__aeabi_d2lz>
  iRampComp1     = (int64_t) ((pGlobalSettings->dComp1Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
 8028f5c:	e9d6 230a 	ldrd	r2, r3, [r6, #40]	; 0x28
  /* Setup ramp range and comparator values */
  /* The formula in the LMX249x data sheet for the following settings is very misleading. The used formular was
  * found by debugging. The essence here is to specify the limits as the difference (limFreq - baseFreq), while
  * limFreq is the N factor with fractional part, but baseFreq must be the integer N factor (no rounding, just truncating).
  */
  iRampComp0     = (int64_t) ((pGlobalSettings->dComp0Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
 8028f60:	4681      	mov	r9, r0
 8028f62:	468a      	mov	sl, r1
  iRampComp1     = (int64_t) ((pGlobalSettings->dComp1Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
 8028f64:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8028f68:	f000 ff64 	bl	8029e34 <__aeabi_dmul>
 8028f6c:	4622      	mov	r2, r4
 8028f6e:	462b      	mov	r3, r5
 8028f70:	f000 fdac 	bl	8029acc <__aeabi_dsub>
 8028f74:	2200      	movs	r2, #0
 8028f76:	4b78      	ldr	r3, [pc, #480]	; (8029158 <lmx249x_configure_ramps+0x434>)
 8028f78:	f000 ff5c 	bl	8029e34 <__aeabi_dmul>
 8028f7c:	f001 faa2 	bl	802a4c4 <__aeabi_d2lz>
  iRampLimitLow  = (int64_t) ((pGlobalSettings->dMinFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
 8028f80:	e9d6 2304 	ldrd	r2, r3, [r6, #16]
  /* The formula in the LMX249x data sheet for the following settings is very misleading. The used formular was
  * found by debugging. The essence here is to specify the limits as the difference (limFreq - baseFreq), while
  * limFreq is the N factor with fractional part, but baseFreq must be the integer N factor (no rounding, just truncating).
  */
  iRampComp0     = (int64_t) ((pGlobalSettings->dComp0Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampComp1     = (int64_t) ((pGlobalSettings->dComp1Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
 8028f84:	e9cd 0102 	strd	r0, r1, [sp, #8]
  iRampLimitLow  = (int64_t) ((pGlobalSettings->dMinFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
 8028f88:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8028f8c:	960b      	str	r6, [sp, #44]	; 0x2c
 8028f8e:	f000 ff51 	bl	8029e34 <__aeabi_dmul>
 8028f92:	4622      	mov	r2, r4
 8028f94:	462b      	mov	r3, r5
 8028f96:	f000 fd99 	bl	8029acc <__aeabi_dsub>
 8028f9a:	2200      	movs	r2, #0
 8028f9c:	4b6e      	ldr	r3, [pc, #440]	; (8029158 <lmx249x_configure_ramps+0x434>)
 8028f9e:	f000 ff49 	bl	8029e34 <__aeabi_dmul>
 8028fa2:	f001 fa8f 	bl	802a4c4 <__aeabi_d2lz>
  iRampLimitHigh = (int64_t) ((pGlobalSettings->dMaxFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
 8028fa6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  * found by debugging. The essence here is to specify the limits as the difference (limFreq - baseFreq), while
  * limFreq is the N factor with fractional part, but baseFreq must be the integer N factor (no rounding, just truncating).
  */
  iRampComp0     = (int64_t) ((pGlobalSettings->dComp0Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampComp1     = (int64_t) ((pGlobalSettings->dComp1Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampLimitLow  = (int64_t) ((pGlobalSettings->dMinFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
 8028fa8:	4606      	mov	r6, r0
  iRampLimitHigh = (int64_t) ((pGlobalSettings->dMaxFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
 8028faa:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
  * found by debugging. The essence here is to specify the limits as the difference (limFreq - baseFreq), while
  * limFreq is the N factor with fractional part, but baseFreq must be the integer N factor (no rounding, just truncating).
  */
  iRampComp0     = (int64_t) ((pGlobalSettings->dComp0Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampComp1     = (int64_t) ((pGlobalSettings->dComp1Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampLimitLow  = (int64_t) ((pGlobalSettings->dMinFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
 8028fae:	460f      	mov	r7, r1
  iRampLimitHigh = (int64_t) ((pGlobalSettings->dMaxFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
 8028fb0:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8028fb4:	f000 ff3e 	bl	8029e34 <__aeabi_dmul>
 8028fb8:	4622      	mov	r2, r4
 8028fba:	462b      	mov	r3, r5
 8028fbc:	f000 fd86 	bl	8029acc <__aeabi_dsub>
 8028fc0:	2200      	movs	r2, #0
 8028fc2:	4b65      	ldr	r3, [pc, #404]	; (8029158 <lmx249x_configure_ramps+0x434>)
 8028fc4:	f000 ff36 	bl	8029e34 <__aeabi_dmul>
 8028fc8:	f001 fa7c 	bl	802a4c4 <__aeabi_d2lz>
  uSPIData[LMX249x_REG_IDX(58, 27, 80)] = (iRampLimitHigh >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 81)] = (iRampLimitHigh >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 82)] = (iRampLimitHigh >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] = ((iRampComp0    & 0x100000000) ? 1 << 0 : 0) |
    ((iRampComp1    & 0x100000000) ? 1 << 1 : 0) |
 8028fcc:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
  * limFreq is the N factor with fractional part, but baseFreq must be the integer N factor (no rounding, just truncating).
  */
  iRampComp0     = (int64_t) ((pGlobalSettings->dComp0Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampComp1     = (int64_t) ((pGlobalSettings->dComp1Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampLimitLow  = (int64_t) ((pGlobalSettings->dMinFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampLimitHigh = (int64_t) ((pGlobalSettings->dMaxFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
 8028fd0:	e9cd 0100 	strd	r0, r1, [sp]
  uSPIData[LMX249x_REG_IDX(58, 27, 80)] = (iRampLimitHigh >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 81)] = (iRampLimitHigh >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 82)] = (iRampLimitHigh >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] = ((iRampComp0    & 0x100000000) ? 1 << 0 : 0) |
    ((iRampComp1    & 0x100000000) ? 1 << 1 : 0) |
 8028fd4:	f005 0301 	and.w	r3, r5, #1
 8028fd8:	2200      	movs	r2, #0
  uSPIData[LMX249x_REG_IDX(58, 27, 79)] = (iRampLimitHigh >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 80)] = (iRampLimitHigh >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 81)] = (iRampLimitHigh >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 82)] = (iRampLimitHigh >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] = ((iRampComp0    & 0x100000000) ? 1 << 0 : 0) |
 8028fda:	ea52 0103 	orrs.w	r1, r2, r3
    ((iRampComp1    & 0x100000000) ? 1 << 1 : 0) |
      ((iRampLimitLow   & 0x100000000) ? 1 << 3 : 0) |
 8028fde:	f007 0301 	and.w	r3, r7, #1
 8028fe2:	f04f 0200 	mov.w	r2, #0
  uSPIData[LMX249x_REG_IDX(58, 27, 75)] = (iRampLimitLow >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 76)] = (iRampLimitLow >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 77)] = (iRampLimitLow >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 78)] = (iRampLimitLow >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 79)] = (iRampLimitHigh >>  0) & 0xFF;
 8028fe6:	f89d 5000 	ldrb.w	r5, [sp]
  iRampComp0     = (int64_t) ((pGlobalSettings->dComp0Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampComp1     = (int64_t) ((pGlobalSettings->dComp1Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampLimitLow  = (int64_t) ((pGlobalSettings->dMinFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampLimitHigh = (int64_t) ((pGlobalSettings->dMaxFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  
  uSPIData[LMX249x_REG_IDX(58, 27, 60)] = (iRampComp0 >>  0) & 0xFF;
 8028fea:	f88d 904a 	strb.w	r9, [sp, #74]	; 0x4a
  uSPIData[LMX249x_REG_IDX(58, 27, 79)] = (iRampLimitHigh >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 80)] = (iRampLimitHigh >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 81)] = (iRampLimitHigh >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 82)] = (iRampLimitHigh >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] = ((iRampComp0    & 0x100000000) ? 1 << 0 : 0) |
 8028fee:	bf0c      	ite	eq
 8028ff0:	4641      	moveq	r1, r8
 8028ff2:	2102      	movne	r1, #2
 8028ff4:	ea52 0e03 	orrs.w	lr, r2, r3
 8028ff8:	9107      	str	r1, [sp, #28]
  uSPIData[LMX249x_REG_IDX(58, 27, 60)] = (iRampComp0 >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 61)] = (iRampComp0 >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 62)] = (iRampComp0 >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 63)] = (iRampComp0 >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 65)] = (iRampComp1 >>  0) & 0xFF;
 8028ffa:	f88d 4045 	strb.w	r4, [sp, #69]	; 0x45
  uSPIData[LMX249x_REG_IDX(58, 27, 66)] = (iRampComp1 >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 67)] = (iRampComp1 >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 68)] = (iRampComp1 >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 75)] = (iRampLimitLow >>  0) & 0xFF;
 8028ffe:	f88d 603b 	strb.w	r6, [sp, #59]	; 0x3b
  uSPIData[LMX249x_REG_IDX(58, 27, 76)] = (iRampLimitLow >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 77)] = (iRampLimitLow >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 78)] = (iRampLimitLow >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 79)] = (iRampLimitHigh >>  0) & 0xFF;
 8029002:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
  uSPIData[LMX249x_REG_IDX(58, 27, 80)] = (iRampLimitHigh >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 81)] = (iRampLimitHigh >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 82)] = (iRampLimitHigh >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] = ((iRampComp0    & 0x100000000) ? 1 << 0 : 0) |
 8029006:	bf0c      	ite	eq
 8029008:	4645      	moveq	r5, r8
 802900a:	2508      	movne	r5, #8
  uSPIData[LMX249x_REG_IDX(58, 27, 61)] = (iRampComp0 >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 62)] = (iRampComp0 >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 63)] = (iRampComp0 >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 65)] = (iRampComp1 >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 66)] = (iRampComp1 >>  8) & 0xFF;
 802900c:	0a23      	lsrs	r3, r4, #8
  uSPIData[LMX249x_REG_IDX(58, 27, 79)] = (iRampLimitHigh >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 80)] = (iRampLimitHigh >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 81)] = (iRampLimitHigh >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 82)] = (iRampLimitHigh >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] = ((iRampComp0    & 0x100000000) ? 1 << 0 : 0) |
 802900e:	9508      	str	r5, [sp, #32]
  uSPIData[LMX249x_REG_IDX(58, 27, 62)] = (iRampComp0 >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 63)] = (iRampComp0 >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 65)] = (iRampComp1 >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 66)] = (iRampComp1 >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 67)] = (iRampComp1 >> 16) & 0xFF;
 8029010:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
 8029014:	ea4f 4c14 	mov.w	ip, r4, lsr #16
  uSPIData[LMX249x_REG_IDX(58, 27, 68)] = (iRampComp1 >> 24) & 0xFF;
 8029018:	ea4f 6e14 	mov.w	lr, r4, lsr #24
  uSPIData[LMX249x_REG_IDX(58, 27, 76)] = (iRampLimitLow >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 77)] = (iRampLimitLow >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 78)] = (iRampLimitLow >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 79)] = (iRampLimitHigh >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 80)] = (iRampLimitHigh >>  8) & 0xFF;
 802901c:	9c00      	ldr	r4, [sp, #0]
  uSPIData[LMX249x_REG_IDX(58, 27, 61)] = (iRampComp0 >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 62)] = (iRampComp0 >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 63)] = (iRampComp0 >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 65)] = (iRampComp1 >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 66)] = (iRampComp1 >>  8) & 0xFF;
 802901e:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
  uSPIData[LMX249x_REG_IDX(58, 27, 76)] = (iRampLimitLow >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 77)] = (iRampLimitLow >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 78)] = (iRampLimitLow >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 79)] = (iRampLimitHigh >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 80)] = (iRampLimitHigh >>  8) & 0xFF;
 8029022:	0a27      	lsrs	r7, r4, #8
  uSPIData[LMX249x_REG_IDX(58, 27, 82)] = (iRampLimitHigh >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] = ((iRampComp0    & 0x100000000) ? 1 << 0 : 0) |
    ((iRampComp1    & 0x100000000) ? 1 << 1 : 0) |
      ((iRampLimitLow   & 0x100000000) ? 1 << 3 : 0) |
        ((iRampLimitHigh  & 0x100000000) ? 1 << 4 : 0);
 8029024:	e9dd 4500 	ldrd	r4, r5, [sp]
  iRampComp1     = (int64_t) ((pGlobalSettings->dComp1Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampLimitLow  = (int64_t) ((pGlobalSettings->dMinFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampLimitHigh = (int64_t) ((pGlobalSettings->dMaxFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  
  uSPIData[LMX249x_REG_IDX(58, 27, 60)] = (iRampComp0 >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 61)] = (iRampComp0 >>  8) & 0xFF;
 8029028:	ea4f 2019 	mov.w	r0, r9, lsr #8
  uSPIData[LMX249x_REG_IDX(58, 27, 62)] = (iRampComp0 >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 63)] = (iRampComp0 >> 24) & 0xFF;
 802902c:	ea4f 6219 	mov.w	r2, r9, lsr #24
  iRampLimitLow  = (int64_t) ((pGlobalSettings->dMinFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampLimitHigh = (int64_t) ((pGlobalSettings->dMaxFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  
  uSPIData[LMX249x_REG_IDX(58, 27, 60)] = (iRampComp0 >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 61)] = (iRampComp0 >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 62)] = (iRampComp0 >> 16) & 0xFF;
 8029030:	ea4f 4119 	mov.w	r1, r9, lsr #16
  iRampComp1     = (int64_t) ((pGlobalSettings->dComp1Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampLimitLow  = (int64_t) ((pGlobalSettings->dMinFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampLimitHigh = (int64_t) ((pGlobalSettings->dMaxFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  
  uSPIData[LMX249x_REG_IDX(58, 27, 60)] = (iRampComp0 >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 61)] = (iRampComp0 >>  8) & 0xFF;
 8029034:	f88d 0049 	strb.w	r0, [sp, #73]	; 0x49
  uSPIData[LMX249x_REG_IDX(58, 27, 62)] = (iRampComp0 >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 63)] = (iRampComp0 >> 24) & 0xFF;
 8029038:	f88d 2047 	strb.w	r2, [sp, #71]	; 0x47
  uSPIData[LMX249x_REG_IDX(58, 27, 66)] = (iRampComp1 >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 67)] = (iRampComp1 >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 68)] = (iRampComp1 >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 75)] = (iRampLimitLow >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 76)] = (iRampLimitLow >>  8) & 0xFF;
 802903c:	0a30      	lsrs	r0, r6, #8
  uSPIData[LMX249x_REG_IDX(58, 27, 82)] = (iRampLimitHigh >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] = ((iRampComp0    & 0x100000000) ? 1 << 0 : 0) |
    ((iRampComp1    & 0x100000000) ? 1 << 1 : 0) |
      ((iRampLimitLow   & 0x100000000) ? 1 << 3 : 0) |
        ((iRampLimitHigh  & 0x100000000) ? 1 << 4 : 0);
 802903e:	f005 0301 	and.w	r3, r5, #1
  uSPIData[LMX249x_REG_IDX(58, 27, 76)] = (iRampLimitLow >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 77)] = (iRampLimitLow >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 78)] = (iRampLimitLow >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 79)] = (iRampLimitHigh >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 80)] = (iRampLimitHigh >>  8) & 0xFF;
 8029042:	f88d 7036 	strb.w	r7, [sp, #54]	; 0x36
  uSPIData[LMX249x_REG_IDX(58, 27, 82)] = (iRampLimitHigh >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] = ((iRampComp0    & 0x100000000) ? 1 << 0 : 0) |
    ((iRampComp1    & 0x100000000) ? 1 << 1 : 0) |
      ((iRampLimitLow   & 0x100000000) ? 1 << 3 : 0) |
        ((iRampLimitHigh  & 0x100000000) ? 1 << 4 : 0);
 8029046:	2200      	movs	r2, #0
  
  /* Define FSK deviation */
  iFSKDev = (int64_t) ((pGlobalSettings->dDeviationFrequency - pGlobalSettings->dBaseFrequency)
 8029048:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
  uSPIData[LMX249x_REG_IDX(58, 27, 66)] = (iRampComp1 >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 67)] = (iRampComp1 >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 68)] = (iRampComp1 >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 75)] = (iRampLimitLow >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 76)] = (iRampLimitLow >>  8) & 0xFF;
 802904a:	f88d 003a 	strb.w	r0, [sp, #58]	; 0x3a
  iRampLimitLow  = (int64_t) ((pGlobalSettings->dMinFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampLimitHigh = (int64_t) ((pGlobalSettings->dMaxFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  
  uSPIData[LMX249x_REG_IDX(58, 27, 60)] = (iRampComp0 >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 61)] = (iRampComp0 >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 62)] = (iRampComp0 >> 16) & 0xFF;
 802904e:	f88d 1048 	strb.w	r1, [sp, #72]	; 0x48
  uSPIData[LMX249x_REG_IDX(58, 27, 79)] = (iRampLimitHigh >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 80)] = (iRampLimitHigh >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 81)] = (iRampLimitHigh >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 82)] = (iRampLimitHigh >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] = ((iRampComp0    & 0x100000000) ? 1 << 0 : 0) |
 8029052:	ea52 0003 	orrs.w	r0, r2, r3
  uSPIData[LMX249x_REG_IDX(58, 27, 67)] = (iRampComp1 >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 68)] = (iRampComp1 >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 75)] = (iRampLimitLow >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 76)] = (iRampLimitLow >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 77)] = (iRampLimitLow >> 16) & 0xFF;
 8029056:	ea4f 4116 	mov.w	r1, r6, lsr #16
  uSPIData[LMX249x_REG_IDX(58, 27, 78)] = (iRampLimitLow >> 24) & 0xFF;
 802905a:	ea4f 6616 	mov.w	r6, r6, lsr #24
    ((iRampComp1    & 0x100000000) ? 1 << 1 : 0) |
      ((iRampLimitLow   & 0x100000000) ? 1 << 3 : 0) |
        ((iRampLimitHigh  & 0x100000000) ? 1 << 4 : 0);
  
  /* Define FSK deviation */
  iFSKDev = (int64_t) ((pGlobalSettings->dDeviationFrequency - pGlobalSettings->dBaseFrequency)
 802905e:	e9d7 2300 	ldrd	r2, r3, [r7]
  uSPIData[LMX249x_REG_IDX(58, 27, 67)] = (iRampComp1 >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 68)] = (iRampComp1 >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 75)] = (iRampLimitLow >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 76)] = (iRampLimitLow >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 77)] = (iRampLimitLow >> 16) & 0xFF;
 8029062:	f88d 1039 	strb.w	r1, [sp, #57]	; 0x39
  uSPIData[LMX249x_REG_IDX(58, 27, 78)] = (iRampLimitLow >> 24) & 0xFF;
 8029066:	f88d 6038 	strb.w	r6, [sp, #56]	; 0x38
    ((iRampComp1    & 0x100000000) ? 1 << 1 : 0) |
      ((iRampLimitLow   & 0x100000000) ? 1 << 3 : 0) |
        ((iRampLimitHigh  & 0x100000000) ? 1 << 4 : 0);
  
  /* Define FSK deviation */
  iFSKDev = (int64_t) ((pGlobalSettings->dDeviationFrequency - pGlobalSettings->dBaseFrequency)
 802906a:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
  uSPIData[LMX249x_REG_IDX(58, 27, 77)] = (iRampLimitLow >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 78)] = (iRampLimitLow >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 79)] = (iRampLimitHigh >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 80)] = (iRampLimitHigh >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 81)] = (iRampLimitHigh >> 16) & 0xFF;
 802906e:	ea4f 4614 	mov.w	r6, r4, lsr #16
  uSPIData[LMX249x_REG_IDX(58, 27, 82)] = (iRampLimitHigh >> 24) & 0xFF;
 8029072:	ea4f 6514 	mov.w	r5, r4, lsr #24
    ((iRampComp1    & 0x100000000) ? 1 << 1 : 0) |
      ((iRampLimitLow   & 0x100000000) ? 1 << 3 : 0) |
        ((iRampLimitHigh  & 0x100000000) ? 1 << 4 : 0);
  
  /* Define FSK deviation */
  iFSKDev = (int64_t) ((pGlobalSettings->dDeviationFrequency - pGlobalSettings->dBaseFrequency)
 8029076:	463c      	mov	r4, r7
  uSPIData[LMX249x_REG_IDX(58, 27, 79)] = (iRampLimitHigh >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 80)] = (iRampLimitHigh >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 81)] = (iRampLimitHigh >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 82)] = (iRampLimitHigh >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] = ((iRampComp0    & 0x100000000) ? 1 << 0 : 0) |
 8029078:	bf0c      	ite	eq
 802907a:	4644      	moveq	r4, r8
 802907c:	2410      	movne	r4, #16
  uSPIData[LMX249x_REG_IDX(58, 27, 62)] = (iRampComp0 >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 63)] = (iRampComp0 >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 65)] = (iRampComp1 >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 66)] = (iRampComp1 >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 67)] = (iRampComp1 >> 16) & 0xFF;
 802907e:	f88d c043 	strb.w	ip, [sp, #67]	; 0x43
  uSPIData[LMX249x_REG_IDX(58, 27, 68)] = (iRampComp1 >> 24) & 0xFF;
 8029082:	f88d e042 	strb.w	lr, [sp, #66]	; 0x42
  uSPIData[LMX249x_REG_IDX(58, 27, 79)] = (iRampLimitHigh >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 80)] = (iRampLimitHigh >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 81)] = (iRampLimitHigh >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 82)] = (iRampLimitHigh >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] = ((iRampComp0    & 0x100000000) ? 1 << 0 : 0) |
 8029086:	9400      	str	r4, [sp, #0]
  uSPIData[LMX249x_REG_IDX(58, 27, 77)] = (iRampLimitLow >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 78)] = (iRampLimitLow >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 79)] = (iRampLimitHigh >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 80)] = (iRampLimitHigh >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 81)] = (iRampLimitHigh >> 16) & 0xFF;
 8029088:	f88d 6035 	strb.w	r6, [sp, #53]	; 0x35
  uSPIData[LMX249x_REG_IDX(58, 27, 82)] = (iRampLimitHigh >> 24) & 0xFF;
 802908c:	f88d 5034 	strb.w	r5, [sp, #52]	; 0x34
    ((iRampComp1    & 0x100000000) ? 1 << 1 : 0) |
      ((iRampLimitLow   & 0x100000000) ? 1 << 3 : 0) |
        ((iRampLimitHigh  & 0x100000000) ? 1 << 4 : 0);
  
  /* Define FSK deviation */
  iFSKDev = (int64_t) ((pGlobalSettings->dDeviationFrequency - pGlobalSettings->dBaseFrequency)
 8029090:	f000 fd1c 	bl	8029acc <__aeabi_dsub>
                       * dFrequencyToNFactor * (1 << 24));
 8029094:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8029098:	f000 fecc 	bl	8029e34 <__aeabi_dmul>
 802909c:	2200      	movs	r2, #0
 802909e:	4b2e      	ldr	r3, [pc, #184]	; (8029158 <lmx249x_configure_ramps+0x434>)
 80290a0:	f000 fec8 	bl	8029e34 <__aeabi_dmul>
    ((iRampComp1    & 0x100000000) ? 1 << 1 : 0) |
      ((iRampLimitLow   & 0x100000000) ? 1 << 3 : 0) |
        ((iRampLimitHigh  & 0x100000000) ? 1 << 4 : 0);
  
  /* Define FSK deviation */
  iFSKDev = (int64_t) ((pGlobalSettings->dDeviationFrequency - pGlobalSettings->dBaseFrequency)
 80290a4:	f001 fa0e 	bl	802a4c4 <__aeabi_d2lz>
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] |= ((iFSKDev    & 0x100000000) ? 1 << 2 : 0)
    | (pGlobalSettings->eDevTrigger << 5);
  
  /* Define Ramp Trigger Sources and Modulation type */
  pThis->uReg58 = (pGlobalSettings->eRampClock) /* 0 << 1) */  | /* internal or external clock */
 80290a8:	f897 5033 	ldrb.w	r5, [r7, #51]	; 0x33
 80290ac:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
    (pGlobalSettings->eModulation) /* 0 << 2) */ | /* phase or frequency modulation */
      (pGlobalSettings->eTriggerA << 4);          /* Trigger A source */
 80290b0:	f897 2030 	ldrb.w	r2, [r7, #48]	; 0x30
  uSPIData[LMX249x_REG_IDX(58, 27, 72)] = (iFSKDev >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 73)] = (iFSKDev >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 74)] = (iFSKDev >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] |= ((iFSKDev    & 0x100000000) ? 1 << 2 : 0)
    | (pGlobalSettings->eDevTrigger << 5);
 80290b4:	f897 6039 	ldrb.w	r6, [r7, #57]	; 0x39
 80290b8:	9c08      	ldr	r4, [sp, #32]
  
  /* Define FSK deviation */
  iFSKDev = (int64_t) ((pGlobalSettings->dDeviationFrequency - pGlobalSettings->dBaseFrequency)
                       * dFrequencyToNFactor * (1 << 24));
  
  uSPIData[LMX249x_REG_IDX(58, 27, 71)] = (iFSKDev >>  0) & 0xFF;
 80290ba:	f88d 003f 	strb.w	r0, [sp, #63]	; 0x3f
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] |= ((iFSKDev    & 0x100000000) ? 1 << 2 : 0)
    | (pGlobalSettings->eDevTrigger << 5);
  
  /* Define Ramp Trigger Sources and Modulation type */
  pThis->uReg58 = (pGlobalSettings->eRampClock) /* 0 << 1) */  | /* internal or external clock */
 80290be:	432b      	orrs	r3, r5
 80290c0:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
  uSPIData[LMX249x_REG_IDX(58, 27, 79)] = (iRampLimitHigh >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 80)] = (iRampLimitHigh >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 81)] = (iRampLimitHigh >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 82)] = (iRampLimitHigh >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] = ((iRampComp0    & 0x100000000) ? 1 << 0 : 0) |
 80290c4:	f00a 0201 	and.w	r2, sl, #1
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] |= ((iFSKDev    & 0x100000000) ? 1 << 2 : 0)
    | (pGlobalSettings->eDevTrigger << 5);
  
  /* Define Ramp Trigger Sources and Modulation type */
  pThis->uReg58 = (pGlobalSettings->eRampClock) /* 0 << 1) */  | /* internal or external clock */
 80290c8:	b2db      	uxtb	r3, r3
 80290ca:	ea42 1246 	orr.w	r2, r2, r6, lsl #5
 80290ce:	9e07      	ldr	r6, [sp, #28]
 80290d0:	f88b 3010 	strb.w	r3, [fp, #16]
  
  uSPIData[LMX249x_REG_IDX(58, 27, 59)] = (pGlobalSettings->eTriggerB)   | /* Trigger B source */
    (pGlobalSettings->eTriggerC << 4);   /* Trigger C source */
  
  /* Setup ramp counter */
  uSPIData[LMX249x_REG_IDX(58, 27, 83)] = (pGlobalSettings->uNumRamps & 0xFF);
 80290d4:	8efd      	ldrh	r5, [r7, #54]	; 0x36
  pThis->uReg58 = (pGlobalSettings->eRampClock) /* 0 << 1) */  | /* internal or external clock */
    (pGlobalSettings->eModulation) /* 0 << 2) */ | /* phase or frequency modulation */
      (pGlobalSettings->eTriggerA << 4);          /* Trigger A source */
  uSPIData[LMX249x_REG_IDX(58, 27, 58)] = pThis->uReg58;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 59)] = (pGlobalSettings->eTriggerB)   | /* Trigger B source */
 80290d6:	f897 a031 	ldrb.w	sl, [r7, #49]	; 0x31
    (pGlobalSettings->eTriggerC << 4);   /* Trigger C source */
  
  /* Setup ramp counter */
  uSPIData[LMX249x_REG_IDX(58, 27, 83)] = (pGlobalSettings->uNumRamps & 0xFF);
  uSPIData[LMX249x_REG_IDX(58, 27, 84)] = ((pGlobalSettings->uNumRamps >> 8)& 0x1F)  |
    (pGlobalSettings->eAutoOff << 5)     |
 80290da:	f897 9035 	ldrb.w	r9, [r7, #53]	; 0x35
      (pGlobalSettings->eRampCountTrigger << 6);
 80290de:	f897 c038 	ldrb.w	ip, [r7, #56]	; 0x38
    (pGlobalSettings->eModulation) /* 0 << 2) */ | /* phase or frequency modulation */
      (pGlobalSettings->eTriggerA << 4);          /* Trigger A source */
  uSPIData[LMX249x_REG_IDX(58, 27, 58)] = pThis->uReg58;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 59)] = (pGlobalSettings->eTriggerB)   | /* Trigger B source */
    (pGlobalSettings->eTriggerC << 4);   /* Trigger C source */
 80290e2:	f897 e032 	ldrb.w	lr, [r7, #50]	; 0x32
  
  /* Define Ramp Trigger Sources and Modulation type */
  pThis->uReg58 = (pGlobalSettings->eRampClock) /* 0 << 1) */  | /* internal or external clock */
    (pGlobalSettings->eModulation) /* 0 << 2) */ | /* phase or frequency modulation */
      (pGlobalSettings->eTriggerA << 4);          /* Trigger A source */
  uSPIData[LMX249x_REG_IDX(58, 27, 58)] = pThis->uReg58;
 80290e6:	f88d 304c 	strb.w	r3, [sp, #76]	; 0x4c
  uSPIData[LMX249x_REG_IDX(58, 27, 71)] = (iFSKDev >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 72)] = (iFSKDev >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 73)] = (iFSKDev >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 74)] = (iFSKDev >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] |= ((iFSKDev    & 0x100000000) ? 1 << 2 : 0)
 80290ea:	f001 0701 	and.w	r7, r1, #1
 80290ee:	4332      	orrs	r2, r6
 80290f0:	2600      	movs	r6, #0
 80290f2:	4322      	orrs	r2, r4
 80290f4:	ea56 0407 	orrs.w	r4, r6, r7
 80290f8:	9c00      	ldr	r4, [sp, #0]
  uSPIData[LMX249x_REG_IDX(58, 27, 84)] = ((pGlobalSettings->uNumRamps >> 8)& 0x1F)  |
    (pGlobalSettings->eAutoOff << 5)     |
      (pGlobalSettings->eRampCountTrigger << 6);
  
  /* Send register sequence to PLL */
  uSPIData[0] = 0;
 80290fa:	f88d 8030 	strb.w	r8, [sp, #48]	; 0x30
  uSPIData[LMX249x_REG_IDX(58, 27, 59)] = (pGlobalSettings->eTriggerB)   | /* Trigger B source */
    (pGlobalSettings->eTriggerC << 4);   /* Trigger C source */
  
  /* Setup ramp counter */
  uSPIData[LMX249x_REG_IDX(58, 27, 83)] = (pGlobalSettings->uNumRamps & 0xFF);
  uSPIData[LMX249x_REG_IDX(58, 27, 84)] = ((pGlobalSettings->uNumRamps >> 8)& 0x1F)  |
 80290fe:	f3c5 2104 	ubfx	r1, r5, #8, #5
 8029102:	ea44 0402 	orr.w	r4, r4, r2
 8029106:	ea41 1949 	orr.w	r9, r1, r9, lsl #5
  uSPIData[LMX249x_REG_IDX(58, 27, 71)] = (iFSKDev >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 72)] = (iFSKDev >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 73)] = (iFSKDev >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 74)] = (iFSKDev >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] |= ((iFSKDev    & 0x100000000) ? 1 << 2 : 0)
 802910a:	bf14      	ite	ne
 802910c:	2204      	movne	r2, #4
 802910e:	4642      	moveq	r2, r8
 8029110:	4314      	orrs	r4, r2
  uSPIData[LMX249x_REG_IDX(58, 27, 59)] = (pGlobalSettings->eTriggerB)   | /* Trigger B source */
    (pGlobalSettings->eTriggerC << 4);   /* Trigger C source */
  
  /* Setup ramp counter */
  uSPIData[LMX249x_REG_IDX(58, 27, 83)] = (pGlobalSettings->uNumRamps & 0xFF);
  uSPIData[LMX249x_REG_IDX(58, 27, 84)] = ((pGlobalSettings->uNumRamps >> 8)& 0x1F)  |
 8029112:	ea49 1c8c 	orr.w	ip, r9, ip, lsl #6
  pThis->uReg58 = (pGlobalSettings->eRampClock) /* 0 << 1) */  | /* internal or external clock */
    (pGlobalSettings->eModulation) /* 0 << 2) */ | /* phase or frequency modulation */
      (pGlobalSettings->eTriggerA << 4);          /* Trigger A source */
  uSPIData[LMX249x_REG_IDX(58, 27, 58)] = pThis->uReg58;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 59)] = (pGlobalSettings->eTriggerB)   | /* Trigger B source */
 8029116:	ea4a 1e0e 	orr.w	lr, sl, lr, lsl #4
  /* Define FSK deviation */
  iFSKDev = (int64_t) ((pGlobalSettings->dDeviationFrequency - pGlobalSettings->dBaseFrequency)
                       * dFrequencyToNFactor * (1 << 24));
  
  uSPIData[LMX249x_REG_IDX(58, 27, 71)] = (iFSKDev >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 72)] = (iFSKDev >>  8) & 0xFF;
 802911a:	0a07      	lsrs	r7, r0, #8
  uSPIData[LMX249x_REG_IDX(58, 27, 73)] = (iFSKDev >> 16) & 0xFF;
 802911c:	0c06      	lsrs	r6, r0, #16
  uSPIData[LMX249x_REG_IDX(58, 27, 74)] = (iFSKDev >> 24) & 0xFF;
 802911e:	0e01      	lsrs	r1, r0, #24
    (pGlobalSettings->eAutoOff << 5)     |
      (pGlobalSettings->eRampCountTrigger << 6);
  
  /* Send register sequence to PLL */
  uSPIData[0] = 0;
  uSPIData[1] = 58 + 27 - 1;
 8029120:	2254      	movs	r2, #84	; 0x54
  pThis->sendSPI(uSPIData, 27 + 2, pThis->pDataForSendSPI);
 8029122:	a80c      	add	r0, sp, #48	; 0x30
  uSPIData[LMX249x_REG_IDX(58, 27, 59)] = (pGlobalSettings->eTriggerB)   | /* Trigger B source */
    (pGlobalSettings->eTriggerC << 4);   /* Trigger C source */
  
  /* Setup ramp counter */
  uSPIData[LMX249x_REG_IDX(58, 27, 83)] = (pGlobalSettings->uNumRamps & 0xFF);
  uSPIData[LMX249x_REG_IDX(58, 27, 84)] = ((pGlobalSettings->uNumRamps >> 8)& 0x1F)  |
 8029124:	f88d c032 	strb.w	ip, [sp, #50]	; 0x32
  pThis->uReg58 = (pGlobalSettings->eRampClock) /* 0 << 1) */  | /* internal or external clock */
    (pGlobalSettings->eModulation) /* 0 << 2) */ | /* phase or frequency modulation */
      (pGlobalSettings->eTriggerA << 4);          /* Trigger A source */
  uSPIData[LMX249x_REG_IDX(58, 27, 58)] = pThis->uReg58;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 59)] = (pGlobalSettings->eTriggerB)   | /* Trigger B source */
 8029128:	f88d e04b 	strb.w	lr, [sp, #75]	; 0x4b
  uSPIData[LMX249x_REG_IDX(58, 27, 71)] = (iFSKDev >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 72)] = (iFSKDev >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 73)] = (iFSKDev >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 74)] = (iFSKDev >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] |= ((iFSKDev    & 0x100000000) ? 1 << 2 : 0)
 802912c:	f88d 4040 	strb.w	r4, [sp, #64]	; 0x40
  
  uSPIData[LMX249x_REG_IDX(58, 27, 59)] = (pGlobalSettings->eTriggerB)   | /* Trigger B source */
    (pGlobalSettings->eTriggerC << 4);   /* Trigger C source */
  
  /* Setup ramp counter */
  uSPIData[LMX249x_REG_IDX(58, 27, 83)] = (pGlobalSettings->uNumRamps & 0xFF);
 8029130:	f88d 5033 	strb.w	r5, [sp, #51]	; 0x33
  /* Define FSK deviation */
  iFSKDev = (int64_t) ((pGlobalSettings->dDeviationFrequency - pGlobalSettings->dBaseFrequency)
                       * dFrequencyToNFactor * (1 << 24));
  
  uSPIData[LMX249x_REG_IDX(58, 27, 71)] = (iFSKDev >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 72)] = (iFSKDev >>  8) & 0xFF;
 8029134:	f88d 703e 	strb.w	r7, [sp, #62]	; 0x3e
  uSPIData[LMX249x_REG_IDX(58, 27, 73)] = (iFSKDev >> 16) & 0xFF;
 8029138:	f88d 603d 	strb.w	r6, [sp, #61]	; 0x3d
  uSPIData[LMX249x_REG_IDX(58, 27, 74)] = (iFSKDev >> 24) & 0xFF;
 802913c:	f88d 103c 	strb.w	r1, [sp, #60]	; 0x3c
    (pGlobalSettings->eAutoOff << 5)     |
      (pGlobalSettings->eRampCountTrigger << 6);
  
  /* Send register sequence to PLL */
  uSPIData[0] = 0;
  uSPIData[1] = 58 + 27 - 1;
 8029140:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
  pThis->sendSPI(uSPIData, 27 + 2, pThis->pDataForSendSPI);
 8029144:	f8db 3014 	ldr.w	r3, [fp, #20]
 8029148:	f8db 2018 	ldr.w	r2, [fp, #24]
 802914c:	211d      	movs	r1, #29
 802914e:	4798      	blx	r3
  
  return (LMX249x_ERROR_CODE_OK);
 8029150:	4640      	mov	r0, r8
}
 8029152:	b015      	add	sp, #84	; 0x54
 8029154:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029158:	41700000 	.word	0x41700000

0802915c <lmx249x_enable_ramps>:

//============================================================================

void lmx249x_enable_ramps(Lmx249x_Object_t* pThis, uint8_t bEnable)
{
 802915c:	b510      	push	{r4, lr}
 802915e:	b082      	sub	sp, #8
  uint8_t uSPIData[4];
  uSPIData[0] = 0;              /* High address byte */
 8029160:	2400      	movs	r4, #0
  uSPIData[1] = 58;             /* Low address byte */
 8029162:	223a      	movs	r2, #58	; 0x3a
  uSPIData[2] = pThis->uReg58;  /* Configuration of register 58 */
 8029164:	7c03      	ldrb	r3, [r0, #16]
//============================================================================

void lmx249x_enable_ramps(Lmx249x_Object_t* pThis, uint8_t bEnable)
{
  uint8_t uSPIData[4];
  uSPIData[0] = 0;              /* High address byte */
 8029166:	f88d 4004 	strb.w	r4, [sp, #4]
  uSPIData[1] = 58;             /* Low address byte */
 802916a:	f88d 2005 	strb.w	r2, [sp, #5]
  uSPIData[2] = pThis->uReg58;  /* Configuration of register 58 */
  
  /* enable ramps */
  if (bEnable != 0)
 802916e:	b951      	cbnz	r1, 8029186 <lmx249x_enable_ramps+0x2a>
    uSPIData[2] |= 1;
  else
    uSPIData[2] &= 0xFE;
 8029170:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 8029174:	f88d 3006 	strb.w	r3, [sp, #6]
  
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
 8029178:	6982      	ldr	r2, [r0, #24]
 802917a:	6943      	ldr	r3, [r0, #20]
 802917c:	2103      	movs	r1, #3
 802917e:	a801      	add	r0, sp, #4
 8029180:	4798      	blx	r3
}
 8029182:	b002      	add	sp, #8
 8029184:	bd10      	pop	{r4, pc}
  uSPIData[1] = 58;             /* Low address byte */
  uSPIData[2] = pThis->uReg58;  /* Configuration of register 58 */
  
  /* enable ramps */
  if (bEnable != 0)
    uSPIData[2] |= 1;
 8029186:	f043 0301 	orr.w	r3, r3, #1
 802918a:	e7f3      	b.n	8029174 <lmx249x_enable_ramps+0x18>

0802918c <lmx249x_get_real_frequency_shift>:
}

//============================================================================

double lmx249x_get_real_frequency_shift(Lmx249x_Object_t* pThis, double FreqShift_MHz, uint32_t FreqShift_time_usec)
{
 802918c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  double RealFreqShift;
  const double FracDenominator = (double)(1<<24);
  uint32_t FreqShiftSteps;
  double FreqShiftPerStep;
  
  FreqShiftSteps =  (uint32_t) (FreqShift_time_usec / pThis->dPFDCycleTime);
 8029190:	e9d0 4502 	ldrd	r4, r5, [r0, #8]
}

//============================================================================

double lmx249x_get_real_frequency_shift(Lmx249x_Object_t* pThis, double FreqShift_MHz, uint32_t FreqShift_time_usec)
{
 8029194:	4601      	mov	r1, r0
  double RealFreqShift;
  const double FracDenominator = (double)(1<<24);
  uint32_t FreqShiftSteps;
  double FreqShiftPerStep;
  
  FreqShiftSteps =  (uint32_t) (FreqShift_time_usec / pThis->dPFDCycleTime);
 8029196:	980a      	ldr	r0, [sp, #40]	; 0x28
  
  FreqShiftPerStep = (FreqShift_MHz * pThis->dExternalDivideFactor) / FreqShiftSteps;
 8029198:	e9d1 6700 	ldrd	r6, r7, [r1]
}

//============================================================================

double lmx249x_get_real_frequency_shift(Lmx249x_Object_t* pThis, double FreqShift_MHz, uint32_t FreqShift_time_usec)
{
 802919c:	4692      	mov	sl, r2
 802919e:	469b      	mov	fp, r3
  double RealFreqShift;
  const double FracDenominator = (double)(1<<24);
  uint32_t FreqShiftSteps;
  double FreqShiftPerStep;
  
  FreqShiftSteps =  (uint32_t) (FreqShift_time_usec / pThis->dPFDCycleTime);
 80291a0:	f000 fdd2 	bl	8029d48 <__aeabi_ui2d>
 80291a4:	4622      	mov	r2, r4
 80291a6:	462b      	mov	r3, r5
 80291a8:	f000 ff6e 	bl	802a088 <__aeabi_ddiv>
 80291ac:	f001 f904 	bl	802a3b8 <__aeabi_d2uiz>
  
  FreqShiftPerStep = (FreqShift_MHz * pThis->dExternalDivideFactor) / FreqShiftSteps;
 80291b0:	f000 fdca 	bl	8029d48 <__aeabi_ui2d>
 80291b4:	4652      	mov	r2, sl
 80291b6:	4680      	mov	r8, r0
 80291b8:	4689      	mov	r9, r1
 80291ba:	465b      	mov	r3, fp
 80291bc:	4630      	mov	r0, r6
 80291be:	4639      	mov	r1, r7
 80291c0:	f000 fe38 	bl	8029e34 <__aeabi_dmul>
 80291c4:	4642      	mov	r2, r8
 80291c6:	464b      	mov	r3, r9
 80291c8:	f000 ff5e 	bl	802a088 <__aeabi_ddiv>
  
  FreqShiftPerStep = ((uint32_t)((FreqShiftPerStep * FracDenominator) * pThis->dPFDCycleTime) ) / FracDenominator / pThis->dPFDCycleTime;
 80291cc:	2200      	movs	r2, #0
 80291ce:	4b10      	ldr	r3, [pc, #64]	; (8029210 <lmx249x_get_real_frequency_shift+0x84>)
 80291d0:	f000 fe30 	bl	8029e34 <__aeabi_dmul>
 80291d4:	4602      	mov	r2, r0
 80291d6:	460b      	mov	r3, r1
 80291d8:	4620      	mov	r0, r4
 80291da:	4629      	mov	r1, r5
 80291dc:	f000 fe2a 	bl	8029e34 <__aeabi_dmul>
 80291e0:	f001 f8ea 	bl	802a3b8 <__aeabi_d2uiz>
 80291e4:	f000 fdb0 	bl	8029d48 <__aeabi_ui2d>
 80291e8:	2200      	movs	r2, #0
 80291ea:	4b0a      	ldr	r3, [pc, #40]	; (8029214 <lmx249x_get_real_frequency_shift+0x88>)
 80291ec:	f000 fe22 	bl	8029e34 <__aeabi_dmul>
 80291f0:	4622      	mov	r2, r4
 80291f2:	462b      	mov	r3, r5
 80291f4:	f000 ff48 	bl	802a088 <__aeabi_ddiv>
 80291f8:	4602      	mov	r2, r0
 80291fa:	460b      	mov	r3, r1
  
  RealFreqShift = FreqShiftPerStep * FreqShiftSteps /  pThis->dExternalDivideFactor;
 80291fc:	4640      	mov	r0, r8
 80291fe:	4649      	mov	r1, r9
 8029200:	f000 fe18 	bl	8029e34 <__aeabi_dmul>
 8029204:	4632      	mov	r2, r6
 8029206:	463b      	mov	r3, r7
 8029208:	f000 ff3e 	bl	802a088 <__aeabi_ddiv>
  
  return (RealFreqShift);
}
 802920c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029210:	41700000 	.word	0x41700000
 8029214:	3e700000 	.word	0x3e700000

08029218 <lmx249x_trigger_ramp>:

//============================================================================

void lmx249x_trigger_ramp(void)
{
 8029218:	4b07      	ldr	r3, [pc, #28]	; (8029238 <lmx249x_trigger_ramp+0x20>)
 802921a:	7c18      	ldrb	r0, [r3, #16]
 802921c:	6819      	ldr	r1, [r3, #0]
 802921e:	2201      	movs	r2, #1
 8029220:	4082      	lsls	r2, r0

__STATIC_INLINE uint32_t XMC_GPIO_GetInput(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_GetInput: Invalid port", XMC_GPIO_CHECK_PORT(port));

  return (((port->IN) >> pin) & 0x1U);
 8029222:	6a4b      	ldr	r3, [r1, #36]	; 0x24
  /* Wait until PLL is ready to generate the next chirp */
  while (DIGITAL_IO_GetInput(&DIGITAL_IO_PLL_MOD) != 0);
 8029224:	421a      	tst	r2, r3
 8029226:	d1fc      	bne.n	8029222 <lmx249x_trigger_ramp+0xa>
 8029228:	4b04      	ldr	r3, [pc, #16]	; (802923c <lmx249x_trigger_ramp+0x24>)

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 802922a:	7c19      	ldrb	r1, [r3, #16]
 802922c:	681a      	ldr	r2, [r3, #0]
 802922e:	2301      	movs	r3, #1
 8029230:	408b      	lsls	r3, r1
 8029232:	6053      	str	r3, [r2, #4]
 8029234:	4770      	bx	lr
 8029236:	bf00      	nop
 8029238:	0802af70 	.word	0x0802af70
 802923c:	0802af5c 	.word	0x0802af5c

08029240 <lmx249x_release_ramp_trigger>:
}

//============================================================================

void lmx249x_release_ramp_trigger(void)
{
 8029240:	4b03      	ldr	r3, [pc, #12]	; (8029250 <lmx249x_release_ramp_trigger+0x10>)

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 8029242:	7c19      	ldrb	r1, [r3, #16]
 8029244:	681a      	ldr	r2, [r3, #0]
 8029246:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 802924a:	408b      	lsls	r3, r1
 802924c:	6053      	str	r3, [r2, #4]
 802924e:	4770      	bx	lr
 8029250:	0802af5c 	.word	0x0802af5c

08029254 <lmx249x_power_up>:
}

//============================================================================

void lmx249x_power_up(void)
{
 8029254:	4b03      	ldr	r3, [pc, #12]	; (8029264 <lmx249x_power_up+0x10>)

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 8029256:	7c19      	ldrb	r1, [r3, #16]
 8029258:	681a      	ldr	r2, [r3, #0]
 802925a:	2301      	movs	r3, #1
 802925c:	408b      	lsls	r3, r1
 802925e:	6053      	str	r3, [r2, #4]
 8029260:	4770      	bx	lr
 8029262:	bf00      	nop
 8029264:	0802aef8 	.word	0x0802aef8

08029268 <lmx249x_power_down>:
}

//============================================================================

void lmx249x_power_down(void)
{
 8029268:	4b03      	ldr	r3, [pc, #12]	; (8029278 <lmx249x_power_down+0x10>)

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 802926a:	7c19      	ldrb	r1, [r3, #16]
 802926c:	681a      	ldr	r2, [r3, #0]
 802926e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8029272:	408b      	lsls	r3, r1
 8029274:	6053      	str	r3, [r2, #4]
 8029276:	4770      	bx	lr
 8029278:	0802aef8 	.word	0x0802aef8

0802927c <bgt24mtr1x_init>:
void bgt24mtr1x_init(Bgt24mtr1x_LNAgain_t lna_gain, Bgt24mtr1x_Power_t power_level)
{
  bgt24mtr1x_global_config = BGT24MTR1X_BASE_CONF;
  
  /* Set the digital IOs used by SPI interface */
  bgt24mtr1x_spi_pins.spi_device    = BGT_DEVICE;
 802927c:	4a36      	ldr	r2, [pc, #216]	; (8029358 <bgt24mtr1x_init+0xdc>)
==============================================================================
 */

void bgt24mtr1x_init(Bgt24mtr1x_LNAgain_t lna_gain, Bgt24mtr1x_Power_t power_level)
{
  bgt24mtr1x_global_config = BGT24MTR1X_BASE_CONF;
 802927e:	4b37      	ldr	r3, [pc, #220]	; (802935c <bgt24mtr1x_init+0xe0>)
   3. EXPORTED FUNCTIONS
==============================================================================
 */

void bgt24mtr1x_init(Bgt24mtr1x_LNAgain_t lna_gain, Bgt24mtr1x_Power_t power_level)
{
 8029280:	b4f0      	push	{r4, r5, r6, r7}
  bgt24mtr1x_global_config = BGT24MTR1X_BASE_CONF;
  
  /* Set the digital IOs used by SPI interface */
  bgt24mtr1x_spi_pins.spi_device    = BGT_DEVICE;
  bgt24mtr1x_spi_pins.gpio_cs_pin 	= (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_BGT24;
 8029282:	4e37      	ldr	r6, [pc, #220]	; (8029360 <bgt24mtr1x_init+0xe4>)
 8029284:	6056      	str	r6, [r2, #4]
==============================================================================
 */

void bgt24mtr1x_init(Bgt24mtr1x_LNAgain_t lna_gain, Bgt24mtr1x_Power_t power_level)
{
  bgt24mtr1x_global_config = BGT24MTR1X_BASE_CONF;
 8029286:	f241 0748 	movw	r7, #4168	; 0x1048
  
  /* Set the digital IOs used by SPI interface */
  bgt24mtr1x_spi_pins.spi_device    = BGT_DEVICE;
  bgt24mtr1x_spi_pins.gpio_cs_pin 	= (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_BGT24;
  bgt24mtr1x_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_DATA;
 802928a:	4d36      	ldr	r5, [pc, #216]	; (8029364 <bgt24mtr1x_init+0xe8>)
  bgt24mtr1x_spi_pins.gpio_clk_pin 	= (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;
 802928c:	4c36      	ldr	r4, [pc, #216]	; (8029368 <bgt24mtr1x_init+0xec>)
==============================================================================
 */

void bgt24mtr1x_init(Bgt24mtr1x_LNAgain_t lna_gain, Bgt24mtr1x_Power_t power_level)
{
  bgt24mtr1x_global_config = BGT24MTR1X_BASE_CONF;
 802928e:	801f      	strh	r7, [r3, #0]
  
  /* Set the digital IOs used by SPI interface */
  bgt24mtr1x_spi_pins.spi_device    = BGT_DEVICE;
 8029290:	2600      	movs	r6, #0
 8029292:	7016      	strb	r6, [r2, #0]
  bgt24mtr1x_spi_pins.gpio_cs_pin 	= (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_BGT24;
  bgt24mtr1x_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_DATA;
 8029294:	6095      	str	r5, [r2, #8]
  bgt24mtr1x_spi_pins.gpio_clk_pin 	= (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;
 8029296:	60d4      	str	r4, [r2, #12]
  
  if (lna_gain)
  {
    bgt24mtr1x_global_config &= BGT24MTR1X_ENA_LNA_MASK;
 8029298:	881a      	ldrh	r2, [r3, #0]
  bgt24mtr1x_spi_pins.spi_device    = BGT_DEVICE;
  bgt24mtr1x_spi_pins.gpio_cs_pin 	= (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_BGT24;
  bgt24mtr1x_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_DATA;
  bgt24mtr1x_spi_pins.gpio_clk_pin 	= (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;
  
  if (lna_gain)
 802929a:	b998      	cbnz	r0, 80292c4 <bgt24mtr1x_init+0x48>
  {
    bgt24mtr1x_global_config &= BGT24MTR1X_ENA_LNA_MASK;
  }
  else
  {
    bgt24mtr1x_global_config |= BGT24MTR1X_DIS_LNA_MASK;
 802929c:	ea6f 4242 	mvn.w	r2, r2, lsl #17
 80292a0:	ea6f 4252 	mvn.w	r2, r2, lsr #17
 80292a4:	b292      	uxth	r2, r2
 80292a6:	801a      	strh	r2, [r3, #0]
//============================================================================

void bgt24mtr1x_set_tx_power(Bgt24mtr1x_Power_t power_level)
{
  /* Clear the last 3-bits */
  bgt24mtr1x_global_config &= 0xFFF8;
 80292a8:	881a      	ldrh	r2, [r3, #0]
 80292aa:	f022 0207 	bic.w	r2, r2, #7
 80292ae:	0412      	lsls	r2, r2, #16
 80292b0:	0c12      	lsrs	r2, r2, #16
 80292b2:	801a      	strh	r2, [r3, #0]
  
  switch (power_level)
 80292b4:	2906      	cmp	r1, #6
 80292b6:	d84a      	bhi.n	802934e <bgt24mtr1x_init+0xd2>
 80292b8:	e8df f001 	tbb	[pc, r1]
 80292bc:	37312b25 	.word	0x37312b25
 80292c0:	433d      	.short	0x433d
 80292c2:	08          	.byte	0x08
 80292c3:	00          	.byte	0x00
  bgt24mtr1x_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_DATA;
  bgt24mtr1x_spi_pins.gpio_clk_pin 	= (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;
  
  if (lna_gain)
  {
    bgt24mtr1x_global_config &= BGT24MTR1X_ENA_LNA_MASK;
 80292c4:	f3c2 020e 	ubfx	r2, r2, #0, #15
 80292c8:	801a      	strh	r2, [r3, #0]
 80292ca:	e7ed      	b.n	80292a8 <bgt24mtr1x_init+0x2c>
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_2;
    break;
    
  case BGT24MTR1X_TX_LEVEL_6:
    /* Reduction by 0.4dBm */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_1;
 80292cc:	881a      	ldrh	r2, [r3, #0]
 80292ce:	b292      	uxth	r2, r2
 80292d0:	f042 0201 	orr.w	r2, r2, #1
 80292d4:	801a      	strh	r2, [r3, #0]

//============================================================================

void bgt24mtr1x_ana_vout_tx(void)
{
  bgt24mtr1x_ana_command = BGT24MTR1X_ANA_CMD_TX_POWER;
 80292d6:	4925      	ldr	r1, [pc, #148]	; (802936c <bgt24mtr1x_init+0xf0>)
 80292d8:	2201      	movs	r2, #1
 80292da:	800a      	strh	r2, [r1, #0]
  
  bgt24mtr1x_global_config &= BGT24MTR1X_AMUX_VOUT_TX;
 80292dc:	881a      	ldrh	r2, [r3, #0]
 80292de:	f422 5206 	bic.w	r2, r2, #8576	; 0x2180
 80292e2:	0412      	lsls	r2, r2, #16
 80292e4:	0c12      	lsrs	r2, r2, #16

//============================================================================

void bgt24mtr1x_ana_vref_tx(void)
{
  bgt24mtr1x_ana_command = BGT24MTR1X_ANA_CMD_TX_POWER_REF;
 80292e6:	2002      	movs	r0, #2

void bgt24mtr1x_ana_vout_tx(void)
{
  bgt24mtr1x_ana_command = BGT24MTR1X_ANA_CMD_TX_POWER;
  
  bgt24mtr1x_global_config &= BGT24MTR1X_AMUX_VOUT_TX;
 80292e8:	801a      	strh	r2, [r3, #0]

//============================================================================

void bgt24mtr1x_ana_vref_tx(void)
{
  bgt24mtr1x_ana_command = BGT24MTR1X_ANA_CMD_TX_POWER_REF;
 80292ea:	8008      	strh	r0, [r1, #0]
  
  bgt24mtr1x_global_config &= BGT24MTR1X_AMUX_VOUT_TX;
 80292ec:	881a      	ldrh	r2, [r3, #0]
 80292ee:	f422 5206 	bic.w	r2, r2, #8576	; 0x2180
 80292f2:	0412      	lsls	r2, r2, #16
 80292f4:	0c12      	lsrs	r2, r2, #16
 80292f6:	801a      	strh	r2, [r3, #0]
  
  bgt24mtr1x_global_config |= BGT24MTR1X_AMUX_0;
 80292f8:	881a      	ldrh	r2, [r3, #0]
 80292fa:	b292      	uxth	r2, r2
 80292fc:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8029300:	801a      	strh	r2, [r3, #0]
  
  /* Configure BGT24MTR1x */
  bgt24mtr1x_set_tx_power(power_level);
  
  bgt24mtr1x_ana_vref_tx();
}
 8029302:	bcf0      	pop	{r4, r5, r6, r7}
 8029304:	4770      	bx	lr
  
  switch (power_level)
  {
  case BGT24MTR1X_TX_MIN:
    /* Reduction by 9dBm */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_7;
 8029306:	881a      	ldrh	r2, [r3, #0]
 8029308:	b292      	uxth	r2, r2
 802930a:	f042 0207 	orr.w	r2, r2, #7
 802930e:	801a      	strh	r2, [r3, #0]
 8029310:	e7e1      	b.n	80292d6 <bgt24mtr1x_init+0x5a>
    break;
    
  case BGT24MTR1X_TX_LEVEL_1:
    /* Reduction by 6dBm */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_6;
 8029312:	881a      	ldrh	r2, [r3, #0]
 8029314:	b292      	uxth	r2, r2
 8029316:	f042 0206 	orr.w	r2, r2, #6
 802931a:	801a      	strh	r2, [r3, #0]
 802931c:	e7db      	b.n	80292d6 <bgt24mtr1x_init+0x5a>
    break;
    
  case BGT24MTR1X_TX_LEVEL_2:
    /* Reduction by 4dBm */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_5;
 802931e:	881a      	ldrh	r2, [r3, #0]
 8029320:	b292      	uxth	r2, r2
 8029322:	f042 0205 	orr.w	r2, r2, #5
 8029326:	801a      	strh	r2, [r3, #0]
 8029328:	e7d5      	b.n	80292d6 <bgt24mtr1x_init+0x5a>
    break;
    
  case BGT24MTR1X_TX_MID:
    /* Reduction by 2.5dBm */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_4;
 802932a:	881a      	ldrh	r2, [r3, #0]
 802932c:	b292      	uxth	r2, r2
 802932e:	f042 0204 	orr.w	r2, r2, #4
 8029332:	801a      	strh	r2, [r3, #0]
 8029334:	e7cf      	b.n	80292d6 <bgt24mtr1x_init+0x5a>
    break;
    
  case BGT24MTR1X_TX_LEVEL_4:
    /* Reduction by 1.4dBm */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_3;
 8029336:	881a      	ldrh	r2, [r3, #0]
 8029338:	b292      	uxth	r2, r2
 802933a:	f042 0203 	orr.w	r2, r2, #3
 802933e:	801a      	strh	r2, [r3, #0]
 8029340:	e7c9      	b.n	80292d6 <bgt24mtr1x_init+0x5a>
    break;
    
  case BGT24MTR1X_TX_LEVEL_5:
    /* Reduction by 0.8dBm */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_2;
 8029342:	881a      	ldrh	r2, [r3, #0]
 8029344:	b292      	uxth	r2, r2
 8029346:	f042 0202 	orr.w	r2, r2, #2
 802934a:	801a      	strh	r2, [r3, #0]
 802934c:	e7c3      	b.n	80292d6 <bgt24mtr1x_init+0x5a>
    break;
    
  case BGT24MTR1X_TX_MAX:
  default:
    /* TX on with maximum power */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_0;
 802934e:	881a      	ldrh	r2, [r3, #0]
 8029350:	b292      	uxth	r2, r2
 8029352:	801a      	strh	r2, [r3, #0]
 8029354:	e7bf      	b.n	80292d6 <bgt24mtr1x_init+0x5a>
 8029356:	bf00      	nop
 8029358:	1fff201c 	.word	0x1fff201c
 802935c:	1ffe8b66 	.word	0x1ffe8b66
 8029360:	0802afac 	.word	0x0802afac
 8029364:	0802afe8 	.word	0x0802afe8
 8029368:	0802af20 	.word	0x0802af20
 802936c:	1ffe8b68 	.word	0x1ffe8b68

08029370 <bgt24mtr1x_start_tx>:

//============================================================================

void bgt24mtr1x_start_tx(void)
{
  bgt24mtr1x_global_config &= BGT24MTR1X_ENA_PA_MASK;
 8029370:	490b      	ldr	r1, [pc, #44]	; (80293a0 <bgt24mtr1x_start_tx+0x30>)
  
  /* Upper byte goes to lower byte position */
  shuffled_data |= (config_val >> 8);
  
  /* Transmit configuration data to BGT24MTR1x through SPI protocol */
  spi_transmit_data((uint8_t *)&shuffled_data , 2U, (void*) &bgt24mtr1x_spi_pins);
 8029372:	4a0c      	ldr	r2, [pc, #48]	; (80293a4 <bgt24mtr1x_start_tx+0x34>)

//============================================================================

void bgt24mtr1x_start_tx(void)
{
  bgt24mtr1x_global_config &= BGT24MTR1X_ENA_PA_MASK;
 8029374:	880b      	ldrh	r3, [r1, #0]
 8029376:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
}

//============================================================================

void bgt24mtr1x_start_tx(void)
{
 802937a:	b500      	push	{lr}
  bgt24mtr1x_global_config &= BGT24MTR1X_ENA_PA_MASK;
 802937c:	041b      	lsls	r3, r3, #16
 802937e:	0c1b      	lsrs	r3, r3, #16
 8029380:	800b      	strh	r3, [r1, #0]
  bgt24mtr1x_set_config(bgt24mtr1x_global_config);
 8029382:	880b      	ldrh	r3, [r1, #0]
}

//============================================================================

void bgt24mtr1x_start_tx(void)
{
 8029384:	b083      	sub	sp, #12
  bgt24mtr1x_global_config &= BGT24MTR1X_ENA_PA_MASK;
  bgt24mtr1x_set_config(bgt24mtr1x_global_config);
 8029386:	b29b      	uxth	r3, r3
  
  /* Lower byte goes to upper byte position */
  shuffled_data  = (config_val << 8);
  
  /* Upper byte goes to lower byte position */
  shuffled_data |= (config_val >> 8);
 8029388:	a802      	add	r0, sp, #8
 802938a:	0a19      	lsrs	r1, r3, #8
 802938c:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
 8029390:	f820 3d02 	strh.w	r3, [r0, #-2]!
  
  /* Transmit configuration data to BGT24MTR1x through SPI protocol */
  spi_transmit_data((uint8_t *)&shuffled_data , 2U, (void*) &bgt24mtr1x_spi_pins);
 8029394:	2102      	movs	r1, #2
 8029396:	f7ff faa5 	bl	80288e4 <spi_transmit_data>

void bgt24mtr1x_start_tx(void)
{
  bgt24mtr1x_global_config &= BGT24MTR1X_ENA_PA_MASK;
  bgt24mtr1x_set_config(bgt24mtr1x_global_config);
}
 802939a:	b003      	add	sp, #12
 802939c:	f85d fb04 	ldr.w	pc, [sp], #4
 80293a0:	1ffe8b66 	.word	0x1ffe8b66
 80293a4:	1fff201c 	.word	0x1fff201c

080293a8 <bgt24mtr1x_stop_tx>:

//============================================================================

void bgt24mtr1x_stop_tx(void)
{
  bgt24mtr1x_global_config |= BGT24MTR1X_DIS_PA_MASK;
 80293a8:	490b      	ldr	r1, [pc, #44]	; (80293d8 <bgt24mtr1x_stop_tx+0x30>)
  
  /* Upper byte goes to lower byte position */
  shuffled_data |= (config_val >> 8);
  
  /* Transmit configuration data to BGT24MTR1x through SPI protocol */
  spi_transmit_data((uint8_t *)&shuffled_data , 2U, (void*) &bgt24mtr1x_spi_pins);
 80293aa:	4a0c      	ldr	r2, [pc, #48]	; (80293dc <bgt24mtr1x_stop_tx+0x34>)

//============================================================================

void bgt24mtr1x_stop_tx(void)
{
  bgt24mtr1x_global_config |= BGT24MTR1X_DIS_PA_MASK;
 80293ac:	880b      	ldrh	r3, [r1, #0]
}

//============================================================================

void bgt24mtr1x_stop_tx(void)
{
 80293ae:	b500      	push	{lr}
  bgt24mtr1x_global_config |= BGT24MTR1X_DIS_PA_MASK;
 80293b0:	b29b      	uxth	r3, r3
 80293b2:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 80293b6:	800b      	strh	r3, [r1, #0]
  bgt24mtr1x_set_config(bgt24mtr1x_global_config);
 80293b8:	880b      	ldrh	r3, [r1, #0]
}

//============================================================================

void bgt24mtr1x_stop_tx(void)
{
 80293ba:	b083      	sub	sp, #12
  bgt24mtr1x_global_config |= BGT24MTR1X_DIS_PA_MASK;
  bgt24mtr1x_set_config(bgt24mtr1x_global_config);
 80293bc:	b29b      	uxth	r3, r3
  
  /* Lower byte goes to upper byte position */
  shuffled_data  = (config_val << 8);
  
  /* Upper byte goes to lower byte position */
  shuffled_data |= (config_val >> 8);
 80293be:	a802      	add	r0, sp, #8
 80293c0:	0a19      	lsrs	r1, r3, #8
 80293c2:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
 80293c6:	f820 3d02 	strh.w	r3, [r0, #-2]!
  
  /* Transmit configuration data to BGT24MTR1x through SPI protocol */
  spi_transmit_data((uint8_t *)&shuffled_data , 2U, (void*) &bgt24mtr1x_spi_pins);
 80293ca:	2102      	movs	r1, #2
 80293cc:	f7ff fa8a 	bl	80288e4 <spi_transmit_data>

void bgt24mtr1x_stop_tx(void)
{
  bgt24mtr1x_global_config |= BGT24MTR1X_DIS_PA_MASK;
  bgt24mtr1x_set_config(bgt24mtr1x_global_config);
}
 80293d0:	b003      	add	sp, #12
 80293d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80293d6:	bf00      	nop
 80293d8:	1ffe8b66 	.word	0x1ffe8b66
 80293dc:	1fff201c 	.word	0x1fff201c

080293e0 <bgt24mtr1x_set_tx_power>:
//============================================================================

void bgt24mtr1x_set_tx_power(Bgt24mtr1x_Power_t power_level)
{
  /* Clear the last 3-bits */
  bgt24mtr1x_global_config &= 0xFFF8;
 80293e0:	4a22      	ldr	r2, [pc, #136]	; (802946c <bgt24mtr1x_set_tx_power+0x8c>)
 80293e2:	8813      	ldrh	r3, [r2, #0]
 80293e4:	f023 0307 	bic.w	r3, r3, #7
 80293e8:	041b      	lsls	r3, r3, #16
 80293ea:	0c1b      	lsrs	r3, r3, #16
 80293ec:	8013      	strh	r3, [r2, #0]
  
  switch (power_level)
 80293ee:	2806      	cmp	r0, #6
 80293f0:	d838      	bhi.n	8029464 <bgt24mtr1x_set_tx_power+0x84>
 80293f2:	e8df f000 	tbb	[pc, r0]
 80293f6:	1913      	.short	0x1913
 80293f8:	312b251f 	.word	0x312b251f
 80293fc:	04          	.byte	0x04
 80293fd:	00          	.byte	0x00
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_2;
    break;
    
  case BGT24MTR1X_TX_LEVEL_6:
    /* Reduction by 0.4dBm */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_1;
 80293fe:	8813      	ldrh	r3, [r2, #0]
 8029400:	b29b      	uxth	r3, r3
 8029402:	f043 0301 	orr.w	r3, r3, #1
 8029406:	8013      	strh	r3, [r2, #0]

//============================================================================

void bgt24mtr1x_ana_vout_tx(void)
{
  bgt24mtr1x_ana_command = BGT24MTR1X_ANA_CMD_TX_POWER;
 8029408:	4b19      	ldr	r3, [pc, #100]	; (8029470 <bgt24mtr1x_set_tx_power+0x90>)
 802940a:	2101      	movs	r1, #1
 802940c:	8019      	strh	r1, [r3, #0]
  
  bgt24mtr1x_global_config &= BGT24MTR1X_AMUX_VOUT_TX;
 802940e:	8813      	ldrh	r3, [r2, #0]
 8029410:	f423 5306 	bic.w	r3, r3, #8576	; 0x2180
 8029414:	041b      	lsls	r3, r3, #16
 8029416:	0c1b      	lsrs	r3, r3, #16
 8029418:	8013      	strh	r3, [r2, #0]
 802941a:	4770      	bx	lr
  
  switch (power_level)
  {
  case BGT24MTR1X_TX_MIN:
    /* Reduction by 9dBm */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_7;
 802941c:	8813      	ldrh	r3, [r2, #0]
 802941e:	b29b      	uxth	r3, r3
 8029420:	f043 0307 	orr.w	r3, r3, #7
 8029424:	8013      	strh	r3, [r2, #0]
    break;
 8029426:	e7ef      	b.n	8029408 <bgt24mtr1x_set_tx_power+0x28>
    
  case BGT24MTR1X_TX_LEVEL_1:
    /* Reduction by 6dBm */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_6;
 8029428:	8813      	ldrh	r3, [r2, #0]
 802942a:	b29b      	uxth	r3, r3
 802942c:	f043 0306 	orr.w	r3, r3, #6
 8029430:	8013      	strh	r3, [r2, #0]
    break;
 8029432:	e7e9      	b.n	8029408 <bgt24mtr1x_set_tx_power+0x28>
    
  case BGT24MTR1X_TX_LEVEL_2:
    /* Reduction by 4dBm */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_5;
 8029434:	8813      	ldrh	r3, [r2, #0]
 8029436:	b29b      	uxth	r3, r3
 8029438:	f043 0305 	orr.w	r3, r3, #5
 802943c:	8013      	strh	r3, [r2, #0]
    break;
 802943e:	e7e3      	b.n	8029408 <bgt24mtr1x_set_tx_power+0x28>
    
  case BGT24MTR1X_TX_MID:
    /* Reduction by 2.5dBm */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_4;
 8029440:	8813      	ldrh	r3, [r2, #0]
 8029442:	b29b      	uxth	r3, r3
 8029444:	f043 0304 	orr.w	r3, r3, #4
 8029448:	8013      	strh	r3, [r2, #0]
    break;
 802944a:	e7dd      	b.n	8029408 <bgt24mtr1x_set_tx_power+0x28>
    
  case BGT24MTR1X_TX_LEVEL_4:
    /* Reduction by 1.4dBm */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_3;
 802944c:	8813      	ldrh	r3, [r2, #0]
 802944e:	b29b      	uxth	r3, r3
 8029450:	f043 0303 	orr.w	r3, r3, #3
 8029454:	8013      	strh	r3, [r2, #0]
    break;
 8029456:	e7d7      	b.n	8029408 <bgt24mtr1x_set_tx_power+0x28>
    
  case BGT24MTR1X_TX_LEVEL_5:
    /* Reduction by 0.8dBm */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_2;
 8029458:	8813      	ldrh	r3, [r2, #0]
 802945a:	b29b      	uxth	r3, r3
 802945c:	f043 0302 	orr.w	r3, r3, #2
 8029460:	8013      	strh	r3, [r2, #0]
    break;
 8029462:	e7d1      	b.n	8029408 <bgt24mtr1x_set_tx_power+0x28>
    break;
    
  case BGT24MTR1X_TX_MAX:
  default:
    /* TX on with maximum power */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_0;
 8029464:	8813      	ldrh	r3, [r2, #0]
 8029466:	b29b      	uxth	r3, r3
 8029468:	8013      	strh	r3, [r2, #0]
 802946a:	e7cd      	b.n	8029408 <bgt24mtr1x_set_tx_power+0x28>
 802946c:	1ffe8b66 	.word	0x1ffe8b66
 8029470:	1ffe8b68 	.word	0x1ffe8b68

08029474 <bgt24mtr1x_lna_gain_enable>:

//============================================================================

void bgt24mtr1x_lna_gain_enable(void)
{
  bgt24mtr1x_global_config &= BGT24MTR1X_ENA_LNA_MASK;
 8029474:	4a02      	ldr	r2, [pc, #8]	; (8029480 <bgt24mtr1x_lna_gain_enable+0xc>)
 8029476:	8813      	ldrh	r3, [r2, #0]
 8029478:	f3c3 030e 	ubfx	r3, r3, #0, #15
 802947c:	8013      	strh	r3, [r2, #0]
 802947e:	4770      	bx	lr
 8029480:	1ffe8b66 	.word	0x1ffe8b66

08029484 <bgt24mtr1x_lna_gain_disable>:

//============================================================================

void bgt24mtr1x_lna_gain_disable(void)
{
  bgt24mtr1x_global_config |= BGT24MTR1X_DIS_LNA_MASK;
 8029484:	4a04      	ldr	r2, [pc, #16]	; (8029498 <bgt24mtr1x_lna_gain_disable+0x14>)
 8029486:	8813      	ldrh	r3, [r2, #0]
 8029488:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 802948c:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8029490:	b29b      	uxth	r3, r3
 8029492:	8013      	strh	r3, [r2, #0]
 8029494:	4770      	bx	lr
 8029496:	bf00      	nop
 8029498:	1ffe8b66 	.word	0x1ffe8b66

0802949c <bgt24mtr1x_set_config>:
}

//============================================================================

void bgt24mtr1x_set_config(uint16_t config_val)
{
 802949c:	b500      	push	{lr}
 802949e:	b083      	sub	sp, #12
  
  /* Lower byte goes to upper byte position */
  shuffled_data  = (config_val << 8);
  
  /* Upper byte goes to lower byte position */
  shuffled_data |= (config_val >> 8);
 80294a0:	ab02      	add	r3, sp, #8
 80294a2:	0a02      	lsrs	r2, r0, #8
 80294a4:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
 80294a8:	f823 0d02 	strh.w	r0, [r3, #-2]!
  
  /* Transmit configuration data to BGT24MTR1x through SPI protocol */
  spi_transmit_data((uint8_t *)&shuffled_data , 2U, (void*) &bgt24mtr1x_spi_pins);
 80294ac:	2102      	movs	r1, #2
 80294ae:	4618      	mov	r0, r3
 80294b0:	4a02      	ldr	r2, [pc, #8]	; (80294bc <bgt24mtr1x_set_config+0x20>)
 80294b2:	f7ff fa17 	bl	80288e4 <spi_transmit_data>
}
 80294b6:	b003      	add	sp, #12
 80294b8:	f85d fb04 	ldr.w	pc, [sp], #4
 80294bc:	1fff201c 	.word	0x1fff201c

080294c0 <bgt24mtr1x_ana_temp>:

//============================================================================

void bgt24mtr1x_ana_temp(void)
{
  bgt24mtr1x_ana_command = BGT24MTR1X_ANA_CMD_TEMPERATURE;
 80294c0:	4b07      	ldr	r3, [pc, #28]	; (80294e0 <bgt24mtr1x_ana_temp+0x20>)
  
  bgt24mtr1x_global_config &= BGT24MTR1X_AMUX_VOUT_TX;
 80294c2:	4a08      	ldr	r2, [pc, #32]	; (80294e4 <bgt24mtr1x_ana_temp+0x24>)

//============================================================================

void bgt24mtr1x_ana_temp(void)
{
  bgt24mtr1x_ana_command = BGT24MTR1X_ANA_CMD_TEMPERATURE;
 80294c4:	2100      	movs	r1, #0
 80294c6:	8019      	strh	r1, [r3, #0]
  
  bgt24mtr1x_global_config &= BGT24MTR1X_AMUX_VOUT_TX;
 80294c8:	8813      	ldrh	r3, [r2, #0]
 80294ca:	f423 5306 	bic.w	r3, r3, #8576	; 0x2180
 80294ce:	041b      	lsls	r3, r3, #16
 80294d0:	0c1b      	lsrs	r3, r3, #16
 80294d2:	8013      	strh	r3, [r2, #0]
  
  bgt24mtr1x_global_config |= BGT24MTR1X_AMUX_2;
 80294d4:	8813      	ldrh	r3, [r2, #0]
 80294d6:	b29b      	uxth	r3, r3
 80294d8:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80294dc:	8013      	strh	r3, [r2, #0]
 80294de:	4770      	bx	lr
 80294e0:	1ffe8b68 	.word	0x1ffe8b68
 80294e4:	1ffe8b66 	.word	0x1ffe8b66

080294e8 <bgt24mtr1x_ana_vout_tx>:

//============================================================================

void bgt24mtr1x_ana_vout_tx(void)
{
  bgt24mtr1x_ana_command = BGT24MTR1X_ANA_CMD_TX_POWER;
 80294e8:	4b05      	ldr	r3, [pc, #20]	; (8029500 <bgt24mtr1x_ana_vout_tx+0x18>)
  
  bgt24mtr1x_global_config &= BGT24MTR1X_AMUX_VOUT_TX;
 80294ea:	4a06      	ldr	r2, [pc, #24]	; (8029504 <bgt24mtr1x_ana_vout_tx+0x1c>)

//============================================================================

void bgt24mtr1x_ana_vout_tx(void)
{
  bgt24mtr1x_ana_command = BGT24MTR1X_ANA_CMD_TX_POWER;
 80294ec:	2101      	movs	r1, #1
 80294ee:	8019      	strh	r1, [r3, #0]
  
  bgt24mtr1x_global_config &= BGT24MTR1X_AMUX_VOUT_TX;
 80294f0:	8813      	ldrh	r3, [r2, #0]
 80294f2:	f423 5306 	bic.w	r3, r3, #8576	; 0x2180
 80294f6:	041b      	lsls	r3, r3, #16
 80294f8:	0c1b      	lsrs	r3, r3, #16
 80294fa:	8013      	strh	r3, [r2, #0]
 80294fc:	4770      	bx	lr
 80294fe:	bf00      	nop
 8029500:	1ffe8b68 	.word	0x1ffe8b68
 8029504:	1ffe8b66 	.word	0x1ffe8b66

08029508 <bgt24mtr1x_ana_vref_tx>:

//============================================================================

void bgt24mtr1x_ana_vref_tx(void)
{
  bgt24mtr1x_ana_command = BGT24MTR1X_ANA_CMD_TX_POWER_REF;
 8029508:	4b07      	ldr	r3, [pc, #28]	; (8029528 <bgt24mtr1x_ana_vref_tx+0x20>)
  
  bgt24mtr1x_global_config &= BGT24MTR1X_AMUX_VOUT_TX;
 802950a:	4a08      	ldr	r2, [pc, #32]	; (802952c <bgt24mtr1x_ana_vref_tx+0x24>)

//============================================================================

void bgt24mtr1x_ana_vref_tx(void)
{
  bgt24mtr1x_ana_command = BGT24MTR1X_ANA_CMD_TX_POWER_REF;
 802950c:	2102      	movs	r1, #2
 802950e:	8019      	strh	r1, [r3, #0]
  
  bgt24mtr1x_global_config &= BGT24MTR1X_AMUX_VOUT_TX;
 8029510:	8813      	ldrh	r3, [r2, #0]
 8029512:	f423 5306 	bic.w	r3, r3, #8576	; 0x2180
 8029516:	041b      	lsls	r3, r3, #16
 8029518:	0c1b      	lsrs	r3, r3, #16
 802951a:	8013      	strh	r3, [r2, #0]
  
  bgt24mtr1x_global_config |= BGT24MTR1X_AMUX_0;
 802951c:	8813      	ldrh	r3, [r2, #0]
 802951e:	b29b      	uxth	r3, r3
 8029520:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8029524:	8013      	strh	r3, [r2, #0]
 8029526:	4770      	bx	lr
 8029528:	1ffe8b68 	.word	0x1ffe8b68
 802952c:	1ffe8b66 	.word	0x1ffe8b66

08029530 <bgt24mtr1x_get_ana_config>:

//============================================================================

uint16_t bgt24mtr1x_get_ana_config(void)
{
  return (bgt24mtr1x_ana_command);
 8029530:	4b01      	ldr	r3, [pc, #4]	; (8029538 <bgt24mtr1x_get_ana_config+0x8>)
 8029532:	8818      	ldrh	r0, [r3, #0]
}
 8029534:	b280      	uxth	r0, r0
 8029536:	4770      	bx	lr
 8029538:	1ffe8b68 	.word	0x1ffe8b68

0802953c <system_reset>:

//===========================================================================

/* This function yet to be filled in case of software reset */
void system_reset(void)
{
 802953c:	4770      	bx	lr
 802953e:	bf00      	nop

08029540 <app_data_acq_started_cb>:
 *  it can be used to get information about the beginning of data acquisition
 */
void app_data_acq_started_cb(void *parameter)
{
  /* Turn On LED at the beginning of data acquisition */
  bsp_led_on();
 8029540:	f7fe bf7e 	b.w	8028440 <bsp_led_on>

08029544 <app_data_acq_done_cb>:

/* This callback function will be executed by radar control at the end of data acquisition,
 * it is used to inform upper layers that data sampling is done and data is ready in user buffer
 */
void app_data_acq_done_cb(void *parameter)
{
 8029544:	b508      	push	{r3, lr}
  /* Turn Off LED at the end of data acquisition */
  bsp_led_off();
 8029546:	f7fe ff85 	bl	8028454 <bsp_led_off>

  /* Set the main application state at the end of data acquisition */
  g_adc_sampling_completed = true;
  radar_app_state = APP_RADAR_DATA_ACQUISITION_COMPLETED;
 802954a:	4b05      	ldr	r3, [pc, #20]	; (8029560 <app_data_acq_done_cb+0x1c>)
{
  /* Turn Off LED at the end of data acquisition */
  bsp_led_off();

  /* Set the main application state at the end of data acquisition */
  g_adc_sampling_completed = true;
 802954c:	4905      	ldr	r1, [pc, #20]	; (8029564 <app_data_acq_done_cb+0x20>)
  radar_app_state = APP_RADAR_DATA_ACQUISITION_COMPLETED;
 802954e:	2203      	movs	r2, #3
{
  /* Turn Off LED at the end of data acquisition */
  bsp_led_off();

  /* Set the main application state at the end of data acquisition */
  g_adc_sampling_completed = true;
 8029550:	2001      	movs	r0, #1
  radar_app_state = APP_RADAR_DATA_ACQUISITION_COMPLETED;
 8029552:	701a      	strb	r2, [r3, #0]
  acq_completed_cb();
}
 8029554:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
  /* Turn Off LED at the end of data acquisition */
  bsp_led_off();

  /* Set the main application state at the end of data acquisition */
  g_adc_sampling_completed = true;
 8029558:	6008      	str	r0, [r1, #0]
  radar_app_state = APP_RADAR_DATA_ACQUISITION_COMPLETED;
  acq_completed_cb();
 802955a:	f000 b8ff 	b.w	802975c <acq_completed_cb>
 802955e:	bf00      	nop
 8029560:	1ffe8b78 	.word	0x1ffe8b78
 8029564:	1ffe8cc0 	.word	0x1ffe8cc0

08029568 <app_init>:
   5. EXPORTED FUNCTIONS
==============================================================================
 */

void app_init(void)
{
 8029568:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  /* Initialize USB */
  if(bsp_usb_init(BSP_USB_TIMEOUT) == 0)
 802956c:	f640 70ff 	movw	r0, #4095	; 0xfff
   5. EXPORTED FUNCTIONS
==============================================================================
 */

void app_init(void)
{
 8029570:	b083      	sub	sp, #12
  /* Initialize USB */
  if(bsp_usb_init(BSP_USB_TIMEOUT) == 0)
 8029572:	f7fe ff19 	bl	80283a8 <bsp_usb_init>
 8029576:	b910      	cbnz	r0, 802957e <app_init+0x16>
  {
    g_usb_init = true;
 8029578:	4b39      	ldr	r3, [pc, #228]	; (8029660 <app_init+0xf8>)
 802957a:	2201      	movs	r2, #1
 802957c:	701a      	strb	r2, [r3, #0]
  }

  /* Open the available radar device */
  if(radar_open_device(0, &h_radar_device) != RADAR_ERR_OK)
 802957e:	4f39      	ldr	r7, [pc, #228]	; (8029664 <app_init+0xfc>)
 8029580:	2000      	movs	r0, #0
 8029582:	4639      	mov	r1, r7
 8029584:	f7f6 ffa0 	bl	80204c8 <radar_open_device>
 8029588:	b100      	cbz	r0, 802958c <app_init+0x24>
  {
    XMC_DEBUG("Opening Radar device failed\n");
    while(1U);
 802958a:	e7fe      	b.n	802958a <app_init+0x22>
  }

  /* Register user callback functions */
  radar_register_callback(RADAR_ACQUISITION_STARTED_CB_ID, app_data_acq_started_cb);
 802958c:	4936      	ldr	r1, [pc, #216]	; (8029668 <app_init+0x100>)
    EP_RADAR_INDUSTRIAL_ENDPOINT_LIST_ENTRY(h_radar_device),
    EP_RADAR_P2G_ENDPOINT_LIST_ENTRY(h_radar_device),
    EP_CALIBRATION_ENDPOINT_LIST_ENTRY(h_radar_device)
  };

  memcpy(endpoint_list, ep_list, NUMBER_SUPPORTED_ENDPOINTS * sizeof(Endpoint_t));
 802958e:	4c37      	ldr	r4, [pc, #220]	; (802966c <app_init+0x104>)
 8029590:	f8df b104 	ldr.w	fp, [pc, #260]	; 8029698 <app_init+0x130>
 8029594:	f8df 8104 	ldr.w	r8, [pc, #260]	; 802969c <app_init+0x134>
 8029598:	f8df a104 	ldr.w	sl, [pc, #260]	; 80296a0 <app_init+0x138>
 802959c:	f8df 9104 	ldr.w	r9, [pc, #260]	; 80296a4 <app_init+0x13c>
 80295a0:	4e33      	ldr	r6, [pc, #204]	; (8029670 <app_init+0x108>)
 80295a2:	4d34      	ldr	r5, [pc, #208]	; (8029674 <app_init+0x10c>)
    XMC_DEBUG("Opening Radar device failed\n");
    while(1U);
  }

  /* Register user callback functions */
  radar_register_callback(RADAR_ACQUISITION_STARTED_CB_ID, app_data_acq_started_cb);
 80295a4:	2001      	movs	r0, #1
 80295a6:	f7f7 fd71 	bl	802108c <radar_register_callback>
  radar_register_callback(RADAR_ACQUISITION_DONE_CB_ID, app_data_acq_done_cb);
 80295aa:	4933      	ldr	r1, [pc, #204]	; (8029678 <app_init+0x110>)
 80295ac:	2002      	movs	r0, #2
 80295ae:	f7f7 fd6d 	bl	802108c <radar_register_callback>
  };

  memcpy(endpoint_list, ep_list, NUMBER_SUPPORTED_ENDPOINTS * sizeof(Endpoint_t));

  /* Initialize the internal protocol state and the communication interface */
  protocol_init(endpoint_list, sizeof(endpoint_list)/sizeof(endpoint_list[0]), SYSTIMER_GetTime, BSP_HOST_TIMEOUT_USEC, system_reset);
 80295b2:	4b32      	ldr	r3, [pc, #200]	; (802967c <app_init+0x114>)
 80295b4:	9300      	str	r3, [sp, #0]
    EP_RADAR_INDUSTRIAL_ENDPOINT_LIST_ENTRY(h_radar_device),
    EP_RADAR_P2G_ENDPOINT_LIST_ENTRY(h_radar_device),
    EP_CALIBRATION_ENDPOINT_LIST_ENTRY(h_radar_device)
  };

  memcpy(endpoint_list, ep_list, NUMBER_SUPPORTED_ENDPOINTS * sizeof(Endpoint_t));
 80295b6:	f8df c0f0 	ldr.w	ip, [pc, #240]	; 80296a8 <app_init+0x140>
 80295ba:	f8df e0f0 	ldr.w	lr, [pc, #240]	; 80296ac <app_init+0x144>
 80295be:	4830      	ldr	r0, [pc, #192]	; (8029680 <app_init+0x118>)
 80295c0:	4930      	ldr	r1, [pc, #192]	; (8029684 <app_init+0x11c>)
 80295c2:	4a31      	ldr	r2, [pc, #196]	; (8029688 <app_init+0x120>)
 80295c4:	4b31      	ldr	r3, [pc, #196]	; (802968c <app_init+0x124>)
 80295c6:	f8c4 b000 	str.w	fp, [r4]
 80295ca:	f8c4 8014 	str.w	r8, [r4, #20]
 80295ce:	f50b 2b5f 	add.w	fp, fp, #913408	; 0xdf000
 80295d2:	f508 38fe 	add.w	r8, r8, #130048	; 0x1fc00
 80295d6:	f8c4 a008 	str.w	sl, [r4, #8]
 80295da:	f8c4 9010 	str.w	r9, [r4, #16]
 80295de:	f8c4 c01c 	str.w	ip, [r4, #28]
 80295e2:	f8c4 e024 	str.w	lr, [r4, #36]	; 0x24
 80295e6:	f8df c0c8 	ldr.w	ip, [pc, #200]	; 80296b0 <app_init+0x148>
 80295ea:	f8df e0c8 	ldr.w	lr, [pc, #200]	; 80296b4 <app_init+0x14c>
 80295ee:	62a0      	str	r0, [r4, #40]	; 0x28
 80295f0:	6326      	str	r6, [r4, #48]	; 0x30

  /* Initialize the internal protocol state and the communication interface */
  protocol_init(endpoint_list, sizeof(endpoint_list)/sizeof(endpoint_list[0]), SYSTIMER_GetTime, BSP_HOST_TIMEOUT_USEC, system_reset);
 80295f2:	4620      	mov	r0, r4
    EP_RADAR_INDUSTRIAL_ENDPOINT_LIST_ENTRY(h_radar_device),
    EP_RADAR_P2G_ENDPOINT_LIST_ENTRY(h_radar_device),
    EP_CALIBRATION_ENDPOINT_LIST_ENTRY(h_radar_device)
  };

  memcpy(endpoint_list, ep_list, NUMBER_SUPPORTED_ENDPOINTS * sizeof(Endpoint_t));
 80295f4:	2601      	movs	r6, #1
 80295f6:	63a5      	str	r5, [r4, #56]	; 0x38
 80295f8:	63e1      	str	r1, [r4, #60]	; 0x3c
  /* Register user callback functions */
  radar_register_callback(RADAR_ACQUISITION_STARTED_CB_ID, app_data_acq_started_cb);
  radar_register_callback(RADAR_ACQUISITION_DONE_CB_ID, app_data_acq_done_cb);

  /* Register all endpoints to the communication protocol */
  Endpoint_t ep_list[NUMBER_SUPPORTED_ENDPOINTS] =
 80295fa:	683d      	ldr	r5, [r7, #0]
    EP_RADAR_INDUSTRIAL_ENDPOINT_LIST_ENTRY(h_radar_device),
    EP_RADAR_P2G_ENDPOINT_LIST_ENTRY(h_radar_device),
    EP_CALIBRATION_ENDPOINT_LIST_ENTRY(h_radar_device)
  };

  memcpy(endpoint_list, ep_list, NUMBER_SUPPORTED_ENDPOINTS * sizeof(Endpoint_t));
 80295fc:	6462      	str	r2, [r4, #68]	; 0x44
 80295fe:	64e3      	str	r3, [r4, #76]	; 0x4c
 8029600:	f10b 0bf4 	add.w	fp, fp, #244	; 0xf4
 8029604:	f8df a0b0 	ldr.w	sl, [pc, #176]	; 80296b8 <app_init+0x150>
 8029608:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 80296bc <app_init+0x154>

  /* Initialize the internal protocol state and the communication interface */
  protocol_init(endpoint_list, sizeof(endpoint_list)/sizeof(endpoint_list[0]), SYSTIMER_GetTime, BSP_HOST_TIMEOUT_USEC, system_reset);
 802960c:	4a20      	ldr	r2, [pc, #128]	; (8029690 <app_init+0x128>)
 802960e:	4b21      	ldr	r3, [pc, #132]	; (8029694 <app_init+0x12c>)
    EP_RADAR_INDUSTRIAL_ENDPOINT_LIST_ENTRY(h_radar_device),
    EP_RADAR_P2G_ENDPOINT_LIST_ENTRY(h_radar_device),
    EP_CALIBRATION_ENDPOINT_LIST_ENTRY(h_radar_device)
  };

  memcpy(endpoint_list, ep_list, NUMBER_SUPPORTED_ENDPOINTS * sizeof(Endpoint_t));
 8029610:	f8c4 b050 	str.w	fp, [r4, #80]	; 0x50
 8029614:	f108 08f4 	add.w	r8, r8, #244	; 0xf4

  /* Initialize the internal protocol state and the communication interface */
  protocol_init(endpoint_list, sizeof(endpoint_list)/sizeof(endpoint_list[0]), SYSTIMER_GetTime, BSP_HOST_TIMEOUT_USEC, system_reset);
 8029618:	2106      	movs	r1, #6
    EP_RADAR_INDUSTRIAL_ENDPOINT_LIST_ENTRY(h_radar_device),
    EP_RADAR_P2G_ENDPOINT_LIST_ENTRY(h_radar_device),
    EP_CALIBRATION_ENDPOINT_LIST_ENTRY(h_radar_device)
  };

  memcpy(endpoint_list, ep_list, NUMBER_SUPPORTED_ENDPOINTS * sizeof(Endpoint_t));
 802961a:	f8c4 a058 	str.w	sl, [r4, #88]	; 0x58
 802961e:	f8c4 9060 	str.w	r9, [r4, #96]	; 0x60
 8029622:	f8c4 8064 	str.w	r8, [r4, #100]	; 0x64
 8029626:	f8c4 c06c 	str.w	ip, [r4, #108]	; 0x6c
 802962a:	f8c4 e074 	str.w	lr, [r4, #116]	; 0x74
 802962e:	80a6      	strh	r6, [r4, #4]
 8029630:	8326      	strh	r6, [r4, #24]
 8029632:	85a6      	strh	r6, [r4, #44]	; 0x2c
 8029634:	f8a4 6040 	strh.w	r6, [r4, #64]	; 0x40
 8029638:	f8a4 6054 	strh.w	r6, [r4, #84]	; 0x54
 802963c:	f8a4 6068 	strh.w	r6, [r4, #104]	; 0x68
 8029640:	60e5      	str	r5, [r4, #12]
 8029642:	6225      	str	r5, [r4, #32]
 8029644:	6365      	str	r5, [r4, #52]	; 0x34
 8029646:	64a5      	str	r5, [r4, #72]	; 0x48
 8029648:	65e5      	str	r5, [r4, #92]	; 0x5c
 802964a:	6725      	str	r5, [r4, #112]	; 0x70

  /* Initialize the internal protocol state and the communication interface */
  protocol_init(endpoint_list, sizeof(endpoint_list)/sizeof(endpoint_list[0]), SYSTIMER_GetTime, BSP_HOST_TIMEOUT_USEC, system_reset);
 802964c:	f7fb f9c6 	bl	80249dc <protocol_init>

  /* Start data acquisition at the defined frame interval */
  if (radar_start_acquisition(h_radar_device) != RADAR_ERR_OK)
 8029650:	6838      	ldr	r0, [r7, #0]
 8029652:	f7f7 fc67 	bl	8020f24 <radar_start_acquisition>
 8029656:	b100      	cbz	r0, 802965a <app_init+0xf2>
  {
    XMC_DEBUG("Starting Radar data acquisition failed\n");
    while(1U);
 8029658:	e7fe      	b.n	8029658 <app_init+0xf0>
  }
}
 802965a:	b003      	add	sp, #12
 802965c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029660:	1fff202c 	.word	0x1fff202c
 8029664:	1fffaf60 	.word	0x1fffaf60
 8029668:	08029541 	.word	0x08029541
 802966c:	1fffaee8 	.word	0x1fffaee8
 8029670:	080246bd 	.word	0x080246bd
 8029674:	080247b1 	.word	0x080247b1
 8029678:	08029545 	.word	0x08029545
 802967c:	0802953d 	.word	0x0802953d
 8029680:	52464d43 	.word	0x52464d43
 8029684:	52494e44 	.word	0x52494e44
 8029688:	08024841 	.word	0x08024841
 802968c:	080248f9 	.word	0x080248f9
 8029690:	08026815 	.word	0x08026815
 8029694:	00989680 	.word	0x00989680
 8029698:	52424153 	.word	0x52424153
 802969c:	52414458 	.word	0x52414458
 80296a0:	08023c89 	.word	0x08023c89
 80296a4:	080243d1 	.word	0x080243d1
 80296a8:	08023b6d 	.word	0x08023b6d
 80296ac:	08023c25 	.word	0x08023c25
 80296b0:	08023919 	.word	0x08023919
 80296b4:	08023b05 	.word	0x08023b05
 80296b8:	080248fd 	.word	0x080248fd
 80296bc:	0802496d 	.word	0x0802496d

080296c0 <app_register_algo_process>:
//===========================================================================

void app_register_algo_process(algorithm algo_processor)
{
  /* Register algorithm processing function */
  algo_processing_function = algo_processor;
 80296c0:	4b01      	ldr	r3, [pc, #4]	; (80296c8 <app_register_algo_process+0x8>)
 80296c2:	6018      	str	r0, [r3, #0]
 80296c4:	4770      	bx	lr
 80296c6:	bf00      	nop
 80296c8:	1fff2030 	.word	0x1fff2030

080296cc <app_process>:
}

//===========================================================================

void app_process(void)
{
 80296cc:	b510      	push	{r4, lr}
  if (g_usb_init == true)
 80296ce:	4c1a      	ldr	r4, [pc, #104]	; (8029738 <app_process+0x6c>)
 80296d0:	7823      	ldrb	r3, [r4, #0]
 80296d2:	2b01      	cmp	r3, #1
 80296d4:	d02c      	beq.n	8029730 <app_process+0x64>
    protocol_run();
  }
  else
  {
    /* Initialize the USB low layer driver and start USB data communication */
    if(bsp_usb_init(BSP_USB_TIMEOUT) == 0)
 80296d6:	f640 70ff 	movw	r0, #4095	; 0xfff
 80296da:	f7fe fe65 	bl	80283a8 <bsp_usb_init>
 80296de:	b908      	cbnz	r0, 80296e4 <app_process+0x18>
    {
      g_usb_init = true;
 80296e0:	2301      	movs	r3, #1
 80296e2:	7023      	strb	r3, [r4, #0]

//===========================================================================

void radar_app_process(void)
{
  switch(radar_app_state)
 80296e4:	4c15      	ldr	r4, [pc, #84]	; (802973c <app_process+0x70>)
 80296e6:	7823      	ldrb	r3, [r4, #0]
 80296e8:	2b03      	cmp	r3, #3
 80296ea:	d011      	beq.n	8029710 <app_process+0x44>
 80296ec:	2b04      	cmp	r3, #4
 80296ee:	d008      	beq.n	8029702 <app_process+0x36>
 80296f0:	2b02      	cmp	r3, #2
 80296f2:	d000      	beq.n	80296f6 <app_process+0x2a>
 80296f4:	bd10      	pop	{r4, pc}
	{
	  radar_app_state = APP_IDLE;
	}
	break;
  case APP_APPLY_DEVICE_SETTINGS:
    if(ds_is_device_settings_updated())
 80296f6:	f7f6 fc8f 	bl	8020018 <ds_is_device_settings_updated>
 80296fa:	b960      	cbnz	r0, 8029716 <app_process+0x4a>
	{
	  radar_app_state = APP_APPLY_DEVICE_SETTINGS;
	}
	else
	{
	  radar_app_state = APP_IDLE;
 80296fc:	2301      	movs	r3, #1
 80296fe:	7023      	strb	r3, [r4, #0]
 8029700:	bd10      	pop	{r4, pc}
    radar_app_state = APP_CHECK_FOR_SETTINGS_UPDATE;
    break;

   case APP_CHECK_FOR_SETTINGS_UPDATE:
	/* Check if a new hardware settings are required */
    if(ds_is_device_settings_updated())
 8029702:	f7f6 fc89 	bl	8020018 <ds_is_device_settings_updated>
 8029706:	2800      	cmp	r0, #0
 8029708:	d0f8      	beq.n	80296fc <app_process+0x30>
	{
	  radar_app_state = APP_APPLY_DEVICE_SETTINGS;
 802970a:	2302      	movs	r3, #2
 802970c:	7023      	strb	r3, [r4, #0]
 802970e:	bd10      	pop	{r4, pc}
    	}
      }
    #endif

    /* Check if a new hardware settings are required */
    radar_app_state = APP_CHECK_FOR_SETTINGS_UPDATE;
 8029710:	2304      	movs	r3, #4
 8029712:	7023      	strb	r3, [r4, #0]
 8029714:	bd10      	pop	{r4, pc}
	}
	break;
  case APP_APPLY_DEVICE_SETTINGS:
    if(ds_is_device_settings_updated())
	{
	  device_settings_t *p_dev_settings = ds_device_get_settings();
 8029716:	f7f6 fc77 	bl	8020008 <ds_device_get_settings>

	  if(radar_apply_hw_settings(h_radar_device, UPDATE, p_dev_settings) == RADAR_ERR_OK)
 802971a:	4b09      	ldr	r3, [pc, #36]	; (8029740 <app_process+0x74>)
	}
	break;
  case APP_APPLY_DEVICE_SETTINGS:
    if(ds_is_device_settings_updated())
	{
	  device_settings_t *p_dev_settings = ds_device_get_settings();
 802971c:	4602      	mov	r2, r0

	  if(radar_apply_hw_settings(h_radar_device, UPDATE, p_dev_settings) == RADAR_ERR_OK)
 802971e:	2104      	movs	r1, #4
 8029720:	6818      	ldr	r0, [r3, #0]
 8029722:	f7f7 fcc1 	bl	80210a8 <radar_apply_hw_settings>
 8029726:	2800      	cmp	r0, #0
 8029728:	d1e8      	bne.n	80296fc <app_process+0x30>
	  {
	    ds_device_settings_copy_to_shadow();
 802972a:	f7f6 fc83 	bl	8020034 <ds_device_settings_copy_to_shadow>
 802972e:	e7e5      	b.n	80296fc <app_process+0x30>
void app_process(void)
{
  if (g_usb_init == true)
  {
    /* Run communication protocol */
    protocol_run();
 8029730:	f7fb f9a2 	bl	8024a78 <protocol_run>
 8029734:	e7d6      	b.n	80296e4 <app_process+0x18>
 8029736:	bf00      	nop
 8029738:	1fff202c 	.word	0x1fff202c
 802973c:	1ffe8b78 	.word	0x1ffe8b78
 8029740:	1fffaf60 	.word	0x1fffaf60

08029744 <main>:
   2. MAIN METHOD
==============================================================================
 */

int main(void)
{
 8029744:	b508      	push	{r3, lr}
  DAVE_STATUS_t status;
  
  /* Initialize DAVE APPs */
  status = DAVE_Init();
 8029746:	f7fd fff5 	bl	8027734 <DAVE_Init>
  
  if(status != DAVE_STATUS_SUCCESS)
 802974a:	b100      	cbz	r0, 802974e <main+0xa>
  {
    /* Placeholder for error handler code.
     * The while loop below can be replaced with an user error handler. */
    XMC_DEBUG("DAVE APPs initialization failed\n");
    while(1U);
 802974c:	e7fe      	b.n	802974c <main+0x8>
  }
  
  /* Register algorithm processing function:
   * Set the algorithm processing function pointer, it will
   * be used by the application for algorithm data processing */
  app_register_algo_process(NULL);
 802974e:	f7ff ffb7 	bl	80296c0 <app_register_algo_process>
  
  /* Initialize the application */
  app_init();
 8029752:	f7ff ff09 	bl	8029568 <app_init>
  
  /* Infinite loop */
  while(1U)
  {
    /* Main application process */
    app_process();
 8029756:	f7ff ffb9 	bl	80296cc <app_process>
  }
 802975a:	e7fc      	b.n	8029756 <main+0x12>

0802975c <acq_completed_cb>:
   3. USER CALLBACK FUNCTIONS
==============================================================================
 */

void acq_completed_cb(void)
{
 802975c:	4770      	bx	lr
 802975e:	bf00      	nop

08029760 <logf>:
 8029760:	b530      	push	{r4, r5, lr}
 8029762:	ed2d 8b02 	vpush	{d8}
 8029766:	4d37      	ldr	r5, [pc, #220]	; (8029844 <logf+0xe4>)
 8029768:	b08b      	sub	sp, #44	; 0x2c
 802976a:	ee08 0a10 	vmov	s16, r0
 802976e:	f000 f873 	bl	8029858 <__ieee754_logf>
 8029772:	f995 3000 	ldrsb.w	r3, [r5]
 8029776:	3301      	adds	r3, #1
 8029778:	4604      	mov	r4, r0
 802977a:	d009      	beq.n	8029790 <logf+0x30>
 802977c:	ee18 0a10 	vmov	r0, s16
 8029780:	f000 f986 	bl	8029a90 <__fpclassifyf>
 8029784:	b120      	cbz	r0, 8029790 <logf+0x30>
 8029786:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 802978a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802978e:	dd04      	ble.n	802979a <logf+0x3a>
 8029790:	4620      	mov	r0, r4
 8029792:	b00b      	add	sp, #44	; 0x2c
 8029794:	ecbd 8b02 	vpop	{d8}
 8029798:	bd30      	pop	{r4, r5, pc}
 802979a:	4b2b      	ldr	r3, [pc, #172]	; (8029848 <logf+0xe8>)
 802979c:	9301      	str	r3, [sp, #4]
 802979e:	ee18 0a10 	vmov	r0, s16
 80297a2:	2300      	movs	r3, #0
 80297a4:	9308      	str	r3, [sp, #32]
 80297a6:	f000 faf1 	bl	8029d8c <__aeabi_f2d>
 80297aa:	782b      	ldrb	r3, [r5, #0]
 80297ac:	e9cd 0104 	strd	r0, r1, [sp, #16]
 80297b0:	e9cd 0102 	strd	r0, r1, [sp, #8]
 80297b4:	b983      	cbnz	r3, 80297d8 <logf+0x78>
 80297b6:	4b25      	ldr	r3, [pc, #148]	; (802984c <logf+0xec>)
 80297b8:	eeb5 8a40 	vcmp.f32	s16, #0.0
 80297bc:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 80297c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80297c4:	e9cd 2306 	strd	r2, r3, [sp, #24]
 80297c8:	d034      	beq.n	8029834 <logf+0xd4>
 80297ca:	2301      	movs	r3, #1
 80297cc:	9300      	str	r3, [sp, #0]
 80297ce:	4668      	mov	r0, sp
 80297d0:	f000 f956 	bl	8029a80 <matherr>
 80297d4:	b988      	cbnz	r0, 80297fa <logf+0x9a>
 80297d6:	e00c      	b.n	80297f2 <logf+0x92>
 80297d8:	491d      	ldr	r1, [pc, #116]	; (8029850 <logf+0xf0>)
 80297da:	eeb5 8a40 	vcmp.f32	s16, #0.0
 80297de:	2000      	movs	r0, #0
 80297e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80297e4:	e9cd 0106 	strd	r0, r1, [sp, #24]
 80297e8:	d016      	beq.n	8029818 <logf+0xb8>
 80297ea:	2201      	movs	r2, #1
 80297ec:	2b02      	cmp	r3, #2
 80297ee:	9200      	str	r2, [sp, #0]
 80297f0:	d1ed      	bne.n	80297ce <logf+0x6e>
 80297f2:	f001 f959 	bl	802aaa8 <__errno>
 80297f6:	2321      	movs	r3, #33	; 0x21
 80297f8:	6003      	str	r3, [r0, #0]
 80297fa:	4816      	ldr	r0, [pc, #88]	; (8029854 <logf+0xf4>)
 80297fc:	f000 f942 	bl	8029a84 <nan>
 8029800:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8029804:	9b08      	ldr	r3, [sp, #32]
 8029806:	b9c3      	cbnz	r3, 802983a <logf+0xda>
 8029808:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 802980c:	f000 fdf4 	bl	802a3f8 <__aeabi_d2f>
 8029810:	b00b      	add	sp, #44	; 0x2c
 8029812:	ecbd 8b02 	vpop	{d8}
 8029816:	bd30      	pop	{r4, r5, pc}
 8029818:	2202      	movs	r2, #2
 802981a:	4293      	cmp	r3, r2
 802981c:	9200      	str	r2, [sp, #0]
 802981e:	d004      	beq.n	802982a <logf+0xca>
 8029820:	4668      	mov	r0, sp
 8029822:	f000 f92d 	bl	8029a80 <matherr>
 8029826:	2800      	cmp	r0, #0
 8029828:	d1ec      	bne.n	8029804 <logf+0xa4>
 802982a:	f001 f93d 	bl	802aaa8 <__errno>
 802982e:	2322      	movs	r3, #34	; 0x22
 8029830:	6003      	str	r3, [r0, #0]
 8029832:	e7e7      	b.n	8029804 <logf+0xa4>
 8029834:	2302      	movs	r3, #2
 8029836:	9300      	str	r3, [sp, #0]
 8029838:	e7f2      	b.n	8029820 <logf+0xc0>
 802983a:	f001 f935 	bl	802aaa8 <__errno>
 802983e:	9b08      	ldr	r3, [sp, #32]
 8029840:	6003      	str	r3, [r0, #0]
 8029842:	e7e1      	b.n	8029808 <logf+0xa8>
 8029844:	1ffe8b79 	.word	0x1ffe8b79
 8029848:	0802b26c 	.word	0x0802b26c
 802984c:	c7efffff 	.word	0xc7efffff
 8029850:	fff00000 	.word	0xfff00000
 8029854:	0802b270 	.word	0x0802b270

08029858 <__ieee754_logf>:
 8029858:	b430      	push	{r4, r5}
 802985a:	b082      	sub	sp, #8
 802985c:	9001      	str	r0, [sp, #4]
 802985e:	9b01      	ldr	r3, [sp, #4]
 8029860:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 8029864:	b372      	cbz	r2, 80298c4 <__ieee754_logf+0x6c>
 8029866:	2b00      	cmp	r3, #0
 8029868:	db42      	blt.n	80298f0 <__ieee754_logf+0x98>
 802986a:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 802986e:	da4c      	bge.n	802990a <__ieee754_logf+0xb2>
 8029870:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 8029874:	db31      	blt.n	80298da <__ieee754_logf+0x82>
 8029876:	2200      	movs	r2, #0
 8029878:	4972      	ldr	r1, [pc, #456]	; (8029a44 <__ieee754_logf+0x1ec>)
 802987a:	f3c3 0516 	ubfx	r5, r3, #0, #23
 802987e:	4429      	add	r1, r5
 8029880:	f401 0100 	and.w	r1, r1, #8388608	; 0x800000
 8029884:	15db      	asrs	r3, r3, #23
 8029886:	3b7f      	subs	r3, #127	; 0x7f
 8029888:	f081 547e 	eor.w	r4, r1, #1065353216	; 0x3f800000
 802988c:	4413      	add	r3, r2
 802988e:	f105 000f 	add.w	r0, r5, #15
 8029892:	ea44 0205 	orr.w	r2, r4, r5
 8029896:	ee07 2a90 	vmov	s15, r2
 802989a:	f3c0 0216 	ubfx	r2, r0, #0, #23
 802989e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 80298a2:	2a0f      	cmp	r2, #15
 80298a4:	eb03 53d1 	add.w	r3, r3, r1, lsr #23
 80298a8:	ee37 7ac7 	vsub.f32	s14, s15, s14
 80298ac:	dc36      	bgt.n	802991c <__ieee754_logf+0xc4>
 80298ae:	eeb5 7a40 	vcmp.f32	s14, #0.0
 80298b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80298b6:	d172      	bne.n	802999e <__ieee754_logf+0x146>
 80298b8:	2b00      	cmp	r3, #0
 80298ba:	f040 809e 	bne.w	80299fa <__ieee754_logf+0x1a2>
 80298be:	eddf 7a62 	vldr	s15, [pc, #392]	; 8029a48 <__ieee754_logf+0x1f0>
 80298c2:	e005      	b.n	80298d0 <__ieee754_logf+0x78>
 80298c4:	eddf 7a61 	vldr	s15, [pc, #388]	; 8029a4c <__ieee754_logf+0x1f4>
 80298c8:	ed9f 7a5f 	vldr	s14, [pc, #380]	; 8029a48 <__ieee754_logf+0x1f0>
 80298cc:	eec7 7a87 	vdiv.f32	s15, s15, s14
 80298d0:	ee17 0a90 	vmov	r0, s15
 80298d4:	b002      	add	sp, #8
 80298d6:	bc30      	pop	{r4, r5}
 80298d8:	4770      	bx	lr
 80298da:	eddf 7a5d 	vldr	s15, [pc, #372]	; 8029a50 <__ieee754_logf+0x1f8>
 80298de:	ed9d 7a01 	vldr	s14, [sp, #4]
 80298e2:	ee67 7a27 	vmul.f32	s15, s14, s15
 80298e6:	f06f 0218 	mvn.w	r2, #24
 80298ea:	ee17 3a90 	vmov	r3, s15
 80298ee:	e7c3      	b.n	8029878 <__ieee754_logf+0x20>
 80298f0:	eddd 7a01 	vldr	s15, [sp, #4]
 80298f4:	ed9f 7a54 	vldr	s14, [pc, #336]	; 8029a48 <__ieee754_logf+0x1f0>
 80298f8:	ee77 7ae7 	vsub.f32	s15, s15, s15
 80298fc:	eec7 7a87 	vdiv.f32	s15, s15, s14
 8029900:	ee17 0a90 	vmov	r0, s15
 8029904:	b002      	add	sp, #8
 8029906:	bc30      	pop	{r4, r5}
 8029908:	4770      	bx	lr
 802990a:	eddd 7a01 	vldr	s15, [sp, #4]
 802990e:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8029912:	ee17 0a90 	vmov	r0, s15
 8029916:	b002      	add	sp, #8
 8029918:	bc30      	pop	{r4, r5}
 802991a:	4770      	bx	lr
 802991c:	eeb0 6a00 	vmov.f32	s12, #0
 8029920:	ee37 6a06 	vadd.f32	s12, s14, s12
 8029924:	ee06 3a90 	vmov	s13, r3
 8029928:	ee87 6a06 	vdiv.f32	s12, s14, s12
 802992c:	4a49      	ldr	r2, [pc, #292]	; (8029a54 <__ieee754_logf+0x1fc>)
 802992e:	f5c5 1157 	rsb	r1, r5, #3522560	; 0x35c000
 8029932:	442a      	add	r2, r5
 8029934:	f501 7122 	add.w	r1, r1, #648	; 0x288
 8029938:	430a      	orrs	r2, r1
 802993a:	2a00      	cmp	r2, #0
 802993c:	ed9f 2a46 	vldr	s4, [pc, #280]	; 8029a58 <__ieee754_logf+0x200>
 8029940:	eddf 3a46 	vldr	s7, [pc, #280]	; 8029a5c <__ieee754_logf+0x204>
 8029944:	eddf 4a46 	vldr	s9, [pc, #280]	; 8029a60 <__ieee754_logf+0x208>
 8029948:	eddf 2a46 	vldr	s5, [pc, #280]	; 8029a64 <__ieee754_logf+0x20c>
 802994c:	ed9f 4a46 	vldr	s8, [pc, #280]	; 8029a68 <__ieee754_logf+0x210>
 8029950:	eddf 7a46 	vldr	s15, [pc, #280]	; 8029a6c <__ieee754_logf+0x214>
 8029954:	eddf 5a46 	vldr	s11, [pc, #280]	; 8029a70 <__ieee754_logf+0x218>
 8029958:	ee26 5a06 	vmul.f32	s10, s12, s12
 802995c:	eeb8 3ae6 	vcvt.f32.s32	s6, s13
 8029960:	ee65 6a05 	vmul.f32	s13, s10, s10
 8029964:	eee6 3a82 	vfma.f32	s7, s13, s4
 8029968:	eea6 4aa2 	vfma.f32	s8, s13, s5
 802996c:	eee3 4aa6 	vfma.f32	s9, s7, s13
 8029970:	eee4 5a26 	vfma.f32	s11, s8, s13
 8029974:	eee4 7aa6 	vfma.f32	s15, s9, s13
 8029978:	ee67 7a85 	vmul.f32	s15, s15, s10
 802997c:	eee5 7aa6 	vfma.f32	s15, s11, s13
 8029980:	dd48      	ble.n	8029a14 <__ieee754_logf+0x1bc>
 8029982:	eef6 5a00 	vmov.f32	s11, #96	; 0x60
 8029986:	ee67 5a25 	vmul.f32	s11, s14, s11
 802998a:	ee65 5a87 	vmul.f32	s11, s11, s14
 802998e:	b9a3      	cbnz	r3, 80299ba <__ieee754_logf+0x162>
 8029990:	ee75 6aa7 	vadd.f32	s13, s11, s15
 8029994:	eee6 5ac6 	vfms.f32	s11, s13, s12
 8029998:	ee77 7a65 	vsub.f32	s15, s14, s11
 802999c:	e798      	b.n	80298d0 <__ieee754_logf+0x78>
 802999e:	eddf 6a35 	vldr	s13, [pc, #212]	; 8029a74 <__ieee754_logf+0x21c>
 80299a2:	eef6 7a00 	vmov.f32	s15, #96	; 0x60
 80299a6:	eee7 7a66 	vfms.f32	s15, s14, s13
 80299aa:	ee67 6a07 	vmul.f32	s13, s14, s14
 80299ae:	ee66 7aa7 	vmul.f32	s15, s13, s15
 80299b2:	b99b      	cbnz	r3, 80299dc <__ieee754_logf+0x184>
 80299b4:	ee77 7a67 	vsub.f32	s15, s14, s15
 80299b8:	e78a      	b.n	80298d0 <__ieee754_logf+0x78>
 80299ba:	ed9f 5a2f 	vldr	s10, [pc, #188]	; 8029a78 <__ieee754_logf+0x220>
 80299be:	eddf 4a2f 	vldr	s9, [pc, #188]	; 8029a7c <__ieee754_logf+0x224>
 80299c2:	ee75 6aa7 	vadd.f32	s13, s11, s15
 80299c6:	ee63 7a05 	vmul.f32	s15, s6, s10
 80299ca:	eee6 7a86 	vfma.f32	s15, s13, s12
 80299ce:	ee75 7ae7 	vsub.f32	s15, s11, s15
 80299d2:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80299d6:	eed3 7a24 	vfnms.f32	s15, s6, s9
 80299da:	e779      	b.n	80298d0 <__ieee754_logf+0x78>
 80299dc:	ee06 3a90 	vmov	s13, r3
 80299e0:	eddf 5a25 	vldr	s11, [pc, #148]	; 8029a78 <__ieee754_logf+0x220>
 80299e4:	ed9f 6a25 	vldr	s12, [pc, #148]	; 8029a7c <__ieee754_logf+0x224>
 80299e8:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 80299ec:	eee6 7ae5 	vfms.f32	s15, s13, s11
 80299f0:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80299f4:	eed6 7a86 	vfnms.f32	s15, s13, s12
 80299f8:	e76a      	b.n	80298d0 <__ieee754_logf+0x78>
 80299fa:	ee07 3a90 	vmov	s15, r3
 80299fe:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8029a02:	eddf 7a1d 	vldr	s15, [pc, #116]	; 8029a78 <__ieee754_logf+0x220>
 8029a06:	eddf 6a1d 	vldr	s13, [pc, #116]	; 8029a7c <__ieee754_logf+0x224>
 8029a0a:	ee67 7a27 	vmul.f32	s15, s14, s15
 8029a0e:	eee7 7a26 	vfma.f32	s15, s14, s13
 8029a12:	e75d      	b.n	80298d0 <__ieee754_logf+0x78>
 8029a14:	b173      	cbz	r3, 8029a34 <__ieee754_logf+0x1dc>
 8029a16:	eddf 5a18 	vldr	s11, [pc, #96]	; 8029a78 <__ieee754_logf+0x220>
 8029a1a:	ed9f 5a18 	vldr	s10, [pc, #96]	; 8029a7c <__ieee754_logf+0x224>
 8029a1e:	ee77 6a67 	vsub.f32	s13, s14, s15
 8029a22:	ee65 7ac3 	vnmul.f32	s15, s11, s6
 8029a26:	eee6 7a86 	vfma.f32	s15, s13, s12
 8029a2a:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8029a2e:	eed3 7a05 	vfnms.f32	s15, s6, s10
 8029a32:	e74d      	b.n	80298d0 <__ieee754_logf+0x78>
 8029a34:	ee77 7a67 	vsub.f32	s15, s14, s15
 8029a38:	eea7 7ac6 	vfms.f32	s14, s15, s12
 8029a3c:	eef0 7a47 	vmov.f32	s15, s14
 8029a40:	e746      	b.n	80298d0 <__ieee754_logf+0x78>
 8029a42:	bf00      	nop
 8029a44:	004afb20 	.word	0x004afb20
 8029a48:	00000000 	.word	0x00000000
 8029a4c:	cc000000 	.word	0xcc000000
 8029a50:	4c000000 	.word	0x4c000000
 8029a54:	ffcf5c30 	.word	0xffcf5c30
 8029a58:	3e178897 	.word	0x3e178897
 8029a5c:	3e3a3325 	.word	0x3e3a3325
 8029a60:	3e924925 	.word	0x3e924925
 8029a64:	3e1cd04f 	.word	0x3e1cd04f
 8029a68:	3e638e29 	.word	0x3e638e29
 8029a6c:	3f2aaaab 	.word	0x3f2aaaab
 8029a70:	3ecccccd 	.word	0x3ecccccd
 8029a74:	3eaaaaab 	.word	0x3eaaaaab
 8029a78:	3717f7d1 	.word	0x3717f7d1
 8029a7c:	3f317180 	.word	0x3f317180

08029a80 <matherr>:
 8029a80:	2000      	movs	r0, #0
 8029a82:	4770      	bx	lr

08029a84 <nan>:
 8029a84:	2000      	movs	r0, #0
 8029a86:	4901      	ldr	r1, [pc, #4]	; (8029a8c <nan+0x8>)
 8029a88:	4770      	bx	lr
 8029a8a:	bf00      	nop
 8029a8c:	7ff80000 	.word	0x7ff80000

08029a90 <__fpclassifyf>:
 8029a90:	f030 4000 	bics.w	r0, r0, #2147483648	; 0x80000000
 8029a94:	d101      	bne.n	8029a9a <__fpclassifyf+0xa>
 8029a96:	2002      	movs	r0, #2
 8029a98:	4770      	bx	lr
 8029a9a:	f5a0 0300 	sub.w	r3, r0, #8388608	; 0x800000
 8029a9e:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
 8029aa2:	d201      	bcs.n	8029aa8 <__fpclassifyf+0x18>
 8029aa4:	2004      	movs	r0, #4
 8029aa6:	4770      	bx	lr
 8029aa8:	4b05      	ldr	r3, [pc, #20]	; (8029ac0 <__fpclassifyf+0x30>)
 8029aaa:	1e42      	subs	r2, r0, #1
 8029aac:	429a      	cmp	r2, r3
 8029aae:	d801      	bhi.n	8029ab4 <__fpclassifyf+0x24>
 8029ab0:	2003      	movs	r0, #3
 8029ab2:	4770      	bx	lr
 8029ab4:	f1a0 40ff 	sub.w	r0, r0, #2139095040	; 0x7f800000
 8029ab8:	fab0 f080 	clz	r0, r0
 8029abc:	0940      	lsrs	r0, r0, #5
 8029abe:	4770      	bx	lr
 8029ac0:	007ffffe 	.word	0x007ffffe

08029ac4 <__aeabi_drsub>:
 8029ac4:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8029ac8:	e002      	b.n	8029ad0 <__adddf3>
 8029aca:	bf00      	nop

08029acc <__aeabi_dsub>:
 8029acc:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

08029ad0 <__adddf3>:
 8029ad0:	b530      	push	{r4, r5, lr}
 8029ad2:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8029ad6:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8029ada:	ea94 0f05 	teq	r4, r5
 8029ade:	bf08      	it	eq
 8029ae0:	ea90 0f02 	teqeq	r0, r2
 8029ae4:	bf1f      	itttt	ne
 8029ae6:	ea54 0c00 	orrsne.w	ip, r4, r0
 8029aea:	ea55 0c02 	orrsne.w	ip, r5, r2
 8029aee:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 8029af2:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8029af6:	f000 80e2 	beq.w	8029cbe <__adddf3+0x1ee>
 8029afa:	ea4f 5454 	mov.w	r4, r4, lsr #21
 8029afe:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 8029b02:	bfb8      	it	lt
 8029b04:	426d      	neglt	r5, r5
 8029b06:	dd0c      	ble.n	8029b22 <__adddf3+0x52>
 8029b08:	442c      	add	r4, r5
 8029b0a:	ea80 0202 	eor.w	r2, r0, r2
 8029b0e:	ea81 0303 	eor.w	r3, r1, r3
 8029b12:	ea82 0000 	eor.w	r0, r2, r0
 8029b16:	ea83 0101 	eor.w	r1, r3, r1
 8029b1a:	ea80 0202 	eor.w	r2, r0, r2
 8029b1e:	ea81 0303 	eor.w	r3, r1, r3
 8029b22:	2d36      	cmp	r5, #54	; 0x36
 8029b24:	bf88      	it	hi
 8029b26:	bd30      	pophi	{r4, r5, pc}
 8029b28:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8029b2c:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8029b30:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8029b34:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8029b38:	d002      	beq.n	8029b40 <__adddf3+0x70>
 8029b3a:	4240      	negs	r0, r0
 8029b3c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8029b40:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8029b44:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8029b48:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8029b4c:	d002      	beq.n	8029b54 <__adddf3+0x84>
 8029b4e:	4252      	negs	r2, r2
 8029b50:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8029b54:	ea94 0f05 	teq	r4, r5
 8029b58:	f000 80a7 	beq.w	8029caa <__adddf3+0x1da>
 8029b5c:	f1a4 0401 	sub.w	r4, r4, #1
 8029b60:	f1d5 0e20 	rsbs	lr, r5, #32
 8029b64:	db0d      	blt.n	8029b82 <__adddf3+0xb2>
 8029b66:	fa02 fc0e 	lsl.w	ip, r2, lr
 8029b6a:	fa22 f205 	lsr.w	r2, r2, r5
 8029b6e:	1880      	adds	r0, r0, r2
 8029b70:	f141 0100 	adc.w	r1, r1, #0
 8029b74:	fa03 f20e 	lsl.w	r2, r3, lr
 8029b78:	1880      	adds	r0, r0, r2
 8029b7a:	fa43 f305 	asr.w	r3, r3, r5
 8029b7e:	4159      	adcs	r1, r3
 8029b80:	e00e      	b.n	8029ba0 <__adddf3+0xd0>
 8029b82:	f1a5 0520 	sub.w	r5, r5, #32
 8029b86:	f10e 0e20 	add.w	lr, lr, #32
 8029b8a:	2a01      	cmp	r2, #1
 8029b8c:	fa03 fc0e 	lsl.w	ip, r3, lr
 8029b90:	bf28      	it	cs
 8029b92:	f04c 0c02 	orrcs.w	ip, ip, #2
 8029b96:	fa43 f305 	asr.w	r3, r3, r5
 8029b9a:	18c0      	adds	r0, r0, r3
 8029b9c:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 8029ba0:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8029ba4:	d507      	bpl.n	8029bb6 <__adddf3+0xe6>
 8029ba6:	f04f 0e00 	mov.w	lr, #0
 8029baa:	f1dc 0c00 	rsbs	ip, ip, #0
 8029bae:	eb7e 0000 	sbcs.w	r0, lr, r0
 8029bb2:	eb6e 0101 	sbc.w	r1, lr, r1
 8029bb6:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8029bba:	d31b      	bcc.n	8029bf4 <__adddf3+0x124>
 8029bbc:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 8029bc0:	d30c      	bcc.n	8029bdc <__adddf3+0x10c>
 8029bc2:	0849      	lsrs	r1, r1, #1
 8029bc4:	ea5f 0030 	movs.w	r0, r0, rrx
 8029bc8:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8029bcc:	f104 0401 	add.w	r4, r4, #1
 8029bd0:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8029bd4:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8029bd8:	f080 809a 	bcs.w	8029d10 <__adddf3+0x240>
 8029bdc:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8029be0:	bf08      	it	eq
 8029be2:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8029be6:	f150 0000 	adcs.w	r0, r0, #0
 8029bea:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8029bee:	ea41 0105 	orr.w	r1, r1, r5
 8029bf2:	bd30      	pop	{r4, r5, pc}
 8029bf4:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8029bf8:	4140      	adcs	r0, r0
 8029bfa:	eb41 0101 	adc.w	r1, r1, r1
 8029bfe:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8029c02:	f1a4 0401 	sub.w	r4, r4, #1
 8029c06:	d1e9      	bne.n	8029bdc <__adddf3+0x10c>
 8029c08:	f091 0f00 	teq	r1, #0
 8029c0c:	bf04      	itt	eq
 8029c0e:	4601      	moveq	r1, r0
 8029c10:	2000      	moveq	r0, #0
 8029c12:	fab1 f381 	clz	r3, r1
 8029c16:	bf08      	it	eq
 8029c18:	3320      	addeq	r3, #32
 8029c1a:	f1a3 030b 	sub.w	r3, r3, #11
 8029c1e:	f1b3 0220 	subs.w	r2, r3, #32
 8029c22:	da0c      	bge.n	8029c3e <__adddf3+0x16e>
 8029c24:	320c      	adds	r2, #12
 8029c26:	dd08      	ble.n	8029c3a <__adddf3+0x16a>
 8029c28:	f102 0c14 	add.w	ip, r2, #20
 8029c2c:	f1c2 020c 	rsb	r2, r2, #12
 8029c30:	fa01 f00c 	lsl.w	r0, r1, ip
 8029c34:	fa21 f102 	lsr.w	r1, r1, r2
 8029c38:	e00c      	b.n	8029c54 <__adddf3+0x184>
 8029c3a:	f102 0214 	add.w	r2, r2, #20
 8029c3e:	bfd8      	it	le
 8029c40:	f1c2 0c20 	rsble	ip, r2, #32
 8029c44:	fa01 f102 	lsl.w	r1, r1, r2
 8029c48:	fa20 fc0c 	lsr.w	ip, r0, ip
 8029c4c:	bfdc      	itt	le
 8029c4e:	ea41 010c 	orrle.w	r1, r1, ip
 8029c52:	4090      	lslle	r0, r2
 8029c54:	1ae4      	subs	r4, r4, r3
 8029c56:	bfa2      	ittt	ge
 8029c58:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8029c5c:	4329      	orrge	r1, r5
 8029c5e:	bd30      	popge	{r4, r5, pc}
 8029c60:	ea6f 0404 	mvn.w	r4, r4
 8029c64:	3c1f      	subs	r4, #31
 8029c66:	da1c      	bge.n	8029ca2 <__adddf3+0x1d2>
 8029c68:	340c      	adds	r4, #12
 8029c6a:	dc0e      	bgt.n	8029c8a <__adddf3+0x1ba>
 8029c6c:	f104 0414 	add.w	r4, r4, #20
 8029c70:	f1c4 0220 	rsb	r2, r4, #32
 8029c74:	fa20 f004 	lsr.w	r0, r0, r4
 8029c78:	fa01 f302 	lsl.w	r3, r1, r2
 8029c7c:	ea40 0003 	orr.w	r0, r0, r3
 8029c80:	fa21 f304 	lsr.w	r3, r1, r4
 8029c84:	ea45 0103 	orr.w	r1, r5, r3
 8029c88:	bd30      	pop	{r4, r5, pc}
 8029c8a:	f1c4 040c 	rsb	r4, r4, #12
 8029c8e:	f1c4 0220 	rsb	r2, r4, #32
 8029c92:	fa20 f002 	lsr.w	r0, r0, r2
 8029c96:	fa01 f304 	lsl.w	r3, r1, r4
 8029c9a:	ea40 0003 	orr.w	r0, r0, r3
 8029c9e:	4629      	mov	r1, r5
 8029ca0:	bd30      	pop	{r4, r5, pc}
 8029ca2:	fa21 f004 	lsr.w	r0, r1, r4
 8029ca6:	4629      	mov	r1, r5
 8029ca8:	bd30      	pop	{r4, r5, pc}
 8029caa:	f094 0f00 	teq	r4, #0
 8029cae:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 8029cb2:	bf06      	itte	eq
 8029cb4:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8029cb8:	3401      	addeq	r4, #1
 8029cba:	3d01      	subne	r5, #1
 8029cbc:	e74e      	b.n	8029b5c <__adddf3+0x8c>
 8029cbe:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8029cc2:	bf18      	it	ne
 8029cc4:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8029cc8:	d029      	beq.n	8029d1e <__adddf3+0x24e>
 8029cca:	ea94 0f05 	teq	r4, r5
 8029cce:	bf08      	it	eq
 8029cd0:	ea90 0f02 	teqeq	r0, r2
 8029cd4:	d005      	beq.n	8029ce2 <__adddf3+0x212>
 8029cd6:	ea54 0c00 	orrs.w	ip, r4, r0
 8029cda:	bf04      	itt	eq
 8029cdc:	4619      	moveq	r1, r3
 8029cde:	4610      	moveq	r0, r2
 8029ce0:	bd30      	pop	{r4, r5, pc}
 8029ce2:	ea91 0f03 	teq	r1, r3
 8029ce6:	bf1e      	ittt	ne
 8029ce8:	2100      	movne	r1, #0
 8029cea:	2000      	movne	r0, #0
 8029cec:	bd30      	popne	{r4, r5, pc}
 8029cee:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 8029cf2:	d105      	bne.n	8029d00 <__adddf3+0x230>
 8029cf4:	0040      	lsls	r0, r0, #1
 8029cf6:	4149      	adcs	r1, r1
 8029cf8:	bf28      	it	cs
 8029cfa:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 8029cfe:	bd30      	pop	{r4, r5, pc}
 8029d00:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8029d04:	bf3c      	itt	cc
 8029d06:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 8029d0a:	bd30      	popcc	{r4, r5, pc}
 8029d0c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8029d10:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8029d14:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8029d18:	f04f 0000 	mov.w	r0, #0
 8029d1c:	bd30      	pop	{r4, r5, pc}
 8029d1e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8029d22:	bf1a      	itte	ne
 8029d24:	4619      	movne	r1, r3
 8029d26:	4610      	movne	r0, r2
 8029d28:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8029d2c:	bf1c      	itt	ne
 8029d2e:	460b      	movne	r3, r1
 8029d30:	4602      	movne	r2, r0
 8029d32:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8029d36:	bf06      	itte	eq
 8029d38:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8029d3c:	ea91 0f03 	teqeq	r1, r3
 8029d40:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8029d44:	bd30      	pop	{r4, r5, pc}
 8029d46:	bf00      	nop

08029d48 <__aeabi_ui2d>:
 8029d48:	f090 0f00 	teq	r0, #0
 8029d4c:	bf04      	itt	eq
 8029d4e:	2100      	moveq	r1, #0
 8029d50:	4770      	bxeq	lr
 8029d52:	b530      	push	{r4, r5, lr}
 8029d54:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8029d58:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8029d5c:	f04f 0500 	mov.w	r5, #0
 8029d60:	f04f 0100 	mov.w	r1, #0
 8029d64:	e750      	b.n	8029c08 <__adddf3+0x138>
 8029d66:	bf00      	nop

08029d68 <__aeabi_i2d>:
 8029d68:	f090 0f00 	teq	r0, #0
 8029d6c:	bf04      	itt	eq
 8029d6e:	2100      	moveq	r1, #0
 8029d70:	4770      	bxeq	lr
 8029d72:	b530      	push	{r4, r5, lr}
 8029d74:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8029d78:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8029d7c:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 8029d80:	bf48      	it	mi
 8029d82:	4240      	negmi	r0, r0
 8029d84:	f04f 0100 	mov.w	r1, #0
 8029d88:	e73e      	b.n	8029c08 <__adddf3+0x138>
 8029d8a:	bf00      	nop

08029d8c <__aeabi_f2d>:
 8029d8c:	0042      	lsls	r2, r0, #1
 8029d8e:	ea4f 01e2 	mov.w	r1, r2, asr #3
 8029d92:	ea4f 0131 	mov.w	r1, r1, rrx
 8029d96:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8029d9a:	bf1f      	itttt	ne
 8029d9c:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 8029da0:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8029da4:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8029da8:	4770      	bxne	lr
 8029daa:	f092 0f00 	teq	r2, #0
 8029dae:	bf14      	ite	ne
 8029db0:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8029db4:	4770      	bxeq	lr
 8029db6:	b530      	push	{r4, r5, lr}
 8029db8:	f44f 7460 	mov.w	r4, #896	; 0x380
 8029dbc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8029dc0:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8029dc4:	e720      	b.n	8029c08 <__adddf3+0x138>
 8029dc6:	bf00      	nop

08029dc8 <__aeabi_ul2d>:
 8029dc8:	ea50 0201 	orrs.w	r2, r0, r1
 8029dcc:	bf08      	it	eq
 8029dce:	4770      	bxeq	lr
 8029dd0:	b530      	push	{r4, r5, lr}
 8029dd2:	f04f 0500 	mov.w	r5, #0
 8029dd6:	e00a      	b.n	8029dee <__aeabi_l2d+0x16>

08029dd8 <__aeabi_l2d>:
 8029dd8:	ea50 0201 	orrs.w	r2, r0, r1
 8029ddc:	bf08      	it	eq
 8029dde:	4770      	bxeq	lr
 8029de0:	b530      	push	{r4, r5, lr}
 8029de2:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8029de6:	d502      	bpl.n	8029dee <__aeabi_l2d+0x16>
 8029de8:	4240      	negs	r0, r0
 8029dea:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8029dee:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8029df2:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8029df6:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8029dfa:	f43f aedc 	beq.w	8029bb6 <__adddf3+0xe6>
 8029dfe:	f04f 0203 	mov.w	r2, #3
 8029e02:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8029e06:	bf18      	it	ne
 8029e08:	3203      	addne	r2, #3
 8029e0a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8029e0e:	bf18      	it	ne
 8029e10:	3203      	addne	r2, #3
 8029e12:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8029e16:	f1c2 0320 	rsb	r3, r2, #32
 8029e1a:	fa00 fc03 	lsl.w	ip, r0, r3
 8029e1e:	fa20 f002 	lsr.w	r0, r0, r2
 8029e22:	fa01 fe03 	lsl.w	lr, r1, r3
 8029e26:	ea40 000e 	orr.w	r0, r0, lr
 8029e2a:	fa21 f102 	lsr.w	r1, r1, r2
 8029e2e:	4414      	add	r4, r2
 8029e30:	e6c1      	b.n	8029bb6 <__adddf3+0xe6>
 8029e32:	bf00      	nop

08029e34 <__aeabi_dmul>:
 8029e34:	b570      	push	{r4, r5, r6, lr}
 8029e36:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8029e3a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8029e3e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8029e42:	bf1d      	ittte	ne
 8029e44:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8029e48:	ea94 0f0c 	teqne	r4, ip
 8029e4c:	ea95 0f0c 	teqne	r5, ip
 8029e50:	f000 f8de 	bleq	802a010 <__aeabi_dmul+0x1dc>
 8029e54:	442c      	add	r4, r5
 8029e56:	ea81 0603 	eor.w	r6, r1, r3
 8029e5a:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8029e5e:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8029e62:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8029e66:	bf18      	it	ne
 8029e68:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8029e6c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8029e70:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8029e74:	d038      	beq.n	8029ee8 <__aeabi_dmul+0xb4>
 8029e76:	fba0 ce02 	umull	ip, lr, r0, r2
 8029e7a:	f04f 0500 	mov.w	r5, #0
 8029e7e:	fbe1 e502 	umlal	lr, r5, r1, r2
 8029e82:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 8029e86:	fbe0 e503 	umlal	lr, r5, r0, r3
 8029e8a:	f04f 0600 	mov.w	r6, #0
 8029e8e:	fbe1 5603 	umlal	r5, r6, r1, r3
 8029e92:	f09c 0f00 	teq	ip, #0
 8029e96:	bf18      	it	ne
 8029e98:	f04e 0e01 	orrne.w	lr, lr, #1
 8029e9c:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 8029ea0:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8029ea4:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8029ea8:	d204      	bcs.n	8029eb4 <__aeabi_dmul+0x80>
 8029eaa:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 8029eae:	416d      	adcs	r5, r5
 8029eb0:	eb46 0606 	adc.w	r6, r6, r6
 8029eb4:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8029eb8:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8029ebc:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8029ec0:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8029ec4:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8029ec8:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8029ecc:	bf88      	it	hi
 8029ece:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8029ed2:	d81e      	bhi.n	8029f12 <__aeabi_dmul+0xde>
 8029ed4:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8029ed8:	bf08      	it	eq
 8029eda:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 8029ede:	f150 0000 	adcs.w	r0, r0, #0
 8029ee2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8029ee6:	bd70      	pop	{r4, r5, r6, pc}
 8029ee8:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8029eec:	ea46 0101 	orr.w	r1, r6, r1
 8029ef0:	ea40 0002 	orr.w	r0, r0, r2
 8029ef4:	ea81 0103 	eor.w	r1, r1, r3
 8029ef8:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8029efc:	bfc2      	ittt	gt
 8029efe:	ebd4 050c 	rsbsgt	r5, r4, ip
 8029f02:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8029f06:	bd70      	popgt	{r4, r5, r6, pc}
 8029f08:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8029f0c:	f04f 0e00 	mov.w	lr, #0
 8029f10:	3c01      	subs	r4, #1
 8029f12:	f300 80ab 	bgt.w	802a06c <__aeabi_dmul+0x238>
 8029f16:	f114 0f36 	cmn.w	r4, #54	; 0x36
 8029f1a:	bfde      	ittt	le
 8029f1c:	2000      	movle	r0, #0
 8029f1e:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 8029f22:	bd70      	pople	{r4, r5, r6, pc}
 8029f24:	f1c4 0400 	rsb	r4, r4, #0
 8029f28:	3c20      	subs	r4, #32
 8029f2a:	da35      	bge.n	8029f98 <__aeabi_dmul+0x164>
 8029f2c:	340c      	adds	r4, #12
 8029f2e:	dc1b      	bgt.n	8029f68 <__aeabi_dmul+0x134>
 8029f30:	f104 0414 	add.w	r4, r4, #20
 8029f34:	f1c4 0520 	rsb	r5, r4, #32
 8029f38:	fa00 f305 	lsl.w	r3, r0, r5
 8029f3c:	fa20 f004 	lsr.w	r0, r0, r4
 8029f40:	fa01 f205 	lsl.w	r2, r1, r5
 8029f44:	ea40 0002 	orr.w	r0, r0, r2
 8029f48:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8029f4c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8029f50:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8029f54:	fa21 f604 	lsr.w	r6, r1, r4
 8029f58:	eb42 0106 	adc.w	r1, r2, r6
 8029f5c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8029f60:	bf08      	it	eq
 8029f62:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8029f66:	bd70      	pop	{r4, r5, r6, pc}
 8029f68:	f1c4 040c 	rsb	r4, r4, #12
 8029f6c:	f1c4 0520 	rsb	r5, r4, #32
 8029f70:	fa00 f304 	lsl.w	r3, r0, r4
 8029f74:	fa20 f005 	lsr.w	r0, r0, r5
 8029f78:	fa01 f204 	lsl.w	r2, r1, r4
 8029f7c:	ea40 0002 	orr.w	r0, r0, r2
 8029f80:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8029f84:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8029f88:	f141 0100 	adc.w	r1, r1, #0
 8029f8c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8029f90:	bf08      	it	eq
 8029f92:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8029f96:	bd70      	pop	{r4, r5, r6, pc}
 8029f98:	f1c4 0520 	rsb	r5, r4, #32
 8029f9c:	fa00 f205 	lsl.w	r2, r0, r5
 8029fa0:	ea4e 0e02 	orr.w	lr, lr, r2
 8029fa4:	fa20 f304 	lsr.w	r3, r0, r4
 8029fa8:	fa01 f205 	lsl.w	r2, r1, r5
 8029fac:	ea43 0302 	orr.w	r3, r3, r2
 8029fb0:	fa21 f004 	lsr.w	r0, r1, r4
 8029fb4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8029fb8:	fa21 f204 	lsr.w	r2, r1, r4
 8029fbc:	ea20 0002 	bic.w	r0, r0, r2
 8029fc0:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8029fc4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8029fc8:	bf08      	it	eq
 8029fca:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8029fce:	bd70      	pop	{r4, r5, r6, pc}
 8029fd0:	f094 0f00 	teq	r4, #0
 8029fd4:	d10f      	bne.n	8029ff6 <__aeabi_dmul+0x1c2>
 8029fd6:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 8029fda:	0040      	lsls	r0, r0, #1
 8029fdc:	eb41 0101 	adc.w	r1, r1, r1
 8029fe0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8029fe4:	bf08      	it	eq
 8029fe6:	3c01      	subeq	r4, #1
 8029fe8:	d0f7      	beq.n	8029fda <__aeabi_dmul+0x1a6>
 8029fea:	ea41 0106 	orr.w	r1, r1, r6
 8029fee:	f095 0f00 	teq	r5, #0
 8029ff2:	bf18      	it	ne
 8029ff4:	4770      	bxne	lr
 8029ff6:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 8029ffa:	0052      	lsls	r2, r2, #1
 8029ffc:	eb43 0303 	adc.w	r3, r3, r3
 802a000:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 802a004:	bf08      	it	eq
 802a006:	3d01      	subeq	r5, #1
 802a008:	d0f7      	beq.n	8029ffa <__aeabi_dmul+0x1c6>
 802a00a:	ea43 0306 	orr.w	r3, r3, r6
 802a00e:	4770      	bx	lr
 802a010:	ea94 0f0c 	teq	r4, ip
 802a014:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 802a018:	bf18      	it	ne
 802a01a:	ea95 0f0c 	teqne	r5, ip
 802a01e:	d00c      	beq.n	802a03a <__aeabi_dmul+0x206>
 802a020:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 802a024:	bf18      	it	ne
 802a026:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 802a02a:	d1d1      	bne.n	8029fd0 <__aeabi_dmul+0x19c>
 802a02c:	ea81 0103 	eor.w	r1, r1, r3
 802a030:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 802a034:	f04f 0000 	mov.w	r0, #0
 802a038:	bd70      	pop	{r4, r5, r6, pc}
 802a03a:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 802a03e:	bf06      	itte	eq
 802a040:	4610      	moveq	r0, r2
 802a042:	4619      	moveq	r1, r3
 802a044:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 802a048:	d019      	beq.n	802a07e <__aeabi_dmul+0x24a>
 802a04a:	ea94 0f0c 	teq	r4, ip
 802a04e:	d102      	bne.n	802a056 <__aeabi_dmul+0x222>
 802a050:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 802a054:	d113      	bne.n	802a07e <__aeabi_dmul+0x24a>
 802a056:	ea95 0f0c 	teq	r5, ip
 802a05a:	d105      	bne.n	802a068 <__aeabi_dmul+0x234>
 802a05c:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 802a060:	bf1c      	itt	ne
 802a062:	4610      	movne	r0, r2
 802a064:	4619      	movne	r1, r3
 802a066:	d10a      	bne.n	802a07e <__aeabi_dmul+0x24a>
 802a068:	ea81 0103 	eor.w	r1, r1, r3
 802a06c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 802a070:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 802a074:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 802a078:	f04f 0000 	mov.w	r0, #0
 802a07c:	bd70      	pop	{r4, r5, r6, pc}
 802a07e:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 802a082:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 802a086:	bd70      	pop	{r4, r5, r6, pc}

0802a088 <__aeabi_ddiv>:
 802a088:	b570      	push	{r4, r5, r6, lr}
 802a08a:	f04f 0cff 	mov.w	ip, #255	; 0xff
 802a08e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 802a092:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 802a096:	bf1d      	ittte	ne
 802a098:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 802a09c:	ea94 0f0c 	teqne	r4, ip
 802a0a0:	ea95 0f0c 	teqne	r5, ip
 802a0a4:	f000 f8a7 	bleq	802a1f6 <__aeabi_ddiv+0x16e>
 802a0a8:	eba4 0405 	sub.w	r4, r4, r5
 802a0ac:	ea81 0e03 	eor.w	lr, r1, r3
 802a0b0:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 802a0b4:	ea4f 3101 	mov.w	r1, r1, lsl #12
 802a0b8:	f000 8088 	beq.w	802a1cc <__aeabi_ddiv+0x144>
 802a0bc:	ea4f 3303 	mov.w	r3, r3, lsl #12
 802a0c0:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 802a0c4:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 802a0c8:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 802a0cc:	ea4f 2202 	mov.w	r2, r2, lsl #8
 802a0d0:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 802a0d4:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 802a0d8:	ea4f 2600 	mov.w	r6, r0, lsl #8
 802a0dc:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 802a0e0:	429d      	cmp	r5, r3
 802a0e2:	bf08      	it	eq
 802a0e4:	4296      	cmpeq	r6, r2
 802a0e6:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 802a0ea:	f504 7440 	add.w	r4, r4, #768	; 0x300
 802a0ee:	d202      	bcs.n	802a0f6 <__aeabi_ddiv+0x6e>
 802a0f0:	085b      	lsrs	r3, r3, #1
 802a0f2:	ea4f 0232 	mov.w	r2, r2, rrx
 802a0f6:	1ab6      	subs	r6, r6, r2
 802a0f8:	eb65 0503 	sbc.w	r5, r5, r3
 802a0fc:	085b      	lsrs	r3, r3, #1
 802a0fe:	ea4f 0232 	mov.w	r2, r2, rrx
 802a102:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 802a106:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 802a10a:	ebb6 0e02 	subs.w	lr, r6, r2
 802a10e:	eb75 0e03 	sbcs.w	lr, r5, r3
 802a112:	bf22      	ittt	cs
 802a114:	1ab6      	subcs	r6, r6, r2
 802a116:	4675      	movcs	r5, lr
 802a118:	ea40 000c 	orrcs.w	r0, r0, ip
 802a11c:	085b      	lsrs	r3, r3, #1
 802a11e:	ea4f 0232 	mov.w	r2, r2, rrx
 802a122:	ebb6 0e02 	subs.w	lr, r6, r2
 802a126:	eb75 0e03 	sbcs.w	lr, r5, r3
 802a12a:	bf22      	ittt	cs
 802a12c:	1ab6      	subcs	r6, r6, r2
 802a12e:	4675      	movcs	r5, lr
 802a130:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 802a134:	085b      	lsrs	r3, r3, #1
 802a136:	ea4f 0232 	mov.w	r2, r2, rrx
 802a13a:	ebb6 0e02 	subs.w	lr, r6, r2
 802a13e:	eb75 0e03 	sbcs.w	lr, r5, r3
 802a142:	bf22      	ittt	cs
 802a144:	1ab6      	subcs	r6, r6, r2
 802a146:	4675      	movcs	r5, lr
 802a148:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 802a14c:	085b      	lsrs	r3, r3, #1
 802a14e:	ea4f 0232 	mov.w	r2, r2, rrx
 802a152:	ebb6 0e02 	subs.w	lr, r6, r2
 802a156:	eb75 0e03 	sbcs.w	lr, r5, r3
 802a15a:	bf22      	ittt	cs
 802a15c:	1ab6      	subcs	r6, r6, r2
 802a15e:	4675      	movcs	r5, lr
 802a160:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 802a164:	ea55 0e06 	orrs.w	lr, r5, r6
 802a168:	d018      	beq.n	802a19c <__aeabi_ddiv+0x114>
 802a16a:	ea4f 1505 	mov.w	r5, r5, lsl #4
 802a16e:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 802a172:	ea4f 1606 	mov.w	r6, r6, lsl #4
 802a176:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 802a17a:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 802a17e:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 802a182:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 802a186:	d1c0      	bne.n	802a10a <__aeabi_ddiv+0x82>
 802a188:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 802a18c:	d10b      	bne.n	802a1a6 <__aeabi_ddiv+0x11e>
 802a18e:	ea41 0100 	orr.w	r1, r1, r0
 802a192:	f04f 0000 	mov.w	r0, #0
 802a196:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 802a19a:	e7b6      	b.n	802a10a <__aeabi_ddiv+0x82>
 802a19c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 802a1a0:	bf04      	itt	eq
 802a1a2:	4301      	orreq	r1, r0
 802a1a4:	2000      	moveq	r0, #0
 802a1a6:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 802a1aa:	bf88      	it	hi
 802a1ac:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 802a1b0:	f63f aeaf 	bhi.w	8029f12 <__aeabi_dmul+0xde>
 802a1b4:	ebb5 0c03 	subs.w	ip, r5, r3
 802a1b8:	bf04      	itt	eq
 802a1ba:	ebb6 0c02 	subseq.w	ip, r6, r2
 802a1be:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 802a1c2:	f150 0000 	adcs.w	r0, r0, #0
 802a1c6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 802a1ca:	bd70      	pop	{r4, r5, r6, pc}
 802a1cc:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 802a1d0:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 802a1d4:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 802a1d8:	bfc2      	ittt	gt
 802a1da:	ebd4 050c 	rsbsgt	r5, r4, ip
 802a1de:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 802a1e2:	bd70      	popgt	{r4, r5, r6, pc}
 802a1e4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 802a1e8:	f04f 0e00 	mov.w	lr, #0
 802a1ec:	3c01      	subs	r4, #1
 802a1ee:	e690      	b.n	8029f12 <__aeabi_dmul+0xde>
 802a1f0:	ea45 0e06 	orr.w	lr, r5, r6
 802a1f4:	e68d      	b.n	8029f12 <__aeabi_dmul+0xde>
 802a1f6:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 802a1fa:	ea94 0f0c 	teq	r4, ip
 802a1fe:	bf08      	it	eq
 802a200:	ea95 0f0c 	teqeq	r5, ip
 802a204:	f43f af3b 	beq.w	802a07e <__aeabi_dmul+0x24a>
 802a208:	ea94 0f0c 	teq	r4, ip
 802a20c:	d10a      	bne.n	802a224 <__aeabi_ddiv+0x19c>
 802a20e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 802a212:	f47f af34 	bne.w	802a07e <__aeabi_dmul+0x24a>
 802a216:	ea95 0f0c 	teq	r5, ip
 802a21a:	f47f af25 	bne.w	802a068 <__aeabi_dmul+0x234>
 802a21e:	4610      	mov	r0, r2
 802a220:	4619      	mov	r1, r3
 802a222:	e72c      	b.n	802a07e <__aeabi_dmul+0x24a>
 802a224:	ea95 0f0c 	teq	r5, ip
 802a228:	d106      	bne.n	802a238 <__aeabi_ddiv+0x1b0>
 802a22a:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 802a22e:	f43f aefd 	beq.w	802a02c <__aeabi_dmul+0x1f8>
 802a232:	4610      	mov	r0, r2
 802a234:	4619      	mov	r1, r3
 802a236:	e722      	b.n	802a07e <__aeabi_dmul+0x24a>
 802a238:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 802a23c:	bf18      	it	ne
 802a23e:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 802a242:	f47f aec5 	bne.w	8029fd0 <__aeabi_dmul+0x19c>
 802a246:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 802a24a:	f47f af0d 	bne.w	802a068 <__aeabi_dmul+0x234>
 802a24e:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 802a252:	f47f aeeb 	bne.w	802a02c <__aeabi_dmul+0x1f8>
 802a256:	e712      	b.n	802a07e <__aeabi_dmul+0x24a>

0802a258 <__gedf2>:
 802a258:	f04f 3cff 	mov.w	ip, #4294967295
 802a25c:	e006      	b.n	802a26c <__cmpdf2+0x4>
 802a25e:	bf00      	nop

0802a260 <__ledf2>:
 802a260:	f04f 0c01 	mov.w	ip, #1
 802a264:	e002      	b.n	802a26c <__cmpdf2+0x4>
 802a266:	bf00      	nop

0802a268 <__cmpdf2>:
 802a268:	f04f 0c01 	mov.w	ip, #1
 802a26c:	f84d cd04 	str.w	ip, [sp, #-4]!
 802a270:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 802a274:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 802a278:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 802a27c:	bf18      	it	ne
 802a27e:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 802a282:	d01b      	beq.n	802a2bc <__cmpdf2+0x54>
 802a284:	b001      	add	sp, #4
 802a286:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 802a28a:	bf0c      	ite	eq
 802a28c:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 802a290:	ea91 0f03 	teqne	r1, r3
 802a294:	bf02      	ittt	eq
 802a296:	ea90 0f02 	teqeq	r0, r2
 802a29a:	2000      	moveq	r0, #0
 802a29c:	4770      	bxeq	lr
 802a29e:	f110 0f00 	cmn.w	r0, #0
 802a2a2:	ea91 0f03 	teq	r1, r3
 802a2a6:	bf58      	it	pl
 802a2a8:	4299      	cmppl	r1, r3
 802a2aa:	bf08      	it	eq
 802a2ac:	4290      	cmpeq	r0, r2
 802a2ae:	bf2c      	ite	cs
 802a2b0:	17d8      	asrcs	r0, r3, #31
 802a2b2:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 802a2b6:	f040 0001 	orr.w	r0, r0, #1
 802a2ba:	4770      	bx	lr
 802a2bc:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 802a2c0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 802a2c4:	d102      	bne.n	802a2cc <__cmpdf2+0x64>
 802a2c6:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 802a2ca:	d107      	bne.n	802a2dc <__cmpdf2+0x74>
 802a2cc:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 802a2d0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 802a2d4:	d1d6      	bne.n	802a284 <__cmpdf2+0x1c>
 802a2d6:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 802a2da:	d0d3      	beq.n	802a284 <__cmpdf2+0x1c>
 802a2dc:	f85d 0b04 	ldr.w	r0, [sp], #4
 802a2e0:	4770      	bx	lr
 802a2e2:	bf00      	nop

0802a2e4 <__aeabi_cdrcmple>:
 802a2e4:	4684      	mov	ip, r0
 802a2e6:	4610      	mov	r0, r2
 802a2e8:	4662      	mov	r2, ip
 802a2ea:	468c      	mov	ip, r1
 802a2ec:	4619      	mov	r1, r3
 802a2ee:	4663      	mov	r3, ip
 802a2f0:	e000      	b.n	802a2f4 <__aeabi_cdcmpeq>
 802a2f2:	bf00      	nop

0802a2f4 <__aeabi_cdcmpeq>:
 802a2f4:	b501      	push	{r0, lr}
 802a2f6:	f7ff ffb7 	bl	802a268 <__cmpdf2>
 802a2fa:	2800      	cmp	r0, #0
 802a2fc:	bf48      	it	mi
 802a2fe:	f110 0f00 	cmnmi.w	r0, #0
 802a302:	bd01      	pop	{r0, pc}

0802a304 <__aeabi_dcmpeq>:
 802a304:	f84d ed08 	str.w	lr, [sp, #-8]!
 802a308:	f7ff fff4 	bl	802a2f4 <__aeabi_cdcmpeq>
 802a30c:	bf0c      	ite	eq
 802a30e:	2001      	moveq	r0, #1
 802a310:	2000      	movne	r0, #0
 802a312:	f85d fb08 	ldr.w	pc, [sp], #8
 802a316:	bf00      	nop

0802a318 <__aeabi_dcmplt>:
 802a318:	f84d ed08 	str.w	lr, [sp, #-8]!
 802a31c:	f7ff ffea 	bl	802a2f4 <__aeabi_cdcmpeq>
 802a320:	bf34      	ite	cc
 802a322:	2001      	movcc	r0, #1
 802a324:	2000      	movcs	r0, #0
 802a326:	f85d fb08 	ldr.w	pc, [sp], #8
 802a32a:	bf00      	nop

0802a32c <__aeabi_dcmple>:
 802a32c:	f84d ed08 	str.w	lr, [sp, #-8]!
 802a330:	f7ff ffe0 	bl	802a2f4 <__aeabi_cdcmpeq>
 802a334:	bf94      	ite	ls
 802a336:	2001      	movls	r0, #1
 802a338:	2000      	movhi	r0, #0
 802a33a:	f85d fb08 	ldr.w	pc, [sp], #8
 802a33e:	bf00      	nop

0802a340 <__aeabi_dcmpge>:
 802a340:	f84d ed08 	str.w	lr, [sp, #-8]!
 802a344:	f7ff ffce 	bl	802a2e4 <__aeabi_cdrcmple>
 802a348:	bf94      	ite	ls
 802a34a:	2001      	movls	r0, #1
 802a34c:	2000      	movhi	r0, #0
 802a34e:	f85d fb08 	ldr.w	pc, [sp], #8
 802a352:	bf00      	nop

0802a354 <__aeabi_dcmpgt>:
 802a354:	f84d ed08 	str.w	lr, [sp, #-8]!
 802a358:	f7ff ffc4 	bl	802a2e4 <__aeabi_cdrcmple>
 802a35c:	bf34      	ite	cc
 802a35e:	2001      	movcc	r0, #1
 802a360:	2000      	movcs	r0, #0
 802a362:	f85d fb08 	ldr.w	pc, [sp], #8
 802a366:	bf00      	nop

0802a368 <__aeabi_d2iz>:
 802a368:	ea4f 0241 	mov.w	r2, r1, lsl #1
 802a36c:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 802a370:	d215      	bcs.n	802a39e <__aeabi_d2iz+0x36>
 802a372:	d511      	bpl.n	802a398 <__aeabi_d2iz+0x30>
 802a374:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 802a378:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 802a37c:	d912      	bls.n	802a3a4 <__aeabi_d2iz+0x3c>
 802a37e:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 802a382:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 802a386:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 802a38a:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 802a38e:	fa23 f002 	lsr.w	r0, r3, r2
 802a392:	bf18      	it	ne
 802a394:	4240      	negne	r0, r0
 802a396:	4770      	bx	lr
 802a398:	f04f 0000 	mov.w	r0, #0
 802a39c:	4770      	bx	lr
 802a39e:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 802a3a2:	d105      	bne.n	802a3b0 <__aeabi_d2iz+0x48>
 802a3a4:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 802a3a8:	bf08      	it	eq
 802a3aa:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 802a3ae:	4770      	bx	lr
 802a3b0:	f04f 0000 	mov.w	r0, #0
 802a3b4:	4770      	bx	lr
 802a3b6:	bf00      	nop

0802a3b8 <__aeabi_d2uiz>:
 802a3b8:	004a      	lsls	r2, r1, #1
 802a3ba:	d211      	bcs.n	802a3e0 <__aeabi_d2uiz+0x28>
 802a3bc:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 802a3c0:	d211      	bcs.n	802a3e6 <__aeabi_d2uiz+0x2e>
 802a3c2:	d50d      	bpl.n	802a3e0 <__aeabi_d2uiz+0x28>
 802a3c4:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 802a3c8:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 802a3cc:	d40e      	bmi.n	802a3ec <__aeabi_d2uiz+0x34>
 802a3ce:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 802a3d2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 802a3d6:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 802a3da:	fa23 f002 	lsr.w	r0, r3, r2
 802a3de:	4770      	bx	lr
 802a3e0:	f04f 0000 	mov.w	r0, #0
 802a3e4:	4770      	bx	lr
 802a3e6:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 802a3ea:	d102      	bne.n	802a3f2 <__aeabi_d2uiz+0x3a>
 802a3ec:	f04f 30ff 	mov.w	r0, #4294967295
 802a3f0:	4770      	bx	lr
 802a3f2:	f04f 0000 	mov.w	r0, #0
 802a3f6:	4770      	bx	lr

0802a3f8 <__aeabi_d2f>:
 802a3f8:	ea4f 0241 	mov.w	r2, r1, lsl #1
 802a3fc:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 802a400:	bf24      	itt	cs
 802a402:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 802a406:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 802a40a:	d90d      	bls.n	802a428 <__aeabi_d2f+0x30>
 802a40c:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 802a410:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 802a414:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 802a418:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 802a41c:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 802a420:	bf08      	it	eq
 802a422:	f020 0001 	biceq.w	r0, r0, #1
 802a426:	4770      	bx	lr
 802a428:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 802a42c:	d121      	bne.n	802a472 <__aeabi_d2f+0x7a>
 802a42e:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 802a432:	bfbc      	itt	lt
 802a434:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 802a438:	4770      	bxlt	lr
 802a43a:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 802a43e:	ea4f 5252 	mov.w	r2, r2, lsr #21
 802a442:	f1c2 0218 	rsb	r2, r2, #24
 802a446:	f1c2 0c20 	rsb	ip, r2, #32
 802a44a:	fa10 f30c 	lsls.w	r3, r0, ip
 802a44e:	fa20 f002 	lsr.w	r0, r0, r2
 802a452:	bf18      	it	ne
 802a454:	f040 0001 	orrne.w	r0, r0, #1
 802a458:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 802a45c:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 802a460:	fa03 fc0c 	lsl.w	ip, r3, ip
 802a464:	ea40 000c 	orr.w	r0, r0, ip
 802a468:	fa23 f302 	lsr.w	r3, r3, r2
 802a46c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 802a470:	e7cc      	b.n	802a40c <__aeabi_d2f+0x14>
 802a472:	ea7f 5362 	mvns.w	r3, r2, asr #21
 802a476:	d107      	bne.n	802a488 <__aeabi_d2f+0x90>
 802a478:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 802a47c:	bf1e      	ittt	ne
 802a47e:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 802a482:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 802a486:	4770      	bxne	lr
 802a488:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 802a48c:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 802a490:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 802a494:	4770      	bx	lr
 802a496:	bf00      	nop

0802a498 <__aeabi_uldivmod>:
 802a498:	b94b      	cbnz	r3, 802a4ae <__aeabi_uldivmod+0x16>
 802a49a:	b942      	cbnz	r2, 802a4ae <__aeabi_uldivmod+0x16>
 802a49c:	2900      	cmp	r1, #0
 802a49e:	bf08      	it	eq
 802a4a0:	2800      	cmpeq	r0, #0
 802a4a2:	d002      	beq.n	802a4aa <__aeabi_uldivmod+0x12>
 802a4a4:	f04f 31ff 	mov.w	r1, #4294967295
 802a4a8:	4608      	mov	r0, r1
 802a4aa:	f000 b877 	b.w	802a59c <__aeabi_idiv0>
 802a4ae:	b082      	sub	sp, #8
 802a4b0:	46ec      	mov	ip, sp
 802a4b2:	e92d 5000 	stmdb	sp!, {ip, lr}
 802a4b6:	f000 f859 	bl	802a56c <__gnu_uldivmod_helper>
 802a4ba:	f8dd e004 	ldr.w	lr, [sp, #4]
 802a4be:	b002      	add	sp, #8
 802a4c0:	bc0c      	pop	{r2, r3}
 802a4c2:	4770      	bx	lr

0802a4c4 <__aeabi_d2lz>:
 802a4c4:	b538      	push	{r3, r4, r5, lr}
 802a4c6:	2200      	movs	r2, #0
 802a4c8:	2300      	movs	r3, #0
 802a4ca:	4604      	mov	r4, r0
 802a4cc:	460d      	mov	r5, r1
 802a4ce:	f7ff ff23 	bl	802a318 <__aeabi_dcmplt>
 802a4d2:	b928      	cbnz	r0, 802a4e0 <__aeabi_d2lz+0x1c>
 802a4d4:	4620      	mov	r0, r4
 802a4d6:	4629      	mov	r1, r5
 802a4d8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 802a4dc:	f000 b80a 	b.w	802a4f4 <__aeabi_d2ulz>
 802a4e0:	4620      	mov	r0, r4
 802a4e2:	f105 4100 	add.w	r1, r5, #2147483648	; 0x80000000
 802a4e6:	f000 f805 	bl	802a4f4 <__aeabi_d2ulz>
 802a4ea:	4240      	negs	r0, r0
 802a4ec:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 802a4f0:	bd38      	pop	{r3, r4, r5, pc}
 802a4f2:	bf00      	nop

0802a4f4 <__aeabi_d2ulz>:
 802a4f4:	b5d0      	push	{r4, r6, r7, lr}
 802a4f6:	2200      	movs	r2, #0
 802a4f8:	4b0e      	ldr	r3, [pc, #56]	; (802a534 <__aeabi_d2ulz+0x40>)
 802a4fa:	4606      	mov	r6, r0
 802a4fc:	460f      	mov	r7, r1
 802a4fe:	f7ff fc99 	bl	8029e34 <__aeabi_dmul>
 802a502:	f7ff ff59 	bl	802a3b8 <__aeabi_d2uiz>
 802a506:	4604      	mov	r4, r0
 802a508:	f7ff fc1e 	bl	8029d48 <__aeabi_ui2d>
 802a50c:	2200      	movs	r2, #0
 802a50e:	4b0a      	ldr	r3, [pc, #40]	; (802a538 <__aeabi_d2ulz+0x44>)
 802a510:	f7ff fc90 	bl	8029e34 <__aeabi_dmul>
 802a514:	4602      	mov	r2, r0
 802a516:	460b      	mov	r3, r1
 802a518:	4630      	mov	r0, r6
 802a51a:	4639      	mov	r1, r7
 802a51c:	f7ff fad6 	bl	8029acc <__aeabi_dsub>
 802a520:	f7ff ff4a 	bl	802a3b8 <__aeabi_d2uiz>
 802a524:	4623      	mov	r3, r4
 802a526:	2200      	movs	r2, #0
 802a528:	ea42 0200 	orr.w	r2, r2, r0
 802a52c:	4610      	mov	r0, r2
 802a52e:	4619      	mov	r1, r3
 802a530:	bdd0      	pop	{r4, r6, r7, pc}
 802a532:	bf00      	nop
 802a534:	3df00000 	.word	0x3df00000
 802a538:	41f00000 	.word	0x41f00000

0802a53c <__gnu_ldivmod_helper>:
 802a53c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802a540:	9c06      	ldr	r4, [sp, #24]
 802a542:	4615      	mov	r5, r2
 802a544:	4606      	mov	r6, r0
 802a546:	460f      	mov	r7, r1
 802a548:	4698      	mov	r8, r3
 802a54a:	f000 f829 	bl	802a5a0 <__divdi3>
 802a54e:	fb05 f301 	mul.w	r3, r5, r1
 802a552:	fb00 3808 	mla	r8, r0, r8, r3
 802a556:	fba5 2300 	umull	r2, r3, r5, r0
 802a55a:	1ab2      	subs	r2, r6, r2
 802a55c:	4443      	add	r3, r8
 802a55e:	eb67 0303 	sbc.w	r3, r7, r3
 802a562:	e9c4 2300 	strd	r2, r3, [r4]
 802a566:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802a56a:	bf00      	nop

0802a56c <__gnu_uldivmod_helper>:
 802a56c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802a570:	9c06      	ldr	r4, [sp, #24]
 802a572:	4690      	mov	r8, r2
 802a574:	4606      	mov	r6, r0
 802a576:	460f      	mov	r7, r1
 802a578:	461d      	mov	r5, r3
 802a57a:	f000 f95f 	bl	802a83c <__udivdi3>
 802a57e:	fb00 f505 	mul.w	r5, r0, r5
 802a582:	fba0 2308 	umull	r2, r3, r0, r8
 802a586:	fb08 5501 	mla	r5, r8, r1, r5
 802a58a:	1ab2      	subs	r2, r6, r2
 802a58c:	442b      	add	r3, r5
 802a58e:	eb67 0303 	sbc.w	r3, r7, r3
 802a592:	e9c4 2300 	strd	r2, r3, [r4]
 802a596:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802a59a:	bf00      	nop

0802a59c <__aeabi_idiv0>:
 802a59c:	4770      	bx	lr
 802a59e:	bf00      	nop

0802a5a0 <__divdi3>:
 802a5a0:	2900      	cmp	r1, #0
 802a5a2:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 802a5a6:	f2c0 80a6 	blt.w	802a6f6 <__divdi3+0x156>
 802a5aa:	2600      	movs	r6, #0
 802a5ac:	2b00      	cmp	r3, #0
 802a5ae:	f2c0 809c 	blt.w	802a6ea <__divdi3+0x14a>
 802a5b2:	4688      	mov	r8, r1
 802a5b4:	4694      	mov	ip, r2
 802a5b6:	469e      	mov	lr, r3
 802a5b8:	4615      	mov	r5, r2
 802a5ba:	4604      	mov	r4, r0
 802a5bc:	460f      	mov	r7, r1
 802a5be:	2b00      	cmp	r3, #0
 802a5c0:	d13d      	bne.n	802a63e <__divdi3+0x9e>
 802a5c2:	428a      	cmp	r2, r1
 802a5c4:	d959      	bls.n	802a67a <__divdi3+0xda>
 802a5c6:	fab2 f382 	clz	r3, r2
 802a5ca:	b13b      	cbz	r3, 802a5dc <__divdi3+0x3c>
 802a5cc:	f1c3 0220 	rsb	r2, r3, #32
 802a5d0:	409f      	lsls	r7, r3
 802a5d2:	fa20 f202 	lsr.w	r2, r0, r2
 802a5d6:	409d      	lsls	r5, r3
 802a5d8:	4317      	orrs	r7, r2
 802a5da:	409c      	lsls	r4, r3
 802a5dc:	0c29      	lsrs	r1, r5, #16
 802a5de:	0c22      	lsrs	r2, r4, #16
 802a5e0:	fbb7 fef1 	udiv	lr, r7, r1
 802a5e4:	b2a8      	uxth	r0, r5
 802a5e6:	fb01 771e 	mls	r7, r1, lr, r7
 802a5ea:	ea42 4707 	orr.w	r7, r2, r7, lsl #16
 802a5ee:	fb00 f30e 	mul.w	r3, r0, lr
 802a5f2:	42bb      	cmp	r3, r7
 802a5f4:	d90a      	bls.n	802a60c <__divdi3+0x6c>
 802a5f6:	197f      	adds	r7, r7, r5
 802a5f8:	f10e 32ff 	add.w	r2, lr, #4294967295
 802a5fc:	f080 8105 	bcs.w	802a80a <__divdi3+0x26a>
 802a600:	42bb      	cmp	r3, r7
 802a602:	f240 8102 	bls.w	802a80a <__divdi3+0x26a>
 802a606:	f1ae 0e02 	sub.w	lr, lr, #2
 802a60a:	442f      	add	r7, r5
 802a60c:	1aff      	subs	r7, r7, r3
 802a60e:	b2a4      	uxth	r4, r4
 802a610:	fbb7 f3f1 	udiv	r3, r7, r1
 802a614:	fb01 7713 	mls	r7, r1, r3, r7
 802a618:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
 802a61c:	fb00 f003 	mul.w	r0, r0, r3
 802a620:	42b8      	cmp	r0, r7
 802a622:	d908      	bls.n	802a636 <__divdi3+0x96>
 802a624:	197f      	adds	r7, r7, r5
 802a626:	f103 32ff 	add.w	r2, r3, #4294967295
 802a62a:	f080 80f0 	bcs.w	802a80e <__divdi3+0x26e>
 802a62e:	42b8      	cmp	r0, r7
 802a630:	f240 80ed 	bls.w	802a80e <__divdi3+0x26e>
 802a634:	3b02      	subs	r3, #2
 802a636:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
 802a63a:	2200      	movs	r2, #0
 802a63c:	e003      	b.n	802a646 <__divdi3+0xa6>
 802a63e:	428b      	cmp	r3, r1
 802a640:	d90f      	bls.n	802a662 <__divdi3+0xc2>
 802a642:	2200      	movs	r2, #0
 802a644:	4613      	mov	r3, r2
 802a646:	1c34      	adds	r4, r6, #0
 802a648:	bf18      	it	ne
 802a64a:	2401      	movne	r4, #1
 802a64c:	4260      	negs	r0, r4
 802a64e:	f04f 0500 	mov.w	r5, #0
 802a652:	eb65 0145 	sbc.w	r1, r5, r5, lsl #1
 802a656:	4058      	eors	r0, r3
 802a658:	4051      	eors	r1, r2
 802a65a:	1900      	adds	r0, r0, r4
 802a65c:	4169      	adcs	r1, r5
 802a65e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 802a662:	fab3 f283 	clz	r2, r3
 802a666:	2a00      	cmp	r2, #0
 802a668:	f040 8086 	bne.w	802a778 <__divdi3+0x1d8>
 802a66c:	428b      	cmp	r3, r1
 802a66e:	d302      	bcc.n	802a676 <__divdi3+0xd6>
 802a670:	4584      	cmp	ip, r0
 802a672:	f200 80db 	bhi.w	802a82c <__divdi3+0x28c>
 802a676:	2301      	movs	r3, #1
 802a678:	e7e5      	b.n	802a646 <__divdi3+0xa6>
 802a67a:	b912      	cbnz	r2, 802a682 <__divdi3+0xe2>
 802a67c:	2301      	movs	r3, #1
 802a67e:	fbb3 f5f2 	udiv	r5, r3, r2
 802a682:	fab5 f085 	clz	r0, r5
 802a686:	2800      	cmp	r0, #0
 802a688:	d13b      	bne.n	802a702 <__divdi3+0x162>
 802a68a:	1b78      	subs	r0, r7, r5
 802a68c:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 802a690:	fa1f fc85 	uxth.w	ip, r5
 802a694:	2201      	movs	r2, #1
 802a696:	fbb0 f8fe 	udiv	r8, r0, lr
 802a69a:	0c21      	lsrs	r1, r4, #16
 802a69c:	fb0e 0718 	mls	r7, lr, r8, r0
 802a6a0:	ea41 4707 	orr.w	r7, r1, r7, lsl #16
 802a6a4:	fb0c f308 	mul.w	r3, ip, r8
 802a6a8:	42bb      	cmp	r3, r7
 802a6aa:	d907      	bls.n	802a6bc <__divdi3+0x11c>
 802a6ac:	197f      	adds	r7, r7, r5
 802a6ae:	f108 31ff 	add.w	r1, r8, #4294967295
 802a6b2:	d202      	bcs.n	802a6ba <__divdi3+0x11a>
 802a6b4:	42bb      	cmp	r3, r7
 802a6b6:	f200 80bd 	bhi.w	802a834 <__divdi3+0x294>
 802a6ba:	4688      	mov	r8, r1
 802a6bc:	1aff      	subs	r7, r7, r3
 802a6be:	b2a4      	uxth	r4, r4
 802a6c0:	fbb7 f3fe 	udiv	r3, r7, lr
 802a6c4:	fb0e 7713 	mls	r7, lr, r3, r7
 802a6c8:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
 802a6cc:	fb0c fc03 	mul.w	ip, ip, r3
 802a6d0:	45bc      	cmp	ip, r7
 802a6d2:	d907      	bls.n	802a6e4 <__divdi3+0x144>
 802a6d4:	197f      	adds	r7, r7, r5
 802a6d6:	f103 31ff 	add.w	r1, r3, #4294967295
 802a6da:	d202      	bcs.n	802a6e2 <__divdi3+0x142>
 802a6dc:	45bc      	cmp	ip, r7
 802a6de:	f200 80a7 	bhi.w	802a830 <__divdi3+0x290>
 802a6e2:	460b      	mov	r3, r1
 802a6e4:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 802a6e8:	e7ad      	b.n	802a646 <__divdi3+0xa6>
 802a6ea:	4252      	negs	r2, r2
 802a6ec:	ea6f 0606 	mvn.w	r6, r6
 802a6f0:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 802a6f4:	e75d      	b.n	802a5b2 <__divdi3+0x12>
 802a6f6:	4240      	negs	r0, r0
 802a6f8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 802a6fc:	f04f 36ff 	mov.w	r6, #4294967295
 802a700:	e754      	b.n	802a5ac <__divdi3+0xc>
 802a702:	f1c0 0220 	rsb	r2, r0, #32
 802a706:	fa24 f102 	lsr.w	r1, r4, r2
 802a70a:	fa07 f300 	lsl.w	r3, r7, r0
 802a70e:	4085      	lsls	r5, r0
 802a710:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 802a714:	40d7      	lsrs	r7, r2
 802a716:	4319      	orrs	r1, r3
 802a718:	fbb7 f2fe 	udiv	r2, r7, lr
 802a71c:	0c0b      	lsrs	r3, r1, #16
 802a71e:	fb0e 7712 	mls	r7, lr, r2, r7
 802a722:	fa1f fc85 	uxth.w	ip, r5
 802a726:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 802a72a:	fb0c f702 	mul.w	r7, ip, r2
 802a72e:	429f      	cmp	r7, r3
 802a730:	fa04 f400 	lsl.w	r4, r4, r0
 802a734:	d907      	bls.n	802a746 <__divdi3+0x1a6>
 802a736:	195b      	adds	r3, r3, r5
 802a738:	f102 30ff 	add.w	r0, r2, #4294967295
 802a73c:	d274      	bcs.n	802a828 <__divdi3+0x288>
 802a73e:	429f      	cmp	r7, r3
 802a740:	d972      	bls.n	802a828 <__divdi3+0x288>
 802a742:	3a02      	subs	r2, #2
 802a744:	442b      	add	r3, r5
 802a746:	1bdf      	subs	r7, r3, r7
 802a748:	b289      	uxth	r1, r1
 802a74a:	fbb7 f8fe 	udiv	r8, r7, lr
 802a74e:	fb0e 7318 	mls	r3, lr, r8, r7
 802a752:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 802a756:	fb0c f708 	mul.w	r7, ip, r8
 802a75a:	429f      	cmp	r7, r3
 802a75c:	d908      	bls.n	802a770 <__divdi3+0x1d0>
 802a75e:	195b      	adds	r3, r3, r5
 802a760:	f108 31ff 	add.w	r1, r8, #4294967295
 802a764:	d25c      	bcs.n	802a820 <__divdi3+0x280>
 802a766:	429f      	cmp	r7, r3
 802a768:	d95a      	bls.n	802a820 <__divdi3+0x280>
 802a76a:	f1a8 0802 	sub.w	r8, r8, #2
 802a76e:	442b      	add	r3, r5
 802a770:	1bd8      	subs	r0, r3, r7
 802a772:	ea48 4202 	orr.w	r2, r8, r2, lsl #16
 802a776:	e78e      	b.n	802a696 <__divdi3+0xf6>
 802a778:	f1c2 0320 	rsb	r3, r2, #32
 802a77c:	fa2c f103 	lsr.w	r1, ip, r3
 802a780:	fa0e fe02 	lsl.w	lr, lr, r2
 802a784:	fa20 f703 	lsr.w	r7, r0, r3
 802a788:	ea41 0e0e 	orr.w	lr, r1, lr
 802a78c:	fa08 f002 	lsl.w	r0, r8, r2
 802a790:	fa28 f103 	lsr.w	r1, r8, r3
 802a794:	ea4f 451e 	mov.w	r5, lr, lsr #16
 802a798:	4338      	orrs	r0, r7
 802a79a:	fbb1 f8f5 	udiv	r8, r1, r5
 802a79e:	0c03      	lsrs	r3, r0, #16
 802a7a0:	fb05 1118 	mls	r1, r5, r8, r1
 802a7a4:	fa1f f78e 	uxth.w	r7, lr
 802a7a8:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 802a7ac:	fb07 f308 	mul.w	r3, r7, r8
 802a7b0:	428b      	cmp	r3, r1
 802a7b2:	fa0c fc02 	lsl.w	ip, ip, r2
 802a7b6:	d909      	bls.n	802a7cc <__divdi3+0x22c>
 802a7b8:	eb11 010e 	adds.w	r1, r1, lr
 802a7bc:	f108 39ff 	add.w	r9, r8, #4294967295
 802a7c0:	d230      	bcs.n	802a824 <__divdi3+0x284>
 802a7c2:	428b      	cmp	r3, r1
 802a7c4:	d92e      	bls.n	802a824 <__divdi3+0x284>
 802a7c6:	f1a8 0802 	sub.w	r8, r8, #2
 802a7ca:	4471      	add	r1, lr
 802a7cc:	1ac9      	subs	r1, r1, r3
 802a7ce:	b280      	uxth	r0, r0
 802a7d0:	fbb1 f3f5 	udiv	r3, r1, r5
 802a7d4:	fb05 1113 	mls	r1, r5, r3, r1
 802a7d8:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 802a7dc:	fb07 f703 	mul.w	r7, r7, r3
 802a7e0:	428f      	cmp	r7, r1
 802a7e2:	d908      	bls.n	802a7f6 <__divdi3+0x256>
 802a7e4:	eb11 010e 	adds.w	r1, r1, lr
 802a7e8:	f103 30ff 	add.w	r0, r3, #4294967295
 802a7ec:	d216      	bcs.n	802a81c <__divdi3+0x27c>
 802a7ee:	428f      	cmp	r7, r1
 802a7f0:	d914      	bls.n	802a81c <__divdi3+0x27c>
 802a7f2:	3b02      	subs	r3, #2
 802a7f4:	4471      	add	r1, lr
 802a7f6:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 802a7fa:	1bc9      	subs	r1, r1, r7
 802a7fc:	fba3 890c 	umull	r8, r9, r3, ip
 802a800:	4549      	cmp	r1, r9
 802a802:	d309      	bcc.n	802a818 <__divdi3+0x278>
 802a804:	d005      	beq.n	802a812 <__divdi3+0x272>
 802a806:	2200      	movs	r2, #0
 802a808:	e71d      	b.n	802a646 <__divdi3+0xa6>
 802a80a:	4696      	mov	lr, r2
 802a80c:	e6fe      	b.n	802a60c <__divdi3+0x6c>
 802a80e:	4613      	mov	r3, r2
 802a810:	e711      	b.n	802a636 <__divdi3+0x96>
 802a812:	4094      	lsls	r4, r2
 802a814:	4544      	cmp	r4, r8
 802a816:	d2f6      	bcs.n	802a806 <__divdi3+0x266>
 802a818:	3b01      	subs	r3, #1
 802a81a:	e7f4      	b.n	802a806 <__divdi3+0x266>
 802a81c:	4603      	mov	r3, r0
 802a81e:	e7ea      	b.n	802a7f6 <__divdi3+0x256>
 802a820:	4688      	mov	r8, r1
 802a822:	e7a5      	b.n	802a770 <__divdi3+0x1d0>
 802a824:	46c8      	mov	r8, r9
 802a826:	e7d1      	b.n	802a7cc <__divdi3+0x22c>
 802a828:	4602      	mov	r2, r0
 802a82a:	e78c      	b.n	802a746 <__divdi3+0x1a6>
 802a82c:	4613      	mov	r3, r2
 802a82e:	e70a      	b.n	802a646 <__divdi3+0xa6>
 802a830:	3b02      	subs	r3, #2
 802a832:	e757      	b.n	802a6e4 <__divdi3+0x144>
 802a834:	f1a8 0802 	sub.w	r8, r8, #2
 802a838:	442f      	add	r7, r5
 802a83a:	e73f      	b.n	802a6bc <__divdi3+0x11c>

0802a83c <__udivdi3>:
 802a83c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802a840:	2b00      	cmp	r3, #0
 802a842:	d144      	bne.n	802a8ce <__udivdi3+0x92>
 802a844:	428a      	cmp	r2, r1
 802a846:	4615      	mov	r5, r2
 802a848:	4604      	mov	r4, r0
 802a84a:	d94f      	bls.n	802a8ec <__udivdi3+0xb0>
 802a84c:	fab2 f782 	clz	r7, r2
 802a850:	460e      	mov	r6, r1
 802a852:	b14f      	cbz	r7, 802a868 <__udivdi3+0x2c>
 802a854:	f1c7 0320 	rsb	r3, r7, #32
 802a858:	40b9      	lsls	r1, r7
 802a85a:	fa20 f603 	lsr.w	r6, r0, r3
 802a85e:	fa02 f507 	lsl.w	r5, r2, r7
 802a862:	430e      	orrs	r6, r1
 802a864:	fa00 f407 	lsl.w	r4, r0, r7
 802a868:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 802a86c:	0c23      	lsrs	r3, r4, #16
 802a86e:	fbb6 f0fe 	udiv	r0, r6, lr
 802a872:	b2af      	uxth	r7, r5
 802a874:	fb0e 6110 	mls	r1, lr, r0, r6
 802a878:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 802a87c:	fb07 f100 	mul.w	r1, r7, r0
 802a880:	4299      	cmp	r1, r3
 802a882:	d909      	bls.n	802a898 <__udivdi3+0x5c>
 802a884:	195b      	adds	r3, r3, r5
 802a886:	f100 32ff 	add.w	r2, r0, #4294967295
 802a88a:	f080 80ec 	bcs.w	802aa66 <__udivdi3+0x22a>
 802a88e:	4299      	cmp	r1, r3
 802a890:	f240 80e9 	bls.w	802aa66 <__udivdi3+0x22a>
 802a894:	3802      	subs	r0, #2
 802a896:	442b      	add	r3, r5
 802a898:	1a5a      	subs	r2, r3, r1
 802a89a:	b2a4      	uxth	r4, r4
 802a89c:	fbb2 f3fe 	udiv	r3, r2, lr
 802a8a0:	fb0e 2213 	mls	r2, lr, r3, r2
 802a8a4:	ea44 4202 	orr.w	r2, r4, r2, lsl #16
 802a8a8:	fb07 f703 	mul.w	r7, r7, r3
 802a8ac:	4297      	cmp	r7, r2
 802a8ae:	d908      	bls.n	802a8c2 <__udivdi3+0x86>
 802a8b0:	1952      	adds	r2, r2, r5
 802a8b2:	f103 31ff 	add.w	r1, r3, #4294967295
 802a8b6:	f080 80d8 	bcs.w	802aa6a <__udivdi3+0x22e>
 802a8ba:	4297      	cmp	r7, r2
 802a8bc:	f240 80d5 	bls.w	802aa6a <__udivdi3+0x22e>
 802a8c0:	3b02      	subs	r3, #2
 802a8c2:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 802a8c6:	2600      	movs	r6, #0
 802a8c8:	4631      	mov	r1, r6
 802a8ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802a8ce:	428b      	cmp	r3, r1
 802a8d0:	d847      	bhi.n	802a962 <__udivdi3+0x126>
 802a8d2:	fab3 f683 	clz	r6, r3
 802a8d6:	2e00      	cmp	r6, #0
 802a8d8:	d148      	bne.n	802a96c <__udivdi3+0x130>
 802a8da:	428b      	cmp	r3, r1
 802a8dc:	d302      	bcc.n	802a8e4 <__udivdi3+0xa8>
 802a8de:	4282      	cmp	r2, r0
 802a8e0:	f200 80cd 	bhi.w	802aa7e <__udivdi3+0x242>
 802a8e4:	2001      	movs	r0, #1
 802a8e6:	4631      	mov	r1, r6
 802a8e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802a8ec:	b912      	cbnz	r2, 802a8f4 <__udivdi3+0xb8>
 802a8ee:	2501      	movs	r5, #1
 802a8f0:	fbb5 f5f2 	udiv	r5, r5, r2
 802a8f4:	fab5 f885 	clz	r8, r5
 802a8f8:	f1b8 0f00 	cmp.w	r8, #0
 802a8fc:	d177      	bne.n	802a9ee <__udivdi3+0x1b2>
 802a8fe:	1b4a      	subs	r2, r1, r5
 802a900:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 802a904:	b2af      	uxth	r7, r5
 802a906:	2601      	movs	r6, #1
 802a908:	fbb2 f0fe 	udiv	r0, r2, lr
 802a90c:	0c23      	lsrs	r3, r4, #16
 802a90e:	fb0e 2110 	mls	r1, lr, r0, r2
 802a912:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 802a916:	fb07 f300 	mul.w	r3, r7, r0
 802a91a:	428b      	cmp	r3, r1
 802a91c:	d907      	bls.n	802a92e <__udivdi3+0xf2>
 802a91e:	1949      	adds	r1, r1, r5
 802a920:	f100 32ff 	add.w	r2, r0, #4294967295
 802a924:	d202      	bcs.n	802a92c <__udivdi3+0xf0>
 802a926:	428b      	cmp	r3, r1
 802a928:	f200 80ba 	bhi.w	802aaa0 <__udivdi3+0x264>
 802a92c:	4610      	mov	r0, r2
 802a92e:	1ac9      	subs	r1, r1, r3
 802a930:	b2a4      	uxth	r4, r4
 802a932:	fbb1 f3fe 	udiv	r3, r1, lr
 802a936:	fb0e 1113 	mls	r1, lr, r3, r1
 802a93a:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
 802a93e:	fb07 f703 	mul.w	r7, r7, r3
 802a942:	42a7      	cmp	r7, r4
 802a944:	d908      	bls.n	802a958 <__udivdi3+0x11c>
 802a946:	1964      	adds	r4, r4, r5
 802a948:	f103 32ff 	add.w	r2, r3, #4294967295
 802a94c:	f080 808f 	bcs.w	802aa6e <__udivdi3+0x232>
 802a950:	42a7      	cmp	r7, r4
 802a952:	f240 808c 	bls.w	802aa6e <__udivdi3+0x232>
 802a956:	3b02      	subs	r3, #2
 802a958:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 802a95c:	4631      	mov	r1, r6
 802a95e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802a962:	2600      	movs	r6, #0
 802a964:	4630      	mov	r0, r6
 802a966:	4631      	mov	r1, r6
 802a968:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802a96c:	f1c6 0420 	rsb	r4, r6, #32
 802a970:	fa22 f504 	lsr.w	r5, r2, r4
 802a974:	40b3      	lsls	r3, r6
 802a976:	432b      	orrs	r3, r5
 802a978:	fa20 fc04 	lsr.w	ip, r0, r4
 802a97c:	fa01 f706 	lsl.w	r7, r1, r6
 802a980:	fa21 f504 	lsr.w	r5, r1, r4
 802a984:	ea4f 4e13 	mov.w	lr, r3, lsr #16
 802a988:	ea4c 0707 	orr.w	r7, ip, r7
 802a98c:	fbb5 f8fe 	udiv	r8, r5, lr
 802a990:	0c39      	lsrs	r1, r7, #16
 802a992:	fb0e 5518 	mls	r5, lr, r8, r5
 802a996:	fa1f fc83 	uxth.w	ip, r3
 802a99a:	ea41 4505 	orr.w	r5, r1, r5, lsl #16
 802a99e:	fb0c f108 	mul.w	r1, ip, r8
 802a9a2:	42a9      	cmp	r1, r5
 802a9a4:	fa02 f206 	lsl.w	r2, r2, r6
 802a9a8:	d904      	bls.n	802a9b4 <__udivdi3+0x178>
 802a9aa:	18ed      	adds	r5, r5, r3
 802a9ac:	f108 34ff 	add.w	r4, r8, #4294967295
 802a9b0:	d367      	bcc.n	802aa82 <__udivdi3+0x246>
 802a9b2:	46a0      	mov	r8, r4
 802a9b4:	1a6d      	subs	r5, r5, r1
 802a9b6:	b2bf      	uxth	r7, r7
 802a9b8:	fbb5 f4fe 	udiv	r4, r5, lr
 802a9bc:	fb0e 5514 	mls	r5, lr, r4, r5
 802a9c0:	ea47 4105 	orr.w	r1, r7, r5, lsl #16
 802a9c4:	fb0c fc04 	mul.w	ip, ip, r4
 802a9c8:	458c      	cmp	ip, r1
 802a9ca:	d904      	bls.n	802a9d6 <__udivdi3+0x19a>
 802a9cc:	18c9      	adds	r1, r1, r3
 802a9ce:	f104 35ff 	add.w	r5, r4, #4294967295
 802a9d2:	d35c      	bcc.n	802aa8e <__udivdi3+0x252>
 802a9d4:	462c      	mov	r4, r5
 802a9d6:	ea44 4408 	orr.w	r4, r4, r8, lsl #16
 802a9da:	ebcc 0101 	rsb	r1, ip, r1
 802a9de:	fba4 2302 	umull	r2, r3, r4, r2
 802a9e2:	4299      	cmp	r1, r3
 802a9e4:	d348      	bcc.n	802aa78 <__udivdi3+0x23c>
 802a9e6:	d044      	beq.n	802aa72 <__udivdi3+0x236>
 802a9e8:	4620      	mov	r0, r4
 802a9ea:	2600      	movs	r6, #0
 802a9ec:	e76c      	b.n	802a8c8 <__udivdi3+0x8c>
 802a9ee:	f1c8 0420 	rsb	r4, r8, #32
 802a9f2:	fa01 f308 	lsl.w	r3, r1, r8
 802a9f6:	fa05 f508 	lsl.w	r5, r5, r8
 802a9fa:	fa20 f704 	lsr.w	r7, r0, r4
 802a9fe:	40e1      	lsrs	r1, r4
 802aa00:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 802aa04:	431f      	orrs	r7, r3
 802aa06:	fbb1 f6fe 	udiv	r6, r1, lr
 802aa0a:	0c3a      	lsrs	r2, r7, #16
 802aa0c:	fb0e 1116 	mls	r1, lr, r6, r1
 802aa10:	fa1f fc85 	uxth.w	ip, r5
 802aa14:	ea42 4301 	orr.w	r3, r2, r1, lsl #16
 802aa18:	fb0c f206 	mul.w	r2, ip, r6
 802aa1c:	429a      	cmp	r2, r3
 802aa1e:	fa00 f408 	lsl.w	r4, r0, r8
 802aa22:	d907      	bls.n	802aa34 <__udivdi3+0x1f8>
 802aa24:	195b      	adds	r3, r3, r5
 802aa26:	f106 31ff 	add.w	r1, r6, #4294967295
 802aa2a:	d237      	bcs.n	802aa9c <__udivdi3+0x260>
 802aa2c:	429a      	cmp	r2, r3
 802aa2e:	d935      	bls.n	802aa9c <__udivdi3+0x260>
 802aa30:	3e02      	subs	r6, #2
 802aa32:	442b      	add	r3, r5
 802aa34:	1a9b      	subs	r3, r3, r2
 802aa36:	b2bf      	uxth	r7, r7
 802aa38:	fbb3 f0fe 	udiv	r0, r3, lr
 802aa3c:	fb0e 3310 	mls	r3, lr, r0, r3
 802aa40:	ea47 4303 	orr.w	r3, r7, r3, lsl #16
 802aa44:	fb0c f100 	mul.w	r1, ip, r0
 802aa48:	4299      	cmp	r1, r3
 802aa4a:	d907      	bls.n	802aa5c <__udivdi3+0x220>
 802aa4c:	195b      	adds	r3, r3, r5
 802aa4e:	f100 32ff 	add.w	r2, r0, #4294967295
 802aa52:	d221      	bcs.n	802aa98 <__udivdi3+0x25c>
 802aa54:	4299      	cmp	r1, r3
 802aa56:	d91f      	bls.n	802aa98 <__udivdi3+0x25c>
 802aa58:	3802      	subs	r0, #2
 802aa5a:	442b      	add	r3, r5
 802aa5c:	1a5a      	subs	r2, r3, r1
 802aa5e:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
 802aa62:	4667      	mov	r7, ip
 802aa64:	e750      	b.n	802a908 <__udivdi3+0xcc>
 802aa66:	4610      	mov	r0, r2
 802aa68:	e716      	b.n	802a898 <__udivdi3+0x5c>
 802aa6a:	460b      	mov	r3, r1
 802aa6c:	e729      	b.n	802a8c2 <__udivdi3+0x86>
 802aa6e:	4613      	mov	r3, r2
 802aa70:	e772      	b.n	802a958 <__udivdi3+0x11c>
 802aa72:	40b0      	lsls	r0, r6
 802aa74:	4290      	cmp	r0, r2
 802aa76:	d2b7      	bcs.n	802a9e8 <__udivdi3+0x1ac>
 802aa78:	1e60      	subs	r0, r4, #1
 802aa7a:	2600      	movs	r6, #0
 802aa7c:	e724      	b.n	802a8c8 <__udivdi3+0x8c>
 802aa7e:	4630      	mov	r0, r6
 802aa80:	e722      	b.n	802a8c8 <__udivdi3+0x8c>
 802aa82:	42a9      	cmp	r1, r5
 802aa84:	d995      	bls.n	802a9b2 <__udivdi3+0x176>
 802aa86:	f1a8 0802 	sub.w	r8, r8, #2
 802aa8a:	441d      	add	r5, r3
 802aa8c:	e792      	b.n	802a9b4 <__udivdi3+0x178>
 802aa8e:	458c      	cmp	ip, r1
 802aa90:	d9a0      	bls.n	802a9d4 <__udivdi3+0x198>
 802aa92:	3c02      	subs	r4, #2
 802aa94:	4419      	add	r1, r3
 802aa96:	e79e      	b.n	802a9d6 <__udivdi3+0x19a>
 802aa98:	4610      	mov	r0, r2
 802aa9a:	e7df      	b.n	802aa5c <__udivdi3+0x220>
 802aa9c:	460e      	mov	r6, r1
 802aa9e:	e7c9      	b.n	802aa34 <__udivdi3+0x1f8>
 802aaa0:	3802      	subs	r0, #2
 802aaa2:	4429      	add	r1, r5
 802aaa4:	e743      	b.n	802a92e <__udivdi3+0xf2>
 802aaa6:	bf00      	nop

0802aaa8 <__errno>:
 802aaa8:	4b01      	ldr	r3, [pc, #4]	; (802aab0 <__errno+0x8>)
 802aaaa:	6818      	ldr	r0, [r3, #0]
 802aaac:	4770      	bx	lr
 802aaae:	bf00      	nop
 802aab0:	1ffe8bdc 	.word	0x1ffe8bdc

0802aab4 <__libc_init_array>:
 802aab4:	b570      	push	{r4, r5, r6, lr}
 802aab6:	4b0e      	ldr	r3, [pc, #56]	; (802aaf0 <__libc_init_array+0x3c>)
 802aab8:	4c0e      	ldr	r4, [pc, #56]	; (802aaf4 <__libc_init_array+0x40>)
 802aaba:	1ae4      	subs	r4, r4, r3
 802aabc:	10a4      	asrs	r4, r4, #2
 802aabe:	2500      	movs	r5, #0
 802aac0:	461e      	mov	r6, r3
 802aac2:	42a5      	cmp	r5, r4
 802aac4:	d004      	beq.n	802aad0 <__libc_init_array+0x1c>
 802aac6:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 802aaca:	4798      	blx	r3
 802aacc:	3501      	adds	r5, #1
 802aace:	e7f8      	b.n	802aac2 <__libc_init_array+0xe>
 802aad0:	f7f8 ff20 	bl	8023914 <_init>
 802aad4:	4c08      	ldr	r4, [pc, #32]	; (802aaf8 <__libc_init_array+0x44>)
 802aad6:	4b09      	ldr	r3, [pc, #36]	; (802aafc <__libc_init_array+0x48>)
 802aad8:	1ae4      	subs	r4, r4, r3
 802aada:	10a4      	asrs	r4, r4, #2
 802aadc:	2500      	movs	r5, #0
 802aade:	461e      	mov	r6, r3
 802aae0:	42a5      	cmp	r5, r4
 802aae2:	d004      	beq.n	802aaee <__libc_init_array+0x3a>
 802aae4:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 802aae8:	4798      	blx	r3
 802aaea:	3501      	adds	r5, #1
 802aaec:	e7f8      	b.n	802aae0 <__libc_init_array+0x2c>
 802aaee:	bd70      	pop	{r4, r5, r6, pc}
 802aaf0:	1ffe8be0 	.word	0x1ffe8be0
 802aaf4:	1ffe8be0 	.word	0x1ffe8be0
 802aaf8:	1ffe8be0 	.word	0x1ffe8be0
 802aafc:	1ffe8be0 	.word	0x1ffe8be0

0802ab00 <memcmp>:
 802ab00:	b510      	push	{r4, lr}
 802ab02:	440a      	add	r2, r1
 802ab04:	1e44      	subs	r4, r0, #1
 802ab06:	4291      	cmp	r1, r2
 802ab08:	d008      	beq.n	802ab1c <memcmp+0x1c>
 802ab0a:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 802ab0e:	7808      	ldrb	r0, [r1, #0]
 802ab10:	4283      	cmp	r3, r0
 802ab12:	d001      	beq.n	802ab18 <memcmp+0x18>
 802ab14:	1a18      	subs	r0, r3, r0
 802ab16:	bd10      	pop	{r4, pc}
 802ab18:	3101      	adds	r1, #1
 802ab1a:	e7f4      	b.n	802ab06 <memcmp+0x6>
 802ab1c:	2000      	movs	r0, #0
 802ab1e:	bd10      	pop	{r4, pc}

0802ab20 <memcpy>:
 802ab20:	b510      	push	{r4, lr}
 802ab22:	1e43      	subs	r3, r0, #1
 802ab24:	440a      	add	r2, r1
 802ab26:	4291      	cmp	r1, r2
 802ab28:	d004      	beq.n	802ab34 <memcpy+0x14>
 802ab2a:	f811 4b01 	ldrb.w	r4, [r1], #1
 802ab2e:	f803 4f01 	strb.w	r4, [r3, #1]!
 802ab32:	e7f8      	b.n	802ab26 <memcpy+0x6>
 802ab34:	bd10      	pop	{r4, pc}

0802ab36 <memset>:
 802ab36:	4402      	add	r2, r0
 802ab38:	4603      	mov	r3, r0
 802ab3a:	4293      	cmp	r3, r2
 802ab3c:	d002      	beq.n	802ab44 <memset+0xe>
 802ab3e:	f803 1b01 	strb.w	r1, [r3], #1
 802ab42:	e7fa      	b.n	802ab3a <memset+0x4>
 802ab44:	4770      	bx	lr
	...

0802ab48 <ds_default_device_settings>:
 802ab48:	012c 0000 0560 4bb8 4bd4 4bb7 d274 4bb8     ,...`..K.K.Kt..K
 802ab58:	0000 4348 0010 0000 0001 0000 42ab 0003     ..HC.........B..
 802ab68:	000c 0004 0701 0001 49f0 0002 0040 0000     .........I..@...
 802ab78:	0003 0000 0000 0000 0000 0000 0000 0000     ................
 802ab88:	0000 0000 6f50 6973 6974 6e6f 4732 206f     ....Position2Go 
 802ab98:	4742 3254 4d34 5254 3231 4420 6d65 206f     BGT24MTR12 Demo 
 802aba8:	6152 6164 2072 6f42 7261 0064               Radar Board.

0802abb4 <cg_device_info_struct>:
 802abb4:	ab8c 0802 97a8 016e a4e8 0171 0201 0107     ......n...q.....
 802abc4:	0201 0100                                   ....

0802abc8 <driver_version_s>:
 802abc8:	0001 0003                                   ....

0802abcc <CSWTCH.37>:
	...
 802abd4:	0002 0000 0002 0000 000c 0000 000c 0000     ................
 802abe4:	000c 0000 000c 0000 0008 0000 000a 0000     ................

0802abf4 <CSWTCH.38>:
 802abf4:	0003 0000 0003 0000 000c 0000 000c 0000     ................
 802ac04:	3000 0000 3000 0000 3000 0000 3000 0000     .0...0...0...0..
 802ac14:	0300 0000 0c00 0000                         ........

0802ac1c <CSWTCH.43>:
 802ac1c:	0003 0000 0003 0000 000c 0000 000c 0000     ................
 802ac2c:	0030 0000 0030 0000 3000 0000 3000 0000     0...0....0...0..
 802ac3c:	0300 0000 0c00 0000                         ........

0802ac44 <CSWTCH.44>:
	...
 802ac4c:	0002 0000 0002 0000 0004 0000 0004 0000     ................
 802ac5c:	000c 0000 000c 0000 0008 0000 000a 0000     ................

0802ac6c <Driver_USBD0>:
 802ac6c:	21c5 0802 2825 0802 2541 0802 21e1 0802     .!..%(..A%...!..
 802ac7c:	21f9 0802 2211 0802 2329 0802 2565 0802     .!..."..)#..e%..
 802ac8c:	2411 0802 2341 0802 29f1 0802 27e5 0802     .$..A#...)...'..
 802ac9c:	2ad1 0802 23cd 0802 2511 0802 2525 0802     .*...#...%..%%..

0802acac <g_xmc_vadc_group_array>:
 802acac:	4400 4000 4800 4000 4c00 4000 5000 4000     .D.@.H.@.L.@.P.@

0802acbc <product_string>:
 802acbc:	0310 0049 0046 0058 0020 0043 0044 0043     ..I.F.X. .C.D.C.
	...

0802ad24 <device_descriptor>:
 802ad24:	0112 0110 0002 4000 058b 0058 0001 0201     .......@..X.....
 802ad34:	0100 0000                                   ....

0802ad38 <language_string>:
 802ad38:	0304 0409 0000 0000 0000 0000 0000 0000     ................
	...

0802ada0 <manufacturer_string>:
 802ada0:	0312 0049 006e 0066 0069 006e 0065 006f     ..I.n.f.i.n.e.o.
 802adb0:	006e 0000 0000 0000 0000 0000 0000 0000     n...............
	...

0802ae08 <CSWTCH.1>:
 802ae08:	ad38 0802 ada0 0802 acbc 0802               8...........

0802ae14 <CSWTCH.2>:
 802ae14:	0004 0012 0010 0000                         ........

0802ae1c <configuration_descriptor>:
 802ae1c:	0209 003e 0102 8000 0932 0004 0100 0202     ..>.....2.......
 802ae2c:	0001 2405 1000 0401 0224 0506 0624 0100     ...$....$...$...
 802ae3c:	0507 0381 0008 09ff 0104 0200 000a 0000     ................
 802ae4c:	0507 0203 0040 0701 8205 4002 0100 0000     ....@......@....

0802ae5c <INTERRUPT_WATCHDOG>:
 802ae5c:	3d39 0100                                   9=..

0802ae60 <INTERRUPT_FRAME>:
 802ae60:	3d38 0100                                   8=..

0802ae64 <group_init_handle0>:
	...
 802ae74:	0080 0000                                   ....

0802ae78 <group_init_handle1>:
	...
 802ae88:	0080 0000                                   ....

0802ae8c <group_init_handle3>:
	...
 802ae9c:	0080 0000                                   ....

0802aea0 <global_config>:
 802aea0:	0000 0000 0004 0000 0000 0000 0000 0000     ................
	...

0802aeb8 <group_init_handle2>:
	...
 802aec8:	0080 0000                                   ....

0802aecc <e_eeprom_xmc4_fce>:
 802aecc:	0020 5002 0700 0000 0000 0000                ..P........

0802aed8 <EVENT_GENERATOR_CCU4_OGU_Config>:
 802aed8:	4014 0000                                   .@..

0802aedc <EVENT_DETECTOR_PLL_TRIG1_ETL_Config>:
 802aedc:	0000 0000 0006 0000                         ........

0802aee4 <DIGITAL_IO_BGT_LDO_ENABLE>:
 802aee4:	8400 4802 0080 0000 0001 0000 0000 0000     ...H............
 802aef4:	0003 0000                                   ....

0802aef8 <DIGITAL_IO_PLL_CE>:
 802aef8:	8200 4802 0080 0000 0000 0001 0001 0000     ...H............
 802af08:	0002 0000                                   ....

0802af0c <DIGITAL_IO_SPI_DATA_PGA>:
 802af0c:	8500 4802 0080 0000 0000 0001 0000 0000     ...H............
 802af1c:	0001 0000                                   ....

0802af20 <DIGITAL_IO_SPI_M_CLK>:
 802af20:	8800 4802 0080 0000 0000 0001 0000 0000     ...H............
 802af30:	0005 0000                                   ....

0802af34 <DIGITAL_IO_SPI_M_CS_PGA>:
 802af34:	8800 4802 0080 0000 0001 0000 0000 0000     ...H............
 802af44:	0004 0000                                   ....

0802af48 <DIGITAL_IO_PLL_TRIG1>:
 802af48:	8100 4802 0000 0000 0000 0000 0000 0000     ...H............
 802af58:	0003 0000                                   ....

0802af5c <DIGITAL_IO_PLL_TRIG2>:
 802af5c:	8100 4802 0080 0000 0000 0001 0000 0000     ...H............
 802af6c:	0001 0000                                   ....

0802af70 <DIGITAL_IO_PLL_MOD>:
 802af70:	8100 4802 0000 0000 0000 0000 0000 0000     ...H............
 802af80:	0002 0000                                   ....

0802af84 <DIGITAL_IO_SPI_M_CS_PLL>:
 802af84:	8100 4802 0080 0000 0001 0000 0000 0000     ...H............
 802af94:	0008 0000                                   ....

0802af98 <DIGITAL_IO_PLL_MUXIN>:
 802af98:	8100 4802 0000 0000 0000 0000 0000 0000     ...H............
 802afa8:	0000 0000                                   ....

0802afac <DIGITAL_IO_SPI_M_CS_BGT24>:
 802afac:	8800 4802 0080 0000 0001 0000 0000 0000     ...H............
 802afbc:	0006 0000                                   ....

0802afc0 <DIGITAL_IO_LED1>:
 802afc0:	8700 4802 0080 0000 0000 0001 0000 0000     ...H............
 802afd0:	0008 0000                                   ....

0802afd4 <DIGITAL_IO_PGA_LDO_ENABLE>:
 802afd4:	8700 4802 0080 0000 0001 0000 0000 0000     ...H............
 802afe4:	000b 0000                                   ....

0802afe8 <DIGITAL_IO_SPI_M_DATA>:
 802afe8:	8800 4802 0080 0000 0000 0001 0000 0000     ...H............
 802aff8:	0007 0000                                   ....

0802affc <DIGITAL_IO_BGT_POWER_ENABLE>:
 802affc:	8200 4802 0080 0000 0000 0001 0000 0000     ...H............
 802b00c:	0003 0000 0315 0101 0000 0001 0000 0000     ................
 802b01c:	0000 0001 0102 0101                         ........

0802b024 <CCU4_SLICE_CONFIG_ADC_TRIG_event1_config>:
 802b024:	0203 0001                                   ....

0802b028 <CCU4_SLICE_CONFIG_ADC_TRIG_event2_config>:
 802b028:	0000 0000                                   ....

0802b02c <CCU4_SLICE_CONFIG_ADC_TRIG>:
 802b02c:	7169 0802 8970 1ffe 4400 4800 0003 0000     iq..p....D.H....

0802b03c <CCU4_SLICE_CONFIG_ADC_TRIG_compare_config>:
 802b03c:	0004 0000 00f0 0000                         ........

0802b044 <CCU4_SLICE_CONFIG_ADC_TRIG_event0_config>:
 802b044:	0103 0001                                   ....

0802b048 <group_ptrs>:
 802b048:	4400 4000 4800 4000 4c00 4000 5000 4000     .D.@.H.@.L.@.P.@

0802b058 <ADC_MEASUREMENT_ADV_G4_queue_handle>:
	...
 802b06c:	b1a4 0802 0001 0001                         ........

0802b074 <ADC_MEASUREMENT_ADV_G3_IF2_I_res_config>:
 802b074:	0000 8000                                   ....

0802b078 <ADC_MEASUREMENT_ADV_G2_queue_handle>:
	...
 802b08c:	b0a4 0802 0001 0000                         ........

0802b094 <ADC_MEASUREMENT_ADV_G4_IF2_Q_ch_config>:
 802b094:	0401 0024 0000 0000 0000 0000 ff01 0000     ..$.............

0802b0a4 <ADC_MEASUREMENT_ADV_G2_queue_config>:
 802b0a4:	000c 0000 4500 0000 0004 0000               .....E......

0802b0b0 <ADC_MEASUREMENT_SCAN_BGT24_ANA_res_config>:
 802b0b0:	0000 0000                                   ....

0802b0b4 <ADC_MEASUREMENT_ADV_G1_IF1_I_ch_config>:
 802b0b4:	0000 002f 0000 0000 0000 0000 ff01 0000     ../.............

0802b0c4 <ADC_MEASUREMENT_SCAN>:
 802b0c4:	8b0c 1ffe 0000 0000 0000 0000 b230 0802     ............0...
 802b0d4:	8b14 1ffe 0001 0103 0101 0000               ............

0802b0e0 <ADC_MEASUREMENT_ADV_G3_IF2_I_handle>:
 802b0e0:	b190 0802 b074 0802 0302 0000               ....t.......

0802b0ec <ADC_MEASUREMENT_ADV_G3_IF2_I_queue_entry_0>:
 802b0ec:	00a3 0000                                   ....

0802b0f0 <ADC_MEASUREMENT_SCAN_BGT24_ANA_ch_config>:
 802b0f0:	0000 0029 0000 0000 0000 0000 ff01 0000     ..).............

0802b100 <ADC_MEASUREMENT_ADV_G2_IF1_Q_queue_entry_0>:
 802b100:	00a6 0000                                   ....

0802b104 <ADC_MEASUREMENT_ADV_G2_IF1_Q_ch_config>:
 802b104:	0400 0023 0000 0000 0000 0000 ff01 0000     ..#.............

0802b114 <ADC_MEASUREMENT_ADV_G1_queue_config>:
 802b114:	000c 0000 4500 0000 0004 0000               .....E......

0802b120 <ADC_MEASUREMENT_ADV_G1_queue_handle>:
	...
 802b134:	b114 0802 0001 0000                         ........

0802b13c <ADC_MEASUREMENT_SCAN_BGT24_ANA_handle>:
 802b13c:	b0f0 0802 b0b0 0802 0503 0000               ............

0802b148 <ADC_MEASUREMENT_ADV_G1_IF1_I_handle>:
 802b148:	b0b4 0802 b1a0 0802 0400 0000               ............

0802b154 <ADC_MEASUREMENT_ADV_G3_queue_handle>:
	...
 802b168:	b170 0802 0001 0000                         p.......

0802b170 <ADC_MEASUREMENT_ADV_G3_queue_config>:
 802b170:	000c 0000 4500 0000 0004 0000               .....E......

0802b17c <ADC_MEASUREMENT_ADV_G4_IF2_Q_handle>:
 802b17c:	b094 0802 b22c 0802 0003 0000               ....,.......

0802b188 <ADC_MEASUREMENT_ADV_G4_IF2_Q_queue_entry_0>:
 802b188:	00a0 0000                                   ....

0802b18c <ADC_MEASUREMENT_ADV_G2_IF1_Q_res_config>:
 802b18c:	0000 8000                                   ....

0802b190 <ADC_MEASUREMENT_ADV_G3_IF2_I_ch_config>:
 802b190:	0400 0020 0000 0000 0000 0000 ff01 0000     .. .............

0802b1a0 <ADC_MEASUREMENT_ADV_G1_IF1_I_res_config>:
 802b1a0:	0000 8000                                   ....

0802b1a4 <ADC_MEASUREMENT_ADV_G4_queue_config>:
 802b1a4:	000c 0000 4500 0000 0004 0000               .....E......

0802b1b0 <ADC_MEASUREMENT_ADV_G1>:
 802b1b0:	8af0 1ffe 8b08 1ffe 76f5 0802 b120 0802     .........v.. ...
 802b1c0:	8af8 1ffe 0e03 0100 0101 0001               ............

0802b1cc <ADC_MEASUREMENT_ADV_G2>:
 802b1cc:	8af4 1ffe 8b00 1ffe 7705 0802 b078 0802     .........w..x...
 802b1dc:	8af9 1ffe 0003 0101 0101 0001               ............

0802b1e8 <ADC_MEASUREMENT_ADV_G3>:
 802b1e8:	8aec 1ffe 8b04 1ffe 7715 0802 b154 0802     .........w..T...
 802b1f8:	8afa 1ffe 0003 0102 0101 0001               ............

0802b204 <ADC_MEASUREMENT_ADV_G4>:
 802b204:	8b10 1ffe 8afc 1ffe 7725 0802 b058 0802     ........%w..X...
 802b214:	8afb 1ffe 0003 0103 0101 0001               ............

0802b220 <ADC_MEASUREMENT_ADV_G2_IF1_Q_handle>:
 802b220:	b104 0802 b18c 0802 0601 0000               ............

0802b22c <ADC_MEASUREMENT_ADV_G4_IF2_Q_res_config>:
 802b22c:	0000 8000                                   ....

0802b230 <ADC_MEASUREMENT_SCAN_scan_handle>:
	...
 802b244:	b258 0802 0001 0000 0020 0000 0000 0000     X....... .......

0802b254 <ADC_MEASUREMENT_ADV_G1_IF1_I_queue_entry_0>:
 802b254:	00a4 0000                                   ....

0802b258 <ADC_MEASUREMENT_SCAN_scan_config>:
	...
 802b260:	0020 0000                                    ...

0802b264 <CSWTCH.9>:
 802b264:	1000 3020 5040 7060 6f6c 6667 0000 0000     .. 0@P`plogf....
 802b274:	0043 0000                                   C...
