
P2G_FMCW.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00000294  08000000  0c000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00011f8c  08020000  0c020000  00010000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .ARM.exidx    00000008  08031f8c  0c031f8c  00021f8c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 Stack         00000800  1ffe8000  1ffe8000  00030000  2**0
                  ALLOC
  4 .data         00000ee0  1ffe8800  0c031f94  00028800  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          0002444c  1ffe96e0  0c032e74  000296e0  2**3
                  ALLOC
  6 USB_RAM       00000e00  2000db2c  2000db2c  0002db2c  2**2
                  ALLOC
  7 ETH_RAM       00000004  2000e92c  2000e92c  0002db2c  2**0
                  ALLOC
  8 .no_init      00000014  2003ffc0  2003ffc0  0002ffc0  2**2
                  ALLOC
  9 .debug_aranges 00002198  00000000  00000000  000296e0  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   00098fc7  00000000  00000000  0002b878  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00010a19  00000000  00000000  000c483f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00022507  00000000  00000000  000d5258  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00006400  00000000  00000000  000f7760  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0001af4e  00000000  00000000  000fdb60  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00024876  00000000  00000000  00118aae  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00006438  00000000  00000000  0013d324  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .build_attributes 00001d9d  00000000  00000000  0014375c  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

08020000 <store_algo_result>:
   4. EXPORTED FUNCTIONS
==============================================================================
 */

void store_algo_result(algo_result_t *p_result)
{
 8020000:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  algo_target_list_t *p_curr_target_list = p_result->p_target_list;
 8020004:	6846      	ldr	r6, [r0, #4]
 8020006:	f8df 904c 	ldr.w	r9, [pc, #76]	; 8020054 <store_algo_result+0x54>
   4. EXPORTED FUNCTIONS
==============================================================================
 */

void store_algo_result(algo_result_t *p_result)
{
 802000a:	4680      	mov	r8, r0
  algo_target_list_t *p_curr_target_list = p_result->p_target_list;
  uint32_t index;

  for(index = 0; index < p_curr_target_list->max_num_of_targets; index++)
 802000c:	6870      	ldr	r0, [r6, #4]
 802000e:	b1b0      	cbz	r0, 802003e <store_algo_result+0x3e>
 8020010:	4633      	mov	r3, r6
 8020012:	464a      	mov	r2, r9
 8020014:	2100      	movs	r1, #0
 8020016:	3101      	adds	r1, #1
 */

static void copy_target_elem(ds_target_elem_t *p_dst, target_data_t *p_src)
{
  p_dst->target_id  = p_src->idx;
  p_dst->strength   = p_src->strength;
 8020018:	691f      	ldr	r7, [r3, #16]
  p_dst->speed      = p_src->speed;
 802001a:	f8d3 c018 	ldr.w	ip, [r3, #24]
  p_dst->range      = p_src->range;
 802001e:	f8d3 e014 	ldr.w	lr, [r3, #20]
  p_dst->angle      = p_src->angle;
 8020022:	69dc      	ldr	r4, [r3, #28]
==============================================================================
 */

static void copy_target_elem(ds_target_elem_t *p_dst, target_data_t *p_src)
{
  p_dst->target_id  = p_src->idx;
 8020024:	68dd      	ldr	r5, [r3, #12]
 8020026:	6095      	str	r5, [r2, #8]
void store_algo_result(algo_result_t *p_result)
{
  algo_target_list_t *p_curr_target_list = p_result->p_target_list;
  uint32_t index;

  for(index = 0; index < p_curr_target_list->max_num_of_targets; index++)
 8020028:	4281      	cmp	r1, r0
 */

static void copy_target_elem(ds_target_elem_t *p_dst, target_data_t *p_src)
{
  p_dst->target_id  = p_src->idx;
  p_dst->strength   = p_src->strength;
 802002a:	6197      	str	r7, [r2, #24]
  p_dst->speed      = p_src->speed;
 802002c:	f8c2 c010 	str.w	ip, [r2, #16]
  p_dst->range      = p_src->range;
 8020030:	f8c2 e00c 	str.w	lr, [r2, #12]
 8020034:	f103 0314 	add.w	r3, r3, #20
  p_dst->angle      = p_src->angle;
 8020038:	f842 4f14 	str.w	r4, [r2, #20]!
void store_algo_result(algo_result_t *p_result)
{
  algo_target_list_t *p_curr_target_list = p_result->p_target_list;
  uint32_t index;

  for(index = 0; index < p_curr_target_list->max_num_of_targets; index++)
 802003c:	d1eb      	bne.n	8020016 <store_algo_result+0x16>
  {
    copy_target_elem(&ds_target_list.elems[index], &p_curr_target_list->elems[index]);
  }
  ds_target_list.max_num_of_targets = p_curr_target_list->max_num_of_targets;
  ds_target_list.used_num_of_targets = p_curr_target_list->num_of_targets;
 802003e:	6831      	ldr	r1, [r6, #0]

  result_range_detection_threshold = p_result->range_detection_threshold;
 8020040:	4b03      	ldr	r3, [pc, #12]	; (8020050 <store_algo_result+0x50>)
 8020042:	f8d8 2000 	ldr.w	r2, [r8]
 8020046:	601a      	str	r2, [r3, #0]

  for(index = 0; index < p_curr_target_list->max_num_of_targets; index++)
  {
    copy_target_elem(&ds_target_list.elems[index], &p_curr_target_list->elems[index]);
  }
  ds_target_list.max_num_of_targets = p_curr_target_list->max_num_of_targets;
 8020048:	e889 0003 	stmia.w	r9, {r0, r1}
  ds_target_list.used_num_of_targets = p_curr_target_list->num_of_targets;

  result_range_detection_threshold = p_result->range_detection_threshold;
 802004c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8020050:	1ffe96e0 	.word	0x1ffe96e0
 8020054:	1ffe8800 	.word	0x1ffe8800

08020058 <ds_get_target_list>:
//============================================================================

ds_target_list_t *ds_get_target_list(void)
{
	return &ds_target_list;
}
 8020058:	4800      	ldr	r0, [pc, #0]	; (802005c <ds_get_target_list+0x4>)
 802005a:	4770      	bx	lr
 802005c:	1ffe8800 	.word	0x1ffe8800

08020060 <ds_algo_store_settings>:

//============================================================================

void ds_algo_store_settings(algo_settings_t *p_algo_settings)
{
 8020060:	4601      	mov	r1, r0
  memcpy(&ds_algo_settings, p_algo_settings, sizeof(ds_algo_settings));
 8020062:	224c      	movs	r2, #76	; 0x4c
 8020064:	4801      	ldr	r0, [pc, #4]	; (802006c <ds_algo_store_settings+0xc>)
 8020066:	f00e bd9f 	b.w	802eba8 <memcpy>
 802006a:	bf00      	nop
 802006c:	1ffe96e4 	.word	0x1ffe96e4

08020070 <ds_algo_fetch_settings>:
//============================================================================

void ds_algo_fetch_settings(algo_settings_t *p_algo_settings)
{
  /* Data structures are aligned, so no need to do a assignment by member */
  memcpy(p_algo_settings, &ds_algo_settings, sizeof(ds_algo_settings));
 8020070:	4901      	ldr	r1, [pc, #4]	; (8020078 <ds_algo_fetch_settings+0x8>)
 8020072:	224c      	movs	r2, #76	; 0x4c
 8020074:	f00e bd98 	b.w	802eba8 <memcpy>
 8020078:	1ffe96e4 	.word	0x1ffe96e4

0802007c <ds_algo_get_settings>:
//============================================================================

algo_settings_t *ds_algo_get_settings(void)
{
  return &ds_algo_settings;
}
 802007c:	4800      	ldr	r0, [pc, #0]	; (8020080 <ds_algo_get_settings+0x4>)
 802007e:	4770      	bx	lr
 8020080:	1ffe96e4 	.word	0x1ffe96e4

08020084 <ds_algo_check_settings>:
 */
uint32_t ds_algo_check_settings(algo_settings_t *ptr)
{
  uint32_t retValue = 0;
  
  if((ptr->tracking_enable != 0) && (ptr->tracking_enable != 1))
 8020084:	68c3      	ldr	r3, [r0, #12]
  }
  if(ptr->mti_filter_len > BSP_MAX_MTI_FILTER_LEN)
  {
    retValue += 4;
  }
  if(!((ptr->num_of_tracks > 0) && (ptr->num_of_tracks <= BSP_MAX_NUM_OF_TRACKS)))
 8020086:	6902      	ldr	r2, [r0, #16]
 */
uint32_t ds_algo_check_settings(algo_settings_t *ptr)
{
  uint32_t retValue = 0;
  
  if((ptr->tracking_enable != 0) && (ptr->tracking_enable != 1))
 8020088:	2b02      	cmp	r3, #2

/* If staged Algo settings are with-in range 0 is return, otherwise non-zero
 * the return value could be interpreted as bit field to identify the failure, if needed!
 */
uint32_t ds_algo_check_settings(algo_settings_t *ptr)
{
 802008a:	b410      	push	{r4}
  
  if((ptr->tracking_enable != 0) && (ptr->tracking_enable != 1))
  {
    retValue += 2;
  }
  if(ptr->mti_filter_len > BSP_MAX_MTI_FILTER_LEN)
 802008c:	69c4      	ldr	r4, [r0, #28]
 */
uint32_t ds_algo_check_settings(algo_settings_t *ptr)
{
  uint32_t retValue = 0;
  
  if((ptr->tracking_enable != 0) && (ptr->tracking_enable != 1))
 802008e:	bf35      	itete	cc
 8020090:	2100      	movcc	r1, #0
 8020092:	2102      	movcs	r1, #2
 8020094:	2304      	movcc	r3, #4
 8020096:	2306      	movcs	r3, #6
  }
  if(ptr->mti_filter_len > BSP_MAX_MTI_FILTER_LEN)
  {
    retValue += 4;
  }
  if(!((ptr->num_of_tracks > 0) && (ptr->num_of_tracks <= BSP_MAX_NUM_OF_TRACKS)))
 8020098:	3a01      	subs	r2, #1
  
  if((ptr->tracking_enable != 0) && (ptr->tracking_enable != 1))
  {
    retValue += 2;
  }
  if(ptr->mti_filter_len > BSP_MAX_MTI_FILTER_LEN)
 802009a:	f5b4 7f7a 	cmp.w	r4, #1000	; 0x3e8
 802009e:	bf98      	it	ls
 80200a0:	460b      	movls	r3, r1
  {
    retValue += 4;
  }
  if(!((ptr->num_of_tracks > 0) && (ptr->num_of_tracks <= BSP_MAX_NUM_OF_TRACKS)))
 80200a2:	2a04      	cmp	r2, #4
  {
    retValue += 8;
  }
  if(ptr->mti_filter_enable > 1)
 80200a4:	6a02      	ldr	r2, [r0, #32]
  }
  if( ptr->speed_detection_threshold > BSP_MAX_SPEED_THRESHOLD )
  {
    retValue += 256;
  }
  if(!(ptr->max_speed_kmh > ptr->min_speed_kmh) && (ptr->max_speed_kmh <= BSP_MAX_SPEED_KMH))
 80200a6:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
  {
    retValue += 4;
  }
  if(!((ptr->num_of_tracks > 0) && (ptr->num_of_tracks <= BSP_MAX_NUM_OF_TRACKS)))
  {
    retValue += 8;
 80200a8:	bf88      	it	hi
 80200aa:	3308      	addhi	r3, #8
  }
  if(ptr->mti_filter_enable > 1)
 80200ac:	2a01      	cmp	r2, #1
  {
    retValue += 32;
  }
  if(!((ptr->mvg_avg_len != 0) && (ptr->mvg_avg_len <= MAX_MVG_AVG_LEN)))
 80200ae:	6942      	ldr	r2, [r0, #20]
 80200b0:	f102 32ff 	add.w	r2, r2, #4294967295
  {
    retValue += 8;
  }
  if(ptr->mti_filter_enable > 1)
  {
    retValue += 32;
 80200b4:	bf88      	it	hi
 80200b6:	3320      	addhi	r3, #32
  }
  if(!((ptr->mvg_avg_len != 0) && (ptr->mvg_avg_len <= MAX_MVG_AVG_LEN)))
 80200b8:	2a09      	cmp	r2, #9
  {
    retValue += 128;
  }
  if( ptr->speed_detection_threshold > BSP_MAX_SPEED_THRESHOLD )
 80200ba:	6b82      	ldr	r2, [r0, #56]	; 0x38
  {
    retValue += 32;
  }
  if(!((ptr->mvg_avg_len != 0) && (ptr->mvg_avg_len <= MAX_MVG_AVG_LEN)))
  {
    retValue += 128;
 80200bc:	bf88      	it	hi
 80200be:	3380      	addhi	r3, #128	; 0x80
  }
  if( ptr->speed_detection_threshold > BSP_MAX_SPEED_THRESHOLD )
 80200c0:	f5b2 7f7a 	cmp.w	r2, #1000	; 0x3e8
  {
    retValue += 256;
  }
  if(!(ptr->max_speed_kmh > ptr->min_speed_kmh) && (ptr->max_speed_kmh <= BSP_MAX_SPEED_KMH))
 80200c4:	6c02      	ldr	r2, [r0, #64]	; 0x40
  {
    retValue += 128;
  }
  if( ptr->speed_detection_threshold > BSP_MAX_SPEED_THRESHOLD )
  {
    retValue += 256;
 80200c6:	bf88      	it	hi
 80200c8:	f503 7380 	addhi.w	r3, r3, #256	; 0x100
  }
  if(!(ptr->max_speed_kmh > ptr->min_speed_kmh) && (ptr->max_speed_kmh <= BSP_MAX_SPEED_KMH))
 80200cc:	428a      	cmp	r2, r1
 80200ce:	d807      	bhi.n	80200e0 <ds_algo_check_settings+0x5c>
 80200d0:	2a14      	cmp	r2, #20
  {
    retValue += 512;
 80200d2:	bf98      	it	ls
 80200d4:	f503 7300 	addls.w	r3, r3, #512	; 0x200
  }
  if(ptr->min_speed_kmh > ptr->max_speed_kmh)
 80200d8:	428a      	cmp	r2, r1
  {
    retValue += 1024;
 80200da:	bf38      	it	cc
 80200dc:	f503 6380 	addcc.w	r3, r3, #1024	; 0x400
  }
  if(ptr->range_detection_threshold > BSP_MAX_RANGE_THRESHOLD)
 80200e0:	6b42      	ldr	r2, [r0, #52]	; 0x34
  {
    retValue += 2048;
  }
  if((ptr->max_distance_cm < ptr->min_distance_cm) || (ptr->max_distance_cm > BSP_MAX_RANGE_CM))
 80200e2:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
  }
  if(ptr->min_speed_kmh > ptr->max_speed_kmh)
  {
    retValue += 1024;
  }
  if(ptr->range_detection_threshold > BSP_MAX_RANGE_THRESHOLD)
 80200e4:	f5b2 7f7a 	cmp.w	r2, #1000	; 0x3e8
  {
    retValue += 2048;
  }
  if((ptr->max_distance_cm < ptr->min_distance_cm) || (ptr->max_distance_cm > BSP_MAX_RANGE_CM))
 80200e8:	6b02      	ldr	r2, [r0, #48]	; 0x30
  {
    retValue += 1024;
  }
  if(ptr->range_detection_threshold > BSP_MAX_RANGE_THRESHOLD)
  {
    retValue += 2048;
 80200ea:	bf88      	it	hi
 80200ec:	f503 6300 	addhi.w	r3, r3, #2048	; 0x800
  }
  if((ptr->max_distance_cm < ptr->min_distance_cm) || (ptr->max_distance_cm > BSP_MAX_RANGE_CM))
 80200f0:	428a      	cmp	r2, r1
 80200f2:	d30b      	bcc.n	802010c <ds_algo_check_settings+0x88>
 80200f4:	f241 3488 	movw	r4, #5000	; 0x1388
 80200f8:	42a2      	cmp	r2, r4
 80200fa:	d812      	bhi.n	8020122 <ds_algo_check_settings+0x9e>
  {
    retValue += 4096;
  }
  if(ptr->min_distance_cm >= ptr->max_distance_cm)
 80200fc:	428a      	cmp	r2, r1
 80200fe:	d808      	bhi.n	8020112 <ds_algo_check_settings+0x8e>
  {
    retValue += 8192;
 8020100:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
  {
    ptr->isChecked = 1;
  }
  
  return retValue;
}
 8020104:	4618      	mov	r0, r3
 8020106:	f85d 4b04 	ldr.w	r4, [sp], #4
 802010a:	4770      	bx	lr
  {
    retValue += 2048;
  }
  if((ptr->max_distance_cm < ptr->min_distance_cm) || (ptr->max_distance_cm > BSP_MAX_RANGE_CM))
  {
    retValue += 4096;
 802010c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8020110:	e7f6      	b.n	8020100 <ds_algo_check_settings+0x7c>
  }
  if(ptr->min_distance_cm >= ptr->max_distance_cm)
  {
    retValue += 8192;
  }
  if(retValue == 0)
 8020112:	2b00      	cmp	r3, #0
 8020114:	d1f6      	bne.n	8020104 <ds_algo_check_settings+0x80>
  {
    ptr->isChecked = 1;
 8020116:	2201      	movs	r2, #1
 8020118:	7042      	strb	r2, [r0, #1]
  }
  
  return retValue;
}
 802011a:	f85d 4b04 	ldr.w	r4, [sp], #4
 802011e:	4618      	mov	r0, r3
 8020120:	4770      	bx	lr
  }
  if((ptr->max_distance_cm < ptr->min_distance_cm) || (ptr->max_distance_cm > BSP_MAX_RANGE_CM))
  {
    retValue += 4096;
  }
  if(ptr->min_distance_cm >= ptr->max_distance_cm)
 8020122:	428a      	cmp	r2, r1
  {
    retValue += 2048;
  }
  if((ptr->max_distance_cm < ptr->min_distance_cm) || (ptr->max_distance_cm > BSP_MAX_RANGE_CM))
  {
    retValue += 4096;
 8020124:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
  }
  if(ptr->min_distance_cm >= ptr->max_distance_cm)
 8020128:	d9ea      	bls.n	8020100 <ds_algo_check_settings+0x7c>
  {
    ptr->isChecked = 1;
  }
  
  return retValue;
}
 802012a:	4618      	mov	r0, r3
 802012c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8020130:	4770      	bx	lr
 8020132:	bf00      	nop

08020134 <ds_device_get_settings>:
//============================================================================

device_settings_t *ds_device_get_settings(void)
{
  return &ds_device_settings;
}
 8020134:	4800      	ldr	r0, [pc, #0]	; (8020138 <ds_device_get_settings+0x4>)
 8020136:	4770      	bx	lr
 8020138:	1ffe9774 	.word	0x1ffe9774

0802013c <ds_device_get_shadow_settings>:
//============================================================================

device_settings_t *ds_device_get_shadow_settings(void)
{
  return &ds_shadow_device_settings;
}
 802013c:	4800      	ldr	r0, [pc, #0]	; (8020140 <ds_device_get_shadow_settings+0x4>)
 802013e:	4770      	bx	lr
 8020140:	1ffe9730 	.word	0x1ffe9730

08020144 <ds_is_device_settings_updated>:

//============================================================================

/* Handling for staged setting */
uint32_t ds_is_device_settings_updated(void)
{
 8020144:	b508      	push	{r3, lr}
  int32_t retValue = 0;
  
  /* If both structs are identical, retValue is 0, otherwise != 0 */
  retValue = memcmp(&ds_shadow_device_settings,&ds_device_settings, sizeof(ds_shadow_device_settings));
 8020146:	4904      	ldr	r1, [pc, #16]	; (8020158 <ds_is_device_settings_updated+0x14>)
 8020148:	4804      	ldr	r0, [pc, #16]	; (802015c <ds_is_device_settings_updated+0x18>)
 802014a:	2244      	movs	r2, #68	; 0x44
 802014c:	f00e fd1c 	bl	802eb88 <memcmp>
  
  /* Result of memcmp could be negative! */
  return (retValue == 0) ? 0U : 1U;
}
 8020150:	3000      	adds	r0, #0
 8020152:	bf18      	it	ne
 8020154:	2001      	movne	r0, #1
 8020156:	bd08      	pop	{r3, pc}
 8020158:	1ffe9774 	.word	0x1ffe9774
 802015c:	1ffe9730 	.word	0x1ffe9730

08020160 <ds_device_settings_copy_to_shadow>:

//============================================================================

void ds_device_settings_copy_to_shadow(void)
{
 8020160:	b508      	push	{r3, lr}
  memcpy(&ds_shadow_device_settings, &ds_device_settings, sizeof(ds_shadow_device_settings));
 8020162:	4903      	ldr	r1, [pc, #12]	; (8020170 <ds_device_settings_copy_to_shadow+0x10>)
 8020164:	4803      	ldr	r0, [pc, #12]	; (8020174 <ds_device_settings_copy_to_shadow+0x14>)
 8020166:	2244      	movs	r2, #68	; 0x44
 8020168:	f00e fd1e 	bl	802eba8 <memcpy>
 802016c:	bd08      	pop	{r3, pc}
 802016e:	bf00      	nop
 8020170:	1ffe9774 	.word	0x1ffe9774
 8020174:	1ffe9730 	.word	0x1ffe9730

08020178 <ds_init>:

/* This function could be used to pre-init the settings store
 *  e.g. with persistent value, that are stored in some persistent memory region.
 */
uint32_t ds_init(void)
{
 8020178:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t retValue = 0;
  
  ds_algo_settings = ds_default_algo_settings;
 802017c:	4c1c      	ldr	r4, [pc, #112]	; (80201f0 <ds_init+0x78>)
  
  ds_device_settings = ds_default_device_settings;
 802017e:	4e1d      	ldr	r6, [pc, #116]	; (80201f4 <ds_init+0x7c>)
 */
uint32_t ds_init(void)
{
  uint32_t retValue = 0;
  
  ds_algo_settings = ds_default_algo_settings;
 8020180:	4620      	mov	r0, r4
 8020182:	2100      	movs	r1, #0
 8020184:	224c      	movs	r2, #76	; 0x4c
 8020186:	f00e fd1a 	bl	802ebbe <memset>
  
  ds_device_settings = ds_default_device_settings;
 802018a:	2544      	movs	r5, #68	; 0x44
 */
uint32_t ds_init(void)
{
  uint32_t retValue = 0;
  
  ds_algo_settings = ds_default_algo_settings;
 802018c:	4b1a      	ldr	r3, [pc, #104]	; (80201f8 <ds_init+0x80>)
 802018e:	f8df e074 	ldr.w	lr, [pc, #116]	; 8020204 <ds_init+0x8c>
 8020192:	6463      	str	r3, [r4, #68]	; 0x44
 8020194:	f04f 0c04 	mov.w	ip, #4
 8020198:	2305      	movs	r3, #5
 802019a:	2764      	movs	r7, #100	; 0x64
  
  ds_device_settings = ds_default_device_settings;
 802019c:	462a      	mov	r2, r5
 802019e:	4917      	ldr	r1, [pc, #92]	; (80201fc <ds_init+0x84>)
 */
uint32_t ds_init(void)
{
  uint32_t retValue = 0;
  
  ds_algo_settings = ds_default_algo_settings;
 80201a0:	6063      	str	r3, [r4, #4]
 80201a2:	f04f 0b02 	mov.w	fp, #2
 80201a6:	f04f 0a5a 	mov.w	sl, #90	; 0x5a
 80201aa:	f44f 797a 	mov.w	r9, #1000	; 0x3e8
 80201ae:	f04f 0832 	mov.w	r8, #50	; 0x32
  
  ds_device_settings = ds_default_device_settings;
 80201b2:	4630      	mov	r0, r6
 */
uint32_t ds_init(void)
{
  uint32_t retValue = 0;
  
  ds_algo_settings = ds_default_algo_settings;
 80201b4:	60a3      	str	r3, [r4, #8]
 80201b6:	6123      	str	r3, [r4, #16]
 80201b8:	61a3      	str	r3, [r4, #24]
 80201ba:	f8c4 c040 	str.w	ip, [r4, #64]	; 0x40
 80201be:	f8c4 e048 	str.w	lr, [r4, #72]	; 0x48
 80201c2:	f8c4 b014 	str.w	fp, [r4, #20]
 80201c6:	f8c4 a02c 	str.w	sl, [r4, #44]	; 0x2c
 80201ca:	f8c4 9030 	str.w	r9, [r4, #48]	; 0x30
 80201ce:	f8c4 8038 	str.w	r8, [r4, #56]	; 0x38
 80201d2:	61e7      	str	r7, [r4, #28]
 80201d4:	6367      	str	r7, [r4, #52]	; 0x34
  
  ds_device_settings = ds_default_device_settings;
 80201d6:	f00e fce7 	bl	802eba8 <memcpy>

//============================================================================

void ds_device_settings_copy_to_shadow(void)
{
  memcpy(&ds_shadow_device_settings, &ds_device_settings, sizeof(ds_shadow_device_settings));
 80201da:	4631      	mov	r1, r6
 80201dc:	462a      	mov	r2, r5
 80201de:	4808      	ldr	r0, [pc, #32]	; (8020200 <ds_init+0x88>)
 80201e0:	f00e fce2 	bl	802eba8 <memcpy>
  {
    retValue += 8192;
  }
  if(retValue == 0)
  {
    ptr->isChecked = 1;
 80201e4:	2301      	movs	r3, #1
 80201e6:	7063      	strb	r3, [r4, #1]
  ds_device_settings_copy_to_shadow();
  
  retValue += ds_algo_check_settings(&ds_algo_settings);
  
  return retValue;
}
 80201e8:	2000      	movs	r0, #0
 80201ea:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80201ee:	bf00      	nop
 80201f0:	1ffe96e4 	.word	0x1ffe96e4
 80201f4:	1ffe9774 	.word	0x1ffe9774
 80201f8:	3fff2d46 	.word	0x3fff2d46
 80201fc:	080308d0 	.word	0x080308d0
 8020200:	1ffe9730 	.word	0x1ffe9730
 8020204:	42480000 	.word	0x42480000

08020208 <ds_get_active_acq_buf>:
//============================================================================

acq_buf_obj *ds_get_active_acq_buf(void)
{
  return &s_acq_buf;
}
 8020208:	4800      	ldr	r0, [pc, #0]	; (802020c <ds_get_active_acq_buf+0x4>)
 802020a:	4770      	bx	lr
 802020c:	1ffe886c 	.word	0x1ffe886c

08020210 <ds_set_active_acq_buf>:

//============================================================================

void ds_set_active_acq_buf(const acq_buf_obj acq_buf)
{
 8020210:	b084      	sub	sp, #16
 8020212:	b538      	push	{r3, r4, r5, lr}
  if(s_acq_buf.p_acq_buf != NULL)
 8020214:	4c0b      	ldr	r4, [pc, #44]	; (8020244 <ds_set_active_acq_buf+0x34>)
 8020216:	6aa5      	ldr	r5, [r4, #40]	; 0x28
}

//============================================================================

void ds_set_active_acq_buf(const acq_buf_obj acq_buf)
{
 8020218:	f10d 0e10 	add.w	lr, sp, #16
 802021c:	e88e 000f 	stmia.w	lr, {r0, r1, r2, r3}
  if(s_acq_buf.p_acq_buf != NULL)
 8020220:	b115      	cbz	r5, 8020228 <ds_set_active_acq_buf+0x18>
  {
    delete_acq_buffer_obj(&s_acq_buf);
 8020222:	4620      	mov	r0, r4
 8020224:	f000 f9f2 	bl	802060c <delete_acq_buffer_obj>
  }
  
  memcpy(&s_acq_buf, &acq_buf, sizeof(acq_buf_obj));
 8020228:	ad04      	add	r5, sp, #16
 802022a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 802022c:	4c05      	ldr	r4, [pc, #20]	; (8020244 <ds_set_active_acq_buf+0x34>)
 802022e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8020230:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020232:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8020234:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8020238:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
}
 802023c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8020240:	b004      	add	sp, #16
 8020242:	4770      	bx	lr
 8020244:	1ffe886c 	.word	0x1ffe886c

08020248 <ds_ep_fetch_adc_config>:
   3. EXPORTED FUNCTIONS
==============================================================================
 */

void ds_ep_fetch_adc_config(Adc_Configuration_t *ptr)
{
 8020248:	b510      	push	{r4, lr}
 802024a:	4604      	mov	r4, r0
	device_settings_t *p_dev   = ds_device_get_settings();
 802024c:	f7ff ff72 	bl	8020134 <ds_device_get_settings>
	ptr->samplerate_Hz 		   = p_dev->adc_sampling_freq_Hz;
 8020250:	69c3      	ldr	r3, [r0, #28]
 8020252:	6023      	str	r3, [r4, #0]
	ptr->resolution    		   = p_dev->adc_resolution;
 8020254:	f890 3020 	ldrb.w	r3, [r0, #32]
 8020258:	7123      	strb	r3, [r4, #4]
	ptr->use_post_calibration  = p_dev->adc_use_post_calibration;
 802025a:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 802025e:	7163      	strb	r3, [r4, #5]
 8020260:	bd10      	pop	{r4, pc}
 8020262:	bf00      	nop

08020264 <ds_ep_store_adc_config>:

uint16_t ds_ep_store_adc_config(const Adc_Configuration_t *p_config)
{
  uint16_t status = RADAR_ERR_BUSY;

  if(p_config != NULL)
 8020264:	b168      	cbz	r0, 8020282 <ds_ep_store_adc_config+0x1e>
}

//============================================================================

uint16_t ds_ep_store_adc_config(const Adc_Configuration_t *p_config)
{
 8020266:	b510      	push	{r4, lr}
 8020268:	4604      	mov	r4, r0
  uint16_t status = RADAR_ERR_BUSY;

  if(p_config != NULL)
  {
	  device_settings_t *p_dev		   = ds_device_get_settings();
 802026a:	f7ff ff63 	bl	8020134 <ds_device_get_settings>
	  p_dev->adc_sampling_freq_Hz 	   = p_config->samplerate_Hz;
 802026e:	6823      	ldr	r3, [r4, #0]
 8020270:	61c3      	str	r3, [r0, #28]
	  p_dev->adc_resolution    		   = p_config->resolution;
 8020272:	7923      	ldrb	r3, [r4, #4]
 8020274:	f880 3020 	strb.w	r3, [r0, #32]
	  p_dev->adc_use_post_calibration  = p_config->use_post_calibration;
 8020278:	7963      	ldrb	r3, [r4, #5]
 802027a:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21

	  status = RADAR_ERR_OK;
 802027e:	2000      	movs	r0, #0
 8020280:	bd10      	pop	{r4, pc}

//============================================================================

uint16_t ds_ep_store_adc_config(const Adc_Configuration_t *p_config)
{
  uint16_t status = RADAR_ERR_BUSY;
 8020282:	2002      	movs	r0, #2
 8020284:	4770      	bx	lr
 8020286:	bf00      	nop

08020288 <ds_ep_fetch_doppler_config>:
}

//============================================================================

void ds_ep_fetch_doppler_config(Doppler_Configuration_t *config)
{
 8020288:	b510      	push	{r4, lr}
 802028a:	4604      	mov	r4, r0
	device_settings_t *p_dev  = ds_device_get_settings();
 802028c:	f7ff ff52 	bl	8020134 <ds_device_get_settings>
    config->frequency_kHz 	  = p_dev->pll_frequency_kHz;
 8020290:	edd0 7a01 	vldr	s15, [r0, #4]
 8020294:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8020298:	edc4 7a00 	vstr	s15, [r4]
    config->tx_power 		  = p_dev->bgt_tx_power_level;
 802029c:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
 80202a0:	7123      	strb	r3, [r4, #4]
 80202a2:	bd10      	pop	{r4, pc}

080202a4 <ds_ep_store_doppler_config>:

uint16_t ds_ep_store_doppler_config(const Doppler_Configuration_t *config)
{
  uint16_t status = RADAR_ERR_BUSY;

  if(config != NULL)
 80202a4:	b180      	cbz	r0, 80202c8 <ds_ep_store_doppler_config+0x24>
}

//============================================================================

uint16_t ds_ep_store_doppler_config(const Doppler_Configuration_t *config)
{
 80202a6:	b510      	push	{r4, lr}
 80202a8:	4604      	mov	r4, r0
  uint16_t status = RADAR_ERR_BUSY;

  if(config != NULL)
  {
	  device_settings_t *p_dev		   = ds_device_get_settings();
 80202aa:	f7ff ff43 	bl	8020134 <ds_device_get_settings>
	  p_dev->pll_frequency_kHz 		   = config->frequency_kHz;
 80202ae:	edd4 7a00 	vldr	s15, [r4]
 80202b2:	eef8 7a67 	vcvt.f32.u32	s15, s15
	  p_dev->bgt_tx_power_level 	   = config->tx_power;
	  p_dev->isUpdated_doppler_config  = 1;
 80202b6:	2301      	movs	r3, #1
  uint16_t status = RADAR_ERR_BUSY;

  if(config != NULL)
  {
	  device_settings_t *p_dev		   = ds_device_get_settings();
	  p_dev->pll_frequency_kHz 		   = config->frequency_kHz;
 80202b8:	edc0 7a01 	vstr	s15, [r0, #4]
	  p_dev->bgt_tx_power_level 	   = config->tx_power;
 80202bc:	7922      	ldrb	r2, [r4, #4]
 80202be:	f880 2025 	strb.w	r2, [r0, #37]	; 0x25
	  p_dev->isUpdated_doppler_config  = 1;
 80202c2:	6403      	str	r3, [r0, #64]	; 0x40

	  status = RADAR_ERR_OK;
 80202c4:	2000      	movs	r0, #0
 80202c6:	bd10      	pop	{r4, pc}

//============================================================================

uint16_t ds_ep_store_doppler_config(const Doppler_Configuration_t *config)
{
  uint16_t status = RADAR_ERR_BUSY;
 80202c8:	2002      	movs	r0, #2
 80202ca:	4770      	bx	lr

080202cc <ds_ep_fetch_fmcw_config>:
}

//============================================================================

void ds_ep_fetch_fmcw_config(Fmcw_Configuration_t *config)
{
 80202cc:	b510      	push	{r4, lr}
 80202ce:	4604      	mov	r4, r0
  device_settings_t *p_dev	   		= ds_device_get_settings();
 80202d0:	f7ff ff30 	bl	8020134 <ds_device_get_settings>
  config->lower_frequency_kHz  		= p_dev->pll_lower_frequency_kHz;
 80202d4:	ed90 7a02 	vldr	s14, [r0, #8]
  config->upper_frequency_kHz  		= p_dev->pll_upper_frequency_kHz;
 80202d8:	edd0 7a03 	vldr	s15, [r0, #12]
  config->direction 		   		= RADAR_DIR_UPCHIRP_ONLY;
  config->tx_power 			   		= p_dev->bgt_tx_power_level;
  config->up_chirp_duration_nsec 	= p_dev->pll_chirp_time_usec * 1000U;
  config->down_chirp_duration_nsec  = (PLL_RAMP_DOWM_TIME_USEC) * 1000U;
 80202dc:	4a0b      	ldr	r2, [pc, #44]	; (802030c <ds_ep_fetch_fmcw_config+0x40>)
//============================================================================

void ds_ep_fetch_fmcw_config(Fmcw_Configuration_t *config)
{
  device_settings_t *p_dev	   		= ds_device_get_settings();
  config->lower_frequency_kHz  		= p_dev->pll_lower_frequency_kHz;
 80202de:	eebc 7ac7 	vcvt.u32.f32	s14, s14
  config->upper_frequency_kHz  		= p_dev->pll_upper_frequency_kHz;
 80202e2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
  config->direction 		   		= RADAR_DIR_UPCHIRP_ONLY;
 80202e6:	2300      	movs	r3, #0
//============================================================================

void ds_ep_fetch_fmcw_config(Fmcw_Configuration_t *config)
{
  device_settings_t *p_dev	   		= ds_device_get_settings();
  config->lower_frequency_kHz  		= p_dev->pll_lower_frequency_kHz;
 80202e8:	ed84 7a00 	vstr	s14, [r4]
  config->upper_frequency_kHz  		= p_dev->pll_upper_frequency_kHz;
 80202ec:	edc4 7a01 	vstr	s15, [r4, #4]
  config->direction 		   		= RADAR_DIR_UPCHIRP_ONLY;
 80202f0:	7223      	strb	r3, [r4, #8]
  config->tx_power 			   		= p_dev->bgt_tx_power_level;
 80202f2:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
 80202f6:	7263      	strb	r3, [r4, #9]
  config->up_chirp_duration_nsec 	= p_dev->pll_chirp_time_usec * 1000U;
 80202f8:	6801      	ldr	r1, [r0, #0]
  config->down_chirp_duration_nsec  = (PLL_RAMP_DOWM_TIME_USEC) * 1000U;
 80202fa:	6122      	str	r2, [r4, #16]
  device_settings_t *p_dev	   		= ds_device_get_settings();
  config->lower_frequency_kHz  		= p_dev->pll_lower_frequency_kHz;
  config->upper_frequency_kHz  		= p_dev->pll_upper_frequency_kHz;
  config->direction 		   		= RADAR_DIR_UPCHIRP_ONLY;
  config->tx_power 			   		= p_dev->bgt_tx_power_level;
  config->up_chirp_duration_nsec 	= p_dev->pll_chirp_time_usec * 1000U;
 80202fc:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8020300:	fb03 f301 	mul.w	r3, r3, r1
 8020304:	60e3      	str	r3, [r4, #12]
  config->down_chirp_duration_nsec  = (PLL_RAMP_DOWM_TIME_USEC) * 1000U;
  config->chirp_to_chirp_delay_nsec = (PLL_STEADY_STATE_USEC)* 1000U;
 8020306:	6162      	str	r2, [r4, #20]
 8020308:	bd10      	pop	{r4, pc}
 802030a:	bf00      	nop
 802030c:	000186a0 	.word	0x000186a0

08020310 <ds_ep_store_fmcw_config>:

uint16_t ds_ep_store_fmcw_config(const Fmcw_Configuration_t *config)
{
  uint16_t status = RADAR_ERR_BUSY;

  if(config != NULL)
 8020310:	b120      	cbz	r0, 802031c <ds_ep_store_fmcw_config+0xc>
}

//============================================================================

uint16_t ds_ep_store_fmcw_config(const Fmcw_Configuration_t *config)
{
 8020312:	b538      	push	{r3, r4, r5, lr}
  uint16_t status = RADAR_ERR_BUSY;

  if(config != NULL)
  {
	  if(config->direction != RADAR_DIR_UPCHIRP_ONLY)
 8020314:	7a04      	ldrb	r4, [r0, #8]
 8020316:	b11c      	cbz	r4, 8020320 <ds_ep_store_fmcw_config+0x10>
	  {
		  status = RADAR_ERR_UNSUPPORTED_DIRECTION;
 8020318:	2020      	movs	r0, #32

		  status = RADAR_ERR_OK;
	  }
  }
  return (status);
}
 802031a:	bd38      	pop	{r3, r4, r5, pc}

//============================================================================

uint16_t ds_ep_store_fmcw_config(const Fmcw_Configuration_t *config)
{
  uint16_t status = RADAR_ERR_BUSY;
 802031c:	2002      	movs	r0, #2

		  status = RADAR_ERR_OK;
	  }
  }
  return (status);
}
 802031e:	4770      	bx	lr
 8020320:	4605      	mov	r5, r0
	  {
		  status = RADAR_ERR_UNSUPPORTED_DIRECTION;
	  }
	  else
	  {
		  device_settings_t *p_dev		  = ds_device_get_settings();
 8020322:	f7ff ff07 	bl	8020134 <ds_device_get_settings>
		  p_dev->pll_lower_frequency_kHz  = config->lower_frequency_kHz;
 8020326:	edd5 7a00 	vldr	s15, [r5]
 802032a:	eeb8 7a67 	vcvt.f32.u32	s14, s15
		  p_dev->pll_upper_frequency_kHz  = config->upper_frequency_kHz;
 802032e:	edd5 7a01 	vldr	s15, [r5, #4]
		  status = RADAR_ERR_UNSUPPORTED_DIRECTION;
	  }
	  else
	  {
		  device_settings_t *p_dev		  = ds_device_get_settings();
		  p_dev->pll_lower_frequency_kHz  = config->lower_frequency_kHz;
 8020332:	ed80 7a02 	vstr	s14, [r0, #8]
		  p_dev->pll_upper_frequency_kHz  = config->upper_frequency_kHz;
 8020336:	eef8 7a67 	vcvt.f32.u32	s15, s15
	  {
		  status = RADAR_ERR_UNSUPPORTED_DIRECTION;
	  }
	  else
	  {
		  device_settings_t *p_dev		  = ds_device_get_settings();
 802033a:	4603      	mov	r3, r0
		  p_dev->pll_lower_frequency_kHz  = config->lower_frequency_kHz;
		  p_dev->pll_upper_frequency_kHz  = config->upper_frequency_kHz;
 802033c:	edc0 7a03 	vstr	s15, [r0, #12]
		  p_dev->bgt_tx_power_level 	  = config->tx_power;
 8020340:	7a6a      	ldrb	r2, [r5, #9]
 8020342:	f880 2025 	strb.w	r2, [r0, #37]	; 0x25
		  p_dev->isUpdated_fmcw_config 	  = 1;
 8020346:	2201      	movs	r2, #1

		  status = RADAR_ERR_OK;
 8020348:	4620      	mov	r0, r4
	  {
		  device_settings_t *p_dev		  = ds_device_get_settings();
		  p_dev->pll_lower_frequency_kHz  = config->lower_frequency_kHz;
		  p_dev->pll_upper_frequency_kHz  = config->upper_frequency_kHz;
		  p_dev->bgt_tx_power_level 	  = config->tx_power;
		  p_dev->isUpdated_fmcw_config 	  = 1;
 802034a:	63da      	str	r2, [r3, #60]	; 0x3c
 802034c:	bd38      	pop	{r3, r4, r5, pc}
 802034e:	bf00      	nop

08020350 <ds_ep_get_device_info>:
//============================================================================

const Device_Info_t *ds_ep_get_device_info(void)
{
  return (&cg_device_info_struct);
}
 8020350:	4800      	ldr	r0, [pc, #0]	; (8020354 <ds_ep_get_device_info+0x4>)
 8020352:	4770      	bx	lr
 8020354:	0803093c 	.word	0x0803093c

08020358 <ds_ep_fetch_frame_format>:

//============================================================================

void ds_ep_fetch_frame_format(Frame_Format_t *p_frame_format)
{
 8020358:	b510      	push	{r4, lr}
 802035a:	4604      	mov	r4, r0
	device_settings_t *p_dev			  = ds_device_get_settings();
 802035c:	f7ff feea 	bl	8020134 <ds_device_get_settings>
	p_frame_format->num_samples_per_chirp = p_dev->num_samples_per_chirp;
	p_frame_format->num_chirps_per_frame  = p_dev->pll_num_of_chirps_per_frame;
 8020360:	6942      	ldr	r2, [r0, #20]
//============================================================================

void ds_ep_fetch_frame_format(Frame_Format_t *p_frame_format)
{
	device_settings_t *p_dev			  = ds_device_get_settings();
	p_frame_format->num_samples_per_chirp = p_dev->num_samples_per_chirp;
 8020362:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
	p_frame_format->num_chirps_per_frame  = p_dev->pll_num_of_chirps_per_frame;
 8020364:	e884 0006 	stmia.w	r4, {r1, r2}
	p_frame_format->rx_mask 		      = p_dev->rx_antenna_mask;
 8020368:	f890 2030 	ldrb.w	r2, [r0, #48]	; 0x30
 802036c:	7222      	strb	r2, [r4, #8]
	p_frame_format->signal_part 	      = RADAR_SIGNAL_I_AND_Q;
 802036e:	2302      	movs	r3, #2
 8020370:	7263      	strb	r3, [r4, #9]
 8020372:	bd10      	pop	{r4, pc}

08020374 <ds_ep_store_frame_format>:

uint16_t ds_ep_store_frame_format(const Frame_Format_t *p_new_frame_format)
{
  uint16_t status = RADAR_ERR_BUSY;

  if(p_new_frame_format != NULL)
 8020374:	b120      	cbz	r0, 8020380 <ds_ep_store_frame_format+0xc>
  {
	  if(p_new_frame_format->signal_part != RADAR_SIGNAL_I_AND_Q)
 8020376:	7a43      	ldrb	r3, [r0, #9]
 8020378:	2b02      	cmp	r3, #2
 802037a:	d003      	beq.n	8020384 <ds_ep_store_frame_format+0x10>
	  {
		  status = RADAR_ERR_UNAVAILABLE_SIGNAL_PART;
 802037c:	200b      	movs	r0, #11
 802037e:	4770      	bx	lr

//============================================================================

uint16_t ds_ep_store_frame_format(const Frame_Format_t *p_new_frame_format)
{
  uint16_t status = RADAR_ERR_BUSY;
 8020380:	2002      	movs	r0, #2
 8020382:	4770      	bx	lr
}

//============================================================================

uint16_t ds_ep_store_frame_format(const Frame_Format_t *p_new_frame_format)
{
 8020384:	b510      	push	{r4, lr}
 8020386:	4604      	mov	r4, r0
	  {
		  status = RADAR_ERR_UNAVAILABLE_SIGNAL_PART;
	  }
	  else
	  {
		  device_settings_t *p_dev				= ds_device_get_settings();
 8020388:	f7ff fed4 	bl	8020134 <ds_device_get_settings>
		  p_dev->num_samples_per_chirp 	        = p_new_frame_format->num_samples_per_chirp;
		  p_dev->pll_num_of_chirps_per_frame 	= p_new_frame_format->num_chirps_per_frame;
 802038c:	e894 000c 	ldmia.w	r4, {r2, r3}
		  status = RADAR_ERR_UNAVAILABLE_SIGNAL_PART;
	  }
	  else
	  {
		  device_settings_t *p_dev				= ds_device_get_settings();
		  p_dev->num_samples_per_chirp 	        = p_new_frame_format->num_samples_per_chirp;
 8020390:	62c2      	str	r2, [r0, #44]	; 0x2c
		  p_dev->pll_num_of_chirps_per_frame 	= p_new_frame_format->num_chirps_per_frame;
 8020392:	6143      	str	r3, [r0, #20]
		  p_dev->rx_antenna_mask	            = p_new_frame_format->rx_mask;
 8020394:	7a23      	ldrb	r3, [r4, #8]
 8020396:	f880 3030 	strb.w	r3, [r0, #48]	; 0x30

		  status = RADAR_ERR_OK;
 802039a:	2000      	movs	r0, #0
 802039c:	bd10      	pop	{r4, pc}
 802039e:	bf00      	nop

080203a0 <ds_ep_fetch_target_list>:
}

//============================================================================

void ds_ep_fetch_target_list(Target_Info_t* target_info_ptr, uint8_t* target_count)
{
 80203a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80203a4:	4607      	mov	r7, r0
 80203a6:	460e      	mov	r6, r1
  uint8_t num_targets = 0;

  if (ds_device_get_settings()->pll_modulation_mode == MODULATION_FMCW)
 80203a8:	f7ff fec4 	bl	8020134 <ds_device_get_settings>
 80203ac:	6983      	ldr	r3, [r0, #24]
 80203ae:	2b01      	cmp	r3, #1
 80203b0:	d003      	beq.n	80203ba <ds_ep_fetch_target_list+0x1a>

//============================================================================

void ds_ep_fetch_target_list(Target_Info_t* target_info_ptr, uint8_t* target_count)
{
  uint8_t num_targets = 0;
 80203b2:	2400      	movs	r4, #0
        num_targets++;
      }
    }
  }

  *target_count = num_targets;
 80203b4:	7034      	strb	r4, [r6, #0]
 80203b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
{
  uint8_t num_targets = 0;

  if (ds_device_get_settings()->pll_modulation_mode == MODULATION_FMCW)
  {
	ds_target_list_t *p_target_list = ds_get_target_list();
 80203ba:	f7ff fe4d 	bl	8020058 <ds_get_target_list>
    for (uint8_t idx = 0; idx < p_target_list->max_num_of_targets; idx++)
 80203be:	f8d0 e000 	ldr.w	lr, [r0]
 80203c2:	f1be 0f00 	cmp.w	lr, #0
 80203c6:	d0f4      	beq.n	80203b2 <ds_ep_fetch_target_list+0x12>
 80203c8:	2300      	movs	r3, #0
      if (p_target_list->elems[idx].target_id != 0)
      {
        target_info_ptr[num_targets].target_id 	   = idx + 1;
    	target_info_ptr[num_targets].level 		   = p_target_list->elems[idx].strength;
        target_info_ptr[num_targets].radius 	   = p_target_list->elems[idx].range;
        target_info_ptr[num_targets].radial_speed  = p_target_list->elems[idx].speed * 3.6f; // m/s => km/h
 80203ca:	ed9f 7a14 	vldr	s14, [pc, #80]	; 802041c <ds_ep_fetch_target_list+0x7c>
  uint8_t num_targets = 0;

  if (ds_device_get_settings()->pll_modulation_mode == MODULATION_FMCW)
  {
	ds_target_list_t *p_target_list = ds_get_target_list();
    for (uint8_t idx = 0; idx < p_target_list->max_num_of_targets; idx++)
 80203ce:	461c      	mov	r4, r3
 80203d0:	e003      	b.n	80203da <ds_ep_fetch_target_list+0x3a>
 80203d2:	3301      	adds	r3, #1
 80203d4:	b2db      	uxtb	r3, r3
 80203d6:	4573      	cmp	r3, lr
 80203d8:	d2ec      	bcs.n	80203b4 <ds_ep_fetch_target_list+0x14>
    {
      if (p_target_list->elems[idx].target_id != 0)
 80203da:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 80203de:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 80203e2:	f102 0108 	add.w	r1, r2, #8
 80203e6:	6895      	ldr	r5, [r2, #8]
 80203e8:	2d00      	cmp	r5, #0
 80203ea:	d0f2      	beq.n	80203d2 <ds_ep_fetch_target_list+0x32>
      {
        target_info_ptr[num_targets].target_id 	   = idx + 1;
    	target_info_ptr[num_targets].level 		   = p_target_list->elems[idx].strength;
        target_info_ptr[num_targets].radius 	   = p_target_list->elems[idx].range;
        target_info_ptr[num_targets].radial_speed  = p_target_list->elems[idx].speed * 3.6f; // m/s => km/h
 80203ec:	edd2 7a04 	vldr	s15, [r2, #16]
    {
      if (p_target_list->elems[idx].target_id != 0)
      {
        target_info_ptr[num_targets].target_id 	   = idx + 1;
    	target_info_ptr[num_targets].level 		   = p_target_list->elems[idx].strength;
        target_info_ptr[num_targets].radius 	   = p_target_list->elems[idx].range;
 80203f0:	f8d1 8004 	ldr.w	r8, [r1, #4]
    for (uint8_t idx = 0; idx < p_target_list->max_num_of_targets; idx++)
    {
      if (p_target_list->elems[idx].target_id != 0)
      {
        target_info_ptr[num_targets].target_id 	   = idx + 1;
    	target_info_ptr[num_targets].level 		   = p_target_list->elems[idx].strength;
 80203f4:	f8d2 c018 	ldr.w	ip, [r2, #24]
        target_info_ptr[num_targets].radius 	   = p_target_list->elems[idx].range;
        target_info_ptr[num_targets].radial_speed  = p_target_list->elems[idx].speed * 3.6f; // m/s => km/h
        target_info_ptr[num_targets].azimuth 	   = p_target_list->elems[idx].angle;
 80203f8:	6951      	ldr	r1, [r2, #20]
	ds_target_list_t *p_target_list = ds_get_target_list();
    for (uint8_t idx = 0; idx < p_target_list->max_num_of_targets; idx++)
    {
      if (p_target_list->elems[idx].target_id != 0)
      {
        target_info_ptr[num_targets].target_id 	   = idx + 1;
 80203fa:	0165      	lsls	r5, r4, #5
 80203fc:	197a      	adds	r2, r7, r5
    	target_info_ptr[num_targets].level 		   = p_target_list->elems[idx].strength;
        target_info_ptr[num_targets].radius 	   = p_target_list->elems[idx].range;
        target_info_ptr[num_targets].radial_speed  = p_target_list->elems[idx].speed * 3.6f; // m/s => km/h
 80203fe:	ee67 7a87 	vmul.f32	s15, s15, s14
	ds_target_list_t *p_target_list = ds_get_target_list();
    for (uint8_t idx = 0; idx < p_target_list->max_num_of_targets; idx++)
    {
      if (p_target_list->elems[idx].target_id != 0)
      {
        target_info_ptr[num_targets].target_id 	   = idx + 1;
 8020402:	3301      	adds	r3, #1
    	target_info_ptr[num_targets].level 		   = p_target_list->elems[idx].strength;
        target_info_ptr[num_targets].radius 	   = p_target_list->elems[idx].range;
        target_info_ptr[num_targets].radial_speed  = p_target_list->elems[idx].speed * 3.6f; // m/s => km/h
        target_info_ptr[num_targets].azimuth 	   = p_target_list->elems[idx].angle;

        num_targets++;
 8020404:	3401      	adds	r4, #1
	ds_target_list_t *p_target_list = ds_get_target_list();
    for (uint8_t idx = 0; idx < p_target_list->max_num_of_targets; idx++)
    {
      if (p_target_list->elems[idx].target_id != 0)
      {
        target_info_ptr[num_targets].target_id 	   = idx + 1;
 8020406:	517b      	str	r3, [r7, r5]
    	target_info_ptr[num_targets].level 		   = p_target_list->elems[idx].strength;
        target_info_ptr[num_targets].radius 	   = p_target_list->elems[idx].range;
        target_info_ptr[num_targets].radial_speed  = p_target_list->elems[idx].speed * 3.6f; // m/s => km/h
        target_info_ptr[num_targets].azimuth 	   = p_target_list->elems[idx].angle;

        num_targets++;
 8020408:	b2e4      	uxtb	r4, r4
    {
      if (p_target_list->elems[idx].target_id != 0)
      {
        target_info_ptr[num_targets].target_id 	   = idx + 1;
    	target_info_ptr[num_targets].level 		   = p_target_list->elems[idx].strength;
        target_info_ptr[num_targets].radius 	   = p_target_list->elems[idx].range;
 802040a:	f8c2 8008 	str.w	r8, [r2, #8]
    for (uint8_t idx = 0; idx < p_target_list->max_num_of_targets; idx++)
    {
      if (p_target_list->elems[idx].target_id != 0)
      {
        target_info_ptr[num_targets].target_id 	   = idx + 1;
    	target_info_ptr[num_targets].level 		   = p_target_list->elems[idx].strength;
 802040e:	f8c2 c004 	str.w	ip, [r2, #4]
        target_info_ptr[num_targets].radius 	   = p_target_list->elems[idx].range;
        target_info_ptr[num_targets].radial_speed  = p_target_list->elems[idx].speed * 3.6f; // m/s => km/h
 8020412:	edc2 7a05 	vstr	s15, [r2, #20]
        target_info_ptr[num_targets].azimuth 	   = p_target_list->elems[idx].angle;
 8020416:	60d1      	str	r1, [r2, #12]
 8020418:	e7dc      	b.n	80203d4 <ds_ep_fetch_target_list+0x34>
 802041a:	bf00      	nop
 802041c:	40666666 	.word	0x40666666

08020420 <ds_ep_fetch_range_detection_threshold>:

//============================================================================

void ds_ep_fetch_range_detection_threshold(uint16_t* threshold)
{
  uint16_t temp = (uint16_t) result_range_detection_threshold;
 8020420:	4b04      	ldr	r3, [pc, #16]	; (8020434 <ds_ep_fetch_range_detection_threshold+0x14>)
 8020422:	edd3 7a00 	vldr	s15, [r3]
 8020426:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 802042a:	ee17 3a90 	vmov	r3, s15
 802042e:	8003      	strh	r3, [r0, #0]
 8020430:	4770      	bx	lr
 8020432:	bf00      	nop
 8020434:	1ffe96e0 	.word	0x1ffe96e0

08020438 <ds_ep_fetch_fft_config>:

  *threshold = temp;
}

void ds_ep_fetch_fft_config(FFT_configuration_t *p_fft_config)
{
 8020438:	b410      	push	{r4}
	p_fft_config->fft_window_size 	= RANGE_FFT_SIZE;
	p_fft_config->mean_removed 		= 0;
 802043a:	2100      	movs	r1, #0
  *threshold = temp;
}

void ds_ep_fetch_fft_config(FFT_configuration_t *p_fft_config)
{
	p_fft_config->fft_window_size 	= RANGE_FFT_SIZE;
 802043c:	f44f 7480 	mov.w	r4, #256	; 0x100
	p_fft_config->mean_removed 		= 0;
	p_fft_config->window_type 		= WINDOW_BLACKMANHARRIS;
 8020440:	2202      	movs	r2, #2
	p_fft_config->scaling_factor	= 1.0F;
 8020442:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
  *threshold = temp;
}

void ds_ep_fetch_fft_config(FFT_configuration_t *p_fft_config)
{
	p_fft_config->fft_window_size 	= RANGE_FFT_SIZE;
 8020446:	6004      	str	r4, [r0, #0]
	p_fft_config->mean_removed 		= 0;
 8020448:	7141      	strb	r1, [r0, #5]
	p_fft_config->window_type 		= WINDOW_BLACKMANHARRIS;
 802044a:	7102      	strb	r2, [r0, #4]
	p_fft_config->scaling_factor	= 1.0F;
 802044c:	6083      	str	r3, [r0, #8]
}
 802044e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8020452:	4770      	bx	lr

08020454 <SystemCoreClockUpdate>:
  uint32_t pdiv;
  uint32_t ndiv;
  uint32_t kdiv;
  uint32_t temp;

  if (SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSSEL_Msk)
 8020454:	4b1c      	ldr	r3, [pc, #112]	; (80204c8 <SystemCoreClockUpdate+0x74>)
 8020456:	68db      	ldr	r3, [r3, #12]
 8020458:	03d9      	lsls	r1, r3, #15

  SystemCoreClockUpdate();
}

__WEAK void SystemCoreClockUpdate(void)
{
 802045a:	b510      	push	{r4, lr}
  uint32_t pdiv;
  uint32_t ndiv;
  uint32_t kdiv;
  uint32_t temp;

  if (SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSSEL_Msk)
 802045c:	d51d      	bpl.n	802049a <SystemCoreClockUpdate+0x46>
  {
    /* fPLL is clock source for fSYS */
    if(SCU_PLL->PLLCON2 & SCU_PLL_PLLCON2_PINSEL_Msk)
 802045e:	4b1b      	ldr	r3, [pc, #108]	; (80204cc <SystemCoreClockUpdate+0x78>)
 8020460:	68db      	ldr	r3, [r3, #12]
 8020462:	07da      	lsls	r2, r3, #31
 8020464:	d52c      	bpl.n	80204c0 <SystemCoreClockUpdate+0x6c>
    {
      /* PLL input clock is the backup clock (fOFI) */
      temp = OFI_FREQUENCY;
 8020466:	481a      	ldr	r0, [pc, #104]	; (80204d0 <SystemCoreClockUpdate+0x7c>)
      /* PLL input clock is the high performance osicllator (fOSCHP) */
      temp = OSCHP_GetFrequency();
    }

    /* check if PLL is locked */
    if (SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk)
 8020468:	4a18      	ldr	r2, [pc, #96]	; (80204cc <SystemCoreClockUpdate+0x78>)
 802046a:	6813      	ldr	r3, [r2, #0]
 802046c:	075b      	lsls	r3, r3, #29
 802046e:	d416      	bmi.n	802049e <SystemCoreClockUpdate+0x4a>
    }
    else
    {
      /* PLL prescalar mode */
      /* read back divider settings */
      kdiv  = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_K1DIV_Msk) >> SCU_PLL_PLLCON1_K1DIV_Pos) + 1;
 8020470:	6893      	ldr	r3, [r2, #8]
 8020472:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8020476:	3301      	adds	r3, #1
      
      temp = (temp / kdiv);
 8020478:	fbb0 f3f3 	udiv	r3, r0, r3
  {
    /* fOFI is clock source for fSYS */    
    temp = OFI_FREQUENCY;
  }

  temp = temp / ((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk) + 1);
 802047c:	4a12      	ldr	r2, [pc, #72]	; (80204c8 <SystemCoreClockUpdate+0x74>)
  temp = temp / ((SCU_CLK->CPUCLKCR & SCU_CLK_CPUCLKCR_CPUDIV_Msk) + 1);

  SystemCoreClock = temp;
 802047e:	4915      	ldr	r1, [pc, #84]	; (80204d4 <SystemCoreClockUpdate+0x80>)
  {
    /* fOFI is clock source for fSYS */    
    temp = OFI_FREQUENCY;
  }

  temp = temp / ((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk) + 1);
 8020480:	68d0      	ldr	r0, [r2, #12]
  temp = temp / ((SCU_CLK->CPUCLKCR & SCU_CLK_CPUCLKCR_CPUDIV_Msk) + 1);
 8020482:	6912      	ldr	r2, [r2, #16]
  {
    /* fOFI is clock source for fSYS */    
    temp = OFI_FREQUENCY;
  }

  temp = temp / ((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk) + 1);
 8020484:	b2c0      	uxtb	r0, r0
  temp = temp / ((SCU_CLK->CPUCLKCR & SCU_CLK_CPUCLKCR_CPUDIV_Msk) + 1);
 8020486:	f002 0201 	and.w	r2, r2, #1
  {
    /* fOFI is clock source for fSYS */    
    temp = OFI_FREQUENCY;
  }

  temp = temp / ((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk) + 1);
 802048a:	3001      	adds	r0, #1
  temp = temp / ((SCU_CLK->CPUCLKCR & SCU_CLK_CPUCLKCR_CPUDIV_Msk) + 1);
 802048c:	3201      	adds	r2, #1
  {
    /* fOFI is clock source for fSYS */    
    temp = OFI_FREQUENCY;
  }

  temp = temp / ((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk) + 1);
 802048e:	fbb3 f0f0 	udiv	r0, r3, r0
  temp = temp / ((SCU_CLK->CPUCLKCR & SCU_CLK_CPUCLKCR_CPUDIV_Msk) + 1);
 8020492:	fbb0 f0f2 	udiv	r0, r0, r2

  SystemCoreClock = temp;
 8020496:	6008      	str	r0, [r1, #0]
 8020498:	bd10      	pop	{r4, pc}
    }
  }
  else
  {
    /* fOFI is clock source for fSYS */    
    temp = OFI_FREQUENCY;
 802049a:	4b0d      	ldr	r3, [pc, #52]	; (80204d0 <SystemCoreClockUpdate+0x7c>)
 802049c:	e7ee      	b.n	802047c <SystemCoreClockUpdate+0x28>
    /* check if PLL is locked */
    if (SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk)
    {
      /* PLL normal mode */
      /* read back divider settings */
      pdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_PDIV_Msk) >> SCU_PLL_PLLCON1_PDIV_Pos) + 1;
 802049e:	6891      	ldr	r1, [r2, #8]
      ndiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_NDIV_Msk) >> SCU_PLL_PLLCON1_NDIV_Pos) + 1;
 80204a0:	6893      	ldr	r3, [r2, #8]
      kdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_K2DIV_Msk) >> SCU_PLL_PLLCON1_K2DIV_Pos) + 1;
 80204a2:	6894      	ldr	r4, [r2, #8]
    /* check if PLL is locked */
    if (SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk)
    {
      /* PLL normal mode */
      /* read back divider settings */
      pdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_PDIV_Msk) >> SCU_PLL_PLLCON1_PDIV_Pos) + 1;
 80204a4:	f3c1 6203 	ubfx	r2, r1, #24, #4
 80204a8:	3201      	adds	r2, #1
      ndiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_NDIV_Msk) >> SCU_PLL_PLLCON1_NDIV_Pos) + 1;
      kdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_K2DIV_Msk) >> SCU_PLL_PLLCON1_K2DIV_Pos) + 1;
 80204aa:	f3c4 4106 	ubfx	r1, r4, #16, #7
    if (SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk)
    {
      /* PLL normal mode */
      /* read back divider settings */
      pdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_PDIV_Msk) >> SCU_PLL_PLLCON1_PDIV_Pos) + 1;
      ndiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_NDIV_Msk) >> SCU_PLL_PLLCON1_NDIV_Pos) + 1;
 80204ae:	f3c3 2306 	ubfx	r3, r3, #8, #7
      kdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_K2DIV_Msk) >> SCU_PLL_PLLCON1_K2DIV_Pos) + 1;

      temp = (temp / (pdiv * kdiv)) * ndiv;
 80204b2:	fb01 2202 	mla	r2, r1, r2, r2
 80204b6:	fbb0 f0f2 	udiv	r0, r0, r2
 80204ba:	fb03 0300 	mla	r3, r3, r0, r0
 80204be:	e7dd      	b.n	802047c <SystemCoreClockUpdate+0x28>
      temp = OFI_FREQUENCY;
    }
    else
    {
      /* PLL input clock is the high performance osicllator (fOSCHP) */
      temp = OSCHP_GetFrequency();
 80204c0:	f008 fa30 	bl	8028924 <OSCHP_GetFrequency>
 80204c4:	e7d0      	b.n	8020468 <SystemCoreClockUpdate+0x14>
 80204c6:	bf00      	nop
 80204c8:	50004600 	.word	0x50004600
 80204cc:	50004710 	.word	0x50004710
 80204d0:	016e3600 	.word	0x016e3600
 80204d4:	2003ffc0 	.word	0x2003ffc0

080204d8 <SystemInit>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

__WEAK void SystemInit(void)
{
 80204d8:	b510      	push	{r4, lr}
  memcpy(g_chipid, CHIPID_LOC, 16);
 80204da:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 80204de:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 80204e0:	4c03      	ldr	r4, [pc, #12]	; (80204f0 <SystemInit+0x18>)
 80204e2:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
  
  SystemCoreSetup();
 80204e6:	f007 f9b9 	bl	802785c <SystemCoreSetup>
  SystemCoreClockSetup(); 
 80204ea:	f008 fa1f 	bl	802892c <SystemCoreClockSetup>
 80204ee:	bd10      	pop	{r4, pc}
 80204f0:	2003ffc4 	.word	0x2003ffc4

080204f4 <get_buffer_address_by_chirp>:

uint8_t *get_buffer_address_by_chirp(acq_buf_obj *p_obj, uint32_t channel_index, uint32_t chirpCnt)
{
  size_t offset = 0;
  
  if(p_obj->p_acq_buf == NULL)
 80204f4:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80204f6:	b15b      	cbz	r3, 8020510 <get_buffer_address_by_chirp+0x1c>
   2. EXPORTED FUNCTIONS
==============================================================================
 */

uint8_t *get_buffer_address_by_chirp(acq_buf_obj *p_obj, uint32_t channel_index, uint32_t chirpCnt)
{
 80204f8:	b410      	push	{r4}
  
  if(p_obj->p_acq_buf == NULL)
    return NULL;
  
  // Since the chirps are interleaved, we calculate the buffer base address for a new chirp and the related channel here:
  offset = (p_obj->internals.chirp_inc * chirpCnt) + (p_obj->internals.channel_inc * channel_index);
 80204fa:	6944      	ldr	r4, [r0, #20]
 80204fc:	6900      	ldr	r0, [r0, #16]
 80204fe:	fb04 f101 	mul.w	r1, r4, r1
 8020502:	fb00 1202 	mla	r2, r0, r2, r1
  
  return &p_obj->p_acq_buf[offset];
 8020506:	4413      	add	r3, r2
}
 8020508:	4618      	mov	r0, r3
 802050a:	f85d 4b04 	ldr.w	r4, [sp], #4
 802050e:	4770      	bx	lr
 8020510:	4618      	mov	r0, r3
 8020512:	4770      	bx	lr

08020514 <create_acq_data_buffer_obj>:

//============================================================================

acq_buf_obj create_acq_data_buffer_obj(uint8_t *p_allocated_buffer, size_t allocated_buffer_size,
                                       uint16_t max_num_of_chirps_per_frame, uint16_t max_num_of_samples_per_chirp, uint16_t max_num_of_I_values, uint16_t max_num_of_Q_values, uint16_t adc_resolution) 
{
 8020514:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8020518:	f8bd e024 	ldrh.w	lr, [sp, #36]	; 0x24
 802051c:	f8bd 701c 	ldrh.w	r7, [sp, #28]
 8020520:	f8bd 6020 	ldrh.w	r6, [sp, #32]
 8020524:	f8bd 5018 	ldrh.w	r5, [sp, #24]
  obj.status = allocation_ok;
  obj.access_lock = 0;
  obj.acq_timestime = 0;
  obj.internals.is_dynamic_allocated = 0;
  
  obj.params.num_of_chirps_per_frame = max_num_of_chirps_per_frame;
 8020528:	8083      	strh	r3, [r0, #4]
acq_buf_obj create_acq_data_buffer_obj(uint8_t *p_allocated_buffer, size_t allocated_buffer_size,
                                       uint16_t max_num_of_chirps_per_frame, uint16_t max_num_of_samples_per_chirp, uint16_t max_num_of_I_values, uint16_t max_num_of_Q_values, uint16_t adc_resolution) 
{
  acq_buf_obj obj;
  size_t required_size = 0;
  size_t value_size = ((adc_resolution - 1) / 8 ) + 1;
 802052a:	f1be 0401 	subs.w	r4, lr, #1
 802052e:	bf48      	it	mi
 8020530:	f10e 0406 	addmi.w	r4, lr, #6
 8020534:	10e4      	asrs	r4, r4, #3
 8020536:	3401      	adds	r4, #1
  obj.acq_timestime = 0;
  obj.internals.is_dynamic_allocated = 0;
  
  obj.params.num_of_chirps_per_frame = max_num_of_chirps_per_frame;
  obj.params.num_of_samples_per_chirp = max_num_of_samples_per_chirp;
  obj.params.num_of_rx_values = (max_num_of_I_values + max_num_of_Q_values);
 8020538:	eb07 0e06 	add.w	lr, r7, r6
  acq_buf_obj obj;
  size_t required_size = 0;
  size_t value_size = ((adc_resolution - 1) / 8 ) + 1;
  
  obj.status = allocation_ok;
  obj.access_lock = 0;
 802053c:	f04f 0c00 	mov.w	ip, #0
  obj.acq_timestime = 0;
  obj.internals.is_dynamic_allocated = 0;
  
  obj.params.num_of_chirps_per_frame = max_num_of_chirps_per_frame;
  obj.params.num_of_samples_per_chirp = max_num_of_samples_per_chirp;
  obj.params.num_of_rx_values = (max_num_of_I_values + max_num_of_Q_values);
 8020540:	fa1f fe8e 	uxth.w	lr, lr
{
  acq_buf_obj obj;
  size_t required_size = 0;
  size_t value_size = ((adc_resolution - 1) / 8 ) + 1;
  
  obj.status = allocation_ok;
 8020544:	f04f 0801 	mov.w	r8, #1
  obj.params.num_of_rx_values = (max_num_of_I_values + max_num_of_Q_values);
  obj.params.size_of_value_in_bytes = value_size;
  
  obj.data_type = data_type_unknown;
  // derive format type from parameters:
  if ((value_size == 2) && (max_num_of_I_values == max_num_of_Q_values) && max_num_of_I_values == 2)
 8020548:	2c02      	cmp	r4, #2
  obj.internals.is_dynamic_allocated = 0;
  
  obj.params.num_of_chirps_per_frame = max_num_of_chirps_per_frame;
  obj.params.num_of_samples_per_chirp = max_num_of_samples_per_chirp;
  obj.params.num_of_rx_values = (max_num_of_I_values + max_num_of_Q_values);
  obj.params.size_of_value_in_bytes = value_size;
 802054a:	8104      	strh	r4, [r0, #8]
  obj.access_lock = 0;
  obj.acq_timestime = 0;
  obj.internals.is_dynamic_allocated = 0;
  
  obj.params.num_of_chirps_per_frame = max_num_of_chirps_per_frame;
  obj.params.num_of_samples_per_chirp = max_num_of_samples_per_chirp;
 802054c:	8045      	strh	r5, [r0, #2]
  obj.params.num_of_rx_values = (max_num_of_I_values + max_num_of_Q_values);
 802054e:	f8a0 e006 	strh.w	lr, [r0, #6]
{
  acq_buf_obj obj;
  size_t required_size = 0;
  size_t value_size = ((adc_resolution - 1) / 8 ) + 1;
  
  obj.status = allocation_ok;
 8020552:	f880 802c 	strb.w	r8, [r0, #44]	; 0x2c
  obj.access_lock = 0;
 8020556:	f8c0 c024 	str.w	ip, [r0, #36]	; 0x24
  obj.acq_timestime = 0;
 802055a:	f8c0 c020 	str.w	ip, [r0, #32]
  obj.internals.is_dynamic_allocated = 0;
 802055e:	f8c0 c018 	str.w	ip, [r0, #24]
  obj.params.num_of_chirps_per_frame = max_num_of_chirps_per_frame;
  obj.params.num_of_samples_per_chirp = max_num_of_samples_per_chirp;
  obj.params.num_of_rx_values = (max_num_of_I_values + max_num_of_Q_values);
  obj.params.size_of_value_in_bytes = value_size;
  
  obj.data_type = data_type_unknown;
 8020562:	f880 c000 	strb.w	ip, [r0]
  // derive format type from parameters:
  if ((value_size == 2) && (max_num_of_I_values == max_num_of_Q_values) && max_num_of_I_values == 2)
 8020566:	d02b      	beq.n	80205c0 <create_acq_data_buffer_obj+0xac>
    obj.data_type = uint16_1x_IandQ;
  }
  
  // calculate the size of allocation buffer
  // consider that an internal acquisition buffer needs to be uint32_t bit aligned on ARM!
  required_size = obj.params.num_of_chirps_per_frame * obj.params.num_of_samples_per_chirp * obj.params.num_of_rx_values * obj.params.size_of_value_in_bytes;
 8020568:	fb05 f303 	mul.w	r3, r5, r3
 802056c:	fb0e f303 	mul.w	r3, lr, r3
 8020570:	fb03 f304 	mul.w	r3, r3, r4
  
  obj.p_acq_buf = p_allocated_buffer;
  obj.internals.size_of_acq_buffer = allocated_buffer_size;
  obj.used_size_of_acq_buffer = required_size;
  
  if ((max_num_of_I_values > MAX_SUPPORTED_RX_SIGNALS_INT) || (max_num_of_Q_values > MAX_SUPPORTED_RX_SIGNALS_INT))
 8020574:	2f02      	cmp	r7, #2
  // consider that an internal acquisition buffer needs to be uint32_t bit aligned on ARM!
  required_size = obj.params.num_of_chirps_per_frame * obj.params.num_of_samples_per_chirp * obj.params.num_of_rx_values * obj.params.size_of_value_in_bytes;
  
  obj.p_acq_buf = p_allocated_buffer;
  obj.internals.size_of_acq_buffer = allocated_buffer_size;
  obj.used_size_of_acq_buffer = required_size;
 8020576:	61c3      	str	r3, [r0, #28]
  
  // calculate the size of allocation buffer
  // consider that an internal acquisition buffer needs to be uint32_t bit aligned on ARM!
  required_size = obj.params.num_of_chirps_per_frame * obj.params.num_of_samples_per_chirp * obj.params.num_of_rx_values * obj.params.size_of_value_in_bytes;
  
  obj.p_acq_buf = p_allocated_buffer;
 8020578:	6281      	str	r1, [r0, #40]	; 0x28
  obj.internals.size_of_acq_buffer = allocated_buffer_size;
 802057a:	60c2      	str	r2, [r0, #12]
  obj.used_size_of_acq_buffer = required_size;
  
  if ((max_num_of_I_values > MAX_SUPPORTED_RX_SIGNALS_INT) || (max_num_of_Q_values > MAX_SUPPORTED_RX_SIGNALS_INT))
 802057c:	d817      	bhi.n	80205ae <create_acq_data_buffer_obj+0x9a>
 802057e:	2e02      	cmp	r6, #2
 8020580:	d815      	bhi.n	80205ae <create_acq_data_buffer_obj+0x9a>
    obj.internals.size_of_acq_buffer = 0;
    obj.used_size_of_acq_buffer = 0;
    return obj;
  }
  
  if (p_allocated_buffer != NULL && allocated_buffer_size == 0)
 8020582:	2900      	cmp	r1, #0
 8020584:	d036      	beq.n	80205f4 <create_acq_data_buffer_obj+0xe0>
 8020586:	b35a      	cbz	r2, 80205e0 <create_acq_data_buffer_obj+0xcc>
    obj.internals.size_of_acq_buffer = 0;
    obj.used_size_of_acq_buffer = 0;
    return obj;
  }
  
  if (((obj.p_acq_buf != NULL) && (obj.internals.size_of_acq_buffer != 0)) && obj.internals.size_of_acq_buffer < required_size)
 8020588:	429a      	cmp	r2, r3
 802058a:	d331      	bcc.n	80205f0 <create_acq_data_buffer_obj+0xdc>
  obj.internals.channel_inc = obj.params.num_of_samples_per_chirp*obj.params.size_of_value_in_bytes;
  obj.internals.chirp_inc   = obj.internals.channel_inc * obj.params.num_of_rx_values;
  
  if(obj.p_acq_buf != NULL)
  {
    memset(obj.p_acq_buf, 0, sizeof(obj.used_size_of_acq_buffer));
 802058c:	460b      	mov	r3, r1
 802058e:	2200      	movs	r2, #0
 8020590:	f803 2b01 	strb.w	r2, [r3], #1
 8020594:	3301      	adds	r3, #1
 8020596:	704a      	strb	r2, [r1, #1]
 8020598:	f803 2b01 	strb.w	r2, [r3], #1
    }
  }
#endif
  
  // calculated internal buffer offsets
  obj.internals.channel_inc = obj.params.num_of_samples_per_chirp*obj.params.size_of_value_in_bytes;
 802059c:	fb05 f404 	mul.w	r4, r5, r4
  obj.internals.chirp_inc   = obj.internals.channel_inc * obj.params.num_of_rx_values;
 80205a0:	fb0e f104 	mul.w	r1, lr, r4
  
  if(obj.p_acq_buf != NULL)
  {
    memset(obj.p_acq_buf, 0, sizeof(obj.used_size_of_acq_buffer));
 80205a4:	701a      	strb	r2, [r3, #0]
  }
#endif
  
  // calculated internal buffer offsets
  obj.internals.channel_inc = obj.params.num_of_samples_per_chirp*obj.params.size_of_value_in_bytes;
  obj.internals.chirp_inc   = obj.internals.channel_inc * obj.params.num_of_rx_values;
 80205a6:	6101      	str	r1, [r0, #16]
    }
  }
#endif
  
  // calculated internal buffer offsets
  obj.internals.channel_inc = obj.params.num_of_samples_per_chirp*obj.params.size_of_value_in_bytes;
 80205a8:	6144      	str	r4, [r0, #20]
 80205aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  obj.internals.size_of_acq_buffer = allocated_buffer_size;
  obj.used_size_of_acq_buffer = required_size;
  
  if ((max_num_of_I_values > MAX_SUPPORTED_RX_SIGNALS_INT) || (max_num_of_Q_values > MAX_SUPPORTED_RX_SIGNALS_INT))
  {
    obj.status = num_of_RX_not_supported;
 80205ae:	2205      	movs	r2, #5
  }
  
  if (((obj.p_acq_buf != NULL) && (obj.internals.size_of_acq_buffer != 0)) && obj.internals.size_of_acq_buffer < required_size)
  {
    obj.status = allocation_buffer_too_small;
    obj.p_acq_buf = NULL;
 80205b0:	2300      	movs	r3, #0
    return obj;
  }
  
  if (((obj.p_acq_buf != NULL) && (obj.internals.size_of_acq_buffer != 0)) && obj.internals.size_of_acq_buffer < required_size)
  {
    obj.status = allocation_buffer_too_small;
 80205b2:	f880 202c 	strb.w	r2, [r0, #44]	; 0x2c
    obj.p_acq_buf = NULL;
 80205b6:	6283      	str	r3, [r0, #40]	; 0x28
    obj.internals.size_of_acq_buffer = 0;
 80205b8:	60c3      	str	r3, [r0, #12]
    obj.used_size_of_acq_buffer = 0;
 80205ba:	61c3      	str	r3, [r0, #28]
    return obj;
 80205bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  obj.params.num_of_rx_values = (max_num_of_I_values + max_num_of_Q_values);
  obj.params.size_of_value_in_bytes = value_size;
  
  obj.data_type = data_type_unknown;
  // derive format type from parameters:
  if ((value_size == 2) && (max_num_of_I_values == max_num_of_Q_values) && max_num_of_I_values == 2)
 80205c0:	42b7      	cmp	r7, r6
 80205c2:	d1d1      	bne.n	8020568 <create_acq_data_buffer_obj+0x54>
 80205c4:	2e02      	cmp	r6, #2
 80205c6:	d01d      	beq.n	8020604 <create_acq_data_buffer_obj+0xf0>
  {
    obj.data_type = uint16_2x_IandQ;
  }
  else if ((value_size == 2) && (max_num_of_I_values == max_num_of_Q_values) && max_num_of_I_values == 1)
 80205c8:	2e01      	cmp	r6, #1
 80205ca:	d1cd      	bne.n	8020568 <create_acq_data_buffer_obj+0x54>
  {
    obj.data_type = uint16_1x_IandQ;
 80205cc:	7004      	strb	r4, [r0, #0]
  }
  
  // calculate the size of allocation buffer
  // consider that an internal acquisition buffer needs to be uint32_t bit aligned on ARM!
  required_size = obj.params.num_of_chirps_per_frame * obj.params.num_of_samples_per_chirp * obj.params.num_of_rx_values * obj.params.size_of_value_in_bytes;
 80205ce:	fb05 f303 	mul.w	r3, r5, r3
 80205d2:	fb0e f303 	mul.w	r3, lr, r3
 80205d6:	005b      	lsls	r3, r3, #1
  
  obj.p_acq_buf = p_allocated_buffer;
  obj.internals.size_of_acq_buffer = allocated_buffer_size;
  obj.used_size_of_acq_buffer = required_size;
 80205d8:	61c3      	str	r3, [r0, #28]
  
  // calculate the size of allocation buffer
  // consider that an internal acquisition buffer needs to be uint32_t bit aligned on ARM!
  required_size = obj.params.num_of_chirps_per_frame * obj.params.num_of_samples_per_chirp * obj.params.num_of_rx_values * obj.params.size_of_value_in_bytes;
  
  obj.p_acq_buf = p_allocated_buffer;
 80205da:	6281      	str	r1, [r0, #40]	; 0x28
  obj.internals.size_of_acq_buffer = allocated_buffer_size;
 80205dc:	60c2      	str	r2, [r0, #12]
 80205de:	e7ce      	b.n	802057e <create_acq_data_buffer_obj+0x6a>
    return obj;
  }
  
  if (p_allocated_buffer != NULL && allocated_buffer_size == 0)
  {
    obj.status = allocation_size_is_zero;
 80205e0:	2304      	movs	r3, #4
    obj.p_acq_buf = NULL;
 80205e2:	6282      	str	r2, [r0, #40]	; 0x28
    obj.internals.size_of_acq_buffer = 0;
 80205e4:	60c2      	str	r2, [r0, #12]
    obj.used_size_of_acq_buffer = 0;
 80205e6:	61c2      	str	r2, [r0, #28]
    return obj;
  }
  
  if (p_allocated_buffer != NULL && allocated_buffer_size == 0)
  {
    obj.status = allocation_size_is_zero;
 80205e8:	f880 302c 	strb.w	r3, [r0, #44]	; 0x2c
    obj.p_acq_buf = NULL;
    obj.internals.size_of_acq_buffer = 0;
    obj.used_size_of_acq_buffer = 0;
    return obj;
 80205ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  
  if (((obj.p_acq_buf != NULL) && (obj.internals.size_of_acq_buffer != 0)) && obj.internals.size_of_acq_buffer < required_size)
  {
    obj.status = allocation_buffer_too_small;
 80205f0:	2203      	movs	r2, #3
 80205f2:	e7dd      	b.n	80205b0 <create_acq_data_buffer_obj+0x9c>
    }
  }
#endif
  
  // calculated internal buffer offsets
  obj.internals.channel_inc = obj.params.num_of_samples_per_chirp*obj.params.size_of_value_in_bytes;
 80205f4:	fb05 f404 	mul.w	r4, r5, r4
  obj.internals.chirp_inc   = obj.internals.channel_inc * obj.params.num_of_rx_values;
 80205f8:	fb0e f304 	mul.w	r3, lr, r4
 80205fc:	6103      	str	r3, [r0, #16]
    }
  }
#endif
  
  // calculated internal buffer offsets
  obj.internals.channel_inc = obj.params.num_of_samples_per_chirp*obj.params.size_of_value_in_bytes;
 80205fe:	6144      	str	r4, [r0, #20]
 8020600:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  
  obj.data_type = data_type_unknown;
  // derive format type from parameters:
  if ((value_size == 2) && (max_num_of_I_values == max_num_of_Q_values) && max_num_of_I_values == 2)
  {
    obj.data_type = uint16_2x_IandQ;
 8020604:	2704      	movs	r7, #4
 8020606:	7007      	strb	r7, [r0, #0]
 8020608:	e7e1      	b.n	80205ce <create_acq_data_buffer_obj+0xba>
 802060a:	bf00      	nop

0802060c <delete_acq_buffer_obj>:

//============================================================================

void delete_acq_buffer_obj(acq_buf_obj *p_obj) 
{ 
  p_obj->status = allocation_is_freed;
 802060c:	2206      	movs	r2, #6
  p_obj->used_size_of_acq_buffer = 0;
 802060e:	2300      	movs	r3, #0

//============================================================================

void delete_acq_buffer_obj(acq_buf_obj *p_obj) 
{ 
  p_obj->status = allocation_is_freed;
 8020610:	f880 202c 	strb.w	r2, [r0, #44]	; 0x2c
  p_obj->used_size_of_acq_buffer = 0;
 8020614:	61c3      	str	r3, [r0, #28]
 8020616:	4770      	bx	lr

08020618 <radar_set_adc_configuration>:
   2. EXPORTED FUNCTIONS
==============================================================================
 */

uint16_t radar_set_adc_configuration(Radar_Handle_t device, const Adc_Configuration_t* configuration)
{
 8020618:	b570      	push	{r4, r5, r6, lr}
 802061a:	4606      	mov	r6, r0
 802061c:	460d      	mov	r5, r1
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  uint32_t chirp_time_usec;
  
  /* Configuration change is only allowed while automatic trigger is not working */
  if (radar_get_data_acq_mode() != RADAR_MANUAL_TRIGGER)
 802061e:	f000 fe43 	bl	80212a8 <radar_get_data_acq_mode>
 8020622:	4604      	mov	r4, r0
 8020624:	b108      	cbz	r0, 802062a <radar_set_adc_configuration+0x12>
  {
    return (RADAR_ERR_BUSY);
 8020626:	2002      	movs	r0, #2
 8020628:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  /* Check if configuration is valid */
  /* ------------------------------- */
  if ((configuration->samplerate_Hz == 0) || (configuration->samplerate_Hz > BSP_MAX_ADC_FREQ_HZ))
 802062a:	682b      	ldr	r3, [r5, #0]
 802062c:	4a1f      	ldr	r2, [pc, #124]	; (80206ac <radar_set_adc_configuration+0x94>)
 802062e:	3b01      	subs	r3, #1
 8020630:	4293      	cmp	r3, r2
 8020632:	d901      	bls.n	8020638 <radar_set_adc_configuration+0x20>
  {
    return (RADAR_ERR_SAMPLERATE_OUT_OF_RANGE);
 8020634:	2050      	movs	r0, #80	; 0x50
 8020636:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  if (configuration->resolution != BSP_ADC_RESOLUTION)
 8020638:	792b      	ldrb	r3, [r5, #4]
 802063a:	2b0c      	cmp	r3, #12
 802063c:	d001      	beq.n	8020642 <radar_set_adc_configuration+0x2a>
  {
    return (RADAR_ERR_UNSUPPORTED_RESOLUTION);
 802063e:	2051      	movs	r0, #81	; 0x51
  /* ---------------------------------------------------------- */
  /* Copy the new adc configuration to the data store*/
  ds_ep_store_adc_config(configuration);
  
  return (RADAR_ERR_OK);
}
 8020640:	bd70      	pop	{r4, r5, r6, pc}
  
  /* Apply ADC configuration */
  /* ----------------------- */
  //sample_rate_divider = ((REFERENCE_OSC_FREQ_HZ << 1) / configuration->samplerate_Hz + 1) >> 1;
  
  if (ds_device_get_settings()->pll_modulation_mode == MODULATION_FMCW)
 8020642:	f7ff fd77 	bl	8020134 <ds_device_get_settings>
 8020646:	6983      	ldr	r3, [r0, #24]
 8020648:	2b01      	cmp	r3, #1
 802064a:	d013      	beq.n	8020674 <radar_set_adc_configuration+0x5c>
  }
  else
  {
    /* Apply ADC configuration */
    /* ----------------------- */
    if (radar_set_sampling_freq(device, MODULATION_DOPPLER, ds_device_get_settings()->adc_sampling_freq_Hz) != RADAR_ERR_OK)
 802064c:	f7ff fd72 	bl	8020134 <ds_device_get_settings>
 8020650:	69c2      	ldr	r2, [r0, #28]
 8020652:	ee07 2a90 	vmov	s15, r2
 8020656:	eef8 7a67 	vcvt.f32.u32	s15, s15
 802065a:	4621      	mov	r1, r4
 802065c:	ee17 2a90 	vmov	r2, s15
 8020660:	4630      	mov	r0, r6
 8020662:	f000 fd9f 	bl	80211a4 <radar_set_sampling_freq>
 8020666:	2800      	cmp	r0, #0
 8020668:	d1e4      	bne.n	8020634 <radar_set_adc_configuration+0x1c>
  }
  
  /* Remember configuration (adjust frequency to rounded value) */
  /* ---------------------------------------------------------- */
  /* Copy the new adc configuration to the data store*/
  ds_ep_store_adc_config(configuration);
 802066a:	4628      	mov	r0, r5
 802066c:	f7ff fdfa 	bl	8020264 <ds_ep_store_adc_config>
  
  return (RADAR_ERR_OK);
 8020670:	2000      	movs	r0, #0
 8020672:	bd70      	pop	{r4, r5, r6, pc}
  /* ----------------------- */
  //sample_rate_divider = ((REFERENCE_OSC_FREQ_HZ << 1) / configuration->samplerate_Hz + 1) >> 1;
  
  if (ds_device_get_settings()->pll_modulation_mode == MODULATION_FMCW)
  {
    chirp_time_usec = (uint32_t) (((float)ds_device_get_settings()->num_samples_per_chirp * 1000.0f ) / configuration->samplerate_Hz * 1000.0f);
 8020674:	f7ff fd5e 	bl	8020134 <ds_device_get_settings>
 8020678:	ed90 7a0b 	vldr	s14, [r0, #44]	; 0x2c
 802067c:	eddf 6a0c 	vldr	s13, [pc, #48]	; 80206b0 <radar_set_adc_configuration+0x98>
 8020680:	edd5 7a00 	vldr	s15, [r5]
 8020684:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 8020688:	eef8 7a67 	vcvt.f32.u32	s15, s15
 802068c:	ee27 7a26 	vmul.f32	s14, s14, s13
    
    if (radar_set_chirp_time(device, chirp_time_usec) != RADAR_ERR_OK)
 8020690:	4630      	mov	r0, r6
  /* ----------------------- */
  //sample_rate_divider = ((REFERENCE_OSC_FREQ_HZ << 1) / configuration->samplerate_Hz + 1) >> 1;
  
  if (ds_device_get_settings()->pll_modulation_mode == MODULATION_FMCW)
  {
    chirp_time_usec = (uint32_t) (((float)ds_device_get_settings()->num_samples_per_chirp * 1000.0f ) / configuration->samplerate_Hz * 1000.0f);
 8020692:	eec7 7a27 	vdiv.f32	s15, s14, s15
 8020696:	ee67 7aa6 	vmul.f32	s15, s15, s13
    
    if (radar_set_chirp_time(device, chirp_time_usec) != RADAR_ERR_OK)
 802069a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 802069e:	ee17 1a90 	vmov	r1, s15
 80206a2:	f000 fd25 	bl	80210f0 <radar_set_chirp_time>
 80206a6:	2800      	cmp	r0, #0
 80206a8:	d1c4      	bne.n	8020634 <radar_set_adc_configuration+0x1c>
 80206aa:	e7de      	b.n	802066a <radar_set_adc_configuration+0x52>
 80206ac:	0016e35f 	.word	0x0016e35f
 80206b0:	447a0000 	.word	0x447a0000

080206b4 <radar_get_adc_configuration>:

uint16_t radar_get_adc_configuration(Radar_Handle_t device, Adc_Configuration_t* configuration)
{
  XMC_UNUSED_ARG(device);  /* Suppress compiler warnings of unused variable */
  
  if(configuration != NULL)
 80206b4:	b129      	cbz	r1, 80206c2 <radar_get_adc_configuration+0xe>
}

//============================================================================

uint16_t radar_get_adc_configuration(Radar_Handle_t device, Adc_Configuration_t* configuration)
{
 80206b6:	b508      	push	{r3, lr}
 80206b8:	4608      	mov	r0, r1
  XMC_UNUSED_ARG(device);  /* Suppress compiler warnings of unused variable */
  
  if(configuration != NULL)
  {
    ds_ep_fetch_adc_config(configuration);
 80206ba:	f7ff fdc5 	bl	8020248 <ds_ep_fetch_adc_config>
    return (RADAR_ERR_OK);
 80206be:	2000      	movs	r0, #0
 80206c0:	bd08      	pop	{r3, pc}
  }
  return (RADAR_ERR_FEATURE_UNAVAILABLE);
 80206c2:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 80206c6:	4770      	bx	lr

080206c8 <radar_get_driver_version>:
 */

const Driver_Version_t* radar_get_driver_version(void)
{
  return (&driver_version_s);
}
 80206c8:	4800      	ldr	r0, [pc, #0]	; (80206cc <radar_get_driver_version+0x4>)
 80206ca:	4770      	bx	lr
 80206cc:	08030950 	.word	0x08030950

080206d0 <radar_open_device>:
}

//============================================================================

uint16_t radar_open_device(int32_t device_number, Radar_Handle_t* device)
{
 80206d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80206d4:	b09a      	sub	sp, #104	; 0x68
  
  Frame_Format_t frame_format;
  uint16_t retValue = RADAR_ERR_OK;
  int32_t status = 0;
  uint16_t num_of_bytes;
  void* calibration_data_ptr = NULL;
 80206d6:	2400      	movs	r4, #0
 80206d8:	ae1a      	add	r6, sp, #104	; 0x68
  acq_buf_obj acq_buf = { .status = not_initialized } ;
    
  /* Initialize the driver instance with NULL, until it was successfully initialized */
  *device = NULL;
 80206da:	600c      	str	r4, [r1, #0]
}

//============================================================================

uint16_t radar_open_device(int32_t device_number, Radar_Handle_t* device)
{
 80206dc:	460f      	mov	r7, r1
  
  Frame_Format_t frame_format;
  uint16_t retValue = RADAR_ERR_OK;
  int32_t status = 0;
  uint16_t num_of_bytes;
  void* calibration_data_ptr = NULL;
 80206de:	f846 4d40 	str.w	r4, [r6, #-64]!
  /* Initialize the driver instance with NULL, until it was successfully initialized */
  *device = NULL;
  
  /* Initialize driver data structure */
  /* -------------------------------- */
  status = ds_init();
 80206e2:	f7ff fd49 	bl	8020178 <ds_init>
  status |= radar_read_calibration(device, CALIBRATION_TARGET_FLASH, CALIBRATION_DATA_ADC, &calibration_data_ptr, &num_of_bytes);
 80206e6:	f10d 0e26 	add.w	lr, sp, #38	; 0x26
  /* Initialize the driver instance with NULL, until it was successfully initialized */
  *device = NULL;
  
  /* Initialize driver data structure */
  /* -------------------------------- */
  status = ds_init();
 80206ea:	4605      	mov	r5, r0
  status |= radar_read_calibration(device, CALIBRATION_TARGET_FLASH, CALIBRATION_DATA_ADC, &calibration_data_ptr, &num_of_bytes);
 80206ec:	4633      	mov	r3, r6
 80206ee:	4638      	mov	r0, r7
 80206f0:	4621      	mov	r1, r4
 80206f2:	4622      	mov	r2, r4
 80206f4:	f8cd e000 	str.w	lr, [sp]
 80206f8:	f000 fa94 	bl	8020c24 <radar_read_calibration>
 80206fc:	4328      	orrs	r0, r5
  if(status > 0)
 80206fe:	42a0      	cmp	r0, r4
 8020700:	dd03      	ble.n	802070a <radar_open_device+0x3a>
  {
    return (RADAR_ERR_UNSUPPORTED_FRAME_FORMAT);
 8020702:	2008      	movs	r0, #8
  retValue = radar_init(device);
  
  g_adc_sampling_completed = false;
  
  return (retValue);
}
 8020704:	b01a      	add	sp, #104	; 0x68
 8020706:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  
  //========================================================================
  //------------------------- Frame Format configurations ------------------
  //========================================================================
  ds_ep_fetch_frame_format(&frame_format);
 802070a:	a80b      	add	r0, sp, #44	; 0x2c
 802070c:	f7ff fe24 	bl	8020358 <ds_ep_fetch_frame_format>
  
  //=========================================================================
  //------------------------- General configurations ------------------------
  //=========================================================================
  radar_set_data_acq_mode(RADAR_MANUAL_TRIGGER);
 8020710:	4620      	mov	r0, r4
 8020712:	f000 fdcf 	bl	80212b4 <radar_set_data_acq_mode>
  
  /* If the frame format contains a 0, this makes no sense. */
  if ((frame_format.rx_mask == 0) ||
 8020716:	f89d 3034 	ldrb.w	r3, [sp, #52]	; 0x34
 802071a:	2b00      	cmp	r3, #0
 802071c:	d0f1      	beq.n	8020702 <radar_open_device+0x32>
      (frame_format.num_chirps_per_frame  == 0) ||
 802071e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  //------------------------- General configurations ------------------------
  //=========================================================================
  radar_set_data_acq_mode(RADAR_MANUAL_TRIGGER);
  
  /* If the frame format contains a 0, this makes no sense. */
  if ((frame_format.rx_mask == 0) ||
 8020720:	2b00      	cmp	r3, #0
 8020722:	d0ee      	beq.n	8020702 <radar_open_device+0x32>
      (frame_format.num_chirps_per_frame  == 0) ||
        (frame_format.num_samples_per_chirp == 0) ||
 8020724:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  //=========================================================================
  radar_set_data_acq_mode(RADAR_MANUAL_TRIGGER);
  
  /* If the frame format contains a 0, this makes no sense. */
  if ((frame_format.rx_mask == 0) ||
      (frame_format.num_chirps_per_frame  == 0) ||
 8020726:	1e51      	subs	r1, r2, #1
 8020728:	29ff      	cmp	r1, #255	; 0xff
 802072a:	d8ea      	bhi.n	8020702 <radar_open_device+0x32>
        (frame_format.num_samples_per_chirp == 0) ||
 802072c:	2b40      	cmp	r3, #64	; 0x40
 802072e:	d8e8      	bhi.n	8020702 <radar_open_device+0x32>
    return (RADAR_ERR_UNSUPPORTED_FRAME_FORMAT);
  }
  
  /* Check frame memory limits */
  /* ------------------------- */
  frame_size = frame_format.num_chirps_per_frame * frame_format.num_samples_per_chirp *
 8020730:	fb02 f503 	mul.w	r5, r2, r3
    ds_ep_get_device_info()->num_rx_antennas * 2U * sizeof(uint16_t); // complex IQ samples per antenna
 8020734:	f7ff fe0c 	bl	8020350 <ds_ep_get_device_info>
    return (RADAR_ERR_UNSUPPORTED_FRAME_FORMAT);
  }
  
  /* Check frame memory limits */
  /* ------------------------- */
  frame_size = frame_format.num_chirps_per_frame * frame_format.num_samples_per_chirp *
 8020738:	7b42      	ldrb	r2, [r0, #13]
 802073a:	491e      	ldr	r1, [pc, #120]	; (80207b4 <radar_open_device+0xe4>)
 802073c:	00ab      	lsls	r3, r5, #2
    ds_ep_get_device_info()->num_rx_antennas * 2U * sizeof(uint16_t); // complex IQ samples per antenna
 802073e:	fb02 f303 	mul.w	r3, r2, r3
  
  if (frame_size > BSP_MAX_ADC_BUFFER_SIZE_BYTES)
 8020742:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
    return (RADAR_ERR_UNSUPPORTED_FRAME_FORMAT);
  }
  
  /* Check frame memory limits */
  /* ------------------------- */
  frame_size = frame_format.num_chirps_per_frame * frame_format.num_samples_per_chirp *
 8020746:	600b      	str	r3, [r1, #0]
    ds_ep_get_device_info()->num_rx_antennas * 2U * sizeof(uint16_t); // complex IQ samples per antenna
  
  if (frame_size > BSP_MAX_ADC_BUFFER_SIZE_BYTES)
 8020748:	d8db      	bhi.n	8020702 <radar_open_device+0x32>
    return (RADAR_ERR_UNSUPPORTED_FRAME_FORMAT);
  }
  
  /* Initialize sensor hardware */
  /* -------------------------- */
  acq_buf = create_acq_data_buffer_obj((uint8_t*) data_fifo, BSP_MAX_ADC_BUFFER_SIZE_BYTES,
 802074a:	f8bd 202c 	ldrh.w	r2, [sp, #44]	; 0x2c
 802074e:	9200      	str	r2, [sp, #0]
 8020750:	f10d 0838 	add.w	r8, sp, #56	; 0x38
 8020754:	2202      	movs	r2, #2
 8020756:	210c      	movs	r1, #12
 8020758:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
 802075c:	9201      	str	r2, [sp, #4]
 802075e:	4640      	mov	r0, r8
 8020760:	9202      	str	r2, [sp, #8]
 8020762:	9103      	str	r1, [sp, #12]
 8020764:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8020768:	4913      	ldr	r1, [pc, #76]	; (80207b8 <radar_open_device+0xe8>)
                                       frame_format.num_chirps_per_frame,
                                       frame_format.num_samples_per_chirp, 2, 2, 12);
  
  ds_set_active_acq_buf(acq_buf);
 802076a:	ae12      	add	r6, sp, #72	; 0x48
    return (RADAR_ERR_UNSUPPORTED_FRAME_FORMAT);
  }
  
  /* Initialize sensor hardware */
  /* -------------------------- */
  acq_buf = create_acq_data_buffer_obj((uint8_t*) data_fifo, BSP_MAX_ADC_BUFFER_SIZE_BYTES,
 802076c:	f7ff fed2 	bl	8020514 <create_acq_data_buffer_obj>
                                       frame_format.num_chirps_per_frame,
                                       frame_format.num_samples_per_chirp, 2, 2, 12);
  
  ds_set_active_acq_buf(acq_buf);
 8020770:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8020772:	466d      	mov	r5, sp
 8020774:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8020776:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
 802077a:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
 802077e:	e898 000f 	ldmia.w	r8, {r0, r1, r2, r3}
 8020782:	f7ff fd45 	bl	8020210 <ds_set_active_acq_buf>
  
  ds_device_get_settings()->num_samples_per_chirp = frame_format.num_samples_per_chirp;
 8020786:	f7ff fcd5 	bl	8020134 <ds_device_get_settings>
 802078a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802078c:	62c3      	str	r3, [r0, #44]	; 0x2c
  
  /* Set the number of samples to captured during each chirp
  This value will be used in BSP to configure the DMA block size and destination address */
  bsp_set_num_samples_per_dma_transfer(ds_device_get_settings()->num_samples_per_chirp);
 802078e:	f7ff fcd1 	bl	8020134 <ds_device_get_settings>
 8020792:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8020794:	f009 fd1c 	bl	802a1d0 <bsp_set_num_samples_per_dma_transfer>
  
  ds_device_get_settings()->pll_num_of_chirps_per_frame = frame_format.num_chirps_per_frame;
 8020798:	f7ff fccc 	bl	8020134 <ds_device_get_settings>
 802079c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802079e:	6143      	str	r3, [r0, #20]
  
  /* Set the number of chirps count per frame */
  bsp_set_num_chirps_per_frame(frame_format.num_chirps_per_frame);
 80207a0:	4618      	mov	r0, r3
 80207a2:	f009 fd1b 	bl	802a1dc <bsp_set_num_chirps_per_frame>
  
  /* BGT, PLL, DMA, Timers & Calibration initialization */
  /* -------------------------------------------------- */
  retValue = radar_init(device);
 80207a6:	4638      	mov	r0, r7
 80207a8:	f000 fbdc 	bl	8020f64 <radar_init>
  
  g_adc_sampling_completed = false;
 80207ac:	4b03      	ldr	r3, [pc, #12]	; (80207bc <radar_open_device+0xec>)
 80207ae:	601c      	str	r4, [r3, #0]
  
  return (retValue);
 80207b0:	e7a8      	b.n	8020704 <radar_open_device+0x34>
 80207b2:	bf00      	nop
 80207b4:	1ffe97b8 	.word	0x1ffe97b8
 80207b8:	20004b28 	.word	0x20004b28
 80207bc:	1ffe97c4 	.word	0x1ffe97c4

080207c0 <radar_get_device_info>:
}

//============================================================================

uint16_t radar_get_device_info(Radar_Handle_t device, Device_Info_t* device_info)
{
 80207c0:	b538      	push	{r3, r4, r5, lr}
 80207c2:	460c      	mov	r4, r1
      - Sensor description
      - Hardware Version information
      - Sensor features
      - Data format
  */
  *device_info = *ds_ep_get_device_info();
 80207c4:	f7ff fdc4 	bl	8020350 <ds_ep_get_device_info>
 80207c8:	4605      	mov	r5, r0
 80207ca:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80207cc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80207ce:	682b      	ldr	r3, [r5, #0]
 80207d0:	6023      	str	r3, [r4, #0]
   
  return (RADAR_ERR_OK);
}
 80207d2:	2000      	movs	r0, #0
 80207d4:	bd38      	pop	{r3, r4, r5, pc}
 80207d6:	bf00      	nop

080207d8 <radar_get_temperature>:
uint16_t radar_get_temperature(Radar_Handle_t device, uint8_t temp_sensor, int32_t* temperature_001C)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  /* Check temperature sensor, only single sensor supported */
  if (temp_sensor == 0)
 80207d8:	b109      	cbz	r1, 80207de <radar_get_temperature+0x6>
    
    return (RADAR_ERR_OK);
  }
  else
  {
    return (RADAR_ERR_SENSOR_DOES_NOT_EXIST);
 80207da:	2007      	movs	r0, #7
 80207dc:	4770      	bx	lr
}

//============================================================================

uint16_t radar_get_temperature(Radar_Handle_t device, uint8_t temp_sensor, int32_t* temperature_001C)
{
 80207de:	b538      	push	{r3, r4, r5, lr}
 80207e0:	460c      	mov	r4, r1
 80207e2:	4615      	mov	r5, r2
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  /* Check temperature sensor, only single sensor supported */
  if (temp_sensor == 0)
  {
    *temperature_001C = (int32_t) (bsp_bgt_get_temp_value() * 1000.0f);	// (expected value is actual temperature in C x 1000)
 80207e4:	f009 fce8 	bl	802a1b8 <bsp_bgt_get_temp_value>
 80207e8:	eddf 7a05 	vldr	s15, [pc, #20]	; 8020800 <radar_get_temperature+0x28>
 80207ec:	ee07 0a10 	vmov	s14, r0
 80207f0:	ee67 7a27 	vmul.f32	s15, s14, s15
    
    return (RADAR_ERR_OK);
 80207f4:	4620      	mov	r0, r4
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  /* Check temperature sensor, only single sensor supported */
  if (temp_sensor == 0)
  {
    *temperature_001C = (int32_t) (bsp_bgt_get_temp_value() * 1000.0f);	// (expected value is actual temperature in C x 1000)
 80207f6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80207fa:	edc5 7a00 	vstr	s15, [r5]
    
    return (RADAR_ERR_OK);
 80207fe:	bd38      	pop	{r3, r4, r5, pc}
 8020800:	447a0000 	.word	0x447a0000

08020804 <radar_get_tx_power>:
uint16_t radar_get_tx_power(Radar_Handle_t device, uint8_t tx_antenna, int32_t* tx_power_001dBm)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  /* Check number of TX antenna */
  if (tx_antenna == 0)
 8020804:	b109      	cbz	r1, 802080a <radar_get_tx_power+0x6>
    *tx_power_001dBm = (int32_t)(bsp_bgt_get_txpower_value() * 1000.0f); // return TX power
    
    return (RADAR_ERR_OK);
  }
  
  return (RADAR_ERR_ANTENNA_DOES_NOT_EXIST);
 8020806:	2006      	movs	r0, #6
 8020808:	4770      	bx	lr
}

//============================================================================

uint16_t radar_get_tx_power(Radar_Handle_t device, uint8_t tx_antenna, int32_t* tx_power_001dBm)
{
 802080a:	b538      	push	{r3, r4, r5, lr}
 802080c:	460c      	mov	r4, r1
 802080e:	4615      	mov	r5, r2
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  /* Check number of TX antenna */
  if (tx_antenna == 0)
  {
    *tx_power_001dBm = (int32_t)(bsp_bgt_get_txpower_value() * 1000.0f); // return TX power
 8020810:	f009 fcd8 	bl	802a1c4 <bsp_bgt_get_txpower_value>
 8020814:	eddf 7a05 	vldr	s15, [pc, #20]	; 802082c <radar_get_tx_power+0x28>
 8020818:	ee07 0a10 	vmov	s14, r0
 802081c:	ee67 7a27 	vmul.f32	s15, s14, s15
    
    return (RADAR_ERR_OK);
 8020820:	4620      	mov	r0, r4
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  /* Check number of TX antenna */
  if (tx_antenna == 0)
  {
    *tx_power_001dBm = (int32_t)(bsp_bgt_get_txpower_value() * 1000.0f); // return TX power
 8020822:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8020826:	edc5 7a00 	vstr	s15, [r5]
    
    return (RADAR_ERR_OK);
 802082a:	bd38      	pop	{r3, r4, r5, pc}
 802082c:	447a0000 	.word	0x447a0000

08020830 <radar_get_chirp_duration>:
}

//============================================================================

uint16_t radar_get_chirp_duration(Radar_Handle_t device, uint32_t* chirp_duration_nsec)
{
 8020830:	b510      	push	{r4, lr}
 8020832:	460c      	mov	r4, r1
  
  /* Calculate chirp timing from current settings */
  /* -------------------------------------------- */
  /* Unit is ns. (factor 10^9 is distributed to denominator and denominator for fixed point precision) */
  
  *chirp_duration_nsec = (ds_device_get_settings()->pll_chirp_time_usec * 1000U);
 8020834:	f7ff fc7e 	bl	8020134 <ds_device_get_settings>
 8020838:	6802      	ldr	r2, [r0, #0]
 802083a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 802083e:	fb03 f302 	mul.w	r3, r3, r2
 8020842:	6023      	str	r3, [r4, #0]
  
  return (RADAR_ERR_OK);
}
 8020844:	2000      	movs	r0, #0
 8020846:	bd10      	pop	{r4, pc}

08020848 <radar_get_min_frame_interval>:

//============================================================================

uint16_t radar_get_min_frame_interval(Radar_Handle_t device, uint32_t* min_frame_interval_usec)
{
 8020848:	b570      	push	{r4, r5, r6, lr}
 802084a:	460d      	mov	r5, r1
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  uint32_t bgt_duty_cycle_delay_usec;
  
  if(ds_device_get_settings()->power_duty_cycle_enable_flag == true)
 802084c:	f7ff fc72 	bl	8020134 <ds_device_get_settings>
 8020850:	f890 2024 	ldrb.w	r2, [r0, #36]	; 0x24
  {
    bgt_duty_cycle_delay_usec = 3000U; /* approximate value calculated from bgt power up sequence 100 + 400 + 100 + update configuration time + PLL_LOCK_TIME_us + BGT_VCO_LOCK_TIME_us */
  }
  else
  {
    bgt_duty_cycle_delay_usec = 1000U; /* approximate delay to accommodate processing time */
 8020854:	f640 33b8 	movw	r3, #3000	; 0xbb8
uint16_t radar_get_min_frame_interval(Radar_Handle_t device, uint32_t* min_frame_interval_usec)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  uint32_t bgt_duty_cycle_delay_usec;
  
  if(ds_device_get_settings()->power_duty_cycle_enable_flag == true)
 8020858:	2a01      	cmp	r2, #1
  {
    bgt_duty_cycle_delay_usec = 3000U; /* approximate value calculated from bgt power up sequence 100 + 400 + 100 + update configuration time + PLL_LOCK_TIME_us + BGT_VCO_LOCK_TIME_us */
  }
  else
  {
    bgt_duty_cycle_delay_usec = 1000U; /* approximate delay to accommodate processing time */
 802085a:	bf0c      	ite	eq
 802085c:	461c      	moveq	r4, r3
 802085e:	f44f 747a 	movne.w	r4, #1000	; 0x3e8
  
  *min_frame_interval_usec = ds_device_get_settings()->pll_num_of_chirps_per_frame * (ds_device_get_settings()->pll_chirp_time_usec + PLL_RAMP_DOWM_TIME_USEC + PLL_STEADY_STATE_USEC) + bgt_duty_cycle_delay_usec +
    ((SAMPLES_PER_CHIRP * 1000U / DOPPLER_SAMPLING_FREQ_HZ) * 1000U) + 2 * ALGO_PROCESS_TIME_USEC; // units in us
  
#elif defined (FMCW_SUPPORTED)
  *min_frame_interval_usec = ds_device_get_settings()->pll_num_of_chirps_per_frame * (ds_device_get_settings()->pll_chirp_time_usec + PLL_RAMP_DOWM_TIME_USEC + PLL_STEADY_STATE_USEC) + bgt_duty_cycle_delay_usec + ALGO_PROCESS_TIME_USEC; // units in us
 8020862:	f7ff fc67 	bl	8020134 <ds_device_get_settings>
 8020866:	6946      	ldr	r6, [r0, #20]
 8020868:	f7ff fc64 	bl	8020134 <ds_device_get_settings>
 802086c:	6802      	ldr	r2, [r0, #0]
 802086e:	32c8      	adds	r2, #200	; 0xc8
 8020870:	fb06 4302 	mla	r3, r6, r2, r4
 8020874:	f503 533b 	add.w	r3, r3, #11968	; 0x2ec0
 8020878:	3320      	adds	r3, #32
 802087a:	602b      	str	r3, [r5, #0]
  }
  
#endif
  
  return (RADAR_ERR_OK);
}
 802087c:	2000      	movs	r0, #0
 802087e:	bd70      	pop	{r4, r5, r6, pc}

08020880 <radar_set_frame_format>:

//============================================================================

uint16_t radar_set_frame_format(Radar_Handle_t device, const Frame_Format_t* frame_format)
{
 8020880:	b570      	push	{r4, r5, r6, lr}
 8020882:	4605      	mov	r5, r0
 8020884:	460c      	mov	r4, r1
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  /* Configuration change is only allowed while automatic trigger is not working */
  if (radar_get_data_acq_mode() != RADAR_MANUAL_TRIGGER)
 8020886:	f000 fd0f 	bl	80212a8 <radar_get_data_acq_mode>
 802088a:	b108      	cbz	r0, 8020890 <radar_set_frame_format+0x10>
  {
    return (RADAR_ERR_BUSY);
 802088c:	2002      	movs	r0, #2
 802088e:	bd70      	pop	{r4, r5, r6, pc}
  
  /* Check if configuration is valid */
  /* ------------------------------- */
  
  /* This sensor can only acquire real signal data */
  if (frame_format->signal_part != RADAR_SIGNAL_I_AND_Q)
 8020890:	7a63      	ldrb	r3, [r4, #9]
 8020892:	2b02      	cmp	r3, #2
 8020894:	d001      	beq.n	802089a <radar_set_frame_format+0x1a>
  {
    return (RADAR_ERR_UNAVAILABLE_SIGNAL_PART);
 8020896:	200b      	movs	r0, #11
 8020898:	bd70      	pop	{r4, r5, r6, pc}
  }
  /* This sensor support RX1, RX2 and both at the same time antennas enabled */
  if (frame_format->rx_mask > BSP_RX_ANTENNA_MASK )
 802089a:	7a23      	ldrb	r3, [r4, #8]
 802089c:	2b03      	cmp	r3, #3
 802089e:	d901      	bls.n	80208a4 <radar_set_frame_format+0x24>
  {
    return (RADAR_ERR_ANTENNA_DOES_NOT_EXIST);
 80208a0:	2006      	movs	r0, #6
 80208a2:	bd70      	pop	{r4, r5, r6, pc}
  }
  /* LMX2491 supports only a limited number of ramps before auto turn off. */
  if ((frame_format->num_chirps_per_frame == 0) || (frame_format->num_chirps_per_frame > BSP_MAX_NUM_CHIRPS_PER_FRAME))
 80208a4:	6863      	ldr	r3, [r4, #4]
 80208a6:	1e5a      	subs	r2, r3, #1
 80208a8:	2a3f      	cmp	r2, #63	; 0x3f
 80208aa:	d901      	bls.n	80208b0 <radar_set_frame_format+0x30>
  {
    return (RADAR_ERR_UNSUPPORTED_FRAME_FORMAT);
 80208ac:	2008      	movs	r0, #8
 80208ae:	bd70      	pop	{r4, r5, r6, pc}
  }
  
  /* BGT can store only a limited number of samples per chirp */
  if ((frame_format->num_samples_per_chirp == 0) || (frame_format->num_samples_per_chirp > BSP_MAX_NUM_SAMPLES_PER_CHIRP))
 80208b0:	6826      	ldr	r6, [r4, #0]
 80208b2:	1e72      	subs	r2, r6, #1
 80208b4:	2aff      	cmp	r2, #255	; 0xff
 80208b6:	d8f9      	bhi.n	80208ac <radar_set_frame_format+0x2c>
  {
    return (RADAR_ERR_UNSUPPORTED_FRAME_FORMAT);
  }
  
  /* For Doppler modulation mode the number of chirp must be 1 */
  if ((frame_format->num_chirps_per_frame != 1) && (ds_device_get_settings()->pll_modulation_mode == MODULATION_DOPPLER))
 80208b8:	2b01      	cmp	r3, #1
 80208ba:	d005      	beq.n	80208c8 <radar_set_frame_format+0x48>
 80208bc:	f7ff fc3a 	bl	8020134 <ds_device_get_settings>
 80208c0:	6983      	ldr	r3, [r0, #24]
 80208c2:	2b00      	cmp	r3, #0
 80208c4:	d0f2      	beq.n	80208ac <radar_set_frame_format+0x2c>
 80208c6:	6826      	ldr	r6, [r4, #0]
  {
    return (RADAR_ERR_UNSUPPORTED_FRAME_FORMAT);
  }
  
  /* Check if samples per chirp are in [32,64,128,256] range */
  if ((frame_format->num_samples_per_chirp != 256U) &&
 80208c8:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
 80208cc:	d007      	beq.n	80208de <radar_set_frame_format+0x5e>
 80208ce:	2e80      	cmp	r6, #128	; 0x80
 80208d0:	d005      	beq.n	80208de <radar_set_frame_format+0x5e>
      (frame_format->num_samples_per_chirp != 128U) &&
 80208d2:	2e40      	cmp	r6, #64	; 0x40
 80208d4:	d003      	beq.n	80208de <radar_set_frame_format+0x5e>
        (frame_format->num_samples_per_chirp != 64U)  &&
 80208d6:	2e20      	cmp	r6, #32
 80208d8:	d001      	beq.n	80208de <radar_set_frame_format+0x5e>
          (frame_format->num_samples_per_chirp != 32U))
  {
    return (RADAR_ERR_SAMPLERATE_OUT_OF_RANGE);
 80208da:	2050      	movs	r0, #80	; 0x50
  ds_ep_store_frame_format(frame_format);
  
  g_adc_sampling_completed = false;
  
  return (RADAR_ERR_OK);
}
 80208dc:	bd70      	pop	{r4, r5, r6, pc}
          (frame_format->num_samples_per_chirp != 32U))
  {
    return (RADAR_ERR_SAMPLERATE_OUT_OF_RANGE);
  }
  
  uint32_t temp_samplerate_Hz = (uint32_t) (((float)frame_format->num_samples_per_chirp * 1000000.0f ) / ds_device_get_settings()->pll_chirp_time_usec );
 80208de:	f7ff fc29 	bl	8020134 <ds_device_get_settings>
 80208e2:	ee07 6a90 	vmov	s15, r6
 80208e6:	ed9f 6a16 	vldr	s12, [pc, #88]	; 8020940 <radar_set_frame_format+0xc0>
 80208ea:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 80208ee:	edd0 7a00 	vldr	s15, [r0]
 80208f2:	eef8 6a67 	vcvt.f32.u32	s13, s15
 80208f6:	ee67 7a06 	vmul.f32	s15, s14, s12
  radar_set_sampling_freq(device, MODULATION_FMCW, temp_samplerate_Hz);
 80208fa:	2101      	movs	r1, #1
          (frame_format->num_samples_per_chirp != 32U))
  {
    return (RADAR_ERR_SAMPLERATE_OUT_OF_RANGE);
  }
  
  uint32_t temp_samplerate_Hz = (uint32_t) (((float)frame_format->num_samples_per_chirp * 1000000.0f ) / ds_device_get_settings()->pll_chirp_time_usec );
 80208fc:	eec7 7aa6 	vdiv.f32	s15, s15, s13
  radar_set_sampling_freq(device, MODULATION_FMCW, temp_samplerate_Hz);
 8020900:	4628      	mov	r0, r5
          (frame_format->num_samples_per_chirp != 32U))
  {
    return (RADAR_ERR_SAMPLERATE_OUT_OF_RANGE);
  }
  
  uint32_t temp_samplerate_Hz = (uint32_t) (((float)frame_format->num_samples_per_chirp * 1000000.0f ) / ds_device_get_settings()->pll_chirp_time_usec );
 8020902:	eefc 7ae7 	vcvt.u32.f32	s15, s15
  radar_set_sampling_freq(device, MODULATION_FMCW, temp_samplerate_Hz);
 8020906:	eef8 7a67 	vcvt.f32.u32	s15, s15
 802090a:	ee17 2a90 	vmov	r2, s15
 802090e:	f000 fc49 	bl	80211a4 <radar_set_sampling_freq>

  /* Check frame memory limits */
  /* ------------------------- */
  frame_size = frame_format->num_chirps_per_frame * frame_format->num_samples_per_chirp * 2U *
 8020912:	e894 0028 	ldmia.w	r4, {r3, r5}
 8020916:	fb03 f505 	mul.w	r5, r3, r5
    ds_ep_get_device_info()->num_rx_antennas * sizeof(uint16_t); // complex IQ samples per antenna
 802091a:	f7ff fd19 	bl	8020350 <ds_ep_get_device_info>
  uint32_t temp_samplerate_Hz = (uint32_t) (((float)frame_format->num_samples_per_chirp * 1000000.0f ) / ds_device_get_settings()->pll_chirp_time_usec );
  radar_set_sampling_freq(device, MODULATION_FMCW, temp_samplerate_Hz);

  /* Check frame memory limits */
  /* ------------------------- */
  frame_size = frame_format->num_chirps_per_frame * frame_format->num_samples_per_chirp * 2U *
 802091e:	7b42      	ldrb	r2, [r0, #13]
 8020920:	4908      	ldr	r1, [pc, #32]	; (8020944 <radar_set_frame_format+0xc4>)
 8020922:	00ab      	lsls	r3, r5, #2
    ds_ep_get_device_info()->num_rx_antennas * sizeof(uint16_t); // complex IQ samples per antenna
 8020924:	fb02 f303 	mul.w	r3, r2, r3
  
  if (frame_size > BSP_MAX_ADC_BUFFER_SIZE_BYTES)
 8020928:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
  uint32_t temp_samplerate_Hz = (uint32_t) (((float)frame_format->num_samples_per_chirp * 1000000.0f ) / ds_device_get_settings()->pll_chirp_time_usec );
  radar_set_sampling_freq(device, MODULATION_FMCW, temp_samplerate_Hz);

  /* Check frame memory limits */
  /* ------------------------- */
  frame_size = frame_format->num_chirps_per_frame * frame_format->num_samples_per_chirp * 2U *
 802092c:	600b      	str	r3, [r1, #0]
    ds_ep_get_device_info()->num_rx_antennas * sizeof(uint16_t); // complex IQ samples per antenna
  
  if (frame_size > BSP_MAX_ADC_BUFFER_SIZE_BYTES)
 802092e:	d8bd      	bhi.n	80208ac <radar_set_frame_format+0x2c>
  {
    return (RADAR_ERR_UNSUPPORTED_FRAME_FORMAT);
  }
  
  /* Store new frame format in store */
  ds_ep_store_frame_format(frame_format);
 8020930:	4620      	mov	r0, r4
 8020932:	f7ff fd1f 	bl	8020374 <ds_ep_store_frame_format>
  
  g_adc_sampling_completed = false;
 8020936:	4b04      	ldr	r3, [pc, #16]	; (8020948 <radar_set_frame_format+0xc8>)
 8020938:	2000      	movs	r0, #0
 802093a:	6018      	str	r0, [r3, #0]
  
  return (RADAR_ERR_OK);
 802093c:	bd70      	pop	{r4, r5, r6, pc}
 802093e:	bf00      	nop
 8020940:	49742400 	.word	0x49742400
 8020944:	1ffe97b8 	.word	0x1ffe97b8
 8020948:	1ffe97c4 	.word	0x1ffe97c4

0802094c <radar_get_frame_format>:
}

//============================================================================

uint16_t radar_get_frame_format(Radar_Handle_t device, Frame_Format_t* p_frame_format)
{
 802094c:	b508      	push	{r3, lr}
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  /* Return current frame format of driver object */
  ds_ep_fetch_frame_format(p_frame_format);
 802094e:	4608      	mov	r0, r1
 8020950:	f7ff fd02 	bl	8020358 <ds_ep_fetch_frame_format>
  
  return (RADAR_ERR_OK);
}
 8020954:	2000      	movs	r0, #0
 8020956:	bd08      	pop	{r3, pc}

08020958 <radar_get_frame>:

//============================================================================

uint16_t radar_get_frame(Radar_Handle_t device, Frame_Info_t* frame_info, uint8_t wait_for_data)
{
 8020958:	b570      	push	{r4, r5, r6, lr}
 802095a:	b084      	sub	sp, #16
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  Frame_Format_t frame_format;
  
  ds_ep_fetch_frame_format(&frame_format);
 802095c:	a801      	add	r0, sp, #4
}

//============================================================================

uint16_t radar_get_frame(Radar_Handle_t device, Frame_Info_t* frame_info, uint8_t wait_for_data)
{
 802095e:	460d      	mov	r5, r1
 8020960:	4614      	mov	r4, r2
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  Frame_Format_t frame_format;
  
  ds_ep_fetch_frame_format(&frame_format);
 8020962:	f7ff fcf9 	bl	8020358 <ds_ep_fetch_frame_format>
  
  acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 8020966:	f7ff fc4f 	bl	8020208 <ds_get_active_acq_buf>
 802096a:	4606      	mov	r6, r0
  
  if (radar_get_data_acq_mode() != RADAR_AUTO_TRIGGER)	// without automaticFrameTrigger
 802096c:	f000 fc9c 	bl	80212a8 <radar_get_data_acq_mode>
 8020970:	2801      	cmp	r0, #1
 8020972:	d02f      	beq.n	80209d4 <radar_get_frame+0x7c>
  {
    bsp_trigger_new_frame();
 8020974:	f009 f9f8 	bl	8029d68 <bsp_trigger_new_frame>
 8020978:	4a1b      	ldr	r2, [pc, #108]	; (80209e8 <radar_get_frame+0x90>)
    {
      return (RADAR_ERR_TIMEOUT);
    }
  }
  
  while (g_adc_sampling_completed == false); // block GetFrame if data is not ready
 802097a:	6813      	ldr	r3, [r2, #0]
 802097c:	4c1a      	ldr	r4, [pc, #104]	; (80209e8 <radar_get_frame+0x90>)
 802097e:	2b00      	cmp	r3, #0
 8020980:	d0fb      	beq.n	802097a <radar_get_frame+0x22>
  
  /* Data acquired */
  /* ------------- */
  //memcpy(transport_buffer, p_acq_buf->p_acq_buf, frame_size);	// copy ADC buffer to be send to avoid data corruption by Automatic trigger
  
  frame_info->sample_data           = p_acq_buf->p_acq_buf;
 8020982:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 8020984:	602b      	str	r3, [r5, #0]
  frame_info->num_rx_antennas       = ds_ep_get_device_info()->num_rx_antennas;
 8020986:	f7ff fce3 	bl	8020350 <ds_ep_get_device_info>
  frame_info->num_chirps            = frame_format.num_chirps_per_frame;
 802098a:	9a02      	ldr	r2, [sp, #8]
  /* Data acquired */
  /* ------------- */
  //memcpy(transport_buffer, p_acq_buf->p_acq_buf, frame_size);	// copy ADC buffer to be send to avoid data corruption by Automatic trigger
  
  frame_info->sample_data           = p_acq_buf->p_acq_buf;
  frame_info->num_rx_antennas       = ds_ep_get_device_info()->num_rx_antennas;
 802098c:	7b41      	ldrb	r1, [r0, #13]
  frame_info->num_chirps            = frame_format.num_chirps_per_frame;
  frame_info->rx_mask               = frame_format.rx_mask;
 802098e:	f89d 300c 	ldrb.w	r3, [sp, #12]
  /* Data acquired */
  /* ------------- */
  //memcpy(transport_buffer, p_acq_buf->p_acq_buf, frame_size);	// copy ADC buffer to be send to avoid data corruption by Automatic trigger
  
  frame_info->sample_data           = p_acq_buf->p_acq_buf;
  frame_info->num_rx_antennas       = ds_ep_get_device_info()->num_rx_antennas;
 8020992:	7329      	strb	r1, [r5, #12]
  frame_info->num_chirps            = frame_format.num_chirps_per_frame;
 8020994:	60aa      	str	r2, [r5, #8]
  frame_info->rx_mask               = frame_format.rx_mask;
 8020996:	762b      	strb	r3, [r5, #24]
  frame_info->adc_resolution        = ds_device_get_settings()->adc_resolution;
 8020998:	f7ff fbcc 	bl	8020134 <ds_device_get_settings>
  frame_info->interleaved_rx        = 0;
 802099c:	2600      	movs	r6, #0
  
  frame_info->sample_data           = p_acq_buf->p_acq_buf;
  frame_info->num_rx_antennas       = ds_ep_get_device_info()->num_rx_antennas;
  frame_info->num_chirps            = frame_format.num_chirps_per_frame;
  frame_info->rx_mask               = frame_format.rx_mask;
  frame_info->adc_resolution        = ds_device_get_settings()->adc_resolution;
 802099e:	f890 3020 	ldrb.w	r3, [r0, #32]
 80209a2:	766b      	strb	r3, [r5, #25]
  frame_info->interleaved_rx        = 0;
 80209a4:	76ae      	strb	r6, [r5, #26]
  frame_info->frame_number          = bsp_get_frame_counter();
 80209a6:	f009 fc1b 	bl	802a1e0 <bsp_get_frame_counter>
  frame_info->data_format           = RADAR_RX_DATA_COMPLEX;
 80209aa:	2301      	movs	r3, #1
 80209ac:	76eb      	strb	r3, [r5, #27]
  frame_info->num_rx_antennas       = ds_ep_get_device_info()->num_rx_antennas;
  frame_info->num_chirps            = frame_format.num_chirps_per_frame;
  frame_info->rx_mask               = frame_format.rx_mask;
  frame_info->adc_resolution        = ds_device_get_settings()->adc_resolution;
  frame_info->interleaved_rx        = 0;
  frame_info->frame_number          = bsp_get_frame_counter();
 80209ae:	6068      	str	r0, [r5, #4]
  frame_info->data_format           = RADAR_RX_DATA_COMPLEX;
  frame_info->temperature_001C      = (int32_t) (bsp_bgt_get_temp_value() * 1000);	// (expected value is actual temperature in C x 1000)
 80209b0:	f009 fc02 	bl	802a1b8 <bsp_bgt_get_temp_value>
 80209b4:	eddf 7a0d 	vldr	s15, [pc, #52]	; 80209ec <radar_get_frame+0x94>
  frame_info->num_samples_per_chirp = frame_format.num_samples_per_chirp;
 80209b8:	9b01      	ldr	r3, [sp, #4]

  g_adc_sampling_completed          = false;
 80209ba:	6026      	str	r6, [r4, #0]
  frame_info->rx_mask               = frame_format.rx_mask;
  frame_info->adc_resolution        = ds_device_get_settings()->adc_resolution;
  frame_info->interleaved_rx        = 0;
  frame_info->frame_number          = bsp_get_frame_counter();
  frame_info->data_format           = RADAR_RX_DATA_COMPLEX;
  frame_info->temperature_001C      = (int32_t) (bsp_bgt_get_temp_value() * 1000);	// (expected value is actual temperature in C x 1000)
 80209bc:	ee07 0a10 	vmov	s14, r0
 80209c0:	ee67 7a27 	vmul.f32	s15, s14, s15
  frame_info->num_samples_per_chirp = frame_format.num_samples_per_chirp;

  g_adc_sampling_completed          = false;
  
  return (RADAR_ERR_OK);
 80209c4:	4630      	mov	r0, r6
  frame_info->rx_mask               = frame_format.rx_mask;
  frame_info->adc_resolution        = ds_device_get_settings()->adc_resolution;
  frame_info->interleaved_rx        = 0;
  frame_info->frame_number          = bsp_get_frame_counter();
  frame_info->data_format           = RADAR_RX_DATA_COMPLEX;
  frame_info->temperature_001C      = (int32_t) (bsp_bgt_get_temp_value() * 1000);	// (expected value is actual temperature in C x 1000)
 80209c6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
  frame_info->num_samples_per_chirp = frame_format.num_samples_per_chirp;
 80209ca:	612b      	str	r3, [r5, #16]
  frame_info->rx_mask               = frame_format.rx_mask;
  frame_info->adc_resolution        = ds_device_get_settings()->adc_resolution;
  frame_info->interleaved_rx        = 0;
  frame_info->frame_number          = bsp_get_frame_counter();
  frame_info->data_format           = RADAR_RX_DATA_COMPLEX;
  frame_info->temperature_001C      = (int32_t) (bsp_bgt_get_temp_value() * 1000);	// (expected value is actual temperature in C x 1000)
 80209cc:	edc5 7a05 	vstr	s15, [r5, #20]
  frame_info->num_samples_per_chirp = frame_format.num_samples_per_chirp;

  g_adc_sampling_completed          = false;
  
  return (RADAR_ERR_OK);
}
 80209d0:	b004      	add	sp, #16
 80209d2:	bd70      	pop	{r4, r5, r6, pc}
  {
    bsp_trigger_new_frame();
  }
  else // with automaticFrameTrigger
  {
    if ((!wait_for_data) && (!g_adc_sampling_completed))
 80209d4:	4a04      	ldr	r2, [pc, #16]	; (80209e8 <radar_get_frame+0x90>)
 80209d6:	2c00      	cmp	r4, #0
 80209d8:	d1cf      	bne.n	802097a <radar_get_frame+0x22>
 80209da:	6813      	ldr	r3, [r2, #0]
 80209dc:	2b00      	cmp	r3, #0
 80209de:	d1cc      	bne.n	802097a <radar_get_frame+0x22>
    {
      return (RADAR_ERR_TIMEOUT);
 80209e0:	2004      	movs	r0, #4
  frame_info->num_samples_per_chirp = frame_format.num_samples_per_chirp;

  g_adc_sampling_completed          = false;
  
  return (RADAR_ERR_OK);
}
 80209e2:	b004      	add	sp, #16
 80209e4:	bd70      	pop	{r4, r5, r6, pc}
 80209e6:	bf00      	nop
 80209e8:	1ffe97c4 	.word	0x1ffe97c4
 80209ec:	447a0000 	.word	0x447a0000

080209f0 <radar_set_automatic_frame_trigger>:

//============================================================================

uint16_t radar_set_automatic_frame_trigger(Radar_Handle_t device, uint32_t frame_interval_usec)
{
 80209f0:	b570      	push	{r4, r5, r6, lr}
  /* Stop trigger timer first  */
  /* ------------------------- */
  bsp_timer_stop_clear(&TIMER_FRAME_TRIG);
 80209f2:	481e      	ldr	r0, [pc, #120]	; (8020a6c <radar_set_automatic_frame_trigger+0x7c>)
}

//============================================================================

uint16_t radar_set_automatic_frame_trigger(Radar_Handle_t device, uint32_t frame_interval_usec)
{
 80209f4:	460c      	mov	r4, r1
  /* Stop trigger timer first  */
  /* ------------------------- */
  bsp_timer_stop_clear(&TIMER_FRAME_TRIG);
 80209f6:	f009 f94d 	bl	8029c94 <bsp_timer_stop_clear>
  
  radar_set_data_acq_mode(RADAR_MANUAL_TRIGGER);
 80209fa:	2000      	movs	r0, #0
 80209fc:	f000 fc5a 	bl	80212b4 <radar_set_data_acq_mode>
  
  /* Restart trigger timer */
  /* --------------------- */
  if (frame_interval_usec > 0)
 8020a00:	b90c      	cbnz	r4, 8020a06 <radar_set_automatic_frame_trigger+0x16>
    radar_set_data_acq_mode(RADAR_AUTO_TRIGGER);
    
    bsp_timer_start(&TIMER_FRAME_TRIG);
  }
  
  return (RADAR_ERR_OK);
 8020a02:	4620      	mov	r0, r4
}
 8020a04:	bd70      	pop	{r4, r5, r6, pc}
uint16_t radar_get_min_frame_interval(Radar_Handle_t device, uint32_t* min_frame_interval_usec)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  uint32_t bgt_duty_cycle_delay_usec;
  
  if(ds_device_get_settings()->power_duty_cycle_enable_flag == true)
 8020a06:	f7ff fb95 	bl	8020134 <ds_device_get_settings>
 8020a0a:	f890 2024 	ldrb.w	r2, [r0, #36]	; 0x24
  {
    bgt_duty_cycle_delay_usec = 3000U; /* approximate value calculated from bgt power up sequence 100 + 400 + 100 + update configuration time + PLL_LOCK_TIME_us + BGT_VCO_LOCK_TIME_us */
  }
  else
  {
    bgt_duty_cycle_delay_usec = 1000U; /* approximate delay to accommodate processing time */
 8020a0e:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8020a12:	2a01      	cmp	r2, #1
 8020a14:	bf0c      	ite	eq
 8020a16:	461d      	moveq	r5, r3
 8020a18:	f44f 757a 	movne.w	r5, #1000	; 0x3e8
  
  *min_frame_interval_usec = ds_device_get_settings()->pll_num_of_chirps_per_frame * (ds_device_get_settings()->pll_chirp_time_usec + PLL_RAMP_DOWM_TIME_USEC + PLL_STEADY_STATE_USEC) + bgt_duty_cycle_delay_usec +
    ((SAMPLES_PER_CHIRP * 1000U / DOPPLER_SAMPLING_FREQ_HZ) * 1000U) + 2 * ALGO_PROCESS_TIME_USEC; // units in us
  
#elif defined (FMCW_SUPPORTED)
  *min_frame_interval_usec = ds_device_get_settings()->pll_num_of_chirps_per_frame * (ds_device_get_settings()->pll_chirp_time_usec + PLL_RAMP_DOWM_TIME_USEC + PLL_STEADY_STATE_USEC) + bgt_duty_cycle_delay_usec + ALGO_PROCESS_TIME_USEC; // units in us
 8020a1c:	f7ff fb8a 	bl	8020134 <ds_device_get_settings>
 8020a20:	6946      	ldr	r6, [r0, #20]
 8020a22:	f7ff fb87 	bl	8020134 <ds_device_get_settings>
 8020a26:	6802      	ldr	r2, [r0, #0]
 8020a28:	32c8      	adds	r2, #200	; 0xc8
 8020a2a:	fb06 5302 	mla	r3, r6, r2, r5
 8020a2e:	f503 533b 	add.w	r3, r3, #11968	; 0x2ec0
 8020a32:	3320      	adds	r3, #32
  {
    uint32_t min_frame_interval_usec;
    
    radar_get_min_frame_interval(device, &min_frame_interval_usec);
    
    if (frame_interval_usec < min_frame_interval_usec)
 8020a34:	429c      	cmp	r4, r3
 8020a36:	d201      	bcs.n	8020a3c <radar_set_automatic_frame_trigger+0x4c>
  {
    bgt_duty_cycle_delay_usec = 3000U; /* approximate value calculated from bgt power up sequence 100 + 400 + 100 + update configuration time + PLL_LOCK_TIME_us + BGT_VCO_LOCK_TIME_us */
  }
  else
  {
    bgt_duty_cycle_delay_usec = 1000U; /* approximate delay to accommodate processing time */
 8020a38:	2005      	movs	r0, #5
 8020a3a:	bd70      	pop	{r4, r5, r6, pc}
    {
      return (RADAR_ERR_UNSUPPORTED_FRAME_INTERVAL);
    }
    
    /* Update time period of Automatic Trigger */
    if (TIMER_SetTimeInterval(&TIMER_FRAME_TRIG, frame_interval_usec * 100U) != TIMER_STATUS_SUCCESS)
 8020a3c:	2164      	movs	r1, #100	; 0x64
 8020a3e:	fb01 f104 	mul.w	r1, r1, r4
 8020a42:	480a      	ldr	r0, [pc, #40]	; (8020a6c <radar_set_automatic_frame_trigger+0x7c>)
 8020a44:	f006 f868 	bl	8026b18 <TIMER_SetTimeInterval>
 8020a48:	4605      	mov	r5, r0
 8020a4a:	2800      	cmp	r0, #0
 8020a4c:	d1f4      	bne.n	8020a38 <radar_set_automatic_frame_trigger+0x48>
    {
      return (RADAR_ERR_UNSUPPORTED_FRAME_INTERVAL);
    }
    
    ds_device_get_settings()->frame_period_usec = frame_interval_usec;
 8020a4e:	f7ff fb71 	bl	8020134 <ds_device_get_settings>
 8020a52:	6284      	str	r4, [r0, #40]	; 0x28
    
    /* Reset the current frame counter */
    bsp_reset_frame_counter();
 8020a54:	f009 fbca 	bl	802a1ec <bsp_reset_frame_counter>
    
    g_adc_sampling_completed = false;
 8020a58:	4b05      	ldr	r3, [pc, #20]	; (8020a70 <radar_set_automatic_frame_trigger+0x80>)
    
    radar_set_data_acq_mode(RADAR_AUTO_TRIGGER);
 8020a5a:	2001      	movs	r0, #1
    ds_device_get_settings()->frame_period_usec = frame_interval_usec;
    
    /* Reset the current frame counter */
    bsp_reset_frame_counter();
    
    g_adc_sampling_completed = false;
 8020a5c:	601d      	str	r5, [r3, #0]
    
    radar_set_data_acq_mode(RADAR_AUTO_TRIGGER);
 8020a5e:	f000 fc29 	bl	80212b4 <radar_set_data_acq_mode>
    
    bsp_timer_start(&TIMER_FRAME_TRIG);
 8020a62:	4802      	ldr	r0, [pc, #8]	; (8020a6c <radar_set_automatic_frame_trigger+0x7c>)
 8020a64:	f009 f922 	bl	8029cac <bsp_timer_start>
  }
  
  return (RADAR_ERR_OK);
 8020a68:	4628      	mov	r0, r5
 8020a6a:	bd70      	pop	{r4, r5, r6, pc}
 8020a6c:	1ffe8978 	.word	0x1ffe8978
 8020a70:	1ffe97c4 	.word	0x1ffe97c4

08020a74 <radar_test_antennas>:
  XMC_UNUSED_ARG(rx_antenna_mask);
  XMC_UNUSED_ARG(frequency_kHz);
  XMC_UNUSED_ARG(tx_power);
  
  return (RADAR_ERR_FEATURE_UNAVAILABLE);
}
 8020a74:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8020a78:	4770      	bx	lr
 8020a7a:	bf00      	nop

08020a7c <radar_get_fft_configuration>:

void radar_get_fft_configuration(Radar_Handle_t device, FFT_configuration_t *p_fft_config)
{
	XMC_UNUSED_ARG(device);

	ds_ep_fetch_fft_config(p_fft_config);
 8020a7c:	4608      	mov	r0, r1
 8020a7e:	f7ff bcdb 	b.w	8020438 <ds_ep_fetch_fft_config>
 8020a82:	bf00      	nop

08020a84 <radar_init_calibration>:

void radar_init_calibration(Radar_Handle_t device)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */

  memset(adc_i1_calibration, DEFAULT_CALIBRATION_VALUE, ADC_CALIB_LEN_BYTES);
 8020a84:	4802      	ldr	r0, [pc, #8]	; (8020a90 <radar_init_calibration+0xc>)
 8020a86:	2100      	movs	r1, #0
 8020a88:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8020a8c:	f00e b897 	b.w	802ebbe <memset>
 8020a90:	2000cb28 	.word	0x2000cb28

08020a94 <radar_save_calibration>:
}

//============================================================================

uint16_t radar_save_calibration(Radar_Handle_t device, Calibration_Target_t target, Calibration_Data_t calib_data_type, const void* calibration_data_ptr)
{
 8020a94:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8020a98:	b08d      	sub	sp, #52	; 0x34
 8020a9a:	9103      	str	r1, [sp, #12]
  if (calib_data_type == CALIBRATION_DATA_ADC)
 8020a9c:	2a00      	cmp	r2, #0
 8020a9e:	f040 8083 	bne.w	8020ba8 <radar_save_calibration+0x114>
  {
    uint16_t status  = 1;
    Frame_Info_t frame_info;
    
    g_do_processing = false;
 8020aa2:	4b5a      	ldr	r3, [pc, #360]	; (8020c0c <radar_save_calibration+0x178>)
 8020aa4:	4604      	mov	r4, r0
 8020aa6:	601a      	str	r2, [r3, #0]
    
    while(status)
    {
      status = radar_get_frame(device, &frame_info, true);
 8020aa8:	4620      	mov	r0, r4
 8020aaa:	a905      	add	r1, sp, #20
 8020aac:	2201      	movs	r2, #1
 8020aae:	f7ff ff53 	bl	8020958 <radar_get_frame>
    uint16_t status  = 1;
    Frame_Info_t frame_info;
    
    g_do_processing = false;
    
    while(status)
 8020ab2:	2800      	cmp	r0, #0
 8020ab4:	d1f8      	bne.n	8020aa8 <radar_save_calibration+0x14>
 8020ab6:	4607      	mov	r7, r0
 */

static void save_adc_calibration(Calibration_Target_t target)
{
  uint32_t cal_idx = 0;
  uint32_t interp_factor = MAX_CALIB_SAMPLES_PER_CHANNEL / ds_device_get_settings()->num_samples_per_chirp;	// interpolation factor
 8020ab8:	f7ff fb3c 	bl	8020134 <ds_device_get_settings>
 8020abc:	f44f 7280 	mov.w	r2, #256	; 0x100
 8020ac0:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8020ac2:	fbb2 f3f3 	udiv	r3, r2, r3
 8020ac6:	9300      	str	r3, [sp, #0]

  acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 8020ac8:	f7ff fb9e 	bl	8020208 <ds_get_active_acq_buf>
  
  uint16_t *adc_temp[4];
  adc_temp[0] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 0, 0);
 8020acc:	4639      	mov	r1, r7
 8020ace:	463a      	mov	r2, r7
static void save_adc_calibration(Calibration_Target_t target)
{
  uint32_t cal_idx = 0;
  uint32_t interp_factor = MAX_CALIB_SAMPLES_PER_CHANNEL / ds_device_get_settings()->num_samples_per_chirp;	// interpolation factor

  acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 8020ad0:	4680      	mov	r8, r0
  
  uint16_t *adc_temp[4];
  adc_temp[0] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 0, 0);
 8020ad2:	f7ff fd0f 	bl	80204f4 <get_buffer_address_by_chirp>
  adc_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 1, 0);
 8020ad6:	463a      	mov	r2, r7
  uint32_t interp_factor = MAX_CALIB_SAMPLES_PER_CHANNEL / ds_device_get_settings()->num_samples_per_chirp;	// interpolation factor

  acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
  
  uint16_t *adc_temp[4];
  adc_temp[0] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 0, 0);
 8020ad8:	4606      	mov	r6, r0
  adc_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 1, 0);
 8020ada:	2101      	movs	r1, #1
 8020adc:	4640      	mov	r0, r8
 8020ade:	f7ff fd09 	bl	80204f4 <get_buffer_address_by_chirp>
  adc_temp[2] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 2, 0);
 8020ae2:	463a      	mov	r2, r7

  acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
  
  uint16_t *adc_temp[4];
  adc_temp[0] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 0, 0);
  adc_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 1, 0);
 8020ae4:	4605      	mov	r5, r0
  adc_temp[2] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 2, 0);
 8020ae6:	2102      	movs	r1, #2
 8020ae8:	4640      	mov	r0, r8
 8020aea:	f7ff fd03 	bl	80204f4 <get_buffer_address_by_chirp>
  adc_temp[3] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, 0);
 8020aee:	463a      	mov	r2, r7
  acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
  
  uint16_t *adc_temp[4];
  adc_temp[0] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 0, 0);
  adc_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 1, 0);
  adc_temp[2] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 2, 0);
 8020af0:	4604      	mov	r4, r0
  adc_temp[3] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, 0);
 8020af2:	2103      	movs	r1, #3
 8020af4:	4640      	mov	r0, r8
 8020af6:	f7ff fcfd 	bl	80204f4 <get_buffer_address_by_chirp>
 8020afa:	9b00      	ldr	r3, [sp, #0]
 8020afc:	4944      	ldr	r1, [pc, #272]	; (8020c10 <radar_save_calibration+0x17c>)

  /* Fill the calibration buffer with raw ADC data */
  for (uint32_t i = 0; i < ds_device_get_settings()->num_samples_per_chirp; i++)
  {
    adc_i1_calibration[cal_idx] = (adc_temp[0])[i];
    adc_q1_calibration[cal_idx] = (adc_temp[1])[i];
 8020afe:	f8df b11c 	ldr.w	fp, [pc, #284]	; 8020c1c <radar_save_calibration+0x188>
    adc_i2_calibration[cal_idx] = (adc_temp[2])[i];
 8020b02:	f8df a11c 	ldr.w	sl, [pc, #284]	; 8020c20 <radar_save_calibration+0x18c>
 8020b06:	ea4f 0843 	mov.w	r8, r3, lsl #1
 8020b0a:	f1c8 0200 	rsb	r2, r8, #0
  
  uint16_t *adc_temp[4];
  adc_temp[0] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 0, 0);
  adc_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 1, 0);
  adc_temp[2] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 2, 0);
  adc_temp[3] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, 0);
 8020b0e:	46b9      	mov	r9, r7
 8020b10:	188b      	adds	r3, r1, r2
 8020b12:	f8cd 8000 	str.w	r8, [sp]
 8020b16:	9201      	str	r2, [sp, #4]
 8020b18:	3e02      	subs	r6, #2
 8020b1a:	3d02      	subs	r5, #2
 8020b1c:	3c02      	subs	r4, #2
 8020b1e:	1e87      	subs	r7, r0, #2
 8020b20:	9302      	str	r3, [sp, #8]

  /* Fill the calibration buffer with raw ADC data */
  for (uint32_t i = 0; i < ds_device_get_settings()->num_samples_per_chirp; i++)
 8020b22:	46c8      	mov	r8, r9
 8020b24:	e018      	b.n	8020b58 <radar_save_calibration+0xc4>
  {
    adc_i1_calibration[cal_idx] = (adc_temp[0])[i];
 8020b26:	9b02      	ldr	r3, [sp, #8]
 8020b28:	f836 0f02 	ldrh.w	r0, [r6, #2]!
 8020b2c:	f823 0009 	strh.w	r0, [r3, r9]
    adc_q1_calibration[cal_idx] = (adc_temp[1])[i];
 8020b30:	f8db 0000 	ldr.w	r0, [fp]
 8020b34:	f835 ef02 	ldrh.w	lr, [r5, #2]!
 8020b38:	f820 e002 	strh.w	lr, [r0, r2]
    adc_i2_calibration[cal_idx] = (adc_temp[2])[i];
 8020b3c:	f8da 0000 	ldr.w	r0, [sl]
 8020b40:	f834 ef02 	ldrh.w	lr, [r4, #2]!
    adc_q2_calibration[cal_idx] = (adc_temp[3])[i];
 8020b44:	4b33      	ldr	r3, [pc, #204]	; (8020c14 <radar_save_calibration+0x180>)
  /* Fill the calibration buffer with raw ADC data */
  for (uint32_t i = 0; i < ds_device_get_settings()->num_samples_per_chirp; i++)
  {
    adc_i1_calibration[cal_idx] = (adc_temp[0])[i];
    adc_q1_calibration[cal_idx] = (adc_temp[1])[i];
    adc_i2_calibration[cal_idx] = (adc_temp[2])[i];
 8020b46:	f820 e002 	strh.w	lr, [r0, r2]
    adc_q2_calibration[cal_idx] = (adc_temp[3])[i];
 8020b4a:	6818      	ldr	r0, [r3, #0]
 8020b4c:	f837 ef02 	ldrh.w	lr, [r7, #2]!
 8020b50:	f820 e002 	strh.w	lr, [r0, r2]
  adc_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 1, 0);
  adc_temp[2] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 2, 0);
  adc_temp[3] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, 0);

  /* Fill the calibration buffer with raw ADC data */
  for (uint32_t i = 0; i < ds_device_get_settings()->num_samples_per_chirp; i++)
 8020b54:	f108 0801 	add.w	r8, r8, #1
 8020b58:	f7ff faec 	bl	8020134 <ds_device_get_settings>
 8020b5c:	9b00      	ldr	r3, [sp, #0]
 8020b5e:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8020b60:	4499      	add	r9, r3
 8020b62:	9b01      	ldr	r3, [sp, #4]
 8020b64:	4580      	cmp	r8, r0
 8020b66:	eb09 0203 	add.w	r2, r9, r3
 8020b6a:	d3dc      	bcc.n	8020b26 <radar_save_calibration+0x92>
    
    cal_idx += interp_factor;
  }
  
  /* Permanently write the calibration data in to the Flash */
  if (target == CALIBRATION_TARGET_FLASH)
 8020b6c:	9b03      	ldr	r3, [sp, #12]
 8020b6e:	b133      	cbz	r3, 8020b7e <radar_save_calibration+0xea>
    {
      status = radar_get_frame(device, &frame_info, true);
    }
    
    save_adc_calibration(target);
    g_do_processing = true;
 8020b70:	4a26      	ldr	r2, [pc, #152]	; (8020c0c <radar_save_calibration+0x178>)
 8020b72:	2301      	movs	r3, #1
 8020b74:	6013      	str	r3, [r2, #0]
    
    save_algo_calibration(target, (const Algo_Calibrations_t*)calibration_data_ptr);
  }
  
  return (RADAR_ERR_OK);
}
 8020b76:	2000      	movs	r0, #0
 8020b78:	b00d      	add	sp, #52	; 0x34
 8020b7a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  
  /* Permanently write the calibration data in to the Flash */
  if (target == CALIBRATION_TARGET_FLASH)
  {
    /* Read the flashed algorithm parameters */
    bsp_flash_read_data(ADC_CALIB_LEN_BYTES, (uint8_t*)&algo_calibration_s, sizeof(algo_calibration_s));
 8020b7e:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8020b82:	4925      	ldr	r1, [pc, #148]	; (8020c18 <radar_save_calibration+0x184>)
 8020b84:	2204      	movs	r2, #4
 8020b86:	f009 f87f 	bl	8029c88 <bsp_flash_read_data>

//============================================================================

static void write_calibration_flash_data(void)
{
	bsp_flash_write_data(0U, (uint8_t*)adc_i1_calibration, ADC_CALIB_LEN_BYTES);
 8020b8a:	9803      	ldr	r0, [sp, #12]
 8020b8c:	4920      	ldr	r1, [pc, #128]	; (8020c10 <radar_save_calibration+0x17c>)
 8020b8e:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8020b92:	f009 f877 	bl	8029c84 <bsp_flash_write_data>

	bsp_flash_write_data(ADC_CALIB_LEN_BYTES, (uint8_t*)&algo_calibration_s, sizeof(algo_calibration_s));
 8020b96:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8020b9a:	491f      	ldr	r1, [pc, #124]	; (8020c18 <radar_save_calibration+0x184>)
 8020b9c:	2204      	movs	r2, #4
 8020b9e:	f009 f871 	bl	8029c84 <bsp_flash_write_data>

	bsp_flash_flush_data();
 8020ba2:	f009 f873 	bl	8029c8c <bsp_flash_flush_data>
 8020ba6:	e7e3      	b.n	8020b70 <radar_save_calibration+0xdc>

//============================================================================

static void save_algo_calibration(Calibration_Target_t target, const Algo_Calibrations_t*  algo_calibration_ptr)
{
	algo_calibration_s = *algo_calibration_ptr;
 8020ba8:	6818      	ldr	r0, [r3, #0]
 8020baa:	4c1b      	ldr	r4, [pc, #108]	; (8020c18 <radar_save_calibration+0x184>)

	if (target == CALIBRATION_TARGET_FLASH)
 8020bac:	9b03      	ldr	r3, [sp, #12]

//============================================================================

static void save_algo_calibration(Calibration_Target_t target, const Algo_Calibrations_t*  algo_calibration_ptr)
{
	algo_calibration_s = *algo_calibration_ptr;
 8020bae:	6020      	str	r0, [r4, #0]

	if (target == CALIBRATION_TARGET_FLASH)
 8020bb0:	b16b      	cbz	r3, 8020bce <radar_save_calibration+0x13a>
		read_adc_calibration(CALIBRATION_TARGET_FLASH);

		write_calibration_flash_data();
	}

	set_angle_offset(algo_calibration_s.angle_offset_deg);
 8020bb2:	8865      	ldrh	r5, [r4, #2]

static void set_angle_offset(int16_t offset)
{
	if ((offset > BSP_MIN_ANGLE_OFFSET_DEG) || (offset < BSP_MAX_ANGLE_OFFSET_DEG))
	{
		ds_algo_get_settings()->angle_offset_deg = offset;
 8020bb4:	f7ff fa62 	bl	802007c <ds_algo_get_settings>

		write_calibration_flash_data();
	}

	set_angle_offset(algo_calibration_s.angle_offset_deg);
	set_range_offset(algo_calibration_s.distance_offset_cm);
 8020bb8:	8824      	ldrh	r4, [r4, #0]

static void set_angle_offset(int16_t offset)
{
	if ((offset > BSP_MIN_ANGLE_OFFSET_DEG) || (offset < BSP_MAX_ANGLE_OFFSET_DEG))
	{
		ds_algo_get_settings()->angle_offset_deg = offset;
 8020bba:	8505      	strh	r5, [r0, #40]	; 0x28

//============================================================================

static void set_range_offset(uint16_t offset)
{
	if (offset < BSP_MAX_RANGE_OFFSET_CM)
 8020bbc:	2c63      	cmp	r4, #99	; 0x63
 8020bbe:	d8da      	bhi.n	8020b76 <radar_save_calibration+0xe2>
	{
		ds_algo_get_settings()->range_offset_cm = offset;
 8020bc0:	f7ff fa5c 	bl	802007c <ds_algo_get_settings>
 8020bc4:	6244      	str	r4, [r0, #36]	; 0x24
    
    save_algo_calibration(target, (const Algo_Calibrations_t*)calibration_data_ptr);
  }
  
  return (RADAR_ERR_OK);
}
 8020bc6:	2000      	movs	r0, #0
 8020bc8:	b00d      	add	sp, #52	; 0x34
 8020bca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
{
	Radar_Handle_t device = NULL;

	if (target == CALIBRATION_TARGET_FLASH)
	{
		if (bsp_flash_is_empty())
 8020bce:	f009 f85f 	bl	8029c90 <bsp_flash_is_empty>
 8020bd2:	b998      	cbnz	r0, 8020bfc <radar_save_calibration+0x168>
			radar_init_calibration(device);
		}
		else
		{
			/* Read calibration stored in flash */
			bsp_flash_read_data(0U, (uint8_t*)adc_i1_calibration, ADC_CALIB_LEN_BYTES);
 8020bd4:	490e      	ldr	r1, [pc, #56]	; (8020c10 <radar_save_calibration+0x17c>)
 8020bd6:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8020bda:	f009 f855 	bl	8029c88 <bsp_flash_read_data>

//============================================================================

static void write_calibration_flash_data(void)
{
	bsp_flash_write_data(0U, (uint8_t*)adc_i1_calibration, ADC_CALIB_LEN_BYTES);
 8020bde:	2000      	movs	r0, #0
 8020be0:	490b      	ldr	r1, [pc, #44]	; (8020c10 <radar_save_calibration+0x17c>)
 8020be2:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8020be6:	f009 f84d 	bl	8029c84 <bsp_flash_write_data>

	bsp_flash_write_data(ADC_CALIB_LEN_BYTES, (uint8_t*)&algo_calibration_s, sizeof(algo_calibration_s));
 8020bea:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8020bee:	490a      	ldr	r1, [pc, #40]	; (8020c18 <radar_save_calibration+0x184>)
 8020bf0:	2204      	movs	r2, #4
 8020bf2:	f009 f847 	bl	8029c84 <bsp_flash_write_data>

	bsp_flash_flush_data();
 8020bf6:	f009 f849 	bl	8029c8c <bsp_flash_flush_data>
 8020bfa:	e7da      	b.n	8020bb2 <radar_save_calibration+0x11e>

void radar_init_calibration(Radar_Handle_t device)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */

  memset(adc_i1_calibration, DEFAULT_CALIBRATION_VALUE, ADC_CALIB_LEN_BYTES);
 8020bfc:	9903      	ldr	r1, [sp, #12]
 8020bfe:	4804      	ldr	r0, [pc, #16]	; (8020c10 <radar_save_calibration+0x17c>)
 8020c00:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8020c04:	f00d ffdb 	bl	802ebbe <memset>
 8020c08:	e7e9      	b.n	8020bde <radar_save_calibration+0x14a>
 8020c0a:	bf00      	nop
 8020c0c:	1ffe88a8 	.word	0x1ffe88a8
 8020c10:	2000cb28 	.word	0x2000cb28
 8020c14:	1ffe88a4 	.word	0x1ffe88a4
 8020c18:	1ffe97bc 	.word	0x1ffe97bc
 8020c1c:	1ffe889c 	.word	0x1ffe889c
 8020c20:	1ffe88a0 	.word	0x1ffe88a0

08020c24 <radar_read_calibration>:
}

//============================================================================

uint16_t radar_read_calibration(Radar_Handle_t device, Calibration_Target_t target, Calibration_Data_t calib_data_type, void** data_ptr, uint16_t* num_of_bytes)
{
 8020c24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8020c28:	9f06      	ldr	r7, [sp, #24]
 8020c2a:	460d      	mov	r5, r1
 8020c2c:	461e      	mov	r6, r3
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  if (calib_data_type == CALIBRATION_DATA_ADC)
 8020c2e:	b19a      	cbz	r2, 8020c58 <radar_read_calibration+0x34>

static uint32_t read_algo_calibration(Calibration_Target_t target)
{
	size_t algo_size = sizeof(algo_calibration_s);

	if (target == CALIBRATION_TARGET_FLASH)
 8020c30:	b1d9      	cbz	r1, 8020c6a <radar_read_calibration+0x46>
 8020c32:	4c1e      	ldr	r4, [pc, #120]	; (8020cac <radar_read_calibration+0x88>)
 8020c34:	f8b4 8002 	ldrh.w	r8, [r4, #2]

static void set_angle_offset(int16_t offset)
{
	if ((offset > BSP_MIN_ANGLE_OFFSET_DEG) || (offset < BSP_MAX_ANGLE_OFFSET_DEG))
	{
		ds_algo_get_settings()->angle_offset_deg = offset;
 8020c38:	f7ff fa20 	bl	802007c <ds_algo_get_settings>
			bsp_flash_read_data(ADC_CALIB_LEN_BYTES, (uint8_t*)&algo_calibration_s, algo_size);
		}
	}

	set_angle_offset(algo_calibration_s.angle_offset_deg);
	set_range_offset(algo_calibration_s.distance_offset_cm);
 8020c3c:	8825      	ldrh	r5, [r4, #0]

static void set_angle_offset(int16_t offset)
{
	if ((offset > BSP_MIN_ANGLE_OFFSET_DEG) || (offset < BSP_MAX_ANGLE_OFFSET_DEG))
	{
		ds_algo_get_settings()->angle_offset_deg = offset;
 8020c3e:	f8a0 8028 	strh.w	r8, [r0, #40]	; 0x28

//============================================================================

static void set_range_offset(uint16_t offset)
{
	if (offset < BSP_MAX_RANGE_OFFSET_CM)
 8020c42:	2d63      	cmp	r5, #99	; 0x63
 8020c44:	d802      	bhi.n	8020c4c <radar_read_calibration+0x28>
	{
		ds_algo_get_settings()->range_offset_cm = offset;
 8020c46:	f7ff fa19 	bl	802007c <ds_algo_get_settings>
 8020c4a:	6245      	str	r5, [r0, #36]	; 0x24
    *num_of_bytes = read_adc_calibration(target);
    *data_ptr = adc_i1_calibration;
  }
  else
  {
    *num_of_bytes = read_algo_calibration(target);
 8020c4c:	2304      	movs	r3, #4
 8020c4e:	803b      	strh	r3, [r7, #0]
    *data_ptr = &algo_calibration_s;
  }
  
  return (RADAR_ERR_OK);
}
 8020c50:	2000      	movs	r0, #0
    *data_ptr = adc_i1_calibration;
  }
  else
  {
    *num_of_bytes = read_algo_calibration(target);
    *data_ptr = &algo_calibration_s;
 8020c52:	6034      	str	r4, [r6, #0]
  }
  
  return (RADAR_ERR_OK);
}
 8020c54:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

static uint32_t read_adc_calibration(Calibration_Target_t target)
{
	Radar_Handle_t device = NULL;

	if (target == CALIBRATION_TARGET_FLASH)
 8020c58:	b171      	cbz	r1, 8020c78 <radar_read_calibration+0x54>
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  if (calib_data_type == CALIBRATION_DATA_ADC)
  {
    *num_of_bytes = read_adc_calibration(target);
 8020c5a:	f44f 6200 	mov.w	r2, #2048	; 0x800
    *data_ptr = adc_i1_calibration;
 8020c5e:	4b14      	ldr	r3, [pc, #80]	; (8020cb0 <radar_read_calibration+0x8c>)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  if (calib_data_type == CALIBRATION_DATA_ADC)
  {
    *num_of_bytes = read_adc_calibration(target);
 8020c60:	803a      	strh	r2, [r7, #0]
    *num_of_bytes = read_algo_calibration(target);
    *data_ptr = &algo_calibration_s;
  }
  
  return (RADAR_ERR_OK);
}
 8020c62:	2000      	movs	r0, #0
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  if (calib_data_type == CALIBRATION_DATA_ADC)
  {
    *num_of_bytes = read_adc_calibration(target);
    *data_ptr = adc_i1_calibration;
 8020c64:	6033      	str	r3, [r6, #0]
    *num_of_bytes = read_algo_calibration(target);
    *data_ptr = &algo_calibration_s;
  }
  
  return (RADAR_ERR_OK);
}
 8020c66:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
{
	size_t algo_size = sizeof(algo_calibration_s);

	if (target == CALIBRATION_TARGET_FLASH)
	{
		if (bsp_flash_is_empty())
 8020c6a:	f009 f811 	bl	8029c90 <bsp_flash_is_empty>
		{
			memset(&algo_calibration_s, DEFAULT_CALIBRATION_VALUE, algo_size);
 8020c6e:	4c0f      	ldr	r4, [pc, #60]	; (8020cac <radar_read_calibration+0x88>)
{
	size_t algo_size = sizeof(algo_calibration_s);

	if (target == CALIBRATION_TARGET_FLASH)
	{
		if (bsp_flash_is_empty())
 8020c70:	b158      	cbz	r0, 8020c8a <radar_read_calibration+0x66>
		{
			memset(&algo_calibration_s, DEFAULT_CALIBRATION_VALUE, algo_size);
 8020c72:	46a8      	mov	r8, r5
 8020c74:	6025      	str	r5, [r4, #0]
 8020c76:	e7df      	b.n	8020c38 <radar_read_calibration+0x14>
{
	Radar_Handle_t device = NULL;

	if (target == CALIBRATION_TARGET_FLASH)
	{
		if (bsp_flash_is_empty())
 8020c78:	f009 f80a 	bl	8029c90 <bsp_flash_is_empty>
 8020c7c:	b970      	cbnz	r0, 8020c9c <radar_read_calibration+0x78>
			radar_init_calibration(device);
		}
		else
		{
			/* Read calibration stored in flash */
			bsp_flash_read_data(0U, (uint8_t*)adc_i1_calibration, ADC_CALIB_LEN_BYTES);
 8020c7e:	490c      	ldr	r1, [pc, #48]	; (8020cb0 <radar_read_calibration+0x8c>)
 8020c80:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8020c84:	f009 f800 	bl	8029c88 <bsp_flash_read_data>
 8020c88:	e7e7      	b.n	8020c5a <radar_read_calibration+0x36>
		{
			memset(&algo_calibration_s, DEFAULT_CALIBRATION_VALUE, algo_size);
		}
		else
		{
			bsp_flash_read_data(ADC_CALIB_LEN_BYTES, (uint8_t*)&algo_calibration_s, algo_size);
 8020c8a:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8020c8e:	4621      	mov	r1, r4
 8020c90:	2204      	movs	r2, #4
 8020c92:	f008 fff9 	bl	8029c88 <bsp_flash_read_data>
 8020c96:	f8b4 8002 	ldrh.w	r8, [r4, #2]
 8020c9a:	e7cd      	b.n	8020c38 <radar_read_calibration+0x14>

void radar_init_calibration(Radar_Handle_t device)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */

  memset(adc_i1_calibration, DEFAULT_CALIBRATION_VALUE, ADC_CALIB_LEN_BYTES);
 8020c9c:	4629      	mov	r1, r5
 8020c9e:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8020ca2:	4803      	ldr	r0, [pc, #12]	; (8020cb0 <radar_read_calibration+0x8c>)
 8020ca4:	f00d ff8b 	bl	802ebbe <memset>
 8020ca8:	e7d7      	b.n	8020c5a <radar_read_calibration+0x36>
 8020caa:	bf00      	nop
 8020cac:	1ffe97bc 	.word	0x1ffe97bc
 8020cb0:	2000cb28 	.word	0x2000cb28

08020cb4 <radar_clear_calibration>:
}

//============================================================================

uint16_t radar_clear_calibration(Radar_Handle_t device, Calibration_Target_t target, Calibration_Data_t calib_data_type)
{
 8020cb4:	b538      	push	{r3, r4, r5, lr}
 8020cb6:	460c      	mov	r4, r1
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  if (calib_data_type == CALIBRATION_DATA_ADC)
 8020cb8:	b17a      	cbz	r2, 8020cda <radar_clear_calibration+0x26>

//============================================================================

static void clear_algo_calibration(Calibration_Target_t target)
{
	memset(&algo_calibration_s, 0, sizeof(algo_calibration_s));
 8020cba:	4d26      	ldr	r5, [pc, #152]	; (8020d54 <radar_clear_calibration+0xa0>)
 8020cbc:	2300      	movs	r3, #0
 8020cbe:	602b      	str	r3, [r5, #0]

	if (target == CALIBRATION_TARGET_FLASH)
 8020cc0:	b349      	cbz	r1, 8020d16 <radar_clear_calibration+0x62>
 8020cc2:	461c      	mov	r4, r3

static void set_angle_offset(int16_t offset)
{
	if ((offset > BSP_MIN_ANGLE_OFFSET_DEG) || (offset < BSP_MAX_ANGLE_OFFSET_DEG))
	{
		ds_algo_get_settings()->angle_offset_deg = offset;
 8020cc4:	f7ff f9da 	bl	802007c <ds_algo_get_settings>

		write_calibration_flash_data();
	}

	set_angle_offset(algo_calibration_s.angle_offset_deg);
	set_range_offset(algo_calibration_s.distance_offset_cm);
 8020cc8:	882d      	ldrh	r5, [r5, #0]

static void set_angle_offset(int16_t offset)
{
	if ((offset > BSP_MIN_ANGLE_OFFSET_DEG) || (offset < BSP_MAX_ANGLE_OFFSET_DEG))
	{
		ds_algo_get_settings()->angle_offset_deg = offset;
 8020cca:	8504      	strh	r4, [r0, #40]	; 0x28

//============================================================================

static void set_range_offset(uint16_t offset)
{
	if (offset < BSP_MAX_RANGE_OFFSET_CM)
 8020ccc:	2d63      	cmp	r5, #99	; 0x63
 8020cce:	d802      	bhi.n	8020cd6 <radar_clear_calibration+0x22>
	{
		ds_algo_get_settings()->range_offset_cm = offset;
 8020cd0:	f7ff f9d4 	bl	802007c <ds_algo_get_settings>
 8020cd4:	6245      	str	r5, [r0, #36]	; 0x24
  {
    clear_algo_calibration(target);
  }
  
  return (RADAR_ERR_OK);
}
 8020cd6:	2000      	movs	r0, #0
 8020cd8:	bd38      	pop	{r3, r4, r5, pc}

void radar_init_calibration(Radar_Handle_t device)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */

  memset(adc_i1_calibration, DEFAULT_CALIBRATION_VALUE, ADC_CALIB_LEN_BYTES);
 8020cda:	4611      	mov	r1, r2
 8020cdc:	481e      	ldr	r0, [pc, #120]	; (8020d58 <radar_clear_calibration+0xa4>)
 8020cde:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8020ce2:	f00d ff6c 	bl	802ebbe <memset>
  Radar_Handle_t device = NULL;
  
  /* Reset SRAM buffer to a default value */
  radar_init_calibration(device);
  
  if (target == CALIBRATION_TARGET_FLASH)
 8020ce6:	2c00      	cmp	r4, #0
 8020ce8:	d1f5      	bne.n	8020cd6 <radar_clear_calibration+0x22>
  {
    bsp_flash_read_data(ADC_CALIB_LEN_BYTES, (uint8_t*)&algo_calibration_s, sizeof(algo_calibration_s));
 8020cea:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8020cee:	4919      	ldr	r1, [pc, #100]	; (8020d54 <radar_clear_calibration+0xa0>)
 8020cf0:	2204      	movs	r2, #4
 8020cf2:	f008 ffc9 	bl	8029c88 <bsp_flash_read_data>

//============================================================================

static void write_calibration_flash_data(void)
{
	bsp_flash_write_data(0U, (uint8_t*)adc_i1_calibration, ADC_CALIB_LEN_BYTES);
 8020cf6:	4620      	mov	r0, r4
 8020cf8:	4917      	ldr	r1, [pc, #92]	; (8020d58 <radar_clear_calibration+0xa4>)
 8020cfa:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8020cfe:	f008 ffc1 	bl	8029c84 <bsp_flash_write_data>

	bsp_flash_write_data(ADC_CALIB_LEN_BYTES, (uint8_t*)&algo_calibration_s, sizeof(algo_calibration_s));
 8020d02:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8020d06:	4913      	ldr	r1, [pc, #76]	; (8020d54 <radar_clear_calibration+0xa0>)
 8020d08:	2204      	movs	r2, #4
 8020d0a:	f008 ffbb 	bl	8029c84 <bsp_flash_write_data>

	bsp_flash_flush_data();
 8020d0e:	f008 ffbd 	bl	8029c8c <bsp_flash_flush_data>
  {
    clear_algo_calibration(target);
  }
  
  return (RADAR_ERR_OK);
}
 8020d12:	2000      	movs	r0, #0
 8020d14:	bd38      	pop	{r3, r4, r5, pc}
{
	Radar_Handle_t device = NULL;

	if (target == CALIBRATION_TARGET_FLASH)
	{
		if (bsp_flash_is_empty())
 8020d16:	f008 ffbb 	bl	8029c90 <bsp_flash_is_empty>
 8020d1a:	b9a0      	cbnz	r0, 8020d46 <radar_clear_calibration+0x92>
			radar_init_calibration(device);
		}
		else
		{
			/* Read calibration stored in flash */
			bsp_flash_read_data(0U, (uint8_t*)adc_i1_calibration, ADC_CALIB_LEN_BYTES);
 8020d1c:	490e      	ldr	r1, [pc, #56]	; (8020d58 <radar_clear_calibration+0xa4>)
 8020d1e:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8020d22:	f008 ffb1 	bl	8029c88 <bsp_flash_read_data>

//============================================================================

static void write_calibration_flash_data(void)
{
	bsp_flash_write_data(0U, (uint8_t*)adc_i1_calibration, ADC_CALIB_LEN_BYTES);
 8020d26:	2000      	movs	r0, #0
 8020d28:	490b      	ldr	r1, [pc, #44]	; (8020d58 <radar_clear_calibration+0xa4>)
 8020d2a:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8020d2e:	f008 ffa9 	bl	8029c84 <bsp_flash_write_data>

	bsp_flash_write_data(ADC_CALIB_LEN_BYTES, (uint8_t*)&algo_calibration_s, sizeof(algo_calibration_s));
 8020d32:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8020d36:	4907      	ldr	r1, [pc, #28]	; (8020d54 <radar_clear_calibration+0xa0>)
 8020d38:	2204      	movs	r2, #4
 8020d3a:	f008 ffa3 	bl	8029c84 <bsp_flash_write_data>

	bsp_flash_flush_data();
 8020d3e:	f008 ffa5 	bl	8029c8c <bsp_flash_flush_data>
 8020d42:	886c      	ldrh	r4, [r5, #2]
 8020d44:	e7be      	b.n	8020cc4 <radar_clear_calibration+0x10>

void radar_init_calibration(Radar_Handle_t device)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */

  memset(adc_i1_calibration, DEFAULT_CALIBRATION_VALUE, ADC_CALIB_LEN_BYTES);
 8020d46:	4621      	mov	r1, r4
 8020d48:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8020d4c:	4802      	ldr	r0, [pc, #8]	; (8020d58 <radar_clear_calibration+0xa4>)
 8020d4e:	f00d ff36 	bl	802ebbe <memset>
 8020d52:	e7e8      	b.n	8020d26 <radar_clear_calibration+0x72>
 8020d54:	1ffe97bc 	.word	0x1ffe97bc
 8020d58:	2000cb28 	.word	0x2000cb28

08020d5c <radar_apply_new_hw_setting.isra.1>:
  return (status);
}

//============================================================================

static uint32_t radar_apply_new_hw_setting(Radar_Handle_t device, device_settings_t *p_new)
 8020d5c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8020d5e:	ed2d 8b04 	vpush	{d8-d9}
 8020d62:	4604      	mov	r4, r0
 8020d64:	b095      	sub	sp, #84	; 0x54
{
  bsp_components_power_down();
 8020d66:	f008 ff65 	bl	8029c34 <bsp_components_power_down>
  
  device_settings_t *p_curr = ds_device_get_shadow_settings();
 8020d6a:	f7ff f9e7 	bl	802013c <ds_device_get_shadow_settings>
  
  /* Set BGT RX LNA gain */
  if (p_new->bgt_rx_lna_gain_enable_flag == true)
 8020d6e:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
 8020d72:	2b01      	cmp	r3, #1

static uint32_t radar_apply_new_hw_setting(Radar_Handle_t device, device_settings_t *p_new)
{
  bsp_components_power_down();
  
  device_settings_t *p_curr = ds_device_get_shadow_settings();
 8020d74:	4605      	mov	r5, r0
  
  /* Set BGT RX LNA gain */
  if (p_new->bgt_rx_lna_gain_enable_flag == true)
 8020d76:	d059      	beq.n	8020e2c <radar_apply_new_hw_setting.isra.1+0xd0>
  {
    bgt_lna_gain_enable();
  }
  else
  {
    bgt_lna_gain_disable();
 8020d78:	f008 fd28 	bl	80297cc <bgt_lna_gain_disable>
  }
  
  if (p_curr->pll_chirp_time_usec != p_new->pll_chirp_time_usec || (p_curr->num_samples_per_chirp != p_new->num_samples_per_chirp))
 8020d7c:	682a      	ldr	r2, [r5, #0]
 8020d7e:	6823      	ldr	r3, [r4, #0]
 8020d80:	429a      	cmp	r2, r3
 8020d82:	d04a      	beq.n	8020e1a <radar_apply_new_hw_setting.isra.1+0xbe>
  {
    if (ds_device_get_settings()->pll_modulation_mode == MODULATION_FMCW)
 8020d84:	f7ff f9d6 	bl	8020134 <ds_device_get_settings>
 8020d88:	6986      	ldr	r6, [r0, #24]
 8020d8a:	2e01      	cmp	r6, #1
 8020d8c:	f000 80b5 	beq.w	8020efa <radar_apply_new_hw_setting.isra.1+0x19e>
        return (RADAR_ERR_PARAMETER_OUT_OF_RANGE);
      }
	}
  }
  
  if (p_curr->pll_num_of_chirps_per_frame != p_new->pll_num_of_chirps_per_frame)
 8020d90:	6960      	ldr	r0, [r4, #20]
 8020d92:	696b      	ldr	r3, [r5, #20]
 8020d94:	4283      	cmp	r3, r0
 8020d96:	d004      	beq.n	8020da2 <radar_apply_new_hw_setting.isra.1+0x46>
  {
    /* Update the number of chirps count per frame */
    bsp_set_num_chirps_per_frame(p_new->pll_num_of_chirps_per_frame);
 8020d98:	f009 fa20 	bl	802a1dc <bsp_set_num_chirps_per_frame>
    pll_set_update_config_flag(true);
 8020d9c:	2001      	movs	r0, #1
 8020d9e:	f009 fc0b 	bl	802a5b8 <pll_set_update_config_flag>
  }
  
  if (p_curr->num_samples_per_chirp != p_new->num_samples_per_chirp)
 8020da2:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8020da4:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8020da6:	4283      	cmp	r3, r0
 8020da8:	d001      	beq.n	8020dae <radar_apply_new_hw_setting.isra.1+0x52>
  {
    bsp_set_num_samples_per_dma_transfer(p_new->num_samples_per_chirp);
 8020daa:	f009 fa11 	bl	802a1d0 <bsp_set_num_samples_per_dma_transfer>
  }
  
  if (p_new->isUpdated_doppler_config)
 8020dae:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8020db0:	2b00      	cmp	r3, #0
 8020db2:	f040 8083 	bne.w	8020ebc <radar_apply_new_hw_setting.isra.1+0x160>
    }
    
    p_new->isUpdated_doppler_config = 0;
  }
  
  if(p_new->isUpdated_fmcw_config)
 8020db6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8020db8:	2b00      	cmp	r3, #0
 8020dba:	d13a      	bne.n	8020e32 <radar_apply_new_hw_setting.isra.1+0xd6>
    
    p_new->isUpdated_fmcw_config = 0;
  }

  /* Set the Radar duty cycle */
  if(p_new->is_duty_cycle_enable_updated)
 8020dbc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8020dbe:	2b00      	cmp	r3, #0
 8020dc0:	d175      	bne.n	8020eae <radar_apply_new_hw_setting.isra.1+0x152>
  {
    bsp_set_duty_cycle_enable_flag(p_new->power_duty_cycle_enable_flag);
    p_new->is_duty_cycle_enable_updated = 0;
  }

  if ((p_curr->pll_num_of_chirps_per_frame != p_new->pll_num_of_chirps_per_frame) || (p_curr->num_samples_per_chirp != p_new->num_samples_per_chirp))
 8020dc2:	696a      	ldr	r2, [r5, #20]
 8020dc4:	6963      	ldr	r3, [r4, #20]
 8020dc6:	429a      	cmp	r2, r3
 8020dc8:	d022      	beq.n	8020e10 <radar_apply_new_hw_setting.isra.1+0xb4>
  {
    /* Recreate acq-buffer object! */
    /* The buffer is statically allocated to the max supported buffer size, so it is save to re-use it!
     * checks should have been applied earlier! */
    acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 8020dca:	f7ff fa1d 	bl	8020208 <ds_get_active_acq_buf>
    
    uint8_t *p_temp_buf = p_acq_buf->p_acq_buf;
    uint32_t reserved_size = p_acq_buf->internals.size_of_acq_buffer;

    acq_buf_obj acq_buf = create_acq_data_buffer_obj(p_temp_buf, reserved_size,
 8020dce:	ae08      	add	r6, sp, #32
 8020dd0:	8aa3      	ldrh	r3, [r4, #20]
 8020dd2:	6a81      	ldr	r1, [r0, #40]	; 0x28
 8020dd4:	68c2      	ldr	r2, [r0, #12]
 8020dd6:	8da0      	ldrh	r0, [r4, #44]	; 0x2c
 8020dd8:	9000      	str	r0, [sp, #0]
 8020dda:	2402      	movs	r4, #2
 8020ddc:	250c      	movs	r5, #12
 8020dde:	4630      	mov	r0, r6
 8020de0:	9401      	str	r4, [sp, #4]
 8020de2:	9402      	str	r4, [sp, #8]
 8020de4:	9503      	str	r5, [sp, #12]
                                                     p_new->pll_num_of_chirps_per_frame,
                                                     p_new->num_samples_per_chirp, 2, 2, 12);  // 2 --> 2 I channels and two Q-channels, from two RX-antennas, 12-bit ADC resolution
    
    ds_set_active_acq_buf(acq_buf);
 8020de6:	ad0c      	add	r5, sp, #48	; 0x30
    acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
    
    uint8_t *p_temp_buf = p_acq_buf->p_acq_buf;
    uint32_t reserved_size = p_acq_buf->internals.size_of_acq_buffer;

    acq_buf_obj acq_buf = create_acq_data_buffer_obj(p_temp_buf, reserved_size,
 8020de8:	f7ff fb94 	bl	8020514 <create_acq_data_buffer_obj>
                                                     p_new->pll_num_of_chirps_per_frame,
                                                     p_new->num_samples_per_chirp, 2, 2, 12);  // 2 --> 2 I channels and two Q-channels, from two RX-antennas, 12-bit ADC resolution
    
    ds_set_active_acq_buf(acq_buf);
 8020dec:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020dee:	466c      	mov	r4, sp
 8020df0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8020df2:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8020df6:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 8020dfa:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
 8020dfe:	f7ff fa07 	bl	8020210 <ds_set_active_acq_buf>
  }
  
  bsp_components_power_up();
 8020e02:	f008 fe69 	bl	8029ad8 <bsp_components_power_up>
  
  return 0; // confirm that everything was o.k.
 8020e06:	2000      	movs	r0, #0
}
 8020e08:	b015      	add	sp, #84	; 0x54
 8020e0a:	ecbd 8b04 	vpop	{d8-d9}
 8020e0e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  {
    bsp_set_duty_cycle_enable_flag(p_new->power_duty_cycle_enable_flag);
    p_new->is_duty_cycle_enable_updated = 0;
  }

  if ((p_curr->pll_num_of_chirps_per_frame != p_new->pll_num_of_chirps_per_frame) || (p_curr->num_samples_per_chirp != p_new->num_samples_per_chirp))
 8020e10:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8020e12:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8020e14:	429a      	cmp	r2, r3
 8020e16:	d1d8      	bne.n	8020dca <radar_apply_new_hw_setting.isra.1+0x6e>
 8020e18:	e7f3      	b.n	8020e02 <radar_apply_new_hw_setting.isra.1+0xa6>
  else
  {
    bgt_lna_gain_disable();
  }
  
  if (p_curr->pll_chirp_time_usec != p_new->pll_chirp_time_usec || (p_curr->num_samples_per_chirp != p_new->num_samples_per_chirp))
 8020e1a:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8020e1c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8020e1e:	429a      	cmp	r2, r3
 8020e20:	d1b0      	bne.n	8020d84 <radar_apply_new_hw_setting.isra.1+0x28>
        return (RADAR_ERR_PARAMETER_OUT_OF_RANGE);
      }
	}
  }
  
  if (p_curr->pll_num_of_chirps_per_frame != p_new->pll_num_of_chirps_per_frame)
 8020e22:	6960      	ldr	r0, [r4, #20]
 8020e24:	696b      	ldr	r3, [r5, #20]
 8020e26:	4283      	cmp	r3, r0
 8020e28:	d1b6      	bne.n	8020d98 <radar_apply_new_hw_setting.isra.1+0x3c>
 8020e2a:	e7c0      	b.n	8020dae <radar_apply_new_hw_setting.isra.1+0x52>
  device_settings_t *p_curr = ds_device_get_shadow_settings();
  
  /* Set BGT RX LNA gain */
  if (p_new->bgt_rx_lna_gain_enable_flag == true)
  {
    bgt_lna_gain_enable();
 8020e2c:	f008 fccc 	bl	80297c8 <bgt_lna_gain_enable>
 8020e30:	e7a4      	b.n	8020d7c <radar_apply_new_hw_setting.isra.1+0x20>
    float bandwidth_mhz;
    float pll_base_frequency_mhz;

    /* Apply RF configuration */
    /* ---------------------- */
    bandwidth_mhz = ((float)(p_new->pll_upper_frequency_kHz - p_new->pll_lower_frequency_kHz)) / 1000.0f;
 8020e32:	ed94 9a03 	vldr	s18, [r4, #12]
 8020e36:	ed94 8a02 	vldr	s16, [r4, #8]
 8020e3a:	eddf 8a45 	vldr	s17, [pc, #276]	; 8020f50 <radar_apply_new_hw_setting.isra.1+0x1f4>
 8020e3e:	ee39 8a48 	vsub.f32	s16, s18, s16
    
    pll_base_frequency_mhz = (float)(p_new->pll_upper_frequency_kHz) / 1000.0f;
    
    // This is redundant, but we leave it for now, needs to be tested!
    ds_device_get_settings()->pll_bandwidth_MHz = bandwidth_mhz;
 8020e42:	f7ff f977 	bl	8020134 <ds_device_get_settings>
    float bandwidth_mhz;
    float pll_base_frequency_mhz;

    /* Apply RF configuration */
    /* ---------------------- */
    bandwidth_mhz = ((float)(p_new->pll_upper_frequency_kHz - p_new->pll_lower_frequency_kHz)) / 1000.0f;
 8020e46:	ee88 8a28 	vdiv.f32	s16, s16, s17
    pll_base_frequency_mhz = (float)(p_new->pll_upper_frequency_kHz) / 1000.0f;
    
    // This is redundant, but we leave it for now, needs to be tested!
    ds_device_get_settings()->pll_bandwidth_MHz = bandwidth_mhz;
    
    pll_set_frequency(pll_base_frequency_mhz);
 8020e4a:	eec9 7a28 	vdiv.f32	s15, s18, s17
    bandwidth_mhz = ((float)(p_new->pll_upper_frequency_kHz - p_new->pll_lower_frequency_kHz)) / 1000.0f;
    
    pll_base_frequency_mhz = (float)(p_new->pll_upper_frequency_kHz) / 1000.0f;
    
    // This is redundant, but we leave it for now, needs to be tested!
    ds_device_get_settings()->pll_bandwidth_MHz = bandwidth_mhz;
 8020e4e:	ed80 8a04 	vstr	s16, [r0, #16]
    
    pll_set_frequency(pll_base_frequency_mhz);
 8020e52:	ee17 0a90 	vmov	r0, s15
 8020e56:	f00d f803 	bl	802de60 <__aeabi_f2d>
 8020e5a:	f009 fbbd 	bl	802a5d8 <pll_set_frequency>
    pll_set_bandwidth(bandwidth_mhz);
 8020e5e:	ee18 0a10 	vmov	r0, s16
 8020e62:	f009 fc27 	bl	802a6b4 <pll_set_bandwidth>
    pll_set_upper_lower_frequency(p_new->pll_lower_frequency_kHz / 1000.0f, p_new->pll_upper_frequency_kHz / 1000.0f);
 8020e66:	edd4 7a02 	vldr	s15, [r4, #8]
 8020e6a:	eec7 7aa8 	vdiv.f32	s15, s15, s17
 8020e6e:	ee17 0a90 	vmov	r0, s15
 8020e72:	f00c fff5 	bl	802de60 <__aeabi_f2d>
 8020e76:	edd4 7a03 	vldr	s15, [r4, #12]
 8020e7a:	eec7 7aa8 	vdiv.f32	s15, s15, s17
 8020e7e:	4606      	mov	r6, r0
 8020e80:	460f      	mov	r7, r1
 8020e82:	ee17 0a90 	vmov	r0, s15
 8020e86:	f00c ffeb 	bl	802de60 <__aeabi_f2d>
 8020e8a:	460b      	mov	r3, r1
 8020e8c:	4602      	mov	r2, r0
 8020e8e:	4639      	mov	r1, r7
 8020e90:	4630      	mov	r0, r6
 8020e92:	f009 fbd1 	bl	802a638 <pll_set_upper_lower_frequency>
    pll_set_update_config_flag(true);
 8020e96:	2001      	movs	r0, #1
 8020e98:	f009 fb8e 	bl	802a5b8 <pll_set_update_config_flag>
    
    bgt_set_tx_power(p_new->bgt_tx_power_level);
 8020e9c:	f894 0025 	ldrb.w	r0, [r4, #37]	; 0x25
 8020ea0:	f008 fc90 	bl	80297c4 <bgt_set_tx_power>
    
    p_new->isUpdated_fmcw_config = 0;
 8020ea4:	2300      	movs	r3, #0
 8020ea6:	63e3      	str	r3, [r4, #60]	; 0x3c
  }

  /* Set the Radar duty cycle */
  if(p_new->is_duty_cycle_enable_updated)
 8020ea8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8020eaa:	2b00      	cmp	r3, #0
 8020eac:	d089      	beq.n	8020dc2 <radar_apply_new_hw_setting.isra.1+0x66>
  {
    bsp_set_duty_cycle_enable_flag(p_new->power_duty_cycle_enable_flag);
 8020eae:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
 8020eb2:	f009 f9a1 	bl	802a1f8 <bsp_set_duty_cycle_enable_flag>
    p_new->is_duty_cycle_enable_updated = 0;
 8020eb6:	2300      	movs	r3, #0
 8020eb8:	63a3      	str	r3, [r4, #56]	; 0x38
 8020eba:	e782      	b.n	8020dc2 <radar_apply_new_hw_setting.isra.1+0x66>
  {
    float freq_MHz;
    
    /* Apply RF configuration */
    /* ---------------------- */
    bgt_set_tx_power(p_new->bgt_tx_power_level);
 8020ebc:	f894 0025 	ldrb.w	r0, [r4, #37]	; 0x25
 8020ec0:	f008 fc80 	bl	80297c4 <bgt_set_tx_power>
    
    freq_MHz = (float)(p_new->pll_frequency_kHz / 1000.0f); // to bring into the MHz
 8020ec4:	ed94 8a01 	vldr	s16, [r4, #4]
    
    if (ds_device_get_settings()->pll_modulation_mode == MODULATION_DOPPLER)
 8020ec8:	f7ff f934 	bl	8020134 <ds_device_get_settings>
 8020ecc:	6983      	ldr	r3, [r0, #24]
 8020ece:	b98b      	cbnz	r3, 8020ef4 <radar_apply_new_hw_setting.isra.1+0x198>
    
    /* Apply RF configuration */
    /* ---------------------- */
    bgt_set_tx_power(p_new->bgt_tx_power_level);
    
    freq_MHz = (float)(p_new->pll_frequency_kHz / 1000.0f); // to bring into the MHz
 8020ed0:	ed9f 7a1f 	vldr	s14, [pc, #124]	; 8020f50 <radar_apply_new_hw_setting.isra.1+0x1f4>
//============================================================================
uint16_t radar_set_pll_frequency(Radar_Handle_t device, float freq_MHz)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  if ((freq_MHz >= BSP_MIN_RF_FREQUENCY_KHZ/1000.0f) && (freq_MHz <= BSP_MAX_RF_FREQUENCY_KHZ/1000.0f))
 8020ed4:	eddf 7a1f 	vldr	s15, [pc, #124]	; 8020f54 <radar_apply_new_hw_setting.isra.1+0x1f8>
    
    /* Apply RF configuration */
    /* ---------------------- */
    bgt_set_tx_power(p_new->bgt_tx_power_level);
    
    freq_MHz = (float)(p_new->pll_frequency_kHz / 1000.0f); // to bring into the MHz
 8020ed8:	ee88 8a07 	vdiv.f32	s16, s16, s14
//============================================================================
uint16_t radar_set_pll_frequency(Radar_Handle_t device, float freq_MHz)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  if ((freq_MHz >= BSP_MIN_RF_FREQUENCY_KHZ/1000.0f) && (freq_MHz <= BSP_MAX_RF_FREQUENCY_KHZ/1000.0f))
 8020edc:	eeb4 8ae7 	vcmpe.f32	s16, s15
 8020ee0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020ee4:	db06      	blt.n	8020ef4 <radar_apply_new_hw_setting.isra.1+0x198>
 8020ee6:	eddf 7a1c 	vldr	s15, [pc, #112]	; 8020f58 <radar_apply_new_hw_setting.isra.1+0x1fc>
 8020eea:	eeb4 8ae7 	vcmpe.f32	s16, s15
 8020eee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020ef2:	d922      	bls.n	8020f3a <radar_apply_new_hw_setting.isra.1+0x1de>
    if (ds_device_get_settings()->pll_modulation_mode == MODULATION_DOPPLER)
    {
      radar_set_pll_frequency(device, freq_MHz);
    }
    
    p_new->isUpdated_doppler_config = 0;
 8020ef4:	2300      	movs	r3, #0
 8020ef6:	6423      	str	r3, [r4, #64]	; 0x40
 8020ef8:	e75d      	b.n	8020db6 <radar_apply_new_hw_setting.isra.1+0x5a>
  
  if (p_curr->pll_chirp_time_usec != p_new->pll_chirp_time_usec || (p_curr->num_samples_per_chirp != p_new->num_samples_per_chirp))
  {
    if (ds_device_get_settings()->pll_modulation_mode == MODULATION_FMCW)
	{
      pll_set_chirp_time(p_new->pll_chirp_time_usec);
 8020efa:	6820      	ldr	r0, [r4, #0]
 8020efc:	f009 fbe0 	bl	802a6c0 <pll_set_chirp_time>
      pll_set_update_config_flag(true);
 8020f00:	4630      	mov	r0, r6
 8020f02:	f009 fb59 	bl	802a5b8 <pll_set_update_config_flag>
    
      uint32_t sampling_period_usec = (uint32_t)(((float) p_new->pll_chirp_time_usec * 100.0f) / (float)p_new->num_samples_per_chirp);
 8020f06:	ed94 7a00 	vldr	s14, [r4]
 8020f0a:	eddf 7a14 	vldr	s15, [pc, #80]	; 8020f5c <radar_apply_new_hw_setting.isra.1+0x200>
 8020f0e:	edd4 6a0b 	vldr	s13, [r4, #44]	; 0x2c

      if (TIMER_SetTimeInterval(&TIMER_ADC_TRIG, sampling_period_usec) != TIMER_STATUS_SUCCESS)
 8020f12:	4813      	ldr	r0, [pc, #76]	; (8020f60 <radar_apply_new_hw_setting.isra.1+0x204>)
    if (ds_device_get_settings()->pll_modulation_mode == MODULATION_FMCW)
	{
      pll_set_chirp_time(p_new->pll_chirp_time_usec);
      pll_set_update_config_flag(true);
    
      uint32_t sampling_period_usec = (uint32_t)(((float) p_new->pll_chirp_time_usec * 100.0f) / (float)p_new->num_samples_per_chirp);
 8020f14:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 8020f18:	eef8 6a66 	vcvt.f32.u32	s13, s13
 8020f1c:	ee67 7a27 	vmul.f32	s15, s14, s15
 8020f20:	eec7 7aa6 	vdiv.f32	s15, s15, s13

      if (TIMER_SetTimeInterval(&TIMER_ADC_TRIG, sampling_period_usec) != TIMER_STATUS_SUCCESS)
 8020f24:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8020f28:	ee17 1a90 	vmov	r1, s15
 8020f2c:	f005 fdf4 	bl	8026b18 <TIMER_SetTimeInterval>
 8020f30:	2800      	cmp	r0, #0
 8020f32:	f43f af2d 	beq.w	8020d90 <radar_apply_new_hw_setting.isra.1+0x34>
      {
        return (RADAR_ERR_PARAMETER_OUT_OF_RANGE);
 8020f36:	200c      	movs	r0, #12
 8020f38:	e766      	b.n	8020e08 <radar_apply_new_hw_setting.isra.1+0xac>
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  if ((freq_MHz >= BSP_MIN_RF_FREQUENCY_KHZ/1000.0f) && (freq_MHz <= BSP_MAX_RF_FREQUENCY_KHZ/1000.0f))
  {
    pll_set_frequency(freq_MHz);
 8020f3a:	ee18 0a10 	vmov	r0, s16
 8020f3e:	f00c ff8f 	bl	802de60 <__aeabi_f2d>
 8020f42:	f009 fb49 	bl	802a5d8 <pll_set_frequency>
    pll_set_update_config_flag(true);
 8020f46:	2001      	movs	r0, #1
 8020f48:	f009 fb36 	bl	802a5b8 <pll_set_update_config_flag>
 8020f4c:	e7d2      	b.n	8020ef4 <radar_apply_new_hw_setting.isra.1+0x198>
 8020f4e:	bf00      	nop
 8020f50:	447a0000 	.word	0x447a0000
 8020f54:	46bbb200 	.word	0x46bbb200
 8020f58:	46bd4200 	.word	0x46bd4200
 8020f5c:	42c80000 	.word	0x42c80000
 8020f60:	1ffe8fc4 	.word	0x1ffe8fc4

08020f64 <radar_init>:
    3. EXPORTED FUNCTIONS
==============================================================================
 */

uint16_t radar_init(Radar_Handle_t device)
{
 8020f64:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8020f68:	ed2d 8b02 	vpush	{d8}
 8020f6c:	b085      	sub	sp, #20
  uint16_t status = RADAR_ERR_BUSY;
  uint16_t num_of_bytes;
  void* calibration_data_ptr = NULL;
 8020f6e:	2400      	movs	r4, #0
    3. EXPORTED FUNCTIONS
==============================================================================
 */

uint16_t radar_init(Radar_Handle_t device)
{
 8020f70:	4606      	mov	r6, r0
  uint16_t status = RADAR_ERR_BUSY;
  uint16_t num_of_bytes;
  void* calibration_data_ptr = NULL;
 8020f72:	9403      	str	r4, [sp, #12]
  
  /* PLL parameters setup */
  /* -------------------- */
  float temp_pll_lower_freq_MHz = ds_device_get_settings()->pll_lower_frequency_kHz / 1000.0f;
 8020f74:	f7ff f8de 	bl	8020134 <ds_device_get_settings>
 8020f78:	edd0 8a02 	vldr	s17, [r0, #8]
 8020f7c:	ed9f 8a4d 	vldr	s16, [pc, #308]	; 80210b4 <radar_init+0x150>
  float temp_pll_upper_freq_MHz = ds_device_get_settings()->pll_upper_frequency_kHz / 1000.0f;
 8020f80:	f7ff f8d8 	bl	8020134 <ds_device_get_settings>
 8020f84:	edd0 7a03 	vldr	s15, [r0, #12]
  uint16_t num_of_bytes;
  void* calibration_data_ptr = NULL;
  
  /* PLL parameters setup */
  /* -------------------- */
  float temp_pll_lower_freq_MHz = ds_device_get_settings()->pll_lower_frequency_kHz / 1000.0f;
 8020f88:	eec8 8a88 	vdiv.f32	s17, s17, s16
  /* Set PLL upper and lower frequencies for FMCW modulation */
  pll_set_upper_lower_frequency(temp_pll_lower_freq_MHz, temp_pll_upper_freq_MHz);
  
#if FW_MODULATION_TYPE == 1U
  
  ds_device_get_settings()->pll_modulation_mode = MODULATION_FMCW;
 8020f8c:	2501      	movs	r5, #1
  void* calibration_data_ptr = NULL;
  
  /* PLL parameters setup */
  /* -------------------- */
  float temp_pll_lower_freq_MHz = ds_device_get_settings()->pll_lower_frequency_kHz / 1000.0f;
  float temp_pll_upper_freq_MHz = ds_device_get_settings()->pll_upper_frequency_kHz / 1000.0f;
 8020f8e:	ee87 8a88 	vdiv.f32	s16, s15, s16
  
  /* Set PLL upper and lower frequencies for FMCW modulation */
  pll_set_upper_lower_frequency(temp_pll_lower_freq_MHz, temp_pll_upper_freq_MHz);
 8020f92:	ee18 0a10 	vmov	r0, s16
 8020f96:	f00c ff63 	bl	802de60 <__aeabi_f2d>
 8020f9a:	4680      	mov	r8, r0
 8020f9c:	4689      	mov	r9, r1
 8020f9e:	ee18 0a90 	vmov	r0, s17
 8020fa2:	f00c ff5d 	bl	802de60 <__aeabi_f2d>
 8020fa6:	4642      	mov	r2, r8
 8020fa8:	464b      	mov	r3, r9
 8020faa:	f009 fb45 	bl	802a638 <pll_set_upper_lower_frequency>
  
#if FW_MODULATION_TYPE == 1U
  
  ds_device_get_settings()->pll_modulation_mode = MODULATION_FMCW;
 8020fae:	f7ff f8c1 	bl	8020134 <ds_device_get_settings>
//============================================================================
uint16_t radar_set_pll_frequency(Radar_Handle_t device, float freq_MHz)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  if ((freq_MHz >= BSP_MIN_RF_FREQUENCY_KHZ/1000.0f) && (freq_MHz <= BSP_MAX_RF_FREQUENCY_KHZ/1000.0f))
 8020fb2:	eddf 7a41 	vldr	s15, [pc, #260]	; 80210b8 <radar_init+0x154>
  /* Set PLL upper and lower frequencies for FMCW modulation */
  pll_set_upper_lower_frequency(temp_pll_lower_freq_MHz, temp_pll_upper_freq_MHz);
  
#if FW_MODULATION_TYPE == 1U
  
  ds_device_get_settings()->pll_modulation_mode = MODULATION_FMCW;
 8020fb6:	6185      	str	r5, [r0, #24]
//============================================================================
uint16_t radar_set_pll_frequency(Radar_Handle_t device, float freq_MHz)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  if ((freq_MHz >= BSP_MIN_RF_FREQUENCY_KHZ/1000.0f) && (freq_MHz <= BSP_MAX_RF_FREQUENCY_KHZ/1000.0f))
 8020fb8:	eeb4 8ae7 	vcmpe.f32	s16, s15
 8020fbc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020fc0:	db06      	blt.n	8020fd0 <radar_init+0x6c>
 8020fc2:	eddf 7a3e 	vldr	s15, [pc, #248]	; 80210bc <radar_init+0x158>
 8020fc6:	eeb4 8ae7 	vcmpe.f32	s16, s15
 8020fca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020fce:	d954      	bls.n	802107a <radar_init+0x116>
    
    return (RADAR_ERR_OK);
  }
  else
  {
    return (RADAR_ERR_PARAMETER_OUT_OF_RANGE);
 8020fd0:	240c      	movs	r4, #12
#endif
  
  /* BGT, PLL, PGA, USB and DMA Setup */
  /* -------------------------------- */
  
  acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 8020fd2:	f7ff f919 	bl	8020208 <ds_get_active_acq_buf>
  
  bsp_dma_set_destination_addr_from_acq_buf_obj(p_acq_buf, 0);
 8020fd6:	2100      	movs	r1, #0
 8020fd8:	f008 fe6a 	bl	8029cb0 <bsp_dma_set_destination_addr_from_acq_buf_obj>
  
  status |= (uint16_t) bsp_init();
 8020fdc:	f008 fc0e 	bl	80297fc <bsp_init>
 8020fe0:	4605      	mov	r5, r0
  
  /* Load calibration data & Timers setup */
  /* ------------------------------------ */
  radar_init_calibration(device);
 8020fe2:	4630      	mov	r0, r6
 8020fe4:	f7ff fd4e 	bl	8020a84 <radar_init_calibration>
  
  /* Read ADC calibration data */
  status |= radar_read_calibration(device, CALIBRATION_TARGET_FLASH, CALIBRATION_DATA_ADC, &calibration_data_ptr, &num_of_bytes);
 8020fe8:	f10d 070a 	add.w	r7, sp, #10
 8020fec:	2100      	movs	r1, #0
 8020fee:	460a      	mov	r2, r1
 8020ff0:	ab03      	add	r3, sp, #12
 8020ff2:	9700      	str	r7, [sp, #0]
 8020ff4:	4630      	mov	r0, r6
 8020ff6:	f7ff fe15 	bl	8020c24 <radar_read_calibration>
  
  /* Read algorithm calibration data */
  status |= radar_read_calibration(device, CALIBRATION_TARGET_FLASH, CALIBRATION_DATA_ALGO, &calibration_data_ptr, &num_of_bytes);
 8020ffa:	ab03      	add	r3, sp, #12
 8020ffc:	2201      	movs	r2, #1
 8020ffe:	2100      	movs	r1, #0
 8021000:	4304      	orrs	r4, r0
 8021002:	9700      	str	r7, [sp, #0]
 8021004:	4630      	mov	r0, r6
 8021006:	f7ff fe0d 	bl	8020c24 <radar_read_calibration>
 802100a:	b2a4      	uxth	r4, r4
 802100c:	4320      	orrs	r0, r4
 802100e:	ea40 0405 	orr.w	r4, r0, r5
  
  status |= radar_set_sampling_freq(device, ds_device_get_settings()->pll_modulation_mode, ds_device_get_settings()->adc_sampling_freq_Hz);
 8021012:	f7ff f88f 	bl	8020134 <ds_device_get_settings>
 8021016:	6985      	ldr	r5, [r0, #24]
 8021018:	f7ff f88c 	bl	8020134 <ds_device_get_settings>
 802101c:	ed90 8a07 	vldr	s16, [r0, #28]
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  TIMER_STATUS_t status = TIMER_STATUS_FAILURE;
  uint32_t sampling_period_usec = 0;
  
  if (((uint32_t)freq_Hz <= 0) || ((uint32_t)freq_Hz > BSP_MAX_ADC_FREQ_HZ))
 8021020:	4a27      	ldr	r2, [pc, #156]	; (80210c0 <radar_init+0x15c>)
  status |= radar_read_calibration(device, CALIBRATION_TARGET_FLASH, CALIBRATION_DATA_ADC, &calibration_data_ptr, &num_of_bytes);
  
  /* Read algorithm calibration data */
  status |= radar_read_calibration(device, CALIBRATION_TARGET_FLASH, CALIBRATION_DATA_ALGO, &calibration_data_ptr, &num_of_bytes);
  
  status |= radar_set_sampling_freq(device, ds_device_get_settings()->pll_modulation_mode, ds_device_get_settings()->adc_sampling_freq_Hz);
 8021022:	eeb8 8a48 	vcvt.f32.u32	s16, s16
  
  /* Read ADC calibration data */
  status |= radar_read_calibration(device, CALIBRATION_TARGET_FLASH, CALIBRATION_DATA_ADC, &calibration_data_ptr, &num_of_bytes);
  
  /* Read algorithm calibration data */
  status |= radar_read_calibration(device, CALIBRATION_TARGET_FLASH, CALIBRATION_DATA_ALGO, &calibration_data_ptr, &num_of_bytes);
 8021026:	b2a4      	uxth	r4, r4
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  TIMER_STATUS_t status = TIMER_STATUS_FAILURE;
  uint32_t sampling_period_usec = 0;
  
  if (((uint32_t)freq_Hz <= 0) || ((uint32_t)freq_Hz > BSP_MAX_ADC_FREQ_HZ))
 8021028:	eefc 7ac8 	vcvt.u32.f32	s15, s16
 802102c:	ee17 3a90 	vmov	r3, s15
 8021030:	3b01      	subs	r3, #1
 8021032:	4293      	cmp	r3, r2
 8021034:	d906      	bls.n	8021044 <radar_init+0xe0>
  {
    return (RADAR_ERR_BUSY);
 8021036:	2002      	movs	r0, #2
  status |= radar_read_calibration(device, CALIBRATION_TARGET_FLASH, CALIBRATION_DATA_ALGO, &calibration_data_ptr, &num_of_bytes);
  
  status |= radar_set_sampling_freq(device, ds_device_get_settings()->pll_modulation_mode, ds_device_get_settings()->adc_sampling_freq_Hz);
  
  return (status);
}
 8021038:	4320      	orrs	r0, r4
 802103a:	b005      	add	sp, #20
 802103c:	ecbd 8b02 	vpop	{d8}
 8021040:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if (((uint32_t)freq_Hz <= 0) || ((uint32_t)freq_Hz > BSP_MAX_ADC_FREQ_HZ))
  {
    return (RADAR_ERR_BUSY);
  }
  
  bsp_timer_stop_clear(&TIMER_ADC_TRIG);
 8021044:	481f      	ldr	r0, [pc, #124]	; (80210c4 <radar_init+0x160>)
  
  if (modulation_type == MODULATION_FMCW)
 8021046:	b2ed      	uxtb	r5, r5
  if (((uint32_t)freq_Hz <= 0) || ((uint32_t)freq_Hz > BSP_MAX_ADC_FREQ_HZ))
  {
    return (RADAR_ERR_BUSY);
  }
  
  bsp_timer_stop_clear(&TIMER_ADC_TRIG);
 8021048:	f008 fe24 	bl	8029c94 <bsp_timer_stop_clear>
  
  if (modulation_type == MODULATION_FMCW)
 802104c:	2d01      	cmp	r5, #1
 802104e:	d01c      	beq.n	802108a <radar_init+0x126>
  {
    sampling_period_usec = (uint32_t)(((float) ds_device_get_settings()->pll_chirp_time_usec * 100.0f) / (float)ds_device_get_settings()->num_samples_per_chirp);
  }
  else
  {
    sampling_period_usec = (uint32_t)(1000.0f * 1000.0f * 100.0f / freq_Hz);
 8021050:	eddf 7a1d 	vldr	s15, [pc, #116]	; 80210c8 <radar_init+0x164>
 8021054:	ee87 8a88 	vdiv.f32	s16, s15, s16
 8021058:	eebc 8ac8 	vcvt.u32.f32	s16, s16
  }
  
  status = TIMER_SetTimeInterval(&TIMER_ADC_TRIG, sampling_period_usec);
 802105c:	ee18 1a10 	vmov	r1, s16
 8021060:	4818      	ldr	r0, [pc, #96]	; (80210c4 <radar_init+0x160>)
 8021062:	f005 fd59 	bl	8026b18 <TIMER_SetTimeInterval>
  {
    return (RADAR_ERR_OK);
  }
  else
  {
    return (RADAR_ERR_BUSY);
 8021066:	2800      	cmp	r0, #0
 8021068:	bf0c      	ite	eq
 802106a:	2000      	moveq	r0, #0
 802106c:	2002      	movne	r0, #2
  status |= radar_read_calibration(device, CALIBRATION_TARGET_FLASH, CALIBRATION_DATA_ALGO, &calibration_data_ptr, &num_of_bytes);
  
  status |= radar_set_sampling_freq(device, ds_device_get_settings()->pll_modulation_mode, ds_device_get_settings()->adc_sampling_freq_Hz);
  
  return (status);
}
 802106e:	4320      	orrs	r0, r4
 8021070:	b005      	add	sp, #20
 8021072:	ecbd 8b02 	vpop	{d8}
 8021076:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  if ((freq_MHz >= BSP_MIN_RF_FREQUENCY_KHZ/1000.0f) && (freq_MHz <= BSP_MAX_RF_FREQUENCY_KHZ/1000.0f))
  {
    pll_set_frequency(freq_MHz);
 802107a:	4640      	mov	r0, r8
 802107c:	4649      	mov	r1, r9
 802107e:	f009 faab 	bl	802a5d8 <pll_set_frequency>
    pll_set_update_config_flag(true);
 8021082:	4628      	mov	r0, r5
 8021084:	f009 fa98 	bl	802a5b8 <pll_set_update_config_flag>
 8021088:	e7a3      	b.n	8020fd2 <radar_init+0x6e>
  
  bsp_timer_stop_clear(&TIMER_ADC_TRIG);
  
  if (modulation_type == MODULATION_FMCW)
  {
    sampling_period_usec = (uint32_t)(((float) ds_device_get_settings()->pll_chirp_time_usec * 100.0f) / (float)ds_device_get_settings()->num_samples_per_chirp);
 802108a:	f7ff f853 	bl	8020134 <ds_device_get_settings>
 802108e:	edd0 8a00 	vldr	s17, [r0]
 8021092:	ed9f 8a0e 	vldr	s16, [pc, #56]	; 80210cc <radar_init+0x168>
 8021096:	eef8 7a68 	vcvt.f32.u32	s15, s17
 802109a:	ee67 8a88 	vmul.f32	s17, s15, s16
 802109e:	f7ff f849 	bl	8020134 <ds_device_get_settings>
 80210a2:	ed90 8a0b 	vldr	s16, [r0, #44]	; 0x2c
 80210a6:	eeb8 8a48 	vcvt.f32.u32	s16, s16
 80210aa:	ee88 8a88 	vdiv.f32	s16, s17, s16
 80210ae:	eebc 8ac8 	vcvt.u32.f32	s16, s16
 80210b2:	e7d3      	b.n	802105c <radar_init+0xf8>
 80210b4:	447a0000 	.word	0x447a0000
 80210b8:	46bbb200 	.word	0x46bbb200
 80210bc:	46bd4200 	.word	0x46bd4200
 80210c0:	0016e35f 	.word	0x0016e35f
 80210c4:	1ffe8fc4 	.word	0x1ffe8fc4
 80210c8:	4cbebc20 	.word	0x4cbebc20
 80210cc:	42c80000 	.word	0x42c80000

080210d0 <radar_start_acquisition>:
}

//============================================================================

uint16_t radar_start_acquisition(Radar_Handle_t device)
{
 80210d0:	b510      	push	{r4, lr}
 80210d2:	4604      	mov	r4, r0

  uint16_t status = RADAR_ERR_BUSY;
  
  if (ds_device_get_settings()->frame_period_usec > 0)
 80210d4:	f7ff f82e 	bl	8020134 <ds_device_get_settings>
 80210d8:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80210da:	b90b      	cbnz	r3, 80210e0 <radar_start_acquisition+0x10>
  {
    status = radar_set_automatic_frame_trigger(device, ds_device_get_settings()->frame_period_usec);
  }
  
  return (status);
}
 80210dc:	2002      	movs	r0, #2
 80210de:	bd10      	pop	{r4, pc}

  uint16_t status = RADAR_ERR_BUSY;
  
  if (ds_device_get_settings()->frame_period_usec > 0)
  {
    status = radar_set_automatic_frame_trigger(device, ds_device_get_settings()->frame_period_usec);
 80210e0:	f7ff f828 	bl	8020134 <ds_device_get_settings>
 80210e4:	6a81      	ldr	r1, [r0, #40]	; 0x28
 80210e6:	4620      	mov	r0, r4
  }
  
  return (status);
}
 80210e8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  uint16_t status = RADAR_ERR_BUSY;
  
  if (ds_device_get_settings()->frame_period_usec > 0)
  {
    status = radar_set_automatic_frame_trigger(device, ds_device_get_settings()->frame_period_usec);
 80210ec:	f7ff bc80 	b.w	80209f0 <radar_set_automatic_frame_trigger>

080210f0 <radar_set_chirp_time>:
}

//============================================================================

uint16_t radar_set_chirp_time(Radar_Handle_t device, const uint32_t chirp_time_usec)
{
 80210f0:	b510      	push	{r4, lr}
 80210f2:	ed2d 8b02 	vpush	{d8}
 80210f6:	460c      	mov	r4, r1

//============================================================================

static uint16_t radar_check_chirp_time(const uint32_t chirp_time_usec)
{
  if ((ds_device_get_settings()->pll_modulation_mode == MODULATION_FMCW) &&
 80210f8:	f7ff f81c 	bl	8020134 <ds_device_get_settings>
 80210fc:	6983      	ldr	r3, [r0, #24]
 80210fe:	2b01      	cmp	r3, #1
 8021100:	d029      	beq.n	8021156 <radar_set_chirp_time+0x66>
  {
    return retValue;
  }
  
  /* ---- chirp time was verified being o.k. */
  ds_device_get_settings()->pll_chirp_time_usec = chirp_time_usec;
 8021102:	f7ff f817 	bl	8020134 <ds_device_get_settings>
 8021106:	6004      	str	r4, [r0, #0]
  
  /* Set the current PLL chirp-time, in units of usec */
  pll_set_chirp_time(ds_device_get_settings()->pll_chirp_time_usec);
 8021108:	f7ff f814 	bl	8020134 <ds_device_get_settings>
 802110c:	6800      	ldr	r0, [r0, #0]
 802110e:	f009 fad7 	bl	802a6c0 <pll_set_chirp_time>
   
  bsp_timer_stop_clear(&TIMER_ADC_TRIG);
 8021112:	4822      	ldr	r0, [pc, #136]	; (802119c <radar_set_chirp_time+0xac>)
 8021114:	f008 fdbe 	bl	8029c94 <bsp_timer_stop_clear>
  
  uint32_t sampling_period_usec = (uint32_t)(((float)ds_device_get_settings()->pll_chirp_time_usec * 100.0f) / (float)ds_device_get_settings()->num_samples_per_chirp);
 8021118:	f7ff f80c 	bl	8020134 <ds_device_get_settings>
 802111c:	ed90 8a00 	vldr	s16, [r0]
 8021120:	eddf 7a1f 	vldr	s15, [pc, #124]	; 80211a0 <radar_set_chirp_time+0xb0>
 8021124:	eeb8 8a48 	vcvt.f32.u32	s16, s16
 8021128:	ee28 8a27 	vmul.f32	s16, s16, s15
 802112c:	f7ff f802 	bl	8020134 <ds_device_get_settings>
 8021130:	edd0 7a0b 	vldr	s15, [r0, #44]	; 0x2c
  
  if (TIMER_SetTimeInterval(&TIMER_ADC_TRIG, sampling_period_usec) != TIMER_STATUS_SUCCESS)
 8021134:	4819      	ldr	r0, [pc, #100]	; (802119c <radar_set_chirp_time+0xac>)
  /* Set the current PLL chirp-time, in units of usec */
  pll_set_chirp_time(ds_device_get_settings()->pll_chirp_time_usec);
   
  bsp_timer_stop_clear(&TIMER_ADC_TRIG);
  
  uint32_t sampling_period_usec = (uint32_t)(((float)ds_device_get_settings()->pll_chirp_time_usec * 100.0f) / (float)ds_device_get_settings()->num_samples_per_chirp);
 8021136:	eef8 7a67 	vcvt.f32.u32	s15, s15
 802113a:	ee88 8a27 	vdiv.f32	s16, s16, s15
  
  if (TIMER_SetTimeInterval(&TIMER_ADC_TRIG, sampling_period_usec) != TIMER_STATUS_SUCCESS)
 802113e:	eefc 7ac8 	vcvt.u32.f32	s15, s16
 8021142:	ee17 1a90 	vmov	r1, s15
 8021146:	f005 fce7 	bl	8026b18 <TIMER_SetTimeInterval>
 802114a:	4604      	mov	r4, r0
 802114c:	b308      	cbz	r0, 8021192 <radar_set_chirp_time+0xa2>
}

//============================================================================

uint16_t radar_set_chirp_time(Radar_Handle_t device, const uint32_t chirp_time_usec)
{
 802114e:	200c      	movs	r0, #12
  
  /* Update the PLL Configuration */
  pll_set_update_config_flag(true);
  
  return (RADAR_ERR_OK);
}
 8021150:	ecbd 8b02 	vpop	{d8}
 8021154:	bd10      	pop	{r4, pc}

//============================================================================

static uint16_t radar_check_chirp_time(const uint32_t chirp_time_usec)
{
  if ((ds_device_get_settings()->pll_modulation_mode == MODULATION_FMCW) &&
 8021156:	f1a4 0232 	sub.w	r2, r4, #50	; 0x32
 802115a:	f640 3386 	movw	r3, #2950	; 0xb86
 802115e:	429a      	cmp	r2, r3
 8021160:	d8cf      	bhi.n	8021102 <radar_set_chirp_time+0x12>
      (chirp_time_usec >= BSP_MIN_CHIRP_TIME_USEC) && (chirp_time_usec <= BSP_MAX_CHIRP_TIME_USEC))
  {
    if ((chirp_time_usec < 300 && ds_device_get_settings()->num_samples_per_chirp > 256) ||
 8021162:	f5b4 7f96 	cmp.w	r4, #300	; 0x12c
 8021166:	d2cc      	bcs.n	8021102 <radar_set_chirp_time+0x12>
 8021168:	f7fe ffe4 	bl	8020134 <ds_device_get_settings>
 802116c:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 802116e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8021172:	d8ec      	bhi.n	802114e <radar_set_chirp_time+0x5e>
 8021174:	2c95      	cmp	r4, #149	; 0x95
 8021176:	d8c4      	bhi.n	8021102 <radar_set_chirp_time+0x12>
        (chirp_time_usec < 150 && ds_device_get_settings()->num_samples_per_chirp > 128) ||
 8021178:	f7fe ffdc 	bl	8020134 <ds_device_get_settings>
 802117c:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 802117e:	2b80      	cmp	r3, #128	; 0x80
 8021180:	d8e5      	bhi.n	802114e <radar_set_chirp_time+0x5e>
 8021182:	2c4a      	cmp	r4, #74	; 0x4a
 8021184:	d8bd      	bhi.n	8021102 <radar_set_chirp_time+0x12>
        (chirp_time_usec < 75  && ds_device_get_settings()->num_samples_per_chirp > 64))
 8021186:	f7fe ffd5 	bl	8020134 <ds_device_get_settings>
 802118a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 802118c:	2b40      	cmp	r3, #64	; 0x40
 802118e:	d8de      	bhi.n	802114e <radar_set_chirp_time+0x5e>
 8021190:	e7b7      	b.n	8021102 <radar_set_chirp_time+0x12>
  {
    return (RADAR_ERR_PARAMETER_OUT_OF_RANGE);
  }
  
  /* Update the PLL Configuration */
  pll_set_update_config_flag(true);
 8021192:	2001      	movs	r0, #1
 8021194:	f009 fa10 	bl	802a5b8 <pll_set_update_config_flag>
  
  return (RADAR_ERR_OK);
 8021198:	4620      	mov	r0, r4
 802119a:	e7d9      	b.n	8021150 <radar_set_chirp_time+0x60>
 802119c:	1ffe8fc4 	.word	0x1ffe8fc4
 80211a0:	42c80000 	.word	0x42c80000

080211a4 <radar_set_sampling_freq>:
}

//============================================================================

uint16_t radar_set_sampling_freq(Radar_Handle_t device, Modulation_Type_t modulation_type, const float freq_Hz)
{
 80211a4:	ee07 2a90 	vmov	s15, r2
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  TIMER_STATUS_t status = TIMER_STATUS_FAILURE;
  uint32_t sampling_period_usec = 0;
  
  if (((uint32_t)freq_Hz <= 0) || ((uint32_t)freq_Hz > BSP_MAX_ADC_FREQ_HZ))
 80211a8:	eebc 7ae7 	vcvt.u32.f32	s14, s15
}

//============================================================================

uint16_t radar_set_sampling_freq(Radar_Handle_t device, Modulation_Type_t modulation_type, const float freq_Hz)
{
 80211ac:	b538      	push	{r3, r4, r5, lr}
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  TIMER_STATUS_t status = TIMER_STATUS_FAILURE;
  uint32_t sampling_period_usec = 0;
  
  if (((uint32_t)freq_Hz <= 0) || ((uint32_t)freq_Hz > BSP_MAX_ADC_FREQ_HZ))
 80211ae:	ee17 3a10 	vmov	r3, s14
 80211b2:	4a1d      	ldr	r2, [pc, #116]	; (8021228 <radar_set_sampling_freq+0x84>)
 80211b4:	3b01      	subs	r3, #1
 80211b6:	4293      	cmp	r3, r2
}

//============================================================================

uint16_t radar_set_sampling_freq(Radar_Handle_t device, Modulation_Type_t modulation_type, const float freq_Hz)
{
 80211b8:	ed2d 8b02 	vpush	{d8}
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  TIMER_STATUS_t status = TIMER_STATUS_FAILURE;
  uint32_t sampling_period_usec = 0;
  
  if (((uint32_t)freq_Hz <= 0) || ((uint32_t)freq_Hz > BSP_MAX_ADC_FREQ_HZ))
 80211bc:	d903      	bls.n	80211c6 <radar_set_sampling_freq+0x22>
  }
  else
  {
    return (RADAR_ERR_BUSY);
  }
}
 80211be:	ecbd 8b02 	vpop	{d8}
  TIMER_STATUS_t status = TIMER_STATUS_FAILURE;
  uint32_t sampling_period_usec = 0;
  
  if (((uint32_t)freq_Hz <= 0) || ((uint32_t)freq_Hz > BSP_MAX_ADC_FREQ_HZ))
  {
    return (RADAR_ERR_BUSY);
 80211c2:	2002      	movs	r0, #2
  }
  else
  {
    return (RADAR_ERR_BUSY);
  }
}
 80211c4:	bd38      	pop	{r3, r4, r5, pc}
 80211c6:	460d      	mov	r5, r1
  if (((uint32_t)freq_Hz <= 0) || ((uint32_t)freq_Hz > BSP_MAX_ADC_FREQ_HZ))
  {
    return (RADAR_ERR_BUSY);
  }
  
  bsp_timer_stop_clear(&TIMER_ADC_TRIG);
 80211c8:	4818      	ldr	r0, [pc, #96]	; (802122c <radar_set_sampling_freq+0x88>)
 80211ca:	ee17 4a90 	vmov	r4, s15
 80211ce:	f008 fd61 	bl	8029c94 <bsp_timer_stop_clear>
  
  if (modulation_type == MODULATION_FMCW)
 80211d2:	2d01      	cmp	r5, #1
 80211d4:	d013      	beq.n	80211fe <radar_set_sampling_freq+0x5a>
  {
    sampling_period_usec = (uint32_t)(((float) ds_device_get_settings()->pll_chirp_time_usec * 100.0f) / (float)ds_device_get_settings()->num_samples_per_chirp);
  }
  else
  {
    sampling_period_usec = (uint32_t)(1000.0f * 1000.0f * 100.0f / freq_Hz);
 80211d6:	eddf 7a16 	vldr	s15, [pc, #88]	; 8021230 <radar_set_sampling_freq+0x8c>
 80211da:	ee07 4a10 	vmov	s14, r4
 80211de:	eec7 7a87 	vdiv.f32	s15, s15, s14
 80211e2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
  }
  
  status = TIMER_SetTimeInterval(&TIMER_ADC_TRIG, sampling_period_usec);
 80211e6:	4811      	ldr	r0, [pc, #68]	; (802122c <radar_set_sampling_freq+0x88>)
 80211e8:	ee17 1a90 	vmov	r1, s15
 80211ec:	f005 fc94 	bl	8026b18 <TIMER_SetTimeInterval>
  }
  else
  {
    return (RADAR_ERR_BUSY);
  }
}
 80211f0:	ecbd 8b02 	vpop	{d8}
    sampling_period_usec = (uint32_t)(1000.0f * 1000.0f * 100.0f / freq_Hz);
  }
  
  status = TIMER_SetTimeInterval(&TIMER_ADC_TRIG, sampling_period_usec);
  
  if (status == TIMER_STATUS_SUCCESS)
 80211f4:	2800      	cmp	r0, #0
  {
    return (RADAR_ERR_OK);
  }
  else
  {
    return (RADAR_ERR_BUSY);
 80211f6:	bf0c      	ite	eq
 80211f8:	2000      	moveq	r0, #0
 80211fa:	2002      	movne	r0, #2
  }
}
 80211fc:	bd38      	pop	{r3, r4, r5, pc}
  
  bsp_timer_stop_clear(&TIMER_ADC_TRIG);
  
  if (modulation_type == MODULATION_FMCW)
  {
    sampling_period_usec = (uint32_t)(((float) ds_device_get_settings()->pll_chirp_time_usec * 100.0f) / (float)ds_device_get_settings()->num_samples_per_chirp);
 80211fe:	f7fe ff99 	bl	8020134 <ds_device_get_settings>
 8021202:	ed90 8a00 	vldr	s16, [r0]
 8021206:	ed9f 7a0b 	vldr	s14, [pc, #44]	; 8021234 <radar_set_sampling_freq+0x90>
 802120a:	eef8 7a48 	vcvt.f32.u32	s15, s16
 802120e:	ee27 8a87 	vmul.f32	s16, s15, s14
 8021212:	f7fe ff8f 	bl	8020134 <ds_device_get_settings>
 8021216:	edd0 7a0b 	vldr	s15, [r0, #44]	; 0x2c
 802121a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 802121e:	eec8 7a27 	vdiv.f32	s15, s16, s15
 8021222:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8021226:	e7de      	b.n	80211e6 <radar_set_sampling_freq+0x42>
 8021228:	0016e35f 	.word	0x0016e35f
 802122c:	1ffe8fc4 	.word	0x1ffe8fc4
 8021230:	4cbebc20 	.word	0x4cbebc20
 8021234:	42c80000 	.word	0x42c80000

08021238 <radar_register_callback>:
uint16_t radar_register_callback(Radar_Callback_ID_t cb_id, void (*pcallback)(void *parameter))
{
  uint16_t status = RADAR_ERR_OK;
  
  /* Check if the callback function is valid */
  if(pcallback == NULL)
 8021238:	b151      	cbz	r1, 8021250 <radar_register_callback+0x18>
  {
    return(RADAR_ERR_BUSY);
  }
  
  /* Register user callback function based on callback ID */
  switch (cb_id)
 802123a:	2801      	cmp	r0, #1
}

//============================================================================

uint16_t radar_register_callback(Radar_Callback_ID_t cb_id, void (*pcallback)(void *parameter))
{
 802123c:	b508      	push	{r3, lr}
  {
    return(RADAR_ERR_BUSY);
  }
  
  /* Register user callback function based on callback ID */
  switch (cb_id)
 802123e:	d003      	beq.n	8021248 <radar_register_callback+0x10>
 8021240:	2802      	cmp	r0, #2
 8021242:	d001      	beq.n	8021248 <radar_register_callback+0x10>
    bsp_register_callback(BSP_ACQUISITION_DONE_CB_ID, pcallback);
    break;
    
  default:
    /* Return error status */
    status =  RADAR_ERR_BUSY;
 8021244:	2002      	movs	r0, #2
    break;
  }
  
  return (status);
}
 8021246:	bd08      	pop	{r3, pc}
    bsp_register_callback(BSP_ACQUISITION_STARTED_CB_ID, pcallback);
    break;
    
  case RADAR_ACQUISITION_DONE_CB_ID:
    /* Callback executed by BSP layer at the end of data acquisition process */
    bsp_register_callback(BSP_ACQUISITION_DONE_CB_ID, pcallback);
 8021248:	f008 ffdc 	bl	802a204 <bsp_register_callback>

//============================================================================

uint16_t radar_register_callback(Radar_Callback_ID_t cb_id, void (*pcallback)(void *parameter))
{
  uint16_t status = RADAR_ERR_OK;
 802124c:	2000      	movs	r0, #0
    break;
    
  case RADAR_ACQUISITION_DONE_CB_ID:
    /* Callback executed by BSP layer at the end of data acquisition process */
    bsp_register_callback(BSP_ACQUISITION_DONE_CB_ID, pcallback);
    break;
 802124e:	bd08      	pop	{r3, pc}
  uint16_t status = RADAR_ERR_OK;
  
  /* Check if the callback function is valid */
  if(pcallback == NULL)
  {
    return(RADAR_ERR_BUSY);
 8021250:	2002      	movs	r0, #2
    status =  RADAR_ERR_BUSY;
    break;
  }
  
  return (status);
}
 8021252:	4770      	bx	lr

08021254 <radar_apply_hw_settings>:
}

//============================================================================

uint32_t radar_apply_hw_settings(Radar_Handle_t device, hw_state_setting_t state, device_settings_t *p_hw_settings)
{
 8021254:	b510      	push	{r4, lr}
 8021256:	4614      	mov	r4, r2
  uint32_t retValue = RADAR_ERR_OK;
  
  switch(state)
 8021258:	2905      	cmp	r1, #5
 802125a:	d80e      	bhi.n	802127a <radar_apply_hw_settings+0x26>
 802125c:	e8df f001 	tbb	[pc, r1]
 8021260:	1b0d0d16 	.word	0x1b0d0d16
 8021264:	030f      	.short	0x030f
    }
    break;
    
  case START_MANUAL_ACQ:
    {
      acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 8021266:	f7fe ffcf 	bl	8020208 <ds_get_active_acq_buf>
      
      bsp_dma_set_destination_addr_from_acq_buf_obj(p_acq_buf, 0);
 802126a:	2100      	movs	r1, #0
 802126c:	f008 fd20 	bl	8029cb0 <bsp_dma_set_destination_addr_from_acq_buf_obj>
      
      bsp_reset_frame_counter();
 8021270:	f008 ffbc 	bl	802a1ec <bsp_reset_frame_counter>
      
      g_adc_sampling_completed = false;
 8021274:	4b0a      	ldr	r3, [pc, #40]	; (80212a0 <radar_apply_hw_settings+0x4c>)
 8021276:	2200      	movs	r2, #0
 8021278:	601a      	str	r2, [r3, #0]
  default:
    break;
  }
  
  return retValue;
}
 802127a:	2000      	movs	r0, #0
 802127c:	bd10      	pop	{r4, pc}
  case POWER_DOWN:
    bgt_stop_tx();
    break;
    
  case UPDATE:
    if(ds_is_device_settings_updated())
 802127e:	f7fe ff61 	bl	8020144 <ds_is_device_settings_updated>
 8021282:	2800      	cmp	r0, #0
 8021284:	d0f9      	beq.n	802127a <radar_apply_hw_settings+0x26>
    {
      /* stop the timer for ADC acquisition, while updating the values! */
      bsp_timer_stop_clear(&TIMER_ADC_TRIG);
 8021286:	4807      	ldr	r0, [pc, #28]	; (80212a4 <radar_apply_hw_settings+0x50>)
 8021288:	f008 fd04 	bl	8029c94 <bsp_timer_stop_clear>
      
      retValue = radar_apply_new_hw_setting(device, p_hw_settings);
 802128c:	4620      	mov	r0, r4
  default:
    break;
  }
  
  return retValue;
}
 802128e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    if(ds_is_device_settings_updated())
    {
      /* stop the timer for ADC acquisition, while updating the values! */
      bsp_timer_stop_clear(&TIMER_ADC_TRIG);
      
      retValue = radar_apply_new_hw_setting(device, p_hw_settings);
 8021292:	f7ff bd63 	b.w	8020d5c <radar_apply_new_hw_setting.isra.1>
    
  case LEAVE_POWERSAVING:
    break;
    
  case POWER_DOWN:
    bgt_stop_tx();
 8021296:	f008 fa63 	bl	8029760 <bgt_stop_tx>
  default:
    break;
  }
  
  return retValue;
}
 802129a:	2000      	movs	r0, #0
 802129c:	bd10      	pop	{r4, pc}
 802129e:	bf00      	nop
 80212a0:	1ffe97c4 	.word	0x1ffe97c4
 80212a4:	1ffe8fc4 	.word	0x1ffe8fc4

080212a8 <radar_get_data_acq_mode>:

//============================================================================

Radar_Data_Acq_Mode_t radar_get_data_acq_mode(void)
{
  return s_data_acq_mode;
 80212a8:	4b01      	ldr	r3, [pc, #4]	; (80212b0 <radar_get_data_acq_mode+0x8>)
}
 80212aa:	7818      	ldrb	r0, [r3, #0]
 80212ac:	4770      	bx	lr
 80212ae:	bf00      	nop
 80212b0:	1ffe97c0 	.word	0x1ffe97c0

080212b4 <radar_set_data_acq_mode>:

//============================================================================

void radar_set_data_acq_mode(Radar_Data_Acq_Mode_t new_mode)
{
  s_data_acq_mode = new_mode;
 80212b4:	4b01      	ldr	r3, [pc, #4]	; (80212bc <radar_set_data_acq_mode+0x8>)
 80212b6:	7018      	strb	r0, [r3, #0]
 80212b8:	4770      	bx	lr
 80212ba:	bf00      	nop
 80212bc:	1ffe97c0 	.word	0x1ffe97c0

080212c0 <radar_set_doppler_configuration>:
   2. EXPORTED FUNCTIONS
==============================================================================
 */

uint16_t radar_set_doppler_configuration(Radar_Handle_t device, const Doppler_Configuration_t* const configuration)
{
 80212c0:	b538      	push	{r3, r4, r5, lr}
 80212c2:	460d      	mov	r5, r1
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  /* Configuration change is only allowed while automatic trigger is not working */
  if (radar_get_data_acq_mode() != RADAR_MANUAL_TRIGGER)
 80212c4:	f7ff fff0 	bl	80212a8 <radar_get_data_acq_mode>
 80212c8:	4604      	mov	r4, r0
 80212ca:	b108      	cbz	r0, 80212d0 <radar_set_doppler_configuration+0x10>
  {
    return (RADAR_ERR_BUSY);
 80212cc:	2002      	movs	r0, #2
 80212ce:	bd38      	pop	{r3, r4, r5, pc}
  }
  
  /* Check if configuration is valid */
  /* ------------------------------- */
  if((configuration->frequency_kHz < BSP_MIN_RF_FREQUENCY_KHZ) ||
 80212d0:	6829      	ldr	r1, [r5, #0]
 80212d2:	4b08      	ldr	r3, [pc, #32]	; (80212f4 <radar_set_doppler_configuration+0x34>)
 80212d4:	4a08      	ldr	r2, [pc, #32]	; (80212f8 <radar_set_doppler_configuration+0x38>)
 80212d6:	440b      	add	r3, r1
 80212d8:	4293      	cmp	r3, r2
 80212da:	d901      	bls.n	80212e0 <radar_set_doppler_configuration+0x20>
     (configuration->frequency_kHz > BSP_MAX_RF_FREQUENCY_KHZ))
  {
    return (RADAR_ERR_FREQUENCY_OUT_OF_RANGE);
 80212dc:	2009      	movs	r0, #9
 80212de:	bd38      	pop	{r3, r4, r5, pc}
  }
  
  if (configuration->tx_power > BSP_MAX_TX_POWER_LEVEL)
 80212e0:	792b      	ldrb	r3, [r5, #4]
 80212e2:	2b07      	cmp	r3, #7
 80212e4:	d901      	bls.n	80212ea <radar_set_doppler_configuration+0x2a>
  {
    return (RADAR_ERR_POWER_OUT_OF_RANGE);
 80212e6:	200a      	movs	r0, #10
  
  /* Copy the new Doppler configuration to the data store*/
  ds_ep_store_doppler_config(configuration);
  
  return (RADAR_ERR_OK);
}
 80212e8:	bd38      	pop	{r3, r4, r5, pc}
  {
    return (RADAR_ERR_POWER_OUT_OF_RANGE);
  }
  
  /* Copy the new Doppler configuration to the data store*/
  ds_ep_store_doppler_config(configuration);
 80212ea:	4628      	mov	r0, r5
 80212ec:	f7fe ffda 	bl	80202a4 <ds_ep_store_doppler_config>
  
  return (RADAR_ERR_OK);
 80212f0:	4620      	mov	r0, r4
 80212f2:	bd38      	pop	{r3, r4, r5, pc}
 80212f4:	fe916858 	.word	0xfe916858
 80212f8:	00030d40 	.word	0x00030d40

080212fc <radar_get_doppler_configuration>:
}

//============================================================================

uint16_t radar_get_doppler_configuration(Radar_Handle_t device, Doppler_Configuration_t* configuration)
{
 80212fc:	b508      	push	{r3, lr}
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  /* Get the current Doppler configuration from data store */
  ds_ep_fetch_doppler_config(configuration);
 80212fe:	4608      	mov	r0, r1
 8021300:	f7fe ffc2 	bl	8020288 <ds_ep_fetch_doppler_config>
  return (RADAR_ERR_OK);
}
 8021304:	2000      	movs	r0, #0
 8021306:	bd08      	pop	{r3, pc}

08021308 <radar_set_fmcw_configuration>:
==============================================================================
 */

uint16_t radar_set_fmcw_configuration(Radar_Handle_t device, 
                                      const Fmcw_Configuration_t* configuration)
{
 8021308:	b538      	push	{r3, r4, r5, lr}
 802130a:	460d      	mov	r5, r1
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  float tmp_bandwidth_mhz;
  
  /* Configuration change is only allowed while automatic trigger is not working */
  if (radar_get_data_acq_mode() != RADAR_MANUAL_TRIGGER)
 802130c:	f7ff ffcc 	bl	80212a8 <radar_get_data_acq_mode>
 8021310:	b108      	cbz	r0, 8021316 <radar_set_fmcw_configuration+0xe>
  {
    return (RADAR_ERR_BUSY);
 8021312:	2002      	movs	r0, #2
 8021314:	bd38      	pop	{r3, r4, r5, pc}
  }
  
  /* Check if configuration is valid */
  /* ------------------------------- */
  if ((configuration->lower_frequency_kHz < BSP_MIN_RF_FREQUENCY_KHZ) ||
 8021316:	6829      	ldr	r1, [r5, #0]
 8021318:	4b19      	ldr	r3, [pc, #100]	; (8021380 <radar_set_fmcw_configuration+0x78>)
 802131a:	4a1a      	ldr	r2, [pc, #104]	; (8021384 <radar_set_fmcw_configuration+0x7c>)
 802131c:	440b      	add	r3, r1
 802131e:	4293      	cmp	r3, r2
 8021320:	d901      	bls.n	8021326 <radar_set_fmcw_configuration+0x1e>
      (configuration->lower_frequency_kHz > BSP_MAX_RF_FREQUENCY_KHZ) ||
        (configuration->upper_frequency_kHz < BSP_MIN_RF_FREQUENCY_KHZ) ||
          (configuration->upper_frequency_kHz > BSP_MAX_RF_FREQUENCY_KHZ) ||
            (configuration->lower_frequency_kHz > configuration->upper_frequency_kHz))
  {
    return (RADAR_ERR_FREQUENCY_OUT_OF_RANGE);
 8021322:	2009      	movs	r0, #9
 8021324:	bd38      	pop	{r3, r4, r5, pc}
  
  /* Check if configuration is valid */
  /* ------------------------------- */
  if ((configuration->lower_frequency_kHz < BSP_MIN_RF_FREQUENCY_KHZ) ||
      (configuration->lower_frequency_kHz > BSP_MAX_RF_FREQUENCY_KHZ) ||
        (configuration->upper_frequency_kHz < BSP_MIN_RF_FREQUENCY_KHZ) ||
 8021326:	6868      	ldr	r0, [r5, #4]
  }
  
  /* Check if configuration is valid */
  /* ------------------------------- */
  if ((configuration->lower_frequency_kHz < BSP_MIN_RF_FREQUENCY_KHZ) ||
      (configuration->lower_frequency_kHz > BSP_MAX_RF_FREQUENCY_KHZ) ||
 8021328:	4b15      	ldr	r3, [pc, #84]	; (8021380 <radar_set_fmcw_configuration+0x78>)
 802132a:	4403      	add	r3, r0
 802132c:	4293      	cmp	r3, r2
 802132e:	d8f8      	bhi.n	8021322 <radar_set_fmcw_configuration+0x1a>
        (configuration->upper_frequency_kHz < BSP_MIN_RF_FREQUENCY_KHZ) ||
          (configuration->upper_frequency_kHz > BSP_MAX_RF_FREQUENCY_KHZ) ||
 8021330:	4281      	cmp	r1, r0
 8021332:	d8f6      	bhi.n	8021322 <radar_set_fmcw_configuration+0x1a>
            (configuration->lower_frequency_kHz > configuration->upper_frequency_kHz))
  {
    return (RADAR_ERR_FREQUENCY_OUT_OF_RANGE);
  }
  
  tmp_bandwidth_mhz = ((float)(configuration->upper_frequency_kHz - configuration->lower_frequency_kHz)) / 1000.0f;
 8021334:	1a43      	subs	r3, r0, r1
 8021336:	ee07 3a90 	vmov	s15, r3
 802133a:	ed9f 7a13 	vldr	s14, [pc, #76]	; 8021388 <radar_set_fmcw_configuration+0x80>
 802133e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8021342:	eec7 7a87 	vdiv.f32	s15, s15, s14
  
  if ((tmp_bandwidth_mhz < BSP_MIN_BANDWIDTH_MHZ) || (tmp_bandwidth_mhz > BSP_MAX_BANDWIDTH_MHZ))
 8021346:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 802134a:	eef4 7ac7 	vcmpe.f32	s15, s14
 802134e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021352:	d4e6      	bmi.n	8021322 <radar_set_fmcw_configuration+0x1a>
 8021354:	ed9f 7a0d 	vldr	s14, [pc, #52]	; 802138c <radar_set_fmcw_configuration+0x84>
 8021358:	eef4 7ac7 	vcmpe.f32	s15, s14
 802135c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021360:	dcdf      	bgt.n	8021322 <radar_set_fmcw_configuration+0x1a>
  {
    return (RADAR_ERR_FREQUENCY_OUT_OF_RANGE);
  }
  
  if (configuration->direction != RADAR_DIR_UPCHIRP_ONLY)
 8021362:	7a2c      	ldrb	r4, [r5, #8]
 8021364:	b10c      	cbz	r4, 802136a <radar_set_fmcw_configuration+0x62>
  {
    return (RADAR_ERR_UNSUPPORTED_DIRECTION);
 8021366:	2020      	movs	r0, #32
 8021368:	bd38      	pop	{r3, r4, r5, pc}
  }
  
  if (configuration->tx_power > BSP_MAX_TX_POWER_LEVEL)
 802136a:	7a6b      	ldrb	r3, [r5, #9]
 802136c:	2b07      	cmp	r3, #7
 802136e:	d901      	bls.n	8021374 <radar_set_fmcw_configuration+0x6c>
  {
    return (RADAR_ERR_POWER_OUT_OF_RANGE);
 8021370:	200a      	movs	r0, #10
  }
  
  ds_ep_store_fmcw_config(configuration);
  
  return (RADAR_ERR_OK);
}
 8021372:	bd38      	pop	{r3, r4, r5, pc}
  if (configuration->tx_power > BSP_MAX_TX_POWER_LEVEL)
  {
    return (RADAR_ERR_POWER_OUT_OF_RANGE);
  }
  
  ds_ep_store_fmcw_config(configuration);
 8021374:	4628      	mov	r0, r5
 8021376:	f7fe ffcb 	bl	8020310 <ds_ep_store_fmcw_config>
  
  return (RADAR_ERR_OK);
 802137a:	4620      	mov	r0, r4
 802137c:	bd38      	pop	{r3, r4, r5, pc}
 802137e:	bf00      	nop
 8021380:	fe916858 	.word	0xfe916858
 8021384:	00030d40 	.word	0x00030d40
 8021388:	447a0000 	.word	0x447a0000
 802138c:	43480000 	.word	0x43480000

08021390 <radar_get_fmcw_configuration>:

//============================================================================

uint16_t radar_get_fmcw_configuration(Radar_Handle_t device, 
                                      Fmcw_Configuration_t* configuration)
{
 8021390:	b508      	push	{r3, lr}
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  /* Get the current FMCW configuration from data store */
  ds_ep_fetch_fmcw_config(configuration);
 8021392:	4608      	mov	r0, r1
 8021394:	f7fe ff9a 	bl	80202cc <ds_ep_fetch_fmcw_config>
  return (RADAR_ERR_OK);
}
 8021398:	2000      	movs	r0, #0
 802139a:	bd08      	pop	{r3, pc}

0802139c <radar_get_bandwidth_per_second>:

//============================================================================

uint16_t radar_get_bandwidth_per_second(Radar_Handle_t device, 
                                        uint32_t* bandwidth_per_second_MHz_s)
{
 802139c:	b570      	push	{r4, r5, r6, lr}
 802139e:	ed2d 8b02 	vpush	{d8}
 80213a2:	b084      	sub	sp, #16
  uint32_t remainder;
  uint32_t divisor;
  Frame_Format_t frame_format;
  
  /* Get the current FMCW configuration from data store */
  ds_ep_fetch_frame_format(&frame_format);
 80213a4:	a801      	add	r0, sp, #4

//============================================================================

uint16_t radar_get_bandwidth_per_second(Radar_Handle_t device, 
                                        uint32_t* bandwidth_per_second_MHz_s)
{
 80213a6:	460e      	mov	r6, r1
  uint32_t remainder;
  uint32_t divisor;
  Frame_Format_t frame_format;
  
  /* Get the current FMCW configuration from data store */
  ds_ep_fetch_frame_format(&frame_format);
 80213a8:	f7fe ffd6 	bl	8020358 <ds_ep_fetch_frame_format>
  /* Unit is MHz/s. */
  /*
  * Actual calculation "uBandwidthPerSecond = (uUpperFMCWFrequency - uLowerFMCWFrequency) * 1000000 / chirp_duration"
  * is split up to avoid overflow of 32 bit words
  */
  remainder = (uint32_t)((ds_device_get_settings()->pll_upper_frequency_kHz - ds_device_get_settings()->pll_lower_frequency_kHz) *
 80213ac:	f7fe fec2 	bl	8020134 <ds_device_get_settings>
 80213b0:	ed90 8a03 	vldr	s16, [r0, #12]
 80213b4:	f7fe febe 	bl	8020134 <ds_device_get_settings>
 80213b8:	ed90 7a02 	vldr	s14, [r0, #8]
 80213bc:	eddf 7a12 	vldr	s15, [pc, #72]	; 8021408 <radar_get_bandwidth_per_second+0x6c>
 80213c0:	ee38 8a47 	vsub.f32	s16, s16, s14
  
  remainder -= *bandwidth_per_second_MHz_s * divisor;
  
  *bandwidth_per_second_MHz_s *= 1000;
  
  *bandwidth_per_second_MHz_s += (remainder * 1000) / divisor;
 80213c4:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
  /* Unit is MHz/s. */
  /*
  * Actual calculation "uBandwidthPerSecond = (uUpperFMCWFrequency - uLowerFMCWFrequency) * 1000000 / chirp_duration"
  * is split up to avoid overflow of 32 bit words
  */
  remainder = (uint32_t)((ds_device_get_settings()->pll_upper_frequency_kHz - ds_device_get_settings()->pll_lower_frequency_kHz) *
 80213c8:	ee28 8a27 	vmul.f32	s16, s16, s15
 80213cc:	eefc 7ac8 	vcvt.u32.f32	s15, s16
 80213d0:	ee17 4a90 	vmov	r4, s15
              (BSP_REFERENCE_OSC_FREQ_HZ / 1000000));
  
  uint32_t sample_rate_divider = BSP_REFERENCE_OSC_FREQ_HZ / ds_device_get_settings()->adc_sampling_freq_Hz;
 80213d4:	f7fe feae 	bl	8020134 <ds_device_get_settings>
  
  divisor = frame_format.num_samples_per_chirp * sample_rate_divider;
 80213d8:	9b01      	ldr	r3, [sp, #4]
  * is split up to avoid overflow of 32 bit words
  */
  remainder = (uint32_t)((ds_device_get_settings()->pll_upper_frequency_kHz - ds_device_get_settings()->pll_lower_frequency_kHz) *
              (BSP_REFERENCE_OSC_FREQ_HZ / 1000000));
  
  uint32_t sample_rate_divider = BSP_REFERENCE_OSC_FREQ_HZ / ds_device_get_settings()->adc_sampling_freq_Hz;
 80213da:	69c1      	ldr	r1, [r0, #28]
 80213dc:	4a0b      	ldr	r2, [pc, #44]	; (802140c <radar_get_bandwidth_per_second+0x70>)
 80213de:	fbb2 f2f1 	udiv	r2, r2, r1
  
  divisor = frame_format.num_samples_per_chirp * sample_rate_divider;
 80213e2:	fb03 f202 	mul.w	r2, r3, r2
  
  *bandwidth_per_second_MHz_s = remainder / divisor;
 80213e6:	fbb4 f0f2 	udiv	r0, r4, r2
  
  remainder -= *bandwidth_per_second_MHz_s * divisor;
 80213ea:	fb02 4310 	mls	r3, r2, r0, r4
  
  *bandwidth_per_second_MHz_s *= 1000;
  
  *bandwidth_per_second_MHz_s += (remainder * 1000) / divisor;
 80213ee:	fb05 f303 	mul.w	r3, r5, r3
 80213f2:	fbb3 f4f2 	udiv	r4, r3, r2
 80213f6:	fb05 4400 	mla	r4, r5, r0, r4
  
  return (RADAR_ERR_OK);
}
 80213fa:	2000      	movs	r0, #0
  
  remainder -= *bandwidth_per_second_MHz_s * divisor;
  
  *bandwidth_per_second_MHz_s *= 1000;
  
  *bandwidth_per_second_MHz_s += (remainder * 1000) / divisor;
 80213fc:	6034      	str	r4, [r6, #0]
  
  return (RADAR_ERR_OK);
}
 80213fe:	b004      	add	sp, #16
 8021400:	ecbd 8b02 	vpop	{d8}
 8021404:	bd70      	pop	{r4, r5, r6, pc}
 8021406:	bf00      	nop
 8021408:	42200000 	.word	0x42200000
 802140c:	02625a00 	.word	0x02625a00

08021410 <radar_set_duty_cycle>:
   2. EXPORTED FUNCTIONS
==============================================================================
 */

uint16_t radar_set_duty_cycle(Radar_Handle_t device, const uint8_t flag)
{
 8021410:	b510      	push	{r4, lr}
 8021412:	460c      	mov	r4, r1
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  if (flag != ds_device_get_settings()->power_duty_cycle_enable_flag)
 8021414:	f7fe fe8e 	bl	8020134 <ds_device_get_settings>
 8021418:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
 802141c:	42a3      	cmp	r3, r4
 802141e:	d007      	beq.n	8021430 <radar_set_duty_cycle+0x20>
  {
    ds_device_get_settings()->is_duty_cycle_enable_updated = 1;
 8021420:	f7fe fe88 	bl	8020134 <ds_device_get_settings>
 8021424:	2301      	movs	r3, #1
 8021426:	6383      	str	r3, [r0, #56]	; 0x38
    ds_device_get_settings()->power_duty_cycle_enable_flag = flag;
 8021428:	f7fe fe84 	bl	8020134 <ds_device_get_settings>
 802142c:	f880 4024 	strb.w	r4, [r0, #36]	; 0x24
  }
  
  return (RADAR_ERR_OK);
}
 8021430:	2000      	movs	r0, #0
 8021432:	bd10      	pop	{r4, pc}

08021434 <radar_get_duty_cycle>:

//============================================================================

void radar_get_duty_cycle(Radar_Handle_t device, uint8_t* flag)
{
 8021434:	b510      	push	{r4, lr}
 8021436:	460c      	mov	r4, r1
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  *flag = ds_device_get_settings()->power_duty_cycle_enable_flag;
 8021438:	f7fe fe7c 	bl	8020134 <ds_device_get_settings>
 802143c:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
 8021440:	7023      	strb	r3, [r4, #0]
 8021442:	bd10      	pop	{r4, pc}

08021444 <radar_disable_lna_gain>:
}

//============================================================================

void radar_disable_lna_gain(Radar_Handle_t device)
{
 8021444:	b508      	push	{r3, lr}
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  ds_device_get_settings()->bgt_rx_lna_gain_enable_flag = false;
 8021446:	f7fe fe75 	bl	8020134 <ds_device_get_settings>
 802144a:	2300      	movs	r3, #0
 802144c:	f880 3026 	strb.w	r3, [r0, #38]	; 0x26
 8021450:	bd08      	pop	{r3, pc}
 8021452:	bf00      	nop

08021454 <radar_enable_lna_gain>:
}

//============================================================================

void radar_enable_lna_gain(Radar_Handle_t device)
{
 8021454:	b508      	push	{r3, lr}
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  ds_device_get_settings()->bgt_rx_lna_gain_enable_flag = true;
 8021456:	f7fe fe6d 	bl	8020134 <ds_device_get_settings>
 802145a:	2301      	movs	r3, #1
 802145c:	f880 3026 	strb.w	r3, [r0, #38]	; 0x26
 8021460:	bd08      	pop	{r3, pc}
 8021462:	bf00      	nop

08021464 <radar_get_lna_gain_enable_status>:
}

//============================================================================

uint8_t radar_get_lna_gain_enable_status(Radar_Handle_t device)
{
 8021464:	b508      	push	{r3, lr}
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  return (ds_device_get_settings()->bgt_rx_lna_gain_enable_flag);
 8021466:	f7fe fe65 	bl	8020134 <ds_device_get_settings>
}
 802146a:	f890 0026 	ldrb.w	r0, [r0, #38]	; 0x26
 802146e:	bd08      	pop	{r3, pc}

08021470 <radar_set_gain_level>:

uint16_t radar_set_gain_level(Radar_Handle_t device, uint16_t gain_level)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  if (gain_level > MAX_PGA_GAIN_LEVEL)
 8021470:	2907      	cmp	r1, #7
 8021472:	d901      	bls.n	8021478 <radar_set_gain_level+0x8>
  {
    return (RADAR_ERR_UNSUPPORTED_PGA_GAIN);
 8021474:	2052      	movs	r0, #82	; 0x52
 8021476:	4770      	bx	lr
   2. EXPORTED FUNCTIONS
==============================================================================
 */

uint16_t radar_set_gain_level(Radar_Handle_t device, uint16_t gain_level)
{
 8021478:	b500      	push	{lr}
 802147a:	b083      	sub	sp, #12
 802147c:	9101      	str	r1, [sp, #4]
  {
    return (RADAR_ERR_UNSUPPORTED_PGA_GAIN);
  }
  
  /* Update the PGA Gain level */
  ds_device_get_settings()->pga_rx_gain_level = gain_level;
 802147e:	f7fe fe59 	bl	8020134 <ds_device_get_settings>
 8021482:	9901      	ldr	r1, [sp, #4]
 8021484:	8441      	strh	r1, [r0, #34]	; 0x22
  ds_device_get_settings()->isGainlevelUpdated = 1;
 8021486:	f7fe fe55 	bl	8020134 <ds_device_get_settings>
 802148a:	2301      	movs	r3, #1
 802148c:	6343      	str	r3, [r0, #52]	; 0x34
  
  return (RADAR_ERR_OK);
 802148e:	2000      	movs	r0, #0
}
 8021490:	b003      	add	sp, #12
 8021492:	f85d fb04 	ldr.w	pc, [sp], #4
 8021496:	bf00      	nop

08021498 <radar_get_gain_level>:

//============================================================================

uint16_t radar_get_gain_level(Radar_Handle_t device, uint16_t* gain_level)
{
 8021498:	b510      	push	{r4, lr}
 802149a:	460c      	mov	r4, r1
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  
  /* Get current PGA Gain level from driver */
  *gain_level = ds_device_get_settings()->pga_rx_gain_level;
 802149c:	f7fe fe4a 	bl	8020134 <ds_device_get_settings>
 80214a0:	8c43      	ldrh	r3, [r0, #34]	; 0x22
 80214a2:	8023      	strh	r3, [r4, #0]
  
  return (RADAR_ERR_OK);
}
 80214a4:	2000      	movs	r0, #0
 80214a6:	bd10      	pop	{r4, pc}

080214a8 <radar_set_dsp_settings>:
   2. EXPORTED FUNCTIONS
==============================================================================
 */

uint16_t radar_set_dsp_settings(Radar_Handle_t device, const DSP_Settings_t* configuration)
{
 80214a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80214ac:	b094      	sub	sp, #80	; 0x50
 80214ae:	460c      	mov	r4, r1
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  algo_settings_t new_settings;
  memset(&new_settings, 0, sizeof(algo_settings_t));
 80214b0:	224c      	movs	r2, #76	; 0x4c
 80214b2:	2100      	movs	r1, #0
 80214b4:	a801      	add	r0, sp, #4
 80214b6:	f00d fb82 	bl	802ebbe <memset>
  
  /* Fetch the complete existing data, to update only partially the new data. */
  ds_algo_fetch_settings(&new_settings);
 80214ba:	a801      	add	r0, sp, #4
 80214bc:	f7fe fdd8 	bl	8020070 <ds_algo_fetch_settings>
  
#ifdef FMCW_SUPPORTED
  new_settings.tracking_enable 		  	 = configuration->enable_tracking;
 80214c0:	7ca0      	ldrb	r0, [r4, #18]
  new_settings.mti_filter_enable	 	 = configuration->enable_mti_filter;
 80214c2:	f894 a015 	ldrb.w	sl, [r4, #21]
  new_settings.num_of_tracks			 = configuration->num_of_tracks;
 80214c6:	f894 9013 	ldrb.w	r9, [r4, #19]
  new_settings.mti_filter_len			 = configuration->mti_filter_length;
 80214ca:	f8b4 8016 	ldrh.w	r8, [r4, #22]
  new_settings.median_filter_len		 = configuration->median_filter_length;
 80214ce:	f894 c014 	ldrb.w	ip, [r4, #20]
  new_settings.mvg_avg_len				 = configuration->range_mvg_avg_length;
 80214d2:	f894 e000 	ldrb.w	lr, [r4]
  new_settings.min_distance_cm			 = configuration->min_range_cm;
 80214d6:	8867      	ldrh	r7, [r4, #2]
  new_settings.max_distance_cm			 = configuration->max_range_cm;
 80214d8:	88a6      	ldrh	r6, [r4, #4]
  new_settings.range_detection_threshold = configuration->range_threshold;
 80214da:	89e5      	ldrh	r5, [r4, #14]
#endif
  
#if defined(DOPPLER_SUPPORTED) || defined(FMCW_SUPPORTED)
  new_settings.min_speed_kmh = configuration->min_speed_kmh;
 80214dc:	88e1      	ldrh	r1, [r4, #6]
  new_settings.max_speed_kmh = configuration->max_speed_kmh;
 80214de:	8922      	ldrh	r2, [r4, #8]
  new_settings.speed_detection_threshold = configuration->speed_threshold;
 80214e0:	8a23      	ldrh	r3, [r4, #16]
  
  /* Fetch the complete existing data, to update only partially the new data. */
  ds_algo_fetch_settings(&new_settings);
  
#ifdef FMCW_SUPPORTED
  new_settings.tracking_enable 		  	 = configuration->enable_tracking;
 80214e2:	9004      	str	r0, [sp, #16]
  new_settings.max_speed_kmh = configuration->max_speed_kmh;
  new_settings.speed_detection_threshold = configuration->speed_threshold;
#endif
  
  /* Check for new settings */
  if (ds_algo_check_settings(&new_settings) == 0)
 80214e4:	a801      	add	r0, sp, #4
  /* Fetch the complete existing data, to update only partially the new data. */
  ds_algo_fetch_settings(&new_settings);
  
#ifdef FMCW_SUPPORTED
  new_settings.tracking_enable 		  	 = configuration->enable_tracking;
  new_settings.mti_filter_enable	 	 = configuration->enable_mti_filter;
 80214e6:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
  new_settings.num_of_tracks			 = configuration->num_of_tracks;
 80214ea:	f8cd 9014 	str.w	r9, [sp, #20]
  new_settings.mti_filter_len			 = configuration->mti_filter_length;
 80214ee:	f8cd 8020 	str.w	r8, [sp, #32]
  new_settings.median_filter_len		 = configuration->median_filter_length;
 80214f2:	f8cd c01c 	str.w	ip, [sp, #28]
  new_settings.mvg_avg_len				 = configuration->range_mvg_avg_length;
 80214f6:	f8cd e018 	str.w	lr, [sp, #24]
  new_settings.min_distance_cm			 = configuration->min_range_cm;
 80214fa:	970c      	str	r7, [sp, #48]	; 0x30
  new_settings.max_distance_cm			 = configuration->max_range_cm;
 80214fc:	960d      	str	r6, [sp, #52]	; 0x34
  new_settings.range_detection_threshold = configuration->range_threshold;
 80214fe:	950e      	str	r5, [sp, #56]	; 0x38
#endif
  
#if defined(DOPPLER_SUPPORTED) || defined(FMCW_SUPPORTED)
  new_settings.min_speed_kmh = configuration->min_speed_kmh;
 8021500:	9110      	str	r1, [sp, #64]	; 0x40
  new_settings.max_speed_kmh = configuration->max_speed_kmh;
 8021502:	9211      	str	r2, [sp, #68]	; 0x44
  new_settings.speed_detection_threshold = configuration->speed_threshold;
 8021504:	930f      	str	r3, [sp, #60]	; 0x3c
#endif
  
  /* Check for new settings */
  if (ds_algo_check_settings(&new_settings) == 0)
 8021506:	f7fe fdbd 	bl	8020084 <ds_algo_check_settings>
 802150a:	4604      	mov	r4, r0
 802150c:	b118      	cbz	r0, 8021516 <radar_set_dsp_settings+0x6e>
    ds_algo_store_settings(&new_settings);
    return (RADAR_ERR_OK);
  }
  else
  {
    return (RADAR_ERR_PARAMETER_OUT_OF_RANGE);
 802150e:	200c      	movs	r0, #12
  }
}
 8021510:	b014      	add	sp, #80	; 0x50
 8021512:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  
  /* Check for new settings */
  if (ds_algo_check_settings(&new_settings) == 0)
  {
    /* Apply new settings */
    ds_algo_store_settings(&new_settings);
 8021516:	a801      	add	r0, sp, #4
 8021518:	f7fe fda2 	bl	8020060 <ds_algo_store_settings>
    return (RADAR_ERR_OK);
 802151c:	4620      	mov	r0, r4
  }
  else
  {
    return (RADAR_ERR_PARAMETER_OUT_OF_RANGE);
  }
}
 802151e:	b014      	add	sp, #80	; 0x50
 8021520:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08021524 <radar_get_dsp_settings>:

//============================================================================

uint16_t radar_get_dsp_settings(Radar_Handle_t device, DSP_Settings_t* configuration)
{
 8021524:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8021526:	460c      	mov	r4, r1
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  algo_settings_t *p_ds_config = ds_algo_get_settings();
 8021528:	f7fe fda8 	bl	802007c <ds_algo_get_settings>
 802152c:	4603      	mov	r3, r0
  configuration->min_speed_kmh        = p_ds_config->min_speed_kmh;
  configuration->max_speed_kmh        = p_ds_config->max_speed_kmh;
  configuration->speed_threshold      = p_ds_config->speed_detection_threshold;
  
  return (RADAR_ERR_OK);
}
 802152e:	2000      	movs	r0, #0
uint16_t radar_get_dsp_settings(Radar_Handle_t device, DSP_Settings_t* configuration)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */
  algo_settings_t *p_ds_config = ds_algo_get_settings();
  
  configuration->enable_tracking      = p_ds_config->tracking_enable;
 8021530:	68da      	ldr	r2, [r3, #12]
 8021532:	74a2      	strb	r2, [r4, #18]
  configuration->enable_mti_filter    = p_ds_config->mti_filter_enable;
 8021534:	6a1a      	ldr	r2, [r3, #32]
 8021536:	7562      	strb	r2, [r4, #21]
  configuration->num_of_tracks        = p_ds_config->num_of_tracks;
 8021538:	691a      	ldr	r2, [r3, #16]
 802153a:	74e2      	strb	r2, [r4, #19]
  configuration->mti_filter_length    = p_ds_config->mti_filter_len;
  configuration->median_filter_length = p_ds_config->median_filter_len;
 802153c:	699a      	ldr	r2, [r3, #24]
  algo_settings_t *p_ds_config = ds_algo_get_settings();
  
  configuration->enable_tracking      = p_ds_config->tracking_enable;
  configuration->enable_mti_filter    = p_ds_config->mti_filter_enable;
  configuration->num_of_tracks        = p_ds_config->num_of_tracks;
  configuration->mti_filter_length    = p_ds_config->mti_filter_len;
 802153e:	f8d3 e01c 	ldr.w	lr, [r3, #28]
  configuration->median_filter_length = p_ds_config->median_filter_len;
 8021542:	7522      	strb	r2, [r4, #20]
  configuration->range_mvg_avg_length = p_ds_config->mvg_avg_len;
 8021544:	695a      	ldr	r2, [r3, #20]
 8021546:	7022      	strb	r2, [r4, #0]
  configuration->min_range_cm         = p_ds_config->min_distance_cm;
 8021548:	6adf      	ldr	r7, [r3, #44]	; 0x2c
  configuration->max_range_cm         = p_ds_config->max_distance_cm;
 802154a:	6b1e      	ldr	r6, [r3, #48]	; 0x30
  configuration->range_threshold      = p_ds_config->range_detection_threshold;
 802154c:	6b5d      	ldr	r5, [r3, #52]	; 0x34
  
  configuration->min_speed_kmh        = p_ds_config->min_speed_kmh;
 802154e:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
  configuration->max_speed_kmh        = p_ds_config->max_speed_kmh;
 8021550:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  configuration->speed_threshold      = p_ds_config->speed_detection_threshold;
 8021552:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8021554:	8223      	strh	r3, [r4, #16]
  algo_settings_t *p_ds_config = ds_algo_get_settings();
  
  configuration->enable_tracking      = p_ds_config->tracking_enable;
  configuration->enable_mti_filter    = p_ds_config->mti_filter_enable;
  configuration->num_of_tracks        = p_ds_config->num_of_tracks;
  configuration->mti_filter_length    = p_ds_config->mti_filter_len;
 8021556:	f8a4 e016 	strh.w	lr, [r4, #22]
  configuration->median_filter_length = p_ds_config->median_filter_len;
  configuration->range_mvg_avg_length = p_ds_config->mvg_avg_len;
  configuration->min_range_cm         = p_ds_config->min_distance_cm;
 802155a:	8067      	strh	r7, [r4, #2]
  configuration->max_range_cm         = p_ds_config->max_distance_cm;
 802155c:	80a6      	strh	r6, [r4, #4]
  configuration->range_threshold      = p_ds_config->range_detection_threshold;
 802155e:	81e5      	strh	r5, [r4, #14]
  
  configuration->min_speed_kmh        = p_ds_config->min_speed_kmh;
 8021560:	80e1      	strh	r1, [r4, #6]
  configuration->max_speed_kmh        = p_ds_config->max_speed_kmh;
 8021562:	8122      	strh	r2, [r4, #8]
  configuration->speed_threshold      = p_ds_config->speed_detection_threshold;
  
  return (RADAR_ERR_OK);
}
 8021564:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8021566:	bf00      	nop

08021568 <radar_get_target_info>:

//============================================================================

uint16_t radar_get_target_info(Radar_Handle_t device, Target_Info_t* target_info, uint8_t* target_count)
{
 8021568:	b508      	push	{r3, lr}
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */

  ds_ep_fetch_target_list(target_info, target_count);
 802156a:	4608      	mov	r0, r1
 802156c:	4611      	mov	r1, r2
 802156e:	f7fe ff17 	bl	80203a0 <ds_ep_fetch_target_list>
  return (RADAR_ERR_OK);
}
 8021572:	2000      	movs	r0, #0
 8021574:	bd08      	pop	{r3, pc}
 8021576:	bf00      	nop

08021578 <radar_get_range_detection_threshold>:

//============================================================================

uint16_t radar_get_range_detection_threshold(Radar_Handle_t device, uint16_t *threshold)
{
 8021578:	b508      	push	{r3, lr}
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */

  ds_ep_fetch_range_detection_threshold(threshold);
 802157a:	4608      	mov	r0, r1
 802157c:	f7fe ff50 	bl	8020420 <ds_ep_fetch_range_detection_threshold>
  return (RADAR_ERR_OK);
}
 8021580:	2000      	movs	r0, #0
 8021582:	bd08      	pop	{r3, pc}

08021584 <XMC_ERU_Enable>:
/*********************************************************************************************************************
 * API IMPLEMENTATION
 ********************************************************************************************************************/
/* Enable the clock and De-assert the ERU module from the reset state. */
void XMC_ERU_Enable(XMC_ERU_t *const eru)
{
 8021584:	b508      	push	{r3, lr}
#if defined(XMC_ERU1)
  if (eru == XMC_ERU1)
 8021586:	4b07      	ldr	r3, [pc, #28]	; (80215a4 <XMC_ERU_Enable+0x20>)
 8021588:	4298      	cmp	r0, r3
 802158a:	d000      	beq.n	802158e <XMC_ERU_Enable+0xa>
 802158c:	bd08      	pop	{r3, pc}
  {
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_ERU1);
 802158e:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 8021592:	f000 f925 	bl	80217e0 <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_ERU1);
 8021596:	f44f 3080 	mov.w	r0, #65536	; 0x10000
  }
#else
  XMC_UNUSED_ARG(eru);
  #endif
}
 802159a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  if (eru == XMC_ERU1)
  {
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_ERU1);
#endif
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_ERU1);
 802159e:	f000 b8af 	b.w	8021700 <XMC_SCU_RESET_DeassertPeripheralReset>
 80215a2:	bf00      	nop
 80215a4:	40044000 	.word	0x40044000

080215a8 <XMC_FLASH_ClearStatus>:
void XMC_FLASH_lClearStatusCommand(void)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xf5U;
 80215a8:	4b01      	ldr	r3, [pc, #4]	; (80215b0 <XMC_FLASH_ClearStatus+0x8>)
 80215aa:	22f5      	movs	r2, #245	; 0xf5
 80215ac:	601a      	str	r2, [r3, #0]
 80215ae:	4770      	bx	lr
 80215b0:	0c005554 	.word	0x0c005554

080215b4 <XMC_FLASH_GetStatus>:
/*
 * This API returns the FSR register value
 */
uint32_t XMC_FLASH_GetStatus(void)
{
  return FLASH0->FSR;
 80215b4:	4a02      	ldr	r2, [pc, #8]	; (80215c0 <XMC_FLASH_GetStatus+0xc>)
 80215b6:	f241 0310 	movw	r3, #4112	; 0x1010
 80215ba:	58d0      	ldr	r0, [r2, r3]
}
 80215bc:	4770      	bx	lr
 80215be:	bf00      	nop
 80215c0:	58001000 	.word	0x58001000

080215c4 <XMC_FLASH_ProgramPage>:
void XMC_FLASH_lClearStatusCommand(void)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xf5U;
 80215c4:	4b0f      	ldr	r3, [pc, #60]	; (8021604 <XMC_FLASH_ProgramPage+0x40>)

/*
 * This API write the PFLASH page
 */
void XMC_FLASH_ProgramPage(uint32_t *address, const uint32_t *data)
{
 80215c6:	b470      	push	{r4, r5, r6}
void XMC_FLASH_lEnterPageModeCommand(void)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = (uint32_t)0x50U;
 80215c8:	2250      	movs	r2, #80	; 0x50
void XMC_FLASH_lClearStatusCommand(void)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xf5U;
 80215ca:	24f5      	movs	r4, #245	; 0xf5
void XMC_FLASH_lLoadPageCommand(uint32_t low_word, uint32_t high_word)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x55f0U);
  *address = low_word;
 80215cc:	4e0e      	ldr	r6, [pc, #56]	; (8021608 <XMC_FLASH_ProgramPage+0x44>)
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x55f4U);
  *address = high_word;
 80215ce:	4d0f      	ldr	r5, [pc, #60]	; (802160c <XMC_FLASH_ProgramPage+0x48>)
void XMC_FLASH_lClearStatusCommand(void)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xf5U;
 80215d0:	601c      	str	r4, [r3, #0]
 80215d2:	f501 7480 	add.w	r4, r1, #256	; 0x100
void XMC_FLASH_lEnterPageModeCommand(void)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = (uint32_t)0x50U;
 80215d6:	601a      	str	r2, [r3, #0]
  XMC_FLASH_lClearStatusCommand();  
  XMC_FLASH_lEnterPageModeCommand();

  for (idx = 0U; idx < XMC_FLASH_WORDS_PER_PAGE; idx += 2U)
  {
    XMC_FLASH_lLoadPageCommand(data[idx], data[idx + 1U]);
 80215d8:	e891 000c 	ldmia.w	r1, {r2, r3}
 80215dc:	3108      	adds	r1, #8
  uint32_t idx;

  XMC_FLASH_lClearStatusCommand();  
  XMC_FLASH_lEnterPageModeCommand();

  for (idx = 0U; idx < XMC_FLASH_WORDS_PER_PAGE; idx += 2U)
 80215de:	42a1      	cmp	r1, r4
void XMC_FLASH_lLoadPageCommand(uint32_t low_word, uint32_t high_word)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x55f0U);
  *address = low_word;
 80215e0:	6032      	str	r2, [r6, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x55f4U);
  *address = high_word;
 80215e2:	602b      	str	r3, [r5, #0]
  uint32_t idx;

  XMC_FLASH_lClearStatusCommand();  
  XMC_FLASH_lEnterPageModeCommand();

  for (idx = 0U; idx < XMC_FLASH_WORDS_PER_PAGE; idx += 2U)
 80215e4:	d1f8      	bne.n	80215d8 <XMC_FLASH_ProgramPage+0x14>
void XMC_FLASH_lWritePageCommand(uint32_t *page_start_address)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xaaU;
 80215e6:	4907      	ldr	r1, [pc, #28]	; (8021604 <XMC_FLASH_ProgramPage+0x40>)
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0xaaa8U);
  *address = 0x55U;
 80215e8:	4d09      	ldr	r5, [pc, #36]	; (8021610 <XMC_FLASH_ProgramPage+0x4c>)
  }

  XMC_FLASH_lWritePageCommand(address);    

  /* wait until the operation is completed */
  while ((FLASH0->FSR & (uint32_t)FLASH_FSR_PBUSY_Msk) != 0U){}
 80215ea:	4a0a      	ldr	r2, [pc, #40]	; (8021614 <XMC_FLASH_ProgramPage+0x50>)
void XMC_FLASH_lWritePageCommand(uint32_t *page_start_address)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xaaU;
 80215ec:	23aa      	movs	r3, #170	; 0xaa
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0xaaa8U);
  *address = 0x55U;
 80215ee:	2655      	movs	r6, #85	; 0x55
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xa0U;
 80215f0:	24a0      	movs	r4, #160	; 0xa0
void XMC_FLASH_lWritePageCommand(uint32_t *page_start_address)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xaaU;
 80215f2:	600b      	str	r3, [r1, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0xaaa8U);
  *address = 0x55U;
 80215f4:	602e      	str	r6, [r5, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xa0U;
 80215f6:	600c      	str	r4, [r1, #0]
  address = page_start_address;
  *address = 0xaaU;
 80215f8:	6003      	str	r3, [r0, #0]
  }

  XMC_FLASH_lWritePageCommand(address);    

  /* wait until the operation is completed */
  while ((FLASH0->FSR & (uint32_t)FLASH_FSR_PBUSY_Msk) != 0U){}
 80215fa:	6813      	ldr	r3, [r2, #0]
 80215fc:	07db      	lsls	r3, r3, #31
 80215fe:	d4fc      	bmi.n	80215fa <XMC_FLASH_ProgramPage+0x36>
}
 8021600:	bc70      	pop	{r4, r5, r6}
 8021602:	4770      	bx	lr
 8021604:	0c005554 	.word	0x0c005554
 8021608:	0c0055f0 	.word	0x0c0055f0
 802160c:	0c0055f4 	.word	0x0c0055f4
 8021610:	0c00aaa8 	.word	0x0c00aaa8
 8021614:	58002010 	.word	0x58002010

08021618 <XMC_FLASH_EraseSector>:
void XMC_FLASH_lClearStatusCommand(void)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xf5U;
 8021618:	4b0a      	ldr	r3, [pc, #40]	; (8021644 <XMC_FLASH_EraseSector+0x2c>)
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xaaU;
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0xaaa8U);
  *address = 0x55U;
 802161a:	490b      	ldr	r1, [pc, #44]	; (8021648 <XMC_FLASH_EraseSector+0x30>)
{
  XMC_FLASH_lClearStatusCommand();
  XMC_FLASH_lEraseSectorCommand(address);

  /* wait until the operation is completed */
  while ((FLASH0->FSR & (uint32_t)FLASH_FSR_PBUSY_Msk) != 0U){}
 802161c:	4a0b      	ldr	r2, [pc, #44]	; (802164c <XMC_FLASH_EraseSector+0x34>)

/*
 * This API erase the logical sector
 */
void XMC_FLASH_EraseSector(uint32_t *address)
{
 802161e:	b5f0      	push	{r4, r5, r6, r7, lr}
void XMC_FLASH_lEraseSectorCommand(uint32_t *sector_start_address)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xaaU;
 8021620:	25aa      	movs	r5, #170	; 0xaa
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0xaaa8U);
  *address = 0x55U;
 8021622:	2455      	movs	r4, #85	; 0x55
void XMC_FLASH_lClearStatusCommand(void)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xf5U;
 8021624:	f04f 0ef5 	mov.w	lr, #245	; 0xf5
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xaaU;
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0xaaa8U);
  *address = 0x55U;
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0x80U;
 8021628:	2780      	movs	r7, #128	; 0x80
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xaaU;
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0xaaa8U);
  *address = 0x55U;
  address = sector_start_address;
  *address = 0x30U;
 802162a:	2630      	movs	r6, #48	; 0x30
void XMC_FLASH_lClearStatusCommand(void)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xf5U;
 802162c:	f8c3 e000 	str.w	lr, [r3]
void XMC_FLASH_lEraseSectorCommand(uint32_t *sector_start_address)
{
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xaaU;
 8021630:	601d      	str	r5, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0xaaa8U);
  *address = 0x55U;
 8021632:	600c      	str	r4, [r1, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0x80U;
 8021634:	601f      	str	r7, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
  *address = 0xaaU;
 8021636:	601d      	str	r5, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0xaaa8U);
  *address = 0x55U;
 8021638:	600c      	str	r4, [r1, #0]
  address = sector_start_address;
  *address = 0x30U;
 802163a:	6006      	str	r6, [r0, #0]
{
  XMC_FLASH_lClearStatusCommand();
  XMC_FLASH_lEraseSectorCommand(address);

  /* wait until the operation is completed */
  while ((FLASH0->FSR & (uint32_t)FLASH_FSR_PBUSY_Msk) != 0U){}
 802163c:	6813      	ldr	r3, [r2, #0]
 802163e:	07db      	lsls	r3, r3, #31
 8021640:	d4fc      	bmi.n	802163c <XMC_FLASH_EraseSector+0x24>
}
 8021642:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8021644:	0c005554 	.word	0x0c005554
 8021648:	0c00aaa8 	.word	0x0c00aaa8
 802164c:	58002010 	.word	0x58002010

08021650 <XMC_GPIO_Init>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_GPIO_Init(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_CONFIG_t *const config)
{
 8021650:	f001 03fc 	and.w	r3, r1, #252	; 0xfc
 8021654:	4403      	add	r3, r0
 8021656:	b5f0      	push	{r4, r5, r6, r7, lr}
  XMC_ASSERT("XMC_GPIO_Init: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_Init: Invalid mode", XMC_GPIO_IsModeValid(config->mode));
 
  /* Switch to input */
  port->IOCR[pin >> 2U] &= (uint32_t)~(PORT_IOCR_PC_Msk << (PORT_IOCR_PC_Size * (pin & 0x3U)));
 8021658:	f001 0503 	and.w	r5, r1, #3
 802165c:	691e      	ldr	r6, [r3, #16]
  /* HW port control is disabled */
  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));


  /* Enable digital input */
  if (XMC_GPIO_CHECK_ANALOG_PORT(port))
 802165e:	4f1c      	ldr	r7, [pc, #112]	; (80216d0 <XMC_GPIO_Init+0x80>)
{
  XMC_ASSERT("XMC_GPIO_Init: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_Init: Invalid mode", XMC_GPIO_IsModeValid(config->mode));
 
  /* Switch to input */
  port->IOCR[pin >> 2U] &= (uint32_t)~(PORT_IOCR_PC_Msk << (PORT_IOCR_PC_Size * (pin & 0x3U)));
 8021660:	00ed      	lsls	r5, r5, #3
 8021662:	24f8      	movs	r4, #248	; 0xf8
 8021664:	40ac      	lsls	r4, r5
 8021666:	ea26 0404 	bic.w	r4, r6, r4
 802166a:	611c      	str	r4, [r3, #16]

  /* HW port control is disabled */
  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
 802166c:	6f46      	ldr	r6, [r0, #116]	; 0x74
 802166e:	ea4f 0e41 	mov.w	lr, r1, lsl #1
 8021672:	2403      	movs	r4, #3
 8021674:	fa04 f40e 	lsl.w	r4, r4, lr
 8021678:	ea26 0404 	bic.w	r4, r6, r4


  /* Enable digital input */
  if (XMC_GPIO_CHECK_ANALOG_PORT(port))
 802167c:	42b8      	cmp	r0, r7
 
  /* Switch to input */
  port->IOCR[pin >> 2U] &= (uint32_t)~(PORT_IOCR_PC_Msk << (PORT_IOCR_PC_Size * (pin & 0x3U)));

  /* HW port control is disabled */
  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
 802167e:	6744      	str	r4, [r0, #116]	; 0x74


  /* Enable digital input */
  if (XMC_GPIO_CHECK_ANALOG_PORT(port))
 8021680:	d01d      	beq.n	80216be <XMC_GPIO_Init+0x6e>
 8021682:	4c14      	ldr	r4, [pc, #80]	; (80216d4 <XMC_GPIO_Init+0x84>)
 8021684:	42a0      	cmp	r0, r4
 8021686:	d01a      	beq.n	80216be <XMC_GPIO_Init+0x6e>
    port->PDISC &= ~(uint32_t)((uint32_t)0x1U << pin);
  }
  else
  {
    /* Set output level */
    port->OMR = (uint32_t)config->output_level << pin;
 8021688:	6857      	ldr	r7, [r2, #4]

    /* Set output driver strength */
    port->PDR[pin >> 3U] &= (uint32_t)~(PORT_PDR_Msk << ((uint32_t)PORT_PDR_Size * ((uint32_t)pin & 0x7U)));
    port->PDR[pin >> 3U] |= (uint32_t)config->output_strength << ((uint32_t)PORT_PDR_Size * ((uint32_t)pin & 0x7U));
 802168a:	7a16      	ldrb	r6, [r2, #8]
 802168c:	08cc      	lsrs	r4, r1, #3
 802168e:	eb00 0484 	add.w	r4, r0, r4, lsl #2
    port->PDISC &= ~(uint32_t)((uint32_t)0x1U << pin);
  }
  else
  {
    /* Set output level */
    port->OMR = (uint32_t)config->output_level << pin;
 8021692:	408f      	lsls	r7, r1
 8021694:	6047      	str	r7, [r0, #4]

    /* Set output driver strength */
    port->PDR[pin >> 3U] &= (uint32_t)~(PORT_PDR_Msk << ((uint32_t)PORT_PDR_Size * ((uint32_t)pin & 0x7U)));
 8021696:	f001 0107 	and.w	r1, r1, #7
 802169a:	6c27      	ldr	r7, [r4, #64]	; 0x40
 802169c:	0089      	lsls	r1, r1, #2
 802169e:	2007      	movs	r0, #7
 80216a0:	4088      	lsls	r0, r1
 80216a2:	ea27 0000 	bic.w	r0, r7, r0
 80216a6:	6420      	str	r0, [r4, #64]	; 0x40
    port->PDR[pin >> 3U] |= (uint32_t)config->output_strength << ((uint32_t)PORT_PDR_Size * ((uint32_t)pin & 0x7U));
 80216a8:	6c20      	ldr	r0, [r4, #64]	; 0x40
 80216aa:	fa06 f101 	lsl.w	r1, r6, r1
 80216ae:	4301      	orrs	r1, r0
 80216b0:	6421      	str	r1, [r4, #64]	; 0x40
  }

  /* Set mode */
  port->IOCR[pin >> 2U] |= (uint32_t)config->mode << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U));
 80216b2:	7812      	ldrb	r2, [r2, #0]
 80216b4:	6919      	ldr	r1, [r3, #16]
 80216b6:	40aa      	lsls	r2, r5
 80216b8:	430a      	orrs	r2, r1
 80216ba:	611a      	str	r2, [r3, #16]
 80216bc:	bdf0      	pop	{r4, r5, r6, r7, pc}


  /* Enable digital input */
  if (XMC_GPIO_CHECK_ANALOG_PORT(port))
  {
    port->PDISC &= ~(uint32_t)((uint32_t)0x1U << pin);
 80216be:	6e04      	ldr	r4, [r0, #96]	; 0x60
 80216c0:	2601      	movs	r6, #1
 80216c2:	fa06 f101 	lsl.w	r1, r6, r1
 80216c6:	ea24 0101 	bic.w	r1, r4, r1
 80216ca:	6601      	str	r1, [r0, #96]	; 0x60
 80216cc:	e7f1      	b.n	80216b2 <XMC_GPIO_Init+0x62>
 80216ce:	bf00      	nop
 80216d0:	48028e00 	.word	0x48028e00
 80216d4:	48028f00 	.word	0x48028f00

080216d8 <XMC_SCU_INTERRUPT_EnableNmiRequest>:
}

/* Enables a NMI source */
void XMC_SCU_INTERRUPT_EnableNmiRequest(const uint32_t request)
{
  SCU_INTERRUPT->NMIREQEN |= (uint32_t)request;
 80216d8:	4a02      	ldr	r2, [pc, #8]	; (80216e4 <XMC_SCU_INTERRUPT_EnableNmiRequest+0xc>)
 80216da:	6953      	ldr	r3, [r2, #20]
 80216dc:	4318      	orrs	r0, r3
 80216de:	6150      	str	r0, [r2, #20]
 80216e0:	4770      	bx	lr
 80216e2:	bf00      	nop
 80216e4:	50004074 	.word	0x50004074

080216e8 <XMC_SCU_RESET_AssertPeripheralReset>:
}

/* API to manually assert a reset request */
void XMC_SCU_RESET_AssertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
 80216e8:	0f03      	lsrs	r3, r0, #28
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));

  *(uint32_t *)(&(SCU_RESET->PRSET0) + (index * 3U)) = (uint32_t)mask;
 80216ea:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80216ee:	4a03      	ldr	r2, [pc, #12]	; (80216fc <XMC_SCU_RESET_AssertPeripheralReset+0x14>)

/* API to manually assert a reset request */
void XMC_SCU_RESET_AssertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));
 80216f0:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000

  *(uint32_t *)(&(SCU_RESET->PRSET0) + (index * 3U)) = (uint32_t)mask;
 80216f4:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
 80216f8:	4770      	bx	lr
 80216fa:	bf00      	nop
 80216fc:	50004410 	.word	0x50004410

08021700 <XMC_SCU_RESET_DeassertPeripheralReset>:
}

/* API to manually de-assert a reset request */
void XMC_SCU_RESET_DeassertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
 8021700:	0f03      	lsrs	r3, r0, #28
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));

  *(uint32_t *)(&(SCU_RESET->PRCLR0) + (index * 3U)) = (uint32_t)mask;
 8021702:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8021706:	4a03      	ldr	r2, [pc, #12]	; (8021714 <XMC_SCU_RESET_DeassertPeripheralReset+0x14>)

/* API to manually de-assert a reset request */
void XMC_SCU_RESET_DeassertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));
 8021708:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000

  *(uint32_t *)(&(SCU_RESET->PRCLR0) + (index * 3U)) = (uint32_t)mask;
 802170c:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
 8021710:	4770      	bx	lr
 8021712:	bf00      	nop
 8021714:	50004414 	.word	0x50004414

08021718 <XMC_SCU_RESET_IsPeripheralResetAsserted>:
}

/* Find out if the peripheral reset is asserted */
bool XMC_SCU_RESET_IsPeripheralResetAsserted(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
 8021718:	0f03      	lsrs	r3, r0, #28
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));

  return ((*(uint32_t *)(&(SCU_RESET->PRSTAT0) + (index * 3U)) & mask) != 0U);
 802171a:	4a06      	ldr	r2, [pc, #24]	; (8021734 <XMC_SCU_RESET_IsPeripheralResetAsserted+0x1c>)
 802171c:	eb03 0343 	add.w	r3, r3, r3, lsl #1

/* Find out if the peripheral reset is asserted */
bool XMC_SCU_RESET_IsPeripheralResetAsserted(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));
 8021720:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000

  return ((*(uint32_t *)(&(SCU_RESET->PRSTAT0) + (index * 3U)) & mask) != 0U);
 8021724:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8021728:	4218      	tst	r0, r3
}
 802172a:	bf14      	ite	ne
 802172c:	2001      	movne	r0, #1
 802172e:	2000      	moveq	r0, #0
 8021730:	4770      	bx	lr
 8021732:	bf00      	nop
 8021734:	5000440c 	.word	0x5000440c

08021738 <XMC_SCU_CLOCK_SetUsbClockSource>:
}

/* API to select fUSB */
void XMC_SCU_CLOCK_SetUsbClockSource(const XMC_SCU_CLOCK_USBCLKSRC_t source)
{
  SCU_CLK->USBCLKCR = (SCU_CLK->USBCLKCR & ((uint32_t)~SCU_CLK_USBCLKCR_USBSEL_Msk)) |
 8021738:	4a03      	ldr	r2, [pc, #12]	; (8021748 <XMC_SCU_CLOCK_SetUsbClockSource+0x10>)
 802173a:	6993      	ldr	r3, [r2, #24]
 802173c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8021740:	4318      	orrs	r0, r3
 8021742:	6190      	str	r0, [r2, #24]
 8021744:	4770      	bx	lr
 8021746:	bf00      	nop
 8021748:	50004600 	.word	0x50004600

0802174c <XMC_SCU_CLOCK_SetWdtClockSource>:
}

/* API to select fWDT */
void XMC_SCU_CLOCK_SetWdtClockSource(const XMC_SCU_CLOCK_WDTCLKSRC_t source)
{
  SCU_CLK->WDTCLKCR = (SCU_CLK->WDTCLKCR & ((uint32_t)~SCU_CLK_WDTCLKCR_WDTSEL_Msk)) |
 802174c:	4a03      	ldr	r2, [pc, #12]	; (802175c <XMC_SCU_CLOCK_SetWdtClockSource+0x10>)
 802174e:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8021750:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 8021754:	4318      	orrs	r0, r3
 8021756:	6250      	str	r0, [r2, #36]	; 0x24
 8021758:	4770      	bx	lr
 802175a:	bf00      	nop
 802175c:	50004600 	.word	0x50004600

08021760 <XMC_SCU_HIB_SetRtcClockSource>:

/* API to select fRTC */
void XMC_SCU_HIB_SetRtcClockSource(const XMC_SCU_HIB_RTCCLKSRC_t source)
{ 
  /* Wait until the update of HDCR register in hibernate domain is completed */
  while((SCU_GENERAL->MIRRSTS) & SCU_GENERAL_MIRRSTS_HDCR_Msk)
 8021760:	4a05      	ldr	r2, [pc, #20]	; (8021778 <XMC_SCU_HIB_SetRtcClockSource+0x18>)
 8021762:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
 8021766:	071b      	lsls	r3, r3, #28
 8021768:	d4fb      	bmi.n	8021762 <XMC_SCU_HIB_SetRtcClockSource+0x2>
  {
  }

  SCU_HIBERNATE->HDCR = (SCU_HIBERNATE->HDCR & ((uint32_t)~SCU_HIBERNATE_HDCR_RCS_Msk)) |
 802176a:	4a04      	ldr	r2, [pc, #16]	; (802177c <XMC_SCU_HIB_SetRtcClockSource+0x1c>)
 802176c:	68d3      	ldr	r3, [r2, #12]
 802176e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8021772:	4318      	orrs	r0, r3
 8021774:	60d0      	str	r0, [r2, #12]
 8021776:	4770      	bx	lr
 8021778:	50004000 	.word	0x50004000
 802177c:	50004300 	.word	0x50004300

08021780 <XMC_SCU_CLOCK_SetUsbClockDivider>:
void XMC_SCU_CLOCK_SetUsbClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetSdmmcClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_USBCLKCR_USBDIV_Msk + 1UL)) );

  SCU_CLK->USBCLKCR = (SCU_CLK->USBCLKCR & ((uint32_t)~SCU_CLK_USBCLKCR_USBDIV_Msk)) |
 8021780:	4a03      	ldr	r2, [pc, #12]	; (8021790 <XMC_SCU_CLOCK_SetUsbClockDivider+0x10>)
 8021782:	6993      	ldr	r3, [r2, #24]
                      (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_USBCLKCR_USBDIV_Pos); 
 8021784:	3801      	subs	r0, #1
void XMC_SCU_CLOCK_SetUsbClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetSdmmcClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_USBCLKCR_USBDIV_Msk + 1UL)) );

  SCU_CLK->USBCLKCR = (SCU_CLK->USBCLKCR & ((uint32_t)~SCU_CLK_USBCLKCR_USBDIV_Msk)) |
 8021786:	f023 0307 	bic.w	r3, r3, #7
 802178a:	4303      	orrs	r3, r0
 802178c:	6193      	str	r3, [r2, #24]
 802178e:	4770      	bx	lr
 8021790:	50004600 	.word	0x50004600

08021794 <XMC_SCU_CLOCK_SetEbuClockDivider>:
void XMC_SCU_CLOCK_SetEbuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetEbuClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_EBUCLKCR_EBUDIV_Msk + 1UL) ) );

  SCU_CLK->EBUCLKCR = (SCU_CLK->EBUCLKCR & ((uint32_t)~SCU_CLK_EBUCLKCR_EBUDIV_Msk)) |
 8021794:	4a03      	ldr	r2, [pc, #12]	; (80217a4 <XMC_SCU_CLOCK_SetEbuClockDivider+0x10>)
 8021796:	69d3      	ldr	r3, [r2, #28]
                      (uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_EBUCLKCR_EBUDIV_Pos);
 8021798:	3801      	subs	r0, #1
void XMC_SCU_CLOCK_SetEbuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetEbuClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_EBUCLKCR_EBUDIV_Msk + 1UL) ) );

  SCU_CLK->EBUCLKCR = (SCU_CLK->EBUCLKCR & ((uint32_t)~SCU_CLK_EBUCLKCR_EBUDIV_Msk)) |
 802179a:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 802179e:	4303      	orrs	r3, r0
 80217a0:	61d3      	str	r3, [r2, #28]
 80217a2:	4770      	bx	lr
 80217a4:	50004600 	.word	0x50004600

080217a8 <XMC_SCU_CLOCK_SetWdtClockDivider>:
void XMC_SCU_CLOCK_SetWdtClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetWdtClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_WDTCLKCR_WDTDIV_Msk + 1UL) ) );

  SCU_CLK->WDTCLKCR = (SCU_CLK->WDTCLKCR & ((uint32_t)~SCU_CLK_WDTCLKCR_WDTDIV_Msk)) |
 80217a8:	4a03      	ldr	r2, [pc, #12]	; (80217b8 <XMC_SCU_CLOCK_SetWdtClockDivider+0x10>)
 80217aa:	6a53      	ldr	r3, [r2, #36]	; 0x24
                      (uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_WDTCLKCR_WDTDIV_Pos);
 80217ac:	3801      	subs	r0, #1
void XMC_SCU_CLOCK_SetWdtClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetWdtClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_WDTCLKCR_WDTDIV_Msk + 1UL) ) );

  SCU_CLK->WDTCLKCR = (SCU_CLK->WDTCLKCR & ((uint32_t)~SCU_CLK_WDTCLKCR_WDTDIV_Msk)) |
 80217ae:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 80217b2:	4303      	orrs	r3, r0
 80217b4:	6253      	str	r3, [r2, #36]	; 0x24
 80217b6:	4770      	bx	lr
 80217b8:	50004600 	.word	0x50004600

080217bc <XMC_SCU_CLOCK_EnableClock>:
#endif

/* API to enable a given module clock */
void XMC_SCU_CLOCK_EnableClock(const XMC_SCU_CLOCK_t clock)
{
  SCU_CLK->CLKSET = ((uint32_t)clock);
 80217bc:	4b01      	ldr	r3, [pc, #4]	; (80217c4 <XMC_SCU_CLOCK_EnableClock+0x8>)
 80217be:	6058      	str	r0, [r3, #4]
 80217c0:	4770      	bx	lr
 80217c2:	bf00      	nop
 80217c4:	50004600 	.word	0x50004600

080217c8 <XMC_SCU_CLOCK_GatePeripheralClock>:

#if defined(CLOCK_GATING_SUPPORTED)
/* API to gate a given module clock */
void XMC_SCU_CLOCK_GatePeripheralClock(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
  uint32_t index = (peripheral & 0xf0000000UL) >> 28UL;
 80217c8:	0f03      	lsrs	r3, r0, #28
  uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);

  *(uint32_t *)((&(SCU_CLK->CGATSET0)) + (index * 3U)) = (uint32_t)mask;
 80217ca:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80217ce:	4a03      	ldr	r2, [pc, #12]	; (80217dc <XMC_SCU_CLOCK_GatePeripheralClock+0x14>)
#if defined(CLOCK_GATING_SUPPORTED)
/* API to gate a given module clock */
void XMC_SCU_CLOCK_GatePeripheralClock(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
  uint32_t index = (peripheral & 0xf0000000UL) >> 28UL;
  uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);
 80217d0:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000

  *(uint32_t *)((&(SCU_CLK->CGATSET0)) + (index * 3U)) = (uint32_t)mask;
 80217d4:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
 80217d8:	4770      	bx	lr
 80217da:	bf00      	nop
 80217dc:	50004644 	.word	0x50004644

080217e0 <XMC_SCU_CLOCK_UngatePeripheralClock>:
}

/* API to ungate a given module clock */
void XMC_SCU_CLOCK_UngatePeripheralClock(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
  uint32_t index = (uint32_t)((peripheral & 0xf0000000UL) >> 28UL);
 80217e0:	0f03      	lsrs	r3, r0, #28
  uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);

  *(uint32_t *)(&(SCU_CLK->CGATCLR0) + (index * 3U)) = (uint32_t)mask;
 80217e2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80217e6:	4a03      	ldr	r2, [pc, #12]	; (80217f4 <XMC_SCU_CLOCK_UngatePeripheralClock+0x14>)

/* API to ungate a given module clock */
void XMC_SCU_CLOCK_UngatePeripheralClock(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
  uint32_t index = (uint32_t)((peripheral & 0xf0000000UL) >> 28UL);
  uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);
 80217e8:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000

  *(uint32_t *)(&(SCU_CLK->CGATCLR0) + (index * 3U)) = (uint32_t)mask;
 80217ec:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
 80217f0:	4770      	bx	lr
 80217f2:	bf00      	nop
 80217f4:	50004648 	.word	0x50004648

080217f8 <XMC_SCU_CLOCK_IsPeripheralClockGated>:
}

/* API to ungate a given module clock */
bool XMC_SCU_CLOCK_IsPeripheralClockGated(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
  uint32_t index = ((peripheral & 0xf0000000UL) >> 28UL);
 80217f8:	0f03      	lsrs	r3, r0, #28
  uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);

  return ((*(uint32_t *)(&(SCU_CLK->CGATSTAT0) + (index * 3U)) & mask) != 0U);
 80217fa:	4a06      	ldr	r2, [pc, #24]	; (8021814 <XMC_SCU_CLOCK_IsPeripheralClockGated+0x1c>)
 80217fc:	eb03 0343 	add.w	r3, r3, r3, lsl #1

/* API to ungate a given module clock */
bool XMC_SCU_CLOCK_IsPeripheralClockGated(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
  uint32_t index = ((peripheral & 0xf0000000UL) >> 28UL);
  uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);
 8021800:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000

  return ((*(uint32_t *)(&(SCU_CLK->CGATSTAT0) + (index * 3U)) & mask) != 0U);
 8021804:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8021808:	4218      	tst	r0, r3
}
 802180a:	bf14      	ite	ne
 802180c:	2001      	movne	r0, #1
 802180e:	2000      	moveq	r0, #0
 8021810:	4770      	bx	lr
 8021812:	bf00      	nop
 8021814:	50004640 	.word	0x50004640

08021818 <XMC_SCU_CLOCK_StartUsbPll>:

/* API to configure USB PLL */
void XMC_SCU_CLOCK_StartUsbPll(uint32_t pdiv, uint32_t ndiv)
{
  /* Go to bypass the USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_VCOBYP_Msk;
 8021818:	4b0f      	ldr	r3, [pc, #60]	; (8021858 <XMC_SCU_CLOCK_StartUsbPll+0x40>)
 802181a:	695a      	ldr	r2, [r3, #20]
 802181c:	f042 0201 	orr.w	r2, r2, #1
 8021820:	615a      	str	r2, [r3, #20]

  /* disconnect Oscillator from USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_FINDIS_Msk;
 8021822:	695a      	ldr	r2, [r3, #20]

  /* Setup Divider settings for USB PLL */
  SCU_PLL->USBPLLCON = (uint32_t)((uint32_t)((ndiv -1U) << SCU_PLL_USBPLLCON_NDIV_Pos) |
                       (uint32_t)((pdiv - 1U) << SCU_PLL_USBPLLCON_PDIV_Pos));
 8021824:	3801      	subs	r0, #1
 8021826:	0600      	lsls	r0, r0, #24

  /* disconnect Oscillator from USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_FINDIS_Msk;

  /* Setup Divider settings for USB PLL */
  SCU_PLL->USBPLLCON = (uint32_t)((uint32_t)((ndiv -1U) << SCU_PLL_USBPLLCON_NDIV_Pos) |
 8021828:	3901      	subs	r1, #1
{
  /* Go to bypass the USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_VCOBYP_Msk;

  /* disconnect Oscillator from USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_FINDIS_Msk;
 802182a:	f042 0210 	orr.w	r2, r2, #16

  /* Setup Divider settings for USB PLL */
  SCU_PLL->USBPLLCON = (uint32_t)((uint32_t)((ndiv -1U) << SCU_PLL_USBPLLCON_NDIV_Pos) |
 802182e:	ea40 2001 	orr.w	r0, r0, r1, lsl #8
{
  /* Go to bypass the USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_VCOBYP_Msk;

  /* disconnect Oscillator from USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_FINDIS_Msk;
 8021832:	615a      	str	r2, [r3, #20]

  /* Setup Divider settings for USB PLL */
  SCU_PLL->USBPLLCON = (uint32_t)((uint32_t)((ndiv -1U) << SCU_PLL_USBPLLCON_NDIV_Pos) |
 8021834:	6158      	str	r0, [r3, #20]
                       (uint32_t)((pdiv - 1U) << SCU_PLL_USBPLLCON_PDIV_Pos));

  /* Set OSCDISCDIS */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_OSCDISCDIS_Msk;
 8021836:	695a      	ldr	r2, [r3, #20]
 8021838:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 802183c:	615a      	str	r2, [r3, #20]

  /* connect Oscillator to USB PLL */
  SCU_PLL->USBPLLCON &= (uint32_t)~SCU_PLL_USBPLLCON_FINDIS_Msk;
 802183e:	695a      	ldr	r2, [r3, #20]
 8021840:	f022 0210 	bic.w	r2, r2, #16
 8021844:	615a      	str	r2, [r3, #20]

  /* restart PLL Lock detection */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_RESLD_Msk;
 8021846:	695a      	ldr	r2, [r3, #20]
 8021848:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 802184c:	615a      	str	r2, [r3, #20]

  while ((SCU_PLL->USBPLLSTAT & SCU_PLL_USBPLLSTAT_VCOLOCK_Msk) == 0U)
 802184e:	691a      	ldr	r2, [r3, #16]
 8021850:	0752      	lsls	r2, r2, #29
 8021852:	d5fc      	bpl.n	802184e <XMC_SCU_CLOCK_StartUsbPll+0x36>
  {
    /* wait for PLL Lock */
  }

}
 8021854:	4770      	bx	lr
 8021856:	bf00      	nop
 8021858:	50004710 	.word	0x50004710

0802185c <XMC_SCU_POWER_EnableUsb>:

/* API to enable USB Phy and comparator */
void XMC_SCU_POWER_EnableUsb(void)
{
#if defined(USB_OTG_SUPPORTED)
  SCU_POWER->PWRSET = (uint32_t)(SCU_POWER_PWRSET_USBOTGEN_Msk | SCU_POWER_PWRSET_USBPHYPDQ_Msk);
 802185c:	4b02      	ldr	r3, [pc, #8]	; (8021868 <XMC_SCU_POWER_EnableUsb+0xc>)
 802185e:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 8021862:	605a      	str	r2, [r3, #4]
 8021864:	4770      	bx	lr
 8021866:	bf00      	nop
 8021868:	50004200 	.word	0x50004200

0802186c <XMC_SCU_POWER_DisableUsb>:

/* API to power down USB Phy and comparator */
void XMC_SCU_POWER_DisableUsb(void)
{
#if defined(USB_OTG_SUPPORTED)
  SCU_POWER->PWRCLR = (uint32_t)(SCU_POWER_PWRCLR_USBOTGEN_Msk | SCU_POWER_PWRSET_USBPHYPDQ_Msk);
 802186c:	4b02      	ldr	r3, [pc, #8]	; (8021878 <XMC_SCU_POWER_DisableUsb+0xc>)
 802186e:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 8021872:	609a      	str	r2, [r3, #8]
 8021874:	4770      	bx	lr
 8021876:	bf00      	nop
 8021878:	50004200 	.word	0x50004200

0802187c <XMC_SCU_CLOCK_StartSystemPll>:
void XMC_SCU_CLOCK_StartSystemPll(XMC_SCU_CLOCK_SYSPLLCLKSRC_t source,
                                  XMC_SCU_CLOCK_SYSPLL_MODE_t mode,
                                  uint32_t pdiv,
                                  uint32_t ndiv,
                                  uint32_t kdiv)
{
 802187c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802187e:	b083      	sub	sp, #12
void XMC_SCU_CLOCK_SetSystemPllClockSource(const XMC_SCU_CLOCK_SYSPLLCLKSRC_t source)
{
  /* Check input clock */
  if (source == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP) /* Select PLLClockSource */
  {
    SCU_PLL->PLLCON2 &= (uint32_t)~(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
 8021880:	4c64      	ldr	r4, [pc, #400]	; (8021a14 <XMC_SCU_CLOCK_StartSystemPll+0x198>)
void XMC_SCU_CLOCK_StartSystemPll(XMC_SCU_CLOCK_SYSPLLCLKSRC_t source,
                                  XMC_SCU_CLOCK_SYSPLL_MODE_t mode,
                                  uint32_t pdiv,
                                  uint32_t ndiv,
                                  uint32_t kdiv)
{
 8021882:	9e08      	ldr	r6, [sp, #32]

/* API to select fPLL */
void XMC_SCU_CLOCK_SetSystemPllClockSource(const XMC_SCU_CLOCK_SYSPLLCLKSRC_t source)
{
  /* Check input clock */
  if (source == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP) /* Select PLLClockSource */
 8021884:	b1c0      	cbz	r0, 80218b8 <XMC_SCU_CLOCK_StartSystemPll+0x3c>
  {
    SCU_PLL->PLLCON2 &= (uint32_t)~(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
  }
  else
  {
    SCU_PLL->PLLCON2 |= (uint32_t)(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
 8021886:	68e0      	ldr	r0, [r4, #12]
 8021888:	f440 7080 	orr.w	r0, r0, #256	; 0x100
 802188c:	f040 0001 	orr.w	r0, r0, #1
  uint32_t vco_frequency; /* Q10.22, max VCO frequency = 520MHz */
  uint32_t kdiv_temp;

  XMC_SCU_CLOCK_SetSystemPllClockSource(source);

  if (mode == XMC_SCU_CLOCK_SYSPLL_MODE_NORMAL)
 8021890:	2901      	cmp	r1, #1
  {
    SCU_PLL->PLLCON2 &= (uint32_t)~(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
  }
  else
  {
    SCU_PLL->PLLCON2 |= (uint32_t)(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
 8021892:	60e0      	str	r0, [r4, #12]
  uint32_t vco_frequency; /* Q10.22, max VCO frequency = 520MHz */
  uint32_t kdiv_temp;

  XMC_SCU_CLOCK_SetSystemPllClockSource(source);

  if (mode == XMC_SCU_CLOCK_SYSPLL_MODE_NORMAL)
 8021894:	f000 8086 	beq.w	80219a4 <XMC_SCU_CLOCK_StartSystemPll+0x128>

    XMC_SCU_CLOCK_StepSystemPllFrequency(kdiv);
  }
  else
  {
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K1DIV_Msk) |
 8021898:	4a5e      	ldr	r2, [pc, #376]	; (8021a14 <XMC_SCU_CLOCK_StartSystemPll+0x198>)
 802189a:	6893      	ldr	r3, [r2, #8]
                       ((kdiv -1UL) << SCU_PLL_PLLCON1_K1DIV_Pos));
 802189c:	3e01      	subs	r6, #1

    XMC_SCU_CLOCK_StepSystemPllFrequency(kdiv);
  }
  else
  {
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K1DIV_Msk) |
 802189e:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80218a2:	431e      	orrs	r6, r3
 80218a4:	6096      	str	r6, [r2, #8]
                       ((kdiv -1UL) << SCU_PLL_PLLCON1_K1DIV_Pos));

    /* Switch to prescaler mode */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_VCOBYP_Msk;
 80218a6:	6853      	ldr	r3, [r2, #4]
 80218a8:	f043 0301 	orr.w	r3, r3, #1
 80218ac:	6053      	str	r3, [r2, #4]

    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOBYST_Msk) == 0U)
 80218ae:	6813      	ldr	r3, [r2, #0]
 80218b0:	07db      	lsls	r3, r3, #31
 80218b2:	d5fc      	bpl.n	80218ae <XMC_SCU_CLOCK_StartSystemPll+0x32>
    {
      /* wait for prescaler mode */
    }
  }
}
 80218b4:	b003      	add	sp, #12
 80218b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
void XMC_SCU_CLOCK_SetSystemPllClockSource(const XMC_SCU_CLOCK_SYSPLLCLKSRC_t source)
{
  /* Check input clock */
  if (source == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP) /* Select PLLClockSource */
  {
    SCU_PLL->PLLCON2 &= (uint32_t)~(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
 80218b8:	68e0      	ldr	r0, [r4, #12]
 80218ba:	f420 7080 	bic.w	r0, r0, #256	; 0x100
 80218be:	f020 0001 	bic.w	r0, r0, #1
  uint32_t vco_frequency; /* Q10.22, max VCO frequency = 520MHz */
  uint32_t kdiv_temp;

  XMC_SCU_CLOCK_SetSystemPllClockSource(source);

  if (mode == XMC_SCU_CLOCK_SYSPLL_MODE_NORMAL)
 80218c2:	2901      	cmp	r1, #1
void XMC_SCU_CLOCK_SetSystemPllClockSource(const XMC_SCU_CLOCK_SYSPLLCLKSRC_t source)
{
  /* Check input clock */
  if (source == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP) /* Select PLLClockSource */
  {
    SCU_PLL->PLLCON2 &= (uint32_t)~(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
 80218c4:	60e0      	str	r0, [r4, #12]
  uint32_t vco_frequency; /* Q10.22, max VCO frequency = 520MHz */
  uint32_t kdiv_temp;

  XMC_SCU_CLOCK_SetSystemPllClockSource(source);

  if (mode == XMC_SCU_CLOCK_SYSPLL_MODE_NORMAL)
 80218c6:	d1e7      	bne.n	8021898 <XMC_SCU_CLOCK_StartSystemPll+0x1c>
 80218c8:	e88d 000c 	stmia.w	sp, {r2, r3}
  {
    /* Calculate initial step to be close to fOFI */
    if (source == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP)
    {
      vco_frequency = (OSCHP_GetFrequency() / 1000000U) << 22;
 80218cc:	f007 f82a 	bl	8028924 <OSCHP_GetFrequency>
 80218d0:	4d51      	ldr	r5, [pc, #324]	; (8021a18 <XMC_SCU_CLOCK_StartSystemPll+0x19c>)
 80218d2:	fba5 3500 	umull	r3, r5, r5, r0
 80218d6:	e89d 000c 	ldmia.w	sp, {r2, r3}
 80218da:	0cad      	lsrs	r5, r5, #18
 80218dc:	05ad      	lsls	r5, r5, #22
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
    kdiv_temp = (vco_frequency / (OFI_FREQUENCY / 1000000U)) >> 22;

    /* Switch to prescaler mode */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_VCOBYP_Msk;
 80218de:	494d      	ldr	r1, [pc, #308]	; (8021a14 <XMC_SCU_CLOCK_StartSystemPll+0x198>)
    else
    {
      vco_frequency = (OFI_FREQUENCY / 1000000U) << 22;
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
    kdiv_temp = (vco_frequency / (OFI_FREQUENCY / 1000000U)) >> 22;
 80218e0:	4c4e      	ldr	r4, [pc, #312]	; (8021a1c <XMC_SCU_CLOCK_StartSystemPll+0x1a0>)

    /* Switch to prescaler mode */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_VCOBYP_Msk;
 80218e2:	684f      	ldr	r7, [r1, #4]

    /* disconnect Oscillator from PLL */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
 80218e4:	484e      	ldr	r0, [pc, #312]	; (8021a20 <XMC_SCU_CLOCK_StartSystemPll+0x1a4>)
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
    kdiv_temp = (vco_frequency / (OFI_FREQUENCY / 1000000U)) >> 22;

    /* Switch to prescaler mode */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_VCOBYP_Msk;
 80218e6:	f047 0701 	orr.w	r7, r7, #1
 80218ea:	604f      	str	r7, [r1, #4]

    /* disconnect Oscillator from PLL */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;
 80218ec:	684f      	ldr	r7, [r1, #4]
 80218ee:	f047 0710 	orr.w	r7, r7, #16
 80218f2:	604f      	str	r7, [r1, #4]

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
 80218f4:	f8d1 e008 	ldr.w	lr, [r1, #8]
    }
    else
    {
      vco_frequency = (OFI_FREQUENCY / 1000000U) << 22;
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
 80218f8:	fb03 f505 	mul.w	r5, r3, r5

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
                                   SCU_PLL_PLLCON1_PDIV_Msk)) | ((ndiv - 1UL) << SCU_PLL_PLLCON1_NDIV_Pos) |
                                   ((kdiv_temp - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos) |
                                   ((pdiv - 1UL)<< SCU_PLL_PLLCON1_PDIV_Pos));
 80218fc:	1e57      	subs	r7, r2, #1
    }
    else
    {
      vco_frequency = (OFI_FREQUENCY / 1000000U) << 22;
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
 80218fe:	fbb5 f5f2 	udiv	r5, r5, r2

    /* disconnect Oscillator from PLL */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
 8021902:	ea0e 0000 	and.w	r0, lr, r0
    else
    {
      vco_frequency = (OFI_FREQUENCY / 1000000U) << 22;
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
    kdiv_temp = (vco_frequency / (OFI_FREQUENCY / 1000000U)) >> 22;
 8021906:	fba4 4205 	umull	r4, r2, r4, r5
 802190a:	ea40 6007 	orr.w	r0, r0, r7, lsl #24
    /* disconnect Oscillator from PLL */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
                                   SCU_PLL_PLLCON1_PDIV_Msk)) | ((ndiv - 1UL) << SCU_PLL_PLLCON1_NDIV_Pos) |
 802190e:	1e5c      	subs	r4, r3, #1
    else
    {
      vco_frequency = (OFI_FREQUENCY / 1000000U) << 22;
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
    kdiv_temp = (vco_frequency / (OFI_FREQUENCY / 1000000U)) >> 22;
 8021910:	0e93      	lsrs	r3, r2, #26
 8021912:	ea40 2004 	orr.w	r0, r0, r4, lsl #8
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
                                   SCU_PLL_PLLCON1_PDIV_Msk)) | ((ndiv - 1UL) << SCU_PLL_PLLCON1_NDIV_Pos) |
                                   ((kdiv_temp - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos) |
 8021916:	3b01      	subs	r3, #1

    /* disconnect Oscillator from PLL */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
 8021918:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
 802191c:	608b      	str	r3, [r1, #8]
                                   SCU_PLL_PLLCON1_PDIV_Msk)) | ((ndiv - 1UL) << SCU_PLL_PLLCON1_NDIV_Pos) |
                                   ((kdiv_temp - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos) |
                                   ((pdiv - 1UL)<< SCU_PLL_PLLCON1_PDIV_Pos));

    /* Set OSCDISCDIS, OSC clock remains connected to the VCO in case of loss of lock */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_OSCDISCDIS_Msk;
 802191e:	684b      	ldr	r3, [r1, #4]
 8021920:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8021924:	604b      	str	r3, [r1, #4]

    /* connect Oscillator to PLL */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_FINDIS_Msk;
 8021926:	684b      	ldr	r3, [r1, #4]
 8021928:	f023 0310 	bic.w	r3, r3, #16
 802192c:	604b      	str	r3, [r1, #4]

    /* restart PLL Lock detection */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_RESLD_Msk;
 802192e:	684b      	ldr	r3, [r1, #4]
 8021930:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8021934:	604b      	str	r3, [r1, #4]
    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk) == 0U)
 8021936:	6808      	ldr	r0, [r1, #0]
 8021938:	4b36      	ldr	r3, [pc, #216]	; (8021a14 <XMC_SCU_CLOCK_StartSystemPll+0x198>)
 802193a:	0742      	lsls	r2, r0, #29
 802193c:	d5fb      	bpl.n	8021936 <XMC_SCU_CLOCK_StartSystemPll+0xba>
    {
      /* wait for PLL Lock */
    }

    /* Switch to normal mode */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_VCOBYP_Msk;
 802193e:	685a      	ldr	r2, [r3, #4]
 8021940:	f022 0201 	bic.w	r2, r2, #1
 8021944:	605a      	str	r2, [r3, #4]
    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOBYST_Msk) != 0U)
 8021946:	4619      	mov	r1, r3
 8021948:	680b      	ldr	r3, [r1, #0]
 802194a:	4a32      	ldr	r2, [pc, #200]	; (8021a14 <XMC_SCU_CLOCK_StartSystemPll+0x198>)
 802194c:	f013 0401 	ands.w	r4, r3, #1
 8021950:	d1fa      	bne.n	8021948 <XMC_SCU_CLOCK_StartSystemPll+0xcc>
    {
      /* wait for normal mode */
    }

    /* Ramp up PLL frequency in steps */
    kdiv_temp = (vco_frequency / 60UL) >> 22;
 8021952:	4b34      	ldr	r3, [pc, #208]	; (8021a24 <XMC_SCU_CLOCK_StartSystemPll+0x1a8>)
 8021954:	fba3 1305 	umull	r1, r3, r3, r5
 8021958:	0edb      	lsrs	r3, r3, #27
    if (kdiv < kdiv_temp)
 802195a:	429e      	cmp	r6, r3
 802195c:	d33f      	bcc.n	80219de <XMC_SCU_CLOCK_StartSystemPll+0x162>
 802195e:	4f32      	ldr	r7, [pc, #200]	; (8021a28 <XMC_SCU_CLOCK_StartSystemPll+0x1ac>)
    {
      XMC_SCU_CLOCK_StepSystemPllFrequency(kdiv_temp);
    }

    kdiv_temp = (vco_frequency / 90UL) >> 22;
 8021960:	4b32      	ldr	r3, [pc, #200]	; (8021a2c <XMC_SCU_CLOCK_StartSystemPll+0x1b0>)
 8021962:	086d      	lsrs	r5, r5, #1
 8021964:	fba3 2305 	umull	r2, r3, r3, r5
 8021968:	0edb      	lsrs	r3, r3, #27
    if (kdiv < kdiv_temp)
 802196a:	429e      	cmp	r6, r3
 802196c:	d31d      	bcc.n	80219aa <XMC_SCU_CLOCK_StartSystemPll+0x12e>
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 802196e:	4a29      	ldr	r2, [pc, #164]	; (8021a14 <XMC_SCU_CLOCK_StartSystemPll+0x198>)
 8021970:	6893      	ldr	r3, [r2, #8]
                     ((kdiv - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos));
 8021972:	3e01      	subs	r6, #1
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 8021974:	f423 03fe 	bic.w	r3, r3, #8323072	; 0x7f0000
 8021978:	ea43 4606 	orr.w	r6, r3, r6, lsl #16
 802197c:	6096      	str	r6, [r2, #8]
/* This is a local function used to generate the delay until register get updated with new configured value.  */
void XMC_SCU_lDelay(uint32_t delay)
{
  uint32_t i;

  SystemCoreClockUpdate();
 802197e:	f7fe fd69 	bl	8020454 <SystemCoreClockUpdate>
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 8021982:	683b      	ldr	r3, [r7, #0]
 8021984:	4a24      	ldr	r2, [pc, #144]	; (8021a18 <XMC_SCU_CLOCK_StartSystemPll+0x19c>)
 8021986:	fba2 3203 	umull	r3, r2, r2, r3
 802198a:	0c92      	lsrs	r2, r2, #18
 802198c:	2332      	movs	r3, #50	; 0x32
 802198e:	fb03 f202 	mul.w	r2, r3, r2

  for (i = 0U; i < delay; ++i)
 8021992:	2300      	movs	r3, #0
 8021994:	2a00      	cmp	r2, #0
 8021996:	d08d      	beq.n	80218b4 <XMC_SCU_CLOCK_StartSystemPll+0x38>
  {
    __NOP();
 8021998:	bf00      	nop
  uint32_t i;

  SystemCoreClockUpdate();
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);

  for (i = 0U; i < delay; ++i)
 802199a:	3301      	adds	r3, #1
 802199c:	4293      	cmp	r3, r2
 802199e:	d1fb      	bne.n	8021998 <XMC_SCU_CLOCK_StartSystemPll+0x11c>
    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOBYST_Msk) == 0U)
    {
      /* wait for prescaler mode */
    }
  }
}
 80219a0:	b003      	add	sp, #12
 80219a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    {
      vco_frequency = (OSCHP_GetFrequency() / 1000000U) << 22;
    }
    else
    {
      vco_frequency = (OFI_FREQUENCY / 1000000U) << 22;
 80219a4:	f04f 65c0 	mov.w	r5, #100663296	; 0x6000000
 80219a8:	e799      	b.n	80218de <XMC_SCU_CLOCK_StartSystemPll+0x62>
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 80219aa:	491a      	ldr	r1, [pc, #104]	; (8021a14 <XMC_SCU_CLOCK_StartSystemPll+0x198>)
 80219ac:	688a      	ldr	r2, [r1, #8]
                     ((kdiv - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos));
 80219ae:	3b01      	subs	r3, #1
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 80219b0:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 80219b4:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
 80219b8:	608b      	str	r3, [r1, #8]
/* This is a local function used to generate the delay until register get updated with new configured value.  */
void XMC_SCU_lDelay(uint32_t delay)
{
  uint32_t i;

  SystemCoreClockUpdate();
 80219ba:	f7fe fd4b 	bl	8020454 <SystemCoreClockUpdate>
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 80219be:	683b      	ldr	r3, [r7, #0]
 80219c0:	4a15      	ldr	r2, [pc, #84]	; (8021a18 <XMC_SCU_CLOCK_StartSystemPll+0x19c>)
 80219c2:	fba2 3203 	umull	r3, r2, r2, r3
 80219c6:	0c92      	lsrs	r2, r2, #18
 80219c8:	2332      	movs	r3, #50	; 0x32
 80219ca:	fb03 f202 	mul.w	r2, r3, r2

  for (i = 0U; i < delay; ++i)
 80219ce:	2a00      	cmp	r2, #0
 80219d0:	d0cd      	beq.n	802196e <XMC_SCU_CLOCK_StartSystemPll+0xf2>
 80219d2:	2300      	movs	r3, #0
  {
    __NOP();
 80219d4:	bf00      	nop
  uint32_t i;

  SystemCoreClockUpdate();
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);

  for (i = 0U; i < delay; ++i)
 80219d6:	3301      	adds	r3, #1
 80219d8:	4293      	cmp	r3, r2
 80219da:	d1fb      	bne.n	80219d4 <XMC_SCU_CLOCK_StartSystemPll+0x158>
 80219dc:	e7c7      	b.n	802196e <XMC_SCU_CLOCK_StartSystemPll+0xf2>
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 80219de:	6891      	ldr	r1, [r2, #8]
void XMC_SCU_lDelay(uint32_t delay)
{
  uint32_t i;

  SystemCoreClockUpdate();
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 80219e0:	4f11      	ldr	r7, [pc, #68]	; (8021a28 <XMC_SCU_CLOCK_StartSystemPll+0x1ac>)
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 80219e2:	f421 01fe 	bic.w	r1, r1, #8323072	; 0x7f0000
                     ((kdiv - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos));
 80219e6:	3b01      	subs	r3, #1
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 80219e8:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 80219ec:	6093      	str	r3, [r2, #8]
/* This is a local function used to generate the delay until register get updated with new configured value.  */
void XMC_SCU_lDelay(uint32_t delay)
{
  uint32_t i;

  SystemCoreClockUpdate();
 80219ee:	f7fe fd31 	bl	8020454 <SystemCoreClockUpdate>
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 80219f2:	683b      	ldr	r3, [r7, #0]
 80219f4:	4a08      	ldr	r2, [pc, #32]	; (8021a18 <XMC_SCU_CLOCK_StartSystemPll+0x19c>)
 80219f6:	fba2 3203 	umull	r3, r2, r2, r3
 80219fa:	0c92      	lsrs	r2, r2, #18
 80219fc:	2332      	movs	r3, #50	; 0x32
 80219fe:	fb03 f202 	mul.w	r2, r3, r2

  for (i = 0U; i < delay; ++i)
 8021a02:	2a00      	cmp	r2, #0
 8021a04:	d0ac      	beq.n	8021960 <XMC_SCU_CLOCK_StartSystemPll+0xe4>
 8021a06:	4623      	mov	r3, r4
  {
    __NOP();
 8021a08:	bf00      	nop
  uint32_t i;

  SystemCoreClockUpdate();
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);

  for (i = 0U; i < delay; ++i)
 8021a0a:	3301      	adds	r3, #1
 8021a0c:	4293      	cmp	r3, r2
 8021a0e:	d1fb      	bne.n	8021a08 <XMC_SCU_CLOCK_StartSystemPll+0x18c>
 8021a10:	e7a6      	b.n	8021960 <XMC_SCU_CLOCK_StartSystemPll+0xe4>
 8021a12:	bf00      	nop
 8021a14:	50004710 	.word	0x50004710
 8021a18:	431bde83 	.word	0x431bde83
 8021a1c:	aaaaaaab 	.word	0xaaaaaaab
 8021a20:	f08080ff 	.word	0xf08080ff
 8021a24:	88888889 	.word	0x88888889
 8021a28:	2003ffc0 	.word	0x2003ffc0
 8021a2c:	b60b60b7 	.word	0xb60b60b7

08021a30 <XMC_SCU_CLOCK_Init>:
}

/* API to select fSYS */
void XMC_SCU_CLOCK_SetSystemClockSource(const XMC_SCU_CLOCK_SYSCLKSRC_t source)
{
  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSSEL_Msk)) |
 8021a30:	4977      	ldr	r1, [pc, #476]	; (8021c10 <XMC_SCU_CLOCK_Init+0x1e0>)

/* API to power up the hibernation domain */
void XMC_SCU_HIB_EnableHibernateDomain(void)
{
  /* Power up HIB domain if and only if it is currently powered down */
  if((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 8021a32:	4a78      	ldr	r2, [pc, #480]	; (8021c14 <XMC_SCU_CLOCK_Init+0x1e4>)
}

/* API to select fSYS */
void XMC_SCU_CLOCK_SetSystemClockSource(const XMC_SCU_CLOCK_SYSCLKSRC_t source)
{
  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSSEL_Msk)) |
 8021a34:	68cb      	ldr	r3, [r1, #12]
  return (SCU_GENERAL->RMDATA);
}

/* API to initialize the clock tree */
void XMC_SCU_CLOCK_Init(const XMC_SCU_CLOCK_CONFIG_t *const config)
{
 8021a36:	b5f0      	push	{r4, r5, r6, r7, lr}
}

/* API to select fSYS */
void XMC_SCU_CLOCK_SetSystemClockSource(const XMC_SCU_CLOCK_SYSCLKSRC_t source)
{
  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSSEL_Msk)) |
 8021a38:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8021a3c:	60cb      	str	r3, [r1, #12]

/* API to power up the hibernation domain */
void XMC_SCU_HIB_EnableHibernateDomain(void)
{
  /* Power up HIB domain if and only if it is currently powered down */
  if((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 8021a3e:	6813      	ldr	r3, [r2, #0]
  return (SCU_GENERAL->RMDATA);
}

/* API to initialize the clock tree */
void XMC_SCU_CLOCK_Init(const XMC_SCU_CLOCK_CONFIG_t *const config)
{
 8021a40:	4605      	mov	r5, r0

/* API to power up the hibernation domain */
void XMC_SCU_HIB_EnableHibernateDomain(void)
{
  /* Power up HIB domain if and only if it is currently powered down */
  if((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 8021a42:	07d8      	lsls	r0, r3, #31
  return (SCU_GENERAL->RMDATA);
}

/* API to initialize the clock tree */
void XMC_SCU_CLOCK_Init(const XMC_SCU_CLOCK_CONFIG_t *const config)
{
 8021a44:	b083      	sub	sp, #12

/* API to power up the hibernation domain */
void XMC_SCU_HIB_EnableHibernateDomain(void)
{
  /* Power up HIB domain if and only if it is currently powered down */
  if((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 8021a46:	d404      	bmi.n	8021a52 <XMC_SCU_CLOCK_Init+0x22>
  {
    SCU_POWER->PWRSET = (uint32_t)SCU_POWER_PWRSET_HIB_Msk;
 8021a48:	2301      	movs	r3, #1
 8021a4a:	6053      	str	r3, [r2, #4]
    
    while((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 8021a4c:	6813      	ldr	r3, [r2, #0]
 8021a4e:	07db      	lsls	r3, r3, #31
 8021a50:	d5fc      	bpl.n	8021a4c <XMC_SCU_CLOCK_Init+0x1c>
      /* wait until HIB domain is enabled */
    }    
  }
  
  /* Remove the reset only if HIB domain were in a state of reset */
  if((SCU_RESET->RSTSTAT) & SCU_RESET_RSTSTAT_HIBRS_Msk)
 8021a52:	4a71      	ldr	r2, [pc, #452]	; (8021c18 <XMC_SCU_CLOCK_Init+0x1e8>)
 8021a54:	6813      	ldr	r3, [r2, #0]
 8021a56:	0599      	lsls	r1, r3, #22
 8021a58:	d505      	bpl.n	8021a66 <XMC_SCU_CLOCK_Init+0x36>
  {
    SCU_RESET->RSTCLR = (uint32_t)SCU_RESET_RSTCLR_HIBRS_Msk;
 8021a5a:	f44f 7300 	mov.w	r3, #512	; 0x200
 8021a5e:	6093      	str	r3, [r2, #8]
    while((SCU_RESET->RSTSTAT & SCU_RESET_RSTSTAT_HIBRS_Msk) != 0UL)
 8021a60:	6813      	ldr	r3, [r2, #0]
 8021a62:	059f      	lsls	r7, r3, #22
 8021a64:	d4fc      	bmi.n	8021a60 <XMC_SCU_CLOCK_Init+0x30>

  XMC_SCU_CLOCK_SetSystemClockSource(XMC_SCU_CLOCK_SYSCLKSRC_OFI);

  XMC_SCU_HIB_EnableHibernateDomain();

  if (config->enable_osculp == true)
 8021a66:	79eb      	ldrb	r3, [r5, #7]
 8021a68:	2b00      	cmp	r3, #0
 8021a6a:	f040 8091 	bne.w	8021b90 <XMC_SCU_CLOCK_Init+0x160>
  {
    XMC_SCU_CLOCK_EnableLowPowerOscillator();
    while (XMC_SCU_CLOCK_IsLowPowerOscillatorStable() == false);
  }
  
  XMC_SCU_HIB_SetStandbyClockSource(config->fstdby_clksrc);  
 8021a6e:	7a68      	ldrb	r0, [r5, #9]
}

/* API to select fSTDBY */
void XMC_SCU_HIB_SetStandbyClockSource(const XMC_SCU_HIB_STDBYCLKSRC_t source)
{
  while((SCU_GENERAL->MIRRSTS) & SCU_GENERAL_MIRRSTS_HDCR_Msk)
 8021a70:	4a6a      	ldr	r2, [pc, #424]	; (8021c1c <XMC_SCU_CLOCK_Init+0x1ec>)
 8021a72:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
 8021a76:	071b      	lsls	r3, r3, #28
 8021a78:	d4fb      	bmi.n	8021a72 <XMC_SCU_CLOCK_Init+0x42>
  {
    /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
  }
  SCU_HIBERNATE->HDCR = (SCU_HIBERNATE->HDCR & ((uint32_t)~SCU_HIBERNATE_HDCR_STDBYSEL_Msk)) |
 8021a7a:	4969      	ldr	r1, [pc, #420]	; (8021c20 <XMC_SCU_CLOCK_Init+0x1f0>)
 * is busy with executing the previous operation.\n
 * Note: There is no hibernate domain in XMC1x devices. This register is retained for legacy purpose.
 */
__STATIC_INLINE uint32_t XMC_SCU_GetMirrorStatus(void)
{
  return(SCU_GENERAL->MIRRSTS);
 8021a7c:	4b67      	ldr	r3, [pc, #412]	; (8021c1c <XMC_SCU_CLOCK_Init+0x1ec>)
 8021a7e:	68ca      	ldr	r2, [r1, #12]
 8021a80:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8021a84:	4302      	orrs	r2, r0
 8021a86:	60ca      	str	r2, [r1, #12]
 8021a88:	f8d3 40c4 	ldr.w	r4, [r3, #196]	; 0xc4
    XMC_SCU_CLOCK_EnableLowPowerOscillator();
    while (XMC_SCU_CLOCK_IsLowPowerOscillatorStable() == false);
  }
  
  XMC_SCU_HIB_SetStandbyClockSource(config->fstdby_clksrc);  
  while (XMC_SCU_GetMirrorStatus() != 0)
 8021a8c:	2c00      	cmp	r4, #0
 8021a8e:	d1fb      	bne.n	8021a88 <XMC_SCU_CLOCK_Init+0x58>

/* API to onfigure the calibration mode for internal oscillator */
void XMC_SCU_CLOCK_SetBackupClockCalibrationMode(XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_t mode)
{
  /* Enable factory calibration based trimming */
  SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FOTR_Msk;
 8021a90:	4a64      	ldr	r2, [pc, #400]	; (8021c24 <XMC_SCU_CLOCK_Init+0x1f4>)
  while (XMC_SCU_GetMirrorStatus() != 0)
  {
    /* Wait until update of the stanby clock source is done in the HIB domain */    
  }

  XMC_SCU_CLOCK_SetBackupClockCalibrationMode(config->calibration_mode);
 8021a92:	7a29      	ldrb	r1, [r5, #8]

/* API to onfigure the calibration mode for internal oscillator */
void XMC_SCU_CLOCK_SetBackupClockCalibrationMode(XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_t mode)
{
  /* Enable factory calibration based trimming */
  SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FOTR_Msk;
 8021a94:	6853      	ldr	r3, [r2, #4]

  if (mode == XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_AUTOMATIC)
 8021a96:	2901      	cmp	r1, #1

/* API to onfigure the calibration mode for internal oscillator */
void XMC_SCU_CLOCK_SetBackupClockCalibrationMode(XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_t mode)
{
  /* Enable factory calibration based trimming */
  SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FOTR_Msk;
 8021a98:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8021a9c:	6053      	str	r3, [r2, #4]

  if (mode == XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_AUTOMATIC)
 8021a9e:	f000 809d 	beq.w	8021bdc <XMC_SCU_CLOCK_Init+0x1ac>
 8021aa2:	4e61      	ldr	r6, [pc, #388]	; (8021c28 <XMC_SCU_CLOCK_Init+0x1f8>)
/* This is a local function used to generate the delay until register get updated with new configured value.  */
void XMC_SCU_lDelay(uint32_t delay)
{
  uint32_t i;

  SystemCoreClockUpdate();
 8021aa4:	f7fe fcd6 	bl	8020454 <SystemCoreClockUpdate>
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 8021aa8:	6833      	ldr	r3, [r6, #0]
 8021aaa:	4a60      	ldr	r2, [pc, #384]	; (8021c2c <XMC_SCU_CLOCK_Init+0x1fc>)
 8021aac:	fba2 3203 	umull	r3, r2, r2, r3
 8021ab0:	0c92      	lsrs	r2, r2, #18
 8021ab2:	2364      	movs	r3, #100	; 0x64
 8021ab4:	fb03 f202 	mul.w	r2, r3, r2

  for (i = 0U; i < delay; ++i)
 8021ab8:	b122      	cbz	r2, 8021ac4 <XMC_SCU_CLOCK_Init+0x94>
 8021aba:	2300      	movs	r3, #0
  {
    __NOP();
 8021abc:	bf00      	nop
  uint32_t i;

  SystemCoreClockUpdate();
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);

  for (i = 0U; i < delay; ++i)
 8021abe:	3301      	adds	r3, #1
 8021ac0:	4293      	cmp	r3, r2
 8021ac2:	d1fb      	bne.n	8021abc <XMC_SCU_CLOCK_Init+0x8c>
void XMC_SCU_CLOCK_SetSystemClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetSystemClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_SYSCLKCR_SYSDIV_Msk + 1UL)) );

  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSDIV_Msk)) |
 8021ac4:	4b52      	ldr	r3, [pc, #328]	; (8021c10 <XMC_SCU_CLOCK_Init+0x1e0>)
    /* Wait until update of the stanby clock source is done in the HIB domain */    
  }

  XMC_SCU_CLOCK_SetBackupClockCalibrationMode(config->calibration_mode);

  XMC_SCU_CLOCK_SetSystemClockDivider((uint32_t)config->fsys_clkdiv);
 8021ac6:	7c2c      	ldrb	r4, [r5, #16]
void XMC_SCU_CLOCK_SetSystemClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetSystemClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_SYSCLKCR_SYSDIV_Msk + 1UL)) );

  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSDIV_Msk)) |
 8021ac8:	68da      	ldr	r2, [r3, #12]
  XMC_SCU_CLOCK_SetSystemClockDivider((uint32_t)config->fsys_clkdiv);
  XMC_SCU_CLOCK_SetCpuClockDivider((uint32_t)config->fcpu_clkdiv);
  XMC_SCU_CLOCK_SetCcuClockDivider((uint32_t)config->fccu_clkdiv);
  XMC_SCU_CLOCK_SetPeripheralClockDivider((uint32_t)config->fperipheral_clkdiv);

  if (config->enable_oschp == true)
 8021aca:	79a8      	ldrb	r0, [r5, #6]
void XMC_SCU_CLOCK_SetSystemClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetSystemClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_SYSCLKCR_SYSDIV_Msk + 1UL)) );

  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSDIV_Msk)) |
 8021acc:	f022 01ff 	bic.w	r1, r2, #255	; 0xff
                      ((uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_SYSCLKCR_SYSDIV_Pos));
 8021ad0:	1e62      	subs	r2, r4, #1
void XMC_SCU_CLOCK_SetSystemClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetSystemClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_SYSCLKCR_SYSDIV_Msk + 1UL)) );

  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSDIV_Msk)) |
 8021ad2:	430a      	orrs	r2, r1
 8021ad4:	60da      	str	r2, [r3, #12]
/* API to program the divider placed between fcpu and its parent */
void XMC_SCU_CLOCK_SetCpuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetCpuClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CPUCLKCR = (SCU_CLK->CPUCLKCR & ((uint32_t)~SCU_CLK_CPUCLKCR_CPUDIV_Msk)) |
 8021ad6:	691a      	ldr	r2, [r3, #16]
  }

  XMC_SCU_CLOCK_SetBackupClockCalibrationMode(config->calibration_mode);

  XMC_SCU_CLOCK_SetSystemClockDivider((uint32_t)config->fsys_clkdiv);
  XMC_SCU_CLOCK_SetCpuClockDivider((uint32_t)config->fcpu_clkdiv);
 8021ad8:	7c6c      	ldrb	r4, [r5, #17]
/* API to program the divider placed between fcpu and its parent */
void XMC_SCU_CLOCK_SetCpuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetCpuClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CPUCLKCR = (SCU_CLK->CPUCLKCR & ((uint32_t)~SCU_CLK_CPUCLKCR_CPUDIV_Msk)) |
 8021ada:	f022 0101 	bic.w	r1, r2, #1
                      (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_CPUCLKCR_CPUDIV_Pos);
 8021ade:	1e62      	subs	r2, r4, #1
/* API to program the divider placed between fcpu and its parent */
void XMC_SCU_CLOCK_SetCpuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetCpuClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CPUCLKCR = (SCU_CLK->CPUCLKCR & ((uint32_t)~SCU_CLK_CPUCLKCR_CPUDIV_Msk)) |
 8021ae0:	430a      	orrs	r2, r1
 8021ae2:	611a      	str	r2, [r3, #16]
/* API to program the divider placed between fccu and its parent */
void XMC_SCU_CLOCK_SetCcuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetCapcomClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CCUCLKCR = (SCU_CLK->CCUCLKCR & ((uint32_t)~SCU_CLK_CCUCLKCR_CCUDIV_Msk)) |
 8021ae4:	6a1a      	ldr	r2, [r3, #32]

  XMC_SCU_CLOCK_SetBackupClockCalibrationMode(config->calibration_mode);

  XMC_SCU_CLOCK_SetSystemClockDivider((uint32_t)config->fsys_clkdiv);
  XMC_SCU_CLOCK_SetCpuClockDivider((uint32_t)config->fcpu_clkdiv);
  XMC_SCU_CLOCK_SetCcuClockDivider((uint32_t)config->fccu_clkdiv);
 8021ae6:	7cac      	ldrb	r4, [r5, #18]
/* API to program the divider placed between fccu and its parent */
void XMC_SCU_CLOCK_SetCcuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetCapcomClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CCUCLKCR = (SCU_CLK->CCUCLKCR & ((uint32_t)~SCU_CLK_CCUCLKCR_CCUDIV_Msk)) |
 8021ae8:	f022 0101 	bic.w	r1, r2, #1
                      (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_CCUCLKCR_CCUDIV_Pos);
 8021aec:	1e62      	subs	r2, r4, #1
/* API to program the divider placed between fccu and its parent */
void XMC_SCU_CLOCK_SetCcuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetCapcomClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CCUCLKCR = (SCU_CLK->CCUCLKCR & ((uint32_t)~SCU_CLK_CCUCLKCR_CCUDIV_Msk)) |
 8021aee:	430a      	orrs	r2, r1
 8021af0:	621a      	str	r2, [r3, #32]
/* API to program the divider placed between fperiph and its parent */
void XMC_SCU_CLOCK_SetPeripheralClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetPeripheralClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->PBCLKCR = (SCU_CLK->PBCLKCR & ((uint32_t)~SCU_CLK_PBCLKCR_PBDIV_Msk)) |
 8021af2:	695a      	ldr	r2, [r3, #20]
  XMC_SCU_CLOCK_SetBackupClockCalibrationMode(config->calibration_mode);

  XMC_SCU_CLOCK_SetSystemClockDivider((uint32_t)config->fsys_clkdiv);
  XMC_SCU_CLOCK_SetCpuClockDivider((uint32_t)config->fcpu_clkdiv);
  XMC_SCU_CLOCK_SetCcuClockDivider((uint32_t)config->fccu_clkdiv);
  XMC_SCU_CLOCK_SetPeripheralClockDivider((uint32_t)config->fperipheral_clkdiv);
 8021af4:	7cec      	ldrb	r4, [r5, #19]
/* API to program the divider placed between fperiph and its parent */
void XMC_SCU_CLOCK_SetPeripheralClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetPeripheralClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->PBCLKCR = (SCU_CLK->PBCLKCR & ((uint32_t)~SCU_CLK_PBCLKCR_PBDIV_Msk)) |
 8021af6:	f022 0101 	bic.w	r1, r2, #1
                     ((uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_PBCLKCR_PBDIV_Pos));
 8021afa:	1e62      	subs	r2, r4, #1
/* API to program the divider placed between fperiph and its parent */
void XMC_SCU_CLOCK_SetPeripheralClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetPeripheralClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->PBCLKCR = (SCU_CLK->PBCLKCR & ((uint32_t)~SCU_CLK_PBCLKCR_PBDIV_Msk)) |
 8021afc:	430a      	orrs	r2, r1
 8021afe:	615a      	str	r2, [r3, #20]
  XMC_SCU_CLOCK_SetSystemClockDivider((uint32_t)config->fsys_clkdiv);
  XMC_SCU_CLOCK_SetCpuClockDivider((uint32_t)config->fcpu_clkdiv);
  XMC_SCU_CLOCK_SetCcuClockDivider((uint32_t)config->fccu_clkdiv);
  XMC_SCU_CLOCK_SetPeripheralClockDivider((uint32_t)config->fperipheral_clkdiv);

  if (config->enable_oschp == true)
 8021b00:	bb28      	cbnz	r0, 8021b4e <XMC_SCU_CLOCK_Init+0x11e>
  {
    XMC_SCU_CLOCK_EnableHighPerformanceOscillator();
    while(XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable() == false);
  }

  if (config->syspll_config.mode == XMC_SCU_CLOCK_SYSPLL_MODE_DISABLED)
 8021b02:	78e9      	ldrb	r1, [r5, #3]
 8021b04:	b9a1      	cbnz	r1, 8021b30 <XMC_SCU_CLOCK_Init+0x100>
}

/* API to disable main PLL */
void XMC_SCU_CLOCK_DisableSystemPll(void)
{
  SCU_PLL->PLLCON0 |= (uint32_t)(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk);
 8021b06:	4a47      	ldr	r2, [pc, #284]	; (8021c24 <XMC_SCU_CLOCK_Init+0x1f4>)
 8021b08:	6853      	ldr	r3, [r2, #4]
 8021b0a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8021b0e:	f043 0302 	orr.w	r3, r3, #2
 8021b12:	6053      	str	r3, [r2, #4]
                                 (uint32_t)config->syspll_config.n_div,
                                 (uint32_t)config->syspll_config.k_div);
  }

  /* use SYSPLL? */
  if (config->fsys_clksrc == XMC_SCU_CLOCK_SYSCLKSRC_PLL)
 8021b14:	68eb      	ldr	r3, [r5, #12]
 8021b16:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8021b1a:	d104      	bne.n	8021b26 <XMC_SCU_CLOCK_Init+0xf6>
}

/* API to select fSYS */
void XMC_SCU_CLOCK_SetSystemClockSource(const XMC_SCU_CLOCK_SYSCLKSRC_t source)
{
  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSSEL_Msk)) |
 8021b1c:	4a3c      	ldr	r2, [pc, #240]	; (8021c10 <XMC_SCU_CLOCK_Init+0x1e0>)
 8021b1e:	68d3      	ldr	r3, [r2, #12]
 8021b20:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8021b24:	60d3      	str	r3, [r2, #12]
  if (config->fsys_clksrc == XMC_SCU_CLOCK_SYSCLKSRC_PLL)
  {
    XMC_SCU_CLOCK_SetSystemClockSource(XMC_SCU_CLOCK_SYSCLKSRC_PLL);    
  }
  SystemCoreClockUpdate();
}
 8021b26:	b003      	add	sp, #12
 8021b28:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  /* use SYSPLL? */
  if (config->fsys_clksrc == XMC_SCU_CLOCK_SYSCLKSRC_PLL)
  {
    XMC_SCU_CLOCK_SetSystemClockSource(XMC_SCU_CLOCK_SYSCLKSRC_PLL);    
  }
  SystemCoreClockUpdate();
 8021b2c:	f7fe bc92 	b.w	8020454 <SystemCoreClockUpdate>
}

/* API to enable main PLL */
void XMC_SCU_CLOCK_EnableSystemPll(void)
{
  SCU_PLL->PLLCON0 &= (uint32_t)~(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk);
 8021b30:	4a3c      	ldr	r2, [pc, #240]	; (8021c24 <XMC_SCU_CLOCK_Init+0x1f4>)
  }
  else
  {

    XMC_SCU_CLOCK_EnableSystemPll();
    XMC_SCU_CLOCK_StartSystemPll(config->syspll_config.clksrc,
 8021b32:	88a8      	ldrh	r0, [r5, #4]
}

/* API to enable main PLL */
void XMC_SCU_CLOCK_EnableSystemPll(void)
{
  SCU_PLL->PLLCON0 &= (uint32_t)~(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk);
 8021b34:	6853      	ldr	r3, [r2, #4]
 8021b36:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8021b3a:	f023 0302 	bic.w	r3, r3, #2
 8021b3e:	6053      	str	r3, [r2, #4]
  }
  else
  {

    XMC_SCU_CLOCK_EnableSystemPll();
    XMC_SCU_CLOCK_StartSystemPll(config->syspll_config.clksrc,
 8021b40:	78ac      	ldrb	r4, [r5, #2]
 8021b42:	786a      	ldrb	r2, [r5, #1]
 8021b44:	782b      	ldrb	r3, [r5, #0]
 8021b46:	9400      	str	r4, [sp, #0]
 8021b48:	f7ff fe98 	bl	802187c <XMC_SCU_CLOCK_StartSystemPll>
 8021b4c:	e7e2      	b.n	8021b14 <XMC_SCU_CLOCK_Init+0xe4>
}

/* API to enable High Precision High Speed oscillator */
void XMC_SCU_CLOCK_EnableHighPerformanceOscillator(void)
{
  SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_PLLPWD_Msk;
 8021b4e:	4c35      	ldr	r4, [pc, #212]	; (8021c24 <XMC_SCU_CLOCK_Init+0x1f4>)

  SCU_OSC->OSCHPCTRL = (uint32_t)((SCU_OSC->OSCHPCTRL & ~(SCU_OSC_OSCHPCTRL_MODE_Msk | SCU_OSC_OSCHPCTRL_OSCVAL_Msk)) |
 8021b50:	4f37      	ldr	r7, [pc, #220]	; (8021c30 <XMC_SCU_CLOCK_Init+0x200>)
}

/* API to enable High Precision High Speed oscillator */
void XMC_SCU_CLOCK_EnableHighPerformanceOscillator(void)
{
  SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_PLLPWD_Msk;
 8021b52:	6863      	ldr	r3, [r4, #4]
 8021b54:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8021b58:	6063      	str	r3, [r4, #4]

  SCU_OSC->OSCHPCTRL = (uint32_t)((SCU_OSC->OSCHPCTRL & ~(SCU_OSC_OSCHPCTRL_MODE_Msk | SCU_OSC_OSCHPCTRL_OSCVAL_Msk)) |
 8021b5a:	687e      	ldr	r6, [r7, #4]
                                  (((OSCHP_GetFrequency() / FOSCREF) - 1UL) << SCU_OSC_OSCHPCTRL_OSCVAL_Pos));
 8021b5c:	f006 fee2 	bl	8028924 <OSCHP_GetFrequency>
 8021b60:	4a34      	ldr	r2, [pc, #208]	; (8021c34 <XMC_SCU_CLOCK_Init+0x204>)
 8021b62:	fba2 3200 	umull	r3, r2, r2, r0
 8021b66:	0d12      	lsrs	r2, r2, #20
/* API to enable High Precision High Speed oscillator */
void XMC_SCU_CLOCK_EnableHighPerformanceOscillator(void)
{
  SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_PLLPWD_Msk;

  SCU_OSC->OSCHPCTRL = (uint32_t)((SCU_OSC->OSCHPCTRL & ~(SCU_OSC_OSCHPCTRL_MODE_Msk | SCU_OSC_OSCHPCTRL_OSCVAL_Msk)) |
 8021b68:	f426 2370 	bic.w	r3, r6, #983040	; 0xf0000
                                  (((OSCHP_GetFrequency() / FOSCREF) - 1UL) << SCU_OSC_OSCHPCTRL_OSCVAL_Pos));
 8021b6c:	3a01      	subs	r2, #1
/* API to enable High Precision High Speed oscillator */
void XMC_SCU_CLOCK_EnableHighPerformanceOscillator(void)
{
  SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_PLLPWD_Msk;

  SCU_OSC->OSCHPCTRL = (uint32_t)((SCU_OSC->OSCHPCTRL & ~(SCU_OSC_OSCHPCTRL_MODE_Msk | SCU_OSC_OSCHPCTRL_OSCVAL_Msk)) |
 8021b6e:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 8021b72:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8021b76:	607b      	str	r3, [r7, #4]
                                  (((OSCHP_GetFrequency() / FOSCREF) - 1UL) << SCU_OSC_OSCHPCTRL_OSCVAL_Pos));

  /* restart OSC Watchdog */
  SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_OSCRES_Msk;
 8021b78:	6863      	ldr	r3, [r4, #4]
 8021b7a:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8021b7e:	6063      	str	r3, [r4, #4]
}

bool XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable(void)
{
  return ((SCU_PLL->PLLSTAT & XMC_SCU_PLL_PLLSTAT_OSC_USABLE) == XMC_SCU_PLL_PLLSTAT_OSC_USABLE);
 8021b80:	4622      	mov	r2, r4
 8021b82:	6813      	ldr	r3, [r2, #0]
 8021b84:	f403 7360 	and.w	r3, r3, #896	; 0x380
  XMC_SCU_CLOCK_SetPeripheralClockDivider((uint32_t)config->fperipheral_clkdiv);

  if (config->enable_oschp == true)
  {
    XMC_SCU_CLOCK_EnableHighPerformanceOscillator();
    while(XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable() == false);
 8021b88:	f5b3 7f60 	cmp.w	r3, #896	; 0x380
 8021b8c:	d1f9      	bne.n	8021b82 <XMC_SCU_CLOCK_Init+0x152>
 8021b8e:	e7b8      	b.n	8021b02 <XMC_SCU_CLOCK_Init+0xd2>

/* API to configure the 32khz Ultra Low Power oscillator */
void XMC_SCU_CLOCK_EnableLowPowerOscillator(void)
{
  /* Enable OSC_ULP */
  while((SCU_GENERAL->MIRRSTS) & SCU_GENERAL_MIRRSTS_OSCULCTRL_Msk)
 8021b90:	4a22      	ldr	r2, [pc, #136]	; (8021c1c <XMC_SCU_CLOCK_Init+0x1ec>)
 8021b92:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
 8021b96:	061e      	lsls	r6, r3, #24
 8021b98:	d4fb      	bmi.n	8021b92 <XMC_SCU_CLOCK_Init+0x162>
  {
    /* Wait until no pending update to OSCULCTRL register in hibernate domain */
  }
  SCU_HIBERNATE->OSCULCTRL &= ~SCU_HIBERNATE_OSCULCTRL_MODE_Msk;
 8021b9a:	4921      	ldr	r1, [pc, #132]	; (8021c20 <XMC_SCU_CLOCK_Init+0x1f0>)

  /* Enable OSC_ULP Oscillator Watchdog*/
  while (SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_HDCR_Msk)
 8021b9c:	4a1f      	ldr	r2, [pc, #124]	; (8021c1c <XMC_SCU_CLOCK_Init+0x1ec>)
  /* Enable OSC_ULP */
  while((SCU_GENERAL->MIRRSTS) & SCU_GENERAL_MIRRSTS_OSCULCTRL_Msk)
  {
    /* Wait until no pending update to OSCULCTRL register in hibernate domain */
  }
  SCU_HIBERNATE->OSCULCTRL &= ~SCU_HIBERNATE_OSCULCTRL_MODE_Msk;
 8021b9e:	69cb      	ldr	r3, [r1, #28]
 8021ba0:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 8021ba4:	61cb      	str	r3, [r1, #28]

  /* Enable OSC_ULP Oscillator Watchdog*/
  while (SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_HDCR_Msk)
 8021ba6:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
 8021baa:	071c      	lsls	r4, r3, #28
 8021bac:	d4fb      	bmi.n	8021ba6 <XMC_SCU_CLOCK_Init+0x176>
  {
    /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
  }
  SCU_HIBERNATE->HDCR |= (uint32_t)SCU_HIBERNATE_HDCR_ULPWDGEN_Msk;
 8021bae:	491c      	ldr	r1, [pc, #112]	; (8021c20 <XMC_SCU_CLOCK_Init+0x1f0>)

  /* Enable OSC_ULP Oscillator Watchdog*/
  while (SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_HDSET_Msk)
 8021bb0:	4a1a      	ldr	r2, [pc, #104]	; (8021c1c <XMC_SCU_CLOCK_Init+0x1ec>)
  /* Enable OSC_ULP Oscillator Watchdog*/
  while (SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_HDCR_Msk)
  {
    /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
  }
  SCU_HIBERNATE->HDCR |= (uint32_t)SCU_HIBERNATE_HDCR_ULPWDGEN_Msk;
 8021bb2:	68cb      	ldr	r3, [r1, #12]
 8021bb4:	f043 0308 	orr.w	r3, r3, #8
 8021bb8:	60cb      	str	r3, [r1, #12]

  /* Enable OSC_ULP Oscillator Watchdog*/
  while (SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_HDSET_Msk)
 8021bba:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
 8021bbe:	0758      	lsls	r0, r3, #29
 8021bc0:	d4fb      	bmi.n	8021bba <XMC_SCU_CLOCK_Init+0x18a>
  {
    /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
  }
  SCU_HIBERNATE->HDSET = (uint32_t)SCU_HIBERNATE_HDSET_ULPWDG_Msk;
 8021bc2:	4b17      	ldr	r3, [pc, #92]	; (8021c20 <XMC_SCU_CLOCK_Init+0x1f0>)
 8021bc4:	4a15      	ldr	r2, [pc, #84]	; (8021c1c <XMC_SCU_CLOCK_Init+0x1ec>)
 8021bc6:	2108      	movs	r1, #8
 8021bc8:	6099      	str	r1, [r3, #8]
 8021bca:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4

  while (XMC_SCU_GetMirrorStatus() != 0)
 8021bce:	2b00      	cmp	r3, #0
 8021bd0:	d1fb      	bne.n	8021bca <XMC_SCU_CLOCK_Init+0x19a>

#endif

bool XMC_SCU_CLOCK_IsLowPowerOscillatorStable(void)
{
  return ((SCU_HIBERNATE->HDSTAT & SCU_HIBERNATE_HDSTAT_ULPWDG_Msk) == 0UL);
 8021bd2:	4a13      	ldr	r2, [pc, #76]	; (8021c20 <XMC_SCU_CLOCK_Init+0x1f0>)
 8021bd4:	6813      	ldr	r3, [r2, #0]
  XMC_SCU_HIB_EnableHibernateDomain();

  if (config->enable_osculp == true)
  {
    XMC_SCU_CLOCK_EnableLowPowerOscillator();
    while (XMC_SCU_CLOCK_IsLowPowerOscillatorStable() == false);
 8021bd6:	0719      	lsls	r1, r3, #28
 8021bd8:	d4fc      	bmi.n	8021bd4 <XMC_SCU_CLOCK_Init+0x1a4>
 8021bda:	e748      	b.n	8021a6e <XMC_SCU_CLOCK_Init+0x3e>
  SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FOTR_Msk;

  if (mode == XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_AUTOMATIC)
  {
    /* Disable factory calibration based trimming */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_FOTR_Msk;
 8021bdc:	6853      	ldr	r3, [r2, #4]
void XMC_SCU_lDelay(uint32_t delay)
{
  uint32_t i;

  SystemCoreClockUpdate();
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 8021bde:	4e12      	ldr	r6, [pc, #72]	; (8021c28 <XMC_SCU_CLOCK_Init+0x1f8>)
  SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FOTR_Msk;

  if (mode == XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_AUTOMATIC)
  {
    /* Disable factory calibration based trimming */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_FOTR_Msk;
 8021be0:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 8021be4:	6053      	str	r3, [r2, #4]
/* This is a local function used to generate the delay until register get updated with new configured value.  */
void XMC_SCU_lDelay(uint32_t delay)
{
  uint32_t i;

  SystemCoreClockUpdate();
 8021be6:	f7fe fc35 	bl	8020454 <SystemCoreClockUpdate>
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 8021bea:	4a10      	ldr	r2, [pc, #64]	; (8021c2c <XMC_SCU_CLOCK_Init+0x1fc>)
 8021bec:	6833      	ldr	r3, [r6, #0]
 8021bee:	fba2 2303 	umull	r2, r3, r2, r3
 8021bf2:	0c9a      	lsrs	r2, r3, #18
 8021bf4:	2364      	movs	r3, #100	; 0x64
 8021bf6:	fb03 f302 	mul.w	r3, r3, r2

  for (i = 0U; i < delay; ++i)
 8021bfa:	b11b      	cbz	r3, 8021c04 <XMC_SCU_CLOCK_Init+0x1d4>
  {
    __NOP();
 8021bfc:	bf00      	nop
  uint32_t i;

  SystemCoreClockUpdate();
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);

  for (i = 0U; i < delay; ++i)
 8021bfe:	3401      	adds	r4, #1
 8021c00:	429c      	cmp	r4, r3
 8021c02:	d1fb      	bne.n	8021bfc <XMC_SCU_CLOCK_Init+0x1cc>
    /* Disable factory calibration based trimming */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_FOTR_Msk;
    XMC_SCU_lDelay(100UL);

    /* Enable automatic calibration */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_AOTREN_Msk;
 8021c04:	4a07      	ldr	r2, [pc, #28]	; (8021c24 <XMC_SCU_CLOCK_Init+0x1f4>)
 8021c06:	6853      	ldr	r3, [r2, #4]
 8021c08:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8021c0c:	6053      	str	r3, [r2, #4]
 8021c0e:	e749      	b.n	8021aa4 <XMC_SCU_CLOCK_Init+0x74>
 8021c10:	50004600 	.word	0x50004600
 8021c14:	50004200 	.word	0x50004200
 8021c18:	50004400 	.word	0x50004400
 8021c1c:	50004000 	.word	0x50004000
 8021c20:	50004300 	.word	0x50004300
 8021c24:	50004710 	.word	0x50004710
 8021c28:	2003ffc0 	.word	0x2003ffc0
 8021c2c:	431bde83 	.word	0x431bde83
 8021c30:	50004700 	.word	0x50004700
 8021c34:	6b5fca6b 	.word	0x6b5fca6b

08021c38 <XMC_CCU4_Init>:
#endif
}

/* API to initialize CCU4 global resources  */
void XMC_CCU4_Init(XMC_CCU4_MODULE_t *const module, const XMC_CCU4_SLICE_MCMS_ACTION_t mcs_action)
{
 8021c38:	b538      	push	{r3, r4, r5, lr}
 8021c3a:	4604      	mov	r4, r0
{
  XMC_ASSERT("XMC_CCU4_EnableModule:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));

#if UC_FAMILY == XMC4
  /* Enable CCU4 module clock */
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_CCU);
 8021c3c:	2010      	movs	r0, #16
#endif
}

/* API to initialize CCU4 global resources  */
void XMC_CCU4_Init(XMC_CCU4_MODULE_t *const module, const XMC_CCU4_SLICE_MCMS_ACTION_t mcs_action)
{
 8021c3e:	460d      	mov	r5, r1
{
  XMC_ASSERT("XMC_CCU4_EnableModule:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));

#if UC_FAMILY == XMC4
  /* Enable CCU4 module clock */
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_CCU);
 8021c40:	f7ff fdbc 	bl	80217bc <XMC_SCU_CLOCK_EnableClock>
  }
}

__STATIC_INLINE void XMC_CCU4_lUngateClock(const XMC_CCU4_MODULE_t *const module)
{
  if (module == CCU40)
 8021c44:	4b19      	ldr	r3, [pc, #100]	; (8021cac <XMC_CCU4_Init+0x74>)
 8021c46:	429c      	cmp	r4, r3
 8021c48:	d01a      	beq.n	8021c80 <XMC_CCU4_Init+0x48>
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU40);
  }
#if defined(CCU41)
  else if (module == CCU41)
 8021c4a:	4b19      	ldr	r3, [pc, #100]	; (8021cb0 <XMC_CCU4_Init+0x78>)
 8021c4c:	429c      	cmp	r4, r3
 8021c4e:	d01e      	beq.n	8021c8e <XMC_CCU4_Init+0x56>
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU41);
  }
#endif
#if defined(CCU42)
  else if (module == CCU42)
 8021c50:	4b18      	ldr	r3, [pc, #96]	; (8021cb4 <XMC_CCU4_Init+0x7c>)
 8021c52:	429c      	cmp	r4, r3
 8021c54:	d022      	beq.n	8021c9c <XMC_CCU4_Init+0x64>
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU42);
  }
#endif
#if defined(CCU43)
  else if (module == CCU43)
 8021c56:	4b18      	ldr	r3, [pc, #96]	; (8021cb8 <XMC_CCU4_Init+0x80>)
 8021c58:	429c      	cmp	r4, r3
 8021c5a:	d00a      	beq.n	8021c72 <XMC_CCU4_Init+0x3a>
 * XMC_CCU4_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU4_StartPrescaler(XMC_CCU4_MODULE_t *const module)
{
  XMC_ASSERT("XMC_CCU4_StartPrescaler:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  module->GIDLC |= (uint32_t) CCU4_GIDLC_SPRB_Msk;
 8021c5c:	68e3      	ldr	r3, [r4, #12]
 8021c5e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8021c62:	60e3      	str	r3, [r4, #12]
  /* Enable CCU4 module */
  XMC_CCU4_EnableModule(module);
  /* Start the prescaler */
  XMC_CCU4_StartPrescaler(module);
  
  gctrl = module->GCTRL;
 8021c64:	6821      	ldr	r1, [r4, #0]
  gctrl &= ~((uint32_t) CCU4_GCTRL_MSDE_Msk);
 8021c66:	f421 4140 	bic.w	r1, r1, #49152	; 0xc000
  gctrl |= ((uint32_t) mcs_action) << CCU4_GCTRL_MSDE_Pos;
 8021c6a:	ea41 3185 	orr.w	r1, r1, r5, lsl #14
  
  module->GCTRL = gctrl;
 8021c6e:	6021      	str	r1, [r4, #0]
 8021c70:	bd38      	pop	{r3, r4, r5, pc}
  }
#endif
#if defined(CCU43)
  else if (module == CCU43)
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU43);
 8021c72:	4812      	ldr	r0, [pc, #72]	; (8021cbc <XMC_CCU4_Init+0x84>)
 8021c74:	f7ff fdb4 	bl	80217e0 <XMC_SCU_CLOCK_UngatePeripheralClock>
  }
#endif
#if defined(CCU43)
  else if (module == CCU43)
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU43);
 8021c78:	4810      	ldr	r0, [pc, #64]	; (8021cbc <XMC_CCU4_Init+0x84>)
 8021c7a:	f7ff fd41 	bl	8021700 <XMC_SCU_RESET_DeassertPeripheralReset>
 8021c7e:	e7ed      	b.n	8021c5c <XMC_CCU4_Init+0x24>

__STATIC_INLINE void XMC_CCU4_lUngateClock(const XMC_CCU4_MODULE_t *const module)
{
  if (module == CCU40)
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU40);
 8021c80:	2004      	movs	r0, #4
 8021c82:	f7ff fdad 	bl	80217e0 <XMC_SCU_CLOCK_UngatePeripheralClock>

__STATIC_INLINE void XMC_CCU4_lDeassertReset(const XMC_CCU4_MODULE_t *const module)
{
  if (module == CCU40)
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU40);
 8021c86:	2004      	movs	r0, #4
 8021c88:	f7ff fd3a 	bl	8021700 <XMC_SCU_RESET_DeassertPeripheralReset>
 8021c8c:	e7e6      	b.n	8021c5c <XMC_CCU4_Init+0x24>
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU40);
  }
#if defined(CCU41)
  else if (module == CCU41)
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU41);
 8021c8e:	2008      	movs	r0, #8
 8021c90:	f7ff fda6 	bl	80217e0 <XMC_SCU_CLOCK_UngatePeripheralClock>
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU40);
  }
#if defined(CCU41)
  else if (module == CCU41)
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU41);
 8021c94:	2008      	movs	r0, #8
 8021c96:	f7ff fd33 	bl	8021700 <XMC_SCU_RESET_DeassertPeripheralReset>
 8021c9a:	e7df      	b.n	8021c5c <XMC_CCU4_Init+0x24>
  }
#endif
#if defined(CCU42)
  else if (module == CCU42)
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU42);
 8021c9c:	2010      	movs	r0, #16
 8021c9e:	f7ff fd9f 	bl	80217e0 <XMC_SCU_CLOCK_UngatePeripheralClock>
  }
#endif
#if defined(CCU42)
  else if (module == CCU42)
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU42);
 8021ca2:	2010      	movs	r0, #16
 8021ca4:	f7ff fd2c 	bl	8021700 <XMC_SCU_RESET_DeassertPeripheralReset>
 8021ca8:	e7d8      	b.n	8021c5c <XMC_CCU4_Init+0x24>
 8021caa:	bf00      	nop
 8021cac:	4000c000 	.word	0x4000c000
 8021cb0:	40010000 	.word	0x40010000
 8021cb4:	40014000 	.word	0x40014000
 8021cb8:	48004000 	.word	0x48004000
 8021cbc:	10000001 	.word	0x10000001

08021cc0 <XMC_CCU4_SetMultiChannelShadowTransferMode>:
{
  uint32_t gctrl;

  XMC_ASSERT("XMC_CCU4_SetMultiChannelShadowTransferMode:Invalid module Pointer", XMC_CCU4_IsValidModule(module));
  
  gctrl = module->GCTRL;
 8021cc0:	6802      	ldr	r2, [r0, #0]
  gctrl &= ~((uint32_t)slice_mode_msk >> 16U);
  gctrl |= ((uint32_t)slice_mode_msk & 0xFFFFU);
 8021cc2:	b28b      	uxth	r3, r1
  uint32_t gctrl;

  XMC_ASSERT("XMC_CCU4_SetMultiChannelShadowTransferMode:Invalid module Pointer", XMC_CCU4_IsValidModule(module));
  
  gctrl = module->GCTRL;
  gctrl &= ~((uint32_t)slice_mode_msk >> 16U);
 8021cc4:	ea22 4111 	bic.w	r1, r2, r1, lsr #16
  gctrl |= ((uint32_t)slice_mode_msk & 0xFFFFU);
 8021cc8:	4319      	orrs	r1, r3
  module->GCTRL = gctrl;
 8021cca:	6001      	str	r1, [r0, #0]
 8021ccc:	4770      	bx	lr
 8021cce:	bf00      	nop

08021cd0 <XMC_CCU4_SLICE_CompareInit>:
}

/* API to configure CC4 Slice as Timer */
void XMC_CCU4_SLICE_CompareInit(XMC_CCU4_SLICE_t *const slice,
                                const XMC_CCU4_SLICE_COMPARE_CONFIG_t *const compare_init)
{
 8021cd0:	b470      	push	{r4, r5, r6}
             (XMC_CCU4_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);

  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t) compare_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
 8021cd2:	794b      	ldrb	r3, [r1, #5]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 8021cd4:	790e      	ldrb	r6, [r1, #4]
  XMC_ASSERT("XMC_CCU4_SLICE_CompareInit:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_CompareInit:Compare Init Pointer is NULL",
             (XMC_CCU4_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);

  /* Program the timer mode */
  slice->TC = compare_init->tc;
 8021cd6:	6809      	ldr	r1, [r1, #0]
 8021cd8:	6141      	str	r1, [r0, #20]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
 8021cda:	461c      	mov	r4, r3
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t) compare_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 8021cdc:	461d      	mov	r5, r3
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 8021cde:	4632      	mov	r2, r6
             (XMC_CCU4_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);

  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t) compare_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
 8021ce0:	f3c3 1340 	ubfx	r3, r3, #5, #1
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 8021ce4:	f006 060f 	and.w	r6, r6, #15
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 8021ce8:	f005 050f 	and.w	r5, r5, #15
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
 8021cec:	f3c4 1100 	ubfx	r1, r4, #4, #1
             (XMC_CCU4_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);

  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t) compare_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
 8021cf0:	051b      	lsls	r3, r3, #20
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 8021cf2:	0912      	lsrs	r2, r2, #4
             (XMC_CCU4_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);

  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t) compare_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
 8021cf4:	6043      	str	r3, [r0, #4]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 8021cf6:	6246      	str	r6, [r0, #36]	; 0x24
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 8021cf8:	6205      	str	r5, [r0, #32]
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
 8021cfa:	6181      	str	r1, [r0, #24]
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
}
 8021cfc:	bc70      	pop	{r4, r5, r6}
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 8021cfe:	62c2      	str	r2, [r0, #44]	; 0x2c
}
 8021d00:	4770      	bx	lr
 8021d02:	bf00      	nop

08021d04 <XMC_CCU4_SLICE_StartConfig>:
  XMC_ASSERT("XMC_CCU4_SLICE_StartConfig:Invalid Event ID", XMC_CCU4_SLICE_CHECK_EVENT_ID(event));
  XMC_ASSERT("XMC_CCU4_SLICE_StartConfig:Invalid Start Mode", 
             ((start_mode == XMC_CCU4_SLICE_START_MODE_TIMER_START_CLEAR) ||\
              (start_mode == XMC_CCU4_SLICE_START_MODE_TIMER_START)));
  /* First, Bind the event with the stop function */
  cmc = slice->CMC;
 8021d04:	6843      	ldr	r3, [r0, #4]
  cmc &= ~((uint32_t) CCU4_CC4_CMC_STRTS_Msk);
 8021d06:	f023 0303 	bic.w	r3, r3, #3
  cmc |= ((uint32_t) event) << CCU4_CC4_CMC_STRTS_Pos;
 8021d0a:	4319      	orrs	r1, r3

  slice->CMC = cmc;
 8021d0c:	6041      	str	r1, [r0, #4]
  
  tc  = slice->TC;
 8021d0e:	6943      	ldr	r3, [r0, #20]
  /* Next, Configure the start mode */
  if (start_mode == XMC_CCU4_SLICE_START_MODE_TIMER_START_CLEAR)
 8021d10:	2a01      	cmp	r2, #1
  {
    tc |= (uint32_t)CCU4_CC4_TC_STRM_Msk;
 8021d12:	bf0c      	ite	eq
 8021d14:	f443 6380 	orreq.w	r3, r3, #1024	; 0x400
  }
  else
  {
    tc &= ~((uint32_t)CCU4_CC4_TC_STRM_Msk);
 8021d18:	f423 6380 	bicne.w	r3, r3, #1024	; 0x400
  }
  
  slice->TC = tc;
 8021d1c:	6143      	str	r3, [r0, #20]
 8021d1e:	4770      	bx	lr

08021d20 <XMC_CCU4_SLICE_StopConfig>:
  XMC_ASSERT("XMC_CCU4_SLICE_StopConfig:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_StopConfig:Invalid Event ID", XMC_CCU4_SLICE_CHECK_EVENT_ID(event));
  XMC_ASSERT("XMC_CCU4_SLICE_StopConfig:Invalid Start Mode", XMC_CCU4_CHECK_END_MODE(end_mode));
  
  /* First, Bind the event with the stop function */
  cmc = slice->CMC;
 8021d20:	6843      	ldr	r3, [r0, #4]
  cmc &= ~((uint32_t) CCU4_CC4_CMC_ENDS_Msk);
 8021d22:	f023 030c 	bic.w	r3, r3, #12
  cmc |= ((uint32_t) event) << CCU4_CC4_CMC_ENDS_Pos;
 8021d26:	ea43 0181 	orr.w	r1, r3, r1, lsl #2

  slice->CMC = cmc;
 8021d2a:	6041      	str	r1, [r0, #4]
  
  /* Next, Configure the stop mode */
  tc = slice->TC;
 8021d2c:	6943      	ldr	r3, [r0, #20]
  tc &= ~((uint32_t) CCU4_CC4_TC_ENDM_Msk);
 8021d2e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  tc |= ((uint32_t) end_mode) << CCU4_CC4_TC_ENDM_Pos;
 8021d32:	ea43 2202 	orr.w	r2, r3, r2, lsl #8

  slice->TC = tc;
 8021d36:	6142      	str	r2, [r0, #20]
 8021d38:	4770      	bx	lr
 8021d3a:	bf00      	nop

08021d3c <XMC_CCU4_SLICE_ConfigureEvent>:
             ((config->level == XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_HIGH) ||\
              (config->level == XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_LOW)));
  XMC_ASSERT("XMC_CCU4_SLICE_ConfigureEvent:Invalid Debounce Period", 
             XMC_CCU4_SLICE_CHECK_EVENT_FILTER(config->duration));
  /* Calculate offset with reference to event */
  offset = ((uint8_t) event) - 1U;
 8021d3c:	1e4b      	subs	r3, r1, #1

/* API to configure a slice trigger event */
void XMC_CCU4_SLICE_ConfigureEvent(XMC_CCU4_SLICE_t *const slice,
                                   const XMC_CCU4_SLICE_EVENT_t event,
                                   const XMC_CCU4_SLICE_EVENT_CONFIG_t *const config)
{
 8021d3e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
             ((config->level == XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_HIGH) ||\
              (config->level == XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_LOW)));
  XMC_ASSERT("XMC_CCU4_SLICE_ConfigureEvent:Invalid Debounce Period", 
             XMC_CCU4_SLICE_CHECK_EVENT_FILTER(config->duration));
  /* Calculate offset with reference to event */
  offset = ((uint8_t) event) - 1U;
 8021d42:	b2db      	uxtb	r3, r3

#else
  ins = slice->INS;
  
  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU4_CC4_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
 8021d44:	ea4f 0843 	mov.w	r8, r3, lsl #1
 8021d48:	fa5f f888 	uxtb.w	r8, r8
 8021d4c:	f108 0910 	add.w	r9, r8, #16
  ins |= ((uint32_t) config->mapped_input) << pos;

  slice->INS1 = ins;

#else
  ins = slice->INS;
 8021d50:	6807      	ldr	r7, [r0, #0]
  
  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU4_CC4_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->edge) << pos;
 8021d52:	f892 c001 	ldrb.w	ip, [r2, #1]
  
  /* Next, the level */
  pos = ((uint8_t) CCU4_CC4_INS_EV0LM_Pos) + offset;
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->level) << pos;
 8021d56:	7896      	ldrb	r6, [r2, #2]
  
  /* Next, the debounce filter */
  pos = ((uint8_t) CCU4_CC4_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->duration) << pos;
 8021d58:	78d4      	ldrb	r4, [r2, #3]

  /* Finally the input */
  pos = ((uint8_t) CCU4_CC4_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_INPUT_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->mapped_input) << pos;
 8021d5a:	f892 e000 	ldrb.w	lr, [r2]
#else
  ins = slice->INS;
  
  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU4_CC4_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
 8021d5e:	fa5f f989 	uxtb.w	r9, r9
 8021d62:	2503      	movs	r5, #3
 8021d64:	fa05 f209 	lsl.w	r2, r5, r9
  ins |= ((uint32_t) config->edge) << pos;
  
  /* Next, the level */
  pos = ((uint8_t) CCU4_CC4_INS_EV0LM_Pos) + offset;
 8021d68:	3115      	adds	r1, #21
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
 8021d6a:	b2c9      	uxtb	r1, r1
#else
  ins = slice->INS;
  
  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU4_CC4_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
 8021d6c:	ea27 0202 	bic.w	r2, r7, r2
  ins |= ((uint32_t) config->edge) << pos;
 8021d70:	fa0c fc09 	lsl.w	ip, ip, r9
  
  /* Next, the level */
  pos = ((uint8_t) CCU4_CC4_INS_EV0LM_Pos) + offset;
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
 8021d74:	2701      	movs	r7, #1
  ins = slice->INS;
  
  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU4_CC4_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->edge) << pos;
 8021d76:	ea42 0c0c 	orr.w	ip, r2, ip
  
  /* Next, the level */
  pos = ((uint8_t) CCU4_CC4_INS_EV0LM_Pos) + offset;
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
 8021d7a:	408f      	lsls	r7, r1
  ins |= ((uint32_t) config->level) << pos;
  
  /* Next, the debounce filter */
  pos = ((uint8_t) CCU4_CC4_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
 8021d7c:	f108 0819 	add.w	r8, r8, #25
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
 8021d80:	fa5f f288 	uxtb.w	r2, r8
  ins |= ((uint32_t) config->edge) << pos;
  
  /* Next, the level */
  pos = ((uint8_t) CCU4_CC4_INS_EV0LM_Pos) + offset;
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->level) << pos;
 8021d84:	408e      	lsls	r6, r1
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->edge) << pos;
  
  /* Next, the level */
  pos = ((uint8_t) CCU4_CC4_INS_EV0LM_Pos) + offset;
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
 8021d86:	ea2c 0707 	bic.w	r7, ip, r7
  pos = ((uint8_t) CCU4_CC4_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->duration) << pos;

  /* Finally the input */
  pos = ((uint8_t) CCU4_CC4_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
 8021d8a:	0099      	lsls	r1, r3, #2
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->level) << pos;
  
  /* Next, the debounce filter */
  pos = ((uint8_t) CCU4_CC4_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
 8021d8c:	4095      	lsls	r5, r2
  ins |= ((uint32_t) config->edge) << pos;
  
  /* Next, the level */
  pos = ((uint8_t) CCU4_CC4_INS_EV0LM_Pos) + offset;
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->level) << pos;
 8021d8e:	433e      	orrs	r6, r7
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->duration) << pos;

  /* Finally the input */
  pos = ((uint8_t) CCU4_CC4_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_INPUT_CONFIG_MASK) << pos);
 8021d90:	b2c9      	uxtb	r1, r1
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->level) << pos;
  
  /* Next, the debounce filter */
  pos = ((uint8_t) CCU4_CC4_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
 8021d92:	ea26 0505 	bic.w	r5, r6, r5
  ins |= ((uint32_t) config->duration) << pos;
 8021d96:	fa04 f202 	lsl.w	r2, r4, r2

  /* Finally the input */
  pos = ((uint8_t) CCU4_CC4_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_INPUT_CONFIG_MASK) << pos);
 8021d9a:	230f      	movs	r3, #15
  ins |= ((uint32_t) config->level) << pos;
  
  /* Next, the debounce filter */
  pos = ((uint8_t) CCU4_CC4_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->duration) << pos;
 8021d9c:	432a      	orrs	r2, r5

  /* Finally the input */
  pos = ((uint8_t) CCU4_CC4_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_INPUT_CONFIG_MASK) << pos);
 8021d9e:	408b      	lsls	r3, r1
  ins |= ((uint32_t) config->mapped_input) << pos;
 8021da0:	fa0e fe01 	lsl.w	lr, lr, r1
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->duration) << pos;

  /* Finally the input */
  pos = ((uint8_t) CCU4_CC4_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
  ins &= ~(((uint32_t) XMC_CCU4_SLICE_EVENT_INPUT_CONFIG_MASK) << pos);
 8021da4:	ea22 0303 	bic.w	r3, r2, r3
  ins |= ((uint32_t) config->mapped_input) << pos;
 8021da8:	ea43 030e 	orr.w	r3, r3, lr

  slice->INS = ins;
 8021dac:	6003      	str	r3, [r0, #0]
 8021dae:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8021db2:	bf00      	nop

08021db4 <XMC_CCU4_SLICE_SetPrescaler>:
{
  uint32_t fpc;
  
  XMC_ASSERT("XMC_CCU4_SLICE_SetPrescaler:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));

  fpc = slice->FPC;
 8021db4:	6a83      	ldr	r3, [r0, #40]	; 0x28
  fpc &= ~((uint32_t) CCU4_CC4_FPC_PVAL_Msk);
 8021db6:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
  fpc |= ((uint32_t) div_val) << CCU4_CC4_FPC_PVAL_Pos;
 8021dba:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  slice->FPC = fpc;
 8021dbe:	6283      	str	r3, [r0, #40]	; 0x28
  /* 
   * In any case, update the initial value of the divider which is to be loaded once the prescaler increments to the 
   * compare value.
   */
  slice->PSC = (uint32_t) div_val;
 8021dc0:	6241      	str	r1, [r0, #36]	; 0x24
 8021dc2:	4770      	bx	lr

08021dc4 <XMC_CCU4_SLICE_SetInterruptNode>:

/* Binds a capcom event to an NVIC node  */
void XMC_CCU4_SLICE_SetInterruptNode(XMC_CCU4_SLICE_t *const slice,
                                     const XMC_CCU4_SLICE_IRQ_ID_t event,
                                     const XMC_CCU4_SLICE_SR_ID_t sr)
{
 8021dc4:	2909      	cmp	r1, #9
 8021dc6:	b430      	push	{r4, r5}

  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid SR ID ", XMC_CCU4_SLICE_CHECK_SR_ID(sr));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  
  srs = slice->SRS;
 8021dc8:	f8d0 40a8 	ldr.w	r4, [r0, #168]	; 0xa8
 8021dcc:	d80d      	bhi.n	8021dea <XMC_CCU4_SLICE_SetInterruptNode+0x26>
 8021dce:	4b09      	ldr	r3, [pc, #36]	; (8021df4 <XMC_CCU4_SLICE_SetInterruptNode+0x30>)
 8021dd0:	4d09      	ldr	r5, [pc, #36]	; (8021df8 <XMC_CCU4_SLICE_SetInterruptNode+0x34>)
 8021dd2:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8021dd6:	f855 1021 	ldr.w	r1, [r5, r1, lsl #2]
 8021dda:	43db      	mvns	r3, r3
      mask = ((uint32_t) CCU4_CC4_SRS_E2SR_Msk);
      pos  = CCU4_CC4_SRS_E2SR_Pos;
      break;
  }
  
  srs &= ~mask; 
 8021ddc:	4023      	ands	r3, r4
  srs |= (uint32_t)sr << pos;
 8021dde:	408a      	lsls	r2, r1
 8021de0:	431a      	orrs	r2, r3
  slice->SRS = srs;
 8021de2:	f8c0 20a8 	str.w	r2, [r0, #168]	; 0xa8
}
 8021de6:	bc30      	pop	{r4, r5}
 8021de8:	4770      	bx	lr

  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid SR ID ", XMC_CCU4_SLICE_CHECK_SR_ID(sr));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  
  srs = slice->SRS;
 8021dea:	210c      	movs	r1, #12
 8021dec:	f46f 5340 	mvn.w	r3, #12288	; 0x3000
 8021df0:	e7f4      	b.n	8021ddc <XMC_CCU4_SLICE_SetInterruptNode+0x18>
 8021df2:	bf00      	nop
 8021df4:	0803097c 	.word	0x0803097c
 8021df8:	08030954 	.word	0x08030954

08021dfc <XMC_CCU8_Init>:
#endif
}

/* API to initialize CCU8 global resources  */
void XMC_CCU8_Init(XMC_CCU8_MODULE_t *const module, const XMC_CCU8_SLICE_MCMS_ACTION_t mcs_action)
{
 8021dfc:	b538      	push	{r3, r4, r5, lr}
 8021dfe:	4604      	mov	r4, r0
{
  XMC_ASSERT("XMC_CCU8_EnableModule:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));

#if (UC_FAMILY == XMC4)
  /* Enable CCU8 module clock */
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_CCU);
 8021e00:	2010      	movs	r0, #16
#endif
}

/* API to initialize CCU8 global resources  */
void XMC_CCU8_Init(XMC_CCU8_MODULE_t *const module, const XMC_CCU8_SLICE_MCMS_ACTION_t mcs_action)
{
 8021e02:	460d      	mov	r5, r1
{
  XMC_ASSERT("XMC_CCU8_EnableModule:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));

#if (UC_FAMILY == XMC4)
  /* Enable CCU8 module clock */
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_CCU);
 8021e04:	f7ff fcda 	bl	80217bc <XMC_SCU_CLOCK_EnableClock>
  }
}

__STATIC_INLINE void XMC_CCU8_lUngateClock(XMC_CCU8_MODULE_t *const module)
{
  if (module == CCU80)
 8021e08:	4b10      	ldr	r3, [pc, #64]	; (8021e4c <XMC_CCU8_Init+0x50>)
 8021e0a:	429c      	cmp	r4, r3
 8021e0c:	d016      	beq.n	8021e3c <XMC_CCU8_Init+0x40>
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU80);
  }
#if defined(CCU81)
  else if (module == CCU81)
 8021e0e:	4b10      	ldr	r3, [pc, #64]	; (8021e50 <XMC_CCU8_Init+0x54>)
 8021e10:	429c      	cmp	r4, r3
 8021e12:	d00a      	beq.n	8021e2a <XMC_CCU8_Init+0x2e>
 *  XMC_CCU8_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU8_StartPrescaler(XMC_CCU8_MODULE_t *const module)
{
  XMC_ASSERT("XMC_CCU8_StartPrescaler:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));
  module->GIDLC |= (uint32_t) CCU8_GIDLC_SPRB_Msk;
 8021e14:	68e3      	ldr	r3, [r4, #12]
 8021e16:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8021e1a:	60e3      	str	r3, [r4, #12]
  /* Enable CCU8 module */
  XMC_CCU8_EnableModule(module);
  /* Start the prescaler */
  XMC_CCU8_StartPrescaler(module);
  
  gctrl = module->GCTRL;
 8021e1c:	6823      	ldr	r3, [r4, #0]
  gctrl &= ~((uint32_t) CCU8_GCTRL_MSDE_Msk);
 8021e1e:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
  gctrl |= (uint32_t)mcs_action << CCU8_GCTRL_MSDE_Pos;
 8021e22:	ea43 3185 	orr.w	r1, r3, r5, lsl #14
  
  module->GCTRL = gctrl;
 8021e26:	6021      	str	r1, [r4, #0]
 8021e28:	bd38      	pop	{r3, r4, r5, pc}
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU80);
  }
#if defined(CCU81)
  else if (module == CCU81)
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU81);
 8021e2a:	f44f 7080 	mov.w	r0, #256	; 0x100
 8021e2e:	f7ff fcd7 	bl	80217e0 <XMC_SCU_CLOCK_UngatePeripheralClock>
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU80);
  }
#if defined(CCU81)
  else if (module == CCU81)
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU81);
 8021e32:	f44f 7080 	mov.w	r0, #256	; 0x100
 8021e36:	f7ff fc63 	bl	8021700 <XMC_SCU_RESET_DeassertPeripheralReset>
 8021e3a:	e7eb      	b.n	8021e14 <XMC_CCU8_Init+0x18>

__STATIC_INLINE void XMC_CCU8_lUngateClock(XMC_CCU8_MODULE_t *const module)
{
  if (module == CCU80)
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU80);
 8021e3c:	2080      	movs	r0, #128	; 0x80
 8021e3e:	f7ff fccf 	bl	80217e0 <XMC_SCU_CLOCK_UngatePeripheralClock>

__STATIC_INLINE void XMC_CCU8_lDeassertReset(const XMC_CCU8_MODULE_t *const module)
{
  if (module == CCU80)
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU80);
 8021e42:	2080      	movs	r0, #128	; 0x80
 8021e44:	f7ff fc5c 	bl	8021700 <XMC_SCU_RESET_DeassertPeripheralReset>
 8021e48:	e7e4      	b.n	8021e14 <XMC_CCU8_Init+0x18>
 8021e4a:	bf00      	nop
 8021e4c:	40020000 	.word	0x40020000
 8021e50:	40024000 	.word	0x40024000

08021e54 <XMC_CCU8_SLICE_CompareInit>:
  /* Stops the timer */
  XMC_CCU8_SLICE_StopTimer(slice);
  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC =  (uint32_t)compare_init->timer_concatenation << CCU8_CC8_CMC_TCE_Pos;
 8021e54:	7b4b      	ldrb	r3, [r1, #13]
}

/* API to configure CC8 Slice in Compare mode */
void XMC_CCU8_SLICE_CompareInit(XMC_CCU8_SLICE_t *const slice,
                                const XMC_CCU8_SLICE_COMPARE_CONFIG_t *const compare_init)
{
 8021e56:	b470      	push	{r4, r5, r6}
  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC =  (uint32_t)compare_init->timer_concatenation << CCU8_CC8_CMC_TCE_Pos;
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 8021e58:	7b0d      	ldrb	r5, [r1, #12]
 *  XMC_CCU8_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_StopTimer(XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_StopTimer:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU8_CC8_TCCLR_TRBC_Msk;
 8021e5a:	2601      	movs	r6, #1
 8021e5c:	6106      	str	r6, [r0, #16]
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 8021e5e:	462c      	mov	r4, r5
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 8021e60:	461a      	mov	r2, r3
  /* Stops the timer */
  XMC_CCU8_SLICE_StopTimer(slice);
  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC =  (uint32_t)compare_init->timer_concatenation << CCU8_CC8_CMC_TCE_Pos;
 8021e62:	f3c3 1300 	ubfx	r3, r3, #4, #1
  XMC_ASSERT("XMC_CCU8_SLICE_CompareInit:Timer Init Pointer is NULL",
             (XMC_CCU8_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);
  /* Stops the timer */
  XMC_CCU8_SLICE_StopTimer(slice);
  /* Program the timer mode */
  slice->TC = compare_init->tc;
 8021e66:	680e      	ldr	r6, [r1, #0]
 8021e68:	6146      	str	r6, [r0, #20]
  /* Enable the timer concatenation */
  slice->CMC =  (uint32_t)compare_init->timer_concatenation << CCU8_CC8_CMC_TCE_Pos;
 8021e6a:	051b      	lsls	r3, r3, #20
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 8021e6c:	f005 050f 	and.w	r5, r5, #15
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 8021e70:	0924      	lsrs	r4, r4, #4
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 8021e72:	f002 020f 	and.w	r2, r2, #15
  /* Stops the timer */
  XMC_CCU8_SLICE_StopTimer(slice);
  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC =  (uint32_t)compare_init->timer_concatenation << CCU8_CC8_CMC_TCE_Pos;
 8021e76:	6043      	str	r3, [r0, #4]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 8021e78:	6245      	str	r5, [r0, #36]	; 0x24
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 8021e7a:	62c4      	str	r4, [r0, #44]	; 0x2c
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 8021e7c:	6202      	str	r2, [r0, #32]
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->psl;
 8021e7e:	684b      	ldr	r3, [r1, #4]
 8021e80:	6183      	str	r3, [r0, #24]
  /* Asymmetric PWM and Slice output routing configuration */
#if defined(CCU8V3) /* Defined for XMC1400 devices only */
  slice->CHC = (uint32_t) compare_init->chc;
#else
  slice->CHC = (uint32_t)((uint32_t)compare_init->chc ^ XMC_CCU8_SLICE_CHC_CONFIG_MASK);
 8021e82:	688b      	ldr	r3, [r1, #8]
 8021e84:	f083 0314 	eor.w	r3, r3, #20
 8021e88:	6483      	str	r3, [r0, #72]	; 0x48
#endif
}
 8021e8a:	bc70      	pop	{r4, r5, r6}
 8021e8c:	4770      	bx	lr
 8021e8e:	bf00      	nop

08021e90 <XMC_CCU8_SLICE_SetTimerPeriodMatch>:

/* Programs period match value of the timer  */
void XMC_CCU8_SLICE_SetTimerPeriodMatch(XMC_CCU8_SLICE_t *const slice, const uint16_t period_val)
{
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->PRS = (uint32_t) period_val;
 8021e90:	6341      	str	r1, [r0, #52]	; 0x34
 8021e92:	4770      	bx	lr

08021e94 <XMC_CCU8_SLICE_SetPrescaler>:
  uint32_t fpc;

  XMC_ASSERT("XMC_CCU8_SLICE_SetPrescaler:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));

  /* If the prescaler is not running, update directly the divider*/
  fpc = slice->FPC;
 8021e94:	6a83      	ldr	r3, [r0, #40]	; 0x28
  fpc &= ~((uint32_t) CCU8_CC8_FPC_PVAL_Msk);
 8021e96:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
  fpc |= ((uint32_t) div_val) << CCU8_CC8_FPC_PVAL_Pos;
 8021e9a:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  slice->FPC = fpc;
 8021e9e:	6283      	str	r3, [r0, #40]	; 0x28

  /*
   * In any case, update the initial value of the divider which is to be loaded once the prescaler increments to the
   * compare value.
   */
  slice->PSC = (uint32_t) div_val;
 8021ea0:	6241      	str	r1, [r0, #36]	; 0x24
 8021ea2:	4770      	bx	lr

08021ea4 <XMC_CCU8_SLICE_SetTimerCompareMatch>:
                                         const uint16_t compare_val)
{
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatch:Invalid channel", XMC_CCU8_SLICE_CHECK_COMP_CHANNEL(channel));

  if (XMC_CCU8_SLICE_COMPARE_CHANNEL_1 == channel)
 8021ea4:	b109      	cbz	r1, 8021eaa <XMC_CCU8_SLICE_SetTimerCompareMatch+0x6>
  {
    slice->CR1S = (uint32_t) compare_val;
  }
  else
  {
    slice->CR2S = (uint32_t) compare_val;
 8021ea6:	6442      	str	r2, [r0, #68]	; 0x44
 8021ea8:	4770      	bx	lr
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatch:Invalid channel", XMC_CCU8_SLICE_CHECK_COMP_CHANNEL(channel));

  if (XMC_CCU8_SLICE_COMPARE_CHANNEL_1 == channel)
  {
    slice->CR1S = (uint32_t) compare_val;
 8021eaa:	63c2      	str	r2, [r0, #60]	; 0x3c
 8021eac:	4770      	bx	lr
 8021eae:	bf00      	nop

08021eb0 <XMC_CCU8_SLICE_SetInterruptNode>:

/* Binds a capcom event to an NVIC node  */
void XMC_CCU8_SLICE_SetInterruptNode(XMC_CCU8_SLICE_t *const slice,
                                     const XMC_CCU8_SLICE_IRQ_ID_t event,
                                     const XMC_CCU8_SLICE_SR_ID_t sr)
{
 8021eb0:	2909      	cmp	r1, #9
 8021eb2:	b430      	push	{r4, r5}

  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid SR ID ", XMC_CCU8_SLICE_CHECK_SR_ID(sr));
  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid event", XMC_CCU8_SLICE_CHECK_INTERRUPT(event));

  srs = slice->SRS;
 8021eb4:	f8d0 40a8 	ldr.w	r4, [r0, #168]	; 0xa8
 8021eb8:	d80d      	bhi.n	8021ed6 <XMC_CCU8_SLICE_SetInterruptNode+0x26>
 8021eba:	4b09      	ldr	r3, [pc, #36]	; (8021ee0 <XMC_CCU8_SLICE_SetInterruptNode+0x30>)
 8021ebc:	4d09      	ldr	r5, [pc, #36]	; (8021ee4 <XMC_CCU8_SLICE_SetInterruptNode+0x34>)
 8021ebe:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8021ec2:	f855 1021 	ldr.w	r1, [r5, r1, lsl #2]
 8021ec6:	43db      	mvns	r3, r3
      mask = ((uint32_t) CCU8_CC8_SRS_E2SR_Msk);
      pos  = CCU8_CC8_SRS_E2SR_Pos;
      break;
  }
  
  srs &= ~mask;
 8021ec8:	4023      	ands	r3, r4
  srs |= (uint32_t)sr << pos;
 8021eca:	408a      	lsls	r2, r1
 8021ecc:	431a      	orrs	r2, r3
  
  slice->SRS = srs;
 8021ece:	f8c0 20a8 	str.w	r2, [r0, #168]	; 0xa8
}
 8021ed2:	bc30      	pop	{r4, r5}
 8021ed4:	4770      	bx	lr

  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid SR ID ", XMC_CCU8_SLICE_CHECK_SR_ID(sr));
  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid event", XMC_CCU8_SLICE_CHECK_INTERRUPT(event));

  srs = slice->SRS;
 8021ed6:	210c      	movs	r1, #12
 8021ed8:	f46f 5340 	mvn.w	r3, #12288	; 0x3000
 8021edc:	e7f4      	b.n	8021ec8 <XMC_CCU8_SLICE_SetInterruptNode+0x18>
 8021ede:	bf00      	nop
 8021ee0:	080309a4 	.word	0x080309a4
 8021ee4:	080309cc 	.word	0x080309cc

08021ee8 <XMC_DMA_Init>:

/* Enable GPDMA module */
void XMC_DMA_Enable(XMC_DMA_t *const dma)
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8021ee8:	4b0c      	ldr	r3, [pc, #48]	; (8021f1c <XMC_DMA_Init+0x34>)
 8021eea:	4298      	cmp	r0, r3
 * API IMPLEMENTATION
 *******************************************************************************/

/* Initialize GPDMA */
void XMC_DMA_Init(XMC_DMA_t *const dma)
{
 8021eec:	b510      	push	{r4, lr}
 8021eee:	4604      	mov	r4, r0

/* Enable GPDMA module */
void XMC_DMA_Enable(XMC_DMA_t *const dma)
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8021ef0:	d009      	beq.n	8021f06 <XMC_DMA_Init+0x1e>
#if defined(GPDMA1)
  }
  else
  {
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_GPDMA1);
 8021ef2:	480b      	ldr	r0, [pc, #44]	; (8021f20 <XMC_DMA_Init+0x38>)
 8021ef4:	f7ff fc74 	bl	80217e0 <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_GPDMA1);
 8021ef8:	4809      	ldr	r0, [pc, #36]	; (8021f20 <XMC_DMA_Init+0x38>)
 8021efa:	f7ff fc01 	bl	8021700 <XMC_SCU_RESET_DeassertPeripheralReset>
  }
#endif

  dma->DMACFGREG = 0x1U;
 8021efe:	2301      	movs	r3, #1
 8021f00:	f8c4 3398 	str.w	r3, [r4, #920]	; 0x398
 8021f04:	bd10      	pop	{r4, pc}
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_GPDMA0);
 8021f06:	4807      	ldr	r0, [pc, #28]	; (8021f24 <XMC_DMA_Init+0x3c>)
 8021f08:	f7ff fc6a 	bl	80217e0 <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_GPDMA0);
 8021f0c:	4805      	ldr	r0, [pc, #20]	; (8021f24 <XMC_DMA_Init+0x3c>)
 8021f0e:	f7ff fbf7 	bl	8021700 <XMC_SCU_RESET_DeassertPeripheralReset>
#endif
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_GPDMA1);
  }
#endif

  dma->DMACFGREG = 0x1U;
 8021f12:	2301      	movs	r3, #1
 8021f14:	f8c4 3398 	str.w	r3, [r4, #920]	; 0x398
 8021f18:	bd10      	pop	{r4, pc}
 8021f1a:	bf00      	nop
 8021f1c:	50014000 	.word	0x50014000
 8021f20:	20000020 	.word	0x20000020
 8021f24:	20000010 	.word	0x20000010

08021f28 <XMC_DMA_CH_Disable>:
}

/* Disable DMA channel */
void XMC_DMA_CH_Disable(XMC_DMA_t *const dma, const uint8_t channel)
{
  dma->CHENREG = (uint32_t)(0x100UL << channel);
 8021f28:	f44f 7380 	mov.w	r3, #256	; 0x100
 8021f2c:	408b      	lsls	r3, r1
 8021f2e:	2201      	movs	r2, #1
 8021f30:	f8c0 33a0 	str.w	r3, [r0, #928]	; 0x3a0
 8021f34:	408a      	lsls	r2, r1
  while((dma->CHENREG & (uint32_t)(0x1UL << channel)) != 0U)
 8021f36:	f8d0 33a0 	ldr.w	r3, [r0, #928]	; 0x3a0
 8021f3a:	421a      	tst	r2, r3
 8021f3c:	d1fb      	bne.n	8021f36 <XMC_DMA_CH_Disable+0xe>
  {
    /* wait until channel is disabled */
  }
}
 8021f3e:	4770      	bx	lr

08021f40 <XMC_DMA_CH_Init>:
  return (bool)(dma->CHENREG & ((uint32_t)1U << channel));
}

/* Initialize DMA channel */
XMC_DMA_CH_STATUS_t XMC_DMA_CH_Init(XMC_DMA_t *const dma, const uint8_t channel, const XMC_DMA_CH_CONFIG_t *const config)
{
 8021f40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
bool XMC_DMA_IsEnabled(const XMC_DMA_t *const dma)
{
  bool status;

#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8021f42:	4ba1      	ldr	r3, [pc, #644]	; (80221c8 <XMC_DMA_CH_Init+0x288>)
 8021f44:	4298      	cmp	r0, r3
  return (bool)(dma->CHENREG & ((uint32_t)1U << channel));
}

/* Initialize DMA channel */
XMC_DMA_CH_STATUS_t XMC_DMA_CH_Init(XMC_DMA_t *const dma, const uint8_t channel, const XMC_DMA_CH_CONFIG_t *const config)
{
 8021f46:	4604      	mov	r4, r0
 8021f48:	460e      	mov	r6, r1
 8021f4a:	4615      	mov	r5, r2
bool XMC_DMA_IsEnabled(const XMC_DMA_t *const dma)
{
  bool status;

#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8021f4c:	d053      	beq.n	8021ff6 <XMC_DMA_CH_Init+0xb6>
#endif
#if defined(GPDMA1)
  }
  else
  {
    status = !XMC_SCU_RESET_IsPeripheralResetAsserted(XMC_SCU_PERIPHERAL_RESET_GPDMA1);
 8021f4e:	489f      	ldr	r0, [pc, #636]	; (80221cc <XMC_DMA_CH_Init+0x28c>)
 8021f50:	f7ff fbe2 	bl	8021718 <XMC_SCU_RESET_IsPeripheralResetAsserted>
#if defined(CLOCK_GATING_SUPPORTED)
    status = status && !XMC_SCU_CLOCK_IsPeripheralClockGated(XMC_SCU_PERIPHERAL_CLOCK_GPDMA1);
 8021f54:	b108      	cbz	r0, 8021f5a <XMC_DMA_CH_Init+0x1a>
      status = XMC_DMA_CH_STATUS_BUSY;
    }
  }
  else 
  {
    status = XMC_DMA_CH_STATUS_ERROR;
 8021f56:	2001      	movs	r0, #1
 8021f58:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  }
  else
  {
    status = !XMC_SCU_RESET_IsPeripheralResetAsserted(XMC_SCU_PERIPHERAL_RESET_GPDMA1);
#if defined(CLOCK_GATING_SUPPORTED)
    status = status && !XMC_SCU_CLOCK_IsPeripheralClockGated(XMC_SCU_PERIPHERAL_CLOCK_GPDMA1);
 8021f5a:	489c      	ldr	r0, [pc, #624]	; (80221cc <XMC_DMA_CH_Init+0x28c>)
 8021f5c:	f7ff fc4c 	bl	80217f8 <XMC_SCU_CLOCK_IsPeripheralClockGated>
 8021f60:	f080 0001 	eor.w	r0, r0, #1
 8021f64:	b2c0      	uxtb	r0, r0
#endif
  }
#endif

  /* DMA reset is not asserted and peripheral clock is not gated */
  if (status == true)
 8021f66:	2800      	cmp	r0, #0
 8021f68:	d0f5      	beq.n	8021f56 <XMC_DMA_CH_Init+0x16>
  {
    status = status && (dma->DMACFGREG != 0U);
 8021f6a:	f8d4 3398 	ldr.w	r3, [r4, #920]	; 0x398
{
  XMC_DMA_CH_STATUS_t status;
  uint8_t line;
  uint8_t peripheral;

  if (XMC_DMA_IsEnabled(dma) == true)
 8021f6e:	2b00      	cmp	r3, #0
 8021f70:	d0f1      	beq.n	8021f56 <XMC_DMA_CH_Init+0x16>
}

/* Check if a DMA channel is enabled */
bool XMC_DMA_CH_IsEnabled(XMC_DMA_t *const dma, const uint8_t channel)
{
  return (bool)(dma->CHENREG & ((uint32_t)1U << channel));
 8021f72:	f8d4 33a0 	ldr.w	r3, [r4, #928]	; 0x3a0
 8021f76:	40f3      	lsrs	r3, r6
  uint8_t line;
  uint8_t peripheral;

  if (XMC_DMA_IsEnabled(dma) == true)
  {
    if (XMC_DMA_CH_IsEnabled(dma, channel) == false)
 8021f78:	07db      	lsls	r3, r3, #31
 8021f7a:	d501      	bpl.n	8021f80 <XMC_DMA_CH_Init+0x40>
      status = XMC_DMA_CH_STATUS_OK;

    }
    else
    {
      status = XMC_DMA_CH_STATUS_BUSY;
 8021f7c:	2002      	movs	r0, #2
 8021f7e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  if (XMC_DMA_IsEnabled(dma) == true)
  {
    if (XMC_DMA_CH_IsEnabled(dma, channel) == false)
    {
      dma->CH[channel].SAR = config->src_addr;
 8021f80:	2258      	movs	r2, #88	; 0x58
 8021f82:	fb02 f206 	mul.w	r2, r2, r6
 8021f86:	6869      	ldr	r1, [r5, #4]
 8021f88:	50a1      	str	r1, [r4, r2]
 8021f8a:	18a3      	adds	r3, r4, r2
      dma->CH[channel].DAR = config->dst_addr;
 8021f8c:	68a9      	ldr	r1, [r5, #8]
      dma->CH[channel].LLP = (uint32_t)config->linked_list_pointer;
      dma->CH[channel].CTLH = (uint32_t)config->block_size;
      dma->CH[channel].CTLL = config->control;

      dma->CH[channel].CFGL = (uint32_t)((uint32_t)config->priority |
 8021f8e:	7eea      	ldrb	r2, [r5, #27]
  {
    if (XMC_DMA_CH_IsEnabled(dma, channel) == false)
    {
      dma->CH[channel].SAR = config->src_addr;
      dma->CH[channel].DAR = config->dst_addr;
      dma->CH[channel].LLP = (uint32_t)config->linked_list_pointer;
 8021f90:	f8d5 e00c 	ldr.w	lr, [r5, #12]
      dma->CH[channel].CTLH = (uint32_t)config->block_size;
 8021f94:	8b2f      	ldrh	r7, [r5, #24]
  if (XMC_DMA_IsEnabled(dma) == true)
  {
    if (XMC_DMA_CH_IsEnabled(dma, channel) == false)
    {
      dma->CH[channel].SAR = config->src_addr;
      dma->CH[channel].DAR = config->dst_addr;
 8021f96:	6099      	str	r1, [r3, #8]

      dma->CH[channel].CFGL = (uint32_t)((uint32_t)config->priority |
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_SRC_Msk |
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_DST_Msk);

      if ((dma == XMC_DMA0) && (channel < (uint8_t)2))
 8021f98:	498b      	ldr	r1, [pc, #556]	; (80221c8 <XMC_DMA_CH_Init+0x288>)
  {
    if (XMC_DMA_CH_IsEnabled(dma, channel) == false)
    {
      dma->CH[channel].SAR = config->src_addr;
      dma->CH[channel].DAR = config->dst_addr;
      dma->CH[channel].LLP = (uint32_t)config->linked_list_pointer;
 8021f9a:	f8c3 e010 	str.w	lr, [r3, #16]
      dma->CH[channel].CTLH = (uint32_t)config->block_size;
 8021f9e:	61df      	str	r7, [r3, #28]
      dma->CH[channel].CTLL = config->control;
 8021fa0:	6828      	ldr	r0, [r5, #0]
 8021fa2:	6198      	str	r0, [r3, #24]

      dma->CH[channel].CFGL = (uint32_t)((uint32_t)config->priority |
 8021fa4:	f442 6240 	orr.w	r2, r2, #3072	; 0xc00
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_SRC_Msk |
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_DST_Msk);

      if ((dma == XMC_DMA0) && (channel < (uint8_t)2))
 8021fa8:	428c      	cmp	r4, r1
      dma->CH[channel].DAR = config->dst_addr;
      dma->CH[channel].LLP = (uint32_t)config->linked_list_pointer;
      dma->CH[channel].CTLH = (uint32_t)config->block_size;
      dma->CH[channel].CTLL = config->control;

      dma->CH[channel].CFGL = (uint32_t)((uint32_t)config->priority |
 8021faa:	641a      	str	r2, [r3, #64]	; 0x40
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_SRC_Msk |
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_DST_Msk);

      if ((dma == XMC_DMA0) && (channel < (uint8_t)2))
 8021fac:	d02f      	beq.n	802200e <XMC_DMA_CH_Init+0xce>
        /* Configure scatter and gather */
        dma->CH[channel].SGR = config->src_gather_control;
        dma->CH[channel].DSR = config->dst_scatter_control;
      }

      if (config->dst_handshaking == XMC_DMA_CH_DST_HANDSHAKING_HARDWARE)
 8021fae:	8c2b      	ldrh	r3, [r5, #32]
 8021fb0:	b923      	cbnz	r3, 8021fbc <XMC_DMA_CH_Init+0x7c>
      {
        /* Hardware handshaking interface configuration */
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_M2P_DMA) ||
 8021fb2:	78ab      	ldrb	r3, [r5, #2]
 8021fb4:	f003 0350 	and.w	r3, r3, #80	; 0x50
 8021fb8:	2b10      	cmp	r3, #16
 8021fba:	d02f      	beq.n	802201c <XMC_DMA_CH_Init+0xdc>
          dma->CH[channel].CFGL &= (uint32_t)~GPDMA0_CH_CFGL_HS_SEL_DST_Msk;
        }
      }


      if (config->src_handshaking == XMC_DMA_CH_SRC_HANDSHAKING_HARDWARE)
 8021fbc:	8bab      	ldrh	r3, [r5, #28]
 8021fbe:	b923      	cbnz	r3, 8021fca <XMC_DMA_CH_Init+0x8a>
      {
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2M_DMA) ||
 8021fc0:	78ab      	ldrb	r3, [r5, #2]
 8021fc2:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8021fc6:	2b20      	cmp	r3, #32
 8021fc8:	d053      	beq.n	8022072 <XMC_DMA_CH_Init+0x132>
                                                           (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_ERROR));

      switch (config->transfer_type)
 8021fca:	7eaa      	ldrb	r2, [r5, #26]

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 8021fcc:	2301      	movs	r3, #1
 8021fce:	40b3      	lsls	r3, r6
                                                           (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_ERROR));

      switch (config->transfer_type)
 8021fd0:	3a01      	subs	r2, #1

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 8021fd2:	f8c4 3338 	str.w	r3, [r4, #824]	; 0x338
 8021fd6:	f8c4 3340 	str.w	r3, [r4, #832]	; 0x340
 8021fda:	f8c4 3348 	str.w	r3, [r4, #840]	; 0x348
 8021fde:	f8c4 3350 	str.w	r3, [r4, #848]	; 0x350
 8021fe2:	f8c4 3358 	str.w	r3, [r4, #856]	; 0x358
                                                           (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_ERROR));

      switch (config->transfer_type)
 8021fe6:	2a07      	cmp	r2, #7
 8021fe8:	d86c      	bhi.n	80220c4 <XMC_DMA_CH_Init+0x184>
 8021fea:	e8df f002 	tbb	[pc, r2]
 8021fee:	9e95      	.short	0x9e95
 8021ff0:	8c7f766d 	.word	0x8c7f766d
 8021ff4:	b4a7      	.short	0xb4a7

#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    status = !XMC_SCU_RESET_IsPeripheralResetAsserted(XMC_SCU_PERIPHERAL_RESET_GPDMA0);
 8021ff6:	4876      	ldr	r0, [pc, #472]	; (80221d0 <XMC_DMA_CH_Init+0x290>)
 8021ff8:	f7ff fb8e 	bl	8021718 <XMC_SCU_RESET_IsPeripheralResetAsserted>
#if defined(CLOCK_GATING_SUPPORTED)
    status = status && !XMC_SCU_CLOCK_IsPeripheralClockGated(XMC_SCU_PERIPHERAL_CLOCK_GPDMA0);
 8021ffc:	2800      	cmp	r0, #0
 8021ffe:	d1aa      	bne.n	8021f56 <XMC_DMA_CH_Init+0x16>
 8022000:	4873      	ldr	r0, [pc, #460]	; (80221d0 <XMC_DMA_CH_Init+0x290>)
 8022002:	f7ff fbf9 	bl	80217f8 <XMC_SCU_CLOCK_IsPeripheralClockGated>
 8022006:	f080 0001 	eor.w	r0, r0, #1
 802200a:	b2c0      	uxtb	r0, r0
 802200c:	e7ab      	b.n	8021f66 <XMC_DMA_CH_Init+0x26>

      dma->CH[channel].CFGL = (uint32_t)((uint32_t)config->priority |
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_SRC_Msk |
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_DST_Msk);

      if ((dma == XMC_DMA0) && (channel < (uint8_t)2))
 802200e:	2e01      	cmp	r6, #1
 8022010:	d8cd      	bhi.n	8021fae <XMC_DMA_CH_Init+0x6e>
      {
        /* Configure scatter and gather */
        dma->CH[channel].SGR = config->src_gather_control;
 8022012:	692a      	ldr	r2, [r5, #16]
 8022014:	649a      	str	r2, [r3, #72]	; 0x48
        dma->CH[channel].DSR = config->dst_scatter_control;
 8022016:	696a      	ldr	r2, [r5, #20]
 8022018:	651a      	str	r2, [r3, #80]	; 0x50
 802201a:	e7c8      	b.n	8021fae <XMC_DMA_CH_Init+0x6e>
        /* Hardware handshaking interface configuration */
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_M2P_DMA) ||
            (config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2P_DMA))
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
 802201c:	4b6a      	ldr	r3, [pc, #424]	; (80221c8 <XMC_DMA_CH_Init+0x288>)
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 802201e:	496d      	ldr	r1, [pc, #436]	; (80221d4 <XMC_DMA_CH_Init+0x294>)
            line = config->dst_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
          }
#endif
          peripheral = config->dst_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_DEST_PER_Pos);
 8022020:	2258      	movs	r2, #88	; 0x58
 8022022:	fb02 4206 	mla	r2, r2, r6, r4
        /* Hardware handshaking interface configuration */
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_M2P_DMA) ||
            (config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2P_DMA))
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
 8022026:	429c      	cmp	r4, r3
            line = config->dst_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
          }
#endif
          peripheral = config->dst_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_DEST_PER_Pos);
 8022028:	6c57      	ldr	r7, [r2, #68]	; 0x44
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
          {
#endif
            line = config->dst_peripheral_request & GPDMA0_CH_CFGH_PER_Msk;
 802202a:	f895 3022 	ldrb.w	r3, [r5, #34]	; 0x22
        /* Hardware handshaking interface configuration */
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_M2P_DMA) ||
            (config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2P_DMA))
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
 802202e:	f000 80b3 	beq.w	8022198 <XMC_DMA_CH_Init+0x258>
            line = config->dst_peripheral_request & GPDMA0_CH_CFGH_PER_Msk;
#if defined(GPDMA1)
          }
          else
          {
            line = config->dst_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
 8022032:	f003 0003 	and.w	r0, r3, #3
          }
#endif
          peripheral = config->dst_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_DEST_PER_Pos);
 8022036:	ea47 27c0 	orr.w	r7, r7, r0, lsl #11
 802203a:	6457      	str	r7, [r2, #68]	; 0x44
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
#if defined(GPDMA1)
  }
  else
  {
    DLR->SRSEL1 = ((DLR->SRSEL1 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 802203c:	68cf      	ldr	r7, [r1, #12]
 802203e:	ea4f 0e80 	mov.w	lr, r0, lsl #2
 8022042:	220f      	movs	r2, #15
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 8022044:	091b      	lsrs	r3, r3, #4
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
#if defined(GPDMA1)
  }
  else
  {
    DLR->SRSEL1 = ((DLR->SRSEL1 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8022046:	fa02 f20e 	lsl.w	r2, r2, lr
 802204a:	ea27 0202 	bic.w	r2, r7, r2
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 802204e:	fa03 f30e 	lsl.w	r3, r3, lr
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
#if defined(GPDMA1)
  }
  else
  {
    DLR->SRSEL1 = ((DLR->SRSEL1 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8022052:	4313      	orrs	r3, r2
 8022054:	60cb      	str	r3, [r1, #12]
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
    DLR->LNEN |= (0x100UL << line);
 8022056:	690a      	ldr	r2, [r1, #16]
 8022058:	f44f 7380 	mov.w	r3, #256	; 0x100
 802205c:	4083      	lsls	r3, r0
 802205e:	4313      	orrs	r3, r2
 8022060:	610b      	str	r3, [r1, #16]
#endif
          peripheral = config->dst_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_DEST_PER_Pos);
          XMC_DMA_EnableRequestLine(dma, line, peripheral);
          dma->CH[channel].CFGL &= (uint32_t)~GPDMA0_CH_CFGL_HS_SEL_DST_Msk;
 8022062:	2358      	movs	r3, #88	; 0x58
 8022064:	fb03 4306 	mla	r3, r3, r6, r4
 8022068:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 802206a:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 802206e:	641a      	str	r2, [r3, #64]	; 0x40
 8022070:	e7a4      	b.n	8021fbc <XMC_DMA_CH_Init+0x7c>
      {
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2M_DMA) ||
            (config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2P_DMA))
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
 8022072:	4b55      	ldr	r3, [pc, #340]	; (80221c8 <XMC_DMA_CH_Init+0x288>)
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8022074:	4957      	ldr	r1, [pc, #348]	; (80221d4 <XMC_DMA_CH_Init+0x294>)
            line = config->src_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
          }
#endif
          peripheral = config->src_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_SRC_PER_Pos);
 8022076:	2258      	movs	r2, #88	; 0x58
 8022078:	fb02 4206 	mla	r2, r2, r6, r4
      {
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2M_DMA) ||
            (config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2P_DMA))
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
 802207c:	429c      	cmp	r4, r3
            line = config->src_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
          }
#endif
          peripheral = config->src_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_SRC_PER_Pos);
 802207e:	6c57      	ldr	r7, [r2, #68]	; 0x44
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
          {
#endif
            line = config->src_peripheral_request & GPDMA0_CH_CFGH_PER_Msk;
 8022080:	7fab      	ldrb	r3, [r5, #30]
      {
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2M_DMA) ||
            (config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2P_DMA))
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
 8022082:	d071      	beq.n	8022168 <XMC_DMA_CH_Init+0x228>
            line = config->src_peripheral_request & GPDMA0_CH_CFGH_PER_Msk;
#if defined(GPDMA1)
          }
          else
          {
            line = config->src_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
 8022084:	f003 0003 	and.w	r0, r3, #3
          }
#endif
          peripheral = config->src_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_SRC_PER_Pos);
 8022088:	ea47 17c0 	orr.w	r7, r7, r0, lsl #7
 802208c:	6457      	str	r7, [r2, #68]	; 0x44
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
#if defined(GPDMA1)
  }
  else
  {
    DLR->SRSEL1 = ((DLR->SRSEL1 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 802208e:	68cf      	ldr	r7, [r1, #12]
 8022090:	ea4f 0e80 	mov.w	lr, r0, lsl #2
 8022094:	220f      	movs	r2, #15
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 8022096:	091b      	lsrs	r3, r3, #4
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
#if defined(GPDMA1)
  }
  else
  {
    DLR->SRSEL1 = ((DLR->SRSEL1 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8022098:	fa02 f20e 	lsl.w	r2, r2, lr
 802209c:	ea27 0202 	bic.w	r2, r7, r2
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 80220a0:	fa03 f30e 	lsl.w	r3, r3, lr
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
#if defined(GPDMA1)
  }
  else
  {
    DLR->SRSEL1 = ((DLR->SRSEL1 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 80220a4:	4313      	orrs	r3, r2
 80220a6:	60cb      	str	r3, [r1, #12]
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
    DLR->LNEN |= (0x100UL << line);
 80220a8:	690a      	ldr	r2, [r1, #16]
 80220aa:	f44f 7380 	mov.w	r3, #256	; 0x100
 80220ae:	4083      	lsls	r3, r0
 80220b0:	4313      	orrs	r3, r2
 80220b2:	610b      	str	r3, [r1, #16]
#endif
          peripheral = config->src_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_SRC_PER_Pos);
          XMC_DMA_EnableRequestLine(dma, line, peripheral);
          dma->CH[channel].CFGL &= (uint32_t)~GPDMA0_CH_CFGL_HS_SEL_SRC_Msk;
 80220b4:	2358      	movs	r3, #88	; 0x58
 80220b6:	fb03 4306 	mla	r3, r3, r6, r4
 80220ba:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80220bc:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 80220c0:	641a      	str	r2, [r3, #64]	; 0x40
 80220c2:	e782      	b.n	8021fca <XMC_DMA_CH_Init+0x8a>

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 80220c4:	2000      	movs	r0, #0
 80220c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_CONTIGUOUS:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)((uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk |
 80220c8:	2158      	movs	r1, #88	; 0x58
 80220ca:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 80220ce:	2000      	movs	r0, #0
        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_CONTIGUOUS:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)((uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk |
 80220d0:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80220d2:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 80220d6:	6423      	str	r3, [r4, #64]	; 0x40
                                              (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk);
          break;
 80220d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_CONTIGUOUS_DSTADR_LINKED:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_DST_EN_Msk;
 80220da:	2158      	movs	r1, #88	; 0x58
 80220dc:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 80220e0:	2000      	movs	r0, #0
          dma->CH[channel].CFGL |= (uint32_t)((uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk |
                                              (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk);
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_CONTIGUOUS_DSTADR_LINKED:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_DST_EN_Msk;
 80220e2:	69a3      	ldr	r3, [r4, #24]
 80220e4:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 80220e8:	61a3      	str	r3, [r4, #24]
          break;
 80220ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_LINKED:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
 80220ec:	2158      	movs	r1, #88	; 0x58
 80220ee:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 80220f2:	2000      	movs	r0, #0
        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_CONTIGUOUS_DSTADR_LINKED:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_DST_EN_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_LINKED:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
 80220f4:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80220f6:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 80220fa:	6423      	str	r3, [r4, #64]	; 0x40
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_DST_EN_Msk;
 80220fc:	69a3      	ldr	r3, [r4, #24]
 80220fe:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 8022102:	61a3      	str	r3, [r4, #24]
          break;
 8022104:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_CONTIGUOUS:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk;
 8022106:	2158      	movs	r1, #88	; 0x58
 8022108:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 802210c:	2000      	movs	r0, #0
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_DST_EN_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_CONTIGUOUS:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk;
 802210e:	69a3      	ldr	r3, [r4, #24]
 8022110:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8022114:	61a3      	str	r3, [r4, #24]
          break;
 8022116:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      {
        case XMC_DMA_CH_TRANSFER_TYPE_SINGLE_BLOCK:
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_CONTIGUOUS_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk;
 8022118:	2158      	movs	r1, #88	; 0x58
 802211a:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 802211e:	2000      	movs	r0, #0
      {
        case XMC_DMA_CH_TRANSFER_TYPE_SINGLE_BLOCK:
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_CONTIGUOUS_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk;
 8022120:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8022122:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8022126:	6423      	str	r3, [r4, #64]	; 0x40
          break;
 8022128:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_CONTIGUOUS:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
 802212a:	2158      	movs	r1, #88	; 0x58
 802212c:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 8022130:	2000      	movs	r0, #0
        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_CONTIGUOUS_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_CONTIGUOUS:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
 8022132:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8022134:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8022138:	6423      	str	r3, [r4, #64]	; 0x40
          break;
 802213a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_CONTIGUOUS:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk;
 802213c:	2158      	movs	r1, #88	; 0x58
 802213e:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 8022142:	2000      	movs	r0, #0
        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_CONTIGUOUS:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk;
 8022144:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8022146:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 802214a:	6423      	str	r3, [r4, #64]	; 0x40
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk;
 802214c:	69a3      	ldr	r3, [r4, #24]
 802214e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8022152:	61a3      	str	r3, [r4, #24]
          break;
 8022154:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_LINKED:
          dma->CH[channel].CTLL |= (uint32_t)((uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk |
 8022156:	2158      	movs	r1, #88	; 0x58
 8022158:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 802215c:	2000      	movs	r0, #0
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk;
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_LINKED:
          dma->CH[channel].CTLL |= (uint32_t)((uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk |
 802215e:	69a3      	ldr	r3, [r4, #24]
 8022160:	f043 53c0 	orr.w	r3, r3, #402653184	; 0x18000000
 8022164:	61a3      	str	r3, [r4, #24]
                                              (uint32_t)GPDMA0_CH_CTLL_LLP_DST_EN_Msk);
          break;
 8022166:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
          {
#endif
            line = config->src_peripheral_request & GPDMA0_CH_CFGH_PER_Msk;
 8022168:	f003 0007 	and.w	r0, r3, #7
            line = config->src_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
          }
#endif
          peripheral = config->src_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_SRC_PER_Pos);
 802216c:	ea47 17c0 	orr.w	r7, r7, r0, lsl #7
 8022170:	6457      	str	r7, [r2, #68]	; 0x44
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8022172:	688f      	ldr	r7, [r1, #8]
 8022174:	ea4f 0e80 	mov.w	lr, r0, lsl #2
 8022178:	220f      	movs	r2, #15
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 802217a:	091b      	lsrs	r3, r3, #4
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 802217c:	fa02 f20e 	lsl.w	r2, r2, lr
 8022180:	ea27 0202 	bic.w	r2, r7, r2
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 8022184:	fa03 f30e 	lsl.w	r3, r3, lr
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8022188:	4313      	orrs	r3, r2
 802218a:	608b      	str	r3, [r1, #8]
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
 802218c:	690a      	ldr	r2, [r1, #16]
 802218e:	2301      	movs	r3, #1
 8022190:	4083      	lsls	r3, r0
 8022192:	4313      	orrs	r3, r2
 8022194:	610b      	str	r3, [r1, #16]
 8022196:	e78d      	b.n	80220b4 <XMC_DMA_CH_Init+0x174>
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
          {
#endif
            line = config->dst_peripheral_request & GPDMA0_CH_CFGH_PER_Msk;
 8022198:	f003 0007 	and.w	r0, r3, #7
            line = config->dst_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
          }
#endif
          peripheral = config->dst_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_DEST_PER_Pos);
 802219c:	ea47 27c0 	orr.w	r7, r7, r0, lsl #11
 80221a0:	6457      	str	r7, [r2, #68]	; 0x44
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 80221a2:	688f      	ldr	r7, [r1, #8]
 80221a4:	ea4f 0e80 	mov.w	lr, r0, lsl #2
 80221a8:	220f      	movs	r2, #15
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 80221aa:	091b      	lsrs	r3, r3, #4
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 80221ac:	fa02 f20e 	lsl.w	r2, r2, lr
 80221b0:	ea27 0202 	bic.w	r2, r7, r2
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 80221b4:	fa03 f30e 	lsl.w	r3, r3, lr
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 80221b8:	4313      	orrs	r3, r2
 80221ba:	608b      	str	r3, [r1, #8]
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
 80221bc:	690a      	ldr	r2, [r1, #16]
 80221be:	2301      	movs	r3, #1
 80221c0:	4083      	lsls	r3, r0
 80221c2:	4313      	orrs	r3, r2
 80221c4:	610b      	str	r3, [r1, #16]
 80221c6:	e74c      	b.n	8022062 <XMC_DMA_CH_Init+0x122>
 80221c8:	50014000 	.word	0x50014000
 80221cc:	20000020 	.word	0x20000020
 80221d0:	20000010 	.word	0x20000010
 80221d4:	50004900 	.word	0x50004900

080221d8 <XMC_DMA_CH_EnableEvent>:

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & ((uint32_t)0x1UL << event_idx))
    {
      dma->MASKCHEV[event_idx * 2UL] = ((uint32_t)0x101UL << channel);
 80221d8:	f240 1301 	movw	r3, #257	; 0x101
 80221dc:	408b      	lsls	r3, r1
{
  uint32_t event_idx;

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & ((uint32_t)0x1UL << event_idx))
 80221de:	07d1      	lsls	r1, r2, #31
    {
      dma->MASKCHEV[event_idx * 2UL] = ((uint32_t)0x101UL << channel);
 80221e0:	bf48      	it	mi
 80221e2:	f8c0 3310 	strmi.w	r3, [r0, #784]	; 0x310
{
  uint32_t event_idx;

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & ((uint32_t)0x1UL << event_idx))
 80221e6:	0791      	lsls	r1, r2, #30
    {
      dma->MASKCHEV[event_idx * 2UL] = ((uint32_t)0x101UL << channel);
 80221e8:	bf48      	it	mi
 80221ea:	f8c0 3318 	strmi.w	r3, [r0, #792]	; 0x318
{
  uint32_t event_idx;

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & ((uint32_t)0x1UL << event_idx))
 80221ee:	0751      	lsls	r1, r2, #29
    {
      dma->MASKCHEV[event_idx * 2UL] = ((uint32_t)0x101UL << channel);
 80221f0:	bf48      	it	mi
 80221f2:	f8c0 3320 	strmi.w	r3, [r0, #800]	; 0x320
{
  uint32_t event_idx;

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & ((uint32_t)0x1UL << event_idx))
 80221f6:	0711      	lsls	r1, r2, #28
    {
      dma->MASKCHEV[event_idx * 2UL] = ((uint32_t)0x101UL << channel);
 80221f8:	bf48      	it	mi
 80221fa:	f8c0 3328 	strmi.w	r3, [r0, #808]	; 0x328
{
  uint32_t event_idx;

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & ((uint32_t)0x1UL << event_idx))
 80221fe:	06d2      	lsls	r2, r2, #27
    {
      dma->MASKCHEV[event_idx * 2UL] = ((uint32_t)0x101UL << channel);
 8022200:	bf48      	it	mi
 8022202:	f8c0 3330 	strmi.w	r3, [r0, #816]	; 0x330
 8022206:	4770      	bx	lr

08022208 <XMC_DMA_CH_SetEventHandler>:

/* Set event handler */
void XMC_DMA_CH_SetEventHandler(XMC_DMA_t *const dma, const uint8_t channel, XMC_DMA_CH_EVENT_HANDLER_t event_handler)
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8022208:	4b03      	ldr	r3, [pc, #12]	; (8022218 <XMC_DMA_CH_SetEventHandler+0x10>)
 802220a:	4298      	cmp	r0, r3
  {
#endif
    dma0_event_handlers[channel] = event_handler;
 802220c:	bf0c      	ite	eq
 802220e:	4b03      	ldreq	r3, [pc, #12]	; (802221c <XMC_DMA_CH_SetEventHandler+0x14>)
#if defined(GPDMA1)
  }
  else
  {
    dma1_event_handlers[channel] = event_handler;
 8022210:	4b03      	ldrne	r3, [pc, #12]	; (8022220 <XMC_DMA_CH_SetEventHandler+0x18>)
 8022212:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
 8022216:	4770      	bx	lr
 8022218:	50014000 	.word	0x50014000
 802221c:	2000d328 	.word	0x2000d328
 8022220:	2000d348 	.word	0x2000d348

08022224 <XMC_DMA_CH_ClearSourcePeripheralRequest>:
}

void XMC_DMA_CH_ClearSourcePeripheralRequest(XMC_DMA_t *const dma, uint8_t channel)
{
  uint32_t line;
  line = (dma->CH[channel].CFGH & GPDMA0_CH_CFGH_SRC_PER_Msk) >> GPDMA0_CH_CFGH_SRC_PER_Pos;
 8022224:	2358      	movs	r3, #88	; 0x58
 8022226:	fb03 0101 	mla	r1, r3, r1, r0
}

void XMC_DMA_ClearRequestLine(XMC_DMA_t *const dma, uint8_t line)
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 802222a:	4a0a      	ldr	r2, [pc, #40]	; (8022254 <XMC_DMA_CH_ClearSourcePeripheralRequest+0x30>)
}

void XMC_DMA_CH_ClearSourcePeripheralRequest(XMC_DMA_t *const dma, uint8_t channel)
{
  uint32_t line;
  line = (dma->CH[channel].CFGH & GPDMA0_CH_CFGH_SRC_PER_Msk) >> GPDMA0_CH_CFGH_SRC_PER_Pos;
 802222c:	6c4b      	ldr	r3, [r1, #68]	; 0x44
 802222e:	f3c3 11c3 	ubfx	r1, r3, #7, #4
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->LNEN &= ~(0x1UL << line);
 8022232:	4b09      	ldr	r3, [pc, #36]	; (8022258 <XMC_DMA_CH_ClearSourcePeripheralRequest+0x34>)
}

void XMC_DMA_ClearRequestLine(XMC_DMA_t *const dma, uint8_t line)
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8022234:	4290      	cmp	r0, r2
  {
#endif
    DLR->LNEN &= ~(0x1UL << line);
 8022236:	bf08      	it	eq
 8022238:	2201      	moveq	r2, #1
	DLR->LNEN |= 0x1UL << line;
#if defined(GPDMA1)
  }
  else
  {
    DLR->LNEN &= ~(0x100UL << line);
 802223a:	6918      	ldr	r0, [r3, #16]
 802223c:	bf18      	it	ne
 802223e:	f44f 7280 	movne.w	r2, #256	; 0x100
 8022242:	408a      	lsls	r2, r1
 8022244:	ea20 0102 	bic.w	r1, r0, r2
 8022248:	6119      	str	r1, [r3, #16]
	DLR->LNEN |= 0x100UL << line;
 802224a:	6919      	ldr	r1, [r3, #16]
 802224c:	430a      	orrs	r2, r1
 802224e:	611a      	str	r2, [r3, #16]
 8022250:	4770      	bx	lr
 8022252:	bf00      	nop
 8022254:	50014000 	.word	0x50014000
 8022258:	50004900 	.word	0x50004900

0802225c <XMC_DMA_IRQHandler>:
    dma_event_handlers = dma0_event_handlers;
#if defined(GPDMA1)
  }
  else
  {
    dma_event_handlers = dma1_event_handlers;
 802225c:	4a5a      	ldr	r2, [pc, #360]	; (80223c8 <XMC_DMA_IRQHandler+0x16c>)
 802225e:	495b      	ldr	r1, [pc, #364]	; (80223cc <XMC_DMA_IRQHandler+0x170>)
 * Destination transaction complete -> ::XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE <br>
 * DMA error event -> ::XMC_DMA_CH_EVENT_ERROR                                     <br>
 */
__STATIC_INLINE uint32_t XMC_DMA_GetEventStatus(XMC_DMA_t *const dma)
{
  return (dma->STATUSGLEV);
 8022260:	f8d0 3360 	ldr.w	r3, [r0, #864]	; 0x360
  XMC_DMA_ClearRequestLine(dma, (uint8_t)line);
}

/* Default DMA IRQ handler */
void XMC_DMA_IRQHandler(XMC_DMA_t *const dma)
{
 8022264:	b430      	push	{r4, r5}
  uint32_t mask;
  XMC_DMA_CH_EVENT_HANDLER_t *dma_event_handlers;
  XMC_DMA_CH_EVENT_HANDLER_t event_handler;

#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8022266:	4d5a      	ldr	r5, [pc, #360]	; (80223d0 <XMC_DMA_IRQHandler+0x174>)
    dma_event_handlers = dma0_event_handlers;
#if defined(GPDMA1)
  }
  else
  {
    dma_event_handlers = dma1_event_handlers;
 8022268:	42a8      	cmp	r0, r5
 802226a:	bf0c      	ite	eq
 802226c:	460d      	moveq	r5, r1
 802226e:	4615      	movne	r5, r2
#endif
  
  event = XMC_DMA_GetEventStatus(dma);
  channel = 0;

  if ((event & (uint32_t)XMC_DMA_CH_EVENT_ERROR) != (uint32_t)0UL)
 8022270:	f013 0210 	ands.w	r2, r3, #16
 8022274:	d01d      	beq.n	80222b2 <XMC_DMA_IRQHandler+0x56>
 * \par
 * The function returns error interrupt status. <br>
 */
__STATIC_INLINE uint32_t XMC_DMA_GetChannelsErrorStatus(XMC_DMA_t *const dma)
{
  return (dma->STATUSCHEV[8]);
 8022276:	f8d0 1308 	ldr.w	r1, [r0, #776]	; 0x308
  {
    event = XMC_DMA_GetChannelsErrorStatus(dma);
    while (event != 0)
 802227a:	b1c1      	cbz	r1, 80222ae <XMC_DMA_IRQHandler+0x52>
    {
      mask = (uint32_t)1U << channel;
      if ((event & mask) != 0)
 802227c:	07cb      	lsls	r3, r1, #31
 802227e:	f100 8097 	bmi.w	80223b0 <XMC_DMA_IRQHandler+0x154>
 8022282:	2301      	movs	r3, #1
  if ((event & (uint32_t)XMC_DMA_CH_EVENT_ERROR) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsErrorStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 8022284:	461c      	mov	r4, r3
 8022286:	e000      	b.n	802228a <XMC_DMA_IRQHandler+0x2e>
          event_handler(XMC_DMA_CH_EVENT_ERROR);
        }
       
        break;
      }
      ++channel;
 8022288:	3301      	adds	r3, #1
  if ((event & (uint32_t)XMC_DMA_CH_EVENT_ERROR) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsErrorStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 802228a:	fa04 f203 	lsl.w	r2, r4, r3
      if ((event & mask) != 0)
 802228e:	420a      	tst	r2, r1
 8022290:	d0fa      	beq.n	8022288 <XMC_DMA_IRQHandler+0x2c>
 8022292:	009a      	lsls	r2, r3, #2
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)XMC_DMA_CH_EVENT_ERROR);

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
 8022294:	58a9      	ldr	r1, [r5, r2]

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 8022296:	b2db      	uxtb	r3, r3
 8022298:	2201      	movs	r2, #1
 802229a:	fa02 f303 	lsl.w	r3, r2, r3
 802229e:	f8c0 3358 	str.w	r3, [r0, #856]	; 0x358
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)XMC_DMA_CH_EVENT_ERROR);

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
 80222a2:	b121      	cbz	r1, 80222ae <XMC_DMA_IRQHandler+0x52>
        {
          event_handler(XMC_DMA_CH_EVENT_ERROR);
 80222a4:	2010      	movs	r0, #16
  else
  {
    /* no active interrupt was found? */
  }

}
 80222a6:	bc30      	pop	{r4, r5}

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
        {
          event_handler(XMC_DMA_CH_EVENT_ERROR);
 80222a8:	4708      	bx	r1
        break;
      }
      ++channel;
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE) != (uint32_t)0UL)
 80222aa:	071a      	lsls	r2, r3, #28
 80222ac:	d465      	bmi.n	802237a <XMC_DMA_IRQHandler+0x11e>
  else
  {
    /* no active interrupt was found? */
  }

}
 80222ae:	bc30      	pop	{r4, r5}
 80222b0:	4770      	bx	lr
        break;
      }
      ++channel;
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_TRANSFER_COMPLETE) != (uint32_t)0UL)
 80222b2:	f013 0401 	ands.w	r4, r3, #1
 80222b6:	d020      	beq.n	80222fa <XMC_DMA_IRQHandler+0x9e>
 * \par
 * The function returns GPDMA transfer complete interrupt status. <br>
 */
__STATIC_INLINE uint32_t XMC_DMA_GetChannelsTransferCompleteStatus(XMC_DMA_t *const dma)
{
  return (dma->STATUSCHEV[0]);
 80222b8:	f8d0 12e8 	ldr.w	r1, [r0, #744]	; 0x2e8
  {
    event = XMC_DMA_GetChannelsTransferCompleteStatus(dma);
    while (event != 0)
 80222bc:	2900      	cmp	r1, #0
 80222be:	d0f6      	beq.n	80222ae <XMC_DMA_IRQHandler+0x52>
    {
      mask = (uint32_t)1U << channel;
      if (event & mask)
 80222c0:	07cc      	lsls	r4, r1, #31
 80222c2:	d478      	bmi.n	80223b6 <XMC_DMA_IRQHandler+0x15a>
 80222c4:	2301      	movs	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_TRANSFER_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsTransferCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 80222c6:	461c      	mov	r4, r3
 80222c8:	e000      	b.n	80222cc <XMC_DMA_IRQHandler+0x70>
          event_handler(XMC_DMA_CH_EVENT_TRANSFER_COMPLETE);
        }
																	  
        break;
      }
      ++channel;
 80222ca:	3301      	adds	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_TRANSFER_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsTransferCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 80222cc:	fa04 f203 	lsl.w	r2, r4, r3
      if (event & mask)
 80222d0:	420a      	tst	r2, r1
 80222d2:	d0fa      	beq.n	80222ca <XMC_DMA_IRQHandler+0x6e>
 80222d4:	009a      	lsls	r2, r3, #2
                                                                      (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE | 
                                                                      (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE | 
                                                                      (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE));

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
 80222d6:	58aa      	ldr	r2, [r5, r2]

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 80222d8:	b2db      	uxtb	r3, r3
 80222da:	2101      	movs	r1, #1
 80222dc:	fa01 f303 	lsl.w	r3, r1, r3
 80222e0:	f8c0 3338 	str.w	r3, [r0, #824]	; 0x338
 80222e4:	f8c0 3340 	str.w	r3, [r0, #832]	; 0x340
 80222e8:	f8c0 3348 	str.w	r3, [r0, #840]	; 0x348
 80222ec:	f8c0 3350 	str.w	r3, [r0, #848]	; 0x350
                                                                      (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE | 
                                                                      (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE));

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
 80222f0:	2a00      	cmp	r2, #0
 80222f2:	d0dc      	beq.n	80222ae <XMC_DMA_IRQHandler+0x52>
        {
          event_handler(XMC_DMA_CH_EVENT_TRANSFER_COMPLETE);
 80222f4:	4608      	mov	r0, r1
  else
  {
    /* no active interrupt was found? */
  }

}
 80222f6:	bc30      	pop	{r4, r5}

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
        {
          event_handler(XMC_DMA_CH_EVENT_TRANSFER_COMPLETE);
 80222f8:	4710      	bx	r2
        break;
      }
      ++channel;
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE) != (uint32_t)0UL)
 80222fa:	f013 0202 	ands.w	r2, r3, #2
 80222fe:	d11d      	bne.n	802233c <XMC_DMA_IRQHandler+0xe0>
        break;
      }
      ++channel;
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE) != (uint32_t)0UL)
 8022300:	f013 0404 	ands.w	r4, r3, #4
 8022304:	d0d1      	beq.n	80222aa <XMC_DMA_IRQHandler+0x4e>
 * If the source peripheral is memory, the source transaction complete interrupt is
 * ignored.
 */
__STATIC_INLINE uint32_t XMC_DMA_GetChannelsSourceTransactionCompleteStatus(XMC_DMA_t *const dma)
{
  return (dma->STATUSCHEV[4]);
 8022306:	f8d0 12f8 	ldr.w	r1, [r0, #760]	; 0x2f8
  {
    event = XMC_DMA_GetChannelsSourceTransactionCompleteStatus(dma);
    while (event != 0)
 802230a:	2900      	cmp	r1, #0
 802230c:	d0cf      	beq.n	80222ae <XMC_DMA_IRQHandler+0x52>
    {
      mask = (uint32_t)1U << channel;
      if (event & mask)
 802230e:	07cc      	lsls	r4, r1, #31
 8022310:	d455      	bmi.n	80223be <XMC_DMA_IRQHandler+0x162>
 8022312:	2301      	movs	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsSourceTransactionCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 8022314:	461c      	mov	r4, r3
 8022316:	e000      	b.n	802231a <XMC_DMA_IRQHandler+0xbe>
          event_handler(XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE);
        }
        
        break;
      }
      ++channel;
 8022318:	3301      	adds	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsSourceTransactionCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 802231a:	fa04 f203 	lsl.w	r2, r4, r3
      if (event & mask)
 802231e:	420a      	tst	r2, r1
 8022320:	d0fa      	beq.n	8022318 <XMC_DMA_IRQHandler+0xbc>
 8022322:	009a      	lsls	r2, r3, #2
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE);

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
 8022324:	58a9      	ldr	r1, [r5, r2]

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 8022326:	b2db      	uxtb	r3, r3
 8022328:	2201      	movs	r2, #1
 802232a:	fa02 f303 	lsl.w	r3, r2, r3
 802232e:	f8c0 3348 	str.w	r3, [r0, #840]	; 0x348
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE);

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
 8022332:	2900      	cmp	r1, #0
 8022334:	d0bb      	beq.n	80222ae <XMC_DMA_IRQHandler+0x52>
        {
          event_handler(XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE);
 8022336:	2004      	movs	r0, #4
  else
  {
    /* no active interrupt was found? */
  }

}
 8022338:	bc30      	pop	{r4, r5}

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
        {
          event_handler(XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE);
 802233a:	4708      	bx	r1
 * \par
 * The function returns GPDMA block transfer complete interrupt status. <br>
 */
__STATIC_INLINE uint32_t XMC_DMA_GetChannelsBlockCompleteStatus(XMC_DMA_t *const dma)
{
  return (dma->STATUSCHEV[2]);
 802233c:	f8d0 12f0 	ldr.w	r1, [r0, #752]	; 0x2f0
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsBlockCompleteStatus(dma);
    while (event != 0)
 8022340:	2900      	cmp	r1, #0
 8022342:	d0b4      	beq.n	80222ae <XMC_DMA_IRQHandler+0x52>
    {
      mask = (uint32_t)1U << channel;
      if (event & mask)
 8022344:	07cb      	lsls	r3, r1, #31
 8022346:	d438      	bmi.n	80223ba <XMC_DMA_IRQHandler+0x15e>
 8022348:	2301      	movs	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsBlockCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 802234a:	461c      	mov	r4, r3
 802234c:	e000      	b.n	8022350 <XMC_DMA_IRQHandler+0xf4>
          event_handler(XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE);
        }

        break;
      }
      ++channel;
 802234e:	3301      	adds	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsBlockCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 8022350:	fa04 f203 	lsl.w	r2, r4, r3
      if (event & mask)
 8022354:	420a      	tst	r2, r1
 8022356:	d0fa      	beq.n	802234e <XMC_DMA_IRQHandler+0xf2>
 8022358:	009c      	lsls	r4, r3, #2
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)((uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE |
                                                                      (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE | 
                                                                      (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE));

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
 802235a:	5929      	ldr	r1, [r5, r4]

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 802235c:	b2db      	uxtb	r3, r3
 802235e:	2201      	movs	r2, #1
 8022360:	fa02 f303 	lsl.w	r3, r2, r3
 8022364:	f8c0 3340 	str.w	r3, [r0, #832]	; 0x340
 8022368:	f8c0 3348 	str.w	r3, [r0, #840]	; 0x348
 802236c:	f8c0 3350 	str.w	r3, [r0, #848]	; 0x350
                                                                      (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE | 
                                                                      (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE));

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
 8022370:	2900      	cmp	r1, #0
 8022372:	d09c      	beq.n	80222ae <XMC_DMA_IRQHandler+0x52>
        {
          event_handler(XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE);
 8022374:	2002      	movs	r0, #2
  else
  {
    /* no active interrupt was found? */
  }

}
 8022376:	bc30      	pop	{r4, r5}

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
        {
          event_handler(XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE);
 8022378:	4708      	bx	r1
 * If the destination peripheral is memory, the destination transaction complete
 * interrupt is ignored.
 */
__STATIC_INLINE uint32_t XMC_DMA_GetChannelsDestinationTransactionCompleteStatus(XMC_DMA_t *const dma)
{
  return (dma->STATUSCHEV[6]);
 802237a:	f8d0 1300 	ldr.w	r1, [r0, #768]	; 0x300
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsDestinationTransactionCompleteStatus(dma);
    while (event != 0)
 802237e:	2900      	cmp	r1, #0
 8022380:	d095      	beq.n	80222ae <XMC_DMA_IRQHandler+0x52>
    {
      mask = (uint32_t)1U << channel;
      if (event & mask)
 8022382:	07cb      	lsls	r3, r1, #31
 8022384:	d41d      	bmi.n	80223c2 <XMC_DMA_IRQHandler+0x166>
 8022386:	2301      	movs	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsDestinationTransactionCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 8022388:	461c      	mov	r4, r3
 802238a:	e000      	b.n	802238e <XMC_DMA_IRQHandler+0x132>
          event_handler(XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE);
        }      

        break;
      }
      ++channel;
 802238c:	3301      	adds	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsDestinationTransactionCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 802238e:	fa04 f203 	lsl.w	r2, r4, r3
      if (event & mask)
 8022392:	420a      	tst	r2, r1
 8022394:	d0fa      	beq.n	802238c <XMC_DMA_IRQHandler+0x130>
 8022396:	009c      	lsls	r4, r3, #2

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 8022398:	b2db      	uxtb	r3, r3
      if (event & mask)
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE);

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
 802239a:	5929      	ldr	r1, [r5, r4]

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 802239c:	2201      	movs	r2, #1
 802239e:	fa02 f303 	lsl.w	r3, r2, r3
 80223a2:	f8c0 3350 	str.w	r3, [r0, #848]	; 0x350
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE);

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
 80223a6:	2900      	cmp	r1, #0
 80223a8:	d081      	beq.n	80222ae <XMC_DMA_IRQHandler+0x52>
        {
          event_handler(XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE);
 80223aa:	2008      	movs	r0, #8
  else
  {
    /* no active interrupt was found? */
  }

}
 80223ac:	bc30      	pop	{r4, r5}

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
        {
          event_handler(XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE);
 80223ae:	4708      	bx	r1
  {
    event = XMC_DMA_GetChannelsErrorStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
      if ((event & mask) != 0)
 80223b0:	2200      	movs	r2, #0
    dma_event_handlers = dma1_event_handlers;
  }
#endif
  
  event = XMC_DMA_GetEventStatus(dma);
  channel = 0;
 80223b2:	4613      	mov	r3, r2
 80223b4:	e76e      	b.n	8022294 <XMC_DMA_IRQHandler+0x38>
 80223b6:	4613      	mov	r3, r2
 80223b8:	e78d      	b.n	80222d6 <XMC_DMA_IRQHandler+0x7a>
 80223ba:	4623      	mov	r3, r4
 80223bc:	e7cd      	b.n	802235a <XMC_DMA_IRQHandler+0xfe>
 80223be:	4613      	mov	r3, r2
 80223c0:	e7b0      	b.n	8022324 <XMC_DMA_IRQHandler+0xc8>
 80223c2:	4623      	mov	r3, r4
 80223c4:	e7e8      	b.n	8022398 <XMC_DMA_IRQHandler+0x13c>
 80223c6:	bf00      	nop
 80223c8:	2000d348 	.word	0x2000d348
 80223cc:	2000d328 	.word	0x2000d328
 80223d0:	50014000 	.word	0x50014000

080223d4 <XMC_ERU_ETL_Init>:
 ********************************************************************************************************************/
/* Initializes the selected ERU_ETLx channel with the config structure.  */
void XMC_ERU_ETL_Init(XMC_ERU_t *const eru,
                      const uint8_t channel,
                      const XMC_ERU_ETL_CONFIG_t *const config)
{ 
 80223d4:	b570      	push	{r4, r5, r6, lr}
 80223d6:	4616      	mov	r6, r2
 80223d8:	4605      	mov	r5, r0
 80223da:	460c      	mov	r4, r1
  XMC_ASSERT("XMC_ERU_ETL_Init:Invalid Module Pointer", XMC_ERU_CHECK_MODULE_PTR(eru));
  XMC_ASSERT("XMC_ERU_ETL_Init:Invalid Channel Number", (channel < 4U));

  XMC_ERU_Enable(eru);
 80223dc:	f7ff f8d2 	bl	8021584 <XMC_ERU_Enable>

  eru->EXISEL = (eru->EXISEL & 
                 ~((uint32_t)(ERU_EXISEL_EXS0A_Msk | ERU_EXISEL_EXS0B_Msk) << (channel * ERU_EXISEL_BITSIZE))) |
 80223e0:	00a2      	lsls	r2, r4, #2
  XMC_ASSERT("XMC_ERU_ETL_Init:Invalid Module Pointer", XMC_ERU_CHECK_MODULE_PTR(eru));
  XMC_ASSERT("XMC_ERU_ETL_Init:Invalid Channel Number", (channel < 4U));

  XMC_ERU_Enable(eru);

  eru->EXISEL = (eru->EXISEL & 
 80223e2:	6828      	ldr	r0, [r5, #0]
                 ~((uint32_t)(ERU_EXISEL_EXS0A_Msk | ERU_EXISEL_EXS0B_Msk) << (channel * ERU_EXISEL_BITSIZE))) |
                (config->input << (channel * (uint32_t)ERU_EXISEL_BITSIZE));
 80223e4:	6833      	ldr	r3, [r6, #0]
  XMC_ASSERT("XMC_ERU_ETL_Init:Invalid Channel Number", (channel < 4U));

  XMC_ERU_Enable(eru);

  eru->EXISEL = (eru->EXISEL & 
                 ~((uint32_t)(ERU_EXISEL_EXS0A_Msk | ERU_EXISEL_EXS0B_Msk) << (channel * ERU_EXISEL_BITSIZE))) |
 80223e6:	210f      	movs	r1, #15
 80223e8:	4091      	lsls	r1, r2
  XMC_ASSERT("XMC_ERU_ETL_Init:Invalid Module Pointer", XMC_ERU_CHECK_MODULE_PTR(eru));
  XMC_ASSERT("XMC_ERU_ETL_Init:Invalid Channel Number", (channel < 4U));

  XMC_ERU_Enable(eru);

  eru->EXISEL = (eru->EXISEL & 
 80223ea:	ea20 0101 	bic.w	r1, r0, r1
                 ~((uint32_t)(ERU_EXISEL_EXS0A_Msk | ERU_EXISEL_EXS0B_Msk) << (channel * ERU_EXISEL_BITSIZE))) |
                (config->input << (channel * (uint32_t)ERU_EXISEL_BITSIZE));
 80223ee:	4093      	lsls	r3, r2
  XMC_ASSERT("XMC_ERU_ETL_Init:Invalid Channel Number", (channel < 4U));

  XMC_ERU_Enable(eru);

  eru->EXISEL = (eru->EXISEL & 
                 ~((uint32_t)(ERU_EXISEL_EXS0A_Msk | ERU_EXISEL_EXS0B_Msk) << (channel * ERU_EXISEL_BITSIZE))) |
 80223f0:	430b      	orrs	r3, r1
  XMC_ASSERT("XMC_ERU_ETL_Init:Invalid Module Pointer", XMC_ERU_CHECK_MODULE_PTR(eru));
  XMC_ASSERT("XMC_ERU_ETL_Init:Invalid Channel Number", (channel < 4U));

  XMC_ERU_Enable(eru);

  eru->EXISEL = (eru->EXISEL & 
 80223f2:	602b      	str	r3, [r5, #0]
                 ~((uint32_t)(ERU_EXISEL_EXS0A_Msk | ERU_EXISEL_EXS0B_Msk) << (channel * ERU_EXISEL_BITSIZE))) |
                (config->input << (channel * (uint32_t)ERU_EXISEL_BITSIZE));
  
  eru->EXICON[channel] = config->raw;
 80223f4:	3404      	adds	r4, #4
 80223f6:	6873      	ldr	r3, [r6, #4]
 80223f8:	f845 3024 	str.w	r3, [r5, r4, lsl #2]
 80223fc:	bd70      	pop	{r4, r5, r6, pc}
 80223fe:	bf00      	nop

08022400 <XMC_ERU_OGU_Init>:

/* Initializes the selected ERU_OGUy channel with the config structure.  */
void XMC_ERU_OGU_Init(XMC_ERU_t *const eru,
                      const uint8_t channel,
                      const XMC_ERU_OGU_CONFIG_t *const config)
{
 8022400:	b570      	push	{r4, r5, r6, lr}
 8022402:	460c      	mov	r4, r1
 8022404:	4616      	mov	r6, r2
 8022406:	4605      	mov	r5, r0
  XMC_ASSERT("XMC_ERU_OGU_Init:Invalid Module Pointer", XMC_ERU_CHECK_MODULE_PTR(eru));
  XMC_ASSERT("XMC_ERU_OGU_Init:Invalid Channel Number", (channel < 4U));

  XMC_ERU_Enable(eru);

  eru->EXOCON[channel] = config->raw;
 8022408:	3408      	adds	r4, #8
                      const XMC_ERU_OGU_CONFIG_t *const config)
{
  XMC_ASSERT("XMC_ERU_OGU_Init:Invalid Module Pointer", XMC_ERU_CHECK_MODULE_PTR(eru));
  XMC_ASSERT("XMC_ERU_OGU_Init:Invalid Channel Number", (channel < 4U));

  XMC_ERU_Enable(eru);
 802240a:	f7ff f8bb 	bl	8021584 <XMC_ERU_Enable>

  eru->EXOCON[channel] = config->raw;
 802240e:	6833      	ldr	r3, [r6, #0]
 8022410:	f845 3024 	str.w	r3, [r5, r4, lsl #2]
 8022414:	bd70      	pop	{r4, r5, r6, pc}
 8022416:	bf00      	nop

08022418 <XMC_FCE_Init>:
/*
 * Initialize the FCE peripheral:
 * Update FCE configuration and initialize seed value
 */
XMC_FCE_STATUS_t XMC_FCE_Init(const XMC_FCE_t *const engine)
{
 8022418:	4603      	mov	r3, r0
  engine->kernel_ptr->CFG = engine->fce_cfg_update.regval;
  engine->kernel_ptr->CRC = engine->seedvalue;
  
  return XMC_FCE_STATUS_OK;
}
 802241a:	2000      	movs	r0, #0
 * Initialize the FCE peripheral:
 * Update FCE configuration and initialize seed value
 */
XMC_FCE_STATUS_t XMC_FCE_Init(const XMC_FCE_t *const engine)
{
  engine->kernel_ptr->CFG = engine->fce_cfg_update.regval;
 802241c:	681a      	ldr	r2, [r3, #0]
 802241e:	6859      	ldr	r1, [r3, #4]
  engine->kernel_ptr->CRC = engine->seedvalue;
 8022420:	689b      	ldr	r3, [r3, #8]
 * Initialize the FCE peripheral:
 * Update FCE configuration and initialize seed value
 */
XMC_FCE_STATUS_t XMC_FCE_Init(const XMC_FCE_t *const engine)
{
  engine->kernel_ptr->CFG = engine->fce_cfg_update.regval;
 8022422:	6091      	str	r1, [r2, #8]
  engine->kernel_ptr->CRC = engine->seedvalue;
 8022424:	6193      	str	r3, [r2, #24]
  
  return XMC_FCE_STATUS_OK;
}
 8022426:	4770      	bx	lr

08022428 <XMC_FCE_Enable>:

}

/* Enable FCE */
void XMC_FCE_Enable(void)
{
 8022428:	b510      	push	{r4, lr}
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_FCE);
 802242a:	4c06      	ldr	r4, [pc, #24]	; (8022444 <XMC_FCE_Enable+0x1c>)
 802242c:	4620      	mov	r0, r4
 802242e:	f7ff f9d7 	bl	80217e0 <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif

  XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_FCE);
 8022432:	4620      	mov	r0, r4
 8022434:	f7ff f964 	bl	8021700 <XMC_SCU_RESET_DeassertPeripheralReset>

  FCE->CLC &= (uint32_t)~FCE_CLC_DISR_Msk;
 8022438:	4a03      	ldr	r2, [pc, #12]	; (8022448 <XMC_FCE_Enable+0x20>)
 802243a:	6813      	ldr	r3, [r2, #0]
 802243c:	f023 0301 	bic.w	r3, r3, #1
 8022440:	6013      	str	r3, [r2, #0]
 8022442:	bd10      	pop	{r4, pc}
 8022444:	20000040 	.word	0x20000040
 8022448:	50020000 	.word	0x50020000

0802244c <XMC_FCE_CalculateCRC32>:
  XMC_ASSERT("XMC_FCE_CalculateCRC32: Length field is empty", (length != 0));
  XMC_ASSERT("XMC_FCE_CalculateCRC32: Length is not aligned", ((length & 0x03) == 0));
  XMC_ASSERT("XMC_FCE_CalculateCRC32: Buffer is not aligned", (((uint32_t)data % 4U) == 0));

  /* Check if data and length are word aligned */
  if (((length & 0x03U) != 0U) || (((uint32_t)length % 4U) != 0U))
 802244c:	f012 0f03 	tst.w	r2, #3
 8022450:	d001      	beq.n	8022456 <XMC_FCE_CalculateCRC32+0xa>
  {
    status = XMC_FCE_STATUS_ERROR;
 8022452:	2002      	movs	r0, #2
 8022454:	4770      	bx	lr
/* Calculate and return the IEEE 802.3 Ethernet CRC32 checksum */
XMC_FCE_STATUS_t XMC_FCE_CalculateCRC32(const XMC_FCE_t *const engine,
                                        const uint32_t *data,
										uint32_t length,
										uint32_t *result)
{
 8022456:	b410      	push	{r4}
 8022458:	6804      	ldr	r4, [r0, #0]
  {
    status = XMC_FCE_STATUS_ERROR;
  }
  else
  {
    while (0UL != length)
 802245a:	b122      	cbz	r2, 8022466 <XMC_FCE_CalculateCRC32+0x1a>
    {
      engine->kernel_ptr->IR = *data;
 802245c:	f851 0b04 	ldr.w	r0, [r1], #4
 8022460:	6020      	str	r0, [r4, #0]
  {
    status = XMC_FCE_STATUS_ERROR;
  }
  else
  {
    while (0UL != length)
 8022462:	3a04      	subs	r2, #4
 8022464:	d1fa      	bne.n	802245c <XMC_FCE_CalculateCRC32+0x10>
      engine->kernel_ptr->IR = *data;
      data++;
      length -= 4U;
    }

    *result = engine->kernel_ptr->CRC;
 8022466:	69a2      	ldr	r2, [r4, #24]
 8022468:	601a      	str	r2, [r3, #0]
XMC_FCE_STATUS_t XMC_FCE_CalculateCRC32(const XMC_FCE_t *const engine,
                                        const uint32_t *data,
										uint32_t length,
										uint32_t *result)
{
  XMC_FCE_STATUS_t status = XMC_FCE_STATUS_OK;
 802246a:	2000      	movs	r0, #0

    *result = engine->kernel_ptr->CRC;
  }
  
  return status;
}
 802246c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8022470:	4770      	bx	lr
 8022472:	bf00      	nop

08022474 <XMC_GPIO_SetHardwareControl>:
  port->IOCR[(uint32_t)pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U)));
  port->IOCR[(uint32_t)pin >> 2U] |= (uint32_t)mode << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U));
}

void XMC_GPIO_SetHardwareControl(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_HWCTRL_t hwctrl)
{
 8022474:	b410      	push	{r4}
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid hwctrl", XMC_GPIO_CHECK_HWCTRL(hwctrl));

  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
 8022476:	0049      	lsls	r1, r1, #1
 8022478:	6f44      	ldr	r4, [r0, #116]	; 0x74
 802247a:	2303      	movs	r3, #3
 802247c:	408b      	lsls	r3, r1
 802247e:	ea24 0303 	bic.w	r3, r4, r3
 8022482:	6743      	str	r3, [r0, #116]	; 0x74
  port->HWSEL |= (uint32_t)hwctrl << ((uint32_t)pin << 1U);
 8022484:	6f43      	ldr	r3, [r0, #116]	; 0x74
}
 8022486:	f85d 4b04 	ldr.w	r4, [sp], #4
{
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid hwctrl", XMC_GPIO_CHECK_HWCTRL(hwctrl));

  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
  port->HWSEL |= (uint32_t)hwctrl << ((uint32_t)pin << 1U);
 802248a:	408a      	lsls	r2, r1
 802248c:	4313      	orrs	r3, r2
 802248e:	6743      	str	r3, [r0, #116]	; 0x74
}
 8022490:	4770      	bx	lr
 8022492:	bf00      	nop

08022494 <XMC_USBD_GetCapabilities>:
  cap.event_remote_wakeup = 1U;
  cap.event_reset = 1U;
  cap.event_resume = 1U;
  cap.event_suspend = 1U;
  cap.reserved = 0U;
  return cap;
 8022494:	2000      	movs	r0, #0
 8022496:	f36f 0000 	bfc	r0, #0, #1
 802249a:	f36f 0041 	bfc	r0, #1, #1
 802249e:	f040 001c 	orr.w	r0, r0, #28
 80224a2:	f36f 1045 	bfc	r0, #5, #1
 80224a6:	f440 70e0 	orr.w	r0, r0, #448	; 0x1c0
}
 80224aa:	f3c0 0008 	ubfx	r0, r0, #0, #9
 80224ae:	4770      	bx	lr

080224b0 <XMC_USBD_DeviceConnect>:
 **/
XMC_USBD_STATUS_t XMC_USBD_DeviceConnect() 
{
  /* Just disable softdisconnect */
  dctl_data_t dctl;
	dctl.d32 = xmc_device.device_register->dctl;
 80224b0:	4b04      	ldr	r3, [pc, #16]	; (80224c4 <XMC_USBD_DeviceConnect+0x14>)
 80224b2:	f8d3 21a4 	ldr.w	r2, [r3, #420]	; 0x1a4
 80224b6:	6853      	ldr	r3, [r2, #4]
  dctl.b.sftdiscon = 0U;
 80224b8:	f36f 0341 	bfc	r3, #1, #1
  xmc_device.device_register->dctl = dctl.d32;
 80224bc:	6053      	str	r3, [r2, #4]
  return XMC_USBD_STATUS_OK;
}
 80224be:	2000      	movs	r0, #0
 80224c0:	4770      	bx	lr
 80224c2:	bf00      	nop
 80224c4:	2000d35c 	.word	0x2000d35c

080224c8 <XMC_USBD_DeviceDisconnect>:
 * Disconnects the USB device from host
 **/
XMC_USBD_STATUS_t XMC_USBD_DeviceDisconnect() 
{
  dctl_data_t dctl;
	dctl.d32 = xmc_device.device_register->dctl;
 80224c8:	4b04      	ldr	r3, [pc, #16]	; (80224dc <XMC_USBD_DeviceDisconnect+0x14>)
 80224ca:	f8d3 21a4 	ldr.w	r2, [r3, #420]	; 0x1a4
 80224ce:	6853      	ldr	r3, [r2, #4]
  dctl.b.sftdiscon = 1U;
 80224d0:	f043 0302 	orr.w	r3, r3, #2
  xmc_device.device_register->dctl = dctl.d32;
 80224d4:	6053      	str	r3, [r2, #4]
  return XMC_USBD_STATUS_OK;
}
 80224d6:	2000      	movs	r0, #0
 80224d8:	4770      	bx	lr
 80224da:	bf00      	nop
 80224dc:	2000d35c 	.word	0x2000d35c

080224e0 <XMC_USBD_DeviceGetState>:
 **/
XMC_USBD_STATE_t XMC_USBD_DeviceGetState(const XMC_USBD_t *const obj) 
{
  XMC_USBD_STATE_t state={0U};
  state.speed = XMC_USBD_SPEED_FULL;
  state.connected = xmc_device.IsConnected;
 80224e0:	4a44      	ldr	r2, [pc, #272]	; (80225f4 <XMC_USBD_DeviceGetState+0x114>)
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 80224e2:	7b01      	ldrb	r1, [r0, #12]

/**
 * Gets the USB device state.
 **/
XMC_USBD_STATE_t XMC_USBD_DeviceGetState(const XMC_USBD_t *const obj) 
{
 80224e4:	b470      	push	{r4, r5, r6}
  XMC_USBD_STATE_t state={0U};
  state.speed = XMC_USBD_SPEED_FULL;
  state.connected = xmc_device.IsConnected;
 80224e6:	f892 41fe 	ldrb.w	r4, [r2, #510]	; 0x1fe
/**
 * Gets the USB device state.
 **/
XMC_USBD_STATE_t XMC_USBD_DeviceGetState(const XMC_USBD_t *const obj) 
{
  XMC_USBD_STATE_t state={0U};
 80224ea:	2000      	movs	r0, #0
  state.speed = XMC_USBD_SPEED_FULL;
  state.connected = xmc_device.IsConnected;
 80224ec:	f004 0401 	and.w	r4, r4, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 80224f0:	2900      	cmp	r1, #0
 80224f2:	d07c      	beq.n	80225ee <XMC_USBD_DeviceGetState+0x10e>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 80224f4:	6853      	ldr	r3, [r2, #4]
 80224f6:	071e      	lsls	r6, r3, #28
 80224f8:	bf56      	itet	pl
 80224fa:	6853      	ldrpl	r3, [r2, #4]
    {
      result = 1U;
 80224fc:	2301      	movmi	r3, #1
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 80224fe:	f3c3 1300 	ubfxpl	r3, r3, #4, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 8022502:	2901      	cmp	r1, #1
 8022504:	d954      	bls.n	80225b0 <XMC_USBD_DeviceGetState+0xd0>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 8022506:	6b95      	ldr	r5, [r2, #56]	; 0x38
 8022508:	4e3a      	ldr	r6, [pc, #232]	; (80225f4 <XMC_USBD_DeviceGetState+0x114>)
 802250a:	072d      	lsls	r5, r5, #28
 802250c:	d461      	bmi.n	80225d2 <XMC_USBD_DeviceGetState+0xf2>
 802250e:	6bb5      	ldr	r5, [r6, #56]	; 0x38
    {
      result = 1U;
 8022510:	f015 0f10 	tst.w	r5, #16
 8022514:	bf18      	it	ne
 8022516:	2301      	movne	r3, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 8022518:	2902      	cmp	r1, #2
 802251a:	d049      	beq.n	80225b0 <XMC_USBD_DeviceGetState+0xd0>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 802251c:	6ed5      	ldr	r5, [r2, #108]	; 0x6c
 802251e:	4e35      	ldr	r6, [pc, #212]	; (80225f4 <XMC_USBD_DeviceGetState+0x114>)
 8022520:	072d      	lsls	r5, r5, #28
 8022522:	d462      	bmi.n	80225ea <XMC_USBD_DeviceGetState+0x10a>
 8022524:	6ef5      	ldr	r5, [r6, #108]	; 0x6c
    {
      result = 1U;
 8022526:	f015 0f10 	tst.w	r5, #16
 802252a:	bf18      	it	ne
 802252c:	2301      	movne	r3, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 802252e:	2903      	cmp	r1, #3
 8022530:	d03e      	beq.n	80225b0 <XMC_USBD_DeviceGetState+0xd0>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 8022532:	f8d2 50a0 	ldr.w	r5, [r2, #160]	; 0xa0
 8022536:	4e2f      	ldr	r6, [pc, #188]	; (80225f4 <XMC_USBD_DeviceGetState+0x114>)
 8022538:	072d      	lsls	r5, r5, #28
 802253a:	d454      	bmi.n	80225e6 <XMC_USBD_DeviceGetState+0x106>
 802253c:	f8d6 50a0 	ldr.w	r5, [r6, #160]	; 0xa0
    {
      result = 1U;
 8022540:	f015 0f10 	tst.w	r5, #16
 8022544:	bf18      	it	ne
 8022546:	2301      	movne	r3, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 8022548:	2904      	cmp	r1, #4
 802254a:	d031      	beq.n	80225b0 <XMC_USBD_DeviceGetState+0xd0>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 802254c:	f8d2 50d4 	ldr.w	r5, [r2, #212]	; 0xd4
 8022550:	4e28      	ldr	r6, [pc, #160]	; (80225f4 <XMC_USBD_DeviceGetState+0x114>)
 8022552:	072d      	lsls	r5, r5, #28
 8022554:	d445      	bmi.n	80225e2 <XMC_USBD_DeviceGetState+0x102>
 8022556:	f8d6 50d4 	ldr.w	r5, [r6, #212]	; 0xd4
    {
      result = 1U;
 802255a:	f015 0f10 	tst.w	r5, #16
 802255e:	bf18      	it	ne
 8022560:	2301      	movne	r3, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 8022562:	2905      	cmp	r1, #5
 8022564:	d024      	beq.n	80225b0 <XMC_USBD_DeviceGetState+0xd0>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 8022566:	f8d2 5108 	ldr.w	r5, [r2, #264]	; 0x108
 802256a:	4e22      	ldr	r6, [pc, #136]	; (80225f4 <XMC_USBD_DeviceGetState+0x114>)
 802256c:	072d      	lsls	r5, r5, #28
 802256e:	d436      	bmi.n	80225de <XMC_USBD_DeviceGetState+0xfe>
 8022570:	f8d6 5108 	ldr.w	r5, [r6, #264]	; 0x108
    {
      result = 1U;
 8022574:	f015 0f10 	tst.w	r5, #16
 8022578:	bf18      	it	ne
 802257a:	2301      	movne	r3, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 802257c:	2906      	cmp	r1, #6
 802257e:	d017      	beq.n	80225b0 <XMC_USBD_DeviceGetState+0xd0>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 8022580:	f8d2 513c 	ldr.w	r5, [r2, #316]	; 0x13c
 8022584:	4e1b      	ldr	r6, [pc, #108]	; (80225f4 <XMC_USBD_DeviceGetState+0x114>)
 8022586:	072d      	lsls	r5, r5, #28
 8022588:	d427      	bmi.n	80225da <XMC_USBD_DeviceGetState+0xfa>
 802258a:	f8d6 513c 	ldr.w	r5, [r6, #316]	; 0x13c
    {
      result = 1U;
 802258e:	f015 0f10 	tst.w	r5, #16
 8022592:	bf18      	it	ne
 8022594:	2301      	movne	r3, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 8022596:	2907      	cmp	r1, #7
 8022598:	d00a      	beq.n	80225b0 <XMC_USBD_DeviceGetState+0xd0>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 802259a:	f8d2 1170 	ldr.w	r1, [r2, #368]	; 0x170
 802259e:	4d15      	ldr	r5, [pc, #84]	; (80225f4 <XMC_USBD_DeviceGetState+0x114>)
 80225a0:	0709      	lsls	r1, r1, #28
 80225a2:	d418      	bmi.n	80225d6 <XMC_USBD_DeviceGetState+0xf6>
 80225a4:	f8d5 1170 	ldr.w	r1, [r5, #368]	; 0x170
    {
      result = 1U;
 80225a8:	f011 0f10 	tst.w	r1, #16
 80225ac:	bf18      	it	ne
 80225ae:	2301      	movne	r3, #1
 80225b0:	f003 0301 	and.w	r3, r3, #1
{
  XMC_USBD_STATE_t state={0U};
  state.speed = XMC_USBD_SPEED_FULL;
  state.connected = xmc_device.IsConnected;
  state.active = XMC_USBD_lDeviceActive(obj);
  state.powered = xmc_device.IsPowered;
 80225b4:	f892 21fe 	ldrb.w	r2, [r2, #510]	; 0x1fe
  return state;
 80225b8:	f3c2 0280 	ubfx	r2, r2, #2, #1
 80225bc:	f362 0000 	bfi	r0, r2, #0, #1
 80225c0:	f364 0041 	bfi	r0, r4, #1, #1
 80225c4:	f363 0082 	bfi	r0, r3, #2, #1
 80225c8:	2301      	movs	r3, #1
 80225ca:	f363 00c4 	bfi	r0, r3, #3, #2
}
 80225ce:	bc70      	pop	{r4, r5, r6}
 80225d0:	4770      	bx	lr
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
    {
      result = 1U;
 80225d2:	2301      	movs	r3, #1
 80225d4:	e7a0      	b.n	8022518 <XMC_USBD_DeviceGetState+0x38>
 80225d6:	2301      	movs	r3, #1
 80225d8:	e7ea      	b.n	80225b0 <XMC_USBD_DeviceGetState+0xd0>
 80225da:	2301      	movs	r3, #1
 80225dc:	e7db      	b.n	8022596 <XMC_USBD_DeviceGetState+0xb6>
 80225de:	2301      	movs	r3, #1
 80225e0:	e7cc      	b.n	802257c <XMC_USBD_DeviceGetState+0x9c>
 80225e2:	2301      	movs	r3, #1
 80225e4:	e7bd      	b.n	8022562 <XMC_USBD_DeviceGetState+0x82>
 80225e6:	2301      	movs	r3, #1
 80225e8:	e7ae      	b.n	8022548 <XMC_USBD_DeviceGetState+0x68>
 80225ea:	2301      	movs	r3, #1
 80225ec:	e79f      	b.n	802252e <XMC_USBD_DeviceGetState+0x4e>
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 80225ee:	4603      	mov	r3, r0
 80225f0:	e7e0      	b.n	80225b4 <XMC_USBD_DeviceGetState+0xd4>
 80225f2:	bf00      	nop
 80225f4:	2000d35c 	.word	0x2000d35c

080225f8 <XMC_USBD_DeviceSetAddress>:
 * Sets the USB device address.
 **/
XMC_USBD_STATUS_t XMC_USBD_DeviceSetAddress(const uint8_t address,const XMC_USBD_SET_ADDRESS_STAGE_t stage) 
{
  dcfg_data_t data;
  data.d32 = xmc_device.device_register->dcfg;
 80225f8:	4b04      	ldr	r3, [pc, #16]	; (802260c <XMC_USBD_DeviceSetAddress+0x14>)
 80225fa:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 80225fe:	681a      	ldr	r2, [r3, #0]
  if (stage == XMC_USBD_SET_ADDRESS_STAGE_SETUP)
 8022600:	b911      	cbnz	r1, 8022608 <XMC_USBD_DeviceSetAddress+0x10>
  {
    data.b.devaddr = address;
 8022602:	f360 120a 	bfi	r2, r0, #4, #7
    xmc_device.device_register->dcfg = data.d32;
 8022606:	601a      	str	r2, [r3, #0]
  }
	return XMC_USBD_STATUS_OK;
}
 8022608:	2000      	movs	r0, #0
 802260a:	4770      	bx	lr
 802260c:	2000d35c 	.word	0x2000d35c

08022610 <XMC_USBD_EndpointStall>:
 * Set/clear stall on the selected endpoint.
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointStall(const uint8_t ep_addr, const bool stall) 
{
  depctl_data_t data;
  XMC_USBD_EP_t *ep = &xmc_device.ep[(ep_addr & (uint8_t)XMC_USBD_EP_NUM_MASK)];
 8022610:	f000 020f 	and.w	r2, r0, #15
  if (stall)
 8022614:	b1e9      	cbz	r1, 8022652 <XMC_USBD_EndpointStall+0x42>
  {
    if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
    {
      /*set stall bit */
      data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022616:	2334      	movs	r3, #52	; 0x34
{
  depctl_data_t data;
  XMC_USBD_EP_t *ep = &xmc_device.ep[(ep_addr & (uint8_t)XMC_USBD_EP_NUM_MASK)];
  if (stall)
  {
    if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
 8022618:	f010 0f80 	tst.w	r0, #128	; 0x80
    {
      /*set stall bit */
      data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 802261c:	fb03 f302 	mul.w	r3, r3, r2
 8022620:	481d      	ldr	r0, [pc, #116]	; (8022698 <XMC_USBD_EndpointStall+0x88>)
 8022622:	5cc3      	ldrb	r3, [r0, r3]
 8022624:	f003 030f 	and.w	r3, r3, #15
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
    }
    else
    {
      /*set stall bit */
      data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 8022628:	bf0b      	itete	eq
 802262a:	eb00 0383 	addeq.w	r3, r0, r3, lsl #2
  if (stall)
  {
    if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
    {
      /*set stall bit */
      data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 802262e:	336a      	addne	r3, #106	; 0x6a
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
    }
    else
    {
      /*set stall bit */
      data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 8022630:	f8d3 11c4 	ldreq.w	r1, [r3, #452]	; 0x1c4
  if (stall)
  {
    if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
    {
      /*set stall bit */
      data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022634:	f850 1023 	ldrne.w	r1, [r0, r3, lsl #2]
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
    }
    else
    {
      /*set stall bit */
      data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 8022638:	680b      	ldr	r3, [r1, #0]
      data.b.stall = 1U;
 802263a:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
      xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
 802263e:	600b      	str	r3, [r1, #0]
    }
    ep->isStalled = 1U;
 8022640:	2334      	movs	r3, #52	; 0x34
 8022642:	fb03 0202 	mla	r2, r3, r2, r0
			xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
		}
		ep->isStalled = 0U;
	}
	return XMC_USBD_STATUS_OK;
}
 8022646:	2000      	movs	r0, #0
      /*set stall bit */
      data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
      data.b.stall = 1U;
      xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
    }
    ep->isStalled = 1U;
 8022648:	7913      	ldrb	r3, [r2, #4]
 802264a:	f043 0320 	orr.w	r3, r3, #32
 802264e:	7113      	strb	r3, [r2, #4]
			xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
		}
		ep->isStalled = 0U;
	}
	return XMC_USBD_STATUS_OK;
}
 8022650:	4770      	bx	lr

/**
 * Set/clear stall on the selected endpoint.
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointStall(const uint8_t ep_addr, const bool stall) 
{
 8022652:	b410      	push	{r4}
  else
  {
    /* just clear stall bit */
		if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
		{
			data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022654:	2334      	movs	r3, #52	; 0x34
    ep->isStalled = 1U;
  }
  else
  {
    /* just clear stall bit */
		if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
 8022656:	f010 0f80 	tst.w	r0, #128	; 0x80
		{
			data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 802265a:	fb03 f302 	mul.w	r3, r3, r2
 802265e:	480e      	ldr	r0, [pc, #56]	; (8022698 <XMC_USBD_EndpointStall+0x88>)
 8022660:	5cc3      	ldrb	r3, [r0, r3]
 8022662:	f003 030f 	and.w	r3, r3, #15
			data.b.setd0pid = 1U; /* reset pid to 0 */
			xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
		}
		else
		{
			data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 8022666:	bf0b      	itete	eq
 8022668:	eb00 0383 	addeq.w	r3, r0, r3, lsl #2
  else
  {
    /* just clear stall bit */
		if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
		{
			data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 802266c:	336a      	addne	r3, #106	; 0x6a
			data.b.setd0pid = 1U; /* reset pid to 0 */
			xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
		}
		else
		{
			data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 802266e:	f8d3 41c4 	ldreq.w	r4, [r3, #452]	; 0x1c4
  else
  {
    /* just clear stall bit */
		if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
		{
			data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022672:	f850 4023 	ldrne.w	r4, [r0, r3, lsl #2]
			data.b.setd0pid = 1U; /* reset pid to 0 */
			xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
		}
		else
		{
			data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 8022676:	6823      	ldr	r3, [r4, #0]
			data.b.stall = 0U;
 8022678:	f361 5355 	bfi	r3, r1, #21, #1
			data.b.setd0pid = 1U; /* reset pid to 0 */
 802267c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
			xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
 8022680:	6023      	str	r3, [r4, #0]
		}
		ep->isStalled = 0U;
 8022682:	2334      	movs	r3, #52	; 0x34
 8022684:	fb03 0202 	mla	r2, r3, r2, r0
	}
	return XMC_USBD_STATUS_OK;
}
 8022688:	f85d 4b04 	ldr.w	r4, [sp], #4
			data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
			data.b.stall = 0U;
			data.b.setd0pid = 1U; /* reset pid to 0 */
			xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
		}
		ep->isStalled = 0U;
 802268c:	7913      	ldrb	r3, [r2, #4]
 802268e:	f36f 1345 	bfc	r3, #5, #1
	}
	return XMC_USBD_STATUS_OK;
}
 8022692:	2000      	movs	r0, #0
			data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
			data.b.stall = 0U;
			data.b.setd0pid = 1U; /* reset pid to 0 */
			xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
		}
		ep->isStalled = 0U;
 8022694:	7113      	strb	r3, [r2, #4]
	}
	return XMC_USBD_STATUS_OK;
}
 8022696:	4770      	bx	lr
 8022698:	2000d35c 	.word	0x2000d35c

0802269c <XMC_USBD_EndpointAbort>:

/**
 * Aborts the data transfer on the selected endpoint
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointAbort(const uint8_t ep_addr) {
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_addr & (uint8_t)XMC_USBD_ENDPOINT_NUMBER_MASK];
 802269c:	f000 000f 	and.w	r0, r0, #15
  if (ep->address_u.address_st.direction)
 80226a0:	2234      	movs	r2, #52	; 0x34
 80226a2:	fb02 f200 	mul.w	r2, r2, r0
 80226a6:	4b0d      	ldr	r3, [pc, #52]	; (80226dc <XMC_USBD_EndpointAbort+0x40>)
 80226a8:	5c99      	ldrb	r1, [r3, r2]
 80226aa:	441a      	add	r2, r3
 80226ac:	f011 0f80 	tst.w	r1, #128	; 0x80
  {
    ep->inInUse = 0U;
 80226b0:	6851      	ldr	r1, [r2, #4]
  }
  if (!ep->address_u.address_st.direction)
  {
    ep->outInUse = 0U;
 80226b2:	bf0c      	ite	eq
 80226b4:	f021 0110 	biceq.w	r1, r1, #16
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointAbort(const uint8_t ep_addr) {
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_addr & (uint8_t)XMC_USBD_ENDPOINT_NUMBER_MASK];
  if (ep->address_u.address_st.direction)
  {
    ep->inInUse = 0U;
 80226b8:	f021 0108 	bicne.w	r1, r1, #8
 80226bc:	6051      	str	r1, [r2, #4]
  }
  if (!ep->address_u.address_st.direction)
  {
    ep->outInUse = 0U;
  }
  ep->isStalled = 0U;
 80226be:	2234      	movs	r2, #52	; 0x34
 80226c0:	fb02 3300 	mla	r3, r2, r0, r3
  ep->outBytesAvailable = 0U;
 80226c4:	2000      	movs	r0, #0
  }
  if (!ep->address_u.address_st.direction)
  {
    ep->outInUse = 0U;
  }
  ep->isStalled = 0U;
 80226c6:	791a      	ldrb	r2, [r3, #4]
  ep->outBytesAvailable = 0U;
  ep->outOffset = 0U;
  ep->xferLength = 0U;
  ep->xferCount = 0U;
 80226c8:	62d8      	str	r0, [r3, #44]	; 0x2c
  }
  if (!ep->address_u.address_st.direction)
  {
    ep->outInUse = 0U;
  }
  ep->isStalled = 0U;
 80226ca:	f36f 1245 	bfc	r2, #5, #1
 80226ce:	711a      	strb	r2, [r3, #4]
  ep->outBytesAvailable = 0U;
 80226d0:	6118      	str	r0, [r3, #16]
  ep->outOffset = 0U;
 80226d2:	6198      	str	r0, [r3, #24]
  ep->xferLength = 0U;
 80226d4:	6298      	str	r0, [r3, #40]	; 0x28
  ep->xferCount = 0U;
  ep->xferTotal = 0U;
 80226d6:	6318      	str	r0, [r3, #48]	; 0x30

  return XMC_USBD_STATUS_OK;
}
 80226d8:	4770      	bx	lr
 80226da:	bf00      	nop
 80226dc:	2000d35c 	.word	0x2000d35c

080226e0 <XMC_USBD_EndpointUnconfigure>:

/**
 * Unconfigure the selected endpoint.
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointUnconfigure(const uint8_t ep_addr) 
{
 80226e0:	b5f0      	push	{r4, r5, r6, r7, lr}
  depctl_data_t data;
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
 80226e2:	4b3d      	ldr	r3, [pc, #244]	; (80227d8 <XMC_USBD_EndpointUnconfigure+0xf8>)
/**
 * Unconfigure the selected endpoint.
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointUnconfigure(const uint8_t ep_addr) 
{
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_addr & (uint8_t)XMC_USBD_ENDPOINT_NUMBER_MASK];
 80226e4:	f000 000f 	and.w	r0, r0, #15
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  number_temp = (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
 80226e8:	2134      	movs	r1, #52	; 0x34
 80226ea:	fb01 f100 	mul.w	r1, r1, r0
 80226ee:	185a      	adds	r2, r3, r1
 80226f0:	f813 e001 	ldrb.w	lr, [r3, r1]
  /* if not configured return an error */
  if (!ep->isConfigured)
 80226f4:	7914      	ldrb	r4, [r2, #4]
  depctl_data_t data;
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
 80226f6:	f8d3 71a4 	ldr.w	r7, [r3, #420]	; 0x1a4
  number_temp = (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
  /* if not configured return an error */
  if (!ep->isConfigured)
 80226fa:	f014 0f04 	tst.w	r4, #4
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  number_temp = (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
 80226fe:	f00e 060f 	and.w	r6, lr, #15
  depctl_data_t data;
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
 8022702:	69fd      	ldr	r5, [r7, #28]
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_addr & (uint8_t)XMC_USBD_ENDPOINT_NUMBER_MASK];
  depctl_data_t data;
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
 8022704:	f04f 0100 	mov.w	r1, #0
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  number_temp = (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
  /* if not configured return an error */
  if (!ep->isConfigured)
 8022708:	d05a      	beq.n	80227c0 <XMC_USBD_EndpointUnconfigure+0xe0>
    data.b.usbactep = 0U;
    data.b.epdis =  1U;
    data.b.snak =  1U;
    data.b.stall =  0U;
    ep->isConfigured =  0U;
    ep->isStalled =  0U;
 802270a:	f004 04fb 	and.w	r4, r4, #251	; 0xfb
 802270e:	f36f 1445 	bfc	r4, #5, #1
 8022712:	7114      	strb	r4, [r2, #4]
    ep->outInUse =  0U;
 8022714:	6854      	ldr	r4, [r2, #4]
 8022716:	f024 0410 	bic.w	r4, r4, #16
 802271a:	6054      	str	r4, [r2, #4]
    ep->inInUse =  0U;
 802271c:	6854      	ldr	r4, [r2, #4]
     result = XMC_USBD_STATUS_ERROR;
  }
  else
  {
    /* disable the endpoint, deactivate it and only send naks */
    data.b.usbactep = 0U;
 802271e:	f361 31cf 	bfi	r1, r1, #15, #1
    data.b.epdis =  1U;
    data.b.snak =  1U;
 8022722:	f041 4190 	orr.w	r1, r1, #1207959552	; 0x48000000
    data.b.stall =  0U;
    ep->isConfigured =  0U;
    ep->isStalled =  0U;
    ep->outInUse =  0U;
    ep->inInUse =  0U;
 8022726:	f024 0408 	bic.w	r4, r4, #8
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  number_temp = (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
 802272a:	f04f 0c01 	mov.w	ip, #1
    ep->isConfigured =  0U;
    ep->isStalled =  0U;
    ep->outInUse =  0U;
    ep->inInUse =  0U;
    /* chose register based on the direction. Control Endpoint need both */
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
 802272e:	f01e 0f80 	tst.w	lr, #128	; 0x80
  {
    /* disable the endpoint, deactivate it and only send naks */
    data.b.usbactep = 0U;
    data.b.epdis =  1U;
    data.b.snak =  1U;
    data.b.stall =  0U;
 8022732:	f36f 5155 	bfc	r1, #21, #1
    ep->isConfigured =  0U;
    ep->isStalled =  0U;
    ep->outInUse =  0U;
    ep->inInUse =  0U;
 8022736:	6054      	str	r4, [r2, #4]
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  number_temp = (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
 8022738:	fa0c fc06 	lsl.w	ip, ip, r6
    ep->isConfigured =  0U;
    ep->isStalled =  0U;
    ep->outInUse =  0U;
    ep->inInUse =  0U;
    /* chose register based on the direction. Control Endpoint need both */
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
 802273c:	d02f      	beq.n	802279e <XMC_USBD_EndpointUnconfigure+0xbe>
    {
      /* disable endpoint configuration */
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
 802273e:	f106 0e6a 	add.w	lr, r6, #106	; 0x6a
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
 8022742:	ea6f 040c 	mvn.w	r4, ip
    ep->inInUse =  0U;
    /* chose register based on the direction. Control Endpoint need both */
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      /* disable endpoint configuration */
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
 8022746:	f853 e02e 	ldr.w	lr, [r3, lr, lsl #2]
 802274a:	f8ce 1000 	str.w	r1, [lr]
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
    }
    if ((ep->address_u.address_st.direction == 0U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
 802274e:	7912      	ldrb	r2, [r2, #4]
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      /* disable endpoint configuration */
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
 8022750:	fa1f fe84 	uxth.w	lr, r4
 8022754:	ea0e 0c05 	and.w	ip, lr, r5
    }
    if ((ep->address_u.address_st.direction == 0U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
 8022758:	0792      	lsls	r2, r2, #30
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      /* disable endpoint configuration */
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
 802275a:	f36c 050f 	bfi	r5, ip, #0, #16
    }
    if ((ep->address_u.address_st.direction == 0U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
 802275e:	d10d      	bne.n	802277c <XMC_USBD_EndpointUnconfigure+0x9c>
    {
      xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
      daintmsk.ep.out = (uint16_t)((uint32_t)daintmsk.ep.out & (~(uint32_t)number_temp));
      if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022760:	4a1e      	ldr	r2, [pc, #120]	; (80227dc <XMC_USBD_EndpointUnconfigure+0xfc>)
 8022762:	6812      	ldr	r2, [r2, #0]
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
    }
    if ((ep->address_u.address_st.direction == 0U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
 8022764:	eb03 0686 	add.w	r6, r3, r6, lsl #2
      daintmsk.ep.out = (uint16_t)((uint32_t)daintmsk.ep.out & (~(uint32_t)number_temp));
      if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022768:	7b52      	ldrb	r2, [r2, #13]
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
    }
    if ((ep->address_u.address_st.direction == 0U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
 802276a:	f8d6 61c4 	ldr.w	r6, [r6, #452]	; 0x1c4
      daintmsk.ep.out = (uint16_t)((uint32_t)daintmsk.ep.out & (~(uint32_t)number_temp));
 802276e:	ea0e 4e15 	and.w	lr, lr, r5, lsr #16
      if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022772:	2a01      	cmp	r2, #1
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
    }
    if ((ep->address_u.address_st.direction == 0U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
 8022774:	6031      	str	r1, [r6, #0]
      daintmsk.ep.out = (uint16_t)((uint32_t)daintmsk.ep.out & (~(uint32_t)number_temp));
 8022776:	f36e 451f 	bfi	r5, lr, #16, #16
      if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 802277a:	d028      	beq.n	80227ce <XMC_USBD_EndpointUnconfigure+0xee>
      {
        xmc_device.device_register->dtknqr4_fifoemptymsk &= ~number_temp;
      }
    }
    xmc_device.device_register->daintmsk = daintmsk.d32;
    XMC_USBD_lUnassignFifo(ep->txFifoNum); /* free fifo */
 802277c:	2234      	movs	r2, #52	; 0x34
 802277e:	fb02 3000 	mla	r0, r2, r0, r3
      if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
      {
        xmc_device.device_register->dtknqr4_fifoemptymsk &= ~number_temp;
      }
    }
    xmc_device.device_register->daintmsk = daintmsk.d32;
 8022782:	61fd      	str	r5, [r7, #28]
    XMC_USBD_lUnassignFifo(ep->txFifoNum); /* free fifo */
 8022784:	8880      	ldrh	r0, [r0, #4]
 * Mark an used tx fifo as free.
 * @param[in] fifo_nr Fifo number to free
 */
static void XMC_USBD_lUnassignFifo(const uint8_t fifo_nr) 
{
  xmc_device.txfifomsk = (uint16_t)((uint32_t)xmc_device.txfifomsk & (uint32_t)(~((uint32_t)((uint32_t)1U << fifo_nr))));
 8022786:	f8b3 11fc 	ldrh.w	r1, [r3, #508]	; 0x1fc
 802278a:	f3c0 1083 	ubfx	r0, r0, #6, #4
 802278e:	2201      	movs	r2, #1
 8022790:	4082      	lsls	r2, r0
 8022792:	ea21 0202 	bic.w	r2, r1, r2
 8022796:	f8a3 21fc 	strh.w	r2, [r3, #508]	; 0x1fc
        xmc_device.device_register->dtknqr4_fifoemptymsk &= ~number_temp;
      }
    }
    xmc_device.device_register->daintmsk = daintmsk.d32;
    XMC_USBD_lUnassignFifo(ep->txFifoNum); /* free fifo */
    result = XMC_USBD_STATUS_OK;
 802279a:	2000      	movs	r0, #0
 802279c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ep->isConfigured =  0U;
    ep->isStalled =  0U;
    ep->outInUse =  0U;
    ep->inInUse =  0U;
    /* chose register based on the direction. Control Endpoint need both */
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
 802279e:	7912      	ldrb	r2, [r2, #4]
 80227a0:	0794      	lsls	r4, r2, #30
 80227a2:	d10f      	bne.n	80227c4 <XMC_USBD_EndpointUnconfigure+0xe4>
    {
      /* disable endpoint configuration */
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
 80227a4:	f106 026a 	add.w	r2, r6, #106	; 0x6a
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
 80227a8:	ea6f 040c 	mvn.w	r4, ip
 80227ac:	fa1f fe84 	uxth.w	lr, r4
    ep->inInUse =  0U;
    /* chose register based on the direction. Control Endpoint need both */
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      /* disable endpoint configuration */
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
 80227b0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
 80227b4:	ea0e 0c05 	and.w	ip, lr, r5
 80227b8:	f36c 050f 	bfi	r5, ip, #0, #16
    ep->inInUse =  0U;
    /* chose register based on the direction. Control Endpoint need both */
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      /* disable endpoint configuration */
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
 80227bc:	6011      	str	r1, [r2, #0]
 80227be:	e7cf      	b.n	8022760 <XMC_USBD_EndpointUnconfigure+0x80>
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  number_temp = (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
  /* if not configured return an error */
  if (!ep->isConfigured)
  {
     result = XMC_USBD_STATUS_ERROR;
 80227c0:	2001      	movs	r0, #1
 80227c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80227c4:	ea6f 040c 	mvn.w	r4, ip
 80227c8:	fa1f fe84 	uxth.w	lr, r4
 80227cc:	e7c8      	b.n	8022760 <XMC_USBD_EndpointUnconfigure+0x80>
    {
      xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
      daintmsk.ep.out = (uint16_t)((uint32_t)daintmsk.ep.out & (~(uint32_t)number_temp));
      if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
      {
        xmc_device.device_register->dtknqr4_fifoemptymsk &= ~number_temp;
 80227ce:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80227d0:	4014      	ands	r4, r2
 80227d2:	637c      	str	r4, [r7, #52]	; 0x34
 80227d4:	e7d2      	b.n	802277c <XMC_USBD_EndpointUnconfigure+0x9c>
 80227d6:	bf00      	nop
 80227d8:	2000d35c 	.word	0x2000d35c
 80227dc:	2000d358 	.word	0x2000d358

080227e0 <XMC_USBD_GetFrameNumber>:
 **/
uint16_t XMC_USBD_GetFrameNumber(void) 
{
  uint16_t result;
  dsts_data_t dsts;
  dsts.d32 = xmc_device.device_register->dsts;
 80227e0:	4b03      	ldr	r3, [pc, #12]	; (80227f0 <XMC_USBD_GetFrameNumber+0x10>)
 80227e2:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 80227e6:	6898      	ldr	r0, [r3, #8]
  result = (uint16_t)dsts.b.soffn;
  return result;
}
 80227e8:	f3c0 200d 	ubfx	r0, r0, #8, #14
 80227ec:	4770      	bx	lr
 80227ee:	bf00      	nop
 80227f0:	2000d35c 	.word	0x2000d35c

080227f4 <XMC_USBD_IsEnumDone>:
 * This should not be used for the actual USB enumeration completion status. For the actual USB enumeration status,
 * the application layer should check for the completion of USB standard request Set configuration.
 **/
uint32_t XMC_USBD_IsEnumDone(void)
{
  return (uint32_t)((uint8_t)xmc_device.IsConnected && (uint8_t)xmc_device.IsPowered);
 80227f4:	4b05      	ldr	r3, [pc, #20]	; (802280c <XMC_USBD_IsEnumDone+0x18>)
 80227f6:	f893 01fe 	ldrb.w	r0, [r3, #510]	; 0x1fe
 80227fa:	f000 0005 	and.w	r0, r0, #5
}
 80227fe:	f1a0 0005 	sub.w	r0, r0, #5
 8022802:	fab0 f080 	clz	r0, r0
 8022806:	0940      	lsrs	r0, r0, #5
 8022808:	4770      	bx	lr
 802280a:	bf00      	nop
 802280c:	2000d35c 	.word	0x2000d35c

08022810 <XMC_USBD_Uninitialize>:
 **/
XMC_USBD_STATUS_t XMC_USBD_Uninitialize() 
{
  /* Disconnect the device */
  dctl_data_t dctl;
	dctl.d32 = xmc_device.device_register->dctl;
 8022810:	4807      	ldr	r0, [pc, #28]	; (8022830 <XMC_USBD_Uninitialize+0x20>)
 8022812:	f8d0 21a4 	ldr.w	r2, [r0, #420]	; 0x1a4

/**
 * Uninitializes the USB device
 **/
XMC_USBD_STATUS_t XMC_USBD_Uninitialize() 
{
 8022816:	b508      	push	{r3, lr}
  /* Disconnect the device */
  dctl_data_t dctl;
	dctl.d32 = xmc_device.device_register->dctl;
 8022818:	6853      	ldr	r3, [r2, #4]
  dctl.b.sftdiscon = 1U;
 802281a:	f043 0302 	orr.w	r3, r3, #2
  xmc_device.device_register->dctl = dctl.d32;
 802281e:	6053      	str	r3, [r2, #4]
  /* clean up */
  memset((void*)&xmc_device,0U,sizeof(xmc_device));
 8022820:	2100      	movs	r1, #0
 8022822:	f44f 7202 	mov.w	r2, #520	; 0x208
 8022826:	f00c f9ca 	bl	802ebbe <memset>
  return XMC_USBD_STATUS_OK;
}
 802282a:	2000      	movs	r0, #0
 802282c:	bd08      	pop	{r3, pc}
 802282e:	bf00      	nop
 8022830:	2000d35c 	.word	0x2000d35c

08022834 <XMC_USBD_EndpointConfigure>:
 * Configures the given endpoint
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointConfigure(const uint8_t ep_addr,
		                                     const XMC_USBD_ENDPOINT_TYPE_t ep_type,
		                                     const uint16_t ep_max_packet_size) 
{
 8022834:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  daint_data_t daintmsk;
  XMC_USBD_EP_t *ep;
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
 8022838:	4d9a      	ldr	r5, [pc, #616]	; (8022aa4 <XMC_USBD_EndpointConfigure+0x270>)
  else
  {
    ep->maxTransferSize = (uint32_t)XMC_USBD_MAX_TRANSFER_SIZE_EP0;
  }
  /* transfer buffer */
  ep->inBuffer = XMC_USBD_EP_IN_BUFFER[ep->address_u.address_st.number];
 802283a:	f8df 826c 	ldr.w	r8, [pc, #620]	; 8022aa8 <XMC_USBD_EndpointConfigure+0x274>
		                                     const XMC_USBD_ENDPOINT_TYPE_t ep_type,
		                                     const uint16_t ep_max_packet_size) 
{
  daint_data_t daintmsk;
  XMC_USBD_EP_t *ep;
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
 802283e:	f8d5 31a4 	ldr.w	r3, [r5, #420]	; 0x1a4
  }
  /* transfer buffer */
  ep->inBuffer = XMC_USBD_EP_IN_BUFFER[ep->address_u.address_st.number];
  ep->outBuffer = XMC_USBD_EP_OUT_BUFFER[ep->address_u.address_st.number];
  /* buffer size*/
  ep->inBufferSize = XMC_USBD_EP_IN_BUFFERSIZE[ep->address_u.address_st.number];
 8022842:	f8df a268 	ldr.w	sl, [pc, #616]	; 8022aac <XMC_USBD_EndpointConfigure+0x278>
		                                     const XMC_USBD_ENDPOINT_TYPE_t ep_type,
		                                     const uint16_t ep_max_packet_size) 
{
  daint_data_t daintmsk;
  XMC_USBD_EP_t *ep;
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
 8022846:	f8d3 e01c 	ldr.w	lr, [r3, #28]
  /* transfer buffer */
  ep->inBuffer = XMC_USBD_EP_IN_BUFFER[ep->address_u.address_st.number];
  ep->outBuffer = XMC_USBD_EP_OUT_BUFFER[ep->address_u.address_st.number];
  /* buffer size*/
  ep->inBufferSize = XMC_USBD_EP_IN_BUFFERSIZE[ep->address_u.address_st.number];
  ep->outBufferSize = XMC_USBD_EP_OUT_BUFFERSIZE[ep->address_u.address_st.number];
 802284a:	f8df 9264 	ldr.w	r9, [pc, #612]	; 8022ab0 <XMC_USBD_EndpointConfigure+0x27c>
		                                     const uint16_t ep_max_packet_size) 
{
  daint_data_t daintmsk;
  XMC_USBD_EP_t *ep;
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  ep =&xmc_device.ep[ep_addr & (uint32_t)XMC_USBD_ENDPOINT_NUMBER_MASK];
 802284e:	f000 0c0f 	and.w	ip, r0, #15
  memset((void*)ep,0x0U,sizeof(XMC_USBD_EP_t)); /* clear endpoint structure */
 8022852:	2734      	movs	r7, #52	; 0x34
 8022854:	fb07 f70c 	mul.w	r7, r7, ip
 8022858:	19ee      	adds	r6, r5, r7
 802285a:	f106 0308 	add.w	r3, r6, #8
 802285e:	2400      	movs	r4, #0
 8022860:	51ec      	str	r4, [r5, r7]
 8022862:	6074      	str	r4, [r6, #4]
 8022864:	f843 4b04 	str.w	r4, [r3], #4
 8022868:	f843 4b04 	str.w	r4, [r3], #4
 802286c:	f843 4b04 	str.w	r4, [r3], #4
 8022870:	f843 4b04 	str.w	r4, [r3], #4
 8022874:	f843 4b04 	str.w	r4, [r3], #4
 8022878:	f843 4b04 	str.w	r4, [r3], #4
 802287c:	f843 4b04 	str.w	r4, [r3], #4
 8022880:	f843 4b04 	str.w	r4, [r3], #4
 8022884:	f843 4b04 	str.w	r4, [r3], #4
 8022888:	f843 4b04 	str.w	r4, [r3], #4
 802288c:	601c      	str	r4, [r3, #0]
  /* do ep configuration */
  ep->address_u.address = ep_addr;
  ep->isConfigured = 1U;
 802288e:	7933      	ldrb	r3, [r6, #4]
  XMC_USBD_EP_t *ep;
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  ep =&xmc_device.ep[ep_addr & (uint32_t)XMC_USBD_ENDPOINT_NUMBER_MASK];
  memset((void*)ep,0x0U,sizeof(XMC_USBD_EP_t)); /* clear endpoint structure */
  /* do ep configuration */
  ep->address_u.address = ep_addr;
 8022890:	55e8      	strb	r0, [r5, r7]
  ep->isConfigured = 1U;
 8022892:	f043 0304 	orr.w	r3, r3, #4
 8022896:	7133      	strb	r3, [r6, #4]
  ep->maxPacketSize = (uint8_t)ep_max_packet_size;
 8022898:	6874      	ldr	r4, [r6, #4]
 802289a:	4633      	mov	r3, r6
 802289c:	f362 24d1 	bfi	r4, r2, #11, #7
 80228a0:	f843 4f04 	str.w	r4, [r3, #4]!
  {
    ep->maxTransferSize = (uint32_t)XMC_USBD_MAX_TRANSFER_SIZE;
  }
  else
  {
    ep->maxTransferSize = (uint32_t)XMC_USBD_MAX_TRANSFER_SIZE_EP0;
 80228a4:	2800      	cmp	r0, #0
 80228a6:	685c      	ldr	r4, [r3, #4]
 80228a8:	f64f 70c0 	movw	r0, #65472	; 0xffc0
 80228ac:	bf08      	it	eq
 80228ae:	2040      	moveq	r0, #64	; 0x40
 80228b0:	f360 0412 	bfi	r4, r0, #0, #19
 80228b4:	605c      	str	r4, [r3, #4]
  }
  /* transfer buffer */
  ep->inBuffer = XMC_USBD_EP_IN_BUFFER[ep->address_u.address_st.number];
 80228b6:	5deb      	ldrb	r3, [r5, r7]
 80228b8:	f003 030f 	and.w	r3, r3, #15
 80228bc:	0218      	lsls	r0, r3, #8
  ep->outBuffer = XMC_USBD_EP_OUT_BUFFER[ep->address_u.address_st.number];
 80228be:	f508 6be0 	add.w	fp, r8, #1792	; 0x700
  else
  {
    ep->maxTransferSize = (uint32_t)XMC_USBD_MAX_TRANSFER_SIZE_EP0;
  }
  /* transfer buffer */
  ep->inBuffer = XMC_USBD_EP_IN_BUFFER[ep->address_u.address_st.number];
 80228c2:	eb08 0400 	add.w	r4, r8, r0
  ep->outBuffer = XMC_USBD_EP_OUT_BUFFER[ep->address_u.address_st.number];
 80228c6:	eb00 080b 	add.w	r8, r0, fp
  /* buffer size*/
  ep->inBufferSize = XMC_USBD_EP_IN_BUFFERSIZE[ep->address_u.address_st.number];
 80228ca:	f85a 0023 	ldr.w	r0, [sl, r3, lsl #2]
 80228ce:	6230      	str	r0, [r6, #32]
  ep->outBufferSize = XMC_USBD_EP_OUT_BUFFERSIZE[ep->address_u.address_st.number];
 80228d0:	f859 0023 	ldr.w	r0, [r9, r3, lsl #2]
 80228d4:	6170      	str	r0, [r6, #20]
  else
  {
    ep->maxTransferSize = (uint32_t)XMC_USBD_MAX_TRANSFER_SIZE_EP0;
  }
  /* transfer buffer */
  ep->inBuffer = XMC_USBD_EP_IN_BUFFER[ep->address_u.address_st.number];
 80228d6:	61f4      	str	r4, [r6, #28]
  ep->outBuffer = XMC_USBD_EP_OUT_BUFFER[ep->address_u.address_st.number];
 80228d8:	f8c6 800c 	str.w	r8, [r6, #12]
  /* buffer size*/
  ep->inBufferSize = XMC_USBD_EP_IN_BUFFERSIZE[ep->address_u.address_st.number];
  ep->outBufferSize = XMC_USBD_EP_OUT_BUFFERSIZE[ep->address_u.address_st.number];
  /* is in */
  if ((ep->address_u.address_st.direction == 1U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
 80228dc:	5de8      	ldrb	r0, [r5, r7]
 80228de:	0600      	lsls	r0, r0, #24
 80228e0:	d41f      	bmi.n	8022922 <XMC_USBD_EndpointConfigure+0xee>
 80228e2:	2900      	cmp	r1, #0
 80228e4:	d07f      	beq.n	80229e6 <XMC_USBD_EndpointConfigure+0x1b2>
  }
  if ((ep->address_u.address_st.direction == 0U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
  {
    /* is out */
		depctl_data_t data;
		data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 80228e6:	eb05 0483 	add.w	r4, r5, r3, lsl #2
 80228ea:	2001      	movs	r0, #1
 80228ec:	f8d4 61c4 	ldr.w	r6, [r4, #452]	; 0x1c4
 80228f0:	6834      	ldr	r4, [r6, #0]
 80228f2:	4098      	lsls	r0, r3
		/*enable endpoint */
		data.b.usbactep = 1U;
 80228f4:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
		/* set ep type */
		data.b.eptype = (uint8_t)ep_type;
 80228f8:	f361 4493 	bfi	r4, r1, #18, #2
 80228fc:	b280      	uxth	r0, r0
					break;
			}
		}
		else
		{
			data.b.mps = ep_max_packet_size;
 80228fe:	f362 040a 	bfi	r4, r2, #0, #11
		}
		/* set first data0 pid */
		data.b.setd0pid = 1U;
 8022902:	f044 5480 	orr.w	r4, r4, #268435456	; 0x10000000
		/* clear stall */
		data.b.stall =(uint8_t) 0U;
 8022906:	f36f 5455 	bfc	r4, #21, #1
		xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32; /* configure endpoint */
		daintmsk.ep.out |=(uint16_t) ((uint16_t)1U << (uint8_t)ep->address_u.address_st.number); /* enable interrupts */
 802290a:	ea40 401e 	orr.w	r0, r0, lr, lsr #16
		}
		/* set first data0 pid */
		data.b.setd0pid = 1U;
		/* clear stall */
		data.b.stall =(uint8_t) 0U;
		xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32; /* configure endpoint */
 802290e:	6034      	str	r4, [r6, #0]
		daintmsk.ep.out |=(uint16_t) ((uint16_t)1U << (uint8_t)ep->address_u.address_st.number); /* enable interrupts */
 8022910:	f360 4e1f 	bfi	lr, r0, #16, #16
  }
  xmc_device.device_register->daintmsk = daintmsk.d32;
 8022914:	f8d5 31a4 	ldr.w	r3, [r5, #420]	; 0x1a4
  return XMC_USBD_STATUS_OK;
}
 8022918:	2000      	movs	r0, #0
		/* clear stall */
		data.b.stall =(uint8_t) 0U;
		xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32; /* configure endpoint */
		daintmsk.ep.out |=(uint16_t) ((uint16_t)1U << (uint8_t)ep->address_u.address_st.number); /* enable interrupts */
  }
  xmc_device.device_register->daintmsk = daintmsk.d32;
 802291a:	f8c3 e01c 	str.w	lr, [r3, #28]
  return XMC_USBD_STATUS_OK;
}
 802291e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  ep->outBufferSize = XMC_USBD_EP_OUT_BUFFERSIZE[ep->address_u.address_st.number];
  /* is in */
  if ((ep->address_u.address_st.direction == 1U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
  {
    depctl_data_t data;
    data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022922:	f103 006a 	add.w	r0, r3, #106	; 0x6a
 8022926:	f855 6020 	ldr.w	r6, [r5, r0, lsl #2]
 802292a:	6834      	ldr	r4, [r6, #0]
		/*enable endpoint */
		data.b.usbactep = 1U;
 802292c:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
		/* set ep type */
		data.b.eptype = (uint8_t)ep_type;
 8022930:	f361 4493 	bfi	r4, r1, #18, #2
		/* set mps */
    if (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL)
 8022934:	2900      	cmp	r1, #0
 8022936:	d05f      	beq.n	80229f8 <XMC_USBD_EndpointConfigure+0x1c4>
				break;
			}
		}
		else
		{
			data.b.mps = ep_max_packet_size;
 8022938:	f362 040a 	bfi	r4, r2, #0, #11
 802293c:	f8b5 01fc 	ldrh.w	r0, [r5, #508]	; 0x1fc
		}
		/* set first data0 pid */
		data.b.setd0pid = 1U;
 8022940:	f044 5480 	orr.w	r4, r4, #268435456	; 0x10000000
static uint8_t XMC_USBD_lAssignTXFifo(void) 
{
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
 8022944:	f010 0701 	ands.w	r7, r0, #1
			data.b.mps = ep_max_packet_size;
		}
		/* set first data0 pid */
		data.b.setd0pid = 1U;
		/* clear stall */
		data.b.stall = 0U;
 8022948:	f36f 5455 	bfc	r4, #21, #1
static uint8_t XMC_USBD_lAssignTXFifo(void) 
{
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
 802294c:	f000 808e 	beq.w	8022a6c <XMC_USBD_EndpointConfigure+0x238>
 8022950:	0787      	lsls	r7, r0, #30
 8022952:	f140 808e 	bpl.w	8022a72 <XMC_USBD_EndpointConfigure+0x23e>
 8022956:	0747      	lsls	r7, r0, #29
 8022958:	f140 808f 	bpl.w	8022a7a <XMC_USBD_EndpointConfigure+0x246>
 802295c:	0707      	lsls	r7, r0, #28
 802295e:	f140 8090 	bpl.w	8022a82 <XMC_USBD_EndpointConfigure+0x24e>
 8022962:	06c7      	lsls	r7, r0, #27
 8022964:	f140 8091 	bpl.w	8022a8a <XMC_USBD_EndpointConfigure+0x256>
 8022968:	0687      	lsls	r7, r0, #26
 802296a:	f140 8092 	bpl.w	8022a92 <XMC_USBD_EndpointConfigure+0x25e>
 802296e:	0647      	lsls	r7, r0, #25
 8022970:	f140 8093 	bpl.w	8022a9a <XMC_USBD_EndpointConfigure+0x266>
  {
    mask = (uint16_t)(mask << 1U);
    i++;
  }
  if ((xmc_device.txfifomsk & mask) == 0U)
 8022974:	0607      	lsls	r7, r0, #24
 8022976:	d449      	bmi.n	8022a0c <XMC_USBD_EndpointConfigure+0x1d8>
 8022978:	2707      	movs	r7, #7
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
 802297a:	f04f 0880 	mov.w	r8, #128	; 0x80
    i++;
  }
  if ((xmc_device.txfifomsk & mask) == 0U)
  {
    xmc_device.txfifomsk |= mask;
 802297e:	ea48 0000 	orr.w	r0, r8, r0
 8022982:	f8a5 01fc 	strh.w	r0, [r5, #508]	; 0x1fc
		/* set first data0 pid */
		data.b.setd0pid = 1U;
		/* clear stall */
		data.b.stall = 0U;
		/* set tx fifo */
		ep->txFifoNum = XMC_USBD_lAssignTXFifo(); /* get tx fifo */
 8022986:	2034      	movs	r0, #52	; 0x34
 8022988:	fb00 fc0c 	mul.w	ip, r0, ip
 802298c:	eb05 090c 	add.w	r9, r5, ip
		data.b.txfnum = ep->txFifoNum;
 8022990:	f367 5499 	bfi	r4, r7, #22, #4
		/* set first data0 pid */
		data.b.setd0pid = 1U;
		/* clear stall */
		data.b.stall = 0U;
		/* set tx fifo */
		ep->txFifoNum = XMC_USBD_lAssignTXFifo(); /* get tx fifo */
 8022994:	f8b9 a004 	ldrh.w	sl, [r9, #4]
 8022998:	f8df 8108 	ldr.w	r8, [pc, #264]	; 8022aa4 <XMC_USBD_EndpointConfigure+0x270>
 802299c:	f367 1a89 	bfi	sl, r7, #6, #4
 80229a0:	f8a9 a004 	strh.w	sl, [r9, #4]
		data.b.txfnum = ep->txFifoNum;
		xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32; /* configure endpoint */
		daintmsk.ep.in |= (uint16_t)((uint16_t)1U << (uint8_t)ep->address_u.address_st.number); /* enable interrupts for endpoint */
 80229a4:	2001      	movs	r0, #1
		/* clear stall */
		data.b.stall = 0U;
		/* set tx fifo */
		ep->txFifoNum = XMC_USBD_lAssignTXFifo(); /* get tx fifo */
		data.b.txfnum = ep->txFifoNum;
		xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32; /* configure endpoint */
 80229a6:	6034      	str	r4, [r6, #0]
		daintmsk.ep.in |= (uint16_t)((uint16_t)1U << (uint8_t)ep->address_u.address_st.number); /* enable interrupts for endpoint */
 80229a8:	4098      	lsls	r0, r3
  }
  if ((ep->address_u.address_st.direction == 0U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
 80229aa:	f815 400c 	ldrb.w	r4, [r5, ip]
		data.b.stall = 0U;
		/* set tx fifo */
		ep->txFifoNum = XMC_USBD_lAssignTXFifo(); /* get tx fifo */
		data.b.txfnum = ep->txFifoNum;
		xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32; /* configure endpoint */
		daintmsk.ep.in |= (uint16_t)((uint16_t)1U << (uint8_t)ep->address_u.address_st.number); /* enable interrupts for endpoint */
 80229ae:	b280      	uxth	r0, r0
 80229b0:	ea40 060e 	orr.w	r6, r0, lr
  }
  if ((ep->address_u.address_st.direction == 0U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
 80229b4:	0624      	lsls	r4, r4, #24
		data.b.stall = 0U;
		/* set tx fifo */
		ep->txFifoNum = XMC_USBD_lAssignTXFifo(); /* get tx fifo */
		data.b.txfnum = ep->txFifoNum;
		xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32; /* configure endpoint */
		daintmsk.ep.in |= (uint16_t)((uint16_t)1U << (uint8_t)ep->address_u.address_st.number); /* enable interrupts for endpoint */
 80229b6:	f366 0e0f 	bfi	lr, r6, #0, #16
  }
  if ((ep->address_u.address_st.direction == 0U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
 80229ba:	d529      	bpl.n	8022a10 <XMC_USBD_EndpointConfigure+0x1dc>
 80229bc:	2900      	cmp	r1, #0
 80229be:	d1a9      	bne.n	8022914 <XMC_USBD_EndpointConfigure+0xe0>
  {
    /* is out */
		depctl_data_t data;
		data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 80229c0:	eb08 0383 	add.w	r3, r8, r3, lsl #2
 80229c4:	f8d3 61c4 	ldr.w	r6, [r3, #452]	; 0x1c4
 80229c8:	6834      	ldr	r4, [r6, #0]
		/*enable endpoint */
		data.b.usbactep = 1U;
 80229ca:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
		/* set ep type */
		data.b.eptype = (uint8_t)ep_type;
 80229ce:	f361 4493 	bfi	r4, r1, #18, #2
    /* set mps */
    if (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL)
		{
			switch(ep_max_packet_size)
 80229d2:	2a10      	cmp	r2, #16
 80229d4:	d03c      	beq.n	8022a50 <XMC_USBD_EndpointConfigure+0x21c>
 80229d6:	d934      	bls.n	8022a42 <XMC_USBD_EndpointConfigure+0x20e>
 80229d8:	2a20      	cmp	r2, #32
 80229da:	d02e      	beq.n	8022a3a <XMC_USBD_EndpointConfigure+0x206>
 80229dc:	2a40      	cmp	r2, #64	; 0x40
 80229de:	d190      	bne.n	8022902 <XMC_USBD_EndpointConfigure+0xce>
			{
				case (64U):
					data.b.mps = 0x0U;
 80229e0:	f36f 040a 	bfc	r4, #0, #11
					break;
 80229e4:	e78d      	b.n	8022902 <XMC_USBD_EndpointConfigure+0xce>
  ep->outBufferSize = XMC_USBD_EP_OUT_BUFFERSIZE[ep->address_u.address_st.number];
  /* is in */
  if ((ep->address_u.address_st.direction == 1U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
  {
    depctl_data_t data;
    data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 80229e6:	f103 006a 	add.w	r0, r3, #106	; 0x6a
 80229ea:	f855 6020 	ldr.w	r6, [r5, r0, lsl #2]
 80229ee:	6834      	ldr	r4, [r6, #0]
		/*enable endpoint */
		data.b.usbactep = 1U;
 80229f0:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
		/* set ep type */
		data.b.eptype = (uint8_t)ep_type;
 80229f4:	f361 4493 	bfi	r4, r1, #18, #2
		/* set mps */
    if (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL)
    {
			switch(ep_max_packet_size)
 80229f8:	2a10      	cmp	r2, #16
 80229fa:	d031      	beq.n	8022a60 <XMC_USBD_EndpointConfigure+0x22c>
 80229fc:	d915      	bls.n	8022a2a <XMC_USBD_EndpointConfigure+0x1f6>
 80229fe:	2a20      	cmp	r2, #32
 8022a00:	d02a      	beq.n	8022a58 <XMC_USBD_EndpointConfigure+0x224>
 8022a02:	2a40      	cmp	r2, #64	; 0x40
 8022a04:	d19a      	bne.n	802293c <XMC_USBD_EndpointConfigure+0x108>
			{
				case (64U):
				data.b.mps = 0x0U;
 8022a06:	f36f 040a 	bfc	r4, #0, #11
				break;
 8022a0a:	e797      	b.n	802293c <XMC_USBD_EndpointConfigure+0x108>
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
    i++;
  }
  if ((xmc_device.txfifomsk & mask) == 0U)
 8022a0c:	2700      	movs	r7, #0
 8022a0e:	e7ba      	b.n	8022986 <XMC_USBD_EndpointConfigure+0x152>
  }
  if ((ep->address_u.address_st.direction == 0U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
  {
    /* is out */
		depctl_data_t data;
		data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 8022a10:	eb08 0383 	add.w	r3, r8, r3, lsl #2
 8022a14:	f8d3 61c4 	ldr.w	r6, [r3, #452]	; 0x1c4
 8022a18:	6834      	ldr	r4, [r6, #0]
		/*enable endpoint */
		data.b.usbactep = 1U;
 8022a1a:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
		/* set ep type */
		data.b.eptype = (uint8_t)ep_type;
 8022a1e:	f361 4493 	bfi	r4, r1, #18, #2
    /* set mps */
    if (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL)
 8022a22:	2900      	cmp	r1, #0
 8022a24:	f47f af6b 	bne.w	80228fe <XMC_USBD_EndpointConfigure+0xca>
 8022a28:	e7d3      	b.n	80229d2 <XMC_USBD_EndpointConfigure+0x19e>
		/* set ep type */
		data.b.eptype = (uint8_t)ep_type;
		/* set mps */
    if (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL)
    {
			switch(ep_max_packet_size)
 8022a2a:	2a08      	cmp	r2, #8
 8022a2c:	d186      	bne.n	802293c <XMC_USBD_EndpointConfigure+0x108>
				break;
				case (16U):
				data.b.mps = 0x2U;
				break;
				case (8U):
				data.b.mps = 0x3U;
 8022a2e:	2703      	movs	r7, #3
 8022a30:	f855 6020 	ldr.w	r6, [r5, r0, lsl #2]
 8022a34:	f367 040a 	bfi	r4, r7, #0, #11
				break;
 8022a38:	e780      	b.n	802293c <XMC_USBD_EndpointConfigure+0x108>
			{
				case (64U):
					data.b.mps = 0x0U;
					break;
				case (32U):
					data.b.mps = 0x1U;
 8022a3a:	2301      	movs	r3, #1
 8022a3c:	f363 040a 	bfi	r4, r3, #0, #11
					break;
 8022a40:	e75f      	b.n	8022902 <XMC_USBD_EndpointConfigure+0xce>
		/* set ep type */
		data.b.eptype = (uint8_t)ep_type;
    /* set mps */
    if (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL)
		{
			switch(ep_max_packet_size)
 8022a42:	2a08      	cmp	r2, #8
 8022a44:	f47f af5d 	bne.w	8022902 <XMC_USBD_EndpointConfigure+0xce>
					break;
				case (16U):
					data.b.mps = 0x2U;
					break;
				case (8U):
					data.b.mps = 0x3U;
 8022a48:	2303      	movs	r3, #3
 8022a4a:	f363 040a 	bfi	r4, r3, #0, #11
					break;
 8022a4e:	e758      	b.n	8022902 <XMC_USBD_EndpointConfigure+0xce>
					break;
				case (32U):
					data.b.mps = 0x1U;
					break;
				case (16U):
					data.b.mps = 0x2U;
 8022a50:	2302      	movs	r3, #2
 8022a52:	f363 040a 	bfi	r4, r3, #0, #11
					break;
 8022a56:	e754      	b.n	8022902 <XMC_USBD_EndpointConfigure+0xce>
			{
				case (64U):
				data.b.mps = 0x0U;
				break;
				case (32U):
				data.b.mps = 0x1U;
 8022a58:	2001      	movs	r0, #1
 8022a5a:	f360 040a 	bfi	r4, r0, #0, #11
				break;
 8022a5e:	e76d      	b.n	802293c <XMC_USBD_EndpointConfigure+0x108>
				case (16U):
				data.b.mps = 0x2U;
 8022a60:	2702      	movs	r7, #2
 8022a62:	f855 6020 	ldr.w	r6, [r5, r0, lsl #2]
 8022a66:	f367 040a 	bfi	r4, r7, #0, #11
				break;
 8022a6a:	e767      	b.n	802293c <XMC_USBD_EndpointConfigure+0x108>
 *
 * @return Fifo number for a free fifo
 */
static uint8_t XMC_USBD_lAssignTXFifo(void) 
{
  uint16_t mask = 1U;
 8022a6c:	f04f 0801 	mov.w	r8, #1
 8022a70:	e785      	b.n	802297e <XMC_USBD_EndpointConfigure+0x14a>
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
    i++;
 8022a72:	2701      	movs	r7, #1
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
 8022a74:	f04f 0802 	mov.w	r8, #2
 8022a78:	e781      	b.n	802297e <XMC_USBD_EndpointConfigure+0x14a>
    i++;
 8022a7a:	2702      	movs	r7, #2
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
 8022a7c:	f04f 0804 	mov.w	r8, #4
 8022a80:	e77d      	b.n	802297e <XMC_USBD_EndpointConfigure+0x14a>
    i++;
 8022a82:	2703      	movs	r7, #3
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
 8022a84:	f04f 0808 	mov.w	r8, #8
 8022a88:	e779      	b.n	802297e <XMC_USBD_EndpointConfigure+0x14a>
    i++;
 8022a8a:	2704      	movs	r7, #4
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
 8022a8c:	f04f 0810 	mov.w	r8, #16
 8022a90:	e775      	b.n	802297e <XMC_USBD_EndpointConfigure+0x14a>
    i++;
 8022a92:	2705      	movs	r7, #5
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
 8022a94:	f04f 0820 	mov.w	r8, #32
 8022a98:	e771      	b.n	802297e <XMC_USBD_EndpointConfigure+0x14a>
    i++;
 8022a9a:	2706      	movs	r7, #6
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
 8022a9c:	f04f 0840 	mov.w	r8, #64	; 0x40
 8022aa0:	e76d      	b.n	802297e <XMC_USBD_EndpointConfigure+0x14a>
 8022aa2:	bf00      	nop
 8022aa4:	2000d35c 	.word	0x2000d35c
 8022aa8:	2000db2c 	.word	0x2000db2c
 8022aac:	1ffe97e4 	.word	0x1ffe97e4
 8022ab0:	1ffe97c8 	.word	0x1ffe97c8

08022ab4 <XMC_USBD_EndpointRead>:

/**
 * Reads the number of bytes from the USB OUT endpoint
 **/
int32_t XMC_USBD_EndpointRead(const uint8_t ep_num,uint8_t * buffer,uint32_t length) 
{
 8022ab4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_num];
  if (length > ep->outBytesAvailable)
 8022ab6:	4f0e      	ldr	r7, [pc, #56]	; (8022af0 <XMC_USBD_EndpointRead+0x3c>)
 8022ab8:	2434      	movs	r4, #52	; 0x34
 8022aba:	fb04 7400 	mla	r4, r4, r0, r7

/**
 * Reads the number of bytes from the USB OUT endpoint
 **/
int32_t XMC_USBD_EndpointRead(const uint8_t ep_num,uint8_t * buffer,uint32_t length) 
{
 8022abe:	4606      	mov	r6, r0
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_num];
  if (length > ep->outBytesAvailable)
 8022ac0:	6925      	ldr	r5, [r4, #16]
  {
    length = ep->outBytesAvailable;
  }
  memcpy(buffer,&ep->outBuffer[ep->outOffset],length);
 8022ac2:	69a3      	ldr	r3, [r4, #24]
 8022ac4:	4295      	cmp	r5, r2
 8022ac6:	4608      	mov	r0, r1
 8022ac8:	68e1      	ldr	r1, [r4, #12]
 8022aca:	bf28      	it	cs
 8022acc:	4615      	movcs	r5, r2
 8022ace:	4419      	add	r1, r3
 8022ad0:	462a      	mov	r2, r5
 8022ad2:	f00c f869 	bl	802eba8 <memcpy>
  ep->outBytesAvailable -= length;
 8022ad6:	6923      	ldr	r3, [r4, #16]
 8022ad8:	1b5b      	subs	r3, r3, r5
 8022ada:	6123      	str	r3, [r4, #16]
  if (ep->outBytesAvailable)
 8022adc:	b10b      	cbz	r3, 8022ae2 <XMC_USBD_EndpointRead+0x2e>
  {
    ep->outOffset += length;
 8022ade:	69a3      	ldr	r3, [r4, #24]
 8022ae0:	442b      	add	r3, r5
 8022ae2:	2234      	movs	r2, #52	; 0x34
 8022ae4:	fb02 7606 	mla	r6, r2, r6, r7
  else
  {
    ep->outOffset = 0U;
  }
  return (int32_t)length;
}
 8022ae8:	4628      	mov	r0, r5
 8022aea:	61b3      	str	r3, [r6, #24]
 8022aec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8022aee:	bf00      	nop
 8022af0:	2000d35c 	.word	0x2000d35c

08022af4 <XMC_USBD_Init>:

/**
 * Initializes the USB device
 **/
XMC_USBD_STATUS_t XMC_USBD_Init(XMC_USBD_t *obj)
{
 8022af4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8022af8:	4607      	mov	r7, r0
 8022afa:	b083      	sub	sp, #12
 * Enables the USB0 module
 **/
void XMC_USBD_Enable(void) 
{
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USB0);
 8022afc:	4869      	ldr	r0, [pc, #420]	; (8022ca4 <XMC_USBD_Init+0x1b0>)
	  XMC_USBD_EP_OUT_BUFFERSIZE[i] = XMC_USBD_EP0_BUFFER_SIZE;
	  XMC_USBD_EP_IN_BUFFERSIZE[i] 	= XMC_USBD_EP0_BUFFER_SIZE;
  }

  /* clear device status */
  memset((void*)&xmc_device,0x0U,sizeof(XMC_USBD_DEVICE_t));
 8022afe:	4c6a      	ldr	r4, [pc, #424]	; (8022ca8 <XMC_USBD_Init+0x1b4>)
  usbd_init = obj;

  /* Filling out buffer size */
  for(i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
	  XMC_USBD_EP_OUT_BUFFERSIZE[i] = XMC_USBD_EP0_BUFFER_SIZE;
 8022b00:	4e6a      	ldr	r6, [pc, #424]	; (8022cac <XMC_USBD_Init+0x1b8>)
	  XMC_USBD_EP_IN_BUFFERSIZE[i] 	= XMC_USBD_EP0_BUFFER_SIZE;
 8022b02:	4d6b      	ldr	r5, [pc, #428]	; (8022cb0 <XMC_USBD_Init+0x1bc>)
 * Enables the USB0 module
 **/
void XMC_USBD_Enable(void) 
{
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USB0);
 8022b04:	f7fe fe6c 	bl	80217e0 <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif
  /* Reset and power up */
  XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_USB0);
 8022b08:	4866      	ldr	r0, [pc, #408]	; (8022ca4 <XMC_USBD_Init+0x1b0>)
 8022b0a:	f7fe fdf9 	bl	8021700 <XMC_SCU_RESET_DeassertPeripheralReset>
  XMC_SCU_POWER_EnableUsb();
 8022b0e:	f7fe fea5 	bl	802185c <XMC_SCU_POWER_EnableUsb>
  XMC_ASSERT("XMC_USBD_Init: obj.usbd_max_num_eps not of type XMC_USBD_MAX_NUM_EPS_t",
 		      XMC_USBD_CHECK_INPUT_MAX_NUM_EPS(obj->usbd_max_num_eps))
  
  XMC_USBD_Enable();
  
  usbd_init = obj;
 8022b12:	4b68      	ldr	r3, [pc, #416]	; (8022cb4 <XMC_USBD_Init+0x1c0>)
	  XMC_USBD_EP_OUT_BUFFERSIZE[i] = XMC_USBD_EP0_BUFFER_SIZE;
	  XMC_USBD_EP_IN_BUFFERSIZE[i] 	= XMC_USBD_EP0_BUFFER_SIZE;
  }

  /* clear device status */
  memset((void*)&xmc_device,0x0U,sizeof(XMC_USBD_DEVICE_t));
 8022b14:	2100      	movs	r1, #0
  XMC_ASSERT("XMC_USBD_Init: obj.usbd_max_num_eps not of type XMC_USBD_MAX_NUM_EPS_t",
 		      XMC_USBD_CHECK_INPUT_MAX_NUM_EPS(obj->usbd_max_num_eps))
  
  XMC_USBD_Enable();
  
  usbd_init = obj;
 8022b16:	601f      	str	r7, [r3, #0]
	  XMC_USBD_EP_OUT_BUFFERSIZE[i] = XMC_USBD_EP0_BUFFER_SIZE;
	  XMC_USBD_EP_IN_BUFFERSIZE[i] 	= XMC_USBD_EP0_BUFFER_SIZE;
  }

  /* clear device status */
  memset((void*)&xmc_device,0x0U,sizeof(XMC_USBD_DEVICE_t));
 8022b18:	f44f 7202 	mov.w	r2, #520	; 0x208
  usbd_init = obj;

  /* Filling out buffer size */
  for(i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
	  XMC_USBD_EP_OUT_BUFFERSIZE[i] = XMC_USBD_EP0_BUFFER_SIZE;
 8022b1c:	2340      	movs	r3, #64	; 0x40
	  XMC_USBD_EP_IN_BUFFERSIZE[i] 	= XMC_USBD_EP0_BUFFER_SIZE;
  }

  /* clear device status */
  memset((void*)&xmc_device,0x0U,sizeof(XMC_USBD_DEVICE_t));
 8022b1e:	4620      	mov	r0, r4
  usbd_init = obj;

  /* Filling out buffer size */
  for(i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
	  XMC_USBD_EP_OUT_BUFFERSIZE[i] = XMC_USBD_EP0_BUFFER_SIZE;
 8022b20:	6033      	str	r3, [r6, #0]
 8022b22:	6073      	str	r3, [r6, #4]
 8022b24:	60b3      	str	r3, [r6, #8]
 8022b26:	60f3      	str	r3, [r6, #12]
 8022b28:	6133      	str	r3, [r6, #16]
 8022b2a:	6173      	str	r3, [r6, #20]
 8022b2c:	61b3      	str	r3, [r6, #24]
	  XMC_USBD_EP_IN_BUFFERSIZE[i] 	= XMC_USBD_EP0_BUFFER_SIZE;
 8022b2e:	602b      	str	r3, [r5, #0]
 8022b30:	606b      	str	r3, [r5, #4]
 8022b32:	60ab      	str	r3, [r5, #8]
 8022b34:	60eb      	str	r3, [r5, #12]
 8022b36:	612b      	str	r3, [r5, #16]
 8022b38:	616b      	str	r3, [r5, #20]
 8022b3a:	61ab      	str	r3, [r5, #24]
  }

  /* clear device status */
  memset((void*)&xmc_device,0x0U,sizeof(XMC_USBD_DEVICE_t));
 8022b3c:	f00c f83f 	bl	802ebbe <memset>

  /* assign callbacks */
  xmc_device.DeviceEvent_cb = obj->cb_xmc_device_event;
  xmc_device.EndpointEvent_cb = obj->cb_endpoint_event;
  XMC_USBD_BASE_ADDRESS = (uint8_t *)(obj->usbd);
 8022b40:	683b      	ldr	r3, [r7, #0]
  /* Done by driver core */
  /* configure ahb details */  
  gahbcfg.d32 = xmc_device.global_register->gahbcfg;
  gahbcfg.b.glblintrmsk = 1U; /* enable interrupts ( global mask ) */
  gahbcfg.b.nptxfemplvl_txfemplvl = 1U;
  if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022b42:	7b7d      	ldrb	r5, [r7, #13]
    						(i * XMC_USBD_TX_FIFO_OFFSET));
  }
  /* obj data structure for endpoint 0 */
  /* Done by driver core */
  /* configure ahb details */  
  gahbcfg.d32 = xmc_device.global_register->gahbcfg;
 8022b44:	689a      	ldr	r2, [r3, #8]

  /* clear device status */
  memset((void*)&xmc_device,0x0U,sizeof(XMC_USBD_DEVICE_t));

  /* assign callbacks */
  xmc_device.DeviceEvent_cb = obj->cb_xmc_device_event;
 8022b46:	6878      	ldr	r0, [r7, #4]
  xmc_device.EndpointEvent_cb = obj->cb_endpoint_event;
 8022b48:	68be      	ldr	r6, [r7, #8]
  /* Done by driver core */
  /* configure ahb details */  
  gahbcfg.d32 = xmc_device.global_register->gahbcfg;
  gahbcfg.b.glblintrmsk = 1U; /* enable interrupts ( global mask ) */
  gahbcfg.b.nptxfemplvl_txfemplvl = 1U;
  if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022b4a:	fab5 f185 	clz	r1, r5
  xmc_device.DeviceEvent_cb = obj->cb_xmc_device_event;
  xmc_device.EndpointEvent_cb = obj->cb_endpoint_event;
  XMC_USBD_BASE_ADDRESS = (uint8_t *)(obj->usbd);
  /* assign register address */
  xmc_device.global_register = (dwc_otg_core_global_regs_t*)(obj->usbd);
  xmc_device.device_register = ((dwc_otg_device_global_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_GLOBAL_REG_OFFSET));
 8022b4e:	f503 6a00 	add.w	sl, r3, #2048	; 0x800
  /* Done by driver core */
  /* configure ahb details */  
  gahbcfg.d32 = xmc_device.global_register->gahbcfg;
  gahbcfg.b.glblintrmsk = 1U; /* enable interrupts ( global mask ) */
  gahbcfg.b.nptxfemplvl_txfemplvl = 1U;
  if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022b52:	0949      	lsrs	r1, r1, #5
  /* assign register address */
  xmc_device.global_register = (dwc_otg_core_global_regs_t*)(obj->usbd);
  xmc_device.device_register = ((dwc_otg_device_global_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_GLOBAL_REG_OFFSET));
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
    xmc_device.endpoint_in_register[i] = (dwc_otg_dev_in_ep_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_IN_EP_REG_OFFSET +
 8022b54:	f503 6910 	add.w	r9, r3, #2304	; 0x900
  /* obj data structure for endpoint 0 */
  /* Done by driver core */
  /* configure ahb details */  
  gahbcfg.d32 = xmc_device.global_register->gahbcfg;
  gahbcfg.b.glblintrmsk = 1U; /* enable interrupts ( global mask ) */
  gahbcfg.b.nptxfemplvl_txfemplvl = 1U;
 8022b58:	f042 0281 	orr.w	r2, r2, #129	; 0x81

  /* clear device status */
  memset((void*)&xmc_device,0x0U,sizeof(XMC_USBD_DEVICE_t));

  /* assign callbacks */
  xmc_device.DeviceEvent_cb = obj->cb_xmc_device_event;
 8022b5c:	f8c4 0200 	str.w	r0, [r4, #512]	; 0x200
  xmc_device.EndpointEvent_cb = obj->cb_endpoint_event;
 8022b60:	f8c4 6204 	str.w	r6, [r4, #516]	; 0x204
  XMC_USBD_BASE_ADDRESS = (uint8_t *)(obj->usbd);
  /* assign register address */
  xmc_device.global_register = (dwc_otg_core_global_regs_t*)(obj->usbd);
  xmc_device.device_register = ((dwc_otg_device_global_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_GLOBAL_REG_OFFSET));
 8022b64:	f8c4 a1a4 	str.w	sl, [r4, #420]	; 0x1a4
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
    xmc_device.endpoint_in_register[i] = (dwc_otg_dev_in_ep_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_IN_EP_REG_OFFSET +
 8022b68:	f8c4 91a8 	str.w	r9, [r4, #424]	; 0x1a8
 8022b6c:	f361 1245 	bfi	r2, r1, #5, #1
 8022b70:	f503 6812 	add.w	r8, r3, #2336	; 0x920
 8022b74:	f503 6c14 	add.w	ip, r3, #2368	; 0x940
 8022b78:	f503 6e16 	add.w	lr, r3, #2400	; 0x960
 8022b7c:	f503 6718 	add.w	r7, r3, #2432	; 0x980
 8022b80:	f503 601a 	add.w	r0, r3, #2464	; 0x9a0
 8022b84:	f503 6b1c 	add.w	fp, r3, #2496	; 0x9c0
    ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
    xmc_device.endpoint_out_register[i] = (dwc_otg_dev_out_ep_regs_t*)(XMC_USBD_BASE_ADDRESS +
    									  DWC_DEV_OUT_EP_REG_OFFSET +
 8022b88:	f503 6130 	add.w	r1, r3, #2816	; 0xb00
 8022b8c:	f503 6632 	add.w	r6, r3, #2848	; 0xb20
 8022b90:	f503 6a34 	add.w	sl, r3, #2880	; 0xb40
 8022b94:	f503 6936 	add.w	r9, r3, #2912	; 0xb60
  /* assign register address */
  xmc_device.global_register = (dwc_otg_core_global_regs_t*)(obj->usbd);
  xmc_device.device_register = ((dwc_otg_device_global_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_GLOBAL_REG_OFFSET));
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
    xmc_device.endpoint_in_register[i] = (dwc_otg_dev_in_ep_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_IN_EP_REG_OFFSET +
 8022b98:	f8c4 81ac 	str.w	r8, [r4, #428]	; 0x1ac
 8022b9c:	f8c4 c1b0 	str.w	ip, [r4, #432]	; 0x1b0
 8022ba0:	f8c4 e1b4 	str.w	lr, [r4, #436]	; 0x1b4
 8022ba4:	f8c4 71b8 	str.w	r7, [r4, #440]	; 0x1b8
 8022ba8:	f8c4 01bc 	str.w	r0, [r4, #444]	; 0x1bc
 8022bac:	f8c4 b1c0 	str.w	fp, [r4, #448]	; 0x1c0
    ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
    xmc_device.endpoint_out_register[i] = (dwc_otg_dev_out_ep_regs_t*)(XMC_USBD_BASE_ADDRESS +
 8022bb0:	f8c4 11c4 	str.w	r1, [r4, #452]	; 0x1c4
 8022bb4:	f8c4 61c8 	str.w	r6, [r4, #456]	; 0x1c8
 8022bb8:	f8c4 a1cc 	str.w	sl, [r4, #460]	; 0x1cc
 8022bbc:	f8c4 91d0 	str.w	r9, [r4, #464]	; 0x1d0
    									  ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.fifo[i] = (uint32_t*)(XMC_USBD_BASE_ADDRESS +
    						XMC_USBD_TX_FIFO_REG_OFFSET +
 8022bc0:	f503 4180 	add.w	r1, r3, #16384	; 0x4000
    ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
    xmc_device.endpoint_out_register[i] = (dwc_otg_dev_out_ep_regs_t*)(XMC_USBD_BASE_ADDRESS +
    									  DWC_DEV_OUT_EP_REG_OFFSET +
 8022bc4:	f503 6838 	add.w	r8, r3, #2944	; 0xb80
 8022bc8:	f503 6c3a 	add.w	ip, r3, #2976	; 0xba0
 8022bcc:	f503 6e3c 	add.w	lr, r3, #3008	; 0xbc0
    									  ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.fifo[i] = (uint32_t*)(XMC_USBD_BASE_ADDRESS +
    						XMC_USBD_TX_FIFO_REG_OFFSET +
 8022bd0:	f503 5780 	add.w	r7, r3, #4096	; 0x1000
 8022bd4:	f503 5000 	add.w	r0, r3, #8192	; 0x2000
 8022bd8:	f503 5b40 	add.w	fp, r3, #12288	; 0x3000
 8022bdc:	f503 46a0 	add.w	r6, r3, #20480	; 0x5000
 8022be0:	f503 4ac0 	add.w	sl, r3, #24576	; 0x6000
 8022be4:	f503 49e0 	add.w	r9, r3, #28672	; 0x7000
    									  DWC_DEV_OUT_EP_REG_OFFSET +
    									  ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.fifo[i] = (uint32_t*)(XMC_USBD_BASE_ADDRESS +
 8022be8:	f8c4 11ec 	str.w	r1, [r4, #492]	; 0x1ec
  /* assign callbacks */
  xmc_device.DeviceEvent_cb = obj->cb_xmc_device_event;
  xmc_device.EndpointEvent_cb = obj->cb_endpoint_event;
  XMC_USBD_BASE_ADDRESS = (uint8_t *)(obj->usbd);
  /* assign register address */
  xmc_device.global_register = (dwc_otg_core_global_regs_t*)(obj->usbd);
 8022bec:	f8c4 31a0 	str.w	r3, [r4, #416]	; 0x1a0
    xmc_device.endpoint_in_register[i] = (dwc_otg_dev_in_ep_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_IN_EP_REG_OFFSET +
    ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
    xmc_device.endpoint_out_register[i] = (dwc_otg_dev_out_ep_regs_t*)(XMC_USBD_BASE_ADDRESS +
 8022bf0:	f8c4 81d4 	str.w	r8, [r4, #468]	; 0x1d4
 8022bf4:	f8c4 c1d8 	str.w	ip, [r4, #472]	; 0x1d8
 8022bf8:	f8c4 e1dc 	str.w	lr, [r4, #476]	; 0x1dc
    									  DWC_DEV_OUT_EP_REG_OFFSET +
    									  ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.fifo[i] = (uint32_t*)(XMC_USBD_BASE_ADDRESS +
 8022bfc:	f8c4 71e0 	str.w	r7, [r4, #480]	; 0x1e0
 8022c00:	f8c4 01e4 	str.w	r0, [r4, #484]	; 0x1e4
 8022c04:	f8c4 b1e8 	str.w	fp, [r4, #488]	; 0x1e8
 8022c08:	f8c4 61f0 	str.w	r6, [r4, #496]	; 0x1f0
 8022c0c:	f8c4 a1f4 	str.w	sl, [r4, #500]	; 0x1f4
 8022c10:	f8c4 91f8 	str.w	r9, [r4, #504]	; 0x1f8
  }
  else
  {
    gahbcfg.b.dmaenable = 0U;
  }
  xmc_device.global_register->gahbcfg = gahbcfg.d32;
 8022c14:	609a      	str	r2, [r3, #8]
  /* configure usb details */  
  gusbcfg.d32= xmc_device.global_register->gusbcfg;
 8022c16:	68d9      	ldr	r1, [r3, #12]
  gusbcfg.b.force_dev_mode = 1U; /* force us into device mode */
  gusbcfg.b.srpcap = 1U; /* enable session request protocoll */
 8022c18:	f041 4180 	orr.w	r1, r1, #1073741824	; 0x40000000
 8022c1c:	f441 7180 	orr.w	r1, r1, #256	; 0x100
  xmc_device.global_register->gusbcfg = gusbcfg.d32;
 8022c20:	60d9      	str	r1, [r3, #12]

  /* Device init */
  /* configure device speed */  
  dcfg.d32 = xmc_device.device_register->dcfg;
 8022c22:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
  dcfg.b.devspd = XMC_USBD_DCFG_DEVSPD_FS;
 8022c26:	f042 0203 	orr.w	r2, r2, #3
  dcfg.b.descdma = 0U;
 8022c2a:	f36f 52d7 	bfc	r2, #23, #1
  xmc_device.device_register->dcfg = dcfg.d32;
 8022c2e:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
  /* configure device functions */  
  dctl.d32 = xmc_device.device_register->dctl;
 8022c32:	f8d3 2804 	ldr.w	r2, [r3, #2052]	; 0x804
 */
static void XMC_USBD_lFlushTXFifo(const uint8_t fifo_num) 
{
  volatile grstctl_t data;  
  uint32_t count;
  data.d32 = 0U;
 8022c36:	2100      	movs	r1, #0
  dcfg.b.devspd = XMC_USBD_DCFG_DEVSPD_FS;
  dcfg.b.descdma = 0U;
  xmc_device.device_register->dcfg = dcfg.d32;
  /* configure device functions */  
  dctl.d32 = xmc_device.device_register->dctl;
  dctl.b.sftdiscon = 1U; /* disconnect the device until its connected by the user */
 8022c38:	f042 0202 	orr.w	r2, r2, #2
  /* all other config is done by default register value */
  xmc_device.device_register->dctl = dctl.d32;
 8022c3c:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
 */
static void XMC_USBD_lFlushTXFifo(const uint8_t fifo_num) 
{
  volatile grstctl_t data;  
  uint32_t count;
  data.d32 = 0U;
 8022c40:	9100      	str	r1, [sp, #0]
  /*flush fifo */
  data.b.txfflsh = 1U;
 8022c42:	9a00      	ldr	r2, [sp, #0]
 8022c44:	f042 0220 	orr.w	r2, r2, #32
 8022c48:	9200      	str	r2, [sp, #0]
  data.b.txfnum = fifo_num;
 8022c4a:	9900      	ldr	r1, [sp, #0]
 8022c4c:	f421 61f8 	bic.w	r1, r1, #1984	; 0x7c0
 8022c50:	f441 6180 	orr.w	r1, r1, #1024	; 0x400
 8022c54:	9100      	str	r1, [sp, #0]
  xmc_device.global_register->grstctl = data.d32;
 8022c56:	9a00      	ldr	r2, [sp, #0]
 8022c58:	611a      	str	r2, [r3, #16]
  for (count = 0U;count < 1000U; count++){}
  do
  {
   data.d32 = xmc_device.global_register->grstctl;
 8022c5a:	691a      	ldr	r2, [r3, #16]
 8022c5c:	9200      	str	r2, [sp, #0]
  } while (data.b.txfflsh);
 8022c5e:	9a00      	ldr	r2, [sp, #0]
 8022c60:	f3c2 1240 	ubfx	r2, r2, #5, #1
 8022c64:	2a00      	cmp	r2, #0
 8022c66:	d1f8      	bne.n	8022c5a <XMC_USBD_Init+0x166>
static void XMC_USBD_lFlushRXFifo(void) 
{
  volatile grstctl_t data;  
  uint32_t count;
	
	data.d32 = 0U;
 8022c68:	9201      	str	r2, [sp, #4]
  data.b.rxfflsh = 1U;
 8022c6a:	9a01      	ldr	r2, [sp, #4]
 8022c6c:	f042 0210 	orr.w	r2, r2, #16
 8022c70:	9201      	str	r2, [sp, #4]
  /* flush FIFO */
  xmc_device.global_register->grstctl = data.d32;
 8022c72:	9a01      	ldr	r2, [sp, #4]
 8022c74:	611a      	str	r2, [r3, #16]
  do
  {
    for (count = 0U; count < 1000U; count++){}
    data.d32 = xmc_device.global_register->grstctl;
 8022c76:	691a      	ldr	r2, [r3, #16]
 8022c78:	9201      	str	r2, [sp, #4]
  } while (data.b.rxfflsh);
 8022c7a:	9801      	ldr	r0, [sp, #4]
 8022c7c:	f3c0 1000 	ubfx	r0, r0, #4, #1
 8022c80:	2800      	cmp	r0, #0
 8022c82:	d1f8      	bne.n	8022c76 <XMC_USBD_Init+0x182>
  gintmsk.b.usbsuspend = 1U;
  gintmsk.b.wkupintr = 1U;
  gintmsk.b.sofintr = 1U;
  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
  {
    gintmsk.b.rxstsqlvl = 1U;
 8022c84:	490c      	ldr	r1, [pc, #48]	; (8022cb8 <XMC_USBD_Init+0x1c4>)
 8022c86:	4a0d      	ldr	r2, [pc, #52]	; (8022cbc <XMC_USBD_Init+0x1c8>)
  /* flush the fifos for proper operation */
  XMC_USBD_lFlushTXFifo((uint8_t)0x10U); /* 0x10 == all fifos, see doc */
  XMC_USBD_lFlushRXFifo();
  /* Enable Global Interrupts */
  /* clear interrupt status bits prior to unmasking */
  xmc_device.global_register->gintmsk = 0U; /* disable all interrupts */
 8022c88:	6198      	str	r0, [r3, #24]
  gintmsk.b.usbsuspend = 1U;
  gintmsk.b.wkupintr = 1U;
  gintmsk.b.sofintr = 1U;
  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
  {
    gintmsk.b.rxstsqlvl = 1U;
 8022c8a:	2d01      	cmp	r5, #1
 8022c8c:	bf18      	it	ne
 8022c8e:	460a      	movne	r2, r1
  }
  gintmsk.b.outepintr = 1U;
  gintmsk.b.inepintr = 1U;
 8022c90:	f442 2240 	orr.w	r2, r2, #786432	; 0xc0000
  XMC_USBD_lFlushTXFifo((uint8_t)0x10U); /* 0x10 == all fifos, see doc */
  XMC_USBD_lFlushRXFifo();
  /* Enable Global Interrupts */
  /* clear interrupt status bits prior to unmasking */
  xmc_device.global_register->gintmsk = 0U; /* disable all interrupts */
  xmc_device.global_register->gintsts = 0xFFFFFFFFU; /* clear all interrupts */
 8022c94:	f04f 31ff 	mov.w	r1, #4294967295
 8022c98:	6159      	str	r1, [r3, #20]
  {
    gintmsk.b.rxstsqlvl = 1U;
  }
  gintmsk.b.outepintr = 1U;
  gintmsk.b.inepintr = 1U;
  xmc_device.global_register->gintmsk = gintmsk.d32;
 8022c9a:	619a      	str	r2, [r3, #24]
  return XMC_USBD_STATUS_OK;
}
 8022c9c:	b003      	add	sp, #12
 8022c9e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8022ca2:	bf00      	nop
 8022ca4:	20000080 	.word	0x20000080
 8022ca8:	2000d35c 	.word	0x2000d35c
 8022cac:	1ffe97c8 	.word	0x1ffe97c8
 8022cb0:	1ffe97e4 	.word	0x1ffe97e4
 8022cb4:	2000d358 	.word	0x2000d358
 8022cb8:	c0003c0e 	.word	0xc0003c0e
 8022cbc:	c0003c1e 	.word	0xc0003c1e

08022cc0 <XMC_USBD_EndpointReadStart>:

/**
 * Prepares the endpoint to read next OUT packet
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointReadStart(const uint8_t ep_addr, uint32_t size) 
{
 8022cc0:	b4f0      	push	{r4, r5, r6, r7}
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_addr & (uint8_t)XMC_USBD_EP_NUM_MASK];
 8022cc2:	f000 000f 	and.w	r0, r0, #15
  XMC_USBD_STATUS_t result;
	
  if (ep->outInUse || !ep->isConfigured)
 8022cc6:	2434      	movs	r4, #52	; 0x34
 8022cc8:	4e33      	ldr	r6, [pc, #204]	; (8022d98 <XMC_USBD_EndpointReadStart+0xd8>)
 8022cca:	fb04 f400 	mul.w	r4, r4, r0
 8022cce:	1932      	adds	r2, r6, r4

/**
 * Prepares the endpoint to read next OUT packet
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointReadStart(const uint8_t ep_addr, uint32_t size) 
{
 8022cd0:	b082      	sub	sp, #8
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_addr & (uint8_t)XMC_USBD_EP_NUM_MASK];
  XMC_USBD_STATUS_t result;
	
  if (ep->outInUse || !ep->isConfigured)
 8022cd2:	6853      	ldr	r3, [r2, #4]
 8022cd4:	f3c3 1300 	ubfx	r3, r3, #4, #1
 8022cd8:	2b00      	cmp	r3, #0
 8022cda:	d136      	bne.n	8022d4a <XMC_USBD_EndpointReadStart+0x8a>
 8022cdc:	7915      	ldrb	r5, [r2, #4]
 8022cde:	076d      	lsls	r5, r5, #29
 8022ce0:	d533      	bpl.n	8022d4a <XMC_USBD_EndpointReadStart+0x8a>
{
  deptsiz_data_t data;
  depctl_data_t epctl;
	
  data.d32 =  0U;
  if ((ep->xferTotal - ep->xferLength) > ep->maxTransferSize)
 8022ce2:	6895      	ldr	r5, [r2, #8]
 8022ce4:	9501      	str	r5, [sp, #4]
 8022ce6:	6955      	ldr	r5, [r2, #20]
    }
    /* set ep values */
    ep->xferTotal = size;
    ep->xferCount = 0U;
    ep->xferLength = 0U;
    ep->xferBuffer = ep->outBuffer;
 8022ce8:	68d7      	ldr	r7, [r2, #12]
    {
      size = ep->outBufferSize;
    }
    /* set ep values */
    ep->xferTotal = size;
    ep->xferCount = 0U;
 8022cea:	62d3      	str	r3, [r2, #44]	; 0x2c
 8022cec:	42a9      	cmp	r1, r5
 8022cee:	bf28      	it	cs
 8022cf0:	4629      	movcs	r1, r5
{
  deptsiz_data_t data;
  depctl_data_t epctl;
	
  data.d32 =  0U;
  if ((ep->xferTotal - ep->xferLength) > ep->maxTransferSize)
 8022cf2:	9d01      	ldr	r5, [sp, #4]
    /* set ep values */
    ep->xferTotal = size;
    ep->xferCount = 0U;
    ep->xferLength = 0U;
    ep->xferBuffer = ep->outBuffer;
    ep->outBytesAvailable = 0U;
 8022cf4:	6113      	str	r3, [r2, #16]
{
  deptsiz_data_t data;
  depctl_data_t epctl;
	
  data.d32 =  0U;
  if ((ep->xferTotal - ep->xferLength) > ep->maxTransferSize)
 8022cf6:	f3c5 0512 	ubfx	r5, r5, #0, #19
 8022cfa:	428d      	cmp	r5, r1
 8022cfc:	bf28      	it	cs
 8022cfe:	460d      	movcs	r5, r1
    if (size > ep->outBufferSize)
    {
      size = ep->outBufferSize;
    }
    /* set ep values */
    ep->xferTotal = size;
 8022d00:	6311      	str	r1, [r2, #48]	; 0x30
 8022d02:	6295      	str	r5, [r2, #40]	; 0x28
    ep->xferCount = 0U;
    ep->xferLength = 0U;
    ep->xferBuffer = ep->outBuffer;
 8022d04:	6257      	str	r7, [r2, #36]	; 0x24
  }
  else
  {
    ep->xferLength = ep->xferTotal;
  }
  if (ep->address_u.address_st.number == 0U)
 8022d06:	5d34      	ldrb	r4, [r6, r4]
 8022d08:	0724      	lsls	r4, r4, #28
 8022d0a:	d022      	beq.n	8022d52 <XMC_USBD_EndpointReadStart+0x92>
    ep0_data->b.xfersize = (uint8_t)ep->xferTotal;
  }
  else
  {
    /* If requested length is zero, just receive one zero length packet */
    if (ep->xferLength == 0U)
 8022d0c:	2d00      	cmp	r5, #0
 8022d0e:	d137      	bne.n	8022d80 <XMC_USBD_EndpointReadStart+0xc0>
    {
      data.b.xfersize = 0U;
      data.b.pktcnt = 1U;
 8022d10:	2201      	movs	r2, #1
 8022d12:	f362 43dc 	bfi	r3, r2, #19, #10
      /* setup endpoint to recive a amount of packages by given size */
      data.b.pktcnt = (uint16_t)(((ep->xferLength - ep->xferCount) + (ep->maxPacketSize -(uint32_t)1U))/ep->maxPacketSize);
      data.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
    }
  }
  if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022d16:	4a21      	ldr	r2, [pc, #132]	; (8022d9c <XMC_USBD_EndpointReadStart+0xdc>)
 8022d18:	6812      	ldr	r2, [r2, #0]
 8022d1a:	7b52      	ldrb	r2, [r2, #13]
 8022d1c:	bb2a      	cbnz	r2, 8022d6a <XMC_USBD_EndpointReadStart+0xaa>
  {
    /* Programm dma address if needed */
    xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepdma = (uint32_t)(ep->xferBuffer);
 8022d1e:	2234      	movs	r2, #52	; 0x34
 8022d20:	fb02 f000 	mul.w	r0, r2, r0
 8022d24:	1831      	adds	r1, r6, r0
 8022d26:	5c32      	ldrb	r2, [r6, r0]
 8022d28:	6a49      	ldr	r1, [r1, #36]	; 0x24
 8022d2a:	f002 020f 	and.w	r2, r2, #15
 8022d2e:	eb06 0282 	add.w	r2, r6, r2, lsl #2
 8022d32:	f8d2 21c4 	ldr.w	r2, [r2, #452]	; 0x1c4
 8022d36:	6151      	str	r1, [r2, #20]
  }
  /* setup endpoint size and enable endpoint */
  xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doeptsiz = data.d32;
 8022d38:	6113      	str	r3, [r2, #16]
 
  epctl.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 8022d3a:	6813      	ldr	r3, [r2, #0]
    ep->xferCount = 0U;
    ep->xferLength = 0U;
    ep->xferBuffer = ep->outBuffer;
    ep->outBytesAvailable = 0U;
    XMC_USBD_lStartReadXfer(ep);
    result= XMC_USBD_STATUS_OK;
 8022d3c:	2000      	movs	r0, #0
  /* setup endpoint size and enable endpoint */
  xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doeptsiz = data.d32;
 
  epctl.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
  epctl.b.cnak = 1U;
  epctl.b.epena = 1U;
 8022d3e:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
  xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = epctl.d32;
 8022d42:	6013      	str	r3, [r2, #0]
    ep->outBytesAvailable = 0U;
    XMC_USBD_lStartReadXfer(ep);
    result= XMC_USBD_STATUS_OK;
  }
  return result;
}
 8022d44:	b002      	add	sp, #8
 8022d46:	bcf0      	pop	{r4, r5, r6, r7}
 8022d48:	4770      	bx	lr
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_addr & (uint8_t)XMC_USBD_EP_NUM_MASK];
  XMC_USBD_STATUS_t result;
	
  if (ep->outInUse || !ep->isConfigured)
  {
    result = XMC_USBD_STATUS_ERROR;
 8022d4a:	2001      	movs	r0, #1
    ep->outBytesAvailable = 0U;
    XMC_USBD_lStartReadXfer(ep);
    result= XMC_USBD_STATUS_OK;
  }
  return result;
}
 8022d4c:	b002      	add	sp, #8
 8022d4e:	bcf0      	pop	{r4, r5, r6, r7}
 8022d50:	4770      	bx	lr
  if (ep->address_u.address_st.number == 0U)
  {
	/* Setup the endpoint to receive 3 setup packages and one normal package.*/
	/* Cast the data pointer to use only one variable */
    deptsiz0_data_t *ep0_data = (deptsiz0_data_t*)&data;
    ep0_data->b.pktcnt = 0x1U;
 8022d52:	2201      	movs	r2, #1
 8022d54:	f362 43d4 	bfi	r3, r2, #19, #2
      /* setup endpoint to recive a amount of packages by given size */
      data.b.pktcnt = (uint16_t)(((ep->xferLength - ep->xferCount) + (ep->maxPacketSize -(uint32_t)1U))/ep->maxPacketSize);
      data.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
    }
  }
  if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022d58:	4a10      	ldr	r2, [pc, #64]	; (8022d9c <XMC_USBD_EndpointReadStart+0xdc>)
 8022d5a:	6812      	ldr	r2, [r2, #0]
 8022d5c:	7b52      	ldrb	r2, [r2, #13]
  {
	/* Setup the endpoint to receive 3 setup packages and one normal package.*/
	/* Cast the data pointer to use only one variable */
    deptsiz0_data_t *ep0_data = (deptsiz0_data_t*)&data;
    ep0_data->b.pktcnt = 0x1U;
    ep0_data->b.supcnt = 0x3U;
 8022d5e:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
    ep0_data->b.xfersize = (uint8_t)ep->xferTotal;
 8022d62:	f361 0306 	bfi	r3, r1, #0, #7
      /* setup endpoint to recive a amount of packages by given size */
      data.b.pktcnt = (uint16_t)(((ep->xferLength - ep->xferCount) + (ep->maxPacketSize -(uint32_t)1U))/ep->maxPacketSize);
      data.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
    }
  }
  if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022d66:	2a00      	cmp	r2, #0
 8022d68:	d0d9      	beq.n	8022d1e <XMC_USBD_EndpointReadStart+0x5e>
 8022d6a:	2234      	movs	r2, #52	; 0x34
 8022d6c:	fb02 f000 	mul.w	r0, r2, r0
 8022d70:	5c32      	ldrb	r2, [r6, r0]
 8022d72:	f002 020f 	and.w	r2, r2, #15
 8022d76:	eb06 0282 	add.w	r2, r6, r2, lsl #2
 8022d7a:	f8d2 21c4 	ldr.w	r2, [r2, #452]	; 0x1c4
 8022d7e:	e7db      	b.n	8022d38 <XMC_USBD_EndpointReadStart+0x78>
      data.b.pktcnt = 1U;
    }
    else
    {
      /* setup endpoint to recive a amount of packages by given size */
      data.b.pktcnt = (uint16_t)(((ep->xferLength - ep->xferCount) + (ep->maxPacketSize -(uint32_t)1U))/ep->maxPacketSize);
 8022d80:	6852      	ldr	r2, [r2, #4]
 8022d82:	f3c2 21c6 	ubfx	r1, r2, #11, #7
 8022d86:	1e4a      	subs	r2, r1, #1
 8022d88:	442a      	add	r2, r5
 8022d8a:	fbb2 f2f1 	udiv	r2, r2, r1
 8022d8e:	f362 43dc 	bfi	r3, r2, #19, #10
      data.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
 8022d92:	f365 0312 	bfi	r3, r5, #0, #19
 8022d96:	e7be      	b.n	8022d16 <XMC_USBD_EndpointReadStart+0x56>
 8022d98:	2000d35c 	.word	0x2000d35c
 8022d9c:	2000d358 	.word	0x2000d358

08022da0 <XMC_USBD_EndpointWrite>:

/**
 * Writes number of bytes in to the USB IN endpoint.
 **/
int32_t XMC_USBD_EndpointWrite(const uint8_t ep_num,const uint8_t * buffer,uint32_t length) 
{
 8022da0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  XMC_USBD_EP_t * ep = &xmc_device.ep[ep_num & (uint8_t)XMC_USBD_EP_NUM_MASK];
 8022da4:	f000 070f 	and.w	r7, r0, #15
  int32_t result;
  if (!ep->isConfigured)
 8022da8:	2634      	movs	r6, #52	; 0x34
 8022daa:	4d39      	ldr	r5, [pc, #228]	; (8022e90 <XMC_USBD_EndpointWrite+0xf0>)
 8022dac:	fb06 f607 	mul.w	r6, r6, r7
 8022db0:	19ac      	adds	r4, r5, r6
 8022db2:	7923      	ldrb	r3, [r4, #4]
 8022db4:	075b      	lsls	r3, r3, #29
 8022db6:	d553      	bpl.n	8022e60 <XMC_USBD_EndpointWrite+0xc0>
  {
    result = (int32_t)XMC_USBD_STATUS_ERROR;
  }
  else if (ep->inInUse == 1U)
 8022db8:	6863      	ldr	r3, [r4, #4]
 8022dba:	0718      	lsls	r0, r3, #28
 8022dbc:	d457      	bmi.n	8022e6e <XMC_USBD_EndpointWrite+0xce>
  {
    result=(int32_t)0;
  }
  else
  {
    if (length > ep->inBufferSize)
 8022dbe:	6a23      	ldr	r3, [r4, #32]
    {
      length = ep->inBufferSize;
    }
    /* copy data into input buffer for DMA and FIFO mode */
		memcpy(ep->inBuffer,(const void *)buffer,length);
 8022dc0:	69e0      	ldr	r0, [r4, #28]
 8022dc2:	429a      	cmp	r2, r3
 8022dc4:	bf28      	it	cs
 8022dc6:	461a      	movcs	r2, r3
 8022dc8:	4691      	mov	r9, r2
 8022dca:	f00b feed 	bl	802eba8 <memcpy>
		ep->xferBuffer = ep->inBuffer;
    ep->xferTotal = length;
    /* set transfer values */
    ep->xferLength = 0U;
    ep->xferCount = 0U;
    ep->inInUse = 1U;
 8022dce:	6863      	ldr	r3, [r4, #4]
    {
      length = ep->inBufferSize;
    }
    /* copy data into input buffer for DMA and FIFO mode */
		memcpy(ep->inBuffer,(const void *)buffer,length);
		ep->xferBuffer = ep->inBuffer;
 8022dd0:	f8d4 c01c 	ldr.w	ip, [r4, #28]
 8022dd4:	f8c4 c024 	str.w	ip, [r4, #36]	; 0x24
    ep->xferTotal = length;
    /* set transfer values */
    ep->xferLength = 0U;
    ep->xferCount = 0U;
    ep->inInUse = 1U;
 8022dd8:	f043 0308 	orr.w	r3, r3, #8
		memcpy(ep->inBuffer,(const void *)buffer,length);
		ep->xferBuffer = ep->inBuffer;
    ep->xferTotal = length;
    /* set transfer values */
    ep->xferLength = 0U;
    ep->xferCount = 0U;
 8022ddc:	2100      	movs	r1, #0
    ep->inInUse = 1U;
 8022dde:	6063      	str	r3, [r4, #4]
		memcpy(ep->inBuffer,(const void *)buffer,length);
		ep->xferBuffer = ep->inBuffer;
    ep->xferTotal = length;
    /* set transfer values */
    ep->xferLength = 0U;
    ep->xferCount = 0U;
 8022de0:	62e1      	str	r1, [r4, #44]	; 0x2c
      length = ep->inBufferSize;
    }
    /* copy data into input buffer for DMA and FIFO mode */
		memcpy(ep->inBuffer,(const void *)buffer,length);
		ep->xferBuffer = ep->inBuffer;
    ep->xferTotal = length;
 8022de2:	f8c4 9030 	str.w	r9, [r4, #48]	; 0x30
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
  ctl.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022de6:	5da8      	ldrb	r0, [r5, r6]

  if ((ep->xferTotal - ep->xferLength)  < ep->maxTransferSize)
 8022de8:	68a3      	ldr	r3, [r4, #8]
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
  ctl.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022dea:	f000 000f 	and.w	r0, r0, #15
 8022dee:	f100 0e6a 	add.w	lr, r0, #106	; 0x6a

  if ((ep->xferTotal - ep->xferLength)  < ep->maxTransferSize)
 8022df2:	f3c3 0212 	ubfx	r2, r3, #0, #19
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
  ctl.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022df6:	f855 802e 	ldr.w	r8, [r5, lr, lsl #2]
 8022dfa:	454a      	cmp	r2, r9
 8022dfc:	bf28      	it	cs
 8022dfe:	464a      	movcs	r2, r9
 8022e00:	f8d8 e000 	ldr.w	lr, [r8]
 8022e04:	62a2      	str	r2, [r4, #40]	; 0x28
  }
  else
  {
    ep->xferLength += ep->maxTransferSize;
  }
  if (ep->xferLength == 0U)
 8022e06:	b3aa      	cbz	r2, 8022e74 <XMC_USBD_EndpointWrite+0xd4>
    size.b.xfersize = 0U;
    size.b.pktcnt = 1U;
  }
  else
  {
    if (ep->address_u.address_st.number == 0U)
 8022e08:	5dab      	ldrb	r3, [r5, r6]
 8022e0a:	071b      	lsls	r3, r3, #28
 8022e0c:	d02b      	beq.n	8022e66 <XMC_USBD_EndpointWrite+0xc6>
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
    }
    else
    {
      size.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
      size.b.pktcnt = (uint16_t)(((uint16_t)(ep->xferLength - ep->xferCount) + (uint16_t)((uint16_t)ep->maxPacketSize - 1U))/
 8022e0e:	6863      	ldr	r3, [r4, #4]
 8022e10:	f3c3 24c6 	ubfx	r4, r3, #11, #7
 8022e14:	1e63      	subs	r3, r4, #1
 8022e16:	b29b      	uxth	r3, r3
 8022e18:	fa13 f382 	uxtah	r3, r3, r2
      /* ep->maxXferSize equals maxPacketSize */
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
    }
    else
    {
      size.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
 8022e1c:	f3c2 0212 	ubfx	r2, r2, #0, #19
      size.b.pktcnt = (uint16_t)(((uint16_t)(ep->xferLength - ep->xferCount) + (uint16_t)((uint16_t)ep->maxPacketSize - 1U))/
 8022e20:	fb93 f3f4 	sdiv	r3, r3, r4
 8022e24:	f3c3 0309 	ubfx	r3, r3, #0, #10
    		 ep->maxPacketSize);
    }
    if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022e28:	4c1a      	ldr	r4, [pc, #104]	; (8022e94 <XMC_USBD_EndpointWrite+0xf4>)
 8022e2a:	6824      	ldr	r4, [r4, #0]
 8022e2c:	7b64      	ldrb	r4, [r4, #13]
 8022e2e:	f362 0112 	bfi	r1, r2, #0, #19
 8022e32:	f363 41dc 	bfi	r1, r3, #19, #10
 8022e36:	bb0c      	cbnz	r4, 8022e7c <XMC_USBD_EndpointWrite+0xdc>
    {
      /* Program dma*/
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepdma = (uint32_t)ep->xferBuffer;
 8022e38:	f8c8 c014 	str.w	ip, [r8, #20]
			xmc_device.device_register->dtknqr4_fifoemptymsk |= (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
    }
  }

  /* Program size of transfer and enable endpoint */
  xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dieptsiz = size.d32;
 8022e3c:	2334      	movs	r3, #52	; 0x34
 8022e3e:	fb03 f707 	mul.w	r7, r3, r7
 8022e42:	19ea      	adds	r2, r5, r7
 8022e44:	5deb      	ldrb	r3, [r5, r7]
    ep->xferLength = 0U;
    ep->xferCount = 0U;
    ep->inInUse = 1U;
    /* start the transfer */
    XMC_USBD_lStartWriteXfer(ep);
    result=(int32_t)ep->xferTotal;
 8022e46:	6b10      	ldr	r0, [r2, #48]	; 0x30
			xmc_device.device_register->dtknqr4_fifoemptymsk |= (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
    }
  }

  /* Program size of transfer and enable endpoint */
  xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dieptsiz = size.d32;
 8022e48:	f003 030f 	and.w	r3, r3, #15
 8022e4c:	336a      	adds	r3, #106	; 0x6a
  ctl.b.epena = 1U;
  ctl.b.cnak = 1U;
 8022e4e:	f04e 4e04 	orr.w	lr, lr, #2214592512	; 0x84000000
			xmc_device.device_register->dtknqr4_fifoemptymsk |= (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
    }
  }

  /* Program size of transfer and enable endpoint */
  xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dieptsiz = size.d32;
 8022e52:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 8022e56:	6119      	str	r1, [r3, #16]
  ctl.b.epena = 1U;
  ctl.b.cnak = 1U;
  xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = ctl.d32;
 8022e58:	f8c3 e000 	str.w	lr, [r3]
 8022e5c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
{
  XMC_USBD_EP_t * ep = &xmc_device.ep[ep_num & (uint8_t)XMC_USBD_EP_NUM_MASK];
  int32_t result;
  if (!ep->isConfigured)
  {
    result = (int32_t)XMC_USBD_STATUS_ERROR;
 8022e60:	2001      	movs	r0, #1
 8022e62:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  {
    if (ep->address_u.address_st.number == 0U)
    {
      size.b.pktcnt = 1U;
      /* ep->maxXferSize equals maxPacketSize */
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
 8022e66:	f3c2 0212 	ubfx	r2, r2, #0, #19
  }
  else
  {
    if (ep->address_u.address_st.number == 0U)
    {
      size.b.pktcnt = 1U;
 8022e6a:	2301      	movs	r3, #1
 8022e6c:	e7dc      	b.n	8022e28 <XMC_USBD_EndpointWrite+0x88>
  {
    result = (int32_t)XMC_USBD_STATUS_ERROR;
  }
  else if (ep->inInUse == 1U)
  {
    result=(int32_t)0;
 8022e6e:	2000      	movs	r0, #0
    /* start the transfer */
    XMC_USBD_lStartWriteXfer(ep);
    result=(int32_t)ep->xferTotal;
  }
  return result;
}
 8022e70:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    ep->xferLength += ep->maxTransferSize;
  }
  if (ep->xferLength == 0U)
  {
    size.b.xfersize = 0U;
    size.b.pktcnt = 1U;
 8022e74:	2301      	movs	r3, #1
 8022e76:	f363 41dc 	bfi	r1, r3, #19, #10
 8022e7a:	e7df      	b.n	8022e3c <XMC_USBD_EndpointWrite+0x9c>
    if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
    {
      /* Program dma*/
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepdma = (uint32_t)ep->xferBuffer;
    }
    if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022e7c:	2c01      	cmp	r4, #1
 8022e7e:	d1dd      	bne.n	8022e3c <XMC_USBD_EndpointWrite+0x9c>
    {
      /* enable fifo empty interrupt */
			xmc_device.device_register->dtknqr4_fifoemptymsk |= (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
 8022e80:	f8d5 21a4 	ldr.w	r2, [r5, #420]	; 0x1a4
 8022e84:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8022e86:	4084      	lsls	r4, r0
 8022e88:	431c      	orrs	r4, r3
 8022e8a:	6354      	str	r4, [r2, #52]	; 0x34
 8022e8c:	e7d6      	b.n	8022e3c <XMC_USBD_EndpointWrite+0x9c>
 8022e8e:	bf00      	nop
 8022e90:	2000d35c 	.word	0x2000d35c
 8022e94:	2000d358 	.word	0x2000d358

08022e98 <XMC_USBD_IRQHandler>:
 *
 * The handler first checks, which global interrupt has caused the interrupt
 * and then dispatches interrupt to the corresponding sub-handler.
 */
void XMC_USBD_IRQHandler(const XMC_USBD_t *const obj) 
{
 8022e98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  gintmsk_data_t gintmsk;
  gintsts_data_t data;
	
  gintmsk.d32 = xmc_device.global_register->gintmsk;
 8022e9c:	4cb9      	ldr	r4, [pc, #740]	; (8023184 <XMC_USBD_IRQHandler+0x2ec>)
 8022e9e:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
 8022ea2:	699d      	ldr	r5, [r3, #24]
  data.d32 = xmc_device.global_register->gintsts & gintmsk.d32;
 8022ea4:	695a      	ldr	r2, [r3, #20]
 *
 * The handler first checks, which global interrupt has caused the interrupt
 * and then dispatches interrupt to the corresponding sub-handler.
 */
void XMC_USBD_IRQHandler(const XMC_USBD_t *const obj) 
{
 8022ea6:	b08f      	sub	sp, #60	; 0x3c
  gintmsk_data_t gintmsk;
  gintsts_data_t data;
	
  gintmsk.d32 = xmc_device.global_register->gintmsk;
  data.d32 = xmc_device.global_register->gintsts & gintmsk.d32;
 8022ea8:	ea02 0a05 	and.w	sl, r2, r5
	
  if (data.b.sofintr)
 8022eac:	fa5f f68a 	uxtb.w	r6, sl
 *
 * The handler first checks, which global interrupt has caused the interrupt
 * and then dispatches interrupt to the corresponding sub-handler.
 */
void XMC_USBD_IRQHandler(const XMC_USBD_t *const obj) 
{
 8022eb0:	9001      	str	r0, [sp, #4]
  gintsts_data_t data;
	
  gintmsk.d32 = xmc_device.global_register->gintmsk;
  data.d32 = xmc_device.global_register->gintsts & gintmsk.d32;
	
  if (data.b.sofintr)
 8022eb2:	0730      	lsls	r0, r6, #28
 8022eb4:	f100 82eb 	bmi.w	802348e <XMC_USBD_IRQHandler+0x5f6>
  {
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_SOF);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_SOF);
  }
  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022eb8:	9a01      	ldr	r2, [sp, #4]
 8022eba:	7b52      	ldrb	r2, [r2, #13]
 8022ebc:	2a01      	cmp	r2, #1
 8022ebe:	f000 82f3 	beq.w	80234a8 <XMC_USBD_IRQHandler+0x610>
      XMC_USBD_lHandleRxFLvl(); /* handle the interrupt */
      gintmsk.b.rxstsqlvl = 1U;
      xmc_device.global_register->gintmsk = gintmsk.d32;
    }
  }
  if (data.b.erlysuspend)
 8022ec2:	f3ca 2507 	ubfx	r5, sl, #8, #8
 8022ec6:	0769      	lsls	r1, r5, #29
	  break;
    case (XMC_USBD_EVENT_SOF):
	  clear.b.sofintr = 1U;
	  break;
    case (XMC_USBD_EVENT_EARLYSUSPEND):
	  clear.b.erlysuspend = 1U;
 8022ec8:	bf44      	itt	mi
 8022eca:	f44f 6280 	movmi.w	r2, #1024	; 0x400
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022ece:	615a      	strmi	r2, [r3, #20]
  }
  if (data.b.erlysuspend)
  {
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_EARLYSUSPEND);
  }
  if (data.b.usbsuspend)
 8022ed0:	072a      	lsls	r2, r5, #28
 8022ed2:	f100 82d2 	bmi.w	802347a <XMC_USBD_IRQHandler+0x5e2>
  {
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_SUSPEND);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_SUSPEND);
  }
  if (data.b.wkupintr)
 8022ed6:	ea4f 661a 	mov.w	r6, sl, lsr #24
 8022eda:	0637      	lsls	r7, r6, #24
 8022edc:	f100 82c3 	bmi.w	8023466 <XMC_USBD_IRQHandler+0x5ce>
  {
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_REMOTE_WAKEUP);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_REMOTE_WAKEUP);
  }
  if (data.b.sessreqintr)
 8022ee0:	0670      	lsls	r0, r6, #25
 8022ee2:	f100 82b0 	bmi.w	8023446 <XMC_USBD_IRQHandler+0x5ae>
  {
    xmc_device.IsPowered = 1U;
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_POWER_ON);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_POWER_ON);
  }
  if (data.b.usbreset)
 8022ee6:	06e9      	lsls	r1, r5, #27
 8022ee8:	f100 81f1 	bmi.w	80232ce <XMC_USBD_IRQHandler+0x436>
  {
    XMC_USBD_lHandleUSBReset(obj);
  }
  if (data.b.enumdone)
 8022eec:	06aa      	lsls	r2, r5, #26
 8022eee:	f100 81d3 	bmi.w	8023298 <XMC_USBD_IRQHandler+0x400>
  {
    XMC_USBD_lHandleEnumDone();
  }
  if (data.b.inepint)
 8022ef2:	f41a 2f80 	tst.w	sl, #262144	; 0x40000
 8022ef6:	f040 8105 	bne.w	8023104 <XMC_USBD_IRQHandler+0x26c>
  {
    XMC_USBD_lHandleIEPInt(obj);
  }
  if (data.b.outepintr)
 8022efa:	f41a 2f00 	tst.w	sl, #524288	; 0x80000
 8022efe:	d118      	bne.n	8022f32 <XMC_USBD_IRQHandler+0x9a>
  {
		XMC_USBD_lHandleOEPInt(obj);
  }
	if (data.b.otgintr)
 8022f00:	f01a 0f04 	tst.w	sl, #4
 8022f04:	d102      	bne.n	8022f0c <XMC_USBD_IRQHandler+0x74>
  {
	  XMC_USBD_lHandleOTGInt();
  }

}
 8022f06:	b00f      	add	sp, #60	; 0x3c
 8022f08:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
* It detects especially connect and disconnect events.
*/
static void XMC_USBD_lHandleOTGInt(void) 
{
  gotgint_data_t data;
  data.d32 = xmc_device.global_register->gotgint;
 8022f0c:	685d      	ldr	r5, [r3, #4]
  if (data.b.sesenddet)
 8022f0e:	0768      	lsls	r0, r5, #29
 8022f10:	d50b      	bpl.n	8022f2a <XMC_USBD_IRQHandler+0x92>
  {
		xmc_device.IsPowered = 0U;
 8022f12:	f894 31fe 	ldrb.w	r3, [r4, #510]	; 0x1fe
		xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_POWER_OFF);
 8022f16:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
{
  gotgint_data_t data;
  data.d32 = xmc_device.global_register->gotgint;
  if (data.b.sesenddet)
  {
		xmc_device.IsPowered = 0U;
 8022f1a:	f36f 0382 	bfc	r3, #2, #1
 8022f1e:	f884 31fe 	strb.w	r3, [r4, #510]	; 0x1fe
		xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_POWER_OFF);
 8022f22:	2001      	movs	r0, #1
 8022f24:	4790      	blx	r2
 8022f26:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
 **/
static void XMC_USBD_lClearEventOTG(uint32_t event)
{
  gotgint_data_t clear = { .d32 = 0U};
  clear.d32 = event;
  xmc_device.global_register->gotgint = clear.d32;
 8022f2a:	605d      	str	r5, [r3, #4]
	if (data.b.otgintr)
  {
	  XMC_USBD_lHandleOTGInt();
  }

}
 8022f2c:	b00f      	add	sp, #60	; 0x3c
 8022f2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  uint16_t temp;
  uint16_t temp1;
  uint16_t mask;
  uint8_t ep_num;
	
  daint.d32 = xmc_device.device_register->daint;
 8022f32:	f8d4 21a4 	ldr.w	r2, [r4, #420]	; 0x1a4
 8022f36:	6993      	ldr	r3, [r2, #24]
  
  daintmsk.d32 = xmc_device.device_register->daintmsk;
 8022f38:	69d7      	ldr	r7, [r2, #28]
  
  doepmsk.d32 = xmc_device.device_register->doepmsk;  
 8022f3a:	6952      	ldr	r2, [r2, #20]
 8022f3c:	9202      	str	r2, [sp, #8]
  
  mask = daint.ep.out & daintmsk.ep.out;
 8022f3e:	f3c3 430f 	ubfx	r3, r3, #16, #16
  ep_num = 0U;
  doeptsiz.d32 = 0U;
 8022f42:	2200      	movs	r2, #0
 
  while ((uint16_t)mask >> ep_num)
 8022f44:	ea13 4717 	ands.w	r7, r3, r7, lsr #16
  
  doepmsk.d32 = xmc_device.device_register->doepmsk;  
  
  mask = daint.ep.out & daintmsk.ep.out;
  ep_num = 0U;
  doeptsiz.d32 = 0U;
 8022f48:	9203      	str	r2, [sp, #12]
 
  while ((uint16_t)mask >> ep_num)
 8022f4a:	f000 8097 	beq.w	802307c <XMC_USBD_IRQHandler+0x1e4>
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8022f4e:	f8dd b004 	ldr.w	fp, [sp, #4]
 8022f52:	f8cd a010 	str.w	sl, [sp, #16]
 8022f56:	4616      	mov	r6, r2
  
  mask = daint.ep.out & daintmsk.ep.out;
  ep_num = 0U;
  doeptsiz.d32 = 0U;
 
  while ((uint16_t)mask >> ep_num)
 8022f58:	463b      	mov	r3, r7
 8022f5a:	4615      	mov	r5, r2
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8022f5c:	f04f 0c34 	mov.w	ip, #52	; 0x34
 8022f60:	46b8      	mov	r8, r7
 
  while ((uint16_t)mask >> ep_num)
  {
    temp1 = (mask >> (uint16_t)ep_num);
    temp = temp1 & 0x1U;
    if (temp)
 8022f62:	07df      	lsls	r7, r3, #31
 8022f64:	f140 8081 	bpl.w	802306a <XMC_USBD_IRQHandler+0x1d2>
    {
      /* load register data for endpoint */
      ep = &xmc_device.ep[ep_num];
      doepint.d32 = xmc_device.endpoint_out_register[ep_num]->doepint & doepmsk.d32;
 8022f68:	f106 0970 	add.w	r9, r6, #112	; 0x70
 8022f6c:	eb04 0289 	add.w	r2, r4, r9, lsl #2
 8022f70:	9902      	ldr	r1, [sp, #8]
 8022f72:	6852      	ldr	r2, [r2, #4]
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022f74:	f89b 300d 	ldrb.w	r3, [fp, #13]
    temp = temp1 & 0x1U;
    if (temp)
    {
      /* load register data for endpoint */
      ep = &xmc_device.ep[ep_num];
      doepint.d32 = xmc_device.endpoint_out_register[ep_num]->doepint & doepmsk.d32;
 8022f78:	6897      	ldr	r7, [r2, #8]
 8022f7a:	400f      	ands	r7, r1
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
      {
        doeptsiz.d32 = xmc_device.endpoint_out_register[ep_num]->doeptsiz;
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
 8022f7c:	fa5f fa87 	uxtb.w	sl, r7
    if (temp)
    {
      /* load register data for endpoint */
      ep = &xmc_device.ep[ep_num];
      doepint.d32 = xmc_device.endpoint_out_register[ep_num]->doepint & doepmsk.d32;
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022f80:	2b00      	cmp	r3, #0
 8022f82:	f040 8081 	bne.w	8023088 <XMC_USBD_IRQHandler+0x1f0>
      {
        doeptsiz.d32 = xmc_device.endpoint_out_register[ep_num]->doeptsiz;
 8022f86:	6911      	ldr	r1, [r2, #16]
 8022f88:	9103      	str	r1, [sp, #12]
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
 8022f8a:	f01a 0f08 	tst.w	sl, #8
 8022f8e:	d021      	beq.n	8022fd4 <XMC_USBD_IRQHandler+0x13c>
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8022f90:	4a7c      	ldr	r2, [pc, #496]	; (8023184 <XMC_USBD_IRQHandler+0x2ec>)
 8022f92:	fb0c 2006 	mla	r0, ip, r6, r2
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* calculate size for setup packet */
		  ep->outBytesAvailable = (uint32_t)(((uint32_t)XMC_USBD_SETUP_COUNT -
		  (uint32_t)((deptsiz0_data_t*)&doeptsiz)->b.supcnt)*(uint32_t)XMC_USBD_SETUP_SIZE);
 8022f96:	9a03      	ldr	r2, [sp, #12]
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8022f98:	7901      	ldrb	r1, [r0, #4]
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* calculate size for setup packet */
		  ep->outBytesAvailable = (uint32_t)(((uint32_t)XMC_USBD_SETUP_COUNT -
		  (uint32_t)((deptsiz0_data_t*)&doeptsiz)->b.supcnt)*(uint32_t)XMC_USBD_SETUP_SIZE);
 8022f9a:	f3c2 7241 	ubfx	r2, r2, #29, #2
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* calculate size for setup packet */
		  ep->outBytesAvailable = (uint32_t)(((uint32_t)XMC_USBD_SETUP_COUNT -
 8022f9e:	00d2      	lsls	r2, r2, #3
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8022fa0:	f363 1145 	bfi	r1, r3, #5, #1
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* calculate size for setup packet */
		  ep->outBytesAvailable = (uint32_t)(((uint32_t)XMC_USBD_SETUP_COUNT -
 8022fa4:	f1c2 0218 	rsb	r2, r2, #24
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8022fa8:	7101      	strb	r1, [r0, #4]
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* calculate size for setup packet */
		  ep->outBytesAvailable = (uint32_t)(((uint32_t)XMC_USBD_SETUP_COUNT -
 8022faa:	6102      	str	r2, [r0, #16]
        }
		if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
		{
			ep->outBytesAvailable += ep->xferCount;
		}
		ep->outInUse = 0U;
 8022fac:	fb0c 4306 	mla	r3, ip, r6, r4
 8022fb0:	f8cd c004 	str.w	ip, [sp, #4]
 8022fb4:	685a      	ldr	r2, [r3, #4]
 8022fb6:	f022 0210 	bic.w	r2, r2, #16
 8022fba:	605a      	str	r2, [r3, #4]
		xmc_device.EndpointEvent_cb(0U,XMC_USBD_EP_EVENT_SETUP); /* signal endpoint event */
 8022fbc:	2000      	movs	r0, #0
 8022fbe:	f8d4 3204 	ldr.w	r3, [r4, #516]	; 0x204
 8022fc2:	4601      	mov	r1, r0
 8022fc4:	4798      	blx	r3
 **/
void XMC_USBD_ClearEventOUTEP(uint32_t event,const uint8_t ep_num)
{
  doepint_data_t clear;
  clear.d32 = event;
  xmc_device.endpoint_out_register[ep_num]->doepint = clear.d32;
 8022fc6:	eb04 0389 	add.w	r3, r4, r9, lsl #2
 8022fca:	2108      	movs	r1, #8
 8022fcc:	685a      	ldr	r2, [r3, #4]
 8022fce:	f8dd c004 	ldr.w	ip, [sp, #4]
 8022fd2:	6091      	str	r1, [r2, #8]
		ep->outInUse = 0U;
		xmc_device.EndpointEvent_cb(0U,XMC_USBD_EP_EVENT_SETUP); /* signal endpoint event */
				/* clear the interrupt */
		XMC_USBD_ClearEventOUTEP((uint32_t)XMC_USBD_EVENT_OUT_EP_SETUP,ep_num);
      }
      if (doepint.b.xfercompl)
 8022fd4:	f01a 0f01 	tst.w	sl, #1
 8022fd8:	d046      	beq.n	8023068 <XMC_USBD_IRQHandler+0x1d0>
      {
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022fda:	f89b 300d 	ldrb.w	r3, [fp, #13]
 8022fde:	2b00      	cmp	r3, #0
 8022fe0:	d063      	beq.n	80230aa <XMC_USBD_IRQHandler+0x212>
 8022fe2:	fb0c 4306 	mla	r3, ip, r6, r4
 8022fe6:	6a99      	ldr	r1, [r3, #40]	; 0x28
        {
          uint32_t bytes = (ep->xferLength - ep->xferCount) - doeptsiz.b.xfersize;
          ep->xferCount += bytes;
          ep->xferBuffer += bytes;
				}
        if (ep->xferTotal == ep->xferLength)
 8022fe8:	fb0c 4306 	mla	r3, ip, r6, r4
 8022fec:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8022fee:	428a      	cmp	r2, r1
 8022ff0:	d072      	beq.n	80230d8 <XMC_USBD_IRQHandler+0x240>
{
  deptsiz_data_t data;
  depctl_data_t epctl;
	
  data.d32 =  0U;
  if ((ep->xferTotal - ep->xferLength) > ep->maxTransferSize)
 8022ff2:	6898      	ldr	r0, [r3, #8]
 8022ff4:	ebc1 0e02 	rsb	lr, r1, r2
 8022ff8:	f3c0 0012 	ubfx	r0, r0, #0, #19
 8022ffc:	4586      	cmp	lr, r0
 8022ffe:	fb0c fe06 	mul.w	lr, ip, r6
  {
    ep->xferLength += ep->maxTransferSize;
 8023002:	bf88      	it	hi
 8023004:	1809      	addhi	r1, r1, r0
 8023006:	eb04 000e 	add.w	r0, r4, lr
{
  deptsiz_data_t data;
  depctl_data_t epctl;
	
  data.d32 =  0U;
  if ((ep->xferTotal - ep->xferLength) > ep->maxTransferSize)
 802300a:	bf98      	it	ls
 802300c:	4611      	movls	r1, r2
 802300e:	6281      	str	r1, [r0, #40]	; 0x28
  }
  else
  {
    ep->xferLength = ep->xferTotal;
  }
  if (ep->address_u.address_st.number == 0U)
 8023010:	f814 e00e 	ldrb.w	lr, [r4, lr]
 8023014:	f01e 0f0f 	tst.w	lr, #15
static void XMC_USBD_lStartReadXfer(XMC_USBD_EP_t *const ep) 
{
  deptsiz_data_t data;
  depctl_data_t epctl;
	
  data.d32 =  0U;
 8023018:	f04f 0300 	mov.w	r3, #0
 802301c:	f100 0a28 	add.w	sl, r0, #40	; 0x28
  }
  else
  {
    ep->xferLength = ep->xferTotal;
  }
  if (ep->address_u.address_st.number == 0U)
 8023020:	f040 82ae 	bne.w	8023580 <XMC_USBD_IRQHandler+0x6e8>
  {
	/* Setup the endpoint to receive 3 setup packages and one normal package.*/
	/* Cast the data pointer to use only one variable */
    deptsiz0_data_t *ep0_data = (deptsiz0_data_t*)&data;
    ep0_data->b.pktcnt = 0x1U;
 8023024:	2101      	movs	r1, #1
 8023026:	f361 43d4 	bfi	r3, r1, #19, #2
    ep0_data->b.supcnt = 0x3U;
 802302a:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
    ep0_data->b.xfersize = (uint8_t)ep->xferTotal;
 802302e:	f362 0306 	bfi	r3, r2, #0, #7
      /* setup endpoint to recive a amount of packages by given size */
      data.b.pktcnt = (uint16_t)(((ep->xferLength - ep->xferCount) + (ep->maxPacketSize -(uint32_t)1U))/ep->maxPacketSize);
      data.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
    }
  }
  if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8023032:	4a55      	ldr	r2, [pc, #340]	; (8023188 <XMC_USBD_IRQHandler+0x2f0>)
 8023034:	6812      	ldr	r2, [r2, #0]
 8023036:	7b52      	ldrb	r2, [r2, #13]
  {
    /* Programm dma address if needed */
    xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepdma = (uint32_t)(ep->xferBuffer);
 8023038:	fb0c f606 	mul.w	r6, ip, r6
      /* setup endpoint to recive a amount of packages by given size */
      data.b.pktcnt = (uint16_t)(((ep->xferLength - ep->xferCount) + (ep->maxPacketSize -(uint32_t)1U))/ep->maxPacketSize);
      data.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
    }
  }
  if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
 802303c:	2a00      	cmp	r2, #0
 802303e:	f040 82a6 	bne.w	802358e <XMC_USBD_IRQHandler+0x6f6>
  {
    /* Programm dma address if needed */
    xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepdma = (uint32_t)(ep->xferBuffer);
 8023042:	5da2      	ldrb	r2, [r4, r6]
 8023044:	f002 020f 	and.w	r2, r2, #15
 8023048:	19a1      	adds	r1, r4, r6
 802304a:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 802304e:	6a48      	ldr	r0, [r1, #36]	; 0x24
 8023050:	f8d2 11c4 	ldr.w	r1, [r2, #452]	; 0x1c4
 8023054:	6148      	str	r0, [r1, #20]
  }
  /* setup endpoint size and enable endpoint */
  xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doeptsiz = data.d32;
 8023056:	610b      	str	r3, [r1, #16]
 
  epctl.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 8023058:	680b      	ldr	r3, [r1, #0]
 802305a:	eb04 0989 	add.w	r9, r4, r9, lsl #2
  epctl.b.cnak = 1U;
  epctl.b.epena = 1U;
 802305e:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 8023062:	f8d9 2004 	ldr.w	r2, [r9, #4]
  xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = epctl.d32;
 8023066:	600b      	str	r3, [r1, #0]
 **/
void XMC_USBD_ClearEventOUTEP(uint32_t event,const uint8_t ep_num)
{
  doepint_data_t clear;
  clear.d32 = event;
  xmc_device.endpoint_out_register[ep_num]->doepint = clear.d32;
 8023068:	6097      	str	r7, [r2, #8]

      }

      XMC_USBD_ClearEventOUTEP(doepint.d32,ep_num);
    }
    ep_num++;
 802306a:	3501      	adds	r5, #1
 802306c:	b2ed      	uxtb	r5, r5
  
  mask = daint.ep.out & daintmsk.ep.out;
  ep_num = 0U;
  doeptsiz.d32 = 0U;
 
  while ((uint16_t)mask >> ep_num)
 802306e:	fa58 f305 	asrs.w	r3, r8, r5
 8023072:	462e      	mov	r6, r5
 8023074:	f47f af75 	bne.w	8022f62 <XMC_USBD_IRQHandler+0xca>
 8023078:	f8dd a010 	ldr.w	sl, [sp, #16]
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 802307c:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
	  break;
    case (XMC_USBD_EVENT_ENUMDONE):
	  clear.b.enumdone = 1U;
	  break;
    case (XMC_USBD_EVENT_OUTEP):
	  clear.b.outepintr = 1U;
 8023080:	f44f 2200 	mov.w	r2, #524288	; 0x80000
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8023084:	615a      	str	r2, [r3, #20]
 8023086:	e73b      	b.n	8022f00 <XMC_USBD_IRQHandler+0x68>
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
      {
        doeptsiz.d32 = xmc_device.endpoint_out_register[ep_num]->doeptsiz;
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
 8023088:	f01a 0f08 	tst.w	sl, #8
 802308c:	d0a2      	beq.n	8022fd4 <XMC_USBD_IRQHandler+0x13c>
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 802308e:	4a3d      	ldr	r2, [pc, #244]	; (8023184 <XMC_USBD_IRQHandler+0x2ec>)
 8023090:	fb0c 2106 	mla	r1, ip, r6, r2
        {
          /* calculate size for setup packet */
		  ep->outBytesAvailable = (uint32_t)(((uint32_t)XMC_USBD_SETUP_COUNT -
		  (uint32_t)((deptsiz0_data_t*)&doeptsiz)->b.supcnt)*(uint32_t)XMC_USBD_SETUP_SIZE);
        }
		if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8023094:	2b01      	cmp	r3, #1
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8023096:	790a      	ldrb	r2, [r1, #4]
 8023098:	f36f 1245 	bfc	r2, #5, #1
 802309c:	710a      	strb	r2, [r1, #4]
        {
          /* calculate size for setup packet */
		  ep->outBytesAvailable = (uint32_t)(((uint32_t)XMC_USBD_SETUP_COUNT -
		  (uint32_t)((deptsiz0_data_t*)&doeptsiz)->b.supcnt)*(uint32_t)XMC_USBD_SETUP_SIZE);
        }
		if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 802309e:	d185      	bne.n	8022fac <XMC_USBD_IRQHandler+0x114>
		{
			ep->outBytesAvailable += ep->xferCount;
 80230a0:	690b      	ldr	r3, [r1, #16]
 80230a2:	6aca      	ldr	r2, [r1, #44]	; 0x2c
 80230a4:	4413      	add	r3, r2
 80230a6:	610b      	str	r3, [r1, #16]
 80230a8:	e780      	b.n	8022fac <XMC_USBD_IRQHandler+0x114>
      }
      if (doepint.b.xfercompl)
      {
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          uint32_t bytes = (ep->xferLength - ep->xferCount) - doeptsiz.b.xfersize;
 80230aa:	fb0c 4006 	mla	r0, ip, r6, r4
 80230ae:	9b03      	ldr	r3, [sp, #12]
 80230b0:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 80230b2:	6a81      	ldr	r1, [r0, #40]	; 0x28
 80230b4:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80230b8:	ebc2 0e01 	rsb	lr, r2, r1
 80230bc:	ebc3 030e 	rsb	r3, r3, lr
          ep->xferCount += bytes;
 80230c0:	eb02 0e03 	add.w	lr, r2, r3
          ep->xferBuffer += bytes;
 80230c4:	6a42      	ldr	r2, [r0, #36]	; 0x24
      if (doepint.b.xfercompl)
      {
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          uint32_t bytes = (ep->xferLength - ep->xferCount) - doeptsiz.b.xfersize;
          ep->xferCount += bytes;
 80230c6:	f8c0 e02c 	str.w	lr, [r0, #44]	; 0x2c
          ep->xferBuffer += bytes;
 80230ca:	4413      	add	r3, r2
 80230cc:	6243      	str	r3, [r0, #36]	; 0x24
				}
        if (ep->xferTotal == ep->xferLength)
 80230ce:	fb0c 4306 	mla	r3, ip, r6, r4
 80230d2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80230d4:	428a      	cmp	r2, r1
 80230d6:	d18c      	bne.n	8022ff2 <XMC_USBD_IRQHandler+0x15a>
 80230d8:	f8cd c004 	str.w	ip, [sp, #4]
        {
          ep->outBytesAvailable = ep->xferCount;
          ep->outInUse = 0U;
 80230dc:	685a      	ldr	r2, [r3, #4]
          ep->xferCount += bytes;
          ep->xferBuffer += bytes;
				}
        if (ep->xferTotal == ep->xferLength)
        {
          ep->outBytesAvailable = ep->xferCount;
 80230de:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 80230e0:	6119      	str	r1, [r3, #16]
          ep->outInUse = 0U;
 80230e2:	f022 0210 	bic.w	r2, r2, #16
 80230e6:	605a      	str	r2, [r3, #4]
          xmc_device.EndpointEvent_cb(ep_num,XMC_USBD_EP_EVENT_OUT);
 80230e8:	4b26      	ldr	r3, [pc, #152]	; (8023184 <XMC_USBD_IRQHandler+0x2ec>)
 80230ea:	4628      	mov	r0, r5
 80230ec:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
 80230f0:	2101      	movs	r1, #1
 80230f2:	4798      	blx	r3
 80230f4:	4b23      	ldr	r3, [pc, #140]	; (8023184 <XMC_USBD_IRQHandler+0x2ec>)
 80230f6:	f8dd c004 	ldr.w	ip, [sp, #4]
 80230fa:	eb03 0989 	add.w	r9, r3, r9, lsl #2
 80230fe:	f8d9 2004 	ldr.w	r2, [r9, #4]
 8023102:	e7b1      	b.n	8023068 <XMC_USBD_IRQHandler+0x1d0>
  uint16_t temp1;
  uint16_t mask;
  uint8_t ep_num;
  uint32_t inepint;
	
  daint.d32 = xmc_device.device_register->daint;
 8023104:	f8d4 31a4 	ldr.w	r3, [r4, #420]	; 0x1a4
 8023108:	699a      	ldr	r2, [r3, #24]
  
  diepmsk.d32 = xmc_device.device_register->diepmsk;
 802310a:	691b      	ldr	r3, [r3, #16]
 802310c:	9303      	str	r3, [sp, #12]
  
  dieptsiz.d32 = 0U;
  mask = daint.ep.in;
  ep_num = 0U;
  
  while ((uint16_t)mask >> ep_num)
 802310e:	b297      	uxth	r7, r2
 8023110:	2f00      	cmp	r7, #0
 8023112:	d061      	beq.n	80231d8 <XMC_USBD_IRQHandler+0x340>
 8023114:	2600      	movs	r6, #0
 8023116:	46b6      	mov	lr, r6
 8023118:	463b      	mov	r3, r7
    if ((uint16_t)temp)
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
 802311a:	f04f 0b34 	mov.w	fp, #52	; 0x34
 802311e:	f8cd a010 	str.w	sl, [sp, #16]
 8023122:	46b9      	mov	r9, r7
  
  while ((uint16_t)mask >> ep_num)
  {
    temp1 = ((uint16_t)mask >> (uint16_t)ep_num);
    temp = (uint16_t)temp1 & (uint16_t)0x1U;
    if ((uint16_t)temp)
 8023124:	07db      	lsls	r3, r3, #31
 8023126:	d54f      	bpl.n	80231c8 <XMC_USBD_IRQHandler+0x330>
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
 8023128:	f10e 036a 	add.w	r3, lr, #106	; 0x6a
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
 802312c:	fb0b f00e 	mul.w	r0, fp, lr
    temp1 = ((uint16_t)mask >> (uint16_t)ep_num);
    temp = (uint16_t)temp1 & (uint16_t)0x1U;
    if ((uint16_t)temp)
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
 8023130:	9302      	str	r3, [sp, #8]
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
 8023132:	f8d4 a1a4 	ldr.w	sl, [r4, #420]	; 0x1a4
    temp1 = ((uint16_t)mask >> (uint16_t)ep_num);
    temp = (uint16_t)temp1 & (uint16_t)0x1U;
    if ((uint16_t)temp)
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
 8023136:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
 802313a:	f814 8000 	ldrb.w	r8, [r4, r0]
    temp1 = ((uint16_t)mask >> (uint16_t)ep_num);
    temp = (uint16_t)temp1 & (uint16_t)0x1U;
    if ((uint16_t)temp)
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
 802313e:	689d      	ldr	r5, [r3, #8]
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
 8023140:	f8da 1034 	ldr.w	r1, [sl, #52]	; 0x34
                     0x1U) << 7U) | (uint32_t)diepmsk.d32);
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8023144:	9a01      	ldr	r2, [sp, #4]
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
                     0x1U) << 7U) | (uint32_t)diepmsk.d32);
 8023146:	9f03      	ldr	r7, [sp, #12]
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8023148:	7b52      	ldrb	r2, [r2, #13]
    if ((uint16_t)temp)
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
 802314a:	f008 0c0f 	and.w	ip, r8, #15
 802314e:	fa21 f10c 	lsr.w	r1, r1, ip
                     0x1U) << 7U) | (uint32_t)diepmsk.d32);
 8023152:	01c9      	lsls	r1, r1, #7
 8023154:	b2c9      	uxtb	r1, r1
 8023156:	4339      	orrs	r1, r7
    if ((uint16_t)temp)
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
 8023158:	4420      	add	r0, r4
    temp = (uint16_t)temp1 & (uint16_t)0x1U;
    if ((uint16_t)temp)
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
      diepint.d32 = inepint &
 802315a:	400d      	ands	r5, r1
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
                     0x1U) << 7U) | (uint32_t)diepmsk.d32);
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 802315c:	b9b2      	cbnz	r2, 802318c <XMC_USBD_IRQHandler+0x2f4>
          bytes = XMC_USBD_lWriteFifo(ep);
          ep->xferCount += bytes;
          ep->xferBuffer += bytes;
        }
      }
      if (diepint.b.xfercompl)
 802315e:	07ef      	lsls	r7, r5, #31
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
                     0x1U) << 7U) | (uint32_t)diepmsk.d32);
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
      {
        dieptsiz.d32 = xmc_device.endpoint_in_register[ep_num]->dieptsiz;
 8023160:	691a      	ldr	r2, [r3, #16]
          bytes = XMC_USBD_lWriteFifo(ep);
          ep->xferCount += bytes;
          ep->xferBuffer += bytes;
        }
      }
      if (diepint.b.xfercompl)
 8023162:	d530      	bpl.n	80231c6 <XMC_USBD_IRQHandler+0x32e>
      {
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* update xfer values */
          if ((dieptsiz.b.pktcnt == 0U) && (dieptsiz.b.xfersize == 0U))
 8023164:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
 8023168:	2a00      	cmp	r2, #0
 802316a:	f000 8218 	beq.w	802359e <XMC_USBD_IRQHandler+0x706>
 802316e:	6a81      	ldr	r1, [r0, #40]	; 0x28
            uint32_t Bytes = ep->xferLength - ep->xferCount;
            ep->xferCount += Bytes;
            ep->xferBuffer += Bytes;
          }
        }
        if (ep->xferTotal==ep->xferLength)
 8023170:	fb0b 420e 	mla	r2, fp, lr, r4
 8023174:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8023176:	428b      	cmp	r3, r1
 8023178:	d133      	bne.n	80231e2 <XMC_USBD_IRQHandler+0x34a>
        {
          ep->inInUse = 0U;
 802317a:	6853      	ldr	r3, [r2, #4]
 802317c:	f023 0308 	bic.w	r3, r3, #8
 8023180:	6053      	str	r3, [r2, #4]
 8023182:	e017      	b.n	80231b4 <XMC_USBD_IRQHandler+0x31c>
 8023184:	2000d35c 	.word	0x2000d35c
 8023188:	2000d358 	.word	0x2000d358
                     0x1U) << 7U) | (uint32_t)diepmsk.d32);
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
      {
        dieptsiz.d32 = xmc_device.endpoint_in_register[ep_num]->dieptsiz;
      }
      if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 802318c:	2a01      	cmp	r2, #1
 802318e:	d102      	bne.n	8023196 <XMC_USBD_IRQHandler+0x2fe>
      {
        if (diepint.b.emptyintr)
 8023190:	0629      	lsls	r1, r5, #24
 8023192:	f100 822a 	bmi.w	80235ea <XMC_USBD_IRQHandler+0x752>
          bytes = XMC_USBD_lWriteFifo(ep);
          ep->xferCount += bytes;
          ep->xferBuffer += bytes;
        }
      }
      if (diepint.b.xfercompl)
 8023196:	07e9      	lsls	r1, r5, #31
 8023198:	d515      	bpl.n	80231c6 <XMC_USBD_IRQHandler+0x32e>
            uint32_t Bytes = ep->xferLength - ep->xferCount;
            ep->xferCount += Bytes;
            ep->xferBuffer += Bytes;
          }
        }
        if (ep->xferTotal==ep->xferLength)
 802319a:	fb0b 400e 	mla	r0, fp, lr, r4
 802319e:	6b03      	ldr	r3, [r0, #48]	; 0x30
 80231a0:	6a81      	ldr	r1, [r0, #40]	; 0x28
 80231a2:	428b      	cmp	r3, r1
 80231a4:	d11d      	bne.n	80231e2 <XMC_USBD_IRQHandler+0x34a>
        {
          ep->inInUse = 0U;
 80231a6:	6843      	ldr	r3, [r0, #4]
          if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 80231a8:	2a01      	cmp	r2, #1
            ep->xferBuffer += Bytes;
          }
        }
        if (ep->xferTotal==ep->xferLength)
        {
          ep->inInUse = 0U;
 80231aa:	f023 0308 	bic.w	r3, r3, #8
 80231ae:	6043      	str	r3, [r0, #4]
          if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 80231b0:	f000 8273 	beq.w	802369a <XMC_USBD_IRQHandler+0x802>
          {
            /* mask fifo empty interrupt */
            xmc_device.device_register->dtknqr4_fifoemptymsk =
            (uint32_t)(xmc_device.device_register->dtknqr4_fifoemptymsk & ~(((uint32_t)1U << ep_num)));
          }
          xmc_device.EndpointEvent_cb(0x80U | ep_num,XMC_USBD_EP_EVENT_IN);
 80231b4:	f8d4 3204 	ldr.w	r3, [r4, #516]	; 0x204
 80231b8:	f046 0080 	orr.w	r0, r6, #128	; 0x80
 80231bc:	2102      	movs	r1, #2
 80231be:	4798      	blx	r3
 80231c0:	9b02      	ldr	r3, [sp, #8]
 80231c2:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 **/
void XMC_USBD_ClearEventINEP(uint32_t event,const uint8_t ep_num)
{
  diepint_data_t clear;
  clear.d32 = event;
  xmc_device.endpoint_in_register[ep_num]->diepint = clear.d32;
 80231c6:	609d      	str	r5, [r3, #8]

      }

      XMC_USBD_ClearEventINEP((uint32_t)diepint.d32,ep_num);
    }
    ep_num++;
 80231c8:	3601      	adds	r6, #1
 80231ca:	b2f6      	uxtb	r6, r6
  
  dieptsiz.d32 = 0U;
  mask = daint.ep.in;
  ep_num = 0U;
  
  while ((uint16_t)mask >> ep_num)
 80231cc:	fa59 f306 	asrs.w	r3, r9, r6
 80231d0:	46b6      	mov	lr, r6
 80231d2:	d1a7      	bne.n	8023124 <XMC_USBD_IRQHandler+0x28c>
 80231d4:	f8dd a010 	ldr.w	sl, [sp, #16]
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 80231d8:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
 80231dc:	2200      	movs	r2, #0
 80231de:	615a      	str	r2, [r3, #20]
 80231e0:	e68b      	b.n	8022efa <XMC_USBD_IRQHandler+0x62>
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
  ctl.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 80231e2:	fb0b f20e 	mul.w	r2, fp, lr
 80231e6:	18a0      	adds	r0, r4, r2
 80231e8:	5ca2      	ldrb	r2, [r4, r2]

  if ((ep->xferTotal - ep->xferLength)  < ep->maxTransferSize)
 80231ea:	6880      	ldr	r0, [r0, #8]
 80231ec:	ebc1 0803 	rsb	r8, r1, r3
 80231f0:	f3c0 0c12 	ubfx	ip, r0, #0, #19
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
  ctl.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 80231f4:	f002 020f 	and.w	r2, r2, #15

  if ((ep->xferTotal - ep->xferLength)  < ep->maxTransferSize)
 80231f8:	45e0      	cmp	r8, ip
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
  ctl.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 80231fa:	9206      	str	r2, [sp, #24]
 80231fc:	f102 026a 	add.w	r2, r2, #106	; 0x6a
  {
    ep->xferLength = ep->xferTotal;
  }
  else
  {
    ep->xferLength += ep->maxTransferSize;
 8023200:	bf28      	it	cs
 8023202:	eb01 030c 	addcs.w	r3, r1, ip
 8023206:	fb0b fc0e 	mul.w	ip, fp, lr
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
  ctl.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 802320a:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 802320e:	9205      	str	r2, [sp, #20]
 8023210:	eb04 010c 	add.w	r1, r4, ip
 8023214:	6812      	ldr	r2, [r2, #0]
 8023216:	628b      	str	r3, [r1, #40]	; 0x28
static void XMC_USBD_lStartWriteXfer(XMC_USBD_EP_t *const ep) 
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
 8023218:	2000      	movs	r0, #0
 802321a:	f101 0828 	add.w	r8, r1, #40	; 0x28
  }
  else
  {
    ep->xferLength += ep->maxTransferSize;
  }
  if (ep->xferLength == 0U)
 802321e:	2b00      	cmp	r3, #0
 8023220:	f000 81dd 	beq.w	80235de <XMC_USBD_IRQHandler+0x746>
    size.b.xfersize = 0U;
    size.b.pktcnt = 1U;
  }
  else
  {
    if (ep->address_u.address_st.number == 0U)
 8023224:	f814 c00c 	ldrb.w	ip, [r4, ip]
 8023228:	f01c 0f0f 	tst.w	ip, #15
 802322c:	f000 81cf 	beq.w	80235ce <XMC_USBD_IRQHandler+0x736>
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
    }
    else
    {
      size.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
      size.b.pktcnt = (uint16_t)(((uint16_t)(ep->xferLength - ep->xferCount) + (uint16_t)((uint16_t)ep->maxPacketSize - 1U))/
 8023230:	6849      	ldr	r1, [r1, #4]
      /* ep->maxXferSize equals maxPacketSize */
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
    }
    else
    {
      size.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
 8023232:	f8d8 7004 	ldr.w	r7, [r8, #4]
      size.b.pktcnt = (uint16_t)(((uint16_t)(ep->xferLength - ep->xferCount) + (uint16_t)((uint16_t)ep->maxPacketSize - 1U))/
 8023236:	f3c1 2cc6 	ubfx	ip, r1, #11, #7
 802323a:	f10c 38ff 	add.w	r8, ip, #4294967295
 802323e:	1bd9      	subs	r1, r3, r7
      /* ep->maxXferSize equals maxPacketSize */
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
    }
    else
    {
      size.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
 8023240:	460b      	mov	r3, r1
      size.b.pktcnt = (uint16_t)(((uint16_t)(ep->xferLength - ep->xferCount) + (uint16_t)((uint16_t)ep->maxPacketSize - 1U))/
 8023242:	fa1f f888 	uxth.w	r8, r8
 8023246:	fa18 f181 	uxtah	r1, r8, r1
      /* ep->maxXferSize equals maxPacketSize */
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
    }
    else
    {
      size.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
 802324a:	f3c3 0312 	ubfx	r3, r3, #0, #19
      size.b.pktcnt = (uint16_t)(((uint16_t)(ep->xferLength - ep->xferCount) + (uint16_t)((uint16_t)ep->maxPacketSize - 1U))/
 802324e:	fb91 fcfc 	sdiv	ip, r1, ip
 8023252:	f3cc 0c09 	ubfx	ip, ip, #0, #10
    		 ep->maxPacketSize);
    }
    if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8023256:	49c2      	ldr	r1, [pc, #776]	; (8023560 <XMC_USBD_IRQHandler+0x6c8>)
 8023258:	6809      	ldr	r1, [r1, #0]
 802325a:	7b49      	ldrb	r1, [r1, #13]
 802325c:	f363 0012 	bfi	r0, r3, #0, #19
 8023260:	f36c 40dc 	bfi	r0, ip, #19, #10
 8023264:	2900      	cmp	r1, #0
 8023266:	f040 820d 	bne.w	8023684 <XMC_USBD_IRQHandler+0x7ec>
    {
      /* Program dma*/
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepdma = (uint32_t)ep->xferBuffer;
 802326a:	fb0b 430e 	mla	r3, fp, lr, r4
 802326e:	9905      	ldr	r1, [sp, #20]
 8023270:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8023272:	614b      	str	r3, [r1, #20]
			xmc_device.device_register->dtknqr4_fifoemptymsk |= (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
    }
  }

  /* Program size of transfer and enable endpoint */
  xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dieptsiz = size.d32;
 8023274:	fb0b fe0e 	mul.w	lr, fp, lr
 8023278:	9b02      	ldr	r3, [sp, #8]
 802327a:	f814 100e 	ldrb.w	r1, [r4, lr]
 802327e:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 8023282:	f001 010f 	and.w	r1, r1, #15
 8023286:	316a      	adds	r1, #106	; 0x6a
  ctl.b.epena = 1U;
  ctl.b.cnak = 1U;
 8023288:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
			xmc_device.device_register->dtknqr4_fifoemptymsk |= (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
    }
  }

  /* Program size of transfer and enable endpoint */
  xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dieptsiz = size.d32;
 802328c:	f854 1021 	ldr.w	r1, [r4, r1, lsl #2]
 8023290:	6108      	str	r0, [r1, #16]
  ctl.b.epena = 1U;
  ctl.b.cnak = 1U;
  xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = ctl.d32;
 8023292:	600a      	str	r2, [r1, #0]
 **/
void XMC_USBD_ClearEventINEP(uint32_t event,const uint8_t ep_num)
{
  diepint_data_t clear;
  clear.d32 = event;
  xmc_device.endpoint_in_register[ep_num]->diepint = clear.d32;
 8023294:	609d      	str	r5, [r3, #8]
 8023296:	e797      	b.n	80231c8 <XMC_USBD_IRQHandler+0x330>
  /* Normaly we need to check dctl
   * We are always fullspeed, so max it up. */
  depctl_data_t epctl;
  gusbcfg_data_t gusbcfg;
	
  epctl.d32=xmc_device.endpoint_in_register[0U]->diepctl;
 8023298:	f8d4 11a8 	ldr.w	r1, [r4, #424]	; 0x1a8
  epctl.b.mps = 0x00U; /* 64 Byte, this is also automatically set for out ep */
  xmc_device.endpoint_in_register[0U]->diepctl = epctl.d32;

  /* update device connected flag */
  xmc_device.IsConnected = 1U;
 802329c:	f894 21fe 	ldrb.w	r2, [r4, #510]	; 0x1fe
  /* Normaly we need to check dctl
   * We are always fullspeed, so max it up. */
  depctl_data_t epctl;
  gusbcfg_data_t gusbcfg;
	
  epctl.d32=xmc_device.endpoint_in_register[0U]->diepctl;
 80232a0:	680b      	ldr	r3, [r1, #0]

  /* update device connected flag */
  xmc_device.IsConnected = 1U;
  xmc_device.IsPowered = 1U;

  xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_CONNECT);
 80232a2:	f8d4 5200 	ldr.w	r5, [r4, #512]	; 0x200
   * We are always fullspeed, so max it up. */
  depctl_data_t epctl;
  gusbcfg_data_t gusbcfg;
	
  epctl.d32=xmc_device.endpoint_in_register[0U]->diepctl;
  epctl.b.mps = 0x00U; /* 64 Byte, this is also automatically set for out ep */
 80232a6:	f36f 030a 	bfc	r3, #0, #11
  xmc_device.endpoint_in_register[0U]->diepctl = epctl.d32;

  /* update device connected flag */
  xmc_device.IsConnected = 1U;
  xmc_device.IsPowered = 1U;
 80232aa:	f042 0205 	orr.w	r2, r2, #5
  depctl_data_t epctl;
  gusbcfg_data_t gusbcfg;
	
  epctl.d32=xmc_device.endpoint_in_register[0U]->diepctl;
  epctl.b.mps = 0x00U; /* 64 Byte, this is also automatically set for out ep */
  xmc_device.endpoint_in_register[0U]->diepctl = epctl.d32;
 80232ae:	600b      	str	r3, [r1, #0]

  /* update device connected flag */
  xmc_device.IsConnected = 1U;
  xmc_device.IsPowered = 1U;

  xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_CONNECT);
 80232b0:	2002      	movs	r0, #2
  epctl.b.mps = 0x00U; /* 64 Byte, this is also automatically set for out ep */
  xmc_device.endpoint_in_register[0U]->diepctl = epctl.d32;

  /* update device connected flag */
  xmc_device.IsConnected = 1U;
  xmc_device.IsPowered = 1U;
 80232b2:	f884 21fe 	strb.w	r2, [r4, #510]	; 0x1fe

  xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_CONNECT);
 80232b6:	47a8      	blx	r5

  /* Set Trim */  
  gusbcfg.d32 = xmc_device.global_register->gusbcfg;
 80232b8:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
 80232bc:	68da      	ldr	r2, [r3, #12]
  gusbcfg.b.usbtrdtim = 9U; /* default value for LS/FS */
 80232be:	2109      	movs	r1, #9
 80232c0:	f361 228d 	bfi	r2, r1, #10, #4
	  break;
    case (XMC_USBD_EVENT_EARLYSUSPEND):
	  clear.b.erlysuspend = 1U;
	  break;
    case (XMC_USBD_EVENT_ENUMDONE):
	  clear.b.enumdone = 1U;
 80232c4:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_CONNECT);

  /* Set Trim */  
  gusbcfg.d32 = xmc_device.global_register->gusbcfg;
  gusbcfg.b.usbtrdtim = 9U; /* default value for LS/FS */
  xmc_device.global_register->gusbcfg = gusbcfg.d32;
 80232c8:	60da      	str	r2, [r3, #12]
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 80232ca:	6159      	str	r1, [r3, #20]
 80232cc:	e611      	b.n	8022ef2 <XMC_USBD_IRQHandler+0x5a>
  fifosize_data_t gnptxfsiz;
  daint_data_t daint;
  dcfg_data_t dcfg;
	
  /* Clear the Remote Wakeup Signaling */
  dctl.d32 = xmc_device.device_register->dctl;
 80232ce:	f8d4 11a4 	ldr.w	r1, [r4, #420]	; 0x1a4
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 80232d2:	f8d4 91c4 	ldr.w	r9, [r4, #452]	; 0x1c4
  fifosize_data_t gnptxfsiz;
  daint_data_t daint;
  dcfg_data_t dcfg;
	
  /* Clear the Remote Wakeup Signaling */
  dctl.d32 = xmc_device.device_register->dctl;
 80232d6:	684a      	ldr	r2, [r1, #4]
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 80232d8:	f8d4 71d4 	ldr.w	r7, [r4, #468]	; 0x1d4
 80232dc:	f8d4 61d8 	ldr.w	r6, [r4, #472]	; 0x1d8
 80232e0:	f8d4 01dc 	ldr.w	r0, [r4, #476]	; 0x1dc
  daint_data_t daint;
  dcfg_data_t dcfg;
	
  /* Clear the Remote Wakeup Signaling */
  dctl.d32 = xmc_device.device_register->dctl;
  dctl.b.rmtwkupsig = 1U;
 80232e4:	f042 0201 	orr.w	r2, r2, #1
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 80232e8:	f504 78e4 	add.w	r8, r4, #456	; 0x1c8
 80232ec:	e898 5100 	ldmia.w	r8, {r8, ip, lr}
  dcfg_data_t dcfg;
	
  /* Clear the Remote Wakeup Signaling */
  dctl.d32 = xmc_device.device_register->dctl;
  dctl.b.rmtwkupsig = 1U;
  xmc_device.device_register->dctl = dctl.d32;
 80232f0:	604a      	str	r2, [r1, #4]

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 80232f2:	f8d9 2000 	ldr.w	r2, [r9]
		epctl.b.snak = 1U;
 80232f6:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
		epctl.b.stall = 0U;
 80232fa:	f36f 5255 	bfc	r2, #21, #1
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
 80232fe:	f8c9 2000 	str.w	r2, [r9]
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 8023302:	f8d8 2000 	ldr.w	r2, [r8]
  gnptxfsiz.b.startaddr = 64U;
  xmc_device.global_register->gnptxfsiz = gnptxfsiz.d32;
  /* calculate the size for the rest */
  for (i = 1U;i < (uint8_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.global_register->dtxfsiz[i- 1U] = (uint32_t)(((256U + (i*(64U)))/4U) | ((uint32_t)16U << 16U));
 8023306:	f8df 9268 	ldr.w	r9, [pc, #616]	; 8023570 <XMC_USBD_IRQHandler+0x6d8>

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
		epctl.b.snak = 1U;
 802330a:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
		epctl.b.stall = 0U;
 802330e:	f36f 5255 	bfc	r2, #21, #1
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
 8023312:	f8c8 2000 	str.w	r2, [r8]
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 8023316:	f8dc 2000 	ldr.w	r2, [ip]
  gnptxfsiz.b.startaddr = 64U;
  xmc_device.global_register->gnptxfsiz = gnptxfsiz.d32;
  /* calculate the size for the rest */
  for (i = 1U;i < (uint8_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.global_register->dtxfsiz[i- 1U] = (uint32_t)(((256U + (i*(64U)))/4U) | ((uint32_t)16U << 16U));
 802331a:	f8df 8258 	ldr.w	r8, [pc, #600]	; 8023574 <XMC_USBD_IRQHandler+0x6dc>

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
		epctl.b.snak = 1U;
 802331e:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
		epctl.b.stall = 0U;
 8023322:	f36f 5255 	bfc	r2, #21, #1
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
 8023326:	f8cc 2000 	str.w	r2, [ip]
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 802332a:	f8de 2000 	ldr.w	r2, [lr]
  gnptxfsiz.b.startaddr = 64U;
  xmc_device.global_register->gnptxfsiz = gnptxfsiz.d32;
  /* calculate the size for the rest */
  for (i = 1U;i < (uint8_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.global_register->dtxfsiz[i- 1U] = (uint32_t)(((256U + (i*(64U)))/4U) | ((uint32_t)16U << 16U));
 802332e:	f8df c248 	ldr.w	ip, [pc, #584]	; 8023578 <XMC_USBD_IRQHandler+0x6e0>

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
		epctl.b.snak = 1U;
 8023332:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
		epctl.b.stall = 0U;
 8023336:	f36f 5255 	bfc	r2, #21, #1
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
 802333a:	f8ce 2000 	str.w	r2, [lr]
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 802333e:	683a      	ldr	r2, [r7, #0]
  gnptxfsiz.b.startaddr = 64U;
  xmc_device.global_register->gnptxfsiz = gnptxfsiz.d32;
  /* calculate the size for the rest */
  for (i = 1U;i < (uint8_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.global_register->dtxfsiz[i- 1U] = (uint32_t)(((256U + (i*(64U)))/4U) | ((uint32_t)16U << 16U));
 8023340:	f8df e238 	ldr.w	lr, [pc, #568]	; 802357c <XMC_USBD_IRQHandler+0x6e4>

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
		epctl.b.snak = 1U;
 8023344:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
		epctl.b.stall = 0U;
 8023348:	f36f 5255 	bfc	r2, #21, #1
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
 802334c:	603a      	str	r2, [r7, #0]
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 802334e:	6832      	ldr	r2, [r6, #0]
  gnptxfsiz.b.startaddr = 64U;
  xmc_device.global_register->gnptxfsiz = gnptxfsiz.d32;
  /* calculate the size for the rest */
  for (i = 1U;i < (uint8_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.global_register->dtxfsiz[i- 1U] = (uint32_t)(((256U + (i*(64U)))/4U) | ((uint32_t)16U << 16U));
 8023350:	4f84      	ldr	r7, [pc, #528]	; (8023564 <XMC_USBD_IRQHandler+0x6cc>)

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
		epctl.b.snak = 1U;
 8023352:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
		epctl.b.stall = 0U;
 8023356:	f36f 5255 	bfc	r2, #21, #1
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
 802335a:	6032      	str	r2, [r6, #0]
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 802335c:	6802      	ldr	r2, [r0, #0]
  gnptxfsiz.b.startaddr = 64U;
  xmc_device.global_register->gnptxfsiz = gnptxfsiz.d32;
  /* calculate the size for the rest */
  for (i = 1U;i < (uint8_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.global_register->dtxfsiz[i- 1U] = (uint32_t)(((256U + (i*(64U)))/4U) | ((uint32_t)16U << 16U));
 802335e:	4e82      	ldr	r6, [pc, #520]	; (8023568 <XMC_USBD_IRQHandler+0x6d0>)

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
		epctl.b.snak = 1U;
 8023360:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
		epctl.b.stall = 0U;
 8023364:	f36f 5255 	bfc	r2, #21, #1
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
 8023368:	6002      	str	r2, [r0, #0]
  }

  /* Configure fifos */
  /* Calculate the size of the rx fifo */
  xmc_device.global_register->grxfsiz = 64U;
 802336a:	2040      	movs	r0, #64	; 0x40
  /* Calculate the size of the tx fifo for ep 0 */  
  gnptxfsiz.d32 = 0U;
  gnptxfsiz.b.depth = 16U;
 802336c:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
  }

  /* Configure fifos */
  /* Calculate the size of the rx fifo */
  xmc_device.global_register->grxfsiz = 64U;
 8023370:	6258      	str	r0, [r3, #36]	; 0x24
  /* Calculate the size of the tx fifo for ep 0 */  
  gnptxfsiz.d32 = 0U;
  gnptxfsiz.b.depth = 16U;
  gnptxfsiz.b.startaddr = 64U;
 8023372:	f360 020f 	bfi	r2, r0, #0, #16
 */
static void XMC_USBD_lFlushTXFifo(const uint8_t fifo_num) 
{
  volatile grstctl_t data;  
  uint32_t count;
  data.d32 = 0U;
 8023376:	2000      	movs	r0, #0
  xmc_device.global_register->grxfsiz = 64U;
  /* Calculate the size of the tx fifo for ep 0 */  
  gnptxfsiz.d32 = 0U;
  gnptxfsiz.b.depth = 16U;
  gnptxfsiz.b.startaddr = 64U;
  xmc_device.global_register->gnptxfsiz = gnptxfsiz.d32;
 8023378:	629a      	str	r2, [r3, #40]	; 0x28
  /* calculate the size for the rest */
  for (i = 1U;i < (uint8_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.global_register->dtxfsiz[i- 1U] = (uint32_t)(((256U + (i*(64U)))/4U) | ((uint32_t)16U << 16U));
 802337a:	f8c3 9104 	str.w	r9, [r3, #260]	; 0x104
 802337e:	f8c3 8108 	str.w	r8, [r3, #264]	; 0x108
 8023382:	f8c3 c10c 	str.w	ip, [r3, #268]	; 0x10c
 8023386:	f8c3 e110 	str.w	lr, [r3, #272]	; 0x110
 802338a:	f8c3 7114 	str.w	r7, [r3, #276]	; 0x114
 802338e:	f8c3 6118 	str.w	r6, [r3, #280]	; 0x118
 */
static void XMC_USBD_lFlushTXFifo(const uint8_t fifo_num) 
{
  volatile grstctl_t data;  
  uint32_t count;
  data.d32 = 0U;
 8023392:	900d      	str	r0, [sp, #52]	; 0x34
  /*flush fifo */
  data.b.txfflsh = 1U;
 8023394:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8023396:	f042 0220 	orr.w	r2, r2, #32
 802339a:	920d      	str	r2, [sp, #52]	; 0x34
  data.b.txfnum = fifo_num;
 802339c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 802339e:	f422 62f8 	bic.w	r2, r2, #1984	; 0x7c0
 80233a2:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80233a6:	920d      	str	r2, [sp, #52]	; 0x34
  xmc_device.global_register->grstctl = data.d32;
 80233a8:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80233aa:	611a      	str	r2, [r3, #16]
  for (count = 0U;count < 1000U; count++){}
  do
  {
   data.d32 = xmc_device.global_register->grstctl;
 80233ac:	691a      	ldr	r2, [r3, #16]
 80233ae:	920d      	str	r2, [sp, #52]	; 0x34
  } while (data.b.txfflsh);
 80233b0:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80233b2:	f3c2 1240 	ubfx	r2, r2, #5, #1
 80233b6:	2a00      	cmp	r2, #0
 80233b8:	d1f8      	bne.n	80233ac <XMC_USBD_IRQHandler+0x514>
 */
static void XMC_USBD_lFlushTXFifo(const uint8_t fifo_num) 
{
  volatile grstctl_t data;  
  uint32_t count;
  data.d32 = 0U;
 80233ba:	920c      	str	r2, [sp, #48]	; 0x30
  /*flush fifo */
  data.b.txfflsh = 1U;
 80233bc:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80233be:	f042 0220 	orr.w	r2, r2, #32
 80233c2:	920c      	str	r2, [sp, #48]	; 0x30
  data.b.txfnum = fifo_num;
 80233c4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80233c6:	f422 62f8 	bic.w	r2, r2, #1984	; 0x7c0
 80233ca:	920c      	str	r2, [sp, #48]	; 0x30
  xmc_device.global_register->grstctl = data.d32;
 80233cc:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80233ce:	611a      	str	r2, [r3, #16]
  for (count = 0U;count < 1000U; count++){}
  do
  {
   data.d32 = xmc_device.global_register->grstctl;
 80233d0:	691a      	ldr	r2, [r3, #16]
 80233d2:	920c      	str	r2, [sp, #48]	; 0x30
  } while (data.b.txfflsh);
 80233d4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80233d6:	f3c2 1240 	ubfx	r2, r2, #5, #1
 80233da:	2a00      	cmp	r2, #0
 80233dc:	d1f8      	bne.n	80233d0 <XMC_USBD_IRQHandler+0x538>
static void XMC_USBD_lFlushRXFifo(void) 
{
  volatile grstctl_t data;  
  uint32_t count;
	
	data.d32 = 0U;
 80233de:	920b      	str	r2, [sp, #44]	; 0x2c
  data.b.rxfflsh = 1U;
 80233e0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80233e2:	f042 0210 	orr.w	r2, r2, #16
 80233e6:	920b      	str	r2, [sp, #44]	; 0x2c
  /* flush FIFO */
  xmc_device.global_register->grstctl = data.d32;
 80233e8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80233ea:	611a      	str	r2, [r3, #16]
  do
  {
    for (count = 0U; count < 1000U; count++){}
    data.d32 = xmc_device.global_register->grstctl;
 80233ec:	691a      	ldr	r2, [r3, #16]
 80233ee:	920b      	str	r2, [sp, #44]	; 0x2c
  } while (data.b.rxfflsh);
 80233f0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80233f2:	f3c2 1200 	ubfx	r2, r2, #4, #1
 80233f6:	2a00      	cmp	r2, #0
 80233f8:	d1f8      	bne.n	80233ec <XMC_USBD_IRQHandler+0x554>
  XMC_USBD_lFlushRXFifo();
  /* Flush learning queue not needed due to fifo config */
  /* enable ep0 interrupts */  
  daint.d32 = 0U;
  daint.b.inep0 = 1U;
  daint.b.outep0 = 1U;
 80233fa:	f04f 1301 	mov.w	r3, #65537	; 0x10001
  xmc_device.device_register->daintmsk = daint.d32;
 80233fe:	61cb      	str	r3, [r1, #28]
 **/
void XMC_USBD_EnableEventOUTEP(uint32_t event)
{
	doepint_data_t doepint;
	doepint.d32 = event;
	xmc_device.device_register->doepmsk |= doepint.d32;
 8023400:	694b      	ldr	r3, [r1, #20]
  /* Clear device Address */  
  dcfg.d32 = xmc_device.device_register->dcfg;
  dcfg.b.devaddr = 0U;
  xmc_device.device_register->dcfg = dcfg.d32;

  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8023402:	9801      	ldr	r0, [sp, #4]
 **/
void XMC_USBD_EnableEventOUTEP(uint32_t event)
{
	doepint_data_t doepint;
	doepint.d32 = event;
	xmc_device.device_register->doepmsk |= doepint.d32;
 8023404:	f043 030f 	orr.w	r3, r3, #15
  /* Clear device Address */  
  dcfg.d32 = xmc_device.device_register->dcfg;
  dcfg.b.devaddr = 0U;
  xmc_device.device_register->dcfg = dcfg.d32;

  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8023408:	7b40      	ldrb	r0, [r0, #13]
 **/
void XMC_USBD_EnableEventOUTEP(uint32_t event)
{
	doepint_data_t doepint;
	doepint.d32 = event;
	xmc_device.device_register->doepmsk |= doepint.d32;
 802340a:	614b      	str	r3, [r1, #20]
 **/
void XMC_USBD_EnableEventINEP(uint32_t event)
{
	diepint_data_t diepint;
	diepint.d32 = event;
	xmc_device.device_register->diepmsk |= diepint.d32;
 802340c:	690b      	ldr	r3, [r1, #16]
 802340e:	f043 030f 	orr.w	r3, r3, #15
 8023412:	610b      	str	r3, [r1, #16]
  XMC_USBD_EnableEventINEP(((uint32_t)XMC_USBD_EVENT_IN_EP_TX_COMPLET | (uint32_t)XMC_USBD_EVENT_IN_EP_DISABLED |
		  (uint32_t)XMC_USBD_EVENT_IN_EP_AHB_ERROR | (uint32_t)XMC_USBD_EVENT_IN_EP_TIMEOUT));


  /* Clear device Address */  
  dcfg.d32 = xmc_device.device_register->dcfg;
 8023414:	680b      	ldr	r3, [r1, #0]
  dcfg.b.devaddr = 0U;
  xmc_device.device_register->dcfg = dcfg.d32;

  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8023416:	2801      	cmp	r0, #1
		  (uint32_t)XMC_USBD_EVENT_IN_EP_AHB_ERROR | (uint32_t)XMC_USBD_EVENT_IN_EP_TIMEOUT));


  /* Clear device Address */  
  dcfg.d32 = xmc_device.device_register->dcfg;
  dcfg.b.devaddr = 0U;
 8023418:	f362 130a 	bfi	r3, r2, #4, #7
  xmc_device.device_register->dcfg = dcfg.d32;
 802341c:	600b      	str	r3, [r1, #0]

  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
  {
    /* Clear Empty interrupt */
    xmc_device.device_register->dtknqr4_fifoemptymsk = 0U;
 802341e:	bf08      	it	eq
 8023420:	634a      	streq	r2, [r1, #52]	; 0x34
  }

  xmc_device.ep[0U].outInUse = 0U;
 8023422:	6863      	ldr	r3, [r4, #4]
  xmc_device.ep[0U].inInUse = 0U;

  xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_RESET);
 8023424:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
  {
    /* Clear Empty interrupt */
    xmc_device.device_register->dtknqr4_fifoemptymsk = 0U;
  }

  xmc_device.ep[0U].outInUse = 0U;
 8023428:	f023 0310 	bic.w	r3, r3, #16
 802342c:	6063      	str	r3, [r4, #4]
  xmc_device.ep[0U].inInUse = 0U;
 802342e:	6863      	ldr	r3, [r4, #4]
 8023430:	f023 0308 	bic.w	r3, r3, #8
 8023434:	6063      	str	r3, [r4, #4]

  xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_RESET);
 8023436:	2004      	movs	r0, #4
 8023438:	4790      	blx	r2
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 802343a:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
  {
    case (XMC_USBD_EVENT_POWER_ON):
	  clear.b.sessreqintr = 1U;
	  break;
    case (XMC_USBD_EVENT_RESET):
	  clear.b.usbreset = 1U;
 802343e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8023442:	615a      	str	r2, [r3, #20]
 8023444:	e552      	b.n	8022eec <XMC_USBD_IRQHandler+0x54>
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_REMOTE_WAKEUP);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_REMOTE_WAKEUP);
  }
  if (data.b.sessreqintr)
  {
    xmc_device.IsPowered = 1U;
 8023446:	f894 31fe 	ldrb.w	r3, [r4, #510]	; 0x1fe
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_POWER_ON);
 802344a:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_REMOTE_WAKEUP);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_REMOTE_WAKEUP);
  }
  if (data.b.sessreqintr)
  {
    xmc_device.IsPowered = 1U;
 802344e:	f043 0304 	orr.w	r3, r3, #4
 8023452:	f884 31fe 	strb.w	r3, [r4, #510]	; 0x1fe
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_POWER_ON);
 8023456:	2000      	movs	r0, #0
 8023458:	4790      	blx	r2
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 802345a:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
  gintsts_data_t clear;
  clear.d32 = 0U;
  switch(event)
  {
    case (XMC_USBD_EVENT_POWER_ON):
	  clear.b.sessreqintr = 1U;
 802345e:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8023462:	615a      	str	r2, [r3, #20]
 8023464:	e53f      	b.n	8022ee6 <XMC_USBD_IRQHandler+0x4e>
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_SUSPEND);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_SUSPEND);
  }
  if (data.b.wkupintr)
  {
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_REMOTE_WAKEUP);
 8023466:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
 802346a:	2008      	movs	r0, #8
 802346c:	4798      	blx	r3
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 802346e:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
	  break;
    case (XMC_USBD_EVENT_RESUME):
	  clear.b.wkupintr = 1U;
	  break;
    case (XMC_USBD_EVENT_REMOTE_WAKEUP):
	  clear.b.wkupintr = 1U;
 8023472:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8023476:	615a      	str	r2, [r3, #20]
 8023478:	e532      	b.n	8022ee0 <XMC_USBD_IRQHandler+0x48>
  {
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_EARLYSUSPEND);
  }
  if (data.b.usbsuspend)
  {
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_SUSPEND);
 802347a:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
 802347e:	2006      	movs	r0, #6
 8023480:	4798      	blx	r3
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8023482:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
	  break;
    case (XMC_USBD_EVENT_RESET):
	  clear.b.usbreset = 1U;
	  break;
    case (XMC_USBD_EVENT_SUSPEND):
	  clear.b.usbsuspend = 1U;
 8023486:	f44f 6200 	mov.w	r2, #2048	; 0x800
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 802348a:	615a      	str	r2, [r3, #20]
 802348c:	e523      	b.n	8022ed6 <XMC_USBD_IRQHandler+0x3e>
  gintmsk.d32 = xmc_device.global_register->gintmsk;
  data.d32 = xmc_device.global_register->gintsts & gintmsk.d32;
	
  if (data.b.sofintr)
  {
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_SOF);
 802348e:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
 8023492:	2009      	movs	r0, #9
 8023494:	4798      	blx	r3
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8023496:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
	  break;
    case (XMC_USBD_EVENT_REMOTE_WAKEUP):
	  clear.b.wkupintr = 1U;
	  break;
    case (XMC_USBD_EVENT_SOF):
	  clear.b.sofintr = 1U;
 802349a:	2208      	movs	r2, #8
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 802349c:	615a      	str	r2, [r3, #20]
  if (data.b.sofintr)
  {
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_SOF);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_SOF);
  }
  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 802349e:	9a01      	ldr	r2, [sp, #4]
 80234a0:	7b52      	ldrb	r2, [r2, #13]
 80234a2:	2a01      	cmp	r2, #1
 80234a4:	f47f ad0d 	bne.w	8022ec2 <XMC_USBD_IRQHandler+0x2a>
  {
    if (data.b.rxstsqlvl)
 80234a8:	06f1      	lsls	r1, r6, #27
 80234aa:	f57f ad0a 	bpl.w	8022ec2 <XMC_USBD_IRQHandler+0x2a>
    {
      /* Masked that interrupt so its only done once */
      gintmsk.b.rxstsqlvl = 0U;
 80234ae:	f36f 1504 	bfc	r5, #4, #1
      xmc_device.global_register->gintmsk = gintmsk.d32;
 80234b2:	619d      	str	r5, [r3, #24]
 * This function handles the interrupt, when the rx fifo is not empty anymore.
 */
static void XMC_USBD_lHandleRxFLvl(void) 
{
  device_grxsts_data_t data;	
  data.d32 = xmc_device.global_register->grxstsp;
 80234b4:	6a1a      	ldr	r2, [r3, #32]

  switch (data.b.pktsts)
 80234b6:	f3c2 4143 	ubfx	r1, r2, #17, #4
 80234ba:	2902      	cmp	r1, #2
 80234bc:	f000 80ff 	beq.w	80236be <XMC_USBD_IRQHandler+0x826>
 80234c0:	2906      	cmp	r1, #6
 80234c2:	d149      	bne.n	8023558 <XMC_USBD_IRQHandler+0x6c0>
      break;
    case XMC_USBD_GRXSTS_PKTSTS_OUTDATA:
      XMC_USBD_lReadFifo((uint32_t)data.b.epnum,(uint32_t)data.b.bcnt);
      break;
    case XMC_USBD_GRXSTS_PKTSTS_SETUP:
      XMC_USBD_lReadFifo((uint32_t)data.b.epnum,(uint32_t)data.b.bcnt);
 80234c4:	f002 070f 	and.w	r7, r2, #15
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
  uint32_t i;
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
 80234c8:	eb04 0187 	add.w	r1, r4, r7, lsl #2
      break;
    case XMC_USBD_GRXSTS_PKTSTS_OUTDATA:
      XMC_USBD_lReadFifo((uint32_t)data.b.epnum,(uint32_t)data.b.bcnt);
      break;
    case XMC_USBD_GRXSTS_PKTSTS_SETUP:
      XMC_USBD_lReadFifo((uint32_t)data.b.epnum,(uint32_t)data.b.bcnt);
 80234cc:	f3c2 120a 	ubfx	r2, r2, #4, #11
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
  uint32_t i;
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
 80234d0:	f8d1 11c4 	ldr.w	r1, [r1, #452]	; 0x1c4
{
  XMC_USBD_EP_t * ep = &xmc_device.ep[ep_num];
  uint32_t word_count;
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
 80234d4:	4825      	ldr	r0, [pc, #148]	; (802356c <XMC_USBD_IRQHandler+0x6d4>)
  uint32_t i;
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
 80234d6:	6809      	ldr	r1, [r1, #0]
{
  XMC_USBD_EP_t * ep = &xmc_device.ep[ep_num];
  uint32_t word_count;
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
 80234d8:	f8d4 81e0 	ldr.w	r8, [r4, #480]	; 0x1e0
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
  word_count = (byte_count >> 2U );
  temp_word_count = (word_count << 2U);
  /* Check if ep is enabled and has buffer */
  if (!data.b.usbactep)
 80234dc:	040e      	lsls	r6, r1, #16
 80234de:	d53b      	bpl.n	8023558 <XMC_USBD_IRQHandler+0x6c0>
  {
    /*Do Nothing*/
  }
  else if (ep->xferBuffer == NULL)
 80234e0:	2134      	movs	r1, #52	; 0x34
 80234e2:	fb01 0e07 	mla	lr, r1, r7, r0
 80234e6:	f8de 0024 	ldr.w	r0, [lr, #36]	; 0x24
 80234ea:	b3a8      	cbz	r0, 8023558 <XMC_USBD_IRQHandler+0x6c0>
	/*Do Nothing*/
  }
  else
  {
    /* store the data */
    for (i = 0U;i < word_count; i++)
 80234ec:	ea5f 0c92 	movs.w	ip, r2, lsr #2
 80234f0:	d00b      	beq.n	802350a <XMC_USBD_IRQHandler+0x672>
 80234f2:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 80234f6:	2100      	movs	r1, #0
 80234f8:	e001      	b.n	80234fe <XMC_USBD_IRQHandler+0x666>
 80234fa:	f8de 0024 	ldr.w	r0, [lr, #36]	; 0x24
    {
      *(((uint32_t*)ep->xferBuffer)+i) = *fifo;
 80234fe:	f8d8 6000 	ldr.w	r6, [r8]
 8023502:	5046      	str	r6, [r0, r1]
 8023504:	3104      	adds	r1, #4
	/*Do Nothing*/
  }
  else
  {
    /* store the data */
    for (i = 0U;i < word_count; i++)
 8023506:	4561      	cmp	r1, ip
 8023508:	d1f7      	bne.n	80234fa <XMC_USBD_IRQHandler+0x662>
    {
      *(((uint32_t*)ep->xferBuffer)+i) = *fifo;
    }
    /* space is not devidable by 4 */
    if (byte_count!=temp_word_count)
 802350a:	4562      	cmp	r2, ip
 802350c:	d01b      	beq.n	8023546 <XMC_USBD_IRQHandler+0x6ae>
    {
      temp_data = *fifo;
 802350e:	f8d8 8000 	ldr.w	r8, [r8]
      for (i = 0U;(temp_word_count + i) < byte_count;i++)
 8023512:	d918      	bls.n	8023546 <XMC_USBD_IRQHandler+0x6ae>
      {
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
 8023514:	f04f 0e34 	mov.w	lr, #52	; 0x34
    }
    /* space is not devidable by 4 */
    if (byte_count!=temp_word_count)
    {
      temp_data = *fifo;
      for (i = 0U;(temp_word_count + i) < byte_count;i++)
 8023518:	4663      	mov	r3, ip
      {
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
 802351a:	fb0e 4e07 	mla	lr, lr, r7, r4
    }
    /* space is not devidable by 4 */
    if (byte_count!=temp_word_count)
    {
      temp_data = *fifo;
      for (i = 0U;(temp_word_count + i) < byte_count;i++)
 802351e:	2600      	movs	r6, #0
      {
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
 8023520:	f04f 09ff 	mov.w	r9, #255	; 0xff
 8023524:	fa09 f106 	lsl.w	r1, r9, r6
 8023528:	ea01 0108 	and.w	r1, r1, r8
 802352c:	f8de 0024 	ldr.w	r0, [lr, #36]	; 0x24
 8023530:	f8df c038 	ldr.w	ip, [pc, #56]	; 802356c <XMC_USBD_IRQHandler+0x6d4>
 8023534:	40f1      	lsrs	r1, r6
 8023536:	54c1      	strb	r1, [r0, r3]
    }
    /* space is not devidable by 4 */
    if (byte_count!=temp_word_count)
    {
      temp_data = *fifo;
      for (i = 0U;(temp_word_count + i) < byte_count;i++)
 8023538:	3301      	adds	r3, #1
 802353a:	429a      	cmp	r2, r3
 802353c:	f106 0608 	add.w	r6, r6, #8
 8023540:	d1f0      	bne.n	8023524 <XMC_USBD_IRQHandler+0x68c>
 8023542:	f8dc 31a0 	ldr.w	r3, [ip, #416]	; 0x1a0
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
      }
    }

    /* save the amount of data */
    ep->xferCount += byte_count;
 8023546:	2634      	movs	r6, #52	; 0x34
 8023548:	fb06 4607 	mla	r6, r6, r7, r4
 802354c:	6af1      	ldr	r1, [r6, #44]	; 0x2c
    ep->xferBuffer += byte_count;
 802354e:	6a70      	ldr	r0, [r6, #36]	; 0x24
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
      }
    }

    /* save the amount of data */
    ep->xferCount += byte_count;
 8023550:	4411      	add	r1, r2
    ep->xferBuffer += byte_count;
 8023552:	4402      	add	r2, r0
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
      }
    }

    /* save the amount of data */
    ep->xferCount += byte_count;
 8023554:	62f1      	str	r1, [r6, #44]	; 0x2c
    ep->xferBuffer += byte_count;
 8023556:	6272      	str	r2, [r6, #36]	; 0x24
    {
      /* Masked that interrupt so its only done once */
      gintmsk.b.rxstsqlvl = 0U;
      xmc_device.global_register->gintmsk = gintmsk.d32;
      XMC_USBD_lHandleRxFLvl(); /* handle the interrupt */
      gintmsk.b.rxstsqlvl = 1U;
 8023558:	f045 0510 	orr.w	r5, r5, #16
      xmc_device.global_register->gintmsk = gintmsk.d32;
 802355c:	619d      	str	r5, [r3, #24]
 802355e:	e4b0      	b.n	8022ec2 <XMC_USBD_IRQHandler+0x2a>
 8023560:	2000d358 	.word	0x2000d358
 8023564:	00100090 	.word	0x00100090
 8023568:	001000a0 	.word	0x001000a0
 802356c:	2000d35c 	.word	0x2000d35c
 8023570:	00100050 	.word	0x00100050
 8023574:	00100060 	.word	0x00100060
 8023578:	00100070 	.word	0x00100070
 802357c:	00100080 	.word	0x00100080
    ep0_data->b.xfersize = (uint8_t)ep->xferTotal;
  }
  else
  {
    /* If requested length is zero, just receive one zero length packet */
    if (ep->xferLength == 0U)
 8023580:	b9a9      	cbnz	r1, 80235ae <XMC_USBD_IRQHandler+0x716>
    {
      data.b.xfersize = 0U;
 8023582:	f361 0312 	bfi	r3, r1, #0, #19
      data.b.pktcnt = 1U;
 8023586:	2201      	movs	r2, #1
 8023588:	f362 43dc 	bfi	r3, r2, #19, #10
 802358c:	e551      	b.n	8023032 <XMC_USBD_IRQHandler+0x19a>
 802358e:	5da2      	ldrb	r2, [r4, r6]
 8023590:	f002 020f 	and.w	r2, r2, #15
 8023594:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 8023598:	f8d2 11c4 	ldr.w	r1, [r2, #452]	; 0x1c4
 802359c:	e55b      	b.n	8023056 <XMC_USBD_IRQHandler+0x1be>
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* update xfer values */
          if ((dieptsiz.b.pktcnt == 0U) && (dieptsiz.b.xfersize == 0U))
          {
            uint32_t Bytes = ep->xferLength - ep->xferCount;
 802359e:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 80235a0:	6a81      	ldr	r1, [r0, #40]	; 0x28
            ep->xferCount += Bytes;
            ep->xferBuffer += Bytes;
 80235a2:	6a43      	ldr	r3, [r0, #36]	; 0x24
        {
          /* update xfer values */
          if ((dieptsiz.b.pktcnt == 0U) && (dieptsiz.b.xfersize == 0U))
          {
            uint32_t Bytes = ep->xferLength - ep->xferCount;
            ep->xferCount += Bytes;
 80235a4:	62c1      	str	r1, [r0, #44]	; 0x2c
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* update xfer values */
          if ((dieptsiz.b.pktcnt == 0U) && (dieptsiz.b.xfersize == 0U))
          {
            uint32_t Bytes = ep->xferLength - ep->xferCount;
 80235a6:	1a8a      	subs	r2, r1, r2
            ep->xferCount += Bytes;
            ep->xferBuffer += Bytes;
 80235a8:	441a      	add	r2, r3
 80235aa:	6242      	str	r2, [r0, #36]	; 0x24
 80235ac:	e5e0      	b.n	8023170 <XMC_USBD_IRQHandler+0x2d8>
      data.b.pktcnt = 1U;
    }
    else
    {
      /* setup endpoint to recive a amount of packages by given size */
      data.b.pktcnt = (uint16_t)(((ep->xferLength - ep->xferCount) + (ep->maxPacketSize -(uint32_t)1U))/ep->maxPacketSize);
 80235ae:	6842      	ldr	r2, [r0, #4]
 80235b0:	f8da 0004 	ldr.w	r0, [sl, #4]
 80235b4:	f3c2 22c6 	ubfx	r2, r2, #11, #7
 80235b8:	1a09      	subs	r1, r1, r0
 80235ba:	f102 3eff 	add.w	lr, r2, #4294967295
 80235be:	448e      	add	lr, r1
 80235c0:	fbbe f2f2 	udiv	r2, lr, r2
 80235c4:	f362 43dc 	bfi	r3, r2, #19, #10
      data.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
 80235c8:	f361 0312 	bfi	r3, r1, #0, #19
 80235cc:	e531      	b.n	8023032 <XMC_USBD_IRQHandler+0x19a>
  {
    if (ep->address_u.address_st.number == 0U)
    {
      size.b.pktcnt = 1U;
      /* ep->maxXferSize equals maxPacketSize */
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
 80235ce:	f8d8 1004 	ldr.w	r1, [r8, #4]
 80235d2:	1a5b      	subs	r3, r3, r1
 80235d4:	f3c3 0312 	ubfx	r3, r3, #0, #19
  }
  else
  {
    if (ep->address_u.address_st.number == 0U)
    {
      size.b.pktcnt = 1U;
 80235d8:	f04f 0c01 	mov.w	ip, #1
 80235dc:	e63b      	b.n	8023256 <XMC_USBD_IRQHandler+0x3be>
  {
    ep->xferLength += ep->maxTransferSize;
  }
  if (ep->xferLength == 0U)
  {
    size.b.xfersize = 0U;
 80235de:	f363 0012 	bfi	r0, r3, #0, #19
    size.b.pktcnt = 1U;
 80235e2:	2301      	movs	r3, #1
 80235e4:	f363 40dc 	bfi	r0, r3, #19, #10
 80235e8:	e644      	b.n	8023274 <XMC_USBD_IRQHandler+0x3dc>
  volatile uint32_t *fifo;
  uint32_t byte_count;
  uint32_t word_count;
  uint32_t result;
  uint32_t i;
  fifo = xmc_device.fifo[ep->address_u.address_st.number]; /* fifo */
 80235ea:	f008 080f 	and.w	r8, r8, #15
  freeSpace.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dtxfsts;
 80235ee:	f108 016a 	add.w	r1, r8, #106	; 0x6a
 80235f2:	4f5e      	ldr	r7, [pc, #376]	; (802376c <XMC_USBD_IRQHandler+0x8d4>)
 80235f4:	f857 1021 	ldr.w	r1, [r7, r1, lsl #2]
  /* calculate the length and the amount of dwords to copy based on the fifo status */
  byte_count = ep->xferLength - ep->xferCount;
 80235f8:	6ac7      	ldr	r7, [r0, #44]	; 0x2c
  uint32_t byte_count;
  uint32_t word_count;
  uint32_t result;
  uint32_t i;
  fifo = xmc_device.fifo[ep->address_u.address_st.number]; /* fifo */
  freeSpace.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dtxfsts;
 80235fa:	f8d1 c018 	ldr.w	ip, [r1, #24]
  volatile uint32_t *fifo;
  uint32_t byte_count;
  uint32_t word_count;
  uint32_t result;
  uint32_t i;
  fifo = xmc_device.fifo[ep->address_u.address_st.number]; /* fifo */
 80235fe:	495b      	ldr	r1, [pc, #364]	; (802376c <XMC_USBD_IRQHandler+0x8d4>)
  freeSpace.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dtxfsts;
  /* calculate the length and the amount of dwords to copy based on the fifo status */
  byte_count = ep->xferLength - ep->xferCount;
 8023600:	9706      	str	r7, [sp, #24]
  volatile uint32_t *fifo;
  uint32_t byte_count;
  uint32_t word_count;
  uint32_t result;
  uint32_t i;
  fifo = xmc_device.fifo[ep->address_u.address_st.number]; /* fifo */
 8023602:	f108 0878 	add.w	r8, r8, #120	; 0x78
 8023606:	f851 1028 	ldr.w	r1, [r1, r8, lsl #2]
 802360a:	9107      	str	r1, [sp, #28]
  freeSpace.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dtxfsts;
  /* calculate the length and the amount of dwords to copy based on the fifo status */
  byte_count = ep->xferLength - ep->xferCount;
  if (!byte_count)
 802360c:	6a81      	ldr	r1, [r0, #40]	; 0x28
 802360e:	1bc9      	subs	r1, r1, r7
 8023610:	9105      	str	r1, [sp, #20]
 8023612:	d051      	beq.n	80236b8 <XMC_USBD_IRQHandler+0x820>
    result = 0U;
  }
  else
  {
    /* add the unaligned bytes to the word count to compare with the fifo space */
    word_count = ((uint32_t)byte_count + 3U) >> 2U;
 8023614:	f101 0803 	add.w	r8, r1, #3
    if (word_count > (uint32_t)freeSpace.b.txfspcavail )
 8023618:	fa1f fc8c 	uxth.w	ip, ip
    result = 0U;
  }
  else
  {
    /* add the unaligned bytes to the word count to compare with the fifo space */
    word_count = ((uint32_t)byte_count + 3U) >> 2U;
 802361c:	ea4f 0898 	mov.w	r8, r8, lsr #2
    if (word_count > (uint32_t)freeSpace.b.txfspcavail )
 8023620:	45e0      	cmp	r8, ip
 8023622:	d844      	bhi.n	80236ae <XMC_USBD_IRQHandler+0x816>
 8023624:	fb0b 410e 	mla	r1, fp, lr, r4
      word_count = (uint32_t)freeSpace.b.txfspcavail;
      byte_count = (uint32_t)word_count << (uint32_t)2U;
    }

    /* copy data dword wise */
    for (i = 0U; i < word_count;ep->xferBuffer+= 4U)
 8023628:	f1b8 0f00 	cmp.w	r8, #0
 802362c:	f000 809b 	beq.w	8023766 <XMC_USBD_IRQHandler+0x8ce>
 8023630:	9106      	str	r1, [sp, #24]
 8023632:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
 8023636:	6a49      	ldr	r1, [r1, #36]	; 0x24
 8023638:	f8dd c01c 	ldr.w	ip, [sp, #28]
 802363c:	9f02      	ldr	r7, [sp, #8]
 802363e:	f8dd 9018 	ldr.w	r9, [sp, #24]
 8023642:	f8cd e020 	str.w	lr, [sp, #32]
 8023646:	2000      	movs	r0, #0
    {
      *fifo = *(uint32_t*)ep->xferBuffer;
 8023648:	6809      	ldr	r1, [r1, #0]
 802364a:	f8cc 1000 	str.w	r1, [ip]
      word_count = (uint32_t)freeSpace.b.txfspcavail;
      byte_count = (uint32_t)word_count << (uint32_t)2U;
    }

    /* copy data dword wise */
    for (i = 0U; i < word_count;ep->xferBuffer+= 4U)
 802364e:	f8d9 1024 	ldr.w	r1, [r9, #36]	; 0x24
    {
      *fifo = *(uint32_t*)ep->xferBuffer;
      i++;
 8023652:	3001      	adds	r0, #1
      word_count = (uint32_t)freeSpace.b.txfspcavail;
      byte_count = (uint32_t)word_count << (uint32_t)2U;
    }

    /* copy data dword wise */
    for (i = 0U; i < word_count;ep->xferBuffer+= 4U)
 8023654:	3104      	adds	r1, #4
 8023656:	4540      	cmp	r0, r8
 8023658:	f8c9 1024 	str.w	r1, [r9, #36]	; 0x24
 802365c:	d1f4      	bne.n	8023648 <XMC_USBD_IRQHandler+0x7b0>
 802365e:	9806      	ldr	r0, [sp, #24]
 8023660:	f8dd e020 	ldr.w	lr, [sp, #32]
 8023664:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8023666:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
 802366a:	9702      	str	r7, [sp, #8]
 802366c:	9006      	str	r0, [sp, #24]
 802366e:	4607      	mov	r7, r0
      {
        if (diepint.b.emptyintr)
        {
          uint32_t bytes;
          bytes = XMC_USBD_lWriteFifo(ep);
          ep->xferCount += bytes;
 8023670:	46bc      	mov	ip, r7
 8023672:	9f05      	ldr	r7, [sp, #20]
 8023674:	fb0b 400e 	mla	r0, fp, lr, r4
 8023678:	44bc      	add	ip, r7
          ep->xferBuffer += bytes;
 802367a:	4439      	add	r1, r7
      {
        if (diepint.b.emptyintr)
        {
          uint32_t bytes;
          bytes = XMC_USBD_lWriteFifo(ep);
          ep->xferCount += bytes;
 802367c:	f8c0 c02c 	str.w	ip, [r0, #44]	; 0x2c
          ep->xferBuffer += bytes;
 8023680:	6241      	str	r1, [r0, #36]	; 0x24
 8023682:	e588      	b.n	8023196 <XMC_USBD_IRQHandler+0x2fe>
    if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
    {
      /* Program dma*/
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepdma = (uint32_t)ep->xferBuffer;
    }
    if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8023684:	2901      	cmp	r1, #1
 8023686:	f47f adf5 	bne.w	8023274 <XMC_USBD_IRQHandler+0x3dc>
    {
      /* enable fifo empty interrupt */
			xmc_device.device_register->dtknqr4_fifoemptymsk |= (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
 802368a:	9f06      	ldr	r7, [sp, #24]
 802368c:	f8da 3034 	ldr.w	r3, [sl, #52]	; 0x34
 8023690:	40b9      	lsls	r1, r7
 8023692:	4319      	orrs	r1, r3
 8023694:	f8ca 1034 	str.w	r1, [sl, #52]	; 0x34
 8023698:	e5ec      	b.n	8023274 <XMC_USBD_IRQHandler+0x3dc>
          ep->inInUse = 0U;
          if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
          {
            /* mask fifo empty interrupt */
            xmc_device.device_register->dtknqr4_fifoemptymsk =
            (uint32_t)(xmc_device.device_register->dtknqr4_fifoemptymsk & ~(((uint32_t)1U << ep_num)));
 802369a:	4b34      	ldr	r3, [pc, #208]	; (802376c <XMC_USBD_IRQHandler+0x8d4>)
 802369c:	f8d3 11a4 	ldr.w	r1, [r3, #420]	; 0x1a4
 80236a0:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 80236a2:	fa02 f20e 	lsl.w	r2, r2, lr
 80236a6:	ea23 0202 	bic.w	r2, r3, r2
        {
          ep->inInUse = 0U;
          if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
          {
            /* mask fifo empty interrupt */
            xmc_device.device_register->dtknqr4_fifoemptymsk =
 80236aa:	634a      	str	r2, [r1, #52]	; 0x34
 80236ac:	e582      	b.n	80231b4 <XMC_USBD_IRQHandler+0x31c>
    /* add the unaligned bytes to the word count to compare with the fifo space */
    word_count = ((uint32_t)byte_count + 3U) >> 2U;
    if (word_count > (uint32_t)freeSpace.b.txfspcavail )
    {
      word_count = (uint32_t)freeSpace.b.txfspcavail;
      byte_count = (uint32_t)word_count << (uint32_t)2U;
 80236ae:	ea4f 018c 	mov.w	r1, ip, lsl #2
 80236b2:	9105      	str	r1, [sp, #20]
 80236b4:	46e0      	mov	r8, ip
 80236b6:	e7b5      	b.n	8023624 <XMC_USBD_IRQHandler+0x78c>
 80236b8:	6a41      	ldr	r1, [r0, #36]	; 0x24
 80236ba:	9f06      	ldr	r7, [sp, #24]
 80236bc:	e7d8      	b.n	8023670 <XMC_USBD_IRQHandler+0x7d8>
    case XMC_USBD_GRXSTS_PKTSTS_GOUTNAK:
      break;
    case XMC_USBD_GRXSTS_PKTSTS_OUTCMPL:
      break;
    case XMC_USBD_GRXSTS_PKTSTS_OUTDATA:
      XMC_USBD_lReadFifo((uint32_t)data.b.epnum,(uint32_t)data.b.bcnt);
 80236be:	f002 070f 	and.w	r7, r2, #15
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
  uint32_t i;
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
 80236c2:	eb04 0187 	add.w	r1, r4, r7, lsl #2
    case XMC_USBD_GRXSTS_PKTSTS_GOUTNAK:
      break;
    case XMC_USBD_GRXSTS_PKTSTS_OUTCMPL:
      break;
    case XMC_USBD_GRXSTS_PKTSTS_OUTDATA:
      XMC_USBD_lReadFifo((uint32_t)data.b.epnum,(uint32_t)data.b.bcnt);
 80236c6:	f3c2 100a 	ubfx	r0, r2, #4, #11
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
  uint32_t i;
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
 80236ca:	f8d1 21c4 	ldr.w	r2, [r1, #452]	; 0x1c4
{
  XMC_USBD_EP_t * ep = &xmc_device.ep[ep_num];
  uint32_t word_count;
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
 80236ce:	f8d4 c1e0 	ldr.w	ip, [r4, #480]	; 0x1e0
  uint32_t i;
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
 80236d2:	6812      	ldr	r2, [r2, #0]
{
  XMC_USBD_EP_t * ep = &xmc_device.ep[ep_num];
  uint32_t word_count;
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
 80236d4:	4925      	ldr	r1, [pc, #148]	; (802376c <XMC_USBD_IRQHandler+0x8d4>)
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
  word_count = (byte_count >> 2U );
  temp_word_count = (word_count << 2U);
  /* Check if ep is enabled and has buffer */
  if (!data.b.usbactep)
 80236d6:	0412      	lsls	r2, r2, #16
 80236d8:	f57f af3e 	bpl.w	8023558 <XMC_USBD_IRQHandler+0x6c0>
  {
    /*Do Nothing*/
  }
  else if (ep->xferBuffer == NULL)
 80236dc:	2234      	movs	r2, #52	; 0x34
 80236de:	fb02 1e07 	mla	lr, r2, r7, r1
 80236e2:	f8de 1024 	ldr.w	r1, [lr, #36]	; 0x24
 80236e6:	2900      	cmp	r1, #0
 80236e8:	f43f af36 	beq.w	8023558 <XMC_USBD_IRQHandler+0x6c0>
	/*Do Nothing*/
  }
  else
  {
    /* store the data */
    for (i = 0U;i < word_count; i++)
 80236ec:	ea5f 0890 	movs.w	r8, r0, lsr #2
 80236f0:	d00f      	beq.n	8023712 <XMC_USBD_IRQHandler+0x87a>
 80236f2:	ea4f 0888 	mov.w	r8, r8, lsl #2
 80236f6:	2200      	movs	r2, #0
 80236f8:	e001      	b.n	80236fe <XMC_USBD_IRQHandler+0x866>
 80236fa:	f8de 1024 	ldr.w	r1, [lr, #36]	; 0x24
    {
      *(((uint32_t*)ep->xferBuffer)+i) = *fifo;
 80236fe:	f8dc 6000 	ldr.w	r6, [ip]
 8023702:	508e      	str	r6, [r1, r2]
 8023704:	3204      	adds	r2, #4
	/*Do Nothing*/
  }
  else
  {
    /* store the data */
    for (i = 0U;i < word_count; i++)
 8023706:	4542      	cmp	r2, r8
 8023708:	d1f7      	bne.n	80236fa <XMC_USBD_IRQHandler+0x862>
 802370a:	2234      	movs	r2, #52	; 0x34
 802370c:	fb02 4207 	mla	r2, r2, r7, r4
 8023710:	6a51      	ldr	r1, [r2, #36]	; 0x24
    {
      *(((uint32_t*)ep->xferBuffer)+i) = *fifo;
    }
    /* space is not devidable by 4 */
    if (byte_count!=temp_word_count)
 8023712:	4540      	cmp	r0, r8
 8023714:	d01e      	beq.n	8023754 <XMC_USBD_IRQHandler+0x8bc>
    {
      temp_data = *fifo;
 8023716:	f8dc c000 	ldr.w	ip, [ip]
      for (i = 0U;(temp_word_count + i) < byte_count;i++)
 802371a:	d91b      	bls.n	8023754 <XMC_USBD_IRQHandler+0x8bc>
 802371c:	f04f 0e34 	mov.w	lr, #52	; 0x34
 8023720:	4643      	mov	r3, r8
 8023722:	fb0e 4e07 	mla	lr, lr, r7, r4
 8023726:	2600      	movs	r6, #0
      {
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
 8023728:	f04f 08ff 	mov.w	r8, #255	; 0xff
 802372c:	e001      	b.n	8023732 <XMC_USBD_IRQHandler+0x89a>
 802372e:	f8de 1024 	ldr.w	r1, [lr, #36]	; 0x24
 8023732:	fa08 f206 	lsl.w	r2, r8, r6
 8023736:	ea02 020c 	and.w	r2, r2, ip
 802373a:	40f2      	lsrs	r2, r6
 802373c:	54ca      	strb	r2, [r1, r3]
    }
    /* space is not devidable by 4 */
    if (byte_count!=temp_word_count)
    {
      temp_data = *fifo;
      for (i = 0U;(temp_word_count + i) < byte_count;i++)
 802373e:	3301      	adds	r3, #1
 8023740:	4298      	cmp	r0, r3
 8023742:	f106 0608 	add.w	r6, r6, #8
 8023746:	d1f2      	bne.n	802372e <XMC_USBD_IRQHandler+0x896>
 8023748:	2234      	movs	r2, #52	; 0x34
 802374a:	fb02 4207 	mla	r2, r2, r7, r4
 802374e:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
 8023752:	6a51      	ldr	r1, [r2, #36]	; 0x24
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
      }
    }

    /* save the amount of data */
    ep->xferCount += byte_count;
 8023754:	2234      	movs	r2, #52	; 0x34
 8023756:	fb02 4707 	mla	r7, r2, r7, r4
    ep->xferBuffer += byte_count;
 802375a:	4401      	add	r1, r0
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
      }
    }

    /* save the amount of data */
    ep->xferCount += byte_count;
 802375c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    ep->xferBuffer += byte_count;
 802375e:	6279      	str	r1, [r7, #36]	; 0x24
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
      }
    }

    /* save the amount of data */
    ep->xferCount += byte_count;
 8023760:	4402      	add	r2, r0
 8023762:	62fa      	str	r2, [r7, #44]	; 0x2c
 8023764:	e6f8      	b.n	8023558 <XMC_USBD_IRQHandler+0x6c0>
 8023766:	6a49      	ldr	r1, [r1, #36]	; 0x24
 8023768:	9f06      	ldr	r7, [sp, #24]
 802376a:	e781      	b.n	8023670 <XMC_USBD_IRQHandler+0x7d8>
 802376c:	2000d35c 	.word	0x2000d35c

08023770 <XMC_USBD_Disable>:

/**
 * Disables the USB0 module
 **/
void XMC_USBD_Disable(void) 
{
 8023770:	b510      	push	{r4, lr}
  /* Clear Reset and power up */
  XMC_SCU_RESET_AssertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_USB0);
 8023772:	4c05      	ldr	r4, [pc, #20]	; (8023788 <XMC_USBD_Disable+0x18>)
 8023774:	4620      	mov	r0, r4
 8023776:	f7fd ffb7 	bl	80216e8 <XMC_SCU_RESET_AssertPeripheralReset>
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_SCU_CLOCK_GatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USB0);
 802377a:	4620      	mov	r0, r4
 802377c:	f7fe f824 	bl	80217c8 <XMC_SCU_CLOCK_GatePeripheralClock>
#endif
  XMC_SCU_POWER_DisableUsb();
}
 8023780:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  /* Clear Reset and power up */
  XMC_SCU_RESET_AssertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_USB0);
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_SCU_CLOCK_GatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USB0);
#endif
  XMC_SCU_POWER_DisableUsb();
 8023784:	f7fe b872 	b.w	802186c <XMC_SCU_POWER_DisableUsb>
 8023788:	20000080 	.word	0x20000080

0802378c <XMC_VADC_GLOBAL_Init>:
}


/* API to initialize global resources */
void XMC_VADC_GLOBAL_Init(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_GLOBAL_CONFIG_t *config)
{
 802378c:	b538      	push	{r3, r4, r5, lr}
 802378e:	460d      	mov	r5, r1
 8023790:	4604      	mov	r4, r0
#if defined (COMPARATOR)
  COMPARATOR->ORCCTRL = (uint32_t)0xFF;
#endif

#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_VADC);
 8023792:	2001      	movs	r0, #1
 8023794:	f7fe f824 	bl	80217e0 <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif

#if defined(PERIPHERAL_RESET_SUPPORTED)
  /* Reset the Hardware */
  XMC_SCU_RESET_DeassertPeripheralReset((XMC_SCU_PERIPHERAL_RESET_t)XMC_SCU_PERIPHERAL_RESET_VADC );
 8023798:	2001      	movs	r0, #1
 802379a:	f7fd ffb1 	bl	8021700 <XMC_SCU_RESET_DeassertPeripheralReset>
  XMC_ASSERT("XMC_VADC_GLOBAL_Init:Wrong Module Pointer", (global_ptr == VADC))

  /* Enable the VADC module*/
  XMC_VADC_GLOBAL_EnableModule();

  global_ptr->CLC = (uint32_t)(config->clc);
 802379e:	696b      	ldr	r3, [r5, #20]
 80237a0:	6023      	str	r3, [r4, #0]

  /* Clock configuration */

#if (XMC_VADC_GROUP_AVAILABLE == 1U)
  global_ptr->GLOBCFG  = (uint32_t)(config->clock_config.globcfg | (uint32_t)(VADC_GLOBCFG_DIVWC_Msk));
 80237a2:	686b      	ldr	r3, [r5, #4]
 80237a4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80237a8:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
#endif

  /* ICLASS-0 configuration */
  global_ptr->GLOBICLASS[0] = (uint32_t)(config->class0.globiclass);
 80237ac:	68ab      	ldr	r3, [r5, #8]
 80237ae:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0

  /* ICLASS-1 configuration */
  global_ptr->GLOBICLASS[1] = (uint32_t)(config->class1.globiclass);
 80237b2:	68eb      	ldr	r3, [r5, #12]
 80237b4:	f8c4 30a4 	str.w	r3, [r4, #164]	; 0xa4


  /*Result generation related configuration */
  global_ptr->GLOBRCR = (uint32_t)(config->globrcr);
 80237b8:	692b      	ldr	r3, [r5, #16]
 80237ba:	f8c4 3280 	str.w	r3, [r4, #640]	; 0x280

#if (XMC_VADC_BOUNDARY_AVAILABLE == 1U)

  /* Boundaries */
  global_ptr->GLOBBOUND = (uint32_t)(config->globbound);
 80237be:	682b      	ldr	r3, [r5, #0]
 80237c0:	f8c4 30b8 	str.w	r3, [r4, #184]	; 0xb8
 80237c4:	bd38      	pop	{r3, r4, r5, pc}
 80237c6:	bf00      	nop

080237c8 <XMC_VADC_GLOBAL_InputClassInit>:
  XMC_ASSERT("XMC_VADC_GLOBAL_InputClassInit:Wrong Module Pointer", (global_ptr == VADC))
  XMC_ASSERT("XMC_VADC_GLOBAL_InputClassInit:Wrong Conversion Type", ((conv_type) <= XMC_VADC_GROUP_CONV_EMUX))
  XMC_ASSERT("XMC_VADC_GLOBAL_InputClassInit:Wrong ICLASS set number", (set_num < XMC_VADC_MAX_ICLASS_SET))

#if(XMC_VADC_EMUX_AVAILABLE == 1U)
  if (conv_type == XMC_VADC_GROUP_CONV_STD )
 80237c8:	b12a      	cbz	r2, 80237d6 <XMC_VADC_GLOBAL_InputClassInit+0xe>
                                      (uint32_t)(VADC_GLOBICLASS_CMS_Msk | VADC_GLOBICLASS_STCS_Msk);
#if(XMC_VADC_EMUX_AVAILABLE == 1U)
  }
  else
  {
    global_ptr->GLOBICLASS[set_num] = config.globiclass & (uint32_t)(VADC_GLOBICLASS_CME_Msk | VADC_GLOBICLASS_STCE_Msk);
 80237ca:	4a06      	ldr	r2, [pc, #24]	; (80237e4 <XMC_VADC_GLOBAL_InputClassInit+0x1c>)
 80237cc:	3328      	adds	r3, #40	; 0x28
 80237ce:	400a      	ands	r2, r1
 80237d0:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
 80237d4:	4770      	bx	lr

#if(XMC_VADC_EMUX_AVAILABLE == 1U)
  if (conv_type == XMC_VADC_GROUP_CONV_STD )
  {
#endif
    global_ptr->GLOBICLASS[set_num] = config.globiclass &
 80237d6:	3328      	adds	r3, #40	; 0x28
 80237d8:	f240 721f 	movw	r2, #1823	; 0x71f
 80237dc:	400a      	ands	r2, r1
 80237de:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
 80237e2:	4770      	bx	lr
 80237e4:	071f0000 	.word	0x071f0000

080237e8 <XMC_VADC_GLOBAL_StartupCalibration>:
  VADC_G_TypeDef *group_ptr;
#endif
  
  XMC_ASSERT("XMC_VADC_GLOBAL_StartupCalibration:Wrong Module Pointer", (global_ptr == VADC))

  global_ptr->GLOBCFG |= (uint32_t)VADC_GLOBCFG_SUCAL_Msk;
 80237e8:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
 80237ec:	490c      	ldr	r1, [pc, #48]	; (8023820 <XMC_VADC_GLOBAL_StartupCalibration+0x38>)
 80237ee:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80237f2:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
 80237f6:	f101 0010 	add.w	r0, r1, #16

#if (XMC_VADC_GROUP_AVAILABLE == 1U)
  /* Loop until all active groups finish calibration */
  for(i=0U; i<XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
  {
    group_ptr = g_xmc_vadc_group_array[i];
 80237fa:	f851 2b04 	ldr.w	r2, [r1], #4
    if ( (group_ptr->ARBCFG) & (uint32_t)VADC_G_ARBCFG_ANONS_Msk)
 80237fe:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 8023802:	f413 3f40 	tst.w	r3, #196608	; 0x30000
 8023806:	d102      	bne.n	802380e <XMC_VADC_GLOBAL_StartupCalibration+0x26>

  global_ptr->GLOBCFG |= (uint32_t)VADC_GLOBCFG_SUCAL_Msk;

#if (XMC_VADC_GROUP_AVAILABLE == 1U)
  /* Loop until all active groups finish calibration */
  for(i=0U; i<XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 8023808:	4281      	cmp	r1, r0
 802380a:	d1f6      	bne.n	80237fa <XMC_VADC_GLOBAL_StartupCalibration+0x12>
         XMC_VADC_SHS_START_UP_CAL_ACTIVE )
  {
    /* NOP */
  }
#endif
}
 802380c:	4770      	bx	lr
  {
    group_ptr = g_xmc_vadc_group_array[i];
    if ( (group_ptr->ARBCFG) & (uint32_t)VADC_G_ARBCFG_ANONS_Msk)
    {
      /* This group is active. Loop until it finishes calibration */
      while((group_ptr->ARBCFG) & (uint32_t)VADC_G_ARBCFG_CAL_Msk)
 802380e:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 8023812:	00db      	lsls	r3, r3, #3
 8023814:	d5f8      	bpl.n	8023808 <XMC_VADC_GLOBAL_StartupCalibration+0x20>
 8023816:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 802381a:	00db      	lsls	r3, r3, #3
 802381c:	d4f7      	bmi.n	802380e <XMC_VADC_GLOBAL_StartupCalibration+0x26>
 802381e:	e7f3      	b.n	8023808 <XMC_VADC_GLOBAL_StartupCalibration+0x20>
 8023820:	08030a34 	.word	0x08030a34

08023824 <XMC_VADC_GROUP_Init>:
}

/* API to initialize an instance of group of VADC hardware */
#if (XMC_VADC_GROUP_AVAILABLE == 1U)  
void XMC_VADC_GROUP_Init( XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_GROUP_CONFIG_t *config)
{
 8023824:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023828:	794b      	ldrb	r3, [r1, #5]
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
  }

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];
 802382a:	f8d0 50a0 	ldr.w	r5, [r0, #160]	; 0xa0
 802382e:	f891 a004 	ldrb.w	sl, [r1, #4]
 8023832:	78ce      	ldrb	r6, [r1, #3]
 8023834:	7acc      	ldrb	r4, [r1, #11]
 8023836:	f891 b007 	ldrb.w	fp, [r1, #7]
 802383a:	f891 9006 	ldrb.w	r9, [r1, #6]
 802383e:	f891 8009 	ldrb.w	r8, [r1, #9]
 8023842:	7a0a      	ldrb	r2, [r1, #8]
 8023844:	f891 c00a 	ldrb.w	ip, [r1, #10]
 8023848:	f8b1 e002 	ldrh.w	lr, [r1, #2]
 802384c:	780f      	ldrb	r7, [r1, #0]

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
 802384e:	f425 65e0 	bic.w	r5, r5, #1792	; 0x700
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 8023852:	f003 0307 	and.w	r3, r3, #7
 8023856:	ea45 2303 	orr.w	r3, r5, r3, lsl #8
  conv_class &= ~(sample_time_mask);
 802385a:	f023 031f 	bic.w	r3, r3, #31
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CMS_Pos;
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CMS_Msk;
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCS_Pos;
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCS_Msk;
    sample_time      = (uint32_t) config.sample_time_std_conv;
 802385e:	f00a 0a1f 	and.w	sl, sl, #31

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
  conv_class &= ~(sample_time_mask);
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
 8023862:	ea43 050a 	orr.w	r5, r3, sl
  group_ptr->ICLASS[set_num] = conv_class;
 8023866:	f8c0 50a0 	str.w	r5, [r0, #160]	; 0xa0
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
  }

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];
 802386a:	f8d0 30a0 	ldr.w	r3, [r0, #160]	; 0xa0

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 802386e:	f00b 0b07 	and.w	fp, fp, #7

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
 8023872:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 8023876:	ea43 630b 	orr.w	r3, r3, fp, lsl #24
  conv_class &= ~(sample_time_mask);
 802387a:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CME_Pos;
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CME_Msk;
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCE_Pos;
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCE_Msk;
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
 802387e:	f009 051f 	and.w	r5, r9, #31

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
  conv_class &= ~(sample_time_mask);
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
 8023882:	ea43 4505 	orr.w	r5, r3, r5, lsl #16
  group_ptr->ICLASS[set_num] = conv_class;
 8023886:	f8c0 50a0 	str.w	r5, [r0, #160]	; 0xa0
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
  }

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];
 802388a:	f8d0 30a4 	ldr.w	r3, [r0, #164]	; 0xa4

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 802388e:	f008 0807 	and.w	r8, r8, #7

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
 8023892:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 8023896:	ea43 2308 	orr.w	r3, r3, r8, lsl #8
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CMS_Pos;
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CMS_Msk;
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCS_Pos;
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCS_Msk;
    sample_time      = (uint32_t) config.sample_time_std_conv;
 802389a:	f002 021f 	and.w	r2, r2, #31
  conv_class  = group_ptr->ICLASS[set_num];

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
  conv_class &= ~(sample_time_mask);
 802389e:	f023 031f 	bic.w	r3, r3, #31
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
 80238a2:	4313      	orrs	r3, r2
  group_ptr->ICLASS[set_num] = conv_class;
 80238a4:	f8c0 30a4 	str.w	r3, [r0, #164]	; 0xa4
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
  }

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];
 80238a8:	f8d0 50a4 	ldr.w	r5, [r0, #164]	; 0xa4

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 80238ac:	f004 0207 	and.w	r2, r4, #7

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
 80238b0:	f025 64e0 	bic.w	r4, r5, #117440512	; 0x7000000
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 80238b4:	ea44 6402 	orr.w	r4, r4, r2, lsl #24
  conv_class &= ~(sample_time_mask);
 80238b8:	f424 14f8 	bic.w	r4, r4, #2031616	; 0x1f0000
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CME_Pos;
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CME_Msk;
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCE_Pos;
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCE_Msk;
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
 80238bc:	f00c 021f 	and.w	r2, ip, #31

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
  conv_class &= ~(sample_time_mask);
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
 80238c0:	ea44 4202 	orr.w	r2, r4, r2, lsl #16
  group_ptr->ICLASS[set_num] = conv_class;
 80238c4:	f8c0 20a4 	str.w	r2, [r0, #164]	; 0xa4
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class0, XMC_VADC_GROUP_CONV_STD, 0U);
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class0, XMC_VADC_GROUP_CONV_EMUX, 0U);
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class1, XMC_VADC_GROUP_CONV_STD, 1U);
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class1, XMC_VADC_GROUP_CONV_EMUX, 1U);

  group_ptr->ARBCFG = config->g_arbcfg;
 80238c8:	690b      	ldr	r3, [r1, #16]
 80238ca:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
  uint32_t   emux_config;

  XMC_ASSERT("XMC_VADC_GROUP_ExternalMuxControlInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  emux_config = ((uint32_t)emux_cfg.starting_external_channel << (uint32_t)VADC_G_EMUXCTR_EMUXSET_Pos) |
              ((uint32_t)emux_cfg.connected_channel << (uint32_t)VADC_G_EMUXCTR_EMUXCH_Pos);
 80238ce:	f3ce 0e09 	ubfx	lr, lr, #0, #10
{
  uint32_t   emux_config;

  XMC_ASSERT("XMC_VADC_GROUP_ExternalMuxControlInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  emux_config = ((uint32_t)emux_cfg.starting_external_channel << (uint32_t)VADC_G_EMUXCTR_EMUXSET_Pos) |
 80238d2:	f007 0707 	and.w	r7, r7, #7

  group_ptr->BOUND = config->g_bound;
 80238d6:	68cb      	ldr	r3, [r1, #12]
 80238d8:	f8c0 30b8 	str.w	r3, [r0, #184]	; 0xb8
 80238dc:	ea47 470e 	orr.w	r7, r7, lr, lsl #16
              ((uint32_t)emux_cfg.connected_channel << (uint32_t)VADC_G_EMUXCTR_EMUXCH_Pos);

  group_ptr->EMUXCTR  = emux_config;
 80238e0:	f8c0 71f0 	str.w	r7, [r0, #496]	; 0x1f0
                ((uint32_t)emux_cfg.stce_usage << (uint32_t)VADC_G_EMUXCTR_EMXST_Pos);

#if (XMC_VADC_EMUX_CH_SEL_STYLE == 1U)
  emux_config |= ((uint32_t)emux_cfg.emux_channel_select_style << (uint32_t)VADC_G_EMUXCTR_EMXCSS_Pos);
#endif
  group_ptr->EMUXCTR  |= (emux_config | ((uint32_t)VADC_G_EMUXCTR_EMXWC_Msk)) ;
 80238e4:	f8d0 21f0 	ldr.w	r2, [r0, #496]	; 0x1f0
 80238e8:	f3c6 1300 	ubfx	r3, r6, #4, #1
 80238ec:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 80238f0:	ea42 7203 	orr.w	r2, r2, r3, lsl #28
 80238f4:	f3c6 0381 	ubfx	r3, r6, #2, #2
 80238f8:	ea42 6283 	orr.w	r2, r2, r3, lsl #26
 80238fc:	f3c6 1340 	ubfx	r3, r6, #5, #1
 8023900:	ea42 7243 	orr.w	r2, r2, r3, lsl #29
 8023904:	f3c6 1380 	ubfx	r3, r6, #6, #1
 8023908:	ea42 7383 	orr.w	r3, r2, r3, lsl #30
 802390c:	f8c0 31f0 	str.w	r3, [r0, #496]	; 0x1f0
 8023910:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08023914 <XMC_VADC_GROUP_InputClassInit>:
}

/* API to program conversion characteristics */
void XMC_VADC_GROUP_InputClassInit(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_GROUP_CLASS_t config,
                                          const XMC_VADC_GROUP_CONV_t conv_type, const uint32_t set_num)
{
 8023914:	b4f0      	push	{r4, r5, r6, r7}

  /* 
   * Obtain the mask and position macros of the parameters based on what is being requested - Standard channels vs
   * external mux channels.
   */
  if (XMC_VADC_GROUP_CONV_STD == conv_type)
 8023916:	b1ba      	cbz	r2, 8023948 <XMC_VADC_GROUP_InputClassInit+0x34>
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CME_Pos;
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CME_Msk;
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCE_Pos;
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCE_Msk;
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
 8023918:	f3c1 4204 	ubfx	r2, r1, #16, #5
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
 802391c:	2510      	movs	r5, #16
 802391e:	f3c1 6102 	ubfx	r1, r1, #24, #3
 8023922:	f46f 16f8 	mvn.w	r6, #2031616	; 0x1f0000
 8023926:	2418      	movs	r4, #24
 8023928:	f06f 67e0 	mvn.w	r7, #117440512	; 0x7000000
 802392c:	eb00 0383 	add.w	r3, r0, r3, lsl #2
  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 8023930:	40a1      	lsls	r1, r4
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
  }

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];
 8023932:	f8d3 40a0 	ldr.w	r4, [r3, #160]	; 0xa0

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
 8023936:	403c      	ands	r4, r7
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 8023938:	4321      	orrs	r1, r4
  conv_class &= ~(sample_time_mask);
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
 802393a:	40aa      	lsls	r2, r5
  conv_class  = group_ptr->ICLASS[set_num];

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
  conv_class &= ~(sample_time_mask);
 802393c:	4031      	ands	r1, r6
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
 802393e:	4311      	orrs	r1, r2
  group_ptr->ICLASS[set_num] = conv_class;
 8023940:	f8c3 10a0 	str.w	r1, [r3, #160]	; 0xa0
}
 8023944:	bcf0      	pop	{r4, r5, r6, r7}
 8023946:	4770      	bx	lr
 8023948:	4615      	mov	r5, r2
 802394a:	f06f 061f 	mvn.w	r6, #31
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CMS_Pos;
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CMS_Msk;
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCS_Pos;
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCS_Msk;
    sample_time      = (uint32_t) config.sample_time_std_conv;
 802394e:	f001 021f 	and.w	r2, r1, #31
 8023952:	2408      	movs	r4, #8
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_standard;
 8023954:	f3c1 2102 	ubfx	r1, r1, #8, #3
 8023958:	f46f 67e0 	mvn.w	r7, #1792	; 0x700
 802395c:	e7e6      	b.n	802392c <XMC_VADC_GROUP_InputClassInit+0x18>
 802395e:	bf00      	nop

08023960 <XMC_VADC_GROUP_SetPowerMode>:
  uint32_t arbcfg;

  XMC_ASSERT("XMC_VADC_GROUP_SetPowerMode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_SetPowerMode:Wrong Power Mode", (power_mode <= XMC_VADC_GROUP_POWERMODE_NORMAL))

  arbcfg = group_ptr->ARBCFG;
 8023960:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80

  arbcfg &= ~((uint32_t)VADC_G_ARBCFG_ANONC_Msk);
 8023964:	f023 0303 	bic.w	r3, r3, #3
  arbcfg |= (uint32_t)power_mode;
 8023968:	4319      	orrs	r1, r3

  group_ptr->ARBCFG = arbcfg;
 802396a:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
 802396e:	4770      	bx	lr

08023970 <XMC_VADC_GROUP_SetSyncSlave>:
    master_grp = master_grp + 1U;
  }
  #endif
  
  /* Program SYNCTR */
  synctr = group_ptr->SYNCTR;
 8023970:	f8d0 30c0 	ldr.w	r3, [r0, #192]	; 0xc0
  XMC_ASSERT("XMC_VADC_GROUP_SetSyncSlave:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  
  #if (XMC_VADC_MULTIPLE_SLAVEGROUPS == 1U )

  /* Determine the coding of SYNCTR */
  if (slave_grp > master_grp)
 8023974:	428a      	cmp	r2, r1
  {
    master_grp = master_grp + 1U;
 8023976:	bf88      	it	hi
 8023978:	3101      	addhi	r1, #1
  }
  #endif
  
  /* Program SYNCTR */
  synctr = group_ptr->SYNCTR;
  synctr   &= ~((uint32_t)VADC_G_SYNCTR_STSEL_Msk);
 802397a:	f023 0303 	bic.w	r3, r3, #3
  synctr   |= master_grp;
 802397e:	4319      	orrs	r1, r3
  group_ptr->SYNCTR = synctr;
 8023980:	f8c0 10c0 	str.w	r1, [r0, #192]	; 0xc0
 8023984:	4770      	bx	lr
 8023986:	bf00      	nop

08023988 <XMC_VADC_GROUP_SetSyncMaster>:
{
  uint32_t synctr;

  XMC_ASSERT("XMC_VADC_GROUP_SetSyncMaster:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  synctr = group_ptr->SYNCTR;
 8023988:	f8d0 30c0 	ldr.w	r3, [r0, #192]	; 0xc0
  synctr   &= ~((uint32_t)VADC_G_SYNCTR_STSEL_Msk);
 802398c:	f023 0303 	bic.w	r3, r3, #3
  group_ptr->SYNCTR = synctr;
 8023990:	f8c0 30c0 	str.w	r3, [r0, #192]	; 0xc0
 8023994:	4770      	bx	lr
 8023996:	bf00      	nop

08023998 <XMC_VADC_GROUP_CheckSlaveReadiness>:
  XMC_ASSERT("XMC_VADC_GROUP_CheckSlaveReadiness:Wrong Slave group", ((slave_group >= 0) && (slave_group <= (XMC_VADC_MAXIMUM_NUM_GROUPS - 1))))

  master_grp_num =0;
  for(i=0; i<XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
  {
    if(g_xmc_vadc_group_array[i] == group_ptr)
 8023998:	4b0e      	ldr	r3, [pc, #56]	; (80239d4 <XMC_VADC_GROUP_CheckSlaveReadiness+0x3c>)
 802399a:	4298      	cmp	r0, r3
 802399c:	d010      	beq.n	80239c0 <XMC_VADC_GROUP_CheckSlaveReadiness+0x28>
 802399e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80239a2:	4298      	cmp	r0, r3
 80239a4:	d011      	beq.n	80239ca <XMC_VADC_GROUP_CheckSlaveReadiness+0x32>
 80239a6:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80239aa:	4298      	cmp	r0, r3
 80239ac:	d00f      	beq.n	80239ce <XMC_VADC_GROUP_CheckSlaveReadiness+0x36>

  if(slave_group < master_grp_num)
  {
    slave_group++;
  }
  group_ptr->SYNCTR |= (1U << (slave_group + XMC_VADC_SYNCTR_START_LOCATION));
 80239ae:	f8d0 20c0 	ldr.w	r2, [r0, #192]	; 0xc0
 80239b2:	3103      	adds	r1, #3
 80239b4:	2301      	movs	r3, #1
 80239b6:	408b      	lsls	r3, r1
 80239b8:	4313      	orrs	r3, r2
 80239ba:	f8c0 30c0 	str.w	r3, [r0, #192]	; 0xc0
 80239be:	4770      	bx	lr
  uint32_t i,master_grp_num;
  XMC_ASSERT("XMC_VADC_GROUP_CheckSlaveReadiness:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_CheckSlaveReadiness:Wrong Slave group", ((slave_group >= 0) && (slave_group <= (XMC_VADC_MAXIMUM_NUM_GROUPS - 1))))

  master_grp_num =0;
  for(i=0; i<XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 80239c0:	2301      	movs	r3, #1
      master_grp_num = i;
    }
  }


  if(slave_group < master_grp_num)
 80239c2:	4299      	cmp	r1, r3
  {
    slave_group++;
 80239c4:	bf38      	it	cc
 80239c6:	3101      	addcc	r1, #1
 80239c8:	e7f1      	b.n	80239ae <XMC_VADC_GROUP_CheckSlaveReadiness+0x16>
  uint32_t i,master_grp_num;
  XMC_ASSERT("XMC_VADC_GROUP_CheckSlaveReadiness:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_CheckSlaveReadiness:Wrong Slave group", ((slave_group >= 0) && (slave_group <= (XMC_VADC_MAXIMUM_NUM_GROUPS - 1))))

  master_grp_num =0;
  for(i=0; i<XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 80239ca:	2302      	movs	r3, #2
 80239cc:	e7f9      	b.n	80239c2 <XMC_VADC_GROUP_CheckSlaveReadiness+0x2a>
 80239ce:	2303      	movs	r3, #3
 80239d0:	e7f7      	b.n	80239c2 <XMC_VADC_GROUP_CheckSlaveReadiness+0x2a>
 80239d2:	bf00      	nop
 80239d4:	40004800 	.word	0x40004800

080239d8 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>:
                                            uint32_t eval_origin_group)
{
  XMC_ASSERT("XMC_VADC_GROUP_SetSyncSlaveReadySignal:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_SetSyncSlaveReadySignal:Wrong Group numbers", (eval_waiting_group == eval_origin_group ))

  if(eval_origin_group < eval_waiting_group)
 80239d8:	428a      	cmp	r2, r1
  {
	  eval_origin_group++;
 80239da:	bf38      	it	cc
 80239dc:	3201      	addcc	r2, #1
  }
  group_ptr->SYNCTR |= (1U << (eval_origin_group + XMC_VADC_SYNCTR_START_LOCATION));
 80239de:	f8d0 10c0 	ldr.w	r1, [r0, #192]	; 0xc0
 80239e2:	3203      	adds	r2, #3
 80239e4:	2301      	movs	r3, #1
 80239e6:	4093      	lsls	r3, r2
 80239e8:	430b      	orrs	r3, r1
 80239ea:	f8c0 30c0 	str.w	r3, [r0, #192]	; 0xc0
 80239ee:	4770      	bx	lr

080239f0 <XMC_VADC_GROUP_ScanInit>:
 *  XMC_VADC_GROUP_ScanEnableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_ScanDisableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanDisableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->ARBPR &= ~((uint32_t)VADC_G_ARBPR_ASEN1_Msk);
 80239f0:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
  /* Read in the existing contents of arbitration priority register */
  reg = group_ptr->ARBPR;

  /* Program the priority of the request source */
  reg &= ~(uint32_t)VADC_G_ARBPR_PRIO1_Msk;
  reg |= (uint32_t)((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO1_Pos);
 80239f4:	780a      	ldrb	r2, [r1, #0]
 80239f6:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 80239fa:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84

  /* All configurations have to be performed with the arbitration slot disabled */
  XMC_VADC_GROUP_ScanDisableArbitrationSlot(group_ptr);
  
  /* Read in the existing contents of arbitration priority register */
  reg = group_ptr->ARBPR;
 80239fe:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
#endif

#if (XMC_VADC_GSCAN_AVAILABLE == 1U)   
/* API to initialize the group scan hardware of a kernel */
void XMC_VADC_GROUP_ScanInit(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_SCAN_CONFIG_t *config)
{
 8023a02:	b410      	push	{r4}
  
  /* Read in the existing contents of arbitration priority register */
  reg = group_ptr->ARBPR;

  /* Program the priority of the request source */
  reg &= ~(uint32_t)VADC_G_ARBPR_PRIO1_Msk;
 8023a04:	f023 0330 	bic.w	r3, r3, #48	; 0x30
  reg |= (uint32_t)((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO1_Pos);
 8023a08:	f3c2 0481 	ubfx	r4, r2, #2, #2
  
  /* Program the start mode */
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)(config->conv_start_mode))
 8023a0c:	f012 0203 	ands.w	r2, r2, #3
  /* Read in the existing contents of arbitration priority register */
  reg = group_ptr->ARBPR;

  /* Program the priority of the request source */
  reg &= ~(uint32_t)VADC_G_ARBPR_PRIO1_Msk;
  reg |= (uint32_t)((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO1_Pos);
 8023a10:	ea43 1304 	orr.w	r3, r3, r4, lsl #4
  
  /* Program the start mode */
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)(config->conv_start_mode))
 8023a14:	d020      	beq.n	8023a58 <XMC_VADC_GROUP_ScanInit+0x68>
  {
    reg |= (uint32_t)(VADC_G_ARBPR_CSM1_Msk);
 8023a16:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  }

  group_ptr->ARBPR = reg;
 8023a1a:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84

  group_ptr->ASCTRL = (uint32_t)(config->asctrl |(VADC_G_ASCTRL_XTWC_Msk) |(VADC_G_ASCTRL_GTWC_Msk) |
 8023a1e:	684b      	ldr	r3, [r1, #4]
 8023a20:	f043 2380 	orr.w	r3, r3, #2147516416	; 0x80008000
 8023a24:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8023a28:	f8c0 3120 	str.w	r3, [r0, #288]	; 0x120
                                                 (VADC_G_ASCTRL_TMWC_Msk));

  group_ptr->ASMR  = (uint32_t)((config->asmr)| (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_G_ASMR_ENGT_Pos));
 8023a2c:	688b      	ldr	r3, [r1, #8]
  
  if (XMC_VADC_STARTMODE_CNR == (XMC_VADC_STARTMODE_t)(config->conv_start_mode))
 8023a2e:	2a02      	cmp	r2, #2
  group_ptr->ARBPR = reg;

  group_ptr->ASCTRL = (uint32_t)(config->asctrl |(VADC_G_ASCTRL_XTWC_Msk) |(VADC_G_ASCTRL_GTWC_Msk) |
                                                 (VADC_G_ASCTRL_TMWC_Msk));

  group_ptr->ASMR  = (uint32_t)((config->asmr)| (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_G_ASMR_ENGT_Pos));
 8023a30:	f043 0301 	orr.w	r3, r3, #1
 8023a34:	f8c0 3124 	str.w	r3, [r0, #292]	; 0x124
  
  if (XMC_VADC_STARTMODE_CNR == (XMC_VADC_STARTMODE_t)(config->conv_start_mode))
 8023a38:	d105      	bne.n	8023a46 <XMC_VADC_GROUP_ScanInit+0x56>
  {
    group_ptr->ASMR |= (uint32_t)VADC_G_ASMR_RPTDIS_Msk;
 8023a3a:	f8d0 3124 	ldr.w	r3, [r0, #292]	; 0x124
 8023a3e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8023a42:	f8c0 3124 	str.w	r3, [r0, #292]	; 0x124
 *  XMC_VADC_GROUP_ScanDisableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_ScanEnableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanEnableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->ARBPR |= (uint32_t)VADC_G_ARBPR_ASEN1_Msk;
 8023a46:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
  }
  
  /* Enable arbitration slot now */
  XMC_VADC_GROUP_ScanEnableArbitrationSlot(group_ptr);
  
}
 8023a4a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8023a4e:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8023a52:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
 8023a56:	4770      	bx	lr
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)(config->conv_start_mode))
  {
    reg |= (uint32_t)(VADC_G_ARBPR_CSM1_Msk);
  }

  group_ptr->ARBPR = reg;
 8023a58:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84

  group_ptr->ASCTRL = (uint32_t)(config->asctrl |(VADC_G_ASCTRL_XTWC_Msk) |(VADC_G_ASCTRL_GTWC_Msk) |
 8023a5c:	684b      	ldr	r3, [r1, #4]
 8023a5e:	f043 2380 	orr.w	r3, r3, #2147516416	; 0x80008000
 8023a62:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8023a66:	f8c0 3120 	str.w	r3, [r0, #288]	; 0x120
                                                 (VADC_G_ASCTRL_TMWC_Msk));

  group_ptr->ASMR  = (uint32_t)((config->asmr)| (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_G_ASMR_ENGT_Pos));
 8023a6a:	688b      	ldr	r3, [r1, #8]
 8023a6c:	f043 0301 	orr.w	r3, r3, #1
 8023a70:	f8c0 3124 	str.w	r3, [r0, #292]	; 0x124
 8023a74:	e7e7      	b.n	8023a46 <XMC_VADC_GROUP_ScanInit+0x56>
 8023a76:	bf00      	nop

08023a78 <XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode>:

/* API to select a service request line (NVIC Node) for request source event */
void XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_SR_t sr)
{
  uint32_t sevnp;
  sevnp = group_ptr->SEVNP;
 8023a78:	f8d0 31c0 	ldr.w	r3, [r0, #448]	; 0x1c0

  XMC_ASSERT("XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode:Wrong Service Request", ((sr)  <= XMC_VADC_SR_SHARED_SR3))

  sevnp &= ~((uint32_t)VADC_G_SEVNP_SEV1NP_Msk);
 8023a7c:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
  sevnp |= (uint32_t)((uint32_t)sr << VADC_G_SEVNP_SEV1NP_Pos);
 8023a80:	ea43 1101 	orr.w	r1, r3, r1, lsl #4

  group_ptr->SEVNP = sevnp;
 8023a84:	f8c0 11c0 	str.w	r1, [r0, #448]	; 0x1c0
 8023a88:	4770      	bx	lr
 8023a8a:	bf00      	nop

08023a8c <XMC_VADC_GROUP_QueueInit>:
 *  XMC_VADC_GROUP_QueueEnableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_QueueDisableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueDisableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr));
  group_ptr->ARBPR &= ~((uint32_t)VADC_G_ARBPR_ASEN0_Msk);
 8023a8c:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
  
  reg = group_ptr->ARBPR;

  /* Request Source priority */
  reg &= ~((uint32_t)VADC_G_ARBPR_PRIO0_Msk);
  reg |= (uint32_t) ((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO0_Pos);
 8023a90:	780a      	ldrb	r2, [r1, #0]
 8023a92:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8023a96:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  XMC_ASSERT("XMC_VADC_GROUP_QueueInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  /* Disable arbitration slot of the queue request source */
  XMC_VADC_GROUP_QueueDisableArbitrationSlot(group_ptr);
  
  reg = group_ptr->ARBPR;
 8023a9a:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
}

#if (XMC_VADC_QUEUE_AVAILABLE == 1U)  
/* API to initialize queue request source */
void XMC_VADC_GROUP_QueueInit(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_QUEUE_CONFIG_t *config)
{
 8023a9e:	b410      	push	{r4}
  XMC_VADC_GROUP_QueueDisableArbitrationSlot(group_ptr);
  
  reg = group_ptr->ARBPR;

  /* Request Source priority */
  reg &= ~((uint32_t)VADC_G_ARBPR_PRIO0_Msk);
 8023aa0:	f023 0303 	bic.w	r3, r3, #3
  reg |= (uint32_t) ((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO0_Pos);
 8023aa4:	f3c2 0481 	ubfx	r4, r2, #2, #2

  /* Conversion Start mode */
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)config->conv_start_mode)
 8023aa8:	f012 0203 	ands.w	r2, r2, #3
  
  reg = group_ptr->ARBPR;

  /* Request Source priority */
  reg &= ~((uint32_t)VADC_G_ARBPR_PRIO0_Msk);
  reg |= (uint32_t) ((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO0_Pos);
 8023aac:	ea43 0304 	orr.w	r3, r3, r4

  /* Conversion Start mode */
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)config->conv_start_mode)
 8023ab0:	d020      	beq.n	8023af4 <XMC_VADC_GROUP_QueueInit+0x68>
  {
    reg |= (uint32_t)(VADC_G_ARBPR_CSM0_Msk);
 8023ab2:	f043 0308 	orr.w	r3, r3, #8
  }

  group_ptr->ARBPR = reg;
 8023ab6:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84


  group_ptr->QCTRL0 = (uint32_t)((config->qctrl0)|(uint32_t)(VADC_G_QCTRL0_XTWC_Msk)|
 8023aba:	684b      	ldr	r3, [r1, #4]
 8023abc:	f043 2380 	orr.w	r3, r3, #2147516416	; 0x80008000
 8023ac0:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8023ac4:	f8c0 3100 	str.w	r3, [r0, #256]	; 0x100
                                                    (uint32_t)(VADC_G_QCTRL0_TMWC_Msk)|
                                                    (uint32_t)(VADC_G_QCTRL0_GTWC_Msk));

  /* Gating mode */
  group_ptr->QMR0 = ((uint32_t)(config->qmr0) | (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_G_QMR0_ENGT_Pos));
 8023ac8:	688b      	ldr	r3, [r1, #8]

  if (XMC_VADC_STARTMODE_CNR == (XMC_VADC_STARTMODE_t)(config->conv_start_mode) )
 8023aca:	2a02      	cmp	r2, #2
  group_ptr->QCTRL0 = (uint32_t)((config->qctrl0)|(uint32_t)(VADC_G_QCTRL0_XTWC_Msk)|
                                                    (uint32_t)(VADC_G_QCTRL0_TMWC_Msk)|
                                                    (uint32_t)(VADC_G_QCTRL0_GTWC_Msk));

  /* Gating mode */
  group_ptr->QMR0 = ((uint32_t)(config->qmr0) | (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_G_QMR0_ENGT_Pos));
 8023acc:	f043 0301 	orr.w	r3, r3, #1
 8023ad0:	f8c0 3104 	str.w	r3, [r0, #260]	; 0x104

  if (XMC_VADC_STARTMODE_CNR == (XMC_VADC_STARTMODE_t)(config->conv_start_mode) )
 8023ad4:	d105      	bne.n	8023ae2 <XMC_VADC_GROUP_QueueInit+0x56>
  {
    group_ptr->QMR0 |= (uint32_t)((uint32_t)1 << VADC_G_QMR0_RPTDIS_Pos);
 8023ad6:	f8d0 3104 	ldr.w	r3, [r0, #260]	; 0x104
 8023ada:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8023ade:	f8c0 3104 	str.w	r3, [r0, #260]	; 0x104
 *  XMC_VADC_GROUP_QueueDisableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_QueueEnableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueEnableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr));
  group_ptr->ARBPR |= (uint32_t)((uint32_t)1 << VADC_G_ARBPR_ASEN0_Pos);
 8023ae2:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
  }
  /* Enable arbitration slot for the queue request source */
  XMC_VADC_GROUP_QueueEnableArbitrationSlot(group_ptr);

}
 8023ae6:	f85d 4b04 	ldr.w	r4, [sp], #4
 8023aea:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8023aee:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
 8023af2:	4770      	bx	lr
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)config->conv_start_mode)
  {
    reg |= (uint32_t)(VADC_G_ARBPR_CSM0_Msk);
  }

  group_ptr->ARBPR = reg;
 8023af4:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84


  group_ptr->QCTRL0 = (uint32_t)((config->qctrl0)|(uint32_t)(VADC_G_QCTRL0_XTWC_Msk)|
 8023af8:	684b      	ldr	r3, [r1, #4]
 8023afa:	f043 2380 	orr.w	r3, r3, #2147516416	; 0x80008000
 8023afe:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8023b02:	f8c0 3100 	str.w	r3, [r0, #256]	; 0x100
                                                    (uint32_t)(VADC_G_QCTRL0_TMWC_Msk)|
                                                    (uint32_t)(VADC_G_QCTRL0_GTWC_Msk));

  /* Gating mode */
  group_ptr->QMR0 = ((uint32_t)(config->qmr0) | (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_G_QMR0_ENGT_Pos));
 8023b06:	688b      	ldr	r3, [r1, #8]
 8023b08:	f043 0301 	orr.w	r3, r3, #1
 8023b0c:	f8c0 3104 	str.w	r3, [r0, #260]	; 0x104
 8023b10:	e7e7      	b.n	8023ae2 <XMC_VADC_GROUP_QueueInit+0x56>
 8023b12:	bf00      	nop

08023b14 <XMC_VADC_GROUP_QueueSetReqSrcEventInterruptNode>:
  uint32_t sevnp;

  XMC_ASSERT("XMC_VADC_GROUP_QueueSetReqSrcEventInterruptNode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_QueueSetReqSrcEventInterruptNode:Wrong Service Request", ((sr)  <= XMC_VADC_SR_SHARED_SR3))

  sevnp = group_ptr->SEVNP;
 8023b14:	f8d0 31c0 	ldr.w	r3, [r0, #448]	; 0x1c0

  sevnp &= ~((uint32_t)VADC_G_SEVNP_SEV0NP_Msk);
 8023b18:	f023 030f 	bic.w	r3, r3, #15
  sevnp |= (uint32_t)((uint32_t)sr << VADC_G_SEVNP_SEV0NP_Pos);
 8023b1c:	4319      	orrs	r1, r3

  group_ptr->SEVNP = sevnp;
 8023b1e:	f8c0 11c0 	str.w	r1, [r0, #448]	; 0x1c0
 8023b22:	4770      	bx	lr

08023b24 <XMC_VADC_GROUP_ChannelInit>:

#if (XMC_VADC_GROUP_AVAILABLE ==1U)
/* API to initialize a channel unit */
void XMC_VADC_GROUP_ChannelInit(XMC_VADC_GROUP_t *const group_ptr, const uint32_t ch_num,
                                        const XMC_VADC_CHANNEL_CONFIG_t *config)
{
 8023b24:	b430      	push	{r4, r5}


  XMC_ASSERT("XMC_VADC_GROUP_ChannelInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_ChannelInit:Wrong Channel Number", ((ch_num) < XMC_VADC_NUM_CHANNELS_PER_GROUP))
  
  prio  = (uint32_t)config->channel_priority;
 8023b26:	7b13      	ldrb	r3, [r2, #12]

  /* Priority channel */
  ch_assign  = group_ptr->CHASS;
 8023b28:	f8d0 5088 	ldr.w	r5, [r0, #136]	; 0x88
  ch_assign &= ~((uint32_t)((uint32_t)1 << ch_num));
 8023b2c:	2401      	movs	r4, #1
 8023b2e:	408c      	lsls	r4, r1
 8023b30:	ea25 0404 	bic.w	r4, r5, r4
  ch_assign |= (uint32_t)(prio << ch_num);
 8023b34:	408b      	lsls	r3, r1
 8023b36:	4323      	orrs	r3, r4
  group_ptr->CHASS = ch_assign;
 8023b38:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88

  /* Alias channel */
  if (config->alias_channel >= (int32_t)0)
 8023b3c:	7b53      	ldrb	r3, [r2, #13]
 8023b3e:	061c      	lsls	r4, r3, #24
 8023b40:	d40a      	bmi.n	8023b58 <XMC_VADC_GROUP_ChannelInit+0x34>
  {
    mask = (uint32_t)0;
    if ((uint32_t)1 == ch_num)
 8023b42:	2901      	cmp	r1, #1
 8023b44:	d023      	beq.n	8023b8e <XMC_VADC_GROUP_ChannelInit+0x6a>
    {
      mask = VADC_G_ALIAS_ALIAS1_Pos;
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS1_Msk);
    }
    else if ((uint32_t)0 == ch_num)
 8023b46:	b1c9      	cbz	r1, 8023b7c <XMC_VADC_GROUP_ChannelInit+0x58>
 8023b48:	2500      	movs	r5, #0
    {
      mask = VADC_G_ALIAS_ALIAS0_Pos;
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS0_Msk);
    }

    group_ptr->ALIAS |= (uint32_t)(config->alias_channel << mask);
 8023b4a:	f8d0 40b0 	ldr.w	r4, [r0, #176]	; 0xb0
 8023b4e:	b25b      	sxtb	r3, r3
 8023b50:	40ab      	lsls	r3, r5
 8023b52:	4323      	orrs	r3, r4
 8023b54:	f8c0 30b0 	str.w	r3, [r0, #176]	; 0xb0
  }

  group_ptr->BFL |= config->bfl;
 8023b58:	f8d0 40c8 	ldr.w	r4, [r0, #200]	; 0xc8
 8023b5c:	6853      	ldr	r3, [r2, #4]
 8023b5e:	4323      	orrs	r3, r4
 8023b60:	f8c0 30c8 	str.w	r3, [r0, #200]	; 0xc8

#if (XMC_VADC_BOUNDARY_FLAG_SELECT == 1U)
  group_ptr->BFLC |= config->bflc;
 8023b64:	f8d0 40d0 	ldr.w	r4, [r0, #208]	; 0xd0
 8023b68:	6893      	ldr	r3, [r2, #8]
 8023b6a:	4323      	orrs	r3, r4
 8023b6c:	f8c0 30d0 	str.w	r3, [r0, #208]	; 0xd0
#endif
  /* Program the CHCTR register */
  group_ptr->CHCTR[ch_num] = config->chctr;
 8023b70:	3180      	adds	r1, #128	; 0x80
 8023b72:	6813      	ldr	r3, [r2, #0]
 8023b74:	f840 3021 	str.w	r3, [r0, r1, lsl #2]

}
 8023b78:	bc30      	pop	{r4, r5}
 8023b7a:	4770      	bx	lr
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS1_Msk);
    }
    else if ((uint32_t)0 == ch_num)
    {
      mask = VADC_G_ALIAS_ALIAS0_Pos;
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS0_Msk);
 8023b7c:	f8d0 30b0 	ldr.w	r3, [r0, #176]	; 0xb0
 8023b80:	f023 031f 	bic.w	r3, r3, #31
 8023b84:	f8c0 30b0 	str.w	r3, [r0, #176]	; 0xb0
 8023b88:	7b53      	ldrb	r3, [r2, #13]
 8023b8a:	460d      	mov	r5, r1
 8023b8c:	e7dd      	b.n	8023b4a <XMC_VADC_GROUP_ChannelInit+0x26>
  {
    mask = (uint32_t)0;
    if ((uint32_t)1 == ch_num)
    {
      mask = VADC_G_ALIAS_ALIAS1_Pos;
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS1_Msk);
 8023b8e:	f8d0 30b0 	ldr.w	r3, [r0, #176]	; 0xb0
 8023b92:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
 8023b96:	f8c0 30b0 	str.w	r3, [r0, #176]	; 0xb0
 8023b9a:	7b53      	ldrb	r3, [r2, #13]
 8023b9c:	2508      	movs	r5, #8
 8023b9e:	e7d4      	b.n	8023b4a <XMC_VADC_GROUP_ChannelInit+0x26>

08023ba0 <XMC_VADC_GROUP_SetResultInterruptNode>:

  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Result Register", ((res_reg) < XMC_VADC_NUM_RESULT_REGISTERS))
  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Service Request", ((sr)  <= XMC_VADC_SR_SHARED_SR3))

  if (res_reg <= 7U)
 8023ba0:	2907      	cmp	r1, #7

/* API to select a service request line (NVIC Node) for result event of specified unit of result hardware */
void XMC_VADC_GROUP_SetResultInterruptNode(XMC_VADC_GROUP_t *const group_ptr,
                                           const uint32_t res_reg,
                                           const XMC_VADC_SR_t sr)
{
 8023ba2:	b410      	push	{r4}

  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Result Register", ((res_reg) < XMC_VADC_NUM_RESULT_REGISTERS))
  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Service Request", ((sr)  <= XMC_VADC_SR_SHARED_SR3))

  if (res_reg <= 7U)
 8023ba4:	d910      	bls.n	8023bc8 <XMC_VADC_GROUP_SetResultInterruptNode+0x28>
    group_ptr->REVNP0 = route_mask;
  }
  else
  {
    route_mask = group_ptr->REVNP1;
    route_mask &= ~((uint32_t)((uint32_t)15 << (( res_reg - (uint32_t)8) * (uint32_t)4) ));
 8023ba6:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 8023baa:	3908      	subs	r1, #8
    route_mask |= (uint32_t)((uint32_t)sr << (res_reg * (uint32_t)4));
    group_ptr->REVNP0 = route_mask;
  }
  else
  {
    route_mask = group_ptr->REVNP1;
 8023bac:	f8d0 41b4 	ldr.w	r4, [r0, #436]	; 0x1b4
    route_mask &= ~((uint32_t)((uint32_t)15 << (( res_reg - (uint32_t)8) * (uint32_t)4) ));
 8023bb0:	0089      	lsls	r1, r1, #2
 8023bb2:	230f      	movs	r3, #15
 8023bb4:	408b      	lsls	r3, r1
 8023bb6:	ea24 0303 	bic.w	r3, r4, r3
    route_mask |= (uint32_t)((uint32_t)sr << ((res_reg - (uint32_t)8) * (uint32_t)4));
 8023bba:	408a      	lsls	r2, r1
 8023bbc:	431a      	orrs	r2, r3
    group_ptr->REVNP1 = route_mask;
 8023bbe:	f8c0 21b4 	str.w	r2, [r0, #436]	; 0x1b4
  }
}
 8023bc2:	f85d 4b04 	ldr.w	r4, [sp], #4
 8023bc6:	4770      	bx	lr
  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Result Register", ((res_reg) < XMC_VADC_NUM_RESULT_REGISTERS))
  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Service Request", ((sr)  <= XMC_VADC_SR_SHARED_SR3))

  if (res_reg <= 7U)
  {
    route_mask  = group_ptr->REVNP0;
 8023bc8:	f8d0 41b0 	ldr.w	r4, [r0, #432]	; 0x1b0
    route_mask &= ~((uint32_t)((uint32_t)15 << (res_reg * (uint32_t)4) ));
 8023bcc:	0089      	lsls	r1, r1, #2
 8023bce:	230f      	movs	r3, #15
 8023bd0:	408b      	lsls	r3, r1
 8023bd2:	ea24 0303 	bic.w	r3, r4, r3
    route_mask |= (uint32_t)((uint32_t)sr << (res_reg * (uint32_t)4));
 8023bd6:	408a      	lsls	r2, r1
 8023bd8:	431a      	orrs	r2, r3
    group_ptr->REVNP0 = route_mask;
 8023bda:	f8c0 21b0 	str.w	r2, [r0, #432]	; 0x1b0
    route_mask = group_ptr->REVNP1;
    route_mask &= ~((uint32_t)((uint32_t)15 << (( res_reg - (uint32_t)8) * (uint32_t)4) ));
    route_mask |= (uint32_t)((uint32_t)sr << ((res_reg - (uint32_t)8) * (uint32_t)4));
    group_ptr->REVNP1 = route_mask;
  }
}
 8023bde:	f85d 4b04 	ldr.w	r4, [sp], #4
 8023be2:	4770      	bx	lr

08023be4 <_sbrk>:
caddr_t _sbrk(int nbytes)
{
  static caddr_t heap_ptr = NULL;
  caddr_t base;

  if (heap_ptr == NULL) {
 8023be4:	4a0c      	ldr	r2, [pc, #48]	; (8023c18 <_sbrk+0x34>)

// defined in linker script
extern caddr_t Heap_Bank1_Start;
extern caddr_t Heap_Bank1_End;
caddr_t _sbrk(int nbytes)
{
 8023be6:	b508      	push	{r3, lr}
  static caddr_t heap_ptr = NULL;
  caddr_t base;

  if (heap_ptr == NULL) {
 8023be8:	6813      	ldr	r3, [r2, #0]
 8023bea:	b18b      	cbz	r3, 8023c10 <_sbrk+0x2c>
  }

  base = heap_ptr;

  /* heap word alignment */
  nbytes = (nbytes + 3) & ~0x3U;
 8023bec:	3003      	adds	r0, #3
 8023bee:	f020 0003 	bic.w	r0, r0, #3
  if ((caddr_t)&Heap_Bank1_End > (heap_ptr + nbytes))
 8023bf2:	490a      	ldr	r1, [pc, #40]	; (8023c1c <_sbrk+0x38>)
 8023bf4:	4418      	add	r0, r3
 8023bf6:	4288      	cmp	r0, r1
 8023bf8:	d202      	bcs.n	8023c00 <_sbrk+0x1c>
  {
    heap_ptr += nbytes;
 8023bfa:	6010      	str	r0, [r2, #0]
  {
    /* Heap overflow */
    errno = ENOMEM;
    return ((caddr_t)-1);
  }
}
 8023bfc:	4618      	mov	r0, r3
 8023bfe:	bd08      	pop	{r3, pc}
    return (base);
  }
  else
  {
    /* Heap overflow */
    errno = ENOMEM;
 8023c00:	f00a ffbc 	bl	802eb7c <__errno>
 8023c04:	230c      	movs	r3, #12
 8023c06:	6003      	str	r3, [r0, #0]
    return ((caddr_t)-1);
 8023c08:	f04f 33ff 	mov.w	r3, #4294967295
  }
}
 8023c0c:	4618      	mov	r0, r3
 8023c0e:	bd08      	pop	{r3, pc}
{
  static caddr_t heap_ptr = NULL;
  caddr_t base;

  if (heap_ptr == NULL) {
    heap_ptr = (caddr_t)&Heap_Bank1_Start;
 8023c10:	4b03      	ldr	r3, [pc, #12]	; (8023c20 <_sbrk+0x3c>)
 8023c12:	6013      	str	r3, [r2, #0]
 8023c14:	e7ea      	b.n	8023bec <_sbrk+0x8>
 8023c16:	bf00      	nop
 8023c18:	1ffe9800 	.word	0x1ffe9800
 8023c1c:	2003ffc0 	.word	0x2003ffc0
 8023c20:	2000e930 	.word	0x2000e930

08023c24 <ep_calibration_handle_message>:
   5. EXPORTED FUNCTIONS
==============================================================================
 */

uint16_t ep_calibration_handle_message(uint8_t endpoint, uint8_t* message_data, uint16_t num_bytes, void* context)
{
 8023c24:	b5f0      	push	{r4, r5, r6, r7, lr}
	Radar_Handle_t radar_driver = (Radar_Handle_t) context;

	uint16_t error_code;

	switch (message_data[0])
 8023c26:	780c      	ldrb	r4, [r1, #0]
 8023c28:	3c01      	subs	r4, #1
   5. EXPORTED FUNCTIONS
==============================================================================
 */

uint16_t ep_calibration_handle_message(uint8_t endpoint, uint8_t* message_data, uint16_t num_bytes, void* context)
{
 8023c2a:	b087      	sub	sp, #28
 8023c2c:	4606      	mov	r6, r0
 8023c2e:	4615      	mov	r5, r2
	Radar_Handle_t radar_driver = (Radar_Handle_t) context;

	uint16_t error_code;

	switch (message_data[0])
 8023c30:	2c0b      	cmp	r4, #11
 8023c32:	d80a      	bhi.n	8023c4a <ep_calibration_handle_message+0x26>
 8023c34:	e8df f004 	tbb	[pc, r4]
 8023c38:	3931160d 	.word	0x3931160d
 8023c3c:	8b766e42 	.word	0x8b766e42
 8023c40:	06bba59c 	.word	0x06bba59c

		//---------------------------------------------------------------

	case MSG_CLEAR_ALGO_SRAM_CALIBRATION:

		if (num_bytes == 1)
 8023c44:	2d01      	cmp	r5, #1
 8023c46:	f000 80dd 	beq.w	8023e04 <ep_calibration_handle_message+0x1e0>
	default:

		break;
	}

	return PROTOCOL_STATUS_INVALID_PAYLOAD;
 8023c4a:	f64f 70ff 	movw	r0, #65535	; 0xffff
}
 8023c4e:	b007      	add	sp, #28
 8023c50:	bdf0      	pop	{r4, r5, r6, r7, pc}

		//---------------------------------------------------------------

	case MSG_SET_ADC_FLASH_CALIBRATION:

		if (num_bytes == 1)
 8023c52:	2d01      	cmp	r5, #1
 8023c54:	d1f9      	bne.n	8023c4a <ep_calibration_handle_message+0x26>
		{
			error_code = radar_save_calibration(radar_driver, CALIBRATION_TARGET_FLASH, CALIBRATION_DATA_ADC, NULL);
 8023c56:	2100      	movs	r1, #0
 8023c58:	4618      	mov	r0, r3
 8023c5a:	460a      	mov	r2, r1
 8023c5c:	460b      	mov	r3, r1
 8023c5e:	f7fc ff19 	bl	8020a94 <radar_save_calibration>

			return error_code;
 8023c62:	e7f4      	b.n	8023c4e <ep_calibration_handle_message+0x2a>
	switch (message_data[0])
	{

	case MSG_GET_ADC_FLASH_CALIBRATION:

		if (num_bytes == 1)
 8023c64:	2d01      	cmp	r5, #1
 8023c66:	d1f0      	bne.n	8023c4a <ep_calibration_handle_message+0x26>
{
	uint16_t error_code = 0;

	uint16_t num_of_bytes;

	void* calibration_data_ptr = NULL;
 8023c68:	aa06      	add	r2, sp, #24
 8023c6a:	2100      	movs	r1, #0
 8023c6c:	f842 1d08 	str.w	r1, [r2, #-8]!

	//----------------------------------------------------------------------

	error_code = radar_read_calibration(radar_driver, target, CALIBRATION_DATA_ADC, &calibration_data_ptr, &num_of_bytes);
 8023c70:	f10d 040a 	add.w	r4, sp, #10
 8023c74:	4618      	mov	r0, r3
 8023c76:	9400      	str	r4, [sp, #0]
 8023c78:	4613      	mov	r3, r2
 8023c7a:	460a      	mov	r2, r1
 8023c7c:	f7fc ffd2 	bl	8020c24 <radar_read_calibration>

	if (error_code == RADAR_ERR_OK)
 8023c80:	4604      	mov	r4, r0
 8023c82:	2800      	cmp	r0, #0
 8023c84:	d144      	bne.n	8023d10 <ep_calibration_handle_message+0xec>
		else
		{
			wr_payload_u8(message_header, 0, MSG_GET_ADC_SRAM_CALIBRATION);
		}

		wr_payload_u16(message_header, 1, num_of_bytes);
 8023c86:	f8bd 300a 	ldrh.w	r3, [sp, #10]

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8023c8a:	f88d 300d 	strb.w	r3, [sp, #13]

		/* send message header */
		protocol_send_header(endpoint, sizeof(message_header) + num_of_bytes);
 8023c8e:	1cd9      	adds	r1, r3, #3
 8023c90:	4630      	mov	r0, r6
 8023c92:	b289      	uxth	r1, r1
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023c94:	0a1b      	lsrs	r3, r3, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023c96:	2202      	movs	r2, #2
 8023c98:	e029      	b.n	8023cee <ep_calibration_handle_message+0xca>

		//---------------------------------------------------------------

	case MSG_CLEAR_ADC_FLASH_CALIBRATION:

		if (num_bytes == 1)
 8023c9a:	2d01      	cmp	r5, #1
 8023c9c:	d1d5      	bne.n	8023c4a <ep_calibration_handle_message+0x26>
		{
			error_code = radar_clear_calibration(radar_driver, CALIBRATION_TARGET_FLASH, CALIBRATION_DATA_ADC);
 8023c9e:	2100      	movs	r1, #0
 8023ca0:	4618      	mov	r0, r3
 8023ca2:	460a      	mov	r2, r1
 8023ca4:	f7fd f806 	bl	8020cb4 <radar_clear_calibration>

			return error_code;
 8023ca8:	e7d1      	b.n	8023c4e <ep_calibration_handle_message+0x2a>

		//---------------------------------------------------------------

	case MSG_SET_ADC_SRAM_CALIBRATION:

		if (num_bytes == 1)
 8023caa:	2d01      	cmp	r5, #1
 8023cac:	d1cd      	bne.n	8023c4a <ep_calibration_handle_message+0x26>
		{
			error_code = radar_save_calibration(radar_driver, CALIBRATION_TARGET_SRAM,CALIBRATION_DATA_ADC, NULL);
 8023cae:	2200      	movs	r2, #0
 8023cb0:	4618      	mov	r0, r3
 8023cb2:	4629      	mov	r1, r5
 8023cb4:	4613      	mov	r3, r2
 8023cb6:	f7fc feed 	bl	8020a94 <radar_save_calibration>

			return error_code;
 8023cba:	e7c8      	b.n	8023c4e <ep_calibration_handle_message+0x2a>

		//---------------------------------------------------------------

	case MSG_GET_ADC_SRAM_CALIBRATION:

		if (num_bytes == 1)
 8023cbc:	2d01      	cmp	r5, #1
 8023cbe:	d1c4      	bne.n	8023c4a <ep_calibration_handle_message+0x26>
{
	uint16_t error_code = 0;

	uint16_t num_of_bytes;

	void* calibration_data_ptr = NULL;
 8023cc0:	ac06      	add	r4, sp, #24
 8023cc2:	2200      	movs	r2, #0
 8023cc4:	f844 2d08 	str.w	r2, [r4, #-8]!

	//----------------------------------------------------------------------

	error_code = radar_read_calibration(radar_driver, target, CALIBRATION_DATA_ADC, &calibration_data_ptr, &num_of_bytes);
 8023cc8:	f10d 070a 	add.w	r7, sp, #10
 8023ccc:	4618      	mov	r0, r3
 8023cce:	4629      	mov	r1, r5
 8023cd0:	4623      	mov	r3, r4
 8023cd2:	9700      	str	r7, [sp, #0]
 8023cd4:	f7fc ffa6 	bl	8020c24 <radar_read_calibration>

	if (error_code == RADAR_ERR_OK)
 8023cd8:	4604      	mov	r4, r0
 8023cda:	b9c8      	cbnz	r0, 8023d10 <ep_calibration_handle_message+0xec>
		else
		{
			wr_payload_u8(message_header, 0, MSG_GET_ADC_SRAM_CALIBRATION);
		}

		wr_payload_u16(message_header, 1, num_of_bytes);
 8023cdc:	f8bd 300a 	ldrh.w	r3, [sp, #10]

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8023ce0:	f88d 300d 	strb.w	r3, [sp, #13]

		/* send message header */
		protocol_send_header(endpoint, sizeof(message_header) + num_of_bytes);
 8023ce4:	1cd9      	adds	r1, r3, #3
 8023ce6:	4630      	mov	r0, r6
 8023ce8:	b289      	uxth	r1, r1
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023cea:	0a1b      	lsrs	r3, r3, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023cec:	2205      	movs	r2, #5
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023cee:	f88d 300e 	strb.w	r3, [sp, #14]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023cf2:	f88d 200c 	strb.w	r2, [sp, #12]
 8023cf6:	f001 fa7b 	bl	80251f0 <protocol_send_header>

		protocol_send_payload(message_header, sizeof(message_header));
 8023cfa:	a803      	add	r0, sp, #12
 8023cfc:	2103      	movs	r1, #3
 8023cfe:	f001 fa8b 	bl	8025218 <protocol_send_payload>

		protocol_send_payload((uint8_t*)calibration_data_ptr, num_of_bytes);
 8023d02:	9804      	ldr	r0, [sp, #16]
 8023d04:	f8bd 100a 	ldrh.w	r1, [sp, #10]
 8023d08:	f001 fa86 	bl	8025218 <protocol_send_payload>

		protocol_send_tail();
 8023d0c:	f001 fa86 	bl	802521c <protocol_send_tail>

	void* calibration_data_ptr;

	//----------------------------------------------------------------------

	error_code = radar_read_calibration(radar_driver, target, CALIBRATION_DATA_ALGO, &calibration_data_ptr, &num_of_bytes);
 8023d10:	4620      	mov	r0, r4

		if (num_bytes == 1)
		{
			error_code = send_algo_calibration_data(endpoint, radar_driver, CALIBRATION_TARGET_SRAM);

			return error_code;
 8023d12:	e79c      	b.n	8023c4e <ep_calibration_handle_message+0x2a>

		//---------------------------------------------------------------

	case MSG_CLEAR_ADC_SRAM_CALIBRATION:

		if (num_bytes == 1)
 8023d14:	2d01      	cmp	r5, #1
 8023d16:	d198      	bne.n	8023c4a <ep_calibration_handle_message+0x26>
		{
			error_code = radar_clear_calibration(radar_driver, CALIBRATION_TARGET_SRAM, CALIBRATION_DATA_ADC);
 8023d18:	4618      	mov	r0, r3
 8023d1a:	4629      	mov	r1, r5
 8023d1c:	2200      	movs	r2, #0
 8023d1e:	f7fc ffc9 	bl	8020cb4 <radar_clear_calibration>

			return error_code;
 8023d22:	e794      	b.n	8023c4e <ep_calibration_handle_message+0x2a>

		//---------------------------------------------------------------

	case MSG_SET_ALGO_FLASH_CALIBRATION:

		if (num_bytes == 5)
 8023d24:	2d05      	cmp	r5, #5
 8023d26:	d190      	bne.n	8023c4a <ep_calibration_handle_message+0x26>
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, uint16_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8023d28:	788e      	ldrb	r6, [r1, #2]
 * than the native little endian implementations.
 */

static inline int16_t rd_payload_i16(const uint8_t* payload, uint16_t offset)
{
    return (int16_t)((((uint16_t)payload[offset + 1]) <<  8) |
 8023d2a:	78ca      	ldrb	r2, [r1, #3]
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, uint16_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8023d2c:	784d      	ldrb	r5, [r1, #1]
 * than the native little endian implementations.
 */

static inline int16_t rd_payload_i16(const uint8_t* payload, uint16_t offset)
{
    return (int16_t)((((uint16_t)payload[offset + 1]) <<  8) |
 8023d2e:	790c      	ldrb	r4, [r1, #4]
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, uint16_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8023d30:	ea45 2506 	orr.w	r5, r5, r6, lsl #8
 * than the native little endian implementations.
 */

static inline int16_t rd_payload_i16(const uint8_t* payload, uint16_t offset)
{
    return (int16_t)((((uint16_t)payload[offset + 1]) <<  8) |
 8023d34:	ea42 2404 	orr.w	r4, r2, r4, lsl #8
			/* extract parameters from message */

			algo_calibration_settings.distance_offset_cm = rd_payload_u16(message_data, 1);
			algo_calibration_settings.angle_offset_deg   = rd_payload_i16(message_data, 3);

			error_code = radar_save_calibration(radar_driver, CALIBRATION_TARGET_FLASH, CALIBRATION_DATA_ALGO, &algo_calibration_settings);
 8023d38:	4618      	mov	r0, r3
 8023d3a:	2100      	movs	r1, #0
 8023d3c:	2201      	movs	r2, #1
 8023d3e:	ab04      	add	r3, sp, #16
		{
			Algo_Calibrations_t algo_calibration_settings;

			/* extract parameters from message */

			algo_calibration_settings.distance_offset_cm = rd_payload_u16(message_data, 1);
 8023d40:	f8ad 5010 	strh.w	r5, [sp, #16]
			algo_calibration_settings.angle_offset_deg   = rd_payload_i16(message_data, 3);
 8023d44:	f8ad 4012 	strh.w	r4, [sp, #18]

			error_code = radar_save_calibration(radar_driver, CALIBRATION_TARGET_FLASH, CALIBRATION_DATA_ALGO, &algo_calibration_settings);
 8023d48:	f7fc fea4 	bl	8020a94 <radar_save_calibration>
 8023d4c:	e77f      	b.n	8023c4e <ep_calibration_handle_message+0x2a>

		//===============================================================

	case MSG_GET_ALGO_FLASH_CALIBRATION:

		if (num_bytes == 1)
 8023d4e:	2d01      	cmp	r5, #1
 8023d50:	f47f af7b 	bne.w	8023c4a <ep_calibration_handle_message+0x26>

	void* calibration_data_ptr;

	//----------------------------------------------------------------------

	error_code = radar_read_calibration(radar_driver, target, CALIBRATION_DATA_ALGO, &calibration_data_ptr, &num_of_bytes);
 8023d54:	f10d 010a 	add.w	r1, sp, #10
 8023d58:	4618      	mov	r0, r3
 8023d5a:	9100      	str	r1, [sp, #0]
 8023d5c:	462a      	mov	r2, r5
 8023d5e:	2100      	movs	r1, #0
 8023d60:	ab03      	add	r3, sp, #12
 8023d62:	f7fc ff5f 	bl	8020c24 <radar_read_calibration>

	if (error_code == RADAR_ERR_OK)
 8023d66:	4604      	mov	r4, r0
 8023d68:	2800      	cmp	r0, #0
 8023d6a:	d1d1      	bne.n	8023d10 <ep_calibration_handle_message+0xec>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023d6c:	2308      	movs	r3, #8
 8023d6e:	e02e      	b.n	8023dce <ep_calibration_handle_message+0x1aa>

		//---------------------------------------------------------------

	case MSG_CLEAR_ALGO_FLASH_CALIBRATION:

		if (num_bytes == 1)
 8023d70:	2d01      	cmp	r5, #1
 8023d72:	f47f af6a 	bne.w	8023c4a <ep_calibration_handle_message+0x26>
		{
			error_code = radar_clear_calibration(radar_driver, CALIBRATION_TARGET_FLASH, CALIBRATION_DATA_ALGO);
 8023d76:	4618      	mov	r0, r3
 8023d78:	462a      	mov	r2, r5
 8023d7a:	2100      	movs	r1, #0
 8023d7c:	f7fc ff9a 	bl	8020cb4 <radar_clear_calibration>

			return error_code;
 8023d80:	e765      	b.n	8023c4e <ep_calibration_handle_message+0x2a>

		//---------------------------------------------------------------

	case MSG_SET_ALGO_SRAM_CALIBRATION:

		if (num_bytes == 5)
 8023d82:	2d05      	cmp	r5, #5
 8023d84:	f47f af61 	bne.w	8023c4a <ep_calibration_handle_message+0x26>
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, uint16_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8023d88:	788e      	ldrb	r6, [r1, #2]
 * than the native little endian implementations.
 */

static inline int16_t rd_payload_i16(const uint8_t* payload, uint16_t offset)
{
    return (int16_t)((((uint16_t)payload[offset + 1]) <<  8) |
 8023d8a:	78ca      	ldrb	r2, [r1, #3]
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, uint16_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8023d8c:	784d      	ldrb	r5, [r1, #1]
 * than the native little endian implementations.
 */

static inline int16_t rd_payload_i16(const uint8_t* payload, uint16_t offset)
{
    return (int16_t)((((uint16_t)payload[offset + 1]) <<  8) |
 8023d8e:	790c      	ldrb	r4, [r1, #4]

			/* extract parameters from message */
			algo_calibration_settings.distance_offset_cm = rd_payload_u16(message_data, 1);
			algo_calibration_settings.angle_offset_deg   = rd_payload_i16(message_data, 3);

			error_code = radar_save_calibration(radar_driver, CALIBRATION_TARGET_SRAM, CALIBRATION_DATA_ALGO, &algo_calibration_settings);
 8023d90:	2101      	movs	r1, #1
 8023d92:	ea42 2404 	orr.w	r4, r2, r4, lsl #8
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, uint16_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8023d96:	ea45 2506 	orr.w	r5, r5, r6, lsl #8
 8023d9a:	4618      	mov	r0, r3
 8023d9c:	460a      	mov	r2, r1
 8023d9e:	ab04      	add	r3, sp, #16
		if (num_bytes == 5)
		{
			Algo_Calibrations_t algo_calibration_settings;

			/* extract parameters from message */
			algo_calibration_settings.distance_offset_cm = rd_payload_u16(message_data, 1);
 8023da0:	f8ad 5010 	strh.w	r5, [sp, #16]
			algo_calibration_settings.angle_offset_deg   = rd_payload_i16(message_data, 3);
 8023da4:	f8ad 4012 	strh.w	r4, [sp, #18]

			error_code = radar_save_calibration(radar_driver, CALIBRATION_TARGET_SRAM, CALIBRATION_DATA_ALGO, &algo_calibration_settings);
 8023da8:	f7fc fe74 	bl	8020a94 <radar_save_calibration>
 8023dac:	e74f      	b.n	8023c4e <ep_calibration_handle_message+0x2a>

		//---------------------------------------------------------------

	case MSG_GET_ALGO_SRAM_CALIBRATION:

		if (num_bytes == 1)
 8023dae:	2d01      	cmp	r5, #1
 8023db0:	f47f af4b 	bne.w	8023c4a <ep_calibration_handle_message+0x26>

	void* calibration_data_ptr;

	//----------------------------------------------------------------------

	error_code = radar_read_calibration(radar_driver, target, CALIBRATION_DATA_ALGO, &calibration_data_ptr, &num_of_bytes);
 8023db4:	f10d 020a 	add.w	r2, sp, #10
 8023db8:	4618      	mov	r0, r3
 8023dba:	9200      	str	r2, [sp, #0]
 8023dbc:	4629      	mov	r1, r5
 8023dbe:	462a      	mov	r2, r5
 8023dc0:	ab03      	add	r3, sp, #12
 8023dc2:	f7fc ff2f 	bl	8020c24 <radar_read_calibration>

	if (error_code == RADAR_ERR_OK)
 8023dc6:	4604      	mov	r4, r0
 8023dc8:	2800      	cmp	r0, #0
 8023dca:	d1a1      	bne.n	8023d10 <ep_calibration_handle_message+0xec>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023dcc:	230b      	movs	r3, #11
		else
		{
			wr_payload_u8(message_header, 0, MSG_GET_ALGO_SRAM_CALIBRATION);
		}

		wr_payload_u16(message_header, 1, ((Algo_Calibrations_t*)calibration_data_ptr)->distance_offset_cm);
 8023dce:	9a03      	ldr	r2, [sp, #12]
 8023dd0:	f88d 3010 	strb.w	r3, [sp, #16]
 8023dd4:	8813      	ldrh	r3, [r2, #0]

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8023dd6:	f88d 3011 	strb.w	r3, [sp, #17]
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023dda:	0a1b      	lsrs	r3, r3, #8
 8023ddc:	f88d 3012 	strb.w	r3, [sp, #18]
		wr_payload_i16(message_header, 3, ((Algo_Calibrations_t*)calibration_data_ptr)->angle_offset_deg);
 8023de0:	8853      	ldrh	r3, [r2, #2]

static inline void wr_payload_i16(uint8_t* payload, uint16_t offset,
                                  int16_t value)
{
    payload[offset + 1] = (((uint16_t)value) >>  8) & 0xFF;
    payload[offset    ] =  ((uint16_t)value)        & 0xFF;
 8023de2:	f88d 3013 	strb.w	r3, [sp, #19]

		/* send message header */
		protocol_send_header(endpoint, sizeof(message_header));
 8023de6:	4630      	mov	r0, r6
}

static inline void wr_payload_i16(uint8_t* payload, uint16_t offset,
                                  int16_t value)
{
    payload[offset + 1] = (((uint16_t)value) >>  8) & 0xFF;
 8023de8:	0a1b      	lsrs	r3, r3, #8
 8023dea:	2105      	movs	r1, #5
 8023dec:	f88d 3014 	strb.w	r3, [sp, #20]
 8023df0:	f001 f9fe 	bl	80251f0 <protocol_send_header>

		protocol_send_payload(message_header, sizeof(message_header));
 8023df4:	a804      	add	r0, sp, #16
 8023df6:	2105      	movs	r1, #5
 8023df8:	f001 fa0e 	bl	8025218 <protocol_send_payload>

		protocol_send_tail();
 8023dfc:	f001 fa0e 	bl	802521c <protocol_send_tail>

	void* calibration_data_ptr;

	//----------------------------------------------------------------------

	error_code = radar_read_calibration(radar_driver, target, CALIBRATION_DATA_ALGO, &calibration_data_ptr, &num_of_bytes);
 8023e00:	4620      	mov	r0, r4
 8023e02:	e724      	b.n	8023c4e <ep_calibration_handle_message+0x2a>

	case MSG_CLEAR_ALGO_SRAM_CALIBRATION:

		if (num_bytes == 1)
		{
			error_code = radar_clear_calibration(radar_driver, CALIBRATION_TARGET_SRAM, CALIBRATION_DATA_ALGO);
 8023e04:	4618      	mov	r0, r3
 8023e06:	4629      	mov	r1, r5
 8023e08:	462a      	mov	r2, r5
 8023e0a:	f7fc ff53 	bl	8020cb4 <radar_clear_calibration>

			return error_code;
 8023e0e:	e71e      	b.n	8023c4e <ep_calibration_handle_message+0x2a>

08023e10 <ep_calibration_handle_change>:
}

//==============================================================================

void ep_calibration_handle_change (uint8_t endpoint, void* context, uint32_t what)
{
 8023e10:	4770      	bx	lr
 8023e12:	bf00      	nop

08023e14 <send_adc_configuration>:
==============================================================================
*/

uint16_t send_adc_configuration(uint8_t endpoint,
                                       Radar_Handle_t radar_driver)
{
 8023e14:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint16_t error_code;
    Adc_Configuration_t adc_configuration;

    adc_endpoint = endpoint;
 8023e16:	4b17      	ldr	r3, [pc, #92]	; (8023e74 <send_adc_configuration+0x60>)
==============================================================================
*/

uint16_t send_adc_configuration(uint8_t endpoint,
                                       Radar_Handle_t radar_driver)
{
 8023e18:	b085      	sub	sp, #20
 8023e1a:	4605      	mov	r5, r0
    Adc_Configuration_t adc_configuration;

    adc_endpoint = endpoint;

    /* read ADC configuration from device */
    error_code = radar_get_adc_configuration(radar_driver,
 8023e1c:	4608      	mov	r0, r1
 8023e1e:	a902      	add	r1, sp, #8
                                       Radar_Handle_t radar_driver)
{
    uint16_t error_code;
    Adc_Configuration_t adc_configuration;

    adc_endpoint = endpoint;
 8023e20:	701d      	strb	r5, [r3, #0]

    /* read ADC configuration from device */
    error_code = radar_get_adc_configuration(radar_driver,
 8023e22:	f7fc fc47 	bl	80206b4 <radar_get_adc_configuration>
                                             &adc_configuration);

    if (error_code == RADAR_ERR_OK)
 8023e26:	4604      	mov	r4, r0
 8023e28:	bb08      	cbnz	r0, 8023e6e <send_adc_configuration+0x5a>
    {
        uint8_t message[7];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_CONFIGURATION);
        wr_payload_u32(message, 1, adc_configuration.samplerate_Hz);
 8023e2a:	9b02      	ldr	r3, [sp, #8]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023e2c:	f89d 200d 	ldrb.w	r2, [sp, #13]
 8023e30:	f89d 600c 	ldrb.w	r6, [sp, #12]
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8023e34:	f88d 3001 	strb.w	r3, [sp, #1]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023e38:	ea4f 6e13 	mov.w	lr, r3, lsr #24
        wr_payload_u8 (message, 5, adc_configuration.resolution);
        wr_payload_u8 (message, 6, adc_configuration.use_post_calibration);

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 8023e3c:	4628      	mov	r0, r5
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023e3e:	0c1f      	lsrs	r7, r3, #16
 8023e40:	2107      	movs	r1, #7
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023e42:	0a1b      	lsrs	r3, r3, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023e44:	2501      	movs	r5, #1
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023e46:	f88d e004 	strb.w	lr, [sp, #4]
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023e4a:	f88d 3002 	strb.w	r3, [sp, #2]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023e4e:	f88d 2006 	strb.w	r2, [sp, #6]

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023e52:	f88d 7003 	strb.w	r7, [sp, #3]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023e56:	f88d 5000 	strb.w	r5, [sp]
 8023e5a:	f88d 6005 	strb.w	r6, [sp, #5]
 8023e5e:	f001 f9c7 	bl	80251f0 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 8023e62:	4668      	mov	r0, sp
 8023e64:	2107      	movs	r1, #7
 8023e66:	f001 f9d7 	bl	8025218 <protocol_send_payload>
        protocol_send_tail();
 8023e6a:	f001 f9d7 	bl	802521c <protocol_send_tail>
    }
    return error_code;
}
 8023e6e:	4620      	mov	r0, r4
 8023e70:	b005      	add	sp, #20
 8023e72:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8023e74:	1ffe9804 	.word	0x1ffe9804

08023e78 <ep_radar_adcxmc_handle_message>:

uint16_t ep_radar_adcxmc_handle_message(uint8_t endpoint,
                                        uint8_t* message_data,
                                        uint16_t num_bytes,
                                        void* context)
{
 8023e78:	b5f0      	push	{r4, r5, r6, r7, lr}
 8023e7a:	4605      	mov	r5, r0
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (message_data[0])
 8023e7c:	7808      	ldrb	r0, [r1, #0]

uint16_t ep_radar_adcxmc_handle_message(uint8_t endpoint,
                                        uint8_t* message_data,
                                        uint16_t num_bytes,
                                        void* context)
{
 8023e7e:	b087      	sub	sp, #28
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (message_data[0])
 8023e80:	b328      	cbz	r0, 8023ece <ep_radar_adcxmc_handle_message+0x56>
 8023e82:	2801      	cmp	r0, #1
 8023e84:	d004      	beq.n	8023e90 <ep_radar_adcxmc_handle_message+0x18>
        break;

    default:
        break;
    }
    return PROTOCOL_STATUS_INVALID_PAYLOAD;
 8023e86:	f64f 74ff 	movw	r4, #65535	; 0xffff
}
 8023e8a:	4620      	mov	r0, r4
 8023e8c:	b007      	add	sp, #28
 8023e8e:	bdf0      	pop	{r4, r5, r6, r7, pc}
            return send_adc_configuration(endpoint, radar_driver);
        }
        break;

    case MSG_SET_CONFIGURATION:
        if (num_bytes == 7)
 8023e90:	2a07      	cmp	r2, #7
 8023e92:	d1f8      	bne.n	8023e86 <ep_radar_adcxmc_handle_message+0xe>
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 8023e94:	78cc      	ldrb	r4, [r1, #3]
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 8023e96:	790a      	ldrb	r2, [r1, #4]
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
            ((uint32_t)payload[offset    ]);
 8023e98:	7848      	ldrb	r0, [r1, #1]

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 8023e9a:	788e      	ldrb	r6, [r1, #2]
            unsigned error_code;
            Adc_Configuration_t config;

            /* extract parameters from message */
            config.samplerate_Hz        = rd_payload_u32(message_data, 1);
            config.resolution           = rd_payload_u8 (message_data, 5);
 8023e9c:	794f      	ldrb	r7, [r1, #5]
            config.use_post_calibration = rd_payload_u8 (message_data, 6);
 8023e9e:	798d      	ldrb	r5, [r1, #6]

            /* apply ADC configuration */
            error_code = radar_set_adc_configuration(radar_driver, &config);
 8023ea0:	9301      	str	r3, [sp, #4]
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 8023ea2:	0421      	lsls	r1, r4, #16
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 8023ea4:	ea41 6202 	orr.w	r2, r1, r2, lsl #24
 8023ea8:	4302      	orrs	r2, r0
 8023eaa:	ea42 2206 	orr.w	r2, r2, r6, lsl #8
 8023eae:	a904      	add	r1, sp, #16
 8023eb0:	4618      	mov	r0, r3
            unsigned error_code;
            Adc_Configuration_t config;

            /* extract parameters from message */
            config.samplerate_Hz        = rd_payload_u32(message_data, 1);
            config.resolution           = rd_payload_u8 (message_data, 5);
 8023eb2:	f88d 7014 	strb.w	r7, [sp, #20]
        {
            unsigned error_code;
            Adc_Configuration_t config;

            /* extract parameters from message */
            config.samplerate_Hz        = rd_payload_u32(message_data, 1);
 8023eb6:	9204      	str	r2, [sp, #16]
            config.resolution           = rd_payload_u8 (message_data, 5);
            config.use_post_calibration = rd_payload_u8 (message_data, 6);
 8023eb8:	f88d 5015 	strb.w	r5, [sp, #21]

            /* apply ADC configuration */
            error_code = radar_set_adc_configuration(radar_driver, &config);
 8023ebc:	f7fc fbac 	bl	8020618 <radar_set_adc_configuration>

            /* inform other endpoints of the change */
            protocol_broadcast_change(radar_driver,
 8023ec0:	9b01      	ldr	r3, [sp, #4]
            config.samplerate_Hz        = rd_payload_u32(message_data, 1);
            config.resolution           = rd_payload_u8 (message_data, 5);
            config.use_post_calibration = rd_payload_u8 (message_data, 6);

            /* apply ADC configuration */
            error_code = radar_set_adc_configuration(radar_driver, &config);
 8023ec2:	4604      	mov	r4, r0

            /* inform other endpoints of the change */
            protocol_broadcast_change(radar_driver,
 8023ec4:	2104      	movs	r1, #4
 8023ec6:	4618      	mov	r0, r3
 8023ec8:	f001 fb68 	bl	802559c <protocol_broadcast_change>
 8023ecc:	e7dd      	b.n	8023e8a <ep_radar_adcxmc_handle_message+0x12>
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (message_data[0])
    {
    case MSG_GET_CONFIGURATION:
        if (num_bytes == 1)
 8023ece:	2a01      	cmp	r2, #1
 8023ed0:	d1d9      	bne.n	8023e86 <ep_radar_adcxmc_handle_message+0xe>
                                       Radar_Handle_t radar_driver)
{
    uint16_t error_code;
    Adc_Configuration_t adc_configuration;

    adc_endpoint = endpoint;
 8023ed2:	4c16      	ldr	r4, [pc, #88]	; (8023f2c <ep_radar_adcxmc_handle_message+0xb4>)
 8023ed4:	9201      	str	r2, [sp, #4]

    /* read ADC configuration from device */
    error_code = radar_get_adc_configuration(radar_driver,
 8023ed6:	4618      	mov	r0, r3
 8023ed8:	a904      	add	r1, sp, #16
                                       Radar_Handle_t radar_driver)
{
    uint16_t error_code;
    Adc_Configuration_t adc_configuration;

    adc_endpoint = endpoint;
 8023eda:	7025      	strb	r5, [r4, #0]

    /* read ADC configuration from device */
    error_code = radar_get_adc_configuration(radar_driver,
 8023edc:	f7fc fbea 	bl	80206b4 <radar_get_adc_configuration>
                                             &adc_configuration);

    if (error_code == RADAR_ERR_OK)
 8023ee0:	9a01      	ldr	r2, [sp, #4]
 8023ee2:	4604      	mov	r4, r0
 8023ee4:	2800      	cmp	r0, #0
 8023ee6:	d1d0      	bne.n	8023e8a <ep_radar_adcxmc_handle_message+0x12>
    {
        uint8_t message[7];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_CONFIGURATION);
        wr_payload_u32(message, 1, adc_configuration.samplerate_Hz);
 8023ee8:	9b04      	ldr	r3, [sp, #16]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023eea:	f89d 7014 	ldrb.w	r7, [sp, #20]
 8023eee:	f89d 6015 	ldrb.w	r6, [sp, #21]
 8023ef2:	f88d 2008 	strb.w	r2, [sp, #8]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023ef6:	ea4f 6e13 	mov.w	lr, r3, lsr #24
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023efa:	0a1a      	lsrs	r2, r3, #8
        wr_payload_u8 (message, 5, adc_configuration.resolution);
        wr_payload_u8 (message, 6, adc_configuration.use_post_calibration);

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 8023efc:	4628      	mov	r0, r5
 8023efe:	2107      	movs	r1, #7

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023f00:	0c1d      	lsrs	r5, r3, #16
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8023f02:	f88d 3009 	strb.w	r3, [sp, #9]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023f06:	f88d e00c 	strb.w	lr, [sp, #12]
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023f0a:	f88d 200a 	strb.w	r2, [sp, #10]

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023f0e:	f88d 500b 	strb.w	r5, [sp, #11]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023f12:	f88d 700d 	strb.w	r7, [sp, #13]
 8023f16:	f88d 600e 	strb.w	r6, [sp, #14]
 8023f1a:	f001 f969 	bl	80251f0 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 8023f1e:	a802      	add	r0, sp, #8
 8023f20:	2107      	movs	r1, #7
 8023f22:	f001 f979 	bl	8025218 <protocol_send_payload>
        protocol_send_tail();
 8023f26:	f001 f979 	bl	802521c <protocol_send_tail>
    switch (message_data[0])
    {
    case MSG_GET_CONFIGURATION:
        if (num_bytes == 1)
        {
            return send_adc_configuration(endpoint, radar_driver);
 8023f2a:	e7ae      	b.n	8023e8a <ep_radar_adcxmc_handle_message+0x12>
 8023f2c:	1ffe9804 	.word	0x1ffe9804

08023f30 <ep_radar_adcxmc_handle_change>:
void ep_radar_adcxmc_handle_change(uint8_t endpoint, void* context,
                                   uint32_t what)
{
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    if (what == EP_RADAR_CHNG_ADC_SETTINGS)
 8023f30:	2a04      	cmp	r2, #4
 8023f32:	d000      	beq.n	8023f36 <ep_radar_adcxmc_handle_change+0x6>
 8023f34:	4770      	bx	lr
    return PROTOCOL_STATUS_INVALID_PAYLOAD;
}

void ep_radar_adcxmc_handle_change(uint8_t endpoint, void* context,
                                   uint32_t what)
{
 8023f36:	b5f0      	push	{r4, r5, r6, r7, lr}
                                       Radar_Handle_t radar_driver)
{
    uint16_t error_code;
    Adc_Configuration_t adc_configuration;

    adc_endpoint = endpoint;
 8023f38:	4b15      	ldr	r3, [pc, #84]	; (8023f90 <ep_radar_adcxmc_handle_change+0x60>)
    return PROTOCOL_STATUS_INVALID_PAYLOAD;
}

void ep_radar_adcxmc_handle_change(uint8_t endpoint, void* context,
                                   uint32_t what)
{
 8023f3a:	b085      	sub	sp, #20
 8023f3c:	4604      	mov	r4, r0
    Adc_Configuration_t adc_configuration;

    adc_endpoint = endpoint;

    /* read ADC configuration from device */
    error_code = radar_get_adc_configuration(radar_driver,
 8023f3e:	4608      	mov	r0, r1
 8023f40:	a902      	add	r1, sp, #8
                                       Radar_Handle_t radar_driver)
{
    uint16_t error_code;
    Adc_Configuration_t adc_configuration;

    adc_endpoint = endpoint;
 8023f42:	701c      	strb	r4, [r3, #0]

    /* read ADC configuration from device */
    error_code = radar_get_adc_configuration(radar_driver,
 8023f44:	f7fc fbb6 	bl	80206b4 <radar_get_adc_configuration>
                                             &adc_configuration);

    if (error_code == RADAR_ERR_OK)
 8023f48:	bb00      	cbnz	r0, 8023f8c <ep_radar_adcxmc_handle_change+0x5c>
    {
        uint8_t message[7];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_CONFIGURATION);
        wr_payload_u32(message, 1, adc_configuration.samplerate_Hz);
 8023f4a:	9b02      	ldr	r3, [sp, #8]
 8023f4c:	f89d 200d 	ldrb.w	r2, [sp, #13]
 8023f50:	f89d 500c 	ldrb.w	r5, [sp, #12]
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8023f54:	f88d 3001 	strb.w	r3, [sp, #1]
        wr_payload_u8 (message, 5, adc_configuration.resolution);
        wr_payload_u8 (message, 6, adc_configuration.use_post_calibration);

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 8023f58:	4620      	mov	r0, r4
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023f5a:	0e1f      	lsrs	r7, r3, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023f5c:	0c1e      	lsrs	r6, r3, #16
 8023f5e:	2107      	movs	r1, #7
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023f60:	0a1b      	lsrs	r3, r3, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023f62:	2401      	movs	r4, #1
static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023f64:	f88d 3002 	strb.w	r3, [sp, #2]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023f68:	f88d 2006 	strb.w	r2, [sp, #6]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023f6c:	f88d 7004 	strb.w	r7, [sp, #4]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023f70:	f88d 6003 	strb.w	r6, [sp, #3]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023f74:	f88d 4000 	strb.w	r4, [sp]
 8023f78:	f88d 5005 	strb.w	r5, [sp, #5]
 8023f7c:	f001 f938 	bl	80251f0 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 8023f80:	4668      	mov	r0, sp
 8023f82:	2107      	movs	r1, #7
 8023f84:	f001 f948 	bl	8025218 <protocol_send_payload>
        protocol_send_tail();
 8023f88:	f001 f948 	bl	802521c <protocol_send_tail>
{
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    if (what == EP_RADAR_CHNG_ADC_SETTINGS)
        send_adc_configuration(endpoint, radar_driver);
}
 8023f8c:	b005      	add	sp, #20
 8023f8e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8023f90:	1ffe9804 	.word	0x1ffe9804

08023f94 <ep_radar_base_handle_message>:
==============================================================================
*/

uint16_t ep_radar_base_handle_message(uint8_t endpoint, uint8_t* message_data,
                                      uint16_t num_bytes, void* context)
{
 8023f94:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (message_data[0])
 8023f98:	780e      	ldrb	r6, [r1, #0]
==============================================================================
*/

uint16_t ep_radar_base_handle_message(uint8_t endpoint, uint8_t* message_data,
                                      uint16_t num_bytes, void* context)
{
 8023f9a:	4680      	mov	r8, r0
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (message_data[0])
 8023f9c:	1e70      	subs	r0, r6, #1
==============================================================================
*/

uint16_t ep_radar_base_handle_message(uint8_t endpoint, uint8_t* message_data,
                                      uint16_t num_bytes, void* context)
{
 8023f9e:	b09f      	sub	sp, #124	; 0x7c
 8023fa0:	4615      	mov	r5, r2
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (message_data[0])
 8023fa2:	2841      	cmp	r0, #65	; 0x41
 8023fa4:	d846      	bhi.n	8024034 <ep_radar_base_handle_message+0xa0>
 8023fa6:	e8df f010 	tbh	[pc, r0, lsl #1]
 8023faa:	004b      	.short	0x004b
 8023fac:	01280116 	.word	0x01280116
 8023fb0:	00450045 	.word	0x00450045
 8023fb4:	00450045 	.word	0x00450045
 8023fb8:	00450045 	.word	0x00450045
 8023fbc:	00450045 	.word	0x00450045
 8023fc0:	00450045 	.word	0x00450045
 8023fc4:	00450045 	.word	0x00450045
 8023fc8:	00450045 	.word	0x00450045
 8023fcc:	00450045 	.word	0x00450045
 8023fd0:	00450045 	.word	0x00450045
 8023fd4:	00450045 	.word	0x00450045
 8023fd8:	00450045 	.word	0x00450045
 8023fdc:	00450045 	.word	0x00450045
 8023fe0:	00450045 	.word	0x00450045
 8023fe4:	00450045 	.word	0x00450045
 8023fe8:	0045013f 	.word	0x0045013f
 8023fec:	0045015d 	.word	0x0045015d
 8023ff0:	00450045 	.word	0x00450045
 8023ff4:	00450045 	.word	0x00450045
 8023ff8:	00450045 	.word	0x00450045
 8023ffc:	00450045 	.word	0x00450045
 8024000:	00450045 	.word	0x00450045
 8024004:	00450045 	.word	0x00450045
 8024008:	004501c2 	.word	0x004501c2
 802400c:	004501d8 	.word	0x004501d8
 8024010:	00450201 	.word	0x00450201
 8024014:	00450215 	.word	0x00450215
 8024018:	00450045 	.word	0x00450045
 802401c:	00450045 	.word	0x00450045
 8024020:	00450045 	.word	0x00450045
 8024024:	00450045 	.word	0x00450045
 8024028:	027b023a 	.word	0x027b023a
 802402c:	0042      	.short	0x0042

            return error_code;
        }
        break;
    case MSG_GET_FFT_INFO:
		if (num_bytes == 1)
 802402e:	2d01      	cmp	r5, #1
 8024030:	f000 8266 	beq.w	8024500 <ep_radar_base_handle_message+0x56c>
		break;

    default:
        break;
    }
    return PROTOCOL_STATUS_INVALID_PAYLOAD;
 8024034:	f64f 74ff 	movw	r4, #65535	; 0xffff
}
 8024038:	4620      	mov	r0, r4
 802403a:	b01f      	add	sp, #124	; 0x7c
 802403c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (message_data[0])
    {
    case MSG_GET_FRAME_DATA:
        if (num_bytes == 2)
 8024040:	2d02      	cmp	r5, #2
 8024042:	d1f7      	bne.n	8024034 <ep_radar_base_handle_message+0xa0>
    uint16_t error_code;

    Frame_Info_t frame_info;

    /* get frame data */
    error_code = radar_get_frame(radar_driver, &frame_info, wait);
 8024044:	784a      	ldrb	r2, [r1, #1]
 8024046:	4618      	mov	r0, r3
 8024048:	a917      	add	r1, sp, #92	; 0x5c
 802404a:	f7fc fc85 	bl	8020958 <radar_get_frame>

    if (error_code == RADAR_ERR_OK)
 802404e:	900b      	str	r0, [sp, #44]	; 0x2c
 8024050:	2800      	cmp	r0, #0
 8024052:	f040 80be 	bne.w	80241d2 <ep_radar_base_handle_message+0x23e>
        uint8_t message_header[18];
        uint32_t sample_start = 0;

        uint32_t num_used_ant = 2;

        if (frame_info.adc_resolution == 12)
 8024056:	f89d 4075 	ldrb.w	r4, [sp, #117]	; 0x75
 802405a:	2c0c      	cmp	r4, #12
 802405c:	f000 8314 	beq.w	8024688 <ep_radar_base_handle_message+0x6f4>
 8024060:	46a9      	mov	r9, r5
        uint32_t num_samples;
        uint32_t data_size;
        uint8_t message_header[18];
        uint32_t sample_start = 0;

        uint32_t num_used_ant = 2;
 8024062:	4629      	mov	r1, r5
 8024064:	f89d c074 	ldrb.w	ip, [sp, #116]	; 0x74

        /* send message containing frame data */
        uint32_t num_samples;
        uint32_t data_size;
        uint8_t message_header[18];
        uint32_t sample_start = 0;
 8024068:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 802406a:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 802406c:	9a19      	ldr	r2, [sp, #100]	; 0x64
 802406e:	f89d e077 	ldrb.w	lr, [sp, #119]	; 0x77
 8024072:	f88d 9051 	strb.w	r9, [sp, #81]	; 0x51
        /* calculate size of data */
        /* calculate total number of bits and divide by 8 to get number of
           bytes. Always round upwards */
        num_samples = frame_info.num_chirps *
                      frame_info.num_samples_per_chirp *
                      num_used_ant *
 8024076:	f1be 0f00 	cmp.w	lr, #0
        wr_payload_u8 (message_header, 17, frame_info.interleaved_rx);

        /* calculate size of data */
        /* calculate total number of bits and divide by 8 to get number of
           bytes. Always round upwards */
        num_samples = frame_info.num_chirps *
 802407a:	fb02 f603 	mul.w	r6, r2, r3
                      frame_info.num_samples_per_chirp *
                      num_used_ant *
 802407e:	bf0c      	ite	eq
 8024080:	2001      	moveq	r0, #1
 8024082:	2002      	movne	r0, #2

        /* calculate size of data */
        /* calculate total number of bits and divide by 8 to get number of
           bytes. Always round upwards */
        num_samples = frame_info.num_chirps *
                      frame_info.num_samples_per_chirp *
 8024084:	fb01 f106 	mul.w	r1, r1, r6
        wr_payload_u8 (message_header, 17, frame_info.interleaved_rx);

        /* calculate size of data */
        /* calculate total number of bits and divide by 8 to get number of
           bytes. Always round upwards */
        num_samples = frame_info.num_chirps *
 8024088:	fb00 f601 	mul.w	r6, r0, r1
                      frame_info.num_samples_per_chirp *
                      num_used_ant *
                      (frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);

        data_size = num_samples * frame_info.adc_resolution;
 802408c:	fb04 f006 	mul.w	r0, r4, r6
        data_size = (data_size >> 3) + ((data_size & 0x07) ? 1 : 0);
 8024090:	f010 0107 	ands.w	r1, r0, #7
 8024094:	bf18      	it	ne
 8024096:	2101      	movne	r1, #1
 8024098:	eb01 01d0 	add.w	r1, r1, r0, lsr #3
						(frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);
			}
        }
        /* setup message header */
        wr_payload_u8 (message_header,  0, MSG_FRAME_DATA);
        wr_payload_u32(message_header,  1, frame_info.frame_number);
 802409c:	9818      	ldr	r0, [sp, #96]	; 0x60
 802409e:	f88d c056 	strb.w	ip, [sp, #86]	; 0x56

        data_size = num_samples * frame_info.adc_resolution;
        data_size = (data_size >> 3) + ((data_size & 0x07) ? 1 : 0);

        /* send message header */
        protocol_send_header(endpoint, data_size + sizeof(message_header));
 80240a2:	b289      	uxth	r1, r1
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 80240a4:	ea4f 6910 	mov.w	r9, r0, lsr #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 80240a8:	ea4f 4c10 	mov.w	ip, r0, lsr #16
 80240ac:	910e      	str	r1, [sp, #56]	; 0x38
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80240ae:	f88d e057 	strb.w	lr, [sp, #87]	; 0x57
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 80240b2:	f88d 0049 	strb.w	r0, [sp, #73]	; 0x49
static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 80240b6:	ea4f 2e10 	mov.w	lr, r0, lsr #8
 80240ba:	3112      	adds	r1, #18
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 80240bc:	0e10      	lsrs	r0, r2, #24
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80240be:	f89d 7076 	ldrb.w	r7, [sp, #118]	; 0x76
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 80240c2:	f88d 204d 	strb.w	r2, [sp, #77]	; 0x4d
 80240c6:	b289      	uxth	r1, r1
 80240c8:	f88d 3052 	strb.w	r3, [sp, #82]	; 0x52
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80240cc:	f88d 4058 	strb.w	r4, [sp, #88]	; 0x58
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 80240d0:	f88d 904c 	strb.w	r9, [sp, #76]	; 0x4c
    payload[offset + 2] = (value >> 16) & 0xFF;
 80240d4:	f88d c04b 	strb.w	ip, [sp, #75]	; 0x4b
 80240d8:	ea4f 4912 	mov.w	r9, r2, lsr #16
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 80240dc:	ea4f 6c13 	mov.w	ip, r3, lsr #24
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 80240e0:	0a12      	lsrs	r2, r2, #8
 80240e2:	f88d e04a 	strb.w	lr, [sp, #74]	; 0x4a
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 80240e6:	f88d 0050 	strb.w	r0, [sp, #80]	; 0x50
    payload[offset + 2] = (value >> 16) & 0xFF;
 80240ea:	ea4f 4e13 	mov.w	lr, r3, lsr #16
 80240ee:	4640      	mov	r0, r8
    payload[offset + 1] = (value >>  8) & 0xFF;
 80240f0:	0a1b      	lsrs	r3, r3, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80240f2:	2400      	movs	r4, #0
static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 80240f4:	f88d 204e 	strb.w	r2, [sp, #78]	; 0x4e
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 80240f8:	f88d c055 	strb.w	ip, [sp, #85]	; 0x55
    payload[offset + 2] = (value >> 16) & 0xFF;
 80240fc:	f88d e054 	strb.w	lr, [sp, #84]	; 0x54
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024100:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024104:	f88d 4048 	strb.w	r4, [sp, #72]	; 0x48

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024108:	f88d 904f 	strb.w	r9, [sp, #79]	; 0x4f
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802410c:	f88d 7059 	strb.w	r7, [sp, #89]	; 0x59
 8024110:	f001 f86e 	bl	80251f0 <protocol_send_header>
        protocol_send_payload(message_header, sizeof(message_header));
 8024114:	a812      	add	r0, sp, #72	; 0x48
 8024116:	2112      	movs	r1, #18
 8024118:	f001 f87e 	bl	8025218 <protocol_send_payload>

        if (frame_info.adc_resolution == 12)
 802411c:	f89d a075 	ldrb.w	sl, [sp, #117]	; 0x75
 8024120:	f1ba 0f0c 	cmp.w	sl, #12
 8024124:	f000 8223 	beq.w	802456e <ep_radar_base_handle_message+0x5da>
			protocol_send_payload((uint8_t*)transport_buffer, data_size);
        }

        else
        {
             uint16_t sample_bit_mask = (1 << frame_info.adc_resolution) - 1;
 8024128:	2701      	movs	r7, #1
 802412a:	fa07 f70a 	lsl.w	r7, r7, sl
 802412e:	3f01      	subs	r7, #1
 			 uint16_t sample_bit_stream = 0;
 8024130:	f8ad 4040 	strh.w	r4, [sp, #64]	; 0x40
			protocol_send_payload((uint8_t*)transport_buffer, data_size);
        }

        else
        {
             uint16_t sample_bit_mask = (1 << frame_info.adc_resolution) - 1;
 8024134:	b2bf      	uxth	r7, r7
 			 uint16_t sample_bit_stream = 0;
			 uint16_t write_bit_position = 0;

			 for (unsigned i = 0; i < num_samples; ++i)
 8024136:	b33e      	cbz	r6, 8024188 <ep_radar_base_handle_message+0x1f4>
 8024138:	006d      	lsls	r5, r5, #1
 802413a:	4622      	mov	r2, r4
 802413c:	46a1      	mov	r9, r4
 802413e:	e001      	b.n	8024144 <ep_radar_base_handle_message+0x1b0>
 8024140:	f89d a075 	ldrb.w	sl, [sp, #117]	; 0x75
			 {
				const uint16_t* unpacked_data = &((uint16_t*)frame_info.sample_data)[sample_start];
				 sample_bit_stream |= (unpacked_data[i] & sample_bit_mask) <<
 8024144:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8024146:	5b5b      	ldrh	r3, [r3, r5]
 8024148:	403b      	ands	r3, r7
									   write_bit_position;
				 write_bit_position += frame_info.adc_resolution;
 802414a:	4492      	add	sl, r2
			 uint16_t write_bit_position = 0;

			 for (unsigned i = 0; i < num_samples; ++i)
			 {
				const uint16_t* unpacked_data = &((uint16_t*)frame_info.sample_data)[sample_start];
				 sample_bit_stream |= (unpacked_data[i] & sample_bit_mask) <<
 802414c:	4093      	lsls	r3, r2
 802414e:	431c      	orrs	r4, r3
									   write_bit_position;
				 write_bit_position += frame_info.adc_resolution;

				 protocol_send_payload((uint8_t*)&sample_bit_stream,
 8024150:	f3ca 01cf 	ubfx	r1, sl, #3, #16
 8024154:	a810      	add	r0, sp, #64	; 0x40
			 uint16_t write_bit_position = 0;

			 for (unsigned i = 0; i < num_samples; ++i)
			 {
				const uint16_t* unpacked_data = &((uint16_t*)frame_info.sample_data)[sample_start];
				 sample_bit_stream |= (unpacked_data[i] & sample_bit_mask) <<
 8024156:	f8ad 4040 	strh.w	r4, [sp, #64]	; 0x40
									   write_bit_position;
				 write_bit_position += frame_info.adc_resolution;

				 protocol_send_payload((uint8_t*)&sample_bit_stream,
 802415a:	f001 f85d 	bl	8025218 <protocol_send_payload>
									   write_bit_position >> 3);
				 sample_bit_stream >>= write_bit_position & 0xF8;
 802415e:	f8bd 4040 	ldrh.w	r4, [sp, #64]	; 0x40
 8024162:	f00a 03f8 	and.w	r3, sl, #248	; 0xf8
 8024166:	411c      	asrs	r4, r3
        {
             uint16_t sample_bit_mask = (1 << frame_info.adc_resolution) - 1;
 			 uint16_t sample_bit_stream = 0;
			 uint16_t write_bit_position = 0;

			 for (unsigned i = 0; i < num_samples; ++i)
 8024168:	f109 0901 	add.w	r9, r9, #1
									   write_bit_position;
				 write_bit_position += frame_info.adc_resolution;

				 protocol_send_payload((uint8_t*)&sample_bit_stream,
									   write_bit_position >> 3);
				 sample_bit_stream >>= write_bit_position & 0xF8;
 802416c:	b2a4      	uxth	r4, r4
        {
             uint16_t sample_bit_mask = (1 << frame_info.adc_resolution) - 1;
 			 uint16_t sample_bit_stream = 0;
			 uint16_t write_bit_position = 0;

			 for (unsigned i = 0; i < num_samples; ++i)
 802416e:	45b1      	cmp	r9, r6
 8024170:	f105 0502 	add.w	r5, r5, #2
				 write_bit_position += frame_info.adc_resolution;

				 protocol_send_payload((uint8_t*)&sample_bit_stream,
									   write_bit_position >> 3);
				 sample_bit_stream >>= write_bit_position & 0xF8;
				 write_bit_position &= 0x07;
 8024174:	f00a 0207 	and.w	r2, sl, #7
									   write_bit_position;
				 write_bit_position += frame_info.adc_resolution;

				 protocol_send_payload((uint8_t*)&sample_bit_stream,
									   write_bit_position >> 3);
				 sample_bit_stream >>= write_bit_position & 0xF8;
 8024178:	f8ad 4040 	strh.w	r4, [sp, #64]	; 0x40
        {
             uint16_t sample_bit_mask = (1 << frame_info.adc_resolution) - 1;
 			 uint16_t sample_bit_stream = 0;
			 uint16_t write_bit_position = 0;

			 for (unsigned i = 0; i < num_samples; ++i)
 802417c:	d1e0      	bne.n	8024140 <ep_radar_base_handle_message+0x1ac>
				 protocol_send_payload((uint8_t*)&sample_bit_stream,
									   write_bit_position >> 3);
				 sample_bit_stream >>= write_bit_position & 0xF8;
				 write_bit_position &= 0x07;
			 }
			 if (write_bit_position != 0)
 802417e:	b11a      	cbz	r2, 8024188 <ep_radar_base_handle_message+0x1f4>
				 protocol_send_payload((uint8_t*)&sample_bit_stream, 1);
 8024180:	a810      	add	r0, sp, #64	; 0x40
 8024182:	2101      	movs	r1, #1
 8024184:	f001 f848 	bl	8025218 <protocol_send_payload>

        /* send another message, containing the temperature */
        {
            // Send the temperature, only when the value is changing!
        	static int32_t previous_temp = 0;
            if( frame_info.temperature_001C != previous_temp )
 8024188:	4cc4      	ldr	r4, [pc, #784]	; (802449c <ep_radar_base_handle_message+0x508>)
			 if (write_bit_position != 0)
				 protocol_send_payload((uint8_t*)&sample_bit_stream, 1);
        }


        protocol_send_tail();
 802418a:	f001 f847 	bl	802521c <protocol_send_tail>

        /* send another message, containing the temperature */
        {
            // Send the temperature, only when the value is changing!
        	static int32_t previous_temp = 0;
            if( frame_info.temperature_001C != previous_temp )
 802418e:	6822      	ldr	r2, [r4, #0]
 8024190:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8024192:	4293      	cmp	r3, r2
 8024194:	d01d      	beq.n	80241d2 <ep_radar_base_handle_message+0x23e>
}

static inline void wr_payload_i32(uint8_t* payload, uint16_t offset,
                                  int32_t value)
{
    payload[offset + 3] = (((uint32_t)value) >> 24) & 0xFF;
 8024196:	0e1e      	lsrs	r6, r3, #24
    payload[offset + 2] = (((uint32_t)value) >> 16) & 0xFF;
 8024198:	0c1d      	lsrs	r5, r3, #16
    payload[offset + 1] = (((uint32_t)value) >>  8) & 0xFF;
 802419a:	0a1a      	lsrs	r2, r3, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802419c:	f04f 0e31 	mov.w	lr, #49	; 0x31
				wr_payload_u8 (message, 0, MSG_SET_TEMPRATURE);
				wr_payload_u8 (message, 1, 0);
				wr_payload_i32(message, 2, frame_info.temperature_001C);

				/* send message */
				protocol_send_header(endpoint, sizeof(message));
 80241a0:	4640      	mov	r0, r8
 80241a2:	2106      	movs	r1, #6
 80241a4:	2700      	movs	r7, #0
                                  int32_t value)
{
    payload[offset + 3] = (((uint32_t)value) >> 24) & 0xFF;
    payload[offset + 2] = (((uint32_t)value) >> 16) & 0xFF;
    payload[offset + 1] = (((uint32_t)value) >>  8) & 0xFF;
    payload[offset    ] =  ((uint32_t)value)        & 0xFF;
 80241a6:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80241aa:	f88d e040 	strb.w	lr, [sp, #64]	; 0x40
static inline void wr_payload_i32(uint8_t* payload, uint16_t offset,
                                  int32_t value)
{
    payload[offset + 3] = (((uint32_t)value) >> 24) & 0xFF;
    payload[offset + 2] = (((uint32_t)value) >> 16) & 0xFF;
    payload[offset + 1] = (((uint32_t)value) >>  8) & 0xFF;
 80241ae:	f88d 2043 	strb.w	r2, [sp, #67]	; 0x43
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80241b2:	f88d 7041 	strb.w	r7, [sp, #65]	; 0x41
}

static inline void wr_payload_i32(uint8_t* payload, uint16_t offset,
                                  int32_t value)
{
    payload[offset + 3] = (((uint32_t)value) >> 24) & 0xFF;
 80241b6:	f88d 6045 	strb.w	r6, [sp, #69]	; 0x45
    payload[offset + 2] = (((uint32_t)value) >> 16) & 0xFF;
 80241ba:	f88d 5044 	strb.w	r5, [sp, #68]	; 0x44
 80241be:	f001 f817 	bl	80251f0 <protocol_send_header>
				protocol_send_payload(message, sizeof(message));
 80241c2:	a810      	add	r0, sp, #64	; 0x40
 80241c4:	2106      	movs	r1, #6
 80241c6:	f001 f827 	bl	8025218 <protocol_send_payload>
				protocol_send_tail();
 80241ca:	f001 f827 	bl	802521c <protocol_send_tail>
				previous_temp = frame_info.temperature_001C;
 80241ce:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 80241d0:	6023      	str	r3, [r4, #0]
    uint16_t error_code;

    Frame_Info_t frame_info;

    /* get frame data */
    error_code = radar_get_frame(radar_driver, &frame_info, wait);
 80241d2:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
            uint8_t wait;

            /* extract parameters from message */
            wait = rd_payload_u8(message_data, 1);

            return send_frame_data(endpoint, radar_driver, wait);
 80241d4:	e730      	b.n	8024038 <ep_radar_base_handle_message+0xa4>
        }
        break;

    case MSG_SET_AUTOMATIC_TRIGGER:
        if (num_bytes == 5)
 80241d6:	2d05      	cmp	r5, #5
 80241d8:	f47f af2c 	bne.w	8024034 <ep_radar_base_handle_message+0xa0>
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 80241dc:	78ca      	ldrb	r2, [r1, #3]
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 80241de:	790c      	ldrb	r4, [r1, #4]
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
            ((uint32_t)payload[offset    ]);
 80241e0:	7848      	ldrb	r0, [r1, #1]

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 80241e2:	7889      	ldrb	r1, [r1, #2]
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 80241e4:	0412      	lsls	r2, r2, #16
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 80241e6:	ea42 6204 	orr.w	r2, r2, r4, lsl #24
 80241ea:	4302      	orrs	r2, r0

            /* extract parameters from message */
            frame_interval = rd_payload_u32(message_data, 1);

            /* apply new settings */
            error_code = radar_set_automatic_frame_trigger(radar_driver,
 80241ec:	ea42 2101 	orr.w	r1, r2, r1, lsl #8
 80241f0:	4618      	mov	r0, r3
 80241f2:	f7fc fbfd 	bl	80209f0 <radar_set_automatic_frame_trigger>
 80241f6:	4604      	mov	r4, r0
                                                           frame_interval);

            return error_code;
 80241f8:	e71e      	b.n	8024038 <ep_radar_base_handle_message+0xa4>
        }
        break;

    case MSG_ENABLE_TEST_MODE:
        if (num_bytes == 8)
 80241fa:	2d08      	cmp	r5, #8
 80241fc:	f47f af1a 	bne.w	8024034 <ep_radar_base_handle_message+0xa0>
           (((uint32_t)payload[offset + 2]) << 16) |
 8024200:	7948      	ldrb	r0, [r1, #5]
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 8024202:	798f      	ldrb	r7, [r1, #6]
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
            ((uint32_t)payload[offset    ]);
 8024204:	78cc      	ldrb	r4, [r1, #3]

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 8024206:	790e      	ldrb	r6, [r1, #4]
            rx_mask   = rd_payload_u8 (message_data, 2);
            frequency = rd_payload_u32(message_data, 3);
            tx_power  = rd_payload_u8 (message_data, 7);

            /* apply new settings */
            error_code = radar_test_antennas(radar_driver, tx_mask, rx_mask,
 8024208:	784d      	ldrb	r5, [r1, #1]
 802420a:	788a      	ldrb	r2, [r1, #2]
 802420c:	79c9      	ldrb	r1, [r1, #7]
 802420e:	9100      	str	r1, [sp, #0]
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 8024210:	0400      	lsls	r0, r0, #16
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 8024212:	ea40 6007 	orr.w	r0, r0, r7, lsl #24
 8024216:	4304      	orrs	r4, r0
 8024218:	4629      	mov	r1, r5
 802421a:	4618      	mov	r0, r3
 802421c:	ea44 2306 	orr.w	r3, r4, r6, lsl #8
 8024220:	f7fc fc28 	bl	8020a74 <radar_test_antennas>
 8024224:	4604      	mov	r4, r0
                                             frequency, tx_power);

            return error_code;
 8024226:	e707      	b.n	8024038 <ep_radar_base_handle_message+0xa4>
        }
        break;

    case MSG_GET_DRIVER_VERSION:
        if (num_bytes == 1)
 8024228:	2d01      	cmp	r5, #1
 802422a:	f47f af03 	bne.w	8024034 <ep_radar_base_handle_message+0xa0>
==============================================================================
*/

static void send_driver_version(uint8_t endpoint)
{
    const Driver_Version_t* driver_version = radar_get_driver_version();
 802422e:	f7fc fa4b 	bl	80206c8 <radar_get_driver_version>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024232:	2221      	movs	r2, #33	; 0x21
 8024234:	f88d 205c 	strb.w	r2, [sp, #92]	; 0x5c

    uint8_t message[4];

    /* compile message */
    wr_payload_u8(message, 0, MSG_SET_DRIVER_VERSION);
    wr_payload_u8(message, 1, driver_version->major);
 8024238:	7802      	ldrb	r2, [r0, #0]
 802423a:	f88d 205d 	strb.w	r2, [sp, #93]	; 0x5d
    wr_payload_u8(message, 2, driver_version->minor);
 802423e:	7842      	ldrb	r2, [r0, #1]
 8024240:	f88d 205e 	strb.w	r2, [sp, #94]	; 0x5e
==============================================================================
*/

static void send_driver_version(uint8_t endpoint)
{
    const Driver_Version_t* driver_version = radar_get_driver_version();
 8024244:	4603      	mov	r3, r0
    wr_payload_u8(message, 1, driver_version->major);
    wr_payload_u8(message, 2, driver_version->minor);
    wr_payload_u8(message, 3, driver_version->revision);

    /* send message */
    protocol_send_header(endpoint, sizeof(message));
 8024246:	2104      	movs	r1, #4

    /* compile message */
    wr_payload_u8(message, 0, MSG_SET_DRIVER_VERSION);
    wr_payload_u8(message, 1, driver_version->major);
    wr_payload_u8(message, 2, driver_version->minor);
    wr_payload_u8(message, 3, driver_version->revision);
 8024248:	789b      	ldrb	r3, [r3, #2]
 802424a:	f88d 305f 	strb.w	r3, [sp, #95]	; 0x5f

    /* send message */
    protocol_send_header(endpoint, sizeof(message));
 802424e:	4640      	mov	r0, r8
 8024250:	f000 ffce 	bl	80251f0 <protocol_send_header>
    protocol_send_payload(message, sizeof(message));
 8024254:	a817      	add	r0, sp, #92	; 0x5c
 8024256:	2104      	movs	r1, #4
 8024258:	f000 ffde 	bl	8025218 <protocol_send_payload>
        if (num_bytes == 1)
        {
            /* send driver version info back to host */
            send_driver_version(endpoint);

            return RADAR_ERR_OK;
 802425c:	2400      	movs	r4, #0
    wr_payload_u8(message, 3, driver_version->revision);

    /* send message */
    protocol_send_header(endpoint, sizeof(message));
    protocol_send_payload(message, sizeof(message));
    protocol_send_tail();
 802425e:	f000 ffdd 	bl	802521c <protocol_send_tail>
 8024262:	e6e9      	b.n	8024038 <ep_radar_base_handle_message+0xa4>
            return RADAR_ERR_OK;
        }
        break;

    case MSG_GET_DEVICE_INFO:
        if (num_bytes == 1)
 8024264:	2d01      	cmp	r5, #1
 8024266:	f47f aee5 	bne.w	8024034 <ep_radar_base_handle_message+0xa0>
{
    uint16_t error_code;
    Device_Info_t device_info;

    /* read device info from device */
    error_code = radar_get_device_info(radar_driver, &device_info);
 802426a:	4618      	mov	r0, r3
 802426c:	a917      	add	r1, sp, #92	; 0x5c
 802426e:	f7fc faa7 	bl	80207c0 <radar_get_device_info>

    if (error_code == RADAR_ERR_OK)
 8024272:	4604      	mov	r4, r0
 8024274:	2800      	cmp	r0, #0
 8024276:	f47f aedf 	bne.w	8024038 <ep_radar_base_handle_message+0xa4>
        uint16_t string_length;
        uint8_t message[17];

        /* compile message */
        wr_payload_u8 (message,  0, MSG_SET_DEVICE_INFO);
        wr_payload_u32(message,  1, device_info.min_rf_frequency_kHz);
 802427a:	9918      	ldr	r1, [sp, #96]	; 0x60
        wr_payload_u32(message,  5, device_info.max_rf_frequency_kHz);
 802427c:	9b19      	ldr	r3, [sp, #100]	; 0x64
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 802427e:	f88d 1049 	strb.w	r1, [sp, #73]	; 0x49
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024282:	ea4f 6b11 	mov.w	fp, r1, lsr #24
 8024286:	f88d b04c 	strb.w	fp, [sp, #76]	; 0x4c
    payload[offset + 2] = (value >> 16) & 0xFF;
 802428a:	ea4f 4b11 	mov.w	fp, r1, lsr #16
 802428e:	f88d b04b 	strb.w	fp, [sp, #75]	; 0x4b
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024292:	0a09      	lsrs	r1, r1, #8
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024294:	ea4f 6b13 	mov.w	fp, r3, lsr #24
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024298:	f89d 506e 	ldrb.w	r5, [sp, #110]	; 0x6e
static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 802429c:	f88d 104a 	strb.w	r1, [sp, #74]	; 0x4a
    payload[offset    ] =  value        & 0xFF;
 80242a0:	f88d 304d 	strb.w	r3, [sp, #77]	; 0x4d

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 80242a4:	0c19      	lsrs	r1, r3, #16
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 80242a6:	f88d b050 	strb.w	fp, [sp, #80]	; 0x50
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 80242aa:	0a1b      	lsrs	r3, r3, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80242ac:	f89d a068 	ldrb.w	sl, [sp, #104]	; 0x68
 80242b0:	f89d 9069 	ldrb.w	r9, [sp, #105]	; 0x69
 80242b4:	f89d c06a 	ldrb.w	ip, [sp, #106]	; 0x6a
 80242b8:	f89d e06b 	ldrb.w	lr, [sp, #107]	; 0x6b
 80242bc:	f89d 706c 	ldrb.w	r7, [sp, #108]	; 0x6c
 80242c0:	f89d 606d 	ldrb.w	r6, [sp, #109]	; 0x6d
 80242c4:	f89d 006f 	ldrb.w	r0, [sp, #111]	; 0x6f
        wr_payload_u8 (message, 15, device_info.interleaved_rx);
        wr_payload_u8 (message, 16, device_info.data_format);

        /* count string length (add 1 for the terminating 0) */
        string_length = 0;
        while (device_info.description[string_length] != 0)
 80242c8:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 80242ca:	f88d 5057 	strb.w	r5, [sp, #87]	; 0x57
 80242ce:	f04f 0b23 	mov.w	fp, #35	; 0x23

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 80242d2:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
    payload[offset + 1] = (value >>  8) & 0xFF;
 80242d6:	f88d 304e 	strb.w	r3, [sp, #78]	; 0x4e
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80242da:	f88d b048 	strb.w	fp, [sp, #72]	; 0x48
 80242de:	f88d a051 	strb.w	sl, [sp, #81]	; 0x51
 80242e2:	f88d 9052 	strb.w	r9, [sp, #82]	; 0x52
 80242e6:	f88d c053 	strb.w	ip, [sp, #83]	; 0x53
 80242ea:	f88d e054 	strb.w	lr, [sp, #84]	; 0x54
 80242ee:	f88d 7055 	strb.w	r7, [sp, #85]	; 0x55
 80242f2:	f88d 6056 	strb.w	r6, [sp, #86]	; 0x56
 80242f6:	f88d 0058 	strb.w	r0, [sp, #88]	; 0x58
 80242fa:	7813      	ldrb	r3, [r2, #0]
 80242fc:	4625      	mov	r5, r4
 80242fe:	b123      	cbz	r3, 802430a <ep_radar_base_handle_message+0x376>
            ++string_length;
 8024300:	3501      	adds	r5, #1
 8024302:	b2ad      	uxth	r5, r5
        wr_payload_u8 (message, 15, device_info.interleaved_rx);
        wr_payload_u8 (message, 16, device_info.data_format);

        /* count string length (add 1 for the terminating 0) */
        string_length = 0;
        while (device_info.description[string_length] != 0)
 8024304:	5d53      	ldrb	r3, [r2, r5]
 8024306:	2b00      	cmp	r3, #0
 8024308:	d1fa      	bne.n	8024300 <ep_radar_base_handle_message+0x36c>
            ++string_length;
        ++string_length;

        /* send message */
        protocol_send_header(endpoint, sizeof(message) + string_length);
 802430a:	f105 0112 	add.w	r1, r5, #18
 802430e:	4640      	mov	r0, r8
 8024310:	b289      	uxth	r1, r1
 8024312:	f000 ff6d 	bl	80251f0 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 8024316:	a812      	add	r0, sp, #72	; 0x48
 8024318:	2111      	movs	r1, #17
 802431a:	f000 ff7d 	bl	8025218 <protocol_send_payload>

        /* count string length (add 1 for the terminating 0) */
        string_length = 0;
        while (device_info.description[string_length] != 0)
            ++string_length;
        ++string_length;
 802431e:	1c69      	adds	r1, r5, #1

        /* send message */
        protocol_send_header(endpoint, sizeof(message) + string_length);
        protocol_send_payload(message, sizeof(message));
        protocol_send_payload((const uint8_t*)device_info.description,
 8024320:	b289      	uxth	r1, r1
 8024322:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8024324:	f000 ff78 	bl	8025218 <protocol_send_payload>
                              string_length);
        protocol_send_tail();
 8024328:	f000 ff78 	bl	802521c <protocol_send_tail>
        break;

    case MSG_GET_DEVICE_INFO:
        if (num_bytes == 1)
        {
            return send_device_info(endpoint, radar_driver);
 802432c:	e684      	b.n	8024038 <ep_radar_base_handle_message+0xa4>
        }
        break;

    case MSG_GET_TEMPRATURE:
    if (num_bytes == 2)
 802432e:	2d02      	cmp	r5, #2
 8024330:	f47f ae80 	bne.w	8024034 <ep_radar_base_handle_message+0xa0>
 *
 * \return The function returns the value read from the payload.
 */
static inline uint8_t rd_payload_u8(const uint8_t* payload, uint16_t offset)
{
    return payload[offset];
 8024334:	784d      	ldrb	r5, [r1, #1]
{
    uint16_t error_code;
    int32_t temperature;

    /* read temperature value */
    error_code = radar_get_temperature(radar_driver, temp_sensor,
 8024336:	4618      	mov	r0, r3
 8024338:	4629      	mov	r1, r5
 802433a:	aa12      	add	r2, sp, #72	; 0x48
 802433c:	f7fc fa4c 	bl	80207d8 <radar_get_temperature>
                                       &temperature);

    if (error_code == RADAR_ERR_OK)
 8024340:	4604      	mov	r4, r0
 8024342:	2800      	cmp	r0, #0
 8024344:	f47f ae78 	bne.w	8024038 <ep_radar_base_handle_message+0xa4>
        uint8_t message[6];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_TEMPRATURE);
        wr_payload_u8 (message, 1, temp_sensor);
        wr_payload_i32(message, 2, temperature);
 8024348:	9b12      	ldr	r3, [sp, #72]	; 0x48
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802434a:	f88d 505d 	strb.w	r5, [sp, #93]	; 0x5d

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 802434e:	4640      	mov	r0, r8
}

static inline void wr_payload_i32(uint8_t* payload, uint16_t offset,
                                  int32_t value)
{
    payload[offset + 3] = (((uint32_t)value) >> 24) & 0xFF;
 8024350:	0e1f      	lsrs	r7, r3, #24
    payload[offset + 2] = (((uint32_t)value) >> 16) & 0xFF;
 8024352:	0c1e      	lsrs	r6, r3, #16
    payload[offset + 1] = (((uint32_t)value) >>  8) & 0xFF;
 8024354:	0a1d      	lsrs	r5, r3, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024356:	2231      	movs	r2, #49	; 0x31
 8024358:	e014      	b.n	8024384 <ep_radar_base_handle_message+0x3f0>
            return send_temperature(endpoint, radar_driver, temp_sensor);
        }
        break;

    case MSG_GET_TX_POWER:
    if (num_bytes == 2)
 802435a:	2d02      	cmp	r5, #2
 802435c:	f47f ae6a 	bne.w	8024034 <ep_radar_base_handle_message+0xa0>
 *
 * \return The function returns the value read from the payload.
 */
static inline uint8_t rd_payload_u8(const uint8_t* payload, uint16_t offset)
{
    return payload[offset];
 8024360:	784d      	ldrb	r5, [r1, #1]
{
    uint16_t error_code;
    int32_t tx_power;

    /* read TX power value value */
    error_code =  radar_get_tx_power(radar_driver, tx_antenna, &tx_power);
 8024362:	4618      	mov	r0, r3
 8024364:	4629      	mov	r1, r5
 8024366:	aa12      	add	r2, sp, #72	; 0x48
 8024368:	f7fc fa4c 	bl	8020804 <radar_get_tx_power>

    if (error_code == RADAR_ERR_OK)
 802436c:	4604      	mov	r4, r0
 802436e:	2800      	cmp	r0, #0
 8024370:	f47f ae62 	bne.w	8024038 <ep_radar_base_handle_message+0xa4>
        uint8_t message[6];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_TX_POWER);
        wr_payload_u8 (message, 1, tx_antenna);
        wr_payload_i32(message, 2, tx_power);
 8024374:	9b12      	ldr	r3, [sp, #72]	; 0x48
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024376:	f88d 505d 	strb.w	r5, [sp, #93]	; 0x5d

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 802437a:	4640      	mov	r0, r8
}

static inline void wr_payload_i32(uint8_t* payload, uint16_t offset,
                                  int32_t value)
{
    payload[offset + 3] = (((uint32_t)value) >> 24) & 0xFF;
 802437c:	0e1f      	lsrs	r7, r3, #24
    payload[offset + 2] = (((uint32_t)value) >> 16) & 0xFF;
 802437e:	0c1e      	lsrs	r6, r3, #16
    payload[offset + 1] = (((uint32_t)value) >>  8) & 0xFF;
 8024380:	0a1d      	lsrs	r5, r3, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024382:	2233      	movs	r2, #51	; 0x33
 8024384:	2106      	movs	r1, #6
                                  int32_t value)
{
    payload[offset + 3] = (((uint32_t)value) >> 24) & 0xFF;
    payload[offset + 2] = (((uint32_t)value) >> 16) & 0xFF;
    payload[offset + 1] = (((uint32_t)value) >>  8) & 0xFF;
    payload[offset    ] =  ((uint32_t)value)        & 0xFF;
 8024386:	f88d 305e 	strb.w	r3, [sp, #94]	; 0x5e
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802438a:	f88d 205c 	strb.w	r2, [sp, #92]	; 0x5c
}

static inline void wr_payload_i32(uint8_t* payload, uint16_t offset,
                                  int32_t value)
{
    payload[offset + 3] = (((uint32_t)value) >> 24) & 0xFF;
 802438e:	f88d 7061 	strb.w	r7, [sp, #97]	; 0x61
    payload[offset + 2] = (((uint32_t)value) >> 16) & 0xFF;
 8024392:	f88d 6060 	strb.w	r6, [sp, #96]	; 0x60
    payload[offset + 1] = (((uint32_t)value) >>  8) & 0xFF;
 8024396:	f88d 505f 	strb.w	r5, [sp, #95]	; 0x5f
 802439a:	f000 ff29 	bl	80251f0 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 802439e:	a817      	add	r0, sp, #92	; 0x5c
 80243a0:	2106      	movs	r1, #6
 80243a2:	f000 ff39 	bl	8025218 <protocol_send_payload>
        protocol_send_tail();
 80243a6:	f000 ff39 	bl	802521c <protocol_send_tail>
            uint8_t tx_antenna;

            /* extract parameters from message */
            tx_antenna = rd_payload_u8(message_data, 1);

            return send_tx_power(endpoint, radar_driver, tx_antenna);
 80243aa:	e645      	b.n	8024038 <ep_radar_base_handle_message+0xa4>
        }
        break;

    case MSG_GET_CHRIP_DURATION:
    if (num_bytes == 1)
 80243ac:	2d01      	cmp	r5, #1
 80243ae:	f47f ae41 	bne.w	8024034 <ep_radar_base_handle_message+0xa0>
{
    uint16_t error_code;
    uint32_t chirp_duration;

    /* read chirp duration */
    error_code = radar_get_chirp_duration(radar_driver, &chirp_duration);
 80243b2:	4618      	mov	r0, r3
 80243b4:	a912      	add	r1, sp, #72	; 0x48
 80243b6:	f7fc fa3b 	bl	8020830 <radar_get_chirp_duration>

    if (error_code == RADAR_ERR_OK)
 80243ba:	4604      	mov	r4, r0
 80243bc:	2800      	cmp	r0, #0
 80243be:	f47f ae3b 	bne.w	8024038 <ep_radar_base_handle_message+0xa4>
    {
        uint8_t message[5];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_CHRIP_DURATION);
        wr_payload_u32(message, 1, chirp_duration);
 80243c2:	9b12      	ldr	r3, [sp, #72]	; 0x48
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 80243c4:	f88d 305d 	strb.w	r3, [sp, #93]	; 0x5d
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 80243c8:	0e1e      	lsrs	r6, r3, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 80243ca:	0c1d      	lsrs	r5, r3, #16

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 80243cc:	4640      	mov	r0, r8
    payload[offset + 1] = (value >>  8) & 0xFF;
 80243ce:	0a1b      	lsrs	r3, r3, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80243d0:	2235      	movs	r2, #53	; 0x35
 80243d2:	e012      	b.n	80243fa <ep_radar_base_handle_message+0x466>
            return send_chirp_duration(endpoint, radar_driver);
        }
        break;

    case MSG_GET_MIN_INTERVAL:
    if (num_bytes == 1)
 80243d4:	2d01      	cmp	r5, #1
 80243d6:	f47f ae2d 	bne.w	8024034 <ep_radar_base_handle_message+0xa0>
{
    uint16_t error_code;
    uint32_t min_frame_interval;

    /* read minimum frame interval */
    error_code = radar_get_min_frame_interval(radar_driver,
 80243da:	4618      	mov	r0, r3
 80243dc:	a912      	add	r1, sp, #72	; 0x48
 80243de:	f7fc fa33 	bl	8020848 <radar_get_min_frame_interval>
                                              &min_frame_interval);

    if (error_code == RADAR_ERR_OK)
 80243e2:	4604      	mov	r4, r0
 80243e4:	2800      	cmp	r0, #0
 80243e6:	f47f ae27 	bne.w	8024038 <ep_radar_base_handle_message+0xa4>
    {
        uint8_t message[5];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_MIN_INTERVAL);
        wr_payload_u32(message, 1, min_frame_interval);
 80243ea:	9b12      	ldr	r3, [sp, #72]	; 0x48
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 80243ec:	f88d 305d 	strb.w	r3, [sp, #93]	; 0x5d
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 80243f0:	0e1e      	lsrs	r6, r3, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 80243f2:	0c1d      	lsrs	r5, r3, #16

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 80243f4:	4640      	mov	r0, r8
    payload[offset + 1] = (value >>  8) & 0xFF;
 80243f6:	0a1b      	lsrs	r3, r3, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80243f8:	2237      	movs	r2, #55	; 0x37
 80243fa:	2105      	movs	r1, #5
static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 80243fc:	f88d 305e 	strb.w	r3, [sp, #94]	; 0x5e
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024400:	f88d 205c 	strb.w	r2, [sp, #92]	; 0x5c
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024404:	f88d 6060 	strb.w	r6, [sp, #96]	; 0x60
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024408:	f88d 505f 	strb.w	r5, [sp, #95]	; 0x5f
 802440c:	f000 fef0 	bl	80251f0 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 8024410:	a817      	add	r0, sp, #92	; 0x5c
 8024412:	2105      	movs	r1, #5
 8024414:	f000 ff00 	bl	8025218 <protocol_send_payload>
        protocol_send_tail();
 8024418:	f000 ff00 	bl	802521c <protocol_send_tail>
        break;

    case MSG_GET_MIN_INTERVAL:
    if (num_bytes == 1)
        {
            return send_min_frame_interval(endpoint, radar_driver);
 802441c:	e60c      	b.n	8024038 <ep_radar_base_handle_message+0xa4>
        }
        break;

    case MSG_GET_FRAME_FORMAT:
        if (num_bytes == 1)
 802441e:	2d01      	cmp	r5, #1
 8024420:	f47f ae08 	bne.w	8024034 <ep_radar_base_handle_message+0xa0>
{
    uint16_t error_code;
    Frame_Format_t frame_format;

    /* get current frame format from radar driver */
    error_code = radar_get_frame_format(radar_driver, &frame_format);
 8024424:	4618      	mov	r0, r3
 8024426:	a917      	add	r1, sp, #92	; 0x5c
 8024428:	f7fc fa90 	bl	802094c <radar_get_frame_format>

    if (error_code == RADAR_ERR_OK)
 802442c:	4604      	mov	r4, r0
 802442e:	2800      	cmp	r0, #0
 8024430:	f47f ae02 	bne.w	8024038 <ep_radar_base_handle_message+0xa4>
        uint8_t message[11];

        /* compile message */
        wr_payload_u8 (message,  0, MSG_SET_FRAME_FORMAT);
        wr_payload_u32(message,  1, frame_format.num_samples_per_chirp);
        wr_payload_u32(message,  5, frame_format.num_chirps_per_frame);
 8024434:	9a18      	ldr	r2, [sp, #96]	; 0x60
    {
        uint8_t message[11];

        /* compile message */
        wr_payload_u8 (message,  0, MSG_SET_FRAME_FORMAT);
        wr_payload_u32(message,  1, frame_format.num_samples_per_chirp);
 8024436:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024438:	f89d 6064 	ldrb.w	r6, [sp, #100]	; 0x64
 802443c:	f89d 5065 	ldrb.w	r5, [sp, #101]	; 0x65
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024440:	f88d 3049 	strb.w	r3, [sp, #73]	; 0x49

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024444:	ea4f 4c12 	mov.w	ip, r2, lsr #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024448:	ea4f 2e12 	mov.w	lr, r2, lsr #8
        wr_payload_u32(message,  5, frame_format.num_chirps_per_frame);
        wr_payload_u8 (message,  9, frame_format.rx_mask);
        wr_payload_u8 (message, 10, frame_format.signal_part);

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 802444c:	4640      	mov	r0, r8
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 802444e:	ea4f 6a13 	mov.w	sl, r3, lsr #24
 8024452:	ea4f 6812 	mov.w	r8, r2, lsr #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024456:	ea4f 4913 	mov.w	r9, r3, lsr #16
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802445a:	2741      	movs	r7, #65	; 0x41
static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 802445c:	0a1b      	lsrs	r3, r3, #8
 802445e:	210b      	movs	r1, #11
 8024460:	f88d 304a 	strb.w	r3, [sp, #74]	; 0x4a
    payload[offset    ] =  value        & 0xFF;
 8024464:	f88d 204d 	strb.w	r2, [sp, #77]	; 0x4d

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024468:	f88d c04f 	strb.w	ip, [sp, #79]	; 0x4f
    payload[offset + 1] = (value >>  8) & 0xFF;
 802446c:	f88d e04e 	strb.w	lr, [sp, #78]	; 0x4e
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024470:	f88d a04c 	strb.w	sl, [sp, #76]	; 0x4c
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024474:	f88d 904b 	strb.w	r9, [sp, #75]	; 0x4b
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024478:	f88d 8050 	strb.w	r8, [sp, #80]	; 0x50
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802447c:	f88d 7048 	strb.w	r7, [sp, #72]	; 0x48
 8024480:	f88d 6051 	strb.w	r6, [sp, #81]	; 0x51
 8024484:	f88d 5052 	strb.w	r5, [sp, #82]	; 0x52
 8024488:	f000 feb2 	bl	80251f0 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 802448c:	a812      	add	r0, sp, #72	; 0x48
 802448e:	210b      	movs	r1, #11
 8024490:	f000 fec2 	bl	8025218 <protocol_send_payload>
        protocol_send_tail();
 8024494:	f000 fec2 	bl	802521c <protocol_send_tail>
        break;

    case MSG_GET_FRAME_FORMAT:
        if (num_bytes == 1)
        {
            return send_frame_format(endpoint, radar_driver);
 8024498:	e5ce      	b.n	8024038 <ep_radar_base_handle_message+0xa4>
 802449a:	bf00      	nop
 802449c:	1ffe9808 	.word	0x1ffe9808
        }
        break;

    case MSG_SET_FRAME_FORMAT:
        if (num_bytes == 11)
 80244a0:	2d0b      	cmp	r5, #11
 80244a2:	f47f adc7 	bne.w	8024034 <ep_radar_base_handle_message+0xa0>
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 80244a6:	f891 c003 	ldrb.w	ip, [r1, #3]
 80244aa:	79ce      	ldrb	r6, [r1, #7]
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 80244ac:	f891 8004 	ldrb.w	r8, [r1, #4]
 80244b0:	7a0a      	ldrb	r2, [r1, #8]
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
            ((uint32_t)payload[offset    ]);
 80244b2:	784d      	ldrb	r5, [r1, #1]
 80244b4:	7948      	ldrb	r0, [r1, #5]

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 80244b6:	f891 e006 	ldrb.w	lr, [r1, #6]
            Frame_Format_t format;

            /* extract parameters from message */
            format.num_samples_per_chirp = rd_payload_u32(message_data,  1);
            format.num_chirps_per_frame  = rd_payload_u32(message_data,  5);
            format.rx_mask               = rd_payload_u8 (message_data,  9);
 80244ba:	f891 9009 	ldrb.w	r9, [r1, #9]
            format.signal_part           = rd_payload_u8 (message_data, 10);
 80244be:	7a8f      	ldrb	r7, [r1, #10]
 80244c0:	788c      	ldrb	r4, [r1, #2]

            /* apply new frame format */
            error_code = radar_set_frame_format(radar_driver, &format);
 80244c2:	9302      	str	r3, [sp, #8]
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 80244c4:	ea4f 410c 	mov.w	r1, ip, lsl #16
 80244c8:	0436      	lsls	r6, r6, #16
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 80244ca:	ea41 6108 	orr.w	r1, r1, r8, lsl #24
 80244ce:	ea46 6202 	orr.w	r2, r6, r2, lsl #24
 80244d2:	4329      	orrs	r1, r5
 80244d4:	4302      	orrs	r2, r0
 80244d6:	ea41 2404 	orr.w	r4, r1, r4, lsl #8
 80244da:	ea42 220e 	orr.w	r2, r2, lr, lsl #8
 80244de:	a917      	add	r1, sp, #92	; 0x5c
 80244e0:	4618      	mov	r0, r3
        {
            unsigned error_code;
            Frame_Format_t format;

            /* extract parameters from message */
            format.num_samples_per_chirp = rd_payload_u32(message_data,  1);
 80244e2:	9417      	str	r4, [sp, #92]	; 0x5c
            format.num_chirps_per_frame  = rd_payload_u32(message_data,  5);
            format.rx_mask               = rd_payload_u8 (message_data,  9);
 80244e4:	f88d 9064 	strb.w	r9, [sp, #100]	; 0x64
            unsigned error_code;
            Frame_Format_t format;

            /* extract parameters from message */
            format.num_samples_per_chirp = rd_payload_u32(message_data,  1);
            format.num_chirps_per_frame  = rd_payload_u32(message_data,  5);
 80244e8:	9218      	str	r2, [sp, #96]	; 0x60
            format.rx_mask               = rd_payload_u8 (message_data,  9);
            format.signal_part           = rd_payload_u8 (message_data, 10);
 80244ea:	f88d 7065 	strb.w	r7, [sp, #101]	; 0x65

            /* apply new frame format */
            error_code = radar_set_frame_format(radar_driver, &format);
 80244ee:	f7fc f9c7 	bl	8020880 <radar_set_frame_format>

            /* inform other endpoints of the change */
            protocol_broadcast_change(radar_driver,
 80244f2:	9b02      	ldr	r3, [sp, #8]
            format.num_chirps_per_frame  = rd_payload_u32(message_data,  5);
            format.rx_mask               = rd_payload_u8 (message_data,  9);
            format.signal_part           = rd_payload_u8 (message_data, 10);

            /* apply new frame format */
            error_code = radar_set_frame_format(radar_driver, &format);
 80244f4:	4604      	mov	r4, r0

            /* inform other endpoints of the change */
            protocol_broadcast_change(radar_driver,
 80244f6:	2101      	movs	r1, #1
 80244f8:	4618      	mov	r0, r3
 80244fa:	f001 f84f 	bl	802559c <protocol_broadcast_change>
 80244fe:	e59b      	b.n	8024038 <ep_radar_base_handle_message+0xa4>
static uint16_t send_fft_config(uint8_t endpoint,
                                 Radar_Handle_t radar_driver)
{

	FFT_configuration_t fft_conf;
	radar_get_fft_configuration(radar_driver,&fft_conf);
 8024500:	4618      	mov	r0, r3
 8024502:	a917      	add	r1, sp, #92	; 0x5c
 8024504:	f7fc faba 	bl	8020a7c <radar_get_fft_configuration>

	union {
			uint32_t  u32_value;
			float	  f32_value;
		} convert_helper;
	convert_helper.f32_value = fft_conf.scaling_factor;
 8024508:	9a19      	ldr	r2, [sp, #100]	; 0x64

    uint8_t message[11];

	/* compile message */
	wr_payload_u8 (message,  0, MSG_SET_FFT_INFO);
	wr_payload_u32(message,  1, fft_conf.fft_window_size);
 802450a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802450c:	f89d 4061 	ldrb.w	r4, [sp, #97]	; 0x61
 8024510:	f89d 5060 	ldrb.w	r5, [sp, #96]	; 0x60
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024514:	f88d 3049 	strb.w	r3, [sp, #73]	; 0x49
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024518:	ea4f 6e13 	mov.w	lr, r3, lsr #24
 802451c:	ea4f 6912 	mov.w	r9, r2, lsr #24
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024520:	ea4f 2c12 	mov.w	ip, r2, lsr #8
	wr_payload_u8(message,   5, (uint8_t)fft_conf.window_type);
	wr_payload_u8 (message,  6, fft_conf.mean_removed);
	wr_payload_u32(message,  7, convert_helper.u32_value);

	/* send message */
	protocol_send_header(endpoint, sizeof(message));
 8024524:	4640      	mov	r0, r8

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024526:	0c1f      	lsrs	r7, r3, #16
 8024528:	ea4f 4812 	mov.w	r8, r2, lsr #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 802452c:	0a1b      	lsrs	r3, r3, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802452e:	2643      	movs	r6, #67	; 0x43
 8024530:	210b      	movs	r1, #11
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024532:	f88d 204f 	strb.w	r2, [sp, #79]	; 0x4f
static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024536:	f88d c050 	strb.w	ip, [sp, #80]	; 0x50
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 802453a:	f88d e04c 	strb.w	lr, [sp, #76]	; 0x4c
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 802453e:	f88d 304a 	strb.w	r3, [sp, #74]	; 0x4a
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024542:	f88d 404e 	strb.w	r4, [sp, #78]	; 0x4e
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024546:	f88d 9052 	strb.w	r9, [sp, #82]	; 0x52
    payload[offset + 2] = (value >> 16) & 0xFF;
 802454a:	f88d 8051 	strb.w	r8, [sp, #81]	; 0x51
 802454e:	f88d 704b 	strb.w	r7, [sp, #75]	; 0x4b
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024552:	f88d 6048 	strb.w	r6, [sp, #72]	; 0x48
 8024556:	f88d 504d 	strb.w	r5, [sp, #77]	; 0x4d
 802455a:	f000 fe49 	bl	80251f0 <protocol_send_header>
	protocol_send_payload(message, sizeof(message));
 802455e:	a812      	add	r0, sp, #72	; 0x48
 8024560:	210b      	movs	r1, #11
 8024562:	f000 fe59 	bl	8025218 <protocol_send_payload>
        }
        break;
    case MSG_GET_FFT_INFO:
		if (num_bytes == 1)
		{
			return send_fft_config(endpoint, radar_driver);
 8024566:	2400      	movs	r4, #0
	wr_payload_u32(message,  7, convert_helper.u32_value);

	/* send message */
	protocol_send_header(endpoint, sizeof(message));
	protocol_send_payload(message, sizeof(message));
	protocol_send_tail();
 8024568:	f000 fe58 	bl	802521c <protocol_send_tail>
        }
        break;
    case MSG_GET_FFT_INFO:
		if (num_bytes == 1)
		{
			return send_fft_config(endpoint, radar_driver);
 802456c:	e564      	b.n	8024038 <ep_radar_base_handle_message+0xa4>
        if (frame_info.adc_resolution == 12)
        {
			uint8_t *destPtr = (uint8_t *)&transport_buffer[0];
			uint8_t *srcPtr  = (uint8_t *)frame_info.sample_data;

			uint32_t channel_inc = frame_info.num_samples_per_chirp*sizeof(uint16_t);
 802456e:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8024570:	9302      	str	r3, [sp, #8]
 8024572:	4619      	mov	r1, r3
			uint32_t chirp_inc   = channel_inc * frame_info.num_rx_antennas * (frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);
 8024574:	f89d 3077 	ldrb.w	r3, [sp, #119]	; 0x77
 8024578:	9308      	str	r3, [sp, #32]
 802457a:	4618      	mov	r0, r3
 802457c:	f89d 3068 	ldrb.w	r3, [sp, #104]	; 0x68
 8024580:	9304      	str	r3, [sp, #16]
 8024582:	461d      	mov	r5, r3

			uint32_t processed_out_bytes = 0;

			for(uint32_t chirp = 0; chirp < frame_info.num_chirps; chirp++)
 8024584:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8024586:	930d      	str	r3, [sp, #52]	; 0x34
        {
			uint8_t *destPtr = (uint8_t *)&transport_buffer[0];
			uint8_t *srcPtr  = (uint8_t *)frame_info.sample_data;

			uint32_t channel_inc = frame_info.num_samples_per_chirp*sizeof(uint16_t);
			uint32_t chirp_inc   = channel_inc * frame_info.num_rx_antennas * (frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);
 8024588:	42a0      	cmp	r0, r4

			uint32_t processed_out_bytes = 0;

			for(uint32_t chirp = 0; chirp < frame_info.num_chirps; chirp++)
 802458a:	461e      	mov	r6, r3
        if (frame_info.adc_resolution == 12)
        {
			uint8_t *destPtr = (uint8_t *)&transport_buffer[0];
			uint8_t *srcPtr  = (uint8_t *)frame_info.sample_data;

			uint32_t channel_inc = frame_info.num_samples_per_chirp*sizeof(uint16_t);
 802458c:	ea4f 0941 	mov.w	r9, r1, lsl #1
        protocol_send_payload(message_header, sizeof(message_header));

        if (frame_info.adc_resolution == 12)
        {
			uint8_t *destPtr = (uint8_t *)&transport_buffer[0];
			uint8_t *srcPtr  = (uint8_t *)frame_info.sample_data;
 8024590:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8024592:	9307      	str	r3, [sp, #28]

			uint32_t channel_inc = frame_info.num_samples_per_chirp*sizeof(uint16_t);
			uint32_t chirp_inc   = channel_inc * frame_info.num_rx_antennas * (frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);
 8024594:	bf08      	it	eq
 8024596:	2201      	moveq	r2, #1
 8024598:	fb09 f305 	mul.w	r3, r9, r5
 802459c:	bf18      	it	ne
 802459e:	2202      	movne	r2, #2
 80245a0:	fb02 f303 	mul.w	r3, r2, r3
 80245a4:	930c      	str	r3, [sp, #48]	; 0x30

			uint32_t processed_out_bytes = 0;

			for(uint32_t chirp = 0; chirp < frame_info.num_chirps; chirp++)
 80245a6:	2e00      	cmp	r6, #0
 80245a8:	d04e      	beq.n	8024648 <ep_radar_base_handle_message+0x6b4>
 80245aa:	1e8b      	subs	r3, r1, #2
 80245ac:	085b      	lsrs	r3, r3, #1
 80245ae:	3301      	adds	r3, #1
 80245b0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80245b4:	2901      	cmp	r1, #1
 80245b6:	9303      	str	r3, [sp, #12]
 80245b8:	bf98      	it	ls
 80245ba:	4623      	movls	r3, r4
 80245bc:	f011 0201 	ands.w	r2, r1, #1
 80245c0:	bf08      	it	eq
 80245c2:	469b      	moveq	fp, r3
 80245c4:	f8df e110 	ldr.w	lr, [pc, #272]	; 80246d8 <ep_radar_base_handle_message+0x744>
 80245c8:	f89d 3074 	ldrb.w	r3, [sp, #116]	; 0x74
 80245cc:	f8cd 803c 	str.w	r8, [sp, #60]	; 0x3c
 80245d0:	9409      	str	r4, [sp, #36]	; 0x24
 80245d2:	bf18      	it	ne
 80245d4:	f04f 3bff 	movne.w	fp, #4294967295
 80245d8:	940a      	str	r4, [sp, #40]	; 0x28
 80245da:	9305      	str	r3, [sp, #20]
 80245dc:	4690      	mov	r8, r2
			{
				for(uint32_t ant_idx= 0; ant_idx < frame_info.num_rx_antennas; ant_idx++)  // max Ant mask!
 80245de:	9b04      	ldr	r3, [sp, #16]
 80245e0:	b333      	cbz	r3, 8024630 <ep_radar_base_handle_message+0x69c>
 80245e2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80245e4:	3304      	adds	r3, #4
 80245e6:	f04f 0a00 	mov.w	sl, #0
 80245ea:	9306      	str	r3, [sp, #24]
				{
					uint8_t mask = (1 << ant_idx);
 80245ec:	2301      	movs	r3, #1
					if( (mask & frame_info.rx_mask) != 0 )
 80245ee:	9a05      	ldr	r2, [sp, #20]

			for(uint32_t chirp = 0; chirp < frame_info.num_chirps; chirp++)
			{
				for(uint32_t ant_idx= 0; ant_idx < frame_info.num_rx_antennas; ant_idx++)  // max Ant mask!
				{
					uint8_t mask = (1 << ant_idx);
 80245f0:	fa03 f30a 	lsl.w	r3, r3, sl
					if( (mask & frame_info.rx_mask) != 0 )
 80245f4:	421a      	tst	r2, r3
 80245f6:	d016      	beq.n	8024626 <ep_radar_base_handle_message+0x692>
					{
						uint32_t num_chan_per_ant = (frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);
 80245f8:	9b08      	ldr	r3, [sp, #32]
 80245fa:	2b00      	cmp	r3, #0
 80245fc:	9b06      	ldr	r3, [sp, #24]
 80245fe:	bf0c      	ite	eq
 8024600:	f04f 0c01 	moveq.w	ip, #1
 8024604:	f04f 0c02 	movne.w	ip, #2
 8024608:	fb09 f70a 	mul.w	r7, r9, sl
 802460c:	fb0c 3707 	mla	r7, ip, r7, r3
 8024610:	9b07      	ldr	r3, [sp, #28]
						for(uint32_t ch_idx = 0; ch_idx < num_chan_per_ant; ch_idx++)
 8024612:	2600      	movs	r6, #0
 8024614:	441f      	add	r7, r3


static size_t packing_helper_12Bit( uint8_t *p_dest, uint16_t *p_src, size_t numSamples)
{
	/* numBytes needs to be devided by 2 */
	if( (numSamples & 1) != 0)
 8024616:	f1b8 0f00 	cmp.w	r8, #0
 802461a:	d01a      	beq.n	8024652 <ep_radar_base_handle_message+0x6be>
				{
					uint8_t mask = (1 << ant_idx);
					if( (mask & frame_info.rx_mask) != 0 )
					{
						uint32_t num_chan_per_ant = (frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);
						for(uint32_t ch_idx = 0; ch_idx < num_chan_per_ant; ch_idx++)
 802461c:	3601      	adds	r6, #1
 802461e:	4566      	cmp	r6, ip
						{
							uint32_t in_offset = (chirp_inc * chirp) + (channel_inc*(ant_idx*num_chan_per_ant + ch_idx ));
							size_t out_offset = packing_helper_12Bit(destPtr, (uint16_t *)&srcPtr[in_offset], frame_info.num_samples_per_chirp );
			
							destPtr += out_offset;
 8024620:	44de      	add	lr, fp
 8024622:	444f      	add	r7, r9
				{
					uint8_t mask = (1 << ant_idx);
					if( (mask & frame_info.rx_mask) != 0 )
					{
						uint32_t num_chan_per_ant = (frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);
						for(uint32_t ch_idx = 0; ch_idx < num_chan_per_ant; ch_idx++)
 8024624:	d1f7      	bne.n	8024616 <ep_radar_base_handle_message+0x682>

			uint32_t processed_out_bytes = 0;

			for(uint32_t chirp = 0; chirp < frame_info.num_chirps; chirp++)
			{
				for(uint32_t ant_idx= 0; ant_idx < frame_info.num_rx_antennas; ant_idx++)  // max Ant mask!
 8024626:	9b04      	ldr	r3, [sp, #16]
 8024628:	f10a 0a01 	add.w	sl, sl, #1
 802462c:	4553      	cmp	r3, sl
 802462e:	d1dd      	bne.n	80245ec <ep_radar_base_handle_message+0x658>
 8024630:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8024632:	990c      	ldr	r1, [sp, #48]	; 0x30
			uint32_t channel_inc = frame_info.num_samples_per_chirp*sizeof(uint16_t);
			uint32_t chirp_inc   = channel_inc * frame_info.num_rx_antennas * (frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);

			uint32_t processed_out_bytes = 0;

			for(uint32_t chirp = 0; chirp < frame_info.num_chirps; chirp++)
 8024634:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8024636:	440a      	add	r2, r1
 8024638:	9209      	str	r2, [sp, #36]	; 0x24
 802463a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 802463c:	3301      	adds	r3, #1
 802463e:	4293      	cmp	r3, r2
 8024640:	930a      	str	r3, [sp, #40]	; 0x28
 8024642:	d1cc      	bne.n	80245de <ep_radar_base_handle_message+0x64a>
 8024644:	f8dd 803c 	ldr.w	r8, [sp, #60]	; 0x3c
						}
					}
				}
			}
			/* now send the packed data at once */
			protocol_send_payload((uint8_t*)transport_buffer, data_size);
 8024648:	990e      	ldr	r1, [sp, #56]	; 0x38
 802464a:	4823      	ldr	r0, [pc, #140]	; (80246d8 <ep_radar_base_handle_message+0x744>)
 802464c:	f000 fde4 	bl	8025218 <protocol_send_payload>
 8024650:	e59a      	b.n	8024188 <ep_radar_base_handle_message+0x1f4>
	if( (numSamples & 1) != 0)
		return -1;

	size_t   processed_output_bytes = 0;

	while (numSamples >= 2)
 8024652:	9b02      	ldr	r3, [sp, #8]
 8024654:	2b01      	cmp	r3, #1
 8024656:	d9e1      	bls.n	802461c <ep_radar_base_handle_message+0x688>
 8024658:	9b03      	ldr	r3, [sp, #12]
 802465a:	4639      	mov	r1, r7
 802465c:	eb0e 0503 	add.w	r5, lr, r3
 8024660:	4672      	mov	r2, lr
	{
		/* pack two samples into one 32 bit word */
		uint32_t packed_word;
		packed_word  = *p_src++;
		packed_word |= *p_src++ << 12;
 8024662:	f831 0c02 	ldrh.w	r0, [r1, #-2]

	while (numSamples >= 2)
	{
		/* pack two samples into one 32 bit word */
		uint32_t packed_word;
		packed_word  = *p_src++;
 8024666:	f831 3c04 	ldrh.w	r3, [r1, #-4]
		packed_word |= *p_src++ << 12;
 802466a:	ea43 3300 	orr.w	r3, r3, r0, lsl #12
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 802466e:	0e18      	lsrs	r0, r3, #24
 8024670:	70d0      	strb	r0, [r2, #3]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024672:	0c1c      	lsrs	r4, r3, #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024674:	0a18      	lsrs	r0, r3, #8

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024676:	7094      	strb	r4, [r2, #2]
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024678:	7050      	strb	r0, [r2, #1]
    payload[offset    ] =  value        & 0xFF;
 802467a:	f802 3b03 	strb.w	r3, [r2], #3
	if( (numSamples & 1) != 0)
		return -1;

	size_t   processed_output_bytes = 0;

	while (numSamples >= 2)
 802467e:	42aa      	cmp	r2, r5
 8024680:	f101 0104 	add.w	r1, r1, #4
 8024684:	d1ed      	bne.n	8024662 <ep_radar_base_handle_message+0x6ce>
 8024686:	e7c9      	b.n	802461c <ep_radar_base_handle_message+0x688>
        uint32_t num_used_ant = 2;

        if (frame_info.adc_resolution == 12)
        {
        	/* Selection of Antenna to output is currently only supported for 12 Bit ADC resolution! */
        	if( frame_info.rx_mask == 1 )
 8024688:	f89d c074 	ldrb.w	ip, [sp, #116]	; 0x74
 802468c:	f1bc 0f01 	cmp.w	ip, #1
 8024690:	46e1      	mov	r9, ip
 8024692:	d00a      	beq.n	80246aa <ep_radar_base_handle_message+0x716>
			{
				sample_start = 0;
				num_used_ant = 1;

			}
			else if( frame_info.rx_mask == 2 )
 8024694:	f1bc 0f02 	cmp.w	ip, #2
 8024698:	d00e      	beq.n	80246b8 <ep_radar_base_handle_message+0x724>
 802469a:	46a9      	mov	r9, r5
        uint32_t num_samples;
        uint32_t data_size;
        uint8_t message_header[18];
        uint32_t sample_start = 0;

        uint32_t num_used_ant = 2;
 802469c:	4629      	mov	r1, r5
 802469e:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 80246a0:	9a19      	ldr	r2, [sp, #100]	; 0x64
 80246a2:	f89d e077 	ldrb.w	lr, [sp, #119]	; 0x77

        /* send message containing frame data */
        uint32_t num_samples;
        uint32_t data_size;
        uint8_t message_header[18];
        uint32_t sample_start = 0;
 80246a6:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 80246a8:	e4e3      	b.n	8024072 <ep_radar_base_handle_message+0xde>
        {
        	/* Selection of Antenna to output is currently only supported for 12 Bit ADC resolution! */
        	if( frame_info.rx_mask == 1 )
			{
				sample_start = 0;
				num_used_ant = 1;
 80246aa:	4661      	mov	r1, ip
        if (frame_info.adc_resolution == 12)
        {
        	/* Selection of Antenna to output is currently only supported for 12 Bit ADC resolution! */
        	if( frame_info.rx_mask == 1 )
			{
				sample_start = 0;
 80246ac:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 80246ae:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 80246b0:	9a19      	ldr	r2, [sp, #100]	; 0x64
 80246b2:	f89d e077 	ldrb.w	lr, [sp, #119]	; 0x77
 80246b6:	e4dc      	b.n	8024072 <ep_radar_base_handle_message+0xde>
			else if( frame_info.rx_mask == 2 )
			{
				num_used_ant = 1;
				sample_start = frame_info.num_chirps *
						frame_info.num_samples_per_chirp *
						num_used_ant *
 80246b8:	f89d e077 	ldrb.w	lr, [sp, #119]	; 0x77

			}
			else if( frame_info.rx_mask == 2 )
			{
				num_used_ant = 1;
				sample_start = frame_info.num_chirps *
 80246bc:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 80246be:	9a19      	ldr	r2, [sp, #100]	; 0x64
						frame_info.num_samples_per_chirp *
						num_used_ant *
 80246c0:	f1be 0f00 	cmp.w	lr, #0

			}
			else if( frame_info.rx_mask == 2 )
			{
				num_used_ant = 1;
				sample_start = frame_info.num_chirps *
 80246c4:	fb02 f103 	mul.w	r1, r2, r3
						frame_info.num_samples_per_chirp *
						num_used_ant *
 80246c8:	bf0c      	ite	eq
 80246ca:	2501      	moveq	r5, #1
 80246cc:	2502      	movne	r5, #2

			}
			else if( frame_info.rx_mask == 2 )
			{
				num_used_ant = 1;
				sample_start = frame_info.num_chirps *
 80246ce:	fb05 f501 	mul.w	r5, r5, r1
 80246d2:	46b1      	mov	r9, r6
				num_used_ant = 1;

			}
			else if( frame_info.rx_mask == 2 )
			{
				num_used_ant = 1;
 80246d4:	2101      	movs	r1, #1
 80246d6:	e4cc      	b.n	8024072 <ep_radar_base_handle_message+0xde>
 80246d8:	1ffe980c 	.word	0x1ffe980c

080246dc <ep_radar_base_handle_change>:
    return PROTOCOL_STATUS_INVALID_PAYLOAD;
}

void ep_radar_base_handle_change(uint8_t endpoint, void* context,
                                 uint32_t what)
{
 80246dc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (what)
 80246e0:	3a01      	subs	r2, #1
    return PROTOCOL_STATUS_INVALID_PAYLOAD;
}

void ep_radar_base_handle_change(uint8_t endpoint, void* context,
                                 uint32_t what)
{
 80246e2:	b086      	sub	sp, #24
 80246e4:	4680      	mov	r8, r0
 80246e6:	460d      	mov	r5, r1
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (what)
 80246e8:	2a04      	cmp	r2, #4
 80246ea:	d84e      	bhi.n	802478a <ep_radar_base_handle_change+0xae>
 80246ec:	e8df f002 	tbb	[pc, r2]
 80246f0:	84505003 	.word	0x84505003
 80246f4:	50          	.byte	0x50
 80246f5:	00          	.byte	0x00
{
    uint16_t error_code;
    Frame_Format_t frame_format;

    /* get current frame format from radar driver */
    error_code = radar_get_frame_format(radar_driver, &frame_format);
 80246f6:	a903      	add	r1, sp, #12
 80246f8:	4628      	mov	r0, r5
 80246fa:	f7fc f927 	bl	802094c <radar_get_frame_format>

    if (error_code == RADAR_ERR_OK)
 80246fe:	2800      	cmp	r0, #0
 8024700:	f000 80a1 	beq.w	8024846 <ep_radar_base_handle_change+0x16a>
 8024704:	466f      	mov	r7, sp
{
    uint16_t error_code;
    uint32_t chirp_duration;

    /* read chirp duration */
    error_code = radar_get_chirp_duration(radar_driver, &chirp_duration);
 8024706:	4628      	mov	r0, r5
 8024708:	4639      	mov	r1, r7
 802470a:	f7fc f891 	bl	8020830 <radar_get_chirp_duration>

    if (error_code == RADAR_ERR_OK)
 802470e:	b9c0      	cbnz	r0, 8024742 <ep_radar_base_handle_change+0x66>
    {
        uint8_t message[5];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_CHRIP_DURATION);
        wr_payload_u32(message, 1, chirp_duration);
 8024710:	9b00      	ldr	r3, [sp, #0]
 8024712:	f88d 300d 	strb.w	r3, [sp, #13]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024716:	2235      	movs	r2, #53	; 0x35
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024718:	0e1e      	lsrs	r6, r3, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 802471a:	0c1c      	lsrs	r4, r3, #16

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 802471c:	4640      	mov	r0, r8
    payload[offset + 1] = (value >>  8) & 0xFF;
 802471e:	0a1b      	lsrs	r3, r3, #8
 8024720:	2105      	movs	r1, #5
 8024722:	f88d 300e 	strb.w	r3, [sp, #14]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024726:	f88d 200c 	strb.w	r2, [sp, #12]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 802472a:	f88d 6010 	strb.w	r6, [sp, #16]
    payload[offset + 2] = (value >> 16) & 0xFF;
 802472e:	f88d 400f 	strb.w	r4, [sp, #15]
 8024732:	f000 fd5d 	bl	80251f0 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 8024736:	a803      	add	r0, sp, #12
 8024738:	2105      	movs	r1, #5
 802473a:	f000 fd6d 	bl	8025218 <protocol_send_payload>
        protocol_send_tail();
 802473e:	f000 fd6d 	bl	802521c <protocol_send_tail>
{
    uint16_t error_code;
    uint32_t min_frame_interval;

    /* read minimum frame interval */
    error_code = radar_get_min_frame_interval(radar_driver,
 8024742:	4639      	mov	r1, r7
 8024744:	4628      	mov	r0, r5
 8024746:	f7fc f87f 	bl	8020848 <radar_get_min_frame_interval>
                                              &min_frame_interval);

    if (error_code == RADAR_ERR_OK)
 802474a:	b9c0      	cbnz	r0, 802477e <ep_radar_base_handle_change+0xa2>
    {
        uint8_t message[5];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_MIN_INTERVAL);
        wr_payload_u32(message, 1, min_frame_interval);
 802474c:	9b00      	ldr	r3, [sp, #0]
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 802474e:	f88d 300d 	strb.w	r3, [sp, #13]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024752:	2237      	movs	r2, #55	; 0x37

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 8024754:	4640      	mov	r0, r8
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024756:	0e1e      	lsrs	r6, r3, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024758:	0c1c      	lsrs	r4, r3, #16
 802475a:	2105      	movs	r1, #5
    payload[offset + 1] = (value >>  8) & 0xFF;
 802475c:	0a1b      	lsrs	r3, r3, #8
 802475e:	f88d 300e 	strb.w	r3, [sp, #14]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024762:	f88d 200c 	strb.w	r2, [sp, #12]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024766:	f88d 6010 	strb.w	r6, [sp, #16]
    payload[offset + 2] = (value >> 16) & 0xFF;
 802476a:	f88d 400f 	strb.w	r4, [sp, #15]
 802476e:	f000 fd3f 	bl	80251f0 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 8024772:	a803      	add	r0, sp, #12
 8024774:	2105      	movs	r1, #5
 8024776:	f000 fd4f 	bl	8025218 <protocol_send_payload>
        protocol_send_tail();
 802477a:	f000 fd4f 	bl	802521c <protocol_send_tail>
        send_min_frame_interval(endpoint, radar_driver);

        {
        	extern uint8_t adc_endpoint;

        	if( adc_endpoint != 0)
 802477e:	4b58      	ldr	r3, [pc, #352]	; (80248e0 <ep_radar_base_handle_change+0x204>)
 8024780:	7818      	ldrb	r0, [r3, #0]
 8024782:	b110      	cbz	r0, 802478a <ep_radar_base_handle_change+0xae>
        		send_adc_configuration(adc_endpoint,radar_driver); // change
 8024784:	4629      	mov	r1, r5
 8024786:	f7ff fb45 	bl	8023e14 <send_adc_configuration>
        break;

    default:
        break;
    }
}
 802478a:	b006      	add	sp, #24
 802478c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
void ep_radar_base_handle_change(uint8_t endpoint, void* context,
                                 uint32_t what)
{
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (what)
 8024790:	2600      	movs	r6, #0
 8024792:	466f      	mov	r7, sp
 8024794:	b2f4      	uxtb	r4, r6
{
    uint16_t error_code;
    int32_t tx_power;

    /* read TX power value value */
    error_code =  radar_get_tx_power(radar_driver, tx_antenna, &tx_power);
 8024796:	4621      	mov	r1, r4
 8024798:	4628      	mov	r0, r5
 802479a:	463a      	mov	r2, r7
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802479c:	f04f 0933 	mov.w	r9, #51	; 0x33
 80247a0:	f7fc f830 	bl	8020804 <radar_get_tx_power>

    if (error_code == RADAR_ERR_OK)
 80247a4:	2800      	cmp	r0, #0
 80247a6:	d1f0      	bne.n	802478a <ep_radar_base_handle_change+0xae>
        uint8_t message[6];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_TX_POWER);
        wr_payload_u8 (message, 1, tx_antenna);
        wr_payload_i32(message, 2, tx_power);
 80247a8:	9b00      	ldr	r3, [sp, #0]
                                  int32_t value)
{
    payload[offset + 3] = (((uint32_t)value) >> 24) & 0xFF;
    payload[offset + 2] = (((uint32_t)value) >> 16) & 0xFF;
    payload[offset + 1] = (((uint32_t)value) >>  8) & 0xFF;
    payload[offset    ] =  ((uint32_t)value)        & 0xFF;
 80247aa:	f88d 300e 	strb.w	r3, [sp, #14]
static inline void wr_payload_i32(uint8_t* payload, uint16_t offset,
                                  int32_t value)
{
    payload[offset + 3] = (((uint32_t)value) >> 24) & 0xFF;
    payload[offset + 2] = (((uint32_t)value) >> 16) & 0xFF;
    payload[offset + 1] = (((uint32_t)value) >>  8) & 0xFF;
 80247ae:	0a1a      	lsrs	r2, r3, #8
}

static inline void wr_payload_i32(uint8_t* payload, uint16_t offset,
                                  int32_t value)
{
    payload[offset + 3] = (((uint32_t)value) >> 24) & 0xFF;
 80247b0:	ea4f 6c13 	mov.w	ip, r3, lsr #24
    payload[offset + 2] = (((uint32_t)value) >> 16) & 0xFF;
 80247b4:	ea4f 4e13 	mov.w	lr, r3, lsr #16

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 80247b8:	4640      	mov	r0, r8
 80247ba:	2106      	movs	r1, #6
 80247bc:	3601      	adds	r6, #1
    payload[offset + 1] = (((uint32_t)value) >>  8) & 0xFF;
 80247be:	f88d 200f 	strb.w	r2, [sp, #15]
}

static inline void wr_payload_i32(uint8_t* payload, uint16_t offset,
                                  int32_t value)
{
    payload[offset + 3] = (((uint32_t)value) >> 24) & 0xFF;
 80247c2:	f88d c011 	strb.w	ip, [sp, #17]
    payload[offset + 2] = (((uint32_t)value) >> 16) & 0xFF;
 80247c6:	f88d e010 	strb.w	lr, [sp, #16]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80247ca:	f88d 400d 	strb.w	r4, [sp, #13]
 80247ce:	f88d 900c 	strb.w	r9, [sp, #12]
 80247d2:	b2f4      	uxtb	r4, r6
 80247d4:	f000 fd0c 	bl	80251f0 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 80247d8:	a803      	add	r0, sp, #12
 80247da:	2106      	movs	r1, #6
 80247dc:	f000 fd1c 	bl	8025218 <protocol_send_payload>
        protocol_send_tail();
 80247e0:	f000 fd1c 	bl	802521c <protocol_send_tail>
{
    uint16_t error_code;
    int32_t tx_power;

    /* read TX power value value */
    error_code =  radar_get_tx_power(radar_driver, tx_antenna, &tx_power);
 80247e4:	4621      	mov	r1, r4
 80247e6:	4628      	mov	r0, r5
 80247e8:	463a      	mov	r2, r7
 80247ea:	f7fc f80b 	bl	8020804 <radar_get_tx_power>

    if (error_code == RADAR_ERR_OK)
 80247ee:	2800      	cmp	r0, #0
 80247f0:	d0da      	beq.n	80247a8 <ep_radar_base_handle_change+0xcc>
        break;

    default:
        break;
    }
}
 80247f2:	b006      	add	sp, #24
 80247f4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
{
    uint16_t error_code;
    uint32_t chirp_duration;

    /* read chirp duration */
    error_code = radar_get_chirp_duration(radar_driver, &chirp_duration);
 80247f8:	4669      	mov	r1, sp
 80247fa:	4628      	mov	r0, r5
 80247fc:	466f      	mov	r7, sp
 80247fe:	f7fc f817 	bl	8020830 <radar_get_chirp_duration>

    if (error_code == RADAR_ERR_OK)
 8024802:	2800      	cmp	r0, #0
 8024804:	d052      	beq.n	80248ac <ep_radar_base_handle_change+0x1d0>
{
    uint16_t error_code;
    uint32_t min_frame_interval;

    /* read minimum frame interval */
    error_code = radar_get_min_frame_interval(radar_driver,
 8024806:	4628      	mov	r0, r5
 8024808:	4639      	mov	r1, r7
 802480a:	f7fc f81d 	bl	8020848 <radar_get_min_frame_interval>
                                              &min_frame_interval);

    if (error_code == RADAR_ERR_OK)
 802480e:	2800      	cmp	r0, #0
 8024810:	d1bb      	bne.n	802478a <ep_radar_base_handle_change+0xae>
    {
        uint8_t message[5];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_MIN_INTERVAL);
        wr_payload_u32(message, 1, min_frame_interval);
 8024812:	9b00      	ldr	r3, [sp, #0]
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024814:	f88d 300d 	strb.w	r3, [sp, #13]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024818:	2237      	movs	r2, #55	; 0x37

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 802481a:	4640      	mov	r0, r8
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 802481c:	0e1d      	lsrs	r5, r3, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 802481e:	0c1c      	lsrs	r4, r3, #16
 8024820:	2105      	movs	r1, #5
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024822:	0a1b      	lsrs	r3, r3, #8
 8024824:	f88d 300e 	strb.w	r3, [sp, #14]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024828:	f88d 200c 	strb.w	r2, [sp, #12]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 802482c:	f88d 5010 	strb.w	r5, [sp, #16]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024830:	f88d 400f 	strb.w	r4, [sp, #15]
 8024834:	f000 fcdc 	bl	80251f0 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 8024838:	a803      	add	r0, sp, #12
 802483a:	2105      	movs	r1, #5
 802483c:	f000 fcec 	bl	8025218 <protocol_send_payload>
        protocol_send_tail();
 8024840:	f000 fcec 	bl	802521c <protocol_send_tail>
 8024844:	e7a1      	b.n	802478a <ep_radar_base_handle_change+0xae>
    {
        uint8_t message[11];

        /* compile message */
        wr_payload_u8 (message,  0, MSG_SET_FRAME_FORMAT);
        wr_payload_u32(message,  1, frame_format.num_samples_per_chirp);
 8024846:	9b03      	ldr	r3, [sp, #12]
        wr_payload_u32(message,  5, frame_format.num_chirps_per_frame);
 8024848:	9a04      	ldr	r2, [sp, #16]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802484a:	f89d 6014 	ldrb.w	r6, [sp, #20]
 802484e:	f89d 4015 	ldrb.w	r4, [sp, #21]
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024852:	f88d 3001 	strb.w	r3, [sp, #1]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024856:	0e19      	lsrs	r1, r3, #24
 8024858:	ea4f 6a12 	mov.w	sl, r2, lsr #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 802485c:	ea4f 4912 	mov.w	r9, r2, lsr #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024860:	ea4f 2c12 	mov.w	ip, r2, lsr #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024864:	f04f 0e41 	mov.w	lr, #65	; 0x41

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024868:	0c1f      	lsrs	r7, r3, #16
        wr_payload_u8 (message,  9, frame_format.rx_mask);
        wr_payload_u8 (message, 10, frame_format.signal_part);

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 802486a:	4640      	mov	r0, r8
    payload[offset + 1] = (value >>  8) & 0xFF;
 802486c:	0a1b      	lsrs	r3, r3, #8
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 802486e:	f88d 1004 	strb.w	r1, [sp, #4]
 8024872:	210b      	movs	r1, #11
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024874:	f88d 7003 	strb.w	r7, [sp, #3]
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024878:	f88d 3002 	strb.w	r3, [sp, #2]
    payload[offset    ] =  value        & 0xFF;
 802487c:	f88d 2005 	strb.w	r2, [sp, #5]
static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024880:	f88d c006 	strb.w	ip, [sp, #6]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024884:	f88d e000 	strb.w	lr, [sp]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024888:	f88d a008 	strb.w	sl, [sp, #8]
    payload[offset + 2] = (value >> 16) & 0xFF;
 802488c:	f88d 9007 	strb.w	r9, [sp, #7]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024890:	f88d 6009 	strb.w	r6, [sp, #9]
 8024894:	f88d 400a 	strb.w	r4, [sp, #10]
 8024898:	f000 fcaa 	bl	80251f0 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 802489c:	4668      	mov	r0, sp
 802489e:	210b      	movs	r1, #11
 80248a0:	466f      	mov	r7, sp
 80248a2:	f000 fcb9 	bl	8025218 <protocol_send_payload>
        protocol_send_tail();
 80248a6:	f000 fcb9 	bl	802521c <protocol_send_tail>
 80248aa:	e72c      	b.n	8024706 <ep_radar_base_handle_change+0x2a>
    {
        uint8_t message[5];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_CHRIP_DURATION);
        wr_payload_u32(message, 1, chirp_duration);
 80248ac:	9b00      	ldr	r3, [sp, #0]
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 80248ae:	f88d 300d 	strb.w	r3, [sp, #13]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80248b2:	2235      	movs	r2, #53	; 0x35
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 80248b4:	0e1e      	lsrs	r6, r3, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 80248b6:	0c1c      	lsrs	r4, r3, #16

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 80248b8:	4640      	mov	r0, r8
    payload[offset + 1] = (value >>  8) & 0xFF;
 80248ba:	0a1b      	lsrs	r3, r3, #8
 80248bc:	2105      	movs	r1, #5
 80248be:	f88d 300e 	strb.w	r3, [sp, #14]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80248c2:	f88d 200c 	strb.w	r2, [sp, #12]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 80248c6:	f88d 6010 	strb.w	r6, [sp, #16]
    payload[offset + 2] = (value >> 16) & 0xFF;
 80248ca:	f88d 400f 	strb.w	r4, [sp, #15]
 80248ce:	f000 fc8f 	bl	80251f0 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 80248d2:	a803      	add	r0, sp, #12
 80248d4:	2105      	movs	r1, #5
 80248d6:	f000 fc9f 	bl	8025218 <protocol_send_payload>
        protocol_send_tail();
 80248da:	f000 fc9f 	bl	802521c <protocol_send_tail>
 80248de:	e792      	b.n	8024806 <ep_radar_base_handle_change+0x12a>
 80248e0:	1ffe9804 	.word	0x1ffe9804

080248e4 <ep_radar_doppler_handle_message>:

uint16_t ep_radar_doppler_handle_message(uint8_t endpoint,
                                         uint8_t* message_data,
                                         uint16_t num_bytes,
                                         void* context)
{
 80248e4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80248e6:	4605      	mov	r5, r0
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (message_data[0])
 80248e8:	7808      	ldrb	r0, [r1, #0]

uint16_t ep_radar_doppler_handle_message(uint8_t endpoint,
                                         uint8_t* message_data,
                                         uint16_t num_bytes,
                                         void* context)
{
 80248ea:	b087      	sub	sp, #28
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (message_data[0])
 80248ec:	b310      	cbz	r0, 8024934 <ep_radar_doppler_handle_message+0x50>
 80248ee:	2801      	cmp	r0, #1
 80248f0:	d004      	beq.n	80248fc <ep_radar_doppler_handle_message+0x18>
        break;

    default:
        break;
    }
    return PROTOCOL_STATUS_INVALID_PAYLOAD;
 80248f2:	f64f 74ff 	movw	r4, #65535	; 0xffff
}
 80248f6:	4620      	mov	r0, r4
 80248f8:	b007      	add	sp, #28
 80248fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
            return send_doppler_configuration(endpoint, radar_driver);
        }
        break;

    case MSG_SET_CONFIGURATION:
        if (num_bytes == 6)
 80248fc:	2a06      	cmp	r2, #6
 80248fe:	d1f8      	bne.n	80248f2 <ep_radar_doppler_handle_message+0xe>
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 8024900:	78cc      	ldrb	r4, [r1, #3]
           (((uint32_t)payload[offset + 1]) <<  8) |
            ((uint32_t)payload[offset    ]);
 8024902:	7848      	ldrb	r0, [r1, #1]

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 8024904:	788d      	ldrb	r5, [r1, #2]
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 8024906:	790a      	ldrb	r2, [r1, #4]
            unsigned error_code;
            Doppler_Configuration_t configuration;

            /* extract parameters from message */
            configuration.frequency_kHz = rd_payload_u32(message_data, 1);
            configuration.tx_power      = rd_payload_u8 (message_data, 5);
 8024908:	7949      	ldrb	r1, [r1, #5]
 802490a:	f88d 1014 	strb.w	r1, [sp, #20]
           (((uint32_t)payload[offset + 2]) << 16) |
 802490e:	0421      	lsls	r1, r4, #16
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 8024910:	ea41 6202 	orr.w	r2, r1, r2, lsl #24
 8024914:	4302      	orrs	r2, r0
 8024916:	ea42 2205 	orr.w	r2, r2, r5, lsl #8

            /* apply FMCW configuration */
            error_code = radar_set_doppler_configuration(radar_driver,
 802491a:	a904      	add	r1, sp, #16
 802491c:	4618      	mov	r0, r3
 802491e:	9301      	str	r3, [sp, #4]
        {
            unsigned error_code;
            Doppler_Configuration_t configuration;

            /* extract parameters from message */
            configuration.frequency_kHz = rd_payload_u32(message_data, 1);
 8024920:	9204      	str	r2, [sp, #16]
            configuration.tx_power      = rd_payload_u8 (message_data, 5);

            /* apply FMCW configuration */
            error_code = radar_set_doppler_configuration(radar_driver,
 8024922:	f7fc fccd 	bl	80212c0 <radar_set_doppler_configuration>
                                                         &configuration);

            /* inform other endpoints of the change */
            protocol_broadcast_change(radar_driver,
 8024926:	9b01      	ldr	r3, [sp, #4]
            /* extract parameters from message */
            configuration.frequency_kHz = rd_payload_u32(message_data, 1);
            configuration.tx_power      = rd_payload_u8 (message_data, 5);

            /* apply FMCW configuration */
            error_code = radar_set_doppler_configuration(radar_driver,
 8024928:	4604      	mov	r4, r0
                                                         &configuration);

            /* inform other endpoints of the change */
            protocol_broadcast_change(radar_driver,
 802492a:	2103      	movs	r1, #3
 802492c:	4618      	mov	r0, r3
 802492e:	f000 fe35 	bl	802559c <protocol_broadcast_change>
 8024932:	e7e0      	b.n	80248f6 <ep_radar_doppler_handle_message+0x12>
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (message_data[0])
    {
    case MSG_GET_CONFIGURATION:
        if (num_bytes == 1)
 8024934:	2a01      	cmp	r2, #1
 8024936:	d1dc      	bne.n	80248f2 <ep_radar_doppler_handle_message+0xe>
{
    uint16_t error_code;
    Doppler_Configuration_t doppler_configuration;

    /* read FMCW configuration from device */
    error_code = radar_get_doppler_configuration(radar_driver,
 8024938:	4618      	mov	r0, r3
 802493a:	a904      	add	r1, sp, #16
 802493c:	9201      	str	r2, [sp, #4]
 802493e:	f7fc fcdd 	bl	80212fc <radar_get_doppler_configuration>
                                                 &doppler_configuration);

    if (error_code == RADAR_ERR_OK)
 8024942:	9a01      	ldr	r2, [sp, #4]
 8024944:	4604      	mov	r4, r0
 8024946:	2800      	cmp	r0, #0
 8024948:	d1d5      	bne.n	80248f6 <ep_radar_doppler_handle_message+0x12>
    {
        uint8_t message[6];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_CONFIGURATION);
        wr_payload_u32(message, 1, doppler_configuration.frequency_kHz);
 802494a:	9b04      	ldr	r3, [sp, #16]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802494c:	f89d 6014 	ldrb.w	r6, [sp, #20]
 8024950:	f88d 2008 	strb.w	r2, [sp, #8]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024954:	0e1f      	lsrs	r7, r3, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024956:	0a1a      	lsrs	r2, r3, #8
        wr_payload_u8 (message, 5, doppler_configuration.tx_power);

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 8024958:	4628      	mov	r0, r5
 802495a:	2106      	movs	r1, #6

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 802495c:	0c1d      	lsrs	r5, r3, #16
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 802495e:	f88d 3009 	strb.w	r3, [sp, #9]
static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024962:	f88d 200a 	strb.w	r2, [sp, #10]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024966:	f88d 700c 	strb.w	r7, [sp, #12]
    payload[offset + 2] = (value >> 16) & 0xFF;
 802496a:	f88d 500b 	strb.w	r5, [sp, #11]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802496e:	f88d 600d 	strb.w	r6, [sp, #13]
 8024972:	f000 fc3d 	bl	80251f0 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 8024976:	a802      	add	r0, sp, #8
 8024978:	2106      	movs	r1, #6
 802497a:	f000 fc4d 	bl	8025218 <protocol_send_payload>
        protocol_send_tail();
 802497e:	f000 fc4d 	bl	802521c <protocol_send_tail>
    switch (message_data[0])
    {
    case MSG_GET_CONFIGURATION:
        if (num_bytes == 1)
        {
            return send_doppler_configuration(endpoint, radar_driver);
 8024982:	e7b8      	b.n	80248f6 <ep_radar_doppler_handle_message+0x12>

08024984 <ep_radar_doppler_handle_change>:
void ep_radar_doppler_handle_change(uint8_t endpoint, void* context,
                                    uint32_t what)
{
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    if (what == EP_RADAR_CHNG_DOPPLER_SETTINGS)
 8024984:	2a03      	cmp	r2, #3
 8024986:	d000      	beq.n	802498a <ep_radar_doppler_handle_change+0x6>
 8024988:	4770      	bx	lr
    return PROTOCOL_STATUS_INVALID_PAYLOAD;
}

void ep_radar_doppler_handle_change(uint8_t endpoint, void* context,
                                    uint32_t what)
{
 802498a:	b570      	push	{r4, r5, r6, lr}
 802498c:	b084      	sub	sp, #16
 802498e:	4604      	mov	r4, r0
{
    uint16_t error_code;
    Doppler_Configuration_t doppler_configuration;

    /* read FMCW configuration from device */
    error_code = radar_get_doppler_configuration(radar_driver,
 8024990:	4608      	mov	r0, r1
 8024992:	a902      	add	r1, sp, #8
 8024994:	f7fc fcb2 	bl	80212fc <radar_get_doppler_configuration>
                                                 &doppler_configuration);

    if (error_code == RADAR_ERR_OK)
 8024998:	b9e0      	cbnz	r0, 80249d4 <ep_radar_doppler_handle_change+0x50>
    {
        uint8_t message[6];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_CONFIGURATION);
        wr_payload_u32(message, 1, doppler_configuration.frequency_kHz);
 802499a:	9b02      	ldr	r3, [sp, #8]
 802499c:	f89d 200c 	ldrb.w	r2, [sp, #12]
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 80249a0:	f88d 3001 	strb.w	r3, [sp, #1]
        wr_payload_u8 (message, 5, doppler_configuration.tx_power);

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 80249a4:	4620      	mov	r0, r4
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 80249a6:	0e1e      	lsrs	r6, r3, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 80249a8:	0c1d      	lsrs	r5, r3, #16
 80249aa:	2106      	movs	r1, #6
    payload[offset + 1] = (value >>  8) & 0xFF;
 80249ac:	0a1b      	lsrs	r3, r3, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80249ae:	2401      	movs	r4, #1
static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 80249b0:	f88d 3002 	strb.w	r3, [sp, #2]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80249b4:	f88d 2005 	strb.w	r2, [sp, #5]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 80249b8:	f88d 6004 	strb.w	r6, [sp, #4]
    payload[offset + 2] = (value >> 16) & 0xFF;
 80249bc:	f88d 5003 	strb.w	r5, [sp, #3]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80249c0:	f88d 4000 	strb.w	r4, [sp]
 80249c4:	f000 fc14 	bl	80251f0 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 80249c8:	4668      	mov	r0, sp
 80249ca:	2106      	movs	r1, #6
 80249cc:	f000 fc24 	bl	8025218 <protocol_send_payload>
        protocol_send_tail();
 80249d0:	f000 fc24 	bl	802521c <protocol_send_tail>
{
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    if (what == EP_RADAR_CHNG_DOPPLER_SETTINGS)
        send_doppler_configuration(endpoint, radar_driver);
}
 80249d4:	b004      	add	sp, #16
 80249d6:	bd70      	pop	{r4, r5, r6, pc}

080249d8 <send_fmcw_configuration>:
==============================================================================
*/

static uint16_t send_fmcw_configuration(uint8_t endpoint,
                                        Radar_Handle_t radar_driver)
{
 80249d8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80249dc:	b08c      	sub	sp, #48	; 0x30
 80249de:	4606      	mov	r6, r0
    uint16_t error_code;
    Fmcw_Configuration_t fmcw_configuration;

    /* read FMCW configuration from device */
    error_code = radar_get_fmcw_configuration(radar_driver,
 80249e0:	4608      	mov	r0, r1
 80249e2:	a906      	add	r1, sp, #24
 80249e4:	f7fc fcd4 	bl	8021390 <radar_get_fmcw_configuration>
                                              &fmcw_configuration);

    if (error_code == RADAR_ERR_OK)
 80249e8:	4604      	mov	r4, r0
 80249ea:	bba8      	cbnz	r0, 8024a58 <send_fmcw_configuration+0x80>
        wr_payload_u32(message,   1, fmcw_configuration.lower_frequency_kHz);
        wr_payload_u32(message,   5, fmcw_configuration.upper_frequency_kHz);
        wr_payload_u8 (message,   9, fmcw_configuration.direction);
        wr_payload_u8 (message,  10, fmcw_configuration.tx_power);

        if( g_host_supports_advanced_configuration ) {
 80249ec:	4932      	ldr	r1, [pc, #200]	; (8024ab8 <send_fmcw_configuration+0xe0>)
        uint8_t message[11 + 12];
        size_t len = 11;

        /* compile message */
        wr_payload_u8 (message,   0, MSG_SET_CONFIGURATION);
        wr_payload_u32(message,   1, fmcw_configuration.lower_frequency_kHz);
 80249ee:	9b06      	ldr	r3, [sp, #24]
        wr_payload_u32(message,   5, fmcw_configuration.upper_frequency_kHz);
 80249f0:	9a07      	ldr	r2, [sp, #28]
        wr_payload_u8 (message,   9, fmcw_configuration.direction);
        wr_payload_u8 (message,  10, fmcw_configuration.tx_power);

        if( g_host_supports_advanced_configuration ) {
 80249f2:	6809      	ldr	r1, [r1, #0]
 80249f4:	f89d 5020 	ldrb.w	r5, [sp, #32]
 80249f8:	f89d 0021 	ldrb.w	r0, [sp, #33]	; 0x21
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 80249fc:	f88d 3001 	strb.w	r3, [sp, #1]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024a00:	ea4f 6a13 	mov.w	sl, r3, lsr #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024a04:	ea4f 4913 	mov.w	r9, r3, lsr #16
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024a08:	ea4f 6812 	mov.w	r8, r2, lsr #24
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024a0c:	0a1b      	lsrs	r3, r3, #8

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024a0e:	ea4f 4c12 	mov.w	ip, r2, lsr #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024a12:	ea4f 2e12 	mov.w	lr, r2, lsr #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024a16:	2701      	movs	r7, #1
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024a18:	f88d a004 	strb.w	sl, [sp, #4]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024a1c:	f88d 9003 	strb.w	r9, [sp, #3]
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024a20:	f88d 3002 	strb.w	r3, [sp, #2]
    payload[offset    ] =  value        & 0xFF;
 8024a24:	f88d 2005 	strb.w	r2, [sp, #5]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024a28:	f88d 8008 	strb.w	r8, [sp, #8]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024a2c:	f88d c007 	strb.w	ip, [sp, #7]
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024a30:	f88d e006 	strb.w	lr, [sp, #6]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024a34:	f88d 7000 	strb.w	r7, [sp]
 8024a38:	f88d 5009 	strb.w	r5, [sp, #9]
 8024a3c:	f88d 000a 	strb.w	r0, [sp, #10]
 8024a40:	b971      	cbnz	r1, 8024a60 <send_fmcw_configuration+0x88>
 8024a42:	250b      	movs	r5, #11
			wr_payload_u32 (message, 15, fmcw_configuration.down_chirp_duration_nsec);
			wr_payload_u32 (message, 19, fmcw_configuration.chirp_to_chirp_delay_nsec);
			len += 4*sizeof(uint32_t);
        }
        /* send message */
        protocol_send_header(endpoint, len);
 8024a44:	4630      	mov	r0, r6
 8024a46:	4629      	mov	r1, r5
 8024a48:	f000 fbd2 	bl	80251f0 <protocol_send_header>
        protocol_send_payload(message, len);
 8024a4c:	4629      	mov	r1, r5
 8024a4e:	4668      	mov	r0, sp
 8024a50:	f000 fbe2 	bl	8025218 <protocol_send_payload>
        protocol_send_tail();
 8024a54:	f000 fbe2 	bl	802521c <protocol_send_tail>
    }
    return error_code;
}
 8024a58:	4620      	mov	r0, r4
 8024a5a:	b00c      	add	sp, #48	; 0x30
 8024a5c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        wr_payload_u32(message,   5, fmcw_configuration.upper_frequency_kHz);
        wr_payload_u8 (message,   9, fmcw_configuration.direction);
        wr_payload_u8 (message,  10, fmcw_configuration.tx_power);

        if( g_host_supports_advanced_configuration ) {
			wr_payload_u32 (message, 11, fmcw_configuration.up_chirp_duration_nsec);
 8024a60:	9b09      	ldr	r3, [sp, #36]	; 0x24
			wr_payload_u32 (message, 15, fmcw_configuration.down_chirp_duration_nsec);
 8024a62:	990a      	ldr	r1, [sp, #40]	; 0x28
			wr_payload_u32 (message, 19, fmcw_configuration.chirp_to_chirp_delay_nsec);
 8024a64:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024a66:	f88d 300b 	strb.w	r3, [sp, #11]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024a6a:	ea4f 6a13 	mov.w	sl, r3, lsr #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024a6e:	ea4f 4913 	mov.w	r9, r3, lsr #16
 8024a72:	0c15      	lsrs	r5, r2, #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024a74:	0a1b      	lsrs	r3, r3, #8
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024a76:	ea4f 6811 	mov.w	r8, r1, lsr #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024a7a:	ea4f 4c11 	mov.w	ip, r1, lsr #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024a7e:	ea4f 2e11 	mov.w	lr, r1, lsr #8
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024a82:	0e17      	lsrs	r7, r2, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024a84:	0a10      	lsrs	r0, r2, #8

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024a86:	f88d 5015 	strb.w	r5, [sp, #21]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024a8a:	f88d a00e 	strb.w	sl, [sp, #14]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024a8e:	f88d 900d 	strb.w	r9, [sp, #13]
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024a92:	f88d 300c 	strb.w	r3, [sp, #12]
    payload[offset    ] =  value        & 0xFF;
 8024a96:	f88d 100f 	strb.w	r1, [sp, #15]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024a9a:	f88d 8012 	strb.w	r8, [sp, #18]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024a9e:	f88d c011 	strb.w	ip, [sp, #17]
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024aa2:	f88d e010 	strb.w	lr, [sp, #16]
    payload[offset    ] =  value        & 0xFF;
 8024aa6:	f88d 2013 	strb.w	r2, [sp, #19]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024aaa:	f88d 7016 	strb.w	r7, [sp, #22]
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024aae:	f88d 0014 	strb.w	r0, [sp, #20]
    payload[offset    ] =  value        & 0xFF;
 8024ab2:	251b      	movs	r5, #27
 8024ab4:	e7c6      	b.n	8024a44 <send_fmcw_configuration+0x6c>
 8024ab6:	bf00      	nop
 8024ab8:	1fff180c 	.word	0x1fff180c

08024abc <ep_radar_fmcw_handle_message>:
==============================================================================
*/

uint16_t ep_radar_fmcw_handle_message(uint8_t endpoint, uint8_t* message_data,
                                      uint16_t num_bytes, void* context)
{
 8024abc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8024ac0:	4605      	mov	r5, r0
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (message_data[0])
 8024ac2:	7808      	ldrb	r0, [r1, #0]
==============================================================================
*/

uint16_t ep_radar_fmcw_handle_message(uint8_t endpoint, uint8_t* message_data,
                                      uint16_t num_bytes, void* context)
{
 8024ac4:	b08b      	sub	sp, #44	; 0x2c
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (message_data[0])
 8024ac6:	2803      	cmp	r0, #3
 8024ac8:	d805      	bhi.n	8024ad6 <ep_radar_fmcw_handle_message+0x1a>
 8024aca:	e8df f000 	tbb	[pc, r0]
 8024ace:	1443      	.short	0x1443
 8024ad0:	0a02      	.short	0x0a02
            return error_code;
        }
        break;

    case MSG_GET_BW_PER_SECOND:
        if (num_bytes == 1)
 8024ad2:	2a01      	cmp	r2, #1
 8024ad4:	d049      	beq.n	8024b6a <ep_radar_fmcw_handle_message+0xae>
        break;

    default:
        break;
    }
    return PROTOCOL_STATUS_INVALID_PAYLOAD;
 8024ad6:	f64f 74ff 	movw	r4, #65535	; 0xffff
}
 8024ada:	4620      	mov	r0, r4
 8024adc:	b00b      	add	sp, #44	; 0x2c
 8024ade:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        	g_host_supports_advanced_configuration = 0;
            return send_fmcw_configuration(endpoint, radar_driver);
        }
        break;
    case MSG_GET_ADV_CONFIGURATION:
		if (num_bytes == 1)
 8024ae2:	2a01      	cmp	r2, #1
 8024ae4:	d1f7      	bne.n	8024ad6 <ep_radar_fmcw_handle_message+0x1a>
		{
			g_host_supports_advanced_configuration = 1;
 8024ae6:	4c31      	ldr	r4, [pc, #196]	; (8024bac <ep_radar_fmcw_handle_message+0xf0>)
			return send_fmcw_configuration(endpoint, radar_driver);
 8024ae8:	4628      	mov	r0, r5
 8024aea:	4619      	mov	r1, r3
        }
        break;
    case MSG_GET_ADV_CONFIGURATION:
		if (num_bytes == 1)
		{
			g_host_supports_advanced_configuration = 1;
 8024aec:	6022      	str	r2, [r4, #0]
			return send_fmcw_configuration(endpoint, radar_driver);
 8024aee:	f7ff ff73 	bl	80249d8 <send_fmcw_configuration>
 8024af2:	4604      	mov	r4, r0
 8024af4:	e7f1      	b.n	8024ada <ep_radar_fmcw_handle_message+0x1e>
		}
		break;

    case MSG_SET_CONFIGURATION:
        if (num_bytes == 11)
 8024af6:	2a0b      	cmp	r2, #11
 8024af8:	d1ed      	bne.n	8024ad6 <ep_radar_fmcw_handle_message+0x1a>
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 8024afa:	f891 c003 	ldrb.w	ip, [r1, #3]
 8024afe:	79ce      	ldrb	r6, [r1, #7]
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 8024b00:	f891 8004 	ldrb.w	r8, [r1, #4]
 8024b04:	7a0a      	ldrb	r2, [r1, #8]
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
            ((uint32_t)payload[offset    ]);
 8024b06:	784d      	ldrb	r5, [r1, #1]
 8024b08:	7948      	ldrb	r0, [r1, #5]

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 8024b0a:	f891 e006 	ldrb.w	lr, [r1, #6]
            Fmcw_Configuration_t config;

            /* extract parameters from message */
            config.lower_frequency_kHz = rd_payload_u32(message_data,  1);
            config.upper_frequency_kHz = rd_payload_u32(message_data,  5);
            config.direction           = rd_payload_u8 (message_data,  9);
 8024b0e:	f891 9009 	ldrb.w	r9, [r1, #9]
            config.tx_power            = rd_payload_u8 (message_data, 10);
 8024b12:	7a8f      	ldrb	r7, [r1, #10]
 8024b14:	788c      	ldrb	r4, [r1, #2]

            /* apply FMCW configuration */
            error_code = radar_set_fmcw_configuration(radar_driver, &config);
 8024b16:	9301      	str	r3, [sp, #4]
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 8024b18:	ea4f 410c 	mov.w	r1, ip, lsl #16
 8024b1c:	0436      	lsls	r6, r6, #16
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, uint16_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 8024b1e:	ea41 6108 	orr.w	r1, r1, r8, lsl #24
 8024b22:	ea46 6202 	orr.w	r2, r6, r2, lsl #24
 8024b26:	4329      	orrs	r1, r5
 8024b28:	4302      	orrs	r2, r0
 8024b2a:	ea41 2404 	orr.w	r4, r1, r4, lsl #8
 8024b2e:	ea42 220e 	orr.w	r2, r2, lr, lsl #8
 8024b32:	a904      	add	r1, sp, #16
 8024b34:	4618      	mov	r0, r3
        {
            unsigned error_code;
            Fmcw_Configuration_t config;

            /* extract parameters from message */
            config.lower_frequency_kHz = rd_payload_u32(message_data,  1);
 8024b36:	9404      	str	r4, [sp, #16]
            config.upper_frequency_kHz = rd_payload_u32(message_data,  5);
            config.direction           = rd_payload_u8 (message_data,  9);
 8024b38:	f88d 9018 	strb.w	r9, [sp, #24]
            unsigned error_code;
            Fmcw_Configuration_t config;

            /* extract parameters from message */
            config.lower_frequency_kHz = rd_payload_u32(message_data,  1);
            config.upper_frequency_kHz = rd_payload_u32(message_data,  5);
 8024b3c:	9205      	str	r2, [sp, #20]
            config.direction           = rd_payload_u8 (message_data,  9);
            config.tx_power            = rd_payload_u8 (message_data, 10);
 8024b3e:	f88d 7019 	strb.w	r7, [sp, #25]

            /* apply FMCW configuration */
            error_code = radar_set_fmcw_configuration(radar_driver, &config);
 8024b42:	f7fc fbe1 	bl	8021308 <radar_set_fmcw_configuration>

            /* inform other endpoints of the change */
            protocol_broadcast_change(radar_driver,
 8024b46:	9b01      	ldr	r3, [sp, #4]
            config.upper_frequency_kHz = rd_payload_u32(message_data,  5);
            config.direction           = rd_payload_u8 (message_data,  9);
            config.tx_power            = rd_payload_u8 (message_data, 10);

            /* apply FMCW configuration */
            error_code = radar_set_fmcw_configuration(radar_driver, &config);
 8024b48:	4604      	mov	r4, r0

            /* inform other endpoints of the change */
            protocol_broadcast_change(radar_driver,
 8024b4a:	2102      	movs	r1, #2
 8024b4c:	4618      	mov	r0, r3
 8024b4e:	f000 fd25 	bl	802559c <protocol_broadcast_change>
 8024b52:	e7c2      	b.n	8024ada <ep_radar_fmcw_handle_message+0x1e>
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (message_data[0])
    {
    case MSG_GET_CONFIGURATION:
        if (num_bytes == 1)
 8024b54:	2a01      	cmp	r2, #1
 8024b56:	d1be      	bne.n	8024ad6 <ep_radar_fmcw_handle_message+0x1a>
        {
        	// a local variable does not work, because the updates are also sent on updates!
        	g_host_supports_advanced_configuration = 0;
 8024b58:	4a14      	ldr	r2, [pc, #80]	; (8024bac <ep_radar_fmcw_handle_message+0xf0>)
            return send_fmcw_configuration(endpoint, radar_driver);
 8024b5a:	4619      	mov	r1, r3
 8024b5c:	4628      	mov	r0, r5
    {
    case MSG_GET_CONFIGURATION:
        if (num_bytes == 1)
        {
        	// a local variable does not work, because the updates are also sent on updates!
        	g_host_supports_advanced_configuration = 0;
 8024b5e:	2300      	movs	r3, #0
 8024b60:	6013      	str	r3, [r2, #0]
            return send_fmcw_configuration(endpoint, radar_driver);
 8024b62:	f7ff ff39 	bl	80249d8 <send_fmcw_configuration>
 8024b66:	4604      	mov	r4, r0
 8024b68:	e7b7      	b.n	8024ada <ep_radar_fmcw_handle_message+0x1e>
{
    uint16_t error_code;
    uint32_t bandwidth_per_second;

    /* read bandwidth per second from device */
    error_code = radar_get_bandwidth_per_second(radar_driver,
 8024b6a:	4618      	mov	r0, r3
 8024b6c:	a903      	add	r1, sp, #12
 8024b6e:	f7fc fc15 	bl	802139c <radar_get_bandwidth_per_second>
                                                &bandwidth_per_second);

    if (error_code == RADAR_ERR_OK)
 8024b72:	4604      	mov	r4, r0
 8024b74:	2800      	cmp	r0, #0
 8024b76:	d1b0      	bne.n	8024ada <ep_radar_fmcw_handle_message+0x1e>
    {
        uint8_t message[5];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_BW_PER_SECOND);
        wr_payload_u32(message, 1, bandwidth_per_second);
 8024b78:	9b03      	ldr	r3, [sp, #12]
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024b7a:	f88d 3011 	strb.w	r3, [sp, #17]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024b7e:	2202      	movs	r2, #2

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 8024b80:	4628      	mov	r0, r5
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024b82:	0e1e      	lsrs	r6, r3, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024b84:	0c1d      	lsrs	r5, r3, #16
 8024b86:	2105      	movs	r1, #5
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024b88:	0a1b      	lsrs	r3, r3, #8
 8024b8a:	f88d 3012 	strb.w	r3, [sp, #18]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024b8e:	f88d 2010 	strb.w	r2, [sp, #16]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024b92:	f88d 6014 	strb.w	r6, [sp, #20]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024b96:	f88d 5013 	strb.w	r5, [sp, #19]
 8024b9a:	f000 fb29 	bl	80251f0 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 8024b9e:	a804      	add	r0, sp, #16
 8024ba0:	2105      	movs	r1, #5
 8024ba2:	f000 fb39 	bl	8025218 <protocol_send_payload>
        protocol_send_tail();
 8024ba6:	f000 fb39 	bl	802521c <protocol_send_tail>
        break;

    case MSG_GET_BW_PER_SECOND:
        if (num_bytes == 1)
        {
            return send_bandwidth_per_second(endpoint, radar_driver);
 8024baa:	e796      	b.n	8024ada <ep_radar_fmcw_handle_message+0x1e>
 8024bac:	1fff180c 	.word	0x1fff180c

08024bb0 <ep_radar_fmcw_handle_change>:
    return PROTOCOL_STATUS_INVALID_PAYLOAD;
}

void ep_radar_fmcw_handle_change(uint8_t endpoint, void* context,
                                 uint32_t what)
{
 8024bb0:	b570      	push	{r4, r5, r6, lr}
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (what)
 8024bb2:	2a02      	cmp	r2, #2
    return PROTOCOL_STATUS_INVALID_PAYLOAD;
}

void ep_radar_fmcw_handle_change(uint8_t endpoint, void* context,
                                 uint32_t what)
{
 8024bb4:	b084      	sub	sp, #16
 8024bb6:	4614      	mov	r4, r2
 8024bb8:	4606      	mov	r6, r0
 8024bba:	460d      	mov	r5, r1
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

    switch (what)
 8024bbc:	d026      	beq.n	8024c0c <ep_radar_fmcw_handle_change+0x5c>
 8024bbe:	2a04      	cmp	r2, #4
 8024bc0:	d003      	beq.n	8024bca <ep_radar_fmcw_handle_change+0x1a>
 8024bc2:	2a01      	cmp	r2, #1
 8024bc4:	d001      	beq.n	8024bca <ep_radar_fmcw_handle_change+0x1a>
        break;

    default:
        break;
    }
}
 8024bc6:	b004      	add	sp, #16
 8024bc8:	bd70      	pop	{r4, r5, r6, pc}
{
    uint16_t error_code;
    uint32_t bandwidth_per_second;

    /* read bandwidth per second from device */
    error_code = radar_get_bandwidth_per_second(radar_driver,
 8024bca:	4628      	mov	r0, r5
 8024bcc:	a901      	add	r1, sp, #4
 8024bce:	f7fc fbe5 	bl	802139c <radar_get_bandwidth_per_second>
                                                &bandwidth_per_second);

    if (error_code == RADAR_ERR_OK)
 8024bd2:	2800      	cmp	r0, #0
 8024bd4:	d1f7      	bne.n	8024bc6 <ep_radar_fmcw_handle_change+0x16>
    {
        uint8_t message[5];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_BW_PER_SECOND);
        wr_payload_u32(message, 1, bandwidth_per_second);
 8024bd6:	9b01      	ldr	r3, [sp, #4]
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024bd8:	f88d 3009 	strb.w	r3, [sp, #9]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024bdc:	0e1d      	lsrs	r5, r3, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024bde:	0c1c      	lsrs	r4, r3, #16
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024be0:	2202      	movs	r2, #2
static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024be2:	0a1b      	lsrs	r3, r3, #8

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 8024be4:	4630      	mov	r0, r6
 8024be6:	2105      	movs	r1, #5
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024be8:	f88d 500c 	strb.w	r5, [sp, #12]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024bec:	f88d 400b 	strb.w	r4, [sp, #11]
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024bf0:	f88d 300a 	strb.w	r3, [sp, #10]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024bf4:	f88d 2008 	strb.w	r2, [sp, #8]
 8024bf8:	f000 fafa 	bl	80251f0 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 8024bfc:	a802      	add	r0, sp, #8
 8024bfe:	2105      	movs	r1, #5
 8024c00:	f000 fb0a 	bl	8025218 <protocol_send_payload>
        protocol_send_tail();
 8024c04:	f000 fb0a 	bl	802521c <protocol_send_tail>
        break;

    default:
        break;
    }
}
 8024c08:	b004      	add	sp, #16
 8024c0a:	bd70      	pop	{r4, r5, r6, pc}
    case EP_RADAR_CHNG_FRAME_FORMAT:
        send_bandwidth_per_second(endpoint, radar_driver);
        break;

    case EP_RADAR_CHNG_FMCW_SETTINGS:
        send_fmcw_configuration(endpoint, radar_driver);
 8024c0c:	f7ff fee4 	bl	80249d8 <send_fmcw_configuration>
{
    uint16_t error_code;
    uint32_t bandwidth_per_second;

    /* read bandwidth per second from device */
    error_code = radar_get_bandwidth_per_second(radar_driver,
 8024c10:	4628      	mov	r0, r5
 8024c12:	a901      	add	r1, sp, #4
 8024c14:	f7fc fbc2 	bl	802139c <radar_get_bandwidth_per_second>
                                                &bandwidth_per_second);

    if (error_code == RADAR_ERR_OK)
 8024c18:	2800      	cmp	r0, #0
 8024c1a:	d1d4      	bne.n	8024bc6 <ep_radar_fmcw_handle_change+0x16>
    {
        uint8_t message[5];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_BW_PER_SECOND);
        wr_payload_u32(message, 1, bandwidth_per_second);
 8024c1c:	9b01      	ldr	r3, [sp, #4]
 8024c1e:	f88d 4008 	strb.w	r4, [sp, #8]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024c22:	0e1d      	lsrs	r5, r3, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024c24:	0c1c      	lsrs	r4, r3, #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024c26:	0a1a      	lsrs	r2, r3, #8

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 8024c28:	4630      	mov	r0, r6
 8024c2a:	2105      	movs	r1, #5
    payload[offset    ] =  value        & 0xFF;
 8024c2c:	f88d 3009 	strb.w	r3, [sp, #9]
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024c30:	f88d 500c 	strb.w	r5, [sp, #12]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024c34:	f88d 400b 	strb.w	r4, [sp, #11]
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024c38:	f88d 200a 	strb.w	r2, [sp, #10]
 8024c3c:	e7dc      	b.n	8024bf8 <ep_radar_fmcw_handle_change+0x48>
 8024c3e:	bf00      	nop

08024c40 <ep_radar_industrial_handle_message>:
==============================================================================
*/

uint16_t ep_radar_industrial_handle_message(uint8_t endpoint, uint8_t* message_data,
											uint16_t num_bytes,	void* context)
{
 8024c40:	b530      	push	{r4, r5, lr}
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

	uint16_t error_code = 0;

    switch (message_data[0])
 8024c42:	780c      	ldrb	r4, [r1, #0]
==============================================================================
*/

uint16_t ep_radar_industrial_handle_message(uint8_t endpoint, uint8_t* message_data,
											uint16_t num_bytes,	void* context)
{
 8024c44:	b083      	sub	sp, #12
 8024c46:	4605      	mov	r5, r0
    Radar_Handle_t radar_driver = (Radar_Handle_t)context;

	uint16_t error_code = 0;

    switch (message_data[0])
 8024c48:	2c05      	cmp	r4, #5
 8024c4a:	d806      	bhi.n	8024c5a <ep_radar_industrial_handle_message+0x1a>
 8024c4c:	e8df f004 	tbb	[pc, r4]
 8024c50:	31171009 	.word	0x31171009
 8024c54:	0338      	.short	0x0338
        }
        break;

	case MSG_IS_ENABLE_BGT_LNA:

		if (num_bytes == 1)
 8024c56:	2a01      	cmp	r2, #1
 8024c58:	d039      	beq.n	8024cce <ep_radar_industrial_handle_message+0x8e>
    default:
	
		break;
    }

    return PROTOCOL_STATUS_INVALID_PAYLOAD;
 8024c5a:	f64f 70ff 	movw	r0, #65535	; 0xffff
}
 8024c5e:	b003      	add	sp, #12
 8024c60:	bd30      	pop	{r4, r5, pc}
    switch (message_data[0])
    {
		
    case MSG_DISABLE_DUTY_CYCLE:
	
        if (num_bytes == 1)
 8024c62:	2a01      	cmp	r2, #1
 8024c64:	d1f9      	bne.n	8024c5a <ep_radar_industrial_handle_message+0x1a>
        {
			error_code = radar_set_duty_cycle(radar_driver, 0);
 8024c66:	4618      	mov	r0, r3
 8024c68:	2100      	movs	r1, #0
 8024c6a:	f7fc fbd1 	bl	8021410 <radar_set_duty_cycle>
			
            return error_code;
 8024c6e:	e7f6      	b.n	8024c5e <ep_radar_industrial_handle_message+0x1e>
        }
        break;
		
	case MSG_ENABLE_DUTY_CYCLE:
	
        if (num_bytes == 1)
 8024c70:	2a01      	cmp	r2, #1
 8024c72:	d1f2      	bne.n	8024c5a <ep_radar_industrial_handle_message+0x1a>
        {
			error_code = radar_set_duty_cycle(radar_driver, 1);
 8024c74:	4618      	mov	r0, r3
 8024c76:	4611      	mov	r1, r2
 8024c78:	f7fc fbca 	bl	8021410 <radar_set_duty_cycle>
			
            return error_code;
 8024c7c:	e7ef      	b.n	8024c5e <ep_radar_industrial_handle_message+0x1e>
        }
        break;

	case MSG_IS_ENABLE_DUTY_CYCLE:

		if (num_bytes == 1)
 8024c7e:	2a01      	cmp	r2, #1
 8024c80:	d1eb      	bne.n	8024c5a <ep_radar_industrial_handle_message+0x1a>
		{
			uint8_t message[2];

			uint8_t flag;

			radar_get_duty_cycle(radar_driver, &flag);
 8024c82:	4618      	mov	r0, r3
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024c84:	2402      	movs	r4, #2
 8024c86:	f10d 0103 	add.w	r1, sp, #3
 8024c8a:	f7fc fbd3 	bl	8021434 <radar_get_duty_cycle>
 8024c8e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8024c92:	f88d 3005 	strb.w	r3, [sp, #5]
			/* compile message */
			wr_payload_u8(message, 0, MSG_IS_ENABLE_DUTY_CYCLE);
			wr_payload_u8(message, 1, flag);

			/* send message */
			protocol_send_header(endpoint, sizeof(message));
 8024c96:	4628      	mov	r0, r5
 8024c98:	4621      	mov	r1, r4
 8024c9a:	f88d 4004 	strb.w	r4, [sp, #4]
 8024c9e:	f000 faa7 	bl	80251f0 <protocol_send_header>
			protocol_send_payload(message, sizeof(message));
 8024ca2:	a801      	add	r0, sp, #4
 8024ca4:	4621      	mov	r1, r4
 8024ca6:	f000 fab7 	bl	8025218 <protocol_send_payload>
			protocol_send_tail();
 8024caa:	f000 fab7 	bl	802521c <protocol_send_tail>

			return RADAR_ERR_OK;
 8024cae:	2000      	movs	r0, #0
 8024cb0:	e7d5      	b.n	8024c5e <ep_radar_industrial_handle_message+0x1e>

		break;

    case MSG_DISABLE_BGT_LNA:
	
        if (num_bytes == 1)
 8024cb2:	2a01      	cmp	r2, #1
 8024cb4:	d1d1      	bne.n	8024c5a <ep_radar_industrial_handle_message+0x1a>
        {    		
        	radar_disable_lna_gain(radar_driver);
 8024cb6:	4618      	mov	r0, r3
 8024cb8:	f7fc fbc4 	bl	8021444 <radar_disable_lna_gain>
			
            return RADAR_ERR_OK;
 8024cbc:	2000      	movs	r0, #0
 8024cbe:	e7ce      	b.n	8024c5e <ep_radar_industrial_handle_message+0x1e>
        }
        break;
		
	case MSG_ENABLE_BGT_LNA:
	
        if (num_bytes == 1)
 8024cc0:	2a01      	cmp	r2, #1
 8024cc2:	d1ca      	bne.n	8024c5a <ep_radar_industrial_handle_message+0x1a>
        {    		
        	radar_enable_lna_gain(radar_driver);
 8024cc4:	4618      	mov	r0, r3
 8024cc6:	f7fc fbc5 	bl	8021454 <radar_enable_lna_gain>

            return RADAR_ERR_OK;
 8024cca:	2000      	movs	r0, #0
 8024ccc:	e7c7      	b.n	8024c5e <ep_radar_industrial_handle_message+0x1e>
		if (num_bytes == 1)
		{
			uint8_t message[2];
			uint8_t flag;

			flag = radar_get_lna_gain_enable_status(radar_driver);
 8024cce:	4618      	mov	r0, r3
 8024cd0:	f7fc fbc8 	bl	8021464 <radar_get_lna_gain_enable_status>
 8024cd4:	2305      	movs	r3, #5
 8024cd6:	f88d 0005 	strb.w	r0, [sp, #5]
			/* compile message */
			wr_payload_u8(message, 0, MSG_IS_ENABLE_BGT_LNA);
			wr_payload_u8(message, 1, flag);

			/* send message */
			protocol_send_header(endpoint, sizeof(message));
 8024cda:	2102      	movs	r1, #2
 8024cdc:	4628      	mov	r0, r5
 8024cde:	f88d 3004 	strb.w	r3, [sp, #4]
 8024ce2:	f000 fa85 	bl	80251f0 <protocol_send_header>
			protocol_send_payload(message, sizeof(message));
 8024ce6:	a801      	add	r0, sp, #4
 8024ce8:	2102      	movs	r1, #2
 8024cea:	f000 fa95 	bl	8025218 <protocol_send_payload>
			protocol_send_tail();
 8024cee:	f000 fa95 	bl	802521c <protocol_send_tail>

			return RADAR_ERR_OK;
 8024cf2:	2000      	movs	r0, #0
 8024cf4:	e7b3      	b.n	8024c5e <ep_radar_industrial_handle_message+0x1e>
 8024cf6:	bf00      	nop

08024cf8 <ep_radar_industrial_handle_change>:
    return PROTOCOL_STATUS_INVALID_PAYLOAD;
}

void ep_radar_industrial_handle_change(uint8_t endpoint, void* context,
                                  	   uint32_t what)
{
 8024cf8:	4770      	bx	lr
 8024cfa:	bf00      	nop

08024cfc <ep_radar_p2g_handle_message>:

uint16_t ep_radar_p2g_handle_message(uint8_t endpoint,
                                     uint8_t* message_data,
                                       uint16_t num_bytes,
                                       void* context)
{
 8024cfc:	b530      	push	{r4, r5, lr}
	
    (void) radar_driver; /* Suppress compiler warnings of unused variable */

	uint16_t error_code;

    switch (message_data[0])
 8024cfe:	780c      	ldrb	r4, [r1, #0]

uint16_t ep_radar_p2g_handle_message(uint8_t endpoint,
                                     uint8_t* message_data,
                                       uint16_t num_bytes,
                                       void* context)
{
 8024d00:	b085      	sub	sp, #20
	
    (void) radar_driver; /* Suppress compiler warnings of unused variable */

	uint16_t error_code;

    switch (message_data[0])
 8024d02:	b17c      	cbz	r4, 8024d24 <ep_radar_p2g_handle_message+0x28>
 8024d04:	2c01      	cmp	r4, #1
 8024d06:	d003      	beq.n	8024d10 <ep_radar_p2g_handle_message+0x14>
    default:
	
		break;
    }

    return PROTOCOL_STATUS_INVALID_PAYLOAD;
 8024d08:	f64f 70ff 	movw	r0, #65535	; 0xffff
}
 8024d0c:	b005      	add	sp, #20
 8024d0e:	bd30      	pop	{r4, r5, pc}
        }
        break;
	
    case MSG_SET_PGA_LEVEL:
	
        if (num_bytes == 3)
 8024d10:	2a03      	cmp	r2, #3
 8024d12:	d1f9      	bne.n	8024d08 <ep_radar_p2g_handle_message+0xc>
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, uint16_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8024d14:	788c      	ldrb	r4, [r1, #2]
 8024d16:	7849      	ldrb	r1, [r1, #1]

            /* extract parameters from message */
            gain_level = rd_payload_u16(message_data, 1);
            
            /* apply PGA Gain Level */
            error_code = radar_set_gain_level(radar_driver, gain_level);
 8024d18:	4618      	mov	r0, r3
 8024d1a:	ea41 2104 	orr.w	r1, r1, r4, lsl #8
 8024d1e:	f7fc fba7 	bl	8021470 <radar_set_gain_level>

            return error_code;
 8024d22:	e7f3      	b.n	8024d0c <ep_radar_p2g_handle_message+0x10>
    switch (message_data[0])
    {
		
    case MSG_GET_PGA_LEVEL:
	
        if (num_bytes == 1)
 8024d24:	2a01      	cmp	r2, #1
 8024d26:	d1ef      	bne.n	8024d08 <ep_radar_p2g_handle_message+0xc>
 8024d28:	4605      	mov	r5, r0
    uint16_t error_code;
    
	uint16_t gain_level;

    /* get current PGA Gain level from driver */
	error_code = radar_get_gain_level(device, &gain_level);
 8024d2a:	f10d 010a 	add.w	r1, sp, #10
 8024d2e:	4618      	mov	r0, r3
 8024d30:	9201      	str	r2, [sp, #4]
 8024d32:	f7fc fbb1 	bl	8021498 <radar_get_gain_level>

    if (error_code == RADAR_ERR_OK)
 8024d36:	9a01      	ldr	r2, [sp, #4]
 8024d38:	4604      	mov	r4, r0
 8024d3a:	b108      	cbz	r0, 8024d40 <ep_radar_p2g_handle_message+0x44>
    uint16_t error_code;
    
	uint16_t gain_level;

    /* get current PGA Gain level from driver */
	error_code = radar_get_gain_level(device, &gain_level);
 8024d3c:	4620      	mov	r0, r4
	
        if (num_bytes == 1)
        {
			error_code = send_pga_level(radar_driver, endpoint);
			
            return error_code;
 8024d3e:	e7e5      	b.n	8024d0c <ep_radar_p2g_handle_message+0x10>
    {
        uint8_t message[3];

        /* compile message */
        wr_payload_u8 (message, 0, MSG_SET_PGA_LEVEL);
        wr_payload_u16(message, 1, gain_level);
 8024d40:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024d44:	f88d 200c 	strb.w	r2, [sp, #12]

        /* send message */
        protocol_send_header(endpoint, sizeof(message));
 8024d48:	4628      	mov	r0, r5
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024d4a:	0a1a      	lsrs	r2, r3, #8
 8024d4c:	2103      	movs	r1, #3
    payload[offset    ] =  value        & 0xFF;
 8024d4e:	f88d 300d 	strb.w	r3, [sp, #13]
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024d52:	f88d 200e 	strb.w	r2, [sp, #14]
 8024d56:	f000 fa4b 	bl	80251f0 <protocol_send_header>
        protocol_send_payload(message, sizeof(message));
 8024d5a:	a803      	add	r0, sp, #12
 8024d5c:	2103      	movs	r1, #3
 8024d5e:	f000 fa5b 	bl	8025218 <protocol_send_payload>
        protocol_send_tail();
 8024d62:	f000 fa5b 	bl	802521c <protocol_send_tail>
    uint16_t error_code;
    
	uint16_t gain_level;

    /* get current PGA Gain level from driver */
	error_code = radar_get_gain_level(device, &gain_level);
 8024d66:	4620      	mov	r0, r4
 8024d68:	e7d0      	b.n	8024d0c <ep_radar_p2g_handle_message+0x10>
 8024d6a:	bf00      	nop

08024d6c <ep_radar_p2g_handle_change>:
    return PROTOCOL_STATUS_INVALID_PAYLOAD;
}

void ep_radar_p2g_handle_change(uint8_t endpoint, void* context,
                                uint32_t what)
{
 8024d6c:	4770      	bx	lr
 8024d6e:	bf00      	nop

08024d70 <ep_target_detection_handle_message>:
   7. EXPORTED FUNCTIONS
==============================================================================
 */

uint16_t ep_target_detection_handle_message (uint8_t endpoint, uint8_t* message_data, uint16_t num_bytes, void* context)
{
 8024d70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8024d74:	4606      	mov	r6, r0
	Radar_Handle_t radar_driver = (Radar_Handle_t) context;

	switch (message_data[0])
 8024d76:	7808      	ldrb	r0, [r1, #0]
   7. EXPORTED FUNCTIONS
==============================================================================
 */

uint16_t ep_target_detection_handle_message (uint8_t endpoint, uint8_t* message_data, uint16_t num_bytes, void* context)
{
 8024d78:	b093      	sub	sp, #76	; 0x4c
 8024d7a:	4615      	mov	r5, r2
	Radar_Handle_t radar_driver = (Radar_Handle_t) context;

	switch (message_data[0])
 8024d7c:	2803      	cmp	r0, #3
 8024d7e:	d806      	bhi.n	8024d8e <ep_target_detection_handle_message+0x1e>
 8024d80:	e8df f000 	tbb	[pc, r0]
 8024d84:	020a50b0 	.word	0x020a50b0

		break;

	case MSG_GET_RANGE_THRESHOLD:

		if (num_bytes == 1)
 8024d88:	2d01      	cmp	r5, #1
 8024d8a:	f000 8122 	beq.w	8024fd2 <ep_target_detection_handle_message+0x262>

	default:
		break;
	}

	return PROTOCOL_STATUS_INVALID_PAYLOAD;
 8024d8e:	f64f 70ff 	movw	r0, #65535	; 0xffff

}
 8024d92:	b013      	add	sp, #76	; 0x4c
 8024d94:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

		break;

	case MSG_GET_TARGETS:

		if (num_bytes == 1)
 8024d98:	2d01      	cmp	r5, #1
 8024d9a:	d1f8      	bne.n	8024d8e <ep_target_detection_handle_message+0x1e>

	uint8_t message = MSG_GET_TARGETS;

	for (i = 0; i < MAX_NUM_OF_TARGETS; i++)		// initialize target list
	{
		target_list[i].target_id = 0;
 8024d9c:	4fad      	ldr	r7, [pc, #692]	; (8025054 <ep_target_detection_handle_message+0x2e4>)
		target_list[i].level = 0.f;
 8024d9e:	2400      	movs	r4, #0
		target_list[i].radial_speed = 0.f;
		target_list[i].azimuth_speed = 0.f;
		target_list[i].elevation_speed = 0.f;
	}

	error_code = radar_get_target_info(radar_driver, target_list, &num_of_targets);
 8024da0:	4618      	mov	r0, r3

	uint16_t error_code = 0;

	uint8_t num_of_targets = 0;

	uint8_t message = MSG_GET_TARGETS;
 8024da2:	f04f 0e02 	mov.w	lr, #2
{
	uint16_t i;

	uint16_t error_code = 0;

	uint8_t num_of_targets = 0;
 8024da6:	2300      	movs	r3, #0

	uint8_t message = MSG_GET_TARGETS;

	for (i = 0; i < MAX_NUM_OF_TARGETS; i++)		// initialize target list
	{
		target_list[i].target_id = 0;
 8024da8:	603b      	str	r3, [r7, #0]
{
	uint16_t i;

	uint16_t error_code = 0;

	uint8_t num_of_targets = 0;
 8024daa:	f88d 3014 	strb.w	r3, [sp, #20]

	uint8_t message = MSG_GET_TARGETS;

	for (i = 0; i < MAX_NUM_OF_TARGETS; i++)		// initialize target list
	{
		target_list[i].target_id = 0;
 8024dae:	623b      	str	r3, [r7, #32]
 8024db0:	643b      	str	r3, [r7, #64]	; 0x40
 8024db2:	663b      	str	r3, [r7, #96]	; 0x60
		target_list[i].level = 0.f;
 8024db4:	607c      	str	r4, [r7, #4]
		target_list[i].radius = 0.f;
 8024db6:	60bc      	str	r4, [r7, #8]
		target_list[i].azimuth = 0.f;
 8024db8:	60fc      	str	r4, [r7, #12]
		target_list[i].elevation = 0.f;
 8024dba:	613c      	str	r4, [r7, #16]
		target_list[i].radial_speed = 0.f;
 8024dbc:	617c      	str	r4, [r7, #20]
		target_list[i].azimuth_speed = 0.f;
 8024dbe:	61bc      	str	r4, [r7, #24]
		target_list[i].elevation_speed = 0.f;
 8024dc0:	61fc      	str	r4, [r7, #28]
	uint8_t message = MSG_GET_TARGETS;

	for (i = 0; i < MAX_NUM_OF_TARGETS; i++)		// initialize target list
	{
		target_list[i].target_id = 0;
		target_list[i].level = 0.f;
 8024dc2:	627c      	str	r4, [r7, #36]	; 0x24
		target_list[i].radius = 0.f;
 8024dc4:	62bc      	str	r4, [r7, #40]	; 0x28
		target_list[i].azimuth = 0.f;
 8024dc6:	62fc      	str	r4, [r7, #44]	; 0x2c
		target_list[i].elevation = 0.f;
 8024dc8:	633c      	str	r4, [r7, #48]	; 0x30
		target_list[i].radial_speed = 0.f;
 8024dca:	637c      	str	r4, [r7, #52]	; 0x34
		target_list[i].azimuth_speed = 0.f;
 8024dcc:	63bc      	str	r4, [r7, #56]	; 0x38
		target_list[i].elevation_speed = 0.f;
 8024dce:	63fc      	str	r4, [r7, #60]	; 0x3c
	uint8_t message = MSG_GET_TARGETS;

	for (i = 0; i < MAX_NUM_OF_TARGETS; i++)		// initialize target list
	{
		target_list[i].target_id = 0;
		target_list[i].level = 0.f;
 8024dd0:	647c      	str	r4, [r7, #68]	; 0x44
		target_list[i].radius = 0.f;
 8024dd2:	64bc      	str	r4, [r7, #72]	; 0x48
		target_list[i].azimuth = 0.f;
 8024dd4:	64fc      	str	r4, [r7, #76]	; 0x4c
		target_list[i].elevation = 0.f;
 8024dd6:	653c      	str	r4, [r7, #80]	; 0x50
		target_list[i].radial_speed = 0.f;
 8024dd8:	657c      	str	r4, [r7, #84]	; 0x54
		target_list[i].azimuth_speed = 0.f;
 8024dda:	65bc      	str	r4, [r7, #88]	; 0x58
		target_list[i].elevation_speed = 0.f;
 8024ddc:	65fc      	str	r4, [r7, #92]	; 0x5c
	uint8_t message = MSG_GET_TARGETS;

	for (i = 0; i < MAX_NUM_OF_TARGETS; i++)		// initialize target list
	{
		target_list[i].target_id = 0;
		target_list[i].level = 0.f;
 8024dde:	667c      	str	r4, [r7, #100]	; 0x64
		target_list[i].radius = 0.f;
 8024de0:	66bc      	str	r4, [r7, #104]	; 0x68
		target_list[i].azimuth = 0.f;
 8024de2:	66fc      	str	r4, [r7, #108]	; 0x6c
		target_list[i].elevation = 0.f;
 8024de4:	673c      	str	r4, [r7, #112]	; 0x70
		target_list[i].radial_speed = 0.f;
 8024de6:	677c      	str	r4, [r7, #116]	; 0x74
		target_list[i].azimuth_speed = 0.f;
 8024de8:	67bc      	str	r4, [r7, #120]	; 0x78

	uint16_t error_code = 0;

	uint8_t num_of_targets = 0;

	uint8_t message = MSG_GET_TARGETS;
 8024dea:	f88d e02c 	strb.w	lr, [sp, #44]	; 0x2c
		target_list[i].radial_speed = 0.f;
		target_list[i].azimuth_speed = 0.f;
		target_list[i].elevation_speed = 0.f;
	}

	error_code = radar_get_target_info(radar_driver, target_list, &num_of_targets);
 8024dee:	4639      	mov	r1, r7
		target_list[i].radius = 0.f;
		target_list[i].azimuth = 0.f;
		target_list[i].elevation = 0.f;
		target_list[i].radial_speed = 0.f;
		target_list[i].azimuth_speed = 0.f;
		target_list[i].elevation_speed = 0.f;
 8024df0:	67fc      	str	r4, [r7, #124]	; 0x7c
	}

	error_code = radar_get_target_info(radar_driver, target_list, &num_of_targets);
 8024df2:	aa05      	add	r2, sp, #20
	uint8_t message = MSG_GET_TARGETS;

	for (i = 0; i < MAX_NUM_OF_TARGETS; i++)		// initialize target list
	{
		target_list[i].target_id = 0;
		target_list[i].level = 0.f;
 8024df4:	f8c7 4084 	str.w	r4, [r7, #132]	; 0x84
		target_list[i].radius = 0.f;
 8024df8:	f8c7 4088 	str.w	r4, [r7, #136]	; 0x88
		target_list[i].azimuth = 0.f;
 8024dfc:	f8c7 408c 	str.w	r4, [r7, #140]	; 0x8c
		target_list[i].elevation = 0.f;
 8024e00:	f8c7 4090 	str.w	r4, [r7, #144]	; 0x90
		target_list[i].radial_speed = 0.f;
 8024e04:	f8c7 4094 	str.w	r4, [r7, #148]	; 0x94
		target_list[i].azimuth_speed = 0.f;
 8024e08:	f8c7 4098 	str.w	r4, [r7, #152]	; 0x98
		target_list[i].elevation_speed = 0.f;
 8024e0c:	f8c7 409c 	str.w	r4, [r7, #156]	; 0x9c

	uint8_t message = MSG_GET_TARGETS;

	for (i = 0; i < MAX_NUM_OF_TARGETS; i++)		// initialize target list
	{
		target_list[i].target_id = 0;
 8024e10:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
		target_list[i].radial_speed = 0.f;
		target_list[i].azimuth_speed = 0.f;
		target_list[i].elevation_speed = 0.f;
	}

	error_code = radar_get_target_info(radar_driver, target_list, &num_of_targets);
 8024e14:	f7fc fba8 	bl	8021568 <radar_get_target_info>

	if (error_code == RADAR_ERR_OK)
 8024e18:	4604      	mov	r4, r0
 8024e1a:	2800      	cmp	r0, #0
 8024e1c:	f000 80fa 	beq.w	8025014 <ep_target_detection_handle_message+0x2a4>
{
	uint16_t error_code = 0;

	uint16_t threshold = 0;

	error_code = radar_get_range_detection_threshold(radar_driver, &threshold);
 8024e20:	4620      	mov	r0, r4

	case MSG_GET_RANGE_THRESHOLD:

		if (num_bytes == 1)
		{
			return send_range_threshold (endpoint, radar_driver);
 8024e22:	e7b6      	b.n	8024d92 <ep_target_detection_handle_message+0x22>

		break;

	case MSG_SET_DSP_SETTINGS:

		if (num_bytes >= 18)
 8024e24:	2d11      	cmp	r5, #17
 8024e26:	d9b2      	bls.n	8024d8e <ep_target_detection_handle_message+0x1e>
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, uint16_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8024e28:	f891 c00b 	ldrb.w	ip, [r1, #11]
 8024e2c:	7a8c      	ldrb	r4, [r1, #10]
 8024e2e:	7b4a      	ldrb	r2, [r1, #13]
 8024e30:	9202      	str	r2, [sp, #8]
 8024e32:	ea44 240c 	orr.w	r4, r4, ip, lsl #8
 8024e36:	7b0a      	ldrb	r2, [r1, #12]
 8024e38:	7bc8      	ldrb	r0, [r1, #15]
 8024e3a:	9401      	str	r4, [sp, #4]
 8024e3c:	9c02      	ldr	r4, [sp, #8]
 8024e3e:	f891 b003 	ldrb.w	fp, [r1, #3]
 8024e42:	f891 9007 	ldrb.w	r9, [r1, #7]
 8024e46:	9003      	str	r0, [sp, #12]
 8024e48:	f891 e002 	ldrb.w	lr, [r1, #2]
 8024e4c:	798e      	ldrb	r6, [r1, #6]
 8024e4e:	f891 a005 	ldrb.w	sl, [r1, #5]
 8024e52:	f891 8009 	ldrb.w	r8, [r1, #9]
 8024e56:	7b88      	ldrb	r0, [r1, #14]
 8024e58:	790f      	ldrb	r7, [r1, #4]
 8024e5a:	7a0d      	ldrb	r5, [r1, #8]

			// skip uint16 entry for index 18
			dsp_settings.enable_tracking  = rd_payload_u8 (message_data, 20);
			dsp_settings.num_of_tracks    = rd_payload_u8 (message_data, 21);

			dsp_settings.median_filter_length = rd_payload_u8 (message_data, 22);
 8024e5c:	f891 c016 	ldrb.w	ip, [r1, #22]
 8024e60:	ea42 2404 	orr.w	r4, r2, r4, lsl #8
 8024e64:	9a03      	ldr	r2, [sp, #12]
			dsp_settings.min_range_cm     = rd_payload_u16(message_data, 2);
			dsp_settings.max_range_cm     = rd_payload_u16(message_data, 4);
			dsp_settings.min_speed_kmh    = rd_payload_u16(message_data, 6);
			dsp_settings.max_speed_kmh    = rd_payload_u16(message_data, 8);
			dsp_settings.min_angle_degree = rd_payload_u16(message_data, 10);
			dsp_settings.max_angle_degree = rd_payload_u16(message_data, 12);
 8024e66:	f8ad 4038 	strh.w	r4, [sp, #56]	; 0x38
 8024e6a:	ea4e 2e0b 	orr.w	lr, lr, fp, lsl #8
 8024e6e:	ea46 2609 	orr.w	r6, r6, r9, lsl #8
 8024e72:	f891 b010 	ldrb.w	fp, [r1, #16]
 8024e76:	f891 9011 	ldrb.w	r9, [r1, #17]
		{
			DSP_Settings_t dsp_settings;

			/* extract parameters from message */
			dsp_settings.range_mvg_avg_length = rd_payload_u8(message_data, 1);
			dsp_settings.min_range_cm     = rd_payload_u16(message_data, 2);
 8024e7a:	f8ad e02e 	strh.w	lr, [sp, #46]	; 0x2e
 8024e7e:	ea47 270a 	orr.w	r7, r7, sl, lsl #8
 8024e82:	ea45 2508 	orr.w	r5, r5, r8, lsl #8
 8024e86:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
			dsp_settings.max_range_cm     = rd_payload_u16(message_data, 4);
			dsp_settings.min_speed_kmh    = rd_payload_u16(message_data, 6);
			dsp_settings.max_speed_kmh    = rd_payload_u16(message_data, 8);
			dsp_settings.min_angle_degree = rd_payload_u16(message_data, 10);
 8024e8a:	f8bd 0004 	ldrh.w	r0, [sp, #4]
		if (num_bytes >= 18)
		{
			DSP_Settings_t dsp_settings;

			/* extract parameters from message */
			dsp_settings.range_mvg_avg_length = rd_payload_u8(message_data, 1);
 8024e8e:	f891 a001 	ldrb.w	sl, [r1, #1]
			dsp_settings.range_threshold  = rd_payload_u16(message_data, 14);
			dsp_settings.speed_threshold  = rd_payload_u16(message_data, 16);

			// skip uint16 entry for index 18
			dsp_settings.enable_tracking  = rd_payload_u8 (message_data, 20);
			dsp_settings.num_of_tracks    = rd_payload_u8 (message_data, 21);
 8024e92:	f891 8015 	ldrb.w	r8, [r1, #21]

			dsp_settings.median_filter_length = rd_payload_u8 (message_data, 22);
			dsp_settings.enable_mti_filter    = rd_payload_u8 (message_data, 23);
 8024e96:	f891 e017 	ldrb.w	lr, [r1, #23]
			dsp_settings.range_mvg_avg_length = rd_payload_u8(message_data, 1);
			dsp_settings.min_range_cm     = rd_payload_u16(message_data, 2);
			dsp_settings.max_range_cm     = rd_payload_u16(message_data, 4);
			dsp_settings.min_speed_kmh    = rd_payload_u16(message_data, 6);
			dsp_settings.max_speed_kmh    = rd_payload_u16(message_data, 8);
			dsp_settings.min_angle_degree = rd_payload_u16(message_data, 10);
 8024e9a:	f8ad 0036 	strh.w	r0, [sp, #54]	; 0x36
 8024e9e:	ea4b 2b09 	orr.w	fp, fp, r9, lsl #8
			DSP_Settings_t dsp_settings;

			/* extract parameters from message */
			dsp_settings.range_mvg_avg_length = rd_payload_u8(message_data, 1);
			dsp_settings.min_range_cm     = rd_payload_u16(message_data, 2);
			dsp_settings.max_range_cm     = rd_payload_u16(message_data, 4);
 8024ea2:	f8ad 7030 	strh.w	r7, [sp, #48]	; 0x30
			dsp_settings.max_angle_degree = rd_payload_u16(message_data, 12);
			dsp_settings.range_threshold  = rd_payload_u16(message_data, 14);
			dsp_settings.speed_threshold  = rd_payload_u16(message_data, 16);

			// skip uint16 entry for index 18
			dsp_settings.enable_tracking  = rd_payload_u8 (message_data, 20);
 8024ea6:	f891 9014 	ldrb.w	r9, [r1, #20]

			/* extract parameters from message */
			dsp_settings.range_mvg_avg_length = rd_payload_u8(message_data, 1);
			dsp_settings.min_range_cm     = rd_payload_u16(message_data, 2);
			dsp_settings.max_range_cm     = rd_payload_u16(message_data, 4);
			dsp_settings.min_speed_kmh    = rd_payload_u16(message_data, 6);
 8024eaa:	f8ad 6032 	strh.w	r6, [sp, #50]	; 0x32
			dsp_settings.max_speed_kmh    = rd_payload_u16(message_data, 8);
 8024eae:	f8ad 5034 	strh.w	r5, [sp, #52]	; 0x34
			dsp_settings.min_angle_degree = rd_payload_u16(message_data, 10);
			dsp_settings.max_angle_degree = rd_payload_u16(message_data, 12);
			dsp_settings.range_threshold  = rd_payload_u16(message_data, 14);
 8024eb2:	f8ad 203a 	strh.w	r2, [sp, #58]	; 0x3a
 8024eb6:	7e4c      	ldrb	r4, [r1, #25]
 8024eb8:	7e0a      	ldrb	r2, [r1, #24]
			dsp_settings.speed_threshold  = rd_payload_u16(message_data, 16);
 8024eba:	f8ad b03c 	strh.w	fp, [sp, #60]	; 0x3c

			dsp_settings.mti_filter_length = rd_payload_u16(message_data, 24);
			// skip uint8 entry for index 26

			/* apply DSP Settings */
			return radar_set_dsp_settings(radar_driver, &dsp_settings);
 8024ebe:	4618      	mov	r0, r3
 8024ec0:	a90b      	add	r1, sp, #44	; 0x2c
 8024ec2:	ea42 2304 	orr.w	r3, r2, r4, lsl #8
		if (num_bytes >= 18)
		{
			DSP_Settings_t dsp_settings;

			/* extract parameters from message */
			dsp_settings.range_mvg_avg_length = rd_payload_u8(message_data, 1);
 8024ec6:	f88d a02c 	strb.w	sl, [sp, #44]	; 0x2c
			dsp_settings.max_angle_degree = rd_payload_u16(message_data, 12);
			dsp_settings.range_threshold  = rd_payload_u16(message_data, 14);
			dsp_settings.speed_threshold  = rd_payload_u16(message_data, 16);

			// skip uint16 entry for index 18
			dsp_settings.enable_tracking  = rd_payload_u8 (message_data, 20);
 8024eca:	f88d 903e 	strb.w	r9, [sp, #62]	; 0x3e
			dsp_settings.num_of_tracks    = rd_payload_u8 (message_data, 21);
 8024ece:	f88d 803f 	strb.w	r8, [sp, #63]	; 0x3f

			dsp_settings.median_filter_length = rd_payload_u8 (message_data, 22);
 8024ed2:	f88d c040 	strb.w	ip, [sp, #64]	; 0x40
			dsp_settings.enable_mti_filter    = rd_payload_u8 (message_data, 23);
 8024ed6:	f88d e041 	strb.w	lr, [sp, #65]	; 0x41

			dsp_settings.mti_filter_length = rd_payload_u16(message_data, 24);
 8024eda:	f8ad 3042 	strh.w	r3, [sp, #66]	; 0x42
			// skip uint8 entry for index 26

			/* apply DSP Settings */
			return radar_set_dsp_settings(radar_driver, &dsp_settings);
 8024ede:	f7fc fae3 	bl	80214a8 <radar_set_dsp_settings>
 8024ee2:	e756      	b.n	8024d92 <ep_target_detection_handle_message+0x22>

	switch (message_data[0])
	{
	case MSG_GET_DSP_SETTINGS:

		if (num_bytes == 1)
 8024ee4:	2d01      	cmp	r5, #1
 8024ee6:	f47f af52 	bne.w	8024d8e <ep_target_detection_handle_message+0x1e>
{
	uint16_t error_code = 0;

	DSP_Settings_t  dsp_settings;

	error_code = radar_get_dsp_settings(radar_driver, &dsp_settings);
 8024eea:	4618      	mov	r0, r3
 8024eec:	a905      	add	r1, sp, #20
 8024eee:	f7fc fb19 	bl	8021524 <radar_get_dsp_settings>

	if (error_code == RADAR_ERR_OK)
 8024ef2:	4604      	mov	r4, r0
 8024ef4:	2800      	cmp	r0, #0
 8024ef6:	d193      	bne.n	8024e20 <ep_target_detection_handle_message+0xb0>

		/* compile message */
		wr_payload_u8 (message,  0, MSG_GET_DSP_SETTINGS);

		wr_payload_u8 (message,  1, dsp_settings.range_mvg_avg_length);
		wr_payload_u16(message,  2, dsp_settings.min_range_cm);
 8024ef8:	f8bd c016 	ldrh.w	ip, [sp, #22]
		wr_payload_u16(message,  4, dsp_settings.max_range_cm);
 8024efc:	f8bd e018 	ldrh.w	lr, [sp, #24]
		wr_payload_u16(message,  6, dsp_settings.min_speed_kmh);
 8024f00:	f8bd 701a 	ldrh.w	r7, [sp, #26]
		wr_payload_u16(message,  8, dsp_settings.max_speed_kmh);
 8024f04:	f8bd 501c 	ldrh.w	r5, [sp, #28]
		wr_payload_u16(message, 10, dsp_settings.min_angle_degree);
 8024f08:	f8bd 001e 	ldrh.w	r0, [sp, #30]
		wr_payload_u16(message, 12, dsp_settings.max_angle_degree);
		wr_payload_u16(message, 14, dsp_settings.range_threshold);
 8024f0c:	f8bd 2022 	ldrh.w	r2, [sp, #34]	; 0x22
		wr_payload_u16(message, 16, dsp_settings.speed_threshold);
 8024f10:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
		wr_payload_u16(message,  2, dsp_settings.min_range_cm);
		wr_payload_u16(message,  4, dsp_settings.max_range_cm);
		wr_payload_u16(message,  6, dsp_settings.min_speed_kmh);
		wr_payload_u16(message,  8, dsp_settings.max_speed_kmh);
		wr_payload_u16(message, 10, dsp_settings.min_angle_degree);
		wr_payload_u16(message, 12, dsp_settings.max_angle_degree);
 8024f14:	f8bd 1020 	ldrh.w	r1, [sp, #32]

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024f18:	f88d c02e 	strb.w	ip, [sp, #46]	; 0x2e
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024f1c:	ea4f 2b1c 	mov.w	fp, ip, lsr #8
 8024f20:	f88d b02f 	strb.w	fp, [sp, #47]	; 0x2f
 8024f24:	ea4f 2c1e 	mov.w	ip, lr, lsr #8
 8024f28:	ea4f 2b17 	mov.w	fp, r7, lsr #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024f2c:	f89d a014 	ldrb.w	sl, [sp, #20]
 8024f30:	f89d 9026 	ldrb.w	r9, [sp, #38]	; 0x26
 8024f34:	f89d 8027 	ldrb.w	r8, [sp, #39]	; 0x27

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024f38:	f88d e030 	strb.w	lr, [sp, #48]	; 0x30
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024f3c:	f88d c031 	strb.w	ip, [sp, #49]	; 0x31
 8024f40:	ea4f 2e15 	mov.w	lr, r5, lsr #8
 8024f44:	ea4f 2c10 	mov.w	ip, r0, lsr #8
    payload[offset    ] =  value        & 0xFF;
 8024f48:	f88d 7032 	strb.w	r7, [sp, #50]	; 0x32
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024f4c:	f88d b033 	strb.w	fp, [sp, #51]	; 0x33
 8024f50:	0a0f      	lsrs	r7, r1, #8
 8024f52:	ea4f 2b12 	mov.w	fp, r2, lsr #8
    payload[offset    ] =  value        & 0xFF;
 8024f56:	f88d 5034 	strb.w	r5, [sp, #52]	; 0x34
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024f5a:	0a1d      	lsrs	r5, r3, #8
 8024f5c:	f88d e035 	strb.w	lr, [sp, #53]	; 0x35
 8024f60:	f88d c037 	strb.w	ip, [sp, #55]	; 0x37
    payload[offset    ] =  value        & 0xFF;
 8024f64:	f88d 0036 	strb.w	r0, [sp, #54]	; 0x36
 8024f68:	f88d 203a 	strb.w	r2, [sp, #58]	; 0x3a
 8024f6c:	f88d 303c 	strb.w	r3, [sp, #60]	; 0x3c
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024f70:	f88d 503d 	strb.w	r5, [sp, #61]	; 0x3d
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024f74:	f88d 402c 	strb.w	r4, [sp, #44]	; 0x2c
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024f78:	f88d 403f 	strb.w	r4, [sp, #63]	; 0x3f
    payload[offset    ] =  value        & 0xFF;
 8024f7c:	f88d 403e 	strb.w	r4, [sp, #62]	; 0x3e
 8024f80:	f88d 1038 	strb.w	r1, [sp, #56]	; 0x38
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024f84:	f88d 7039 	strb.w	r7, [sp, #57]	; 0x39
 8024f88:	f88d b03b 	strb.w	fp, [sp, #59]	; 0x3b
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024f8c:	f88d a02d 	strb.w	sl, [sp, #45]	; 0x2d
 8024f90:	f88d 9040 	strb.w	r9, [sp, #64]	; 0x40
 8024f94:	f88d 8041 	strb.w	r8, [sp, #65]	; 0x41
 8024f98:	f89d 1028 	ldrb.w	r1, [sp, #40]	; 0x28
		wr_payload_u8 (message, 21, dsp_settings.num_of_tracks);

		wr_payload_u8 (message, 22, dsp_settings.median_filter_length);
		wr_payload_u8 (message, 23, dsp_settings.enable_mti_filter);

		wr_payload_u16(message, 24, dsp_settings.mti_filter_length);
 8024f9c:	f8bd 302a 	ldrh.w	r3, [sp, #42]	; 0x2a
 8024fa0:	f89d 2029 	ldrb.w	r2, [sp, #41]	; 0x29
 8024fa4:	f88d 1042 	strb.w	r1, [sp, #66]	; 0x42
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024fa8:	0a1d      	lsrs	r5, r3, #8
		wr_payload_u8 (message, 26, 0); // see MMWSW-603

		/* send message */
		protocol_send_header(endpoint, sizeof(message));
 8024faa:	4630      	mov	r0, r6
 8024fac:	211b      	movs	r1, #27
    payload[offset    ] =  value        & 0xFF;
 8024fae:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024fb2:	f88d 2043 	strb.w	r2, [sp, #67]	; 0x43
 8024fb6:	f88d 4046 	strb.w	r4, [sp, #70]	; 0x46
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024fba:	f88d 5045 	strb.w	r5, [sp, #69]	; 0x45
 8024fbe:	f000 f917 	bl	80251f0 <protocol_send_header>
		protocol_send_payload(message, sizeof(message));
 8024fc2:	a80b      	add	r0, sp, #44	; 0x2c
 8024fc4:	211b      	movs	r1, #27
 8024fc6:	f000 f927 	bl	8025218 <protocol_send_payload>
		protocol_send_tail();
 8024fca:	f000 f927 	bl	802521c <protocol_send_tail>
{
	uint16_t error_code = 0;

	uint16_t threshold = 0;

	error_code = radar_get_range_detection_threshold(radar_driver, &threshold);
 8024fce:	4620      	mov	r0, r4
 8024fd0:	e6df      	b.n	8024d92 <ep_target_detection_handle_message+0x22>

static uint16_t send_range_threshold (uint8_t endpoint, Radar_Handle_t radar_driver)
{
	uint16_t error_code = 0;

	uint16_t threshold = 0;
 8024fd2:	a912      	add	r1, sp, #72	; 0x48
 8024fd4:	2200      	movs	r2, #0
 8024fd6:	f821 2d34 	strh.w	r2, [r1, #-52]!

	error_code = radar_get_range_detection_threshold(radar_driver, &threshold);
 8024fda:	4618      	mov	r0, r3
 8024fdc:	f7fc facc 	bl	8021578 <radar_get_range_detection_threshold>

	if (error_code == RADAR_ERR_OK)
 8024fe0:	4604      	mov	r4, r0
 8024fe2:	2800      	cmp	r0, #0
 8024fe4:	f47f af1c 	bne.w	8024e20 <ep_target_detection_handle_message+0xb0>
	{
		uint8_t message[3];

		/* compile message */
		wr_payload_u8 (message, 0, MSG_GET_RANGE_THRESHOLD);
		wr_payload_u16(message, 1, threshold);
 8024fe8:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    payload[offset    ] =  value        & 0xFF;
 8024fec:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024ff0:	2503      	movs	r5, #3

		/* send message */
		protocol_send_header(endpoint, sizeof(message));
 8024ff2:	4630      	mov	r0, r6
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024ff4:	0a1b      	lsrs	r3, r3, #8
 8024ff6:	4629      	mov	r1, r5
 8024ff8:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024ffc:	f88d 502c 	strb.w	r5, [sp, #44]	; 0x2c
 8025000:	f000 f8f6 	bl	80251f0 <protocol_send_header>
		protocol_send_payload(message, sizeof(message));
 8025004:	4629      	mov	r1, r5
 8025006:	a80b      	add	r0, sp, #44	; 0x2c
 8025008:	f000 f906 	bl	8025218 <protocol_send_payload>
		protocol_send_tail();
 802500c:	f000 f906 	bl	802521c <protocol_send_tail>
{
	uint16_t error_code = 0;

	uint16_t threshold = 0;

	error_code = radar_get_range_detection_threshold(radar_driver, &threshold);
 8025010:	4620      	mov	r0, r4
 8025012:	e6be      	b.n	8024d92 <ep_target_detection_handle_message+0x22>
	error_code = radar_get_target_info(radar_driver, target_list, &num_of_targets);

	if (error_code == RADAR_ERR_OK)
	{
		/* send message */
		protocol_send_header(endpoint, num_of_targets * sizeof(Target_Info_t) + 1 + 1);
 8025014:	f89d 1014 	ldrb.w	r1, [sp, #20]
 8025018:	0149      	lsls	r1, r1, #5
 802501a:	4630      	mov	r0, r6
 802501c:	3102      	adds	r1, #2
 802501e:	f000 f8e7 	bl	80251f0 <protocol_send_header>

		protocol_send_payload (&message, 1);
 8025022:	4629      	mov	r1, r5
 8025024:	a80b      	add	r0, sp, #44	; 0x2c
 8025026:	f000 f8f7 	bl	8025218 <protocol_send_payload>

		protocol_send_payload ((const uint8_t*) &num_of_targets, 1);
 802502a:	4629      	mov	r1, r5
 802502c:	a805      	add	r0, sp, #20
 802502e:	f000 f8f3 	bl	8025218 <protocol_send_payload>

		for (i = 0; i < num_of_targets; i++)
 8025032:	f89d 3014 	ldrb.w	r3, [sp, #20]
 8025036:	4625      	mov	r5, r4
 8025038:	2b00      	cmp	r3, #0
 802503a:	d0e7      	beq.n	802500c <ep_target_detection_handle_message+0x29c>
		{
			protocol_send_payload ((uint8_t*) &target_list[i], sizeof(Target_Info_t));
 802503c:	eb07 1045 	add.w	r0, r7, r5, lsl #5
 8025040:	2120      	movs	r1, #32
 8025042:	f000 f8e9 	bl	8025218 <protocol_send_payload>

		protocol_send_payload (&message, 1);

		protocol_send_payload ((const uint8_t*) &num_of_targets, 1);

		for (i = 0; i < num_of_targets; i++)
 8025046:	3501      	adds	r5, #1
 8025048:	f89d 3014 	ldrb.w	r3, [sp, #20]
 802504c:	b2ad      	uxth	r5, r5
 802504e:	42ab      	cmp	r3, r5
 8025050:	d8f4      	bhi.n	802503c <ep_target_detection_handle_message+0x2cc>
 8025052:	e7db      	b.n	802500c <ep_target_detection_handle_message+0x29c>
 8025054:	2000d564 	.word	0x2000d564

08025058 <ep_target_detection_handle_change>:

void ep_target_detection_handle_change (uint8_t endpoint, void* context, uint32_t what)
{
	Radar_Handle_t radar_driver = (Radar_Handle_t)context;

	switch (what)
 8025058:	2a01      	cmp	r2, #1
 802505a:	d000      	beq.n	802505e <ep_target_detection_handle_change+0x6>
 802505c:	4770      	bx	lr
}

//==============================================================================

void ep_target_detection_handle_change (uint8_t endpoint, void* context, uint32_t what)
{
 802505e:	b5f0      	push	{r4, r5, r6, r7, lr}

	uint8_t message = MSG_GET_TARGETS;

	for (i = 0; i < MAX_NUM_OF_TARGETS; i++)		// initialize target list
	{
		target_list[i].target_id = 0;
 8025060:	4c34      	ldr	r4, [pc, #208]	; (8025134 <ep_target_detection_handle_change+0xdc>)
}

//==============================================================================

void ep_target_detection_handle_change (uint8_t endpoint, void* context, uint32_t what)
{
 8025062:	b083      	sub	sp, #12
	uint8_t message = MSG_GET_TARGETS;

	for (i = 0; i < MAX_NUM_OF_TARGETS; i++)		// initialize target list
	{
		target_list[i].target_id = 0;
		target_list[i].level = 0.f;
 8025064:	2300      	movs	r3, #0
{
	uint16_t i;

	uint16_t error_code = 0;

	uint8_t num_of_targets = 0;
 8025066:	2500      	movs	r5, #0

	uint8_t message = MSG_GET_TARGETS;
 8025068:	f04f 0e02 	mov.w	lr, #2
 802506c:	4607      	mov	r7, r0
 802506e:	4616      	mov	r6, r2
		target_list[i].radial_speed = 0.f;
		target_list[i].azimuth_speed = 0.f;
		target_list[i].elevation_speed = 0.f;
	}

	error_code = radar_get_target_info(radar_driver, target_list, &num_of_targets);
 8025070:	4608      	mov	r0, r1
 8025072:	f10d 0206 	add.w	r2, sp, #6
 8025076:	4621      	mov	r1, r4

	uint8_t message = MSG_GET_TARGETS;

	for (i = 0; i < MAX_NUM_OF_TARGETS; i++)		// initialize target list
	{
		target_list[i].target_id = 0;
 8025078:	6025      	str	r5, [r4, #0]
{
	uint16_t i;

	uint16_t error_code = 0;

	uint8_t num_of_targets = 0;
 802507a:	f88d 5006 	strb.w	r5, [sp, #6]

	uint8_t message = MSG_GET_TARGETS;

	for (i = 0; i < MAX_NUM_OF_TARGETS; i++)		// initialize target list
	{
		target_list[i].target_id = 0;
 802507e:	6225      	str	r5, [r4, #32]
 8025080:	6425      	str	r5, [r4, #64]	; 0x40
 8025082:	6625      	str	r5, [r4, #96]	; 0x60
		target_list[i].level = 0.f;
 8025084:	6063      	str	r3, [r4, #4]
		target_list[i].radius = 0.f;
 8025086:	60a3      	str	r3, [r4, #8]
		target_list[i].azimuth = 0.f;
 8025088:	60e3      	str	r3, [r4, #12]
		target_list[i].elevation = 0.f;
 802508a:	6123      	str	r3, [r4, #16]
		target_list[i].radial_speed = 0.f;
 802508c:	6163      	str	r3, [r4, #20]
		target_list[i].azimuth_speed = 0.f;
 802508e:	61a3      	str	r3, [r4, #24]
		target_list[i].elevation_speed = 0.f;
 8025090:	61e3      	str	r3, [r4, #28]
	uint8_t message = MSG_GET_TARGETS;

	for (i = 0; i < MAX_NUM_OF_TARGETS; i++)		// initialize target list
	{
		target_list[i].target_id = 0;
		target_list[i].level = 0.f;
 8025092:	6263      	str	r3, [r4, #36]	; 0x24
		target_list[i].radius = 0.f;
 8025094:	62a3      	str	r3, [r4, #40]	; 0x28
		target_list[i].azimuth = 0.f;
 8025096:	62e3      	str	r3, [r4, #44]	; 0x2c
		target_list[i].elevation = 0.f;
 8025098:	6323      	str	r3, [r4, #48]	; 0x30
		target_list[i].radial_speed = 0.f;
 802509a:	6363      	str	r3, [r4, #52]	; 0x34
		target_list[i].azimuth_speed = 0.f;
 802509c:	63a3      	str	r3, [r4, #56]	; 0x38
		target_list[i].elevation_speed = 0.f;
 802509e:	63e3      	str	r3, [r4, #60]	; 0x3c
	uint8_t message = MSG_GET_TARGETS;

	for (i = 0; i < MAX_NUM_OF_TARGETS; i++)		// initialize target list
	{
		target_list[i].target_id = 0;
		target_list[i].level = 0.f;
 80250a0:	6463      	str	r3, [r4, #68]	; 0x44
		target_list[i].radius = 0.f;
 80250a2:	64a3      	str	r3, [r4, #72]	; 0x48
		target_list[i].azimuth = 0.f;
 80250a4:	64e3      	str	r3, [r4, #76]	; 0x4c
		target_list[i].elevation = 0.f;
 80250a6:	6523      	str	r3, [r4, #80]	; 0x50
		target_list[i].radial_speed = 0.f;
 80250a8:	6563      	str	r3, [r4, #84]	; 0x54
		target_list[i].azimuth_speed = 0.f;
 80250aa:	65a3      	str	r3, [r4, #88]	; 0x58
		target_list[i].elevation_speed = 0.f;
 80250ac:	65e3      	str	r3, [r4, #92]	; 0x5c
	uint8_t message = MSG_GET_TARGETS;

	for (i = 0; i < MAX_NUM_OF_TARGETS; i++)		// initialize target list
	{
		target_list[i].target_id = 0;
		target_list[i].level = 0.f;
 80250ae:	6663      	str	r3, [r4, #100]	; 0x64
		target_list[i].radius = 0.f;
 80250b0:	66a3      	str	r3, [r4, #104]	; 0x68
		target_list[i].azimuth = 0.f;
 80250b2:	66e3      	str	r3, [r4, #108]	; 0x6c
		target_list[i].elevation = 0.f;
 80250b4:	6723      	str	r3, [r4, #112]	; 0x70
		target_list[i].radial_speed = 0.f;
 80250b6:	6763      	str	r3, [r4, #116]	; 0x74
		target_list[i].azimuth_speed = 0.f;
 80250b8:	67a3      	str	r3, [r4, #120]	; 0x78

	uint16_t error_code = 0;

	uint8_t num_of_targets = 0;

	uint8_t message = MSG_GET_TARGETS;
 80250ba:	f88d e007 	strb.w	lr, [sp, #7]

	for (i = 0; i < MAX_NUM_OF_TARGETS; i++)		// initialize target list
	{
		target_list[i].target_id = 0;
 80250be:	f8c4 5080 	str.w	r5, [r4, #128]	; 0x80
		target_list[i].radius = 0.f;
		target_list[i].azimuth = 0.f;
		target_list[i].elevation = 0.f;
		target_list[i].radial_speed = 0.f;
		target_list[i].azimuth_speed = 0.f;
		target_list[i].elevation_speed = 0.f;
 80250c2:	67e3      	str	r3, [r4, #124]	; 0x7c
	uint8_t message = MSG_GET_TARGETS;

	for (i = 0; i < MAX_NUM_OF_TARGETS; i++)		// initialize target list
	{
		target_list[i].target_id = 0;
		target_list[i].level = 0.f;
 80250c4:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
		target_list[i].radius = 0.f;
 80250c8:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
		target_list[i].azimuth = 0.f;
 80250cc:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
		target_list[i].elevation = 0.f;
 80250d0:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
		target_list[i].radial_speed = 0.f;
 80250d4:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
		target_list[i].azimuth_speed = 0.f;
 80250d8:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
		target_list[i].elevation_speed = 0.f;
 80250dc:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
	}

	error_code = radar_get_target_info(radar_driver, target_list, &num_of_targets);
 80250e0:	f7fc fa42 	bl	8021568 <radar_get_target_info>

	if (error_code == RADAR_ERR_OK)
 80250e4:	4605      	mov	r5, r0
 80250e6:	b108      	cbz	r0, 80250ec <ep_target_detection_handle_change+0x94>
		break;

	default:
		break;
	}
}
 80250e8:	b003      	add	sp, #12
 80250ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
	error_code = radar_get_target_info(radar_driver, target_list, &num_of_targets);

	if (error_code == RADAR_ERR_OK)
	{
		/* send message */
		protocol_send_header(endpoint, num_of_targets * sizeof(Target_Info_t) + 1 + 1);
 80250ec:	f89d 1006 	ldrb.w	r1, [sp, #6]
 80250f0:	0149      	lsls	r1, r1, #5
 80250f2:	4638      	mov	r0, r7
 80250f4:	3102      	adds	r1, #2
 80250f6:	f000 f87b 	bl	80251f0 <protocol_send_header>

		protocol_send_payload (&message, 1);
 80250fa:	f10d 0007 	add.w	r0, sp, #7
 80250fe:	4631      	mov	r1, r6
 8025100:	f000 f88a 	bl	8025218 <protocol_send_payload>

		protocol_send_payload ((const uint8_t*) &num_of_targets, 1);
 8025104:	f10d 0006 	add.w	r0, sp, #6
 8025108:	4631      	mov	r1, r6
 802510a:	f000 f885 	bl	8025218 <protocol_send_payload>

		for (i = 0; i < num_of_targets; i++)
 802510e:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8025112:	b153      	cbz	r3, 802512a <ep_target_detection_handle_change+0xd2>
		{
			protocol_send_payload ((uint8_t*) &target_list[i], sizeof(Target_Info_t));
 8025114:	eb04 1045 	add.w	r0, r4, r5, lsl #5
 8025118:	2120      	movs	r1, #32
 802511a:	f000 f87d 	bl	8025218 <protocol_send_payload>

		protocol_send_payload (&message, 1);

		protocol_send_payload ((const uint8_t*) &num_of_targets, 1);

		for (i = 0; i < num_of_targets; i++)
 802511e:	3501      	adds	r5, #1
 8025120:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8025124:	b2ad      	uxth	r5, r5
 8025126:	42ab      	cmp	r3, r5
 8025128:	d8f4      	bhi.n	8025114 <ep_target_detection_handle_change+0xbc>
		{
			protocol_send_payload ((uint8_t*) &target_list[i], sizeof(Target_Info_t));
		}

		protocol_send_tail();
 802512a:	f000 f877 	bl	802521c <protocol_send_tail>
		break;

	default:
		break;
	}
}
 802512e:	b003      	add	sp, #12
 8025130:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8025132:	bf00      	nop
 8025134:	2000d564 	.word	0x2000d564

08025138 <receive_data>:
    instance.receive_pointer   = instance.message_frame;
    instance.num_bytes_awaited = 4;
}

static void receive_data(void)
{
 8025138:	b530      	push	{r4, r5, lr}
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
 802513a:	4c17      	ldr	r4, [pc, #92]	; (8025198 <receive_data+0x60>)
    instance.receive_pointer   = instance.message_frame;
    instance.num_bytes_awaited = 4;
}

static void receive_data(void)
{
 802513c:	b083      	sub	sp, #12
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
 802513e:	89a1      	ldrh	r1, [r4, #12]
 8025140:	68a0      	ldr	r0, [r4, #8]
 8025142:	f005 fb1d 	bl	802a780 <com_get_data>
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
 8025146:	68a2      	ldr	r2, [r4, #8]
    instance.num_bytes_awaited -= num_received_bytes;
 8025148:	89a3      	ldrh	r3, [r4, #12]

    /* check for timeout */
    if (instance.get_time != NULL)
 802514a:	6a21      	ldr	r1, [r4, #32]
static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
 802514c:	4402      	add	r2, r0
    instance.num_bytes_awaited -= num_received_bytes;
 802514e:	1a1b      	subs	r3, r3, r0
}

static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
 8025150:	4605      	mov	r5, r0
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
 8025152:	60a2      	str	r2, [r4, #8]
    instance.num_bytes_awaited -= num_received_bytes;
 8025154:	81a3      	strh	r3, [r4, #12]

    /* check for timeout */
    if (instance.get_time != NULL)
 8025156:	b1e9      	cbz	r1, 8025194 <receive_data+0x5c>
    {
        /* get current time */
        uint32_t current_time = instance.get_time();
 8025158:	4788      	blx	r1

        /* if no data has been received, check the time since last received
         * bytes
         */
        if (num_received_bytes == 0)
 802515a:	b9d5      	cbnz	r5, 8025192 <receive_data+0x5a>
        {

        	if( instance.time_of_last_byte > current_time)
 802515c:	6923      	ldr	r3, [r4, #16]
 802515e:	4298      	cmp	r0, r3
 8025160:	d317      	bcc.n	8025192 <receive_data+0x5a>
        		/* Handle time wrap-around */
        		instance.time_of_last_byte = current_time;
        	}
        	else {

				if ((instance.state != PROTOCOL_STATE_IDLE) &&
 8025162:	7961      	ldrb	r1, [r4, #5]
 8025164:	b1b1      	cbz	r1, 8025194 <receive_data+0x5c>
					(current_time >= instance.time_of_last_byte +
 8025166:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8025168:	4413      	add	r3, r2
        		/* Handle time wrap-around */
        		instance.time_of_last_byte = current_time;
        	}
        	else {

				if ((instance.state != PROTOCOL_STATE_IDLE) &&
 802516a:	4298      	cmp	r0, r3
 802516c:	d312      	bcc.n	8025194 <receive_data+0x5c>
					(current_time >= instance.time_of_last_byte +
									 instance.timeout_interval))
				{
					/* a timeout has occurred, reset protocol state */
					if (instance.state != PROTOCOL_STATE_CONFUSED)
 802516e:	2904      	cmp	r1, #4
 8025170:	d008      	beq.n	8025184 <receive_data+0x4c>
 8025172:	a802      	add	r0, sp, #8
 8025174:	4b09      	ldr	r3, [pc, #36]	; (802519c <receive_data+0x64>)
 8025176:	f840 3d04 	str.w	r3, [r0, #-4]!
    wr_payload_u8 (status_message, 0, CNST_STARTBYTE_STATUS);
    wr_payload_u8 (status_message, 1, endpoint);
    wr_payload_u16(status_message, 2, status_code);

    /* now send message */
    com_send_data(status_message, sizeof(status_message));
 802517a:	2104      	movs	r1, #4
 802517c:	f005 fafe 	bl	802a77c <com_send_data>
    com_flush();
 8025180:	f005 fb0e 	bl	802a7a0 <com_flush>
}

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state            = PROTOCOL_STATE_IDLE;
 8025184:	2300      	movs	r3, #0
    instance.receive_pointer   = instance.message_frame;
 8025186:	4a06      	ldr	r2, [pc, #24]	; (80251a0 <receive_data+0x68>)
}

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state            = PROTOCOL_STATE_IDLE;
 8025188:	7163      	strb	r3, [r4, #5]
    instance.receive_pointer   = instance.message_frame;
    instance.num_bytes_awaited = 4;
 802518a:	2304      	movs	r3, #4

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state            = PROTOCOL_STATE_IDLE;
    instance.receive_pointer   = instance.message_frame;
 802518c:	60a2      	str	r2, [r4, #8]
    instance.num_bytes_awaited = 4;
 802518e:	81a3      	strh	r3, [r4, #12]
 8025190:	e000      	b.n	8025194 <receive_data+0x5c>
        else
        {
            /* data has been received, so remember current time for next
             * timeout check
             */
            instance.time_of_last_byte = current_time;
 8025192:	6120      	str	r0, [r4, #16]
        }
    }
}
 8025194:	b003      	add	sp, #12
 8025196:	bd30      	pop	{r4, r5, pc}
 8025198:	1fff1810 	.word	0x1fff1810
 802519c:	0001005b 	.word	0x0001005b
 80251a0:	1fff1824 	.word	0x1fff1824

080251a4 <protocol_init>:
*/

void protocol_init(Endpoint_t* endpoints, uint8_t num_endpoints,
                   uint32_t (*get_time)(void), uint32_t timeout_interval,
                   void (*do_system_reset)(void))
{
 80251a4:	b538      	push	{r3, r4, r5, lr}
    /* initialize the internal state structure */
    instance.get_time = get_time;
 80251a6:	4c0f      	ldr	r4, [pc, #60]	; (80251e4 <protocol_init+0x40>)
*/

void protocol_init(Endpoint_t* endpoints, uint8_t num_endpoints,
                   uint32_t (*get_time)(void), uint32_t timeout_interval,
                   void (*do_system_reset)(void))
{
 80251a8:	9d04      	ldr	r5, [sp, #16]
    /* initialize the internal state structure */
    instance.get_time = get_time;
    instance.timeout_interval = timeout_interval;
 80251aa:	6263      	str	r3, [r4, #36]	; 0x24
    instance.do_system_reset = do_system_reset;

    instance.endpoints = endpoints;
    instance.num_endpoints = num_endpoints;

    instance.state = PROTOCOL_STATE_IDLE;
 80251ac:	2300      	movs	r3, #0
void protocol_init(Endpoint_t* endpoints, uint8_t num_endpoints,
                   uint32_t (*get_time)(void), uint32_t timeout_interval,
                   void (*do_system_reset)(void))
{
    /* initialize the internal state structure */
    instance.get_time = get_time;
 80251ae:	6222      	str	r2, [r4, #32]
    instance.timeout_interval = timeout_interval;
    instance.do_system_reset = do_system_reset;

    instance.endpoints = endpoints;
 80251b0:	6020      	str	r0, [r4, #0]
    instance.num_endpoints = num_endpoints;
 80251b2:	7121      	strb	r1, [r4, #4]
                   void (*do_system_reset)(void))
{
    /* initialize the internal state structure */
    instance.get_time = get_time;
    instance.timeout_interval = timeout_interval;
    instance.do_system_reset = do_system_reset;
 80251b4:	62a5      	str	r5, [r4, #40]	; 0x28

    instance.endpoints = endpoints;
    instance.num_endpoints = num_endpoints;

    instance.state = PROTOCOL_STATE_IDLE;
 80251b6:	7163      	strb	r3, [r4, #5]
    instance.receive_pointer = NULL;
 80251b8:	60a3      	str	r3, [r4, #8]
    instance.num_bytes_awaited = 0;
 80251ba:	81a3      	strh	r3, [r4, #12]
    instance.time_of_last_byte = (get_time != NULL) ? instance.get_time() : 0;
 80251bc:	b182      	cbz	r2, 80251e0 <protocol_init+0x3c>
 80251be:	4790      	blx	r2
    instance.payload = data_payload;
 80251c0:	4d09      	ldr	r5, [pc, #36]	; (80251e8 <protocol_init+0x44>)
    instance.num_endpoints = num_endpoints;

    instance.state = PROTOCOL_STATE_IDLE;
    instance.receive_pointer = NULL;
    instance.num_bytes_awaited = 0;
    instance.time_of_last_byte = (get_time != NULL) ? instance.get_time() : 0;
 80251c2:	6120      	str	r0, [r4, #16]
static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state            = PROTOCOL_STATE_IDLE;
    instance.receive_pointer   = instance.message_frame;
    instance.num_bytes_awaited = 4;
 80251c4:	2304      	movs	r3, #4

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state            = PROTOCOL_STATE_IDLE;
    instance.receive_pointer   = instance.message_frame;
 80251c6:	4a09      	ldr	r2, [pc, #36]	; (80251ec <protocol_init+0x48>)

    instance.state = PROTOCOL_STATE_IDLE;
    instance.receive_pointer = NULL;
    instance.num_bytes_awaited = 0;
    instance.time_of_last_byte = (get_time != NULL) ? instance.get_time() : 0;
    instance.payload = data_payload;
 80251c8:	61e5      	str	r5, [r4, #28]
	instance.max_payload = PROTOCOL_MAX_PAYLOAD_SIZE;
 80251ca:	f44f 7000 	mov.w	r0, #512	; 0x200
}

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state            = PROTOCOL_STATE_IDLE;
 80251ce:	2100      	movs	r1, #0
    instance.state = PROTOCOL_STATE_IDLE;
    instance.receive_pointer = NULL;
    instance.num_bytes_awaited = 0;
    instance.time_of_last_byte = (get_time != NULL) ? instance.get_time() : 0;
    instance.payload = data_payload;
	instance.max_payload = PROTOCOL_MAX_PAYLOAD_SIZE;
 80251d0:	62e0      	str	r0, [r4, #44]	; 0x2c
}

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state            = PROTOCOL_STATE_IDLE;
 80251d2:	7161      	strb	r1, [r4, #5]
    instance.receive_pointer   = instance.message_frame;
 80251d4:	60a2      	str	r2, [r4, #8]
    instance.num_bytes_awaited = 4;
 80251d6:	81a3      	strh	r3, [r4, #12]
    /* initialize state */
    reset_state();

    /* initialize communication interface */
    com_init();
}
 80251d8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

    /* initialize state */
    reset_state();

    /* initialize communication interface */
    com_init();
 80251dc:	f005 bacc 	b.w	802a778 <com_init>
    instance.num_endpoints = num_endpoints;

    instance.state = PROTOCOL_STATE_IDLE;
    instance.receive_pointer = NULL;
    instance.num_bytes_awaited = 0;
    instance.time_of_last_byte = (get_time != NULL) ? instance.get_time() : 0;
 80251e0:	4610      	mov	r0, r2
 80251e2:	e7ed      	b.n	80251c0 <protocol_init+0x1c>
 80251e4:	1fff1810 	.word	0x1fff1810
 80251e8:	1fff1840 	.word	0x1fff1840
 80251ec:	1fff1824 	.word	0x1fff1824

080251f0 <protocol_send_header>:
         */
    }
}

void protocol_send_header(uint8_t endpoint, uint16_t num_bytes)
{
 80251f0:	b510      	push	{r4, lr}
 80251f2:	b082      	sub	sp, #8
 80251f4:	460b      	mov	r3, r1
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 80251f6:	0a0c      	lsrs	r4, r1, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80251f8:	f88d 0005 	strb.w	r0, [sp, #5]
 80251fc:	225a      	movs	r2, #90	; 0x5a
    uint8_t header[4];
    wr_payload_u8 (header, 0, CNST_STARTBYTE_DATA);
    wr_payload_u8 (header, 1, endpoint);
    wr_payload_u16(header, 2, num_bytes);

    com_send_data(header, sizeof(header));
 80251fe:	a801      	add	r0, sp, #4
 8025200:	2104      	movs	r1, #4

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8025202:	f88d 3006 	strb.w	r3, [sp, #6]
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8025206:	f88d 4007 	strb.w	r4, [sp, #7]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802520a:	f88d 2004 	strb.w	r2, [sp, #4]
 802520e:	f005 fab5 	bl	802a77c <com_send_data>
}
 8025212:	b002      	add	sp, #8
 8025214:	bd10      	pop	{r4, pc}
 8025216:	bf00      	nop

08025218 <protocol_send_payload>:

void protocol_send_payload(const uint8_t* message_data, uint16_t num_bytes)
{
    /* send the data through the communication stream interface */
    com_send_data(message_data, num_bytes);
 8025218:	f005 bab0 	b.w	802a77c <com_send_data>

0802521c <protocol_send_tail>:
}

void protocol_send_tail(void)
{
 802521c:	b500      	push	{lr}
 802521e:	b083      	sub	sp, #12

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8025220:	a802      	add	r0, sp, #8
 8025222:	23db      	movs	r3, #219	; 0xdb
 8025224:	f800 3d04 	strb.w	r3, [r0, #-4]!
    /* setup message tail and send it */
    uint8_t tail[2];
    wr_payload_u16(tail, 0, CNST_END_OF_PAYLOAD);

    com_send_data(tail, sizeof(tail));
 8025228:	2102      	movs	r1, #2
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 802522a:	23e0      	movs	r3, #224	; 0xe0
 802522c:	f88d 3005 	strb.w	r3, [sp, #5]
 8025230:	f005 faa4 	bl	802a77c <com_send_data>
    com_flush();
 8025234:	f005 fab4 	bl	802a7a0 <com_flush>
}
 8025238:	b003      	add	sp, #12
 802523a:	f85d fb04 	ldr.w	pc, [sp], #4
 802523e:	bf00      	nop

08025240 <protocol_run>:
    /* initialize communication interface */
    com_init();
}

void protocol_run(void)
{
 8025240:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if (instance.state != PROTOCOL_STATE_CONFUSED)
 8025244:	4c9b      	ldr	r4, [pc, #620]	; (80254b4 <protocol_run+0x274>)
 8025246:	7963      	ldrb	r3, [r4, #5]
 8025248:	2b04      	cmp	r3, #4
    /* initialize communication interface */
    com_init();
}

void protocol_run(void)
{
 802524a:	b092      	sub	sp, #72	; 0x48
    if (instance.state != PROTOCOL_STATE_CONFUSED)
 802524c:	d02b      	beq.n	80252a6 <protocol_run+0x66>
    {
        /* if the protocol is in a defined state, read the next bytes from the
         * input stream
         */
        receive_data();
 802524e:	f7ff ff73 	bl	8025138 <receive_data>
        /*
         * now process data until the end of a message has been reached
         * (note the missing brakes, the fall through is intended to proceed
         * with the message, so don't wonder)
         */
        switch (instance.state)
 8025252:	7963      	ldrb	r3, [r4, #5]
 8025254:	2b03      	cmp	r3, #3
 8025256:	d824      	bhi.n	80252a2 <protocol_run+0x62>
 8025258:	e8df f003 	tbb	[pc, r3]
 802525c:	70890207 	.word	0x70890207
            /* no break, fall through and continue with
             * PROTOCOL_STATE_RECEIVING_HEADER
             */

        case PROTOCOL_STATE_RECEIVING_HEADER:
            if (instance.num_bytes_awaited == 0)
 8025260:	89a3      	ldrh	r3, [r4, #12]
 8025262:	b153      	cbz	r3, 802527a <protocol_run+0x3a>
        /*
         * The receive_data function may switch the state back to idle, if a
         * timeout occurs, this is the  only way to get out of confused state.
         */
    }
}
 8025264:	b012      	add	sp, #72	; 0x48
 8025266:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        {
        case PROTOCOL_STATE_IDLE:
            /* if at least one byte has been received, the state is not idle
             *  any more
             */
            if (instance.num_bytes_awaited < 4)
 802526a:	89a3      	ldrh	r3, [r4, #12]
 802526c:	4a91      	ldr	r2, [pc, #580]	; (80254b4 <protocol_run+0x274>)
 802526e:	2b03      	cmp	r3, #3
 8025270:	d8f8      	bhi.n	8025264 <protocol_run+0x24>
                instance.state = PROTOCOL_STATE_RECEIVING_HEADER;
 8025272:	2101      	movs	r1, #1
 8025274:	7151      	strb	r1, [r2, #5]
            /* no break, fall through and continue with
             * PROTOCOL_STATE_RECEIVING_HEADER
             */

        case PROTOCOL_STATE_RECEIVING_HEADER:
            if (instance.num_bytes_awaited == 0)
 8025276:	2b00      	cmp	r3, #0
 8025278:	d1f4      	bne.n	8025264 <protocol_run+0x24>
                sync_byte    = rd_payload_u8 (instance.message_frame, 0);
                endpoint     = rd_payload_u8 (instance.message_frame, 1);
                payload_size = rd_payload_u16(instance.message_frame, 2);

                /* check sync bye, message must be a payload message */
                if (sync_byte != CNST_STARTBYTE_DATA)
 802527a:	7d23      	ldrb	r3, [r4, #20]
 *
 * \return The function returns the value read from the payload.
 */
static inline uint8_t rd_payload_u8(const uint8_t* payload, uint16_t offset)
{
    return payload[offset];
 802527c:	4e8d      	ldr	r6, [pc, #564]	; (80254b4 <protocol_run+0x274>)
 802527e:	7d60      	ldrb	r0, [r4, #21]
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, uint16_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8025280:	7de1      	ldrb	r1, [r4, #23]
            ((uint16_t)payload[offset    ]);
 8025282:	7da2      	ldrb	r2, [r4, #22]
 8025284:	2b5a      	cmp	r3, #90	; 0x5a
 8025286:	d078      	beq.n	802537a <protocol_run+0x13a>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8025288:	4b8b      	ldr	r3, [pc, #556]	; (80254b8 <protocol_run+0x278>)
 802528a:	ad12      	add	r5, sp, #72	; 0x48
 802528c:	f845 3d40 	str.w	r3, [r5, #-64]!
                end_sequence = rd_payload_u16(instance.message_frame, 4);

                /* check end of payload sequence */
                if (end_sequence != CNST_END_OF_PAYLOAD)
                {
                    instance.state = PROTOCOL_STATE_CONFUSED;
 8025290:	2304      	movs	r3, #4
    wr_payload_u8 (status_message, 0, CNST_STARTBYTE_STATUS);
    wr_payload_u8 (status_message, 1, endpoint);
    wr_payload_u16(status_message, 2, status_code);

    /* now send message */
    com_send_data(status_message, sizeof(status_message));
 8025292:	4628      	mov	r0, r5
 8025294:	4619      	mov	r1, r3
                end_sequence = rd_payload_u16(instance.message_frame, 4);

                /* check end of payload sequence */
                if (end_sequence != CNST_END_OF_PAYLOAD)
                {
                    instance.state = PROTOCOL_STATE_CONFUSED;
 8025296:	7173      	strb	r3, [r6, #5]
    wr_payload_u8 (status_message, 0, CNST_STARTBYTE_STATUS);
    wr_payload_u8 (status_message, 1, endpoint);
    wr_payload_u16(status_message, 2, status_code);

    /* now send message */
    com_send_data(status_message, sizeof(status_message));
 8025298:	f005 fa70 	bl	802a77c <com_send_data>
    com_flush();
 802529c:	f005 fa80 	bl	802a7a0 <com_flush>
 80252a0:	7973      	ldrb	r3, [r6, #5]
    }

    /* if state is confused, keep on reading into a dummy buffer, until
     * receive buffer is empty
     */
    if (instance.state == PROTOCOL_STATE_CONFUSED)
 80252a2:	2b04      	cmp	r3, #4
 80252a4:	d1de      	bne.n	8025264 <protocol_run+0x24>
    {
        uint8_t dummy_buffer[64];
        do
        {
            instance.receive_pointer = dummy_buffer;
 80252a6:	4e83      	ldr	r6, [pc, #524]	; (80254b4 <protocol_run+0x274>)
 80252a8:	ad02      	add	r5, sp, #8
            instance.num_bytes_awaited = sizeof(dummy_buffer);
 80252aa:	2740      	movs	r7, #64	; 0x40
}

static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
 80252ac:	2140      	movs	r1, #64	; 0x40
 80252ae:	4628      	mov	r0, r5
    if (instance.state == PROTOCOL_STATE_CONFUSED)
    {
        uint8_t dummy_buffer[64];
        do
        {
            instance.receive_pointer = dummy_buffer;
 80252b0:	60a5      	str	r5, [r4, #8]
            instance.num_bytes_awaited = sizeof(dummy_buffer);
 80252b2:	81a7      	strh	r7, [r4, #12]
}

static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
 80252b4:	f005 fa64 	bl	802a780 <com_get_data>
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
    instance.num_bytes_awaited -= num_received_bytes;
 80252b8:	89a3      	ldrh	r3, [r4, #12]
static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
 80252ba:	68a2      	ldr	r2, [r4, #8]
    instance.num_bytes_awaited -= num_received_bytes;

    /* check for timeout */
    if (instance.get_time != NULL)
 80252bc:	6a21      	ldr	r1, [r4, #32]
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
    instance.num_bytes_awaited -= num_received_bytes;
 80252be:	1a1b      	subs	r3, r3, r0
 80252c0:	b29b      	uxth	r3, r3
static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
 80252c2:	4402      	add	r2, r0
}

static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
 80252c4:	4680      	mov	r8, r0
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
    instance.num_bytes_awaited -= num_received_bytes;
 80252c6:	81a3      	strh	r3, [r4, #12]
static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
 80252c8:	60a2      	str	r2, [r4, #8]
    instance.num_bytes_awaited -= num_received_bytes;

    /* check for timeout */
    if (instance.get_time != NULL)
 80252ca:	b311      	cbz	r1, 8025312 <protocol_run+0xd2>
    {
        /* get current time */
        uint32_t current_time = instance.get_time();
 80252cc:	4788      	blx	r1

        /* if no data has been received, check the time since last received
         * bytes
         */
        if (num_received_bytes == 0)
 80252ce:	f1b8 0f00 	cmp.w	r8, #0
 80252d2:	d121      	bne.n	8025318 <protocol_run+0xd8>
        {

        	if( instance.time_of_last_byte > current_time)
 80252d4:	6933      	ldr	r3, [r6, #16]
 80252d6:	4298      	cmp	r0, r3
 80252d8:	d319      	bcc.n	802530e <protocol_run+0xce>
        		/* Handle time wrap-around */
        		instance.time_of_last_byte = current_time;
        	}
        	else {

				if ((instance.state != PROTOCOL_STATE_IDLE) &&
 80252da:	7971      	ldrb	r1, [r6, #5]
 80252dc:	b309      	cbz	r1, 8025322 <protocol_run+0xe2>
					(current_time >= instance.time_of_last_byte +
 80252de:	6a72      	ldr	r2, [r6, #36]	; 0x24
 80252e0:	4413      	add	r3, r2
        		/* Handle time wrap-around */
        		instance.time_of_last_byte = current_time;
        	}
        	else {

				if ((instance.state != PROTOCOL_STATE_IDLE) &&
 80252e2:	4298      	cmp	r0, r3
 80252e4:	d31d      	bcc.n	8025322 <protocol_run+0xe2>
					(current_time >= instance.time_of_last_byte +
									 instance.timeout_interval))
				{
					/* a timeout has occurred, reset protocol state */
					if (instance.state != PROTOCOL_STATE_CONFUSED)
 80252e6:	2904      	cmp	r1, #4
 80252e8:	d008      	beq.n	80252fc <protocol_run+0xbc>
 80252ea:	a812      	add	r0, sp, #72	; 0x48
 80252ec:	4b73      	ldr	r3, [pc, #460]	; (80254bc <protocol_run+0x27c>)
 80252ee:	f840 3d44 	str.w	r3, [r0, #-68]!
    wr_payload_u8 (status_message, 0, CNST_STARTBYTE_STATUS);
    wr_payload_u8 (status_message, 1, endpoint);
    wr_payload_u16(status_message, 2, status_code);

    /* now send message */
    com_send_data(status_message, sizeof(status_message));
 80252f2:	2104      	movs	r1, #4
 80252f4:	f005 fa42 	bl	802a77c <com_send_data>
    com_flush();
 80252f8:	f005 fa52 	bl	802a7a0 <com_flush>
}

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state            = PROTOCOL_STATE_IDLE;
 80252fc:	2300      	movs	r3, #0
    instance.receive_pointer   = instance.message_frame;
 80252fe:	4a70      	ldr	r2, [pc, #448]	; (80254c0 <protocol_run+0x280>)
}

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state            = PROTOCOL_STATE_IDLE;
 8025300:	7163      	strb	r3, [r4, #5]
    instance.receive_pointer   = instance.message_frame;
    instance.num_bytes_awaited = 4;
 8025302:	2304      	movs	r3, #4

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state            = PROTOCOL_STATE_IDLE;
    instance.receive_pointer   = instance.message_frame;
 8025304:	60a2      	str	r2, [r4, #8]
    instance.num_bytes_awaited = 4;
 8025306:	81a3      	strh	r3, [r4, #12]
        /*
         * The receive_data function may switch the state back to idle, if a
         * timeout occurs, this is the  only way to get out of confused state.
         */
    }
}
 8025308:	b012      	add	sp, #72	; 0x48
 802530a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802530e:	89b3      	ldrh	r3, [r6, #12]
        {

        	if( instance.time_of_last_byte > current_time)
        	{
        		/* Handle time wrap-around */
        		instance.time_of_last_byte = current_time;
 8025310:	6130      	str	r0, [r6, #16]
        do
        {
            instance.receive_pointer = dummy_buffer;
            instance.num_bytes_awaited = sizeof(dummy_buffer);
            receive_data();
        } while (instance.num_bytes_awaited == 0);
 8025312:	2b00      	cmp	r3, #0
 8025314:	d0ca      	beq.n	80252ac <protocol_run+0x6c>
 8025316:	e7a5      	b.n	8025264 <protocol_run+0x24>
 8025318:	89b3      	ldrh	r3, [r6, #12]
        else
        {
            /* data has been received, so remember current time for next
             * timeout check
             */
            instance.time_of_last_byte = current_time;
 802531a:	6130      	str	r0, [r6, #16]
        do
        {
            instance.receive_pointer = dummy_buffer;
            instance.num_bytes_awaited = sizeof(dummy_buffer);
            receive_data();
        } while (instance.num_bytes_awaited == 0);
 802531c:	2b00      	cmp	r3, #0
 802531e:	d0c5      	beq.n	80252ac <protocol_run+0x6c>
 8025320:	e7a0      	b.n	8025264 <protocol_run+0x24>
 8025322:	89a3      	ldrh	r3, [r4, #12]
 8025324:	2b00      	cmp	r3, #0
 8025326:	d0c1      	beq.n	80252ac <protocol_run+0x6c>
 8025328:	e79c      	b.n	8025264 <protocol_run+0x24>

        case PROTOCOL_STATE_RECEIVING_PAYLOAD:
            if (instance.num_bytes_awaited == 0)
            {
                /* prepare for receiving message tail */
                instance.receive_pointer = instance.message_frame + 4;
 802532a:	f103 0018 	add.w	r0, r3, #24
                instance.num_bytes_awaited = 2;
 802532e:	2102      	movs	r1, #2
                instance.state = PROTOCOL_STATE_RECEIVING_TAIL;
 8025330:	2203      	movs	r2, #3

        case PROTOCOL_STATE_RECEIVING_PAYLOAD:
            if (instance.num_bytes_awaited == 0)
            {
                /* prepare for receiving message tail */
                instance.receive_pointer = instance.message_frame + 4;
 8025332:	6098      	str	r0, [r3, #8]
                instance.num_bytes_awaited = 2;
 8025334:	8199      	strh	r1, [r3, #12]
                instance.state = PROTOCOL_STATE_RECEIVING_TAIL;
 8025336:	715a      	strb	r2, [r3, #5]

                /* try to read payload */
                receive_data();
 8025338:	f7ff fefe 	bl	8025138 <receive_data>
                 */
                break;
            }

        case PROTOCOL_STATE_RECEIVING_TAIL:
            if (instance.num_bytes_awaited == 0)
 802533c:	89a3      	ldrh	r3, [r4, #12]
 802533e:	4e5d      	ldr	r6, [pc, #372]	; (80254b4 <protocol_run+0x274>)
 8025340:	2b00      	cmp	r3, #0
 8025342:	d1ad      	bne.n	80252a0 <protocol_run+0x60>
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, uint16_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8025344:	7e71      	ldrb	r1, [r6, #25]
 8025346:	7e33      	ldrb	r3, [r6, #24]
 *
 * \return The function returns the value read from the payload.
 */
static inline uint8_t rd_payload_u8(const uint8_t* payload, uint16_t offset)
{
    return payload[offset];
 8025348:	7d77      	ldrb	r7, [r6, #21]
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, uint16_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 802534a:	7df0      	ldrb	r0, [r6, #23]
            ((uint16_t)payload[offset    ]);
 802534c:	7db2      	ldrb	r2, [r6, #22]
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, uint16_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 802534e:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
                endpoint     = rd_payload_u8 (instance.message_frame, 1);
                payload_size = rd_payload_u16(instance.message_frame, 2);
                end_sequence = rd_payload_u16(instance.message_frame, 4);

                /* check end of payload sequence */
                if (end_sequence != CNST_END_OF_PAYLOAD)
 8025352:	f24e 01db 	movw	r1, #57563	; 0xe0db
 8025356:	428b      	cmp	r3, r1
 8025358:	d01b      	beq.n	8025392 <protocol_run+0x152>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802535a:	ad12      	add	r5, sp, #72	; 0x48
 802535c:	4b59      	ldr	r3, [pc, #356]	; (80254c4 <protocol_run+0x284>)
 802535e:	e795      	b.n	802528c <protocol_run+0x4c>
                      instance.state = PROTOCOL_STATE_CONFUSED;
                      send_status_message(0, PROTOCOL_ERROR_OUT_OF_MEMORY);
                      break;
                    }

                    instance.receive_pointer = instance.payload;
 8025360:	69f1      	ldr	r1, [r6, #28]
                    instance.num_bytes_awaited = payload_size;
 8025362:	81b2      	strh	r2, [r6, #12]
                    instance.state = PROTOCOL_STATE_RECEIVING_PAYLOAD;
 8025364:	2302      	movs	r3, #2
                      instance.state = PROTOCOL_STATE_CONFUSED;
                      send_status_message(0, PROTOCOL_ERROR_OUT_OF_MEMORY);
                      break;
                    }

                    instance.receive_pointer = instance.payload;
 8025366:	60b1      	str	r1, [r6, #8]
                    instance.num_bytes_awaited = payload_size;
                    instance.state = PROTOCOL_STATE_RECEIVING_PAYLOAD;
 8025368:	7173      	strb	r3, [r6, #5]
                    send_status_message(0, PROTOCOL_ERROR_BAD_ENDPOINT_ID);
                    break;
                }

                /* try to read payload */
                receive_data();
 802536a:	f7ff fee5 	bl	8025138 <receive_data>
                 */
                break;
            }

        case PROTOCOL_STATE_RECEIVING_PAYLOAD:
            if (instance.num_bytes_awaited == 0)
 802536e:	89a2      	ldrh	r2, [r4, #12]
 8025370:	4b50      	ldr	r3, [pc, #320]	; (80254b4 <protocol_run+0x274>)
 8025372:	2a00      	cmp	r2, #0
 8025374:	d0d9      	beq.n	802532a <protocol_run+0xea>
 8025376:	795b      	ldrb	r3, [r3, #5]
 8025378:	e793      	b.n	80252a2 <protocol_run+0x62>
                    send_status_message(0, PROTOCOL_ERROR_BAD_MESSAGE_START);
                    break;
                }

                /* check message header for endpoint number */
                if (endpoint <= instance.num_endpoints)
 802537a:	7933      	ldrb	r3, [r6, #4]
 802537c:	4283      	cmp	r3, r0
 802537e:	d329      	bcc.n	80253d4 <protocol_run+0x194>
                {
                    /* check payload size (A message with no payload makes no
                     * sense)
                     */
                    if (payload_size == 0)
 8025380:	ea52 2201 	orrs.w	r2, r2, r1, lsl #8
 8025384:	d049      	beq.n	802541a <protocol_run+0x1da>
                        send_status_message(0, PROTOCOL_ERROR_NO_PAYLOAD);
                        break;
                    }

                    /* prepare for receiving payload */
                    if (payload_size > instance.max_payload)
 8025386:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8025388:	429a      	cmp	r2, r3
 802538a:	d9e9      	bls.n	8025360 <protocol_run+0x120>
 802538c:	ad12      	add	r5, sp, #72	; 0x48
 802538e:	4b4e      	ldr	r3, [pc, #312]	; (80254c8 <protocol_run+0x288>)
 8025390:	e77c      	b.n	802528c <protocol_run+0x4c>
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, uint16_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8025392:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
                    instance.state = PROTOCOL_STATE_CONFUSED;
                    send_status_message(0, PROTOCOL_ERROR_BAD_PAYLOAD_END);
                    break;
                }

                if (endpoint != 0)
 8025396:	b307      	cbz	r7, 80253da <protocol_run+0x19a>
                    Endpoint_t* current_ep;

                    /* now send the payload package to the addressed endpoint
                     * and send the status code back
                     */
                    current_ep = &(instance.endpoints[endpoint-1]);
 8025398:	6835      	ldr	r5, [r6, #0]
                    status_code = current_ep->handle_message(endpoint,
 802539a:	69f1      	ldr	r1, [r6, #28]
                    Endpoint_t* current_ep;

                    /* now send the payload package to the addressed endpoint
                     * and send the status code back
                     */
                    current_ep = &(instance.endpoints[endpoint-1]);
 802539c:	2014      	movs	r0, #20
 802539e:	f06f 0313 	mvn.w	r3, #19
 80253a2:	fb10 3307 	smlabb	r3, r0, r7, r3
 80253a6:	442b      	add	r3, r5
                    status_code = current_ep->handle_message(endpoint,
 80253a8:	4638      	mov	r0, r7
 80253aa:	689d      	ldr	r5, [r3, #8]
 80253ac:	68db      	ldr	r3, [r3, #12]
 80253ae:	47a8      	blx	r5
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80253b0:	225b      	movs	r2, #91	; 0x5b
 80253b2:	4603      	mov	r3, r0
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 80253b4:	0a05      	lsrs	r5, r0, #8
    wr_payload_u8 (status_message, 0, CNST_STARTBYTE_STATUS);
    wr_payload_u8 (status_message, 1, endpoint);
    wr_payload_u16(status_message, 2, status_code);

    /* now send message */
    com_send_data(status_message, sizeof(status_message));
 80253b6:	2104      	movs	r1, #4
 80253b8:	a802      	add	r0, sp, #8
    payload[offset    ] =  value        & 0xFF;
 80253ba:	f88d 300a 	strb.w	r3, [sp, #10]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80253be:	f88d 2008 	strb.w	r2, [sp, #8]
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 80253c2:	f88d 500b 	strb.w	r5, [sp, #11]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80253c6:	f88d 7009 	strb.w	r7, [sp, #9]
 80253ca:	f005 f9d7 	bl	802a77c <com_send_data>
    com_flush();
 80253ce:	f005 f9e7 	bl	802a7a0 <com_flush>
 80253d2:	e793      	b.n	80252fc <protocol_run+0xbc>
 80253d4:	ad12      	add	r5, sp, #72	; 0x48
 80253d6:	4b3d      	ldr	r3, [pc, #244]	; (80254cc <protocol_run+0x28c>)
 80253d8:	e758      	b.n	802528c <protocol_run+0x4c>
 80253da:	69f3      	ldr	r3, [r6, #28]
 80253dc:	f893 8000 	ldrb.w	r8, [r3]
}

static uint16_t handle_message(uint8_t* message_data, uint16_t num_bytes)
{
    /* check command byte of received message */
    switch (message_data[0])
 80253e0:	f1b8 0f01 	cmp.w	r8, #1
 80253e4:	d076      	beq.n	80254d4 <protocol_run+0x294>
 80253e6:	d31b      	bcc.n	8025420 <protocol_run+0x1e0>
 80253e8:	f1b8 0f02 	cmp.w	r8, #2
 80253ec:	d102      	bne.n	80253f4 <protocol_run+0x1b4>
            return PROTOCOL_ERROR_OK;
        }
        break;

    case CNST_MSG_FIRMWARE_RESET:
        if (num_bytes == 1)
 80253ee:	2a01      	cmp	r2, #1
 80253f0:	f000 80c1 	beq.w	8025576 <protocol_run+0x336>
        {
            /* if user did not set system reset function, this feature is not
             * supported.
             */
            if (instance.do_system_reset == NULL)
 80253f4:	27ff      	movs	r7, #255	; 0xff
 80253f6:	ad02      	add	r5, sp, #8
 80253f8:	225b      	movs	r2, #91	; 0x5b
 80253fa:	2300      	movs	r3, #0
    wr_payload_u8 (status_message, 0, CNST_STARTBYTE_STATUS);
    wr_payload_u8 (status_message, 1, endpoint);
    wr_payload_u16(status_message, 2, status_code);

    /* now send message */
    com_send_data(status_message, sizeof(status_message));
 80253fc:	4628      	mov	r0, r5
 80253fe:	2104      	movs	r1, #4
 8025400:	f88d 2008 	strb.w	r2, [sp, #8]
 8025404:	f88d 3009 	strb.w	r3, [sp, #9]
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8025408:	f88d 700b 	strb.w	r7, [sp, #11]
    payload[offset    ] =  value        & 0xFF;
 802540c:	f88d 700a 	strb.w	r7, [sp, #10]
 8025410:	f005 f9b4 	bl	802a77c <com_send_data>
    com_flush();
 8025414:	f005 f9c4 	bl	802a7a0 <com_flush>
 8025418:	e770      	b.n	80252fc <protocol_run+0xbc>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802541a:	ad12      	add	r5, sp, #72	; 0x48
 802541c:	4b2c      	ldr	r3, [pc, #176]	; (80254d0 <protocol_run+0x290>)
 802541e:	e735      	b.n	802528c <protocol_run+0x4c>
{
    /* check command byte of received message */
    switch (message_data[0])
    {
    case CNST_MSG_QUERY_ENDPOINT_INFO:
        if (num_bytes == 1)
 8025420:	2a01      	cmp	r2, #1
 8025422:	d1e7      	bne.n	80253f4 <protocol_run+0x1b4>
    uint8_t i;

    /* setup message start (type und number of endpoints */
    uint8_t message_header[2];
    wr_payload_u8(message_header, 0, CNST_MSG_ENDPOINT_INFO);
    wr_payload_u8(message_header, 1, instance.num_endpoints);
 8025424:	7932      	ldrb	r2, [r6, #4]
 8025426:	f88d 2005 	strb.w	r2, [sp, #5]

    /* calculate message size and send start of message */
    protocol_send_header(0, 6 * instance.num_endpoints +
 802542a:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 802542e:	005b      	lsls	r3, r3, #1
 8025430:	3302      	adds	r3, #2
 8025432:	b29b      	uxth	r3, r3
    uint8_t header[4];
    wr_payload_u8 (header, 0, CNST_STARTBYTE_DATA);
    wr_payload_u8 (header, 1, endpoint);
    wr_payload_u16(header, 2, num_bytes);

    com_send_data(header, sizeof(header));
 8025434:	ad02      	add	r5, sp, #8
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8025436:	ea4f 2c13 	mov.w	ip, r3, lsr #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802543a:	f04f 0e5a 	mov.w	lr, #90	; 0x5a
 802543e:	4628      	mov	r0, r5
 8025440:	2104      	movs	r1, #4

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8025442:	f88d 300a 	strb.w	r3, [sp, #10]
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8025446:	f88d c00b 	strb.w	ip, [sp, #11]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802544a:	f88d e008 	strb.w	lr, [sp, #8]
 802544e:	f88d 7004 	strb.w	r7, [sp, #4]
 8025452:	f88d 7009 	strb.w	r7, [sp, #9]
 8025456:	f005 f991 	bl	802a77c <com_send_data>
}

void protocol_send_payload(const uint8_t* message_data, uint16_t num_bytes)
{
    /* send the data through the communication stream interface */
    com_send_data(message_data, num_bytes);
 802545a:	a801      	add	r0, sp, #4
 802545c:	2102      	movs	r1, #2
 802545e:	f005 f98d 	bl	802a77c <com_send_data>
    protocol_send_header(0, 6 * instance.num_endpoints +
                            sizeof(message_header));
    protocol_send_payload(message_header, sizeof(message_header));

    /* now send type and version for each endpoint */
    for (i = 0; i < instance.num_endpoints; ++i)
 8025462:	7933      	ldrb	r3, [r6, #4]
 8025464:	b30b      	cbz	r3, 80254aa <protocol_run+0x26a>
    {
        uint8_t ep_info[6];
        wr_payload_u32(ep_info, 0, instance.endpoints[i].endpoint_type);
 8025466:	b23a      	sxth	r2, r7
 8025468:	6821      	ldr	r1, [r4, #0]
 802546a:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    protocol_send_header(0, 6 * instance.num_endpoints +
                            sizeof(message_header));
    protocol_send_payload(message_header, sizeof(message_header));

    /* now send type and version for each endpoint */
    for (i = 0; i < instance.num_endpoints; ++i)
 802546e:	3701      	adds	r7, #1
    {
        uint8_t ep_info[6];
        wr_payload_u32(ep_info, 0, instance.endpoints[i].endpoint_type);
 8025470:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8025474:	f88d 3008 	strb.w	r3, [sp, #8]
 8025478:	eb01 0282 	add.w	r2, r1, r2, lsl #2
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 802547c:	0e18      	lsrs	r0, r3, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 802547e:	0c19      	lsrs	r1, r3, #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 8025480:	0a1b      	lsrs	r3, r3, #8
}

static inline void wr_payload_u32(uint8_t* payload, uint16_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8025482:	f88d 000b 	strb.w	r0, [sp, #11]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8025486:	f88d 100a 	strb.w	r1, [sp, #10]
    payload[offset + 1] = (value >>  8) & 0xFF;
 802548a:	f88d 3009 	strb.w	r3, [sp, #9]
        wr_payload_u16(ep_info, 4, instance.endpoints[i].endpoint_version);
 802548e:	8893      	ldrh	r3, [r2, #4]

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8025490:	f88d 300c 	strb.w	r3, [sp, #12]
}

void protocol_send_payload(const uint8_t* message_data, uint16_t num_bytes)
{
    /* send the data through the communication stream interface */
    com_send_data(message_data, num_bytes);
 8025494:	4628      	mov	r0, r5
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8025496:	0a1b      	lsrs	r3, r3, #8
 8025498:	2106      	movs	r1, #6
 802549a:	f88d 300d 	strb.w	r3, [sp, #13]
 802549e:	f005 f96d 	bl	802a77c <com_send_data>
    protocol_send_header(0, 6 * instance.num_endpoints +
                            sizeof(message_header));
    protocol_send_payload(message_header, sizeof(message_header));

    /* now send type and version for each endpoint */
    for (i = 0; i < instance.num_endpoints; ++i)
 80254a2:	7923      	ldrb	r3, [r4, #4]
 80254a4:	b2ff      	uxtb	r7, r7
 80254a6:	42bb      	cmp	r3, r7
 80254a8:	d8dd      	bhi.n	8025466 <protocol_run+0x226>
        wr_payload_u16(ep_info, 4, instance.endpoints[i].endpoint_version);
        protocol_send_payload(ep_info, sizeof(ep_info));
    }

    /* finish the message */
    protocol_send_tail();
 80254aa:	f7ff feb7 	bl	802521c <protocol_send_tail>
 80254ae:	4647      	mov	r7, r8
 80254b0:	e7a2      	b.n	80253f8 <protocol_run+0x1b8>
 80254b2:	bf00      	nop
 80254b4:	1fff1810 	.word	0x1fff1810
 80254b8:	0002005b 	.word	0x0002005b
 80254bc:	0001005b 	.word	0x0001005b
 80254c0:	1fff1824 	.word	0x1fff1824
 80254c4:	0007005b 	.word	0x0007005b
 80254c8:	0006005b 	.word	0x0006005b
 80254cc:	0003005b 	.word	0x0003005b
 80254d0:	0005005b 	.word	0x0005005b
            return PROTOCOL_ERROR_OK;
        }
        break;

    case CNST_MSG_QUERY_FW_INFO:
        if (num_bytes == 1)
 80254d4:	2a01      	cmp	r2, #1
 80254d6:	d18d      	bne.n	80253f4 <protocol_run+0x1b4>
    uint16_t string_length = 0;

    /* setup message start (type and number of endpoints */
    uint8_t message[7];
    wr_payload_u8 (message, 0, CNST_MSG_FW_INFO);
    wr_payload_u16(message, 1, firmware_information.version_major);
 80254d8:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 8025598 <protocol_run+0x358>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80254dc:	f88d 2008 	strb.w	r2, [sp, #8]
 80254e0:	f8b8 3004 	ldrh.w	r3, [r8, #4]
    wr_payload_u16(message, 3, firmware_information.version_minor);
 80254e4:	f8b8 0006 	ldrh.w	r0, [r8, #6]
    wr_payload_u16(message, 5, firmware_information.version_build);
 80254e8:	f8b8 1008 	ldrh.w	r1, [r8, #8]

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 80254ec:	f88d 3009 	strb.w	r3, [sp, #9]
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 80254f0:	0a06      	lsrs	r6, r0, #8
 80254f2:	0a1b      	lsrs	r3, r3, #8

    /* count length of firmware description string */
    while (firmware_information.description[string_length] != 0)
 80254f4:	f8d8 2000 	ldr.w	r2, [r8]
 80254f8:	f88d 600c 	strb.w	r6, [sp, #12]
 80254fc:	0a0d      	lsrs	r5, r1, #8
 80254fe:	f88d 300a 	strb.w	r3, [sp, #10]
    payload[offset    ] =  value        & 0xFF;
 8025502:	f88d 000b 	strb.w	r0, [sp, #11]
 8025506:	f88d 100d 	strb.w	r1, [sp, #13]
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 802550a:	f88d 500e 	strb.w	r5, [sp, #14]
 802550e:	7813      	ldrb	r3, [r2, #0]
 8025510:	463e      	mov	r6, r7
 8025512:	b123      	cbz	r3, 802551e <protocol_run+0x2de>
        ++string_length;
 8025514:	3601      	adds	r6, #1
 8025516:	b2b6      	uxth	r6, r6
    wr_payload_u16(message, 1, firmware_information.version_major);
    wr_payload_u16(message, 3, firmware_information.version_minor);
    wr_payload_u16(message, 5, firmware_information.version_build);

    /* count length of firmware description string */
    while (firmware_information.description[string_length] != 0)
 8025518:	5d93      	ldrb	r3, [r2, r6]
 802551a:	2b00      	cmp	r3, #0
 802551c:	d1fa      	bne.n	8025514 <protocol_run+0x2d4>
        ++string_length;
    ++string_length;

    /* send message */
    protocol_send_header(0, sizeof(message)  + string_length);
 802551e:	f106 0308 	add.w	r3, r6, #8
 8025522:	b29b      	uxth	r3, r3
 8025524:	ea4f 2c13 	mov.w	ip, r3, lsr #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8025528:	f04f 0e5a 	mov.w	lr, #90	; 0x5a
 802552c:	2200      	movs	r2, #0
    uint8_t header[4];
    wr_payload_u8 (header, 0, CNST_STARTBYTE_DATA);
    wr_payload_u8 (header, 1, endpoint);
    wr_payload_u16(header, 2, num_bytes);

    com_send_data(header, sizeof(header));
 802552e:	a801      	add	r0, sp, #4
 8025530:	2104      	movs	r1, #4
}

void protocol_send_payload(const uint8_t* message_data, uint16_t num_bytes)
{
    /* send the data through the communication stream interface */
    com_send_data(message_data, num_bytes);
 8025532:	ad02      	add	r5, sp, #8

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8025534:	f88d 3006 	strb.w	r3, [sp, #6]
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8025538:	f88d c007 	strb.w	ip, [sp, #7]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802553c:	f88d e004 	strb.w	lr, [sp, #4]
 8025540:	f88d 2005 	strb.w	r2, [sp, #5]
    uint8_t header[4];
    wr_payload_u8 (header, 0, CNST_STARTBYTE_DATA);
    wr_payload_u8 (header, 1, endpoint);
    wr_payload_u16(header, 2, num_bytes);

    com_send_data(header, sizeof(header));
 8025544:	f005 f91a 	bl	802a77c <com_send_data>
}

void protocol_send_payload(const uint8_t* message_data, uint16_t num_bytes)
{
    /* send the data through the communication stream interface */
    com_send_data(message_data, num_bytes);
 8025548:	4628      	mov	r0, r5
 802554a:	2107      	movs	r1, #7
 802554c:	f005 f916 	bl	802a77c <com_send_data>
    wr_payload_u16(message, 5, firmware_information.version_build);

    /* count length of firmware description string */
    while (firmware_information.description[string_length] != 0)
        ++string_length;
    ++string_length;
 8025550:	1c71      	adds	r1, r6, #1
}

void protocol_send_payload(const uint8_t* message_data, uint16_t num_bytes)
{
    /* send the data through the communication stream interface */
    com_send_data(message_data, num_bytes);
 8025552:	f8d8 0000 	ldr.w	r0, [r8]
 8025556:	b289      	uxth	r1, r1
 8025558:	f005 f910 	bl	802a77c <com_send_data>
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 802555c:	22e0      	movs	r2, #224	; 0xe0
    payload[offset    ] =  value        & 0xFF;
 802555e:	23db      	movs	r3, #219	; 0xdb
{
    /* setup message tail and send it */
    uint8_t tail[2];
    wr_payload_u16(tail, 0, CNST_END_OF_PAYLOAD);

    com_send_data(tail, sizeof(tail));
 8025560:	a801      	add	r0, sp, #4
 8025562:	2102      	movs	r1, #2
}

static inline void wr_payload_u16(uint8_t* payload, uint16_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8025564:	f88d 2005 	strb.w	r2, [sp, #5]
    payload[offset    ] =  value        & 0xFF;
 8025568:	f88d 3004 	strb.w	r3, [sp, #4]
 802556c:	f005 f906 	bl	802a77c <com_send_data>
    com_flush();
 8025570:	f005 f916 	bl	802a7a0 <com_flush>
 8025574:	e740      	b.n	80253f8 <protocol_run+0x1b8>
        if (num_bytes == 1)
        {
            /* if user did not set system reset function, this feature is not
             * supported.
             */
            if (instance.do_system_reset == NULL)
 8025576:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 8025578:	2b00      	cmp	r3, #0
 802557a:	f43f af3b 	beq.w	80253f4 <protocol_run+0x1b4>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline void wr_payload_u8(uint8_t* payload, uint16_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802557e:	ad12      	add	r5, sp, #72	; 0x48
 8025580:	235b      	movs	r3, #91	; 0x5b
 8025582:	f845 3d40 	str.w	r3, [r5, #-64]!
    wr_payload_u8 (status_message, 0, CNST_STARTBYTE_STATUS);
    wr_payload_u8 (status_message, 1, endpoint);
    wr_payload_u16(status_message, 2, status_code);

    /* now send message */
    com_send_data(status_message, sizeof(status_message));
 8025586:	2104      	movs	r1, #4
 8025588:	4628      	mov	r0, r5
 802558a:	f005 f8f7 	bl	802a77c <com_send_data>
    com_flush();
 802558e:	f005 f907 	bl	802a7a0 <com_flush>
             * possible.
             */
            send_status_message(0, PROTOCOL_ERROR_OK);

            /* now do the system reset */
            instance.do_system_reset();
 8025592:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 8025594:	4798      	blx	r3
 8025596:	e72f      	b.n	80253f8 <protocol_run+0x1b8>
 8025598:	1ffe9088 	.word	0x1ffe9088

0802559c <protocol_broadcast_change>:
    com_send_data(tail, sizeof(tail));
    com_flush();
}

void protocol_broadcast_change(void* context, uint32_t what)
{
 802559c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    uint8_t i;

    /* broadcast change notification to all endpoints that have a
     * handle_change function
     */
    for (i = 0; i < instance.num_endpoints; ++i)
 80255a0:	4d16      	ldr	r5, [pc, #88]	; (80255fc <protocol_broadcast_change+0x60>)
 80255a2:	f895 e004 	ldrb.w	lr, [r5, #4]
 80255a6:	f1be 0f00 	cmp.w	lr, #0
 80255aa:	d01c      	beq.n	80255e6 <protocol_broadcast_change+0x4a>
 80255ac:	4689      	mov	r9, r1
 80255ae:	4606      	mov	r6, r0
 80255b0:	2401      	movs	r4, #1
    {
        if ((instance.endpoints[i].handle_change) &&
 80255b2:	46a8      	mov	r8, r5
 80255b4:	e006      	b.n	80255c4 <protocol_broadcast_change+0x28>
 80255b6:	68db      	ldr	r3, [r3, #12]
 80255b8:	42b3      	cmp	r3, r6
 80255ba:	d016      	beq.n	80255ea <protocol_broadcast_change+0x4e>
 80255bc:	3401      	adds	r4, #1
    uint8_t i;

    /* broadcast change notification to all endpoints that have a
     * handle_change function
     */
    for (i = 0; i < instance.num_endpoints; ++i)
 80255be:	4572      	cmp	r2, lr
 80255c0:	b2e4      	uxtb	r4, r4
 80255c2:	d210      	bcs.n	80255e6 <protocol_broadcast_change+0x4a>
 80255c4:	1e63      	subs	r3, r4, #1
    {
        if ((instance.endpoints[i].handle_change) &&
 80255c6:	682a      	ldr	r2, [r5, #0]
 80255c8:	b2db      	uxtb	r3, r3
 80255ca:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80255ce:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80255d2:	4622      	mov	r2, r4
 80255d4:	691f      	ldr	r7, [r3, #16]
 80255d6:	2f00      	cmp	r7, #0
 80255d8:	d1ed      	bne.n	80255b6 <protocol_broadcast_change+0x1a>
 80255da:	4622      	mov	r2, r4
    uint8_t i;

    /* broadcast change notification to all endpoints that have a
     * handle_change function
     */
    for (i = 0; i < instance.num_endpoints; ++i)
 80255dc:	4572      	cmp	r2, lr
 80255de:	f104 0401 	add.w	r4, r4, #1
 80255e2:	b2e4      	uxtb	r4, r4
 80255e4:	d3ee      	bcc.n	80255c4 <protocol_broadcast_change+0x28>
 80255e6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    {
        if ((instance.endpoints[i].handle_change) &&
            (instance.endpoints[i].context == context))
        {
            instance.endpoints[i].handle_change(i + 1, context, what);
 80255ea:	464a      	mov	r2, r9
 80255ec:	4620      	mov	r0, r4
 80255ee:	4631      	mov	r1, r6
 80255f0:	47b8      	blx	r7
 80255f2:	f898 e004 	ldrb.w	lr, [r8, #4]
 80255f6:	4622      	mov	r2, r4
 80255f8:	e7e0      	b.n	80255bc <protocol_broadcast_change+0x20>
 80255fa:	bf00      	nop
 80255fc:	1fff1810 	.word	0x1fff1810

08025600 <USBD_VCOM_Event_GetDescriptor>:
	const uint8_t  descriptor_type   = (w_value >> 8);
	const uint8_t  descriptor_number = (w_value & 0xFF);
	const void* address = NULL;
	uint16_t    size    = NO_DESCRIPTOR;

	switch (descriptor_type)
 8025600:	0a03      	lsrs	r3, r0, #8
 8025602:	2b02      	cmp	r3, #2
 8025604:	d016      	beq.n	8025634 <USBD_VCOM_Event_GetDescriptor+0x34>
 8025606:	2b03      	cmp	r3, #3
 8025608:	d009      	beq.n	802561e <USBD_VCOM_Event_GetDescriptor+0x1e>
 802560a:	2b01      	cmp	r3, #1
 802560c:	d003      	beq.n	8025616 <USBD_VCOM_Event_GetDescriptor+0x16>
uint16_t USBD_VCOM_Event_GetDescriptor(const uint16_t w_value,
                                    const uint16_t w_index,
                                    const void** const descriptor_address)
{
	const uint8_t  descriptor_type   = (w_value >> 8);
	const uint8_t  descriptor_number = (w_value & 0xFF);
 802560e:	2000      	movs	r0, #0
 8025610:	4603      	mov	r3, r0
			}
			break;
	}

	(void)w_index;
	*descriptor_address = address;
 8025612:	6013      	str	r3, [r2, #0]
	return size;
}
 8025614:	4770      	bx	lr
	uint16_t    size    = NO_DESCRIPTOR;

	switch (descriptor_type)
	{
		case DTYPE_Device:
			address = &device_descriptor;
 8025616:	4b09      	ldr	r3, [pc, #36]	; (802563c <USBD_VCOM_Event_GetDescriptor+0x3c>)
			}
			break;
	}

	(void)w_index;
	*descriptor_address = address;
 8025618:	6013      	str	r3, [r2, #0]

	switch (descriptor_type)
	{
		case DTYPE_Device:
			address = &device_descriptor;
			size    = sizeof(USB_Descriptor_Device_t);
 802561a:	2012      	movs	r0, #18
	}

	(void)w_index;
	*descriptor_address = address;
	return size;
}
 802561c:	4770      	bx	lr
uint16_t USBD_VCOM_Event_GetDescriptor(const uint16_t w_value,
                                    const uint16_t w_index,
                                    const void** const descriptor_address)
{
	const uint8_t  descriptor_type   = (w_value >> 8);
	const uint8_t  descriptor_number = (w_value & 0xFF);
 802561e:	b2c0      	uxtb	r0, r0
 8025620:	2802      	cmp	r0, #2
 8025622:	d8f4      	bhi.n	802560e <USBD_VCOM_Event_GetDescriptor+0xe>
 8025624:	4b06      	ldr	r3, [pc, #24]	; (8025640 <USBD_VCOM_Event_GetDescriptor+0x40>)
 8025626:	4907      	ldr	r1, [pc, #28]	; (8025644 <USBD_VCOM_Event_GetDescriptor+0x44>)
 8025628:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
			}
			break;
	}

	(void)w_index;
	*descriptor_address = address;
 802562c:	6013      	str	r3, [r2, #0]
 802562e:	f831 0010 	ldrh.w	r0, [r1, r0, lsl #1]
	return size;
}
 8025632:	4770      	bx	lr
		case DTYPE_Device:
			address = &device_descriptor;
			size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			address = &configuration_descriptor;
 8025634:	4b04      	ldr	r3, [pc, #16]	; (8025648 <USBD_VCOM_Event_GetDescriptor+0x48>)
			}
			break;
	}

	(void)w_index;
	*descriptor_address = address;
 8025636:	6013      	str	r3, [r2, #0]
			address = &device_descriptor;
			size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			address = &configuration_descriptor;
			size    = sizeof(USB_Descriptor_Configuration_t);
 8025638:	203e      	movs	r0, #62	; 0x3e
	}

	(void)w_index;
	*descriptor_address = address;
	return size;
}
 802563a:	4770      	bx	lr
 802563c:	08030aac 	.word	0x08030aac
 8025640:	08030b90 	.word	0x08030b90
 8025644:	08030b9c 	.word	0x08030b9c
 8025648:	08030ba4 	.word	0x08030ba4

0802564c <CDC_Device_ProcessControlRequest>:
	 *  packet, \c false otherwise.
	 */
	static inline bool Endpoint_IsSETUPReceived(void);
	static inline bool Endpoint_IsSETUPReceived(void)
	{
		return device.IsSetupRecieved;
 802564c:	4a45      	ldr	r2, [pc, #276]	; (8025764 <CDC_Device_ProcessControlRequest+0x118>)
 802564e:	f892 313e 	ldrb.w	r3, [r2, #318]	; 0x13e
 * API IMPLEMENTATION
 **********************************************************************************************************************/
void CDC_Device_ProcessControlRequest(
					USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	if ((Endpoint_IsSETUPReceived() != 0) && (USB_ControlRequest.wIndex ==
 8025652:	079b      	lsls	r3, r3, #30
 8025654:	d510      	bpl.n	8025678 <CDC_Device_ProcessControlRequest+0x2c>
/**********************************************************************************************************************
 * API IMPLEMENTATION
 **********************************************************************************************************************/
void CDC_Device_ProcessControlRequest(
					USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
 8025656:	b570      	push	{r4, r5, r6, lr}
	if ((Endpoint_IsSETUPReceived() != 0) && (USB_ControlRequest.wIndex ==
 8025658:	4943      	ldr	r1, [pc, #268]	; (8025768 <CDC_Device_ProcessControlRequest+0x11c>)
 802565a:	7c84      	ldrb	r4, [r0, #18]
 802565c:	888b      	ldrh	r3, [r1, #4]
 802565e:	b29b      	uxth	r3, r3
 8025660:	429c      	cmp	r4, r3
 8025662:	d000      	beq.n	8025666 <CDC_Device_ProcessControlRequest+0x1a>
 8025664:	bd70      	pop	{r4, r5, r6, pc}
			CDCInterfaceInfo->Config.ControlInterfaceNumber))
	{

		switch (USB_ControlRequest.bRequest)
 8025666:	784b      	ldrb	r3, [r1, #1]
 8025668:	3b20      	subs	r3, #32
 802566a:	4604      	mov	r4, r0
 802566c:	2b03      	cmp	r3, #3
 802566e:	d8f9      	bhi.n	8025664 <CDC_Device_ProcessControlRequest+0x18>
 8025670:	e8df f003 	tbb	[pc, r3]
 8025674:	03633f18 	.word	0x03633f18
 8025678:	4770      	bx	lr

				}

				break;
			case CDC_REQ_SendBreak:
				if ((REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE) == USB_ControlRequest.bmRequestType)
 802567a:	780b      	ldrb	r3, [r1, #0]
 802567c:	493a      	ldr	r1, [pc, #232]	; (8025768 <CDC_Device_ProcessControlRequest+0x11c>)
 802567e:	2b21      	cmp	r3, #33	; 0x21
 8025680:	d1f0      	bne.n	8025664 <CDC_Device_ProcessControlRequest+0x18>
				{
					Endpoint_ClearSETUP();
					Endpoint_ClearStatusStage();

					if(0 != cdc_class_events.Device_BreakSent)
 8025682:	483a      	ldr	r0, [pc, #232]	; (802576c <CDC_Device_ProcessControlRequest+0x120>)
	 *  \note This is not applicable for non CONTROL type endpoints.
	 */
	static inline void Endpoint_ClearSETUP(void);
	static inline void Endpoint_ClearSETUP(void)
	{
		device.IsSetupRecieved = 0;
 8025684:	f892 313e 	ldrb.w	r3, [r2, #318]	; 0x13e
 8025688:	6885      	ldr	r5, [r0, #8]
 802568a:	f023 0302 	bic.w	r3, r3, #2
 802568e:	f882 313e 	strb.w	r3, [r2, #318]	; 0x13e
 8025692:	2d00      	cmp	r5, #0
 8025694:	d0e6      	beq.n	8025664 <CDC_Device_ProcessControlRequest+0x18>
					{
						cdc_class_events.Device_BreakSent(CDCInterfaceInfo,	(uint8_t)USB_ControlRequest.wValue);
 8025696:	8849      	ldrh	r1, [r1, #2]
 8025698:	4620      	mov	r0, r4
 802569a:	462b      	mov	r3, r5
 802569c:	b2c9      	uxtb	r1, r1
				}

				break;
		}
	}
}
 802569e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
					Endpoint_ClearSETUP();
					Endpoint_ClearStatusStage();

					if(0 != cdc_class_events.Device_BreakSent)
					{
						cdc_class_events.Device_BreakSent(CDCInterfaceInfo,	(uint8_t)USB_ControlRequest.wValue);
 80256a2:	4718      	bx	r3
					Endpoint_ClearStatusStage();
				}

				break;
			case CDC_REQ_SetLineEncoding:
				if ((REQDIR_HOSTTODEVICE |REQTYPE_CLASS | REQREC_INTERFACE) == USB_ControlRequest.bmRequestType)
 80256a4:	780b      	ldrb	r3, [r1, #0]
 80256a6:	2b21      	cmp	r3, #33	; 0x21
 80256a8:	d1dc      	bne.n	8025664 <CDC_Device_ProcessControlRequest+0x18>
 80256aa:	f892 013e 	ldrb.w	r0, [r2, #318]	; 0x13e
 80256ae:	f892 313c 	ldrb.w	r3, [r2, #316]	; 0x13c
				{
					Endpoint_ClearSETUP();

					while (!(Endpoint_IsOUTReceived()))
					{
						if (USB_DeviceState == DEVICE_STATE_Unattached)
 80256b2:	492f      	ldr	r1, [pc, #188]	; (8025770 <CDC_Device_ProcessControlRequest+0x124>)
 80256b4:	f020 0002 	bic.w	r0, r0, #2
	 */
	static inline bool Endpoint_IsOUTReceived(void);
	static inline bool Endpoint_IsOUTReceived(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->IsOutRecieved;
 80256b8:	252c      	movs	r5, #44	; 0x2c
	 *  \note This is not applicable for non CONTROL type endpoints.
	 */
	static inline void Endpoint_ClearSETUP(void);
	static inline void Endpoint_ClearSETUP(void)
	{
		device.IsSetupRecieved = 0;
 80256ba:	f882 013e 	strb.w	r0, [r2, #318]	; 0x13e
	 */
	static inline bool Endpoint_IsOUTReceived(void);
	static inline bool Endpoint_IsOUTReceived(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->IsOutRecieved;
 80256be:	fb05 2203 	mla	r2, r5, r3, r2
 80256c2:	e002      	b.n	80256ca <CDC_Device_ProcessControlRequest+0x7e>
 80256c4:	780b      	ldrb	r3, [r1, #0]
 80256c6:	2b00      	cmp	r3, #0
 80256c8:	d0cc      	beq.n	8025664 <CDC_Device_ProcessControlRequest+0x18>
 80256ca:	6893      	ldr	r3, [r2, #8]
			case CDC_REQ_SetLineEncoding:
				if ((REQDIR_HOSTTODEVICE |REQTYPE_CLASS | REQREC_INTERFACE) == USB_ControlRequest.bmRequestType)
				{
					Endpoint_ClearSETUP();

					while (!(Endpoint_IsOUTReceived()))
 80256cc:	069b      	lsls	r3, r3, #26
 80256ce:	d5f9      	bpl.n	80256c4 <CDC_Device_ProcessControlRequest+0x78>
					{
						if (USB_DeviceState == DEVICE_STATE_Unattached)
						  return;
					}

					CDCInterfaceInfo->State.LineEncoding.BaudRateBPS = Endpoint_Read_32_LE();
 80256d0:	f000 fc30 	bl	8025f34 <Endpoint_Read_32_LE>
 80256d4:	61a0      	str	r0, [r4, #24]
					CDCInterfaceInfo->State.LineEncoding.CharFormat  = Endpoint_Read_8();
 80256d6:	f000 fc01 	bl	8025edc <Endpoint_Read_8>
 80256da:	7720      	strb	r0, [r4, #28]
					CDCInterfaceInfo->State.LineEncoding.ParityType  = Endpoint_Read_8();
 80256dc:	f000 fbfe 	bl	8025edc <Endpoint_Read_8>
 80256e0:	7760      	strb	r0, [r4, #29]
					CDCInterfaceInfo->State.LineEncoding.DataBits    = Endpoint_Read_8();
 80256e2:	f000 fbfb 	bl	8025edc <Endpoint_Read_8>

					//Endpoint_ClearOUT();
					Endpoint_ClearStatusStage();

					if(0 != cdc_class_events.LineEncodingChanged)
 80256e6:	4b21      	ldr	r3, [pc, #132]	; (802576c <CDC_Device_ProcessControlRequest+0x120>)
					}

					CDCInterfaceInfo->State.LineEncoding.BaudRateBPS = Endpoint_Read_32_LE();
					CDCInterfaceInfo->State.LineEncoding.CharFormat  = Endpoint_Read_8();
					CDCInterfaceInfo->State.LineEncoding.ParityType  = Endpoint_Read_8();
					CDCInterfaceInfo->State.LineEncoding.DataBits    = Endpoint_Read_8();
 80256e8:	77a0      	strb	r0, [r4, #30]

					//Endpoint_ClearOUT();
					Endpoint_ClearStatusStage();

					if(0 != cdc_class_events.LineEncodingChanged)
 80256ea:	681b      	ldr	r3, [r3, #0]
 80256ec:	2b00      	cmp	r3, #0
 80256ee:	d134      	bne.n	802575a <CDC_Device_ProcessControlRequest+0x10e>
 80256f0:	e7b8      	b.n	8025664 <CDC_Device_ProcessControlRequest+0x18>
	{

		switch (USB_ControlRequest.bRequest)
		{
			case CDC_REQ_GetLineEncoding:
				if ((REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE) == USB_ControlRequest.bmRequestType)
 80256f2:	780b      	ldrb	r3, [r1, #0]
 80256f4:	2ba1      	cmp	r3, #161	; 0xa1
 80256f6:	d1b5      	bne.n	8025664 <CDC_Device_ProcessControlRequest+0x18>
	 *  \note This is not applicable for non CONTROL type endpoints.
	 */
	static inline void Endpoint_ClearSETUP(void);
	static inline void Endpoint_ClearSETUP(void)
	{
		device.IsSetupRecieved = 0;
 80256f8:	f892 113e 	ldrb.w	r1, [r2, #318]	; 0x13e
 80256fc:	f892 313c 	ldrb.w	r3, [r2, #316]	; 0x13c
 8025700:	f021 0102 	bic.w	r1, r1, #2
	 */
	static inline bool Endpoint_IsINReady(void);
	static inline bool Endpoint_IsINReady(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->InInUse == 0 && ep->IsEnabled;
 8025704:	202c      	movs	r0, #44	; 0x2c
	 *  \note This is not applicable for non CONTROL type endpoints.
	 */
	static inline void Endpoint_ClearSETUP(void);
	static inline void Endpoint_ClearSETUP(void)
	{
		device.IsSetupRecieved = 0;
 8025706:	f882 113e 	strb.w	r1, [r2, #318]	; 0x13e
	 */
	static inline bool Endpoint_IsINReady(void);
	static inline bool Endpoint_IsINReady(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->InInUse == 0 && ep->IsEnabled;
 802570a:	fb00 2203 	mla	r2, r0, r3, r2
 802570e:	6893      	ldr	r3, [r2, #8]
 8025710:	06d8      	lsls	r0, r3, #27
 8025712:	d4fc      	bmi.n	802570e <CDC_Device_ProcessControlRequest+0xc2>
 8025714:	6893      	ldr	r3, [r2, #8]
 8025716:	0799      	lsls	r1, r3, #30
 8025718:	d5f9      	bpl.n	802570e <CDC_Device_ProcessControlRequest+0xc2>
				{
					Endpoint_ClearSETUP();

					while (!(Endpoint_IsINReady()));

					Endpoint_Write_32_LE(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS);
 802571a:	69a0      	ldr	r0, [r4, #24]
 802571c:	f000 fbf4 	bl	8025f08 <Endpoint_Write_32_LE>
					Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.CharFormat);
 8025720:	7f20      	ldrb	r0, [r4, #28]
 8025722:	f000 fbc5 	bl	8025eb0 <Endpoint_Write_8>
					Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.ParityType);
 8025726:	7f60      	ldrb	r0, [r4, #29]
 8025728:	f000 fbc2 	bl	8025eb0 <Endpoint_Write_8>
					Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.DataBits);
 802572c:	7fa0      	ldrb	r0, [r4, #30]
 802572e:	f000 fbbf 	bl	8025eb0 <Endpoint_Write_8>
				}

				break;
		}
	}
}
 8025732:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
					Endpoint_Write_32_LE(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS);
					Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.CharFormat);
					Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.ParityType);
					Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.DataBits);

					Endpoint_ClearIN();
 8025736:	f000 bb6b 	b.w	8025e10 <Endpoint_ClearIN>

				}

				break;
			case CDC_REQ_SetControlLineState:
				if ((REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE) == USB_ControlRequest.bmRequestType)
 802573a:	780b      	ldrb	r3, [r1, #0]
 802573c:	490a      	ldr	r1, [pc, #40]	; (8025768 <CDC_Device_ProcessControlRequest+0x11c>)
 802573e:	2b21      	cmp	r3, #33	; 0x21
 8025740:	d190      	bne.n	8025664 <CDC_Device_ProcessControlRequest+0x18>
	 *  \note This is not applicable for non CONTROL type endpoints.
	 */
	static inline void Endpoint_ClearSETUP(void);
	static inline void Endpoint_ClearSETUP(void)
	{
		device.IsSetupRecieved = 0;
 8025742:	f892 313e 	ldrb.w	r3, [r2, #318]	; 0x13e
					Endpoint_ClearSETUP();
					Endpoint_ClearStatusStage();

					CDCInterfaceInfo->State.ControlLineStates.HostToDevice = USB_ControlRequest.wValue;

					if(0 != cdc_class_events.ControLineStateChanged)
 8025746:	4809      	ldr	r0, [pc, #36]	; (802576c <CDC_Device_ProcessControlRequest+0x120>)
 8025748:	f023 0302 	bic.w	r3, r3, #2
 802574c:	f882 313e 	strb.w	r3, [r2, #318]	; 0x13e
 8025750:	6843      	ldr	r3, [r0, #4]
				if ((REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE) == USB_ControlRequest.bmRequestType)
				{
					Endpoint_ClearSETUP();
					Endpoint_ClearStatusStage();

					CDCInterfaceInfo->State.ControlLineStates.HostToDevice = USB_ControlRequest.wValue;
 8025752:	884a      	ldrh	r2, [r1, #2]
 8025754:	82a2      	strh	r2, [r4, #20]

					if(0 != cdc_class_events.ControLineStateChanged)
 8025756:	2b00      	cmp	r3, #0
 8025758:	d084      	beq.n	8025664 <CDC_Device_ProcessControlRequest+0x18>
					{
						cdc_class_events.ControLineStateChanged(CDCInterfaceInfo);
 802575a:	4620      	mov	r0, r4
				}

				break;
		}
	}
}
 802575c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

					CDCInterfaceInfo->State.ControlLineStates.HostToDevice = USB_ControlRequest.wValue;

					if(0 != cdc_class_events.ControLineStateChanged)
					{
						cdc_class_events.ControLineStateChanged(CDCInterfaceInfo);
 8025760:	4718      	bx	r3
 8025762:	bf00      	nop
 8025764:	2000d8f4 	.word	0x2000d8f4
 8025768:	2000d6ec 	.word	0x2000d6ec
 802576c:	1ffe88ac 	.word	0x1ffe88ac
 8025770:	2000d6e9 	.word	0x2000d6e9

08025774 <CDC_Device_ConfigureEndpoints>:




bool CDC_Device_ConfigureEndpoints(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
 8025774:	b538      	push	{r3, r4, r5, lr}
	bool status = true;
	memset(&CDCInterfaceInfo->State, 0x00, sizeof(CDCInterfaceInfo->State));

	CDCInterfaceInfo->Config.DataINEndpoint.Type       = EP_TYPE_BULK;
 8025776:	2202      	movs	r2, #2


bool CDC_Device_ConfigureEndpoints(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	bool status = true;
	memset(&CDCInterfaceInfo->State, 0x00, sizeof(CDCInterfaceInfo->State));
 8025778:	2300      	movs	r3, #0

	CDCInterfaceInfo->Config.DataINEndpoint.Type       = EP_TYPE_BULK;
	CDCInterfaceInfo->Config.DataOUTEndpoint.Type      = EP_TYPE_BULK;
	CDCInterfaceInfo->Config.NotificationEndpoint.Type = EP_TYPE_INTERRUPT;
 802577a:	2103      	movs	r1, #3


bool CDC_Device_ConfigureEndpoints(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	bool status = true;
	memset(&CDCInterfaceInfo->State, 0x00, sizeof(CDCInterfaceInfo->State));
 802577c:	7503      	strb	r3, [r0, #20]
 802577e:	7543      	strb	r3, [r0, #21]
 8025780:	7583      	strb	r3, [r0, #22]
 8025782:	75c3      	strb	r3, [r0, #23]
 8025784:	7603      	strb	r3, [r0, #24]
 8025786:	7643      	strb	r3, [r0, #25]
 8025788:	7683      	strb	r3, [r0, #26]
 802578a:	76c3      	strb	r3, [r0, #27]
 802578c:	7703      	strb	r3, [r0, #28]
 802578e:	7743      	strb	r3, [r0, #29]
 8025790:	7783      	strb	r3, [r0, #30]
 8025792:	77c3      	strb	r3, [r0, #31]

	CDCInterfaceInfo->Config.DataINEndpoint.Type       = EP_TYPE_BULK;
 8025794:	7102      	strb	r2, [r0, #4]
	CDCInterfaceInfo->Config.DataOUTEndpoint.Type      = EP_TYPE_BULK;
 8025796:	7282      	strb	r2, [r0, #10]
	CDCInterfaceInfo->Config.NotificationEndpoint.Type = EP_TYPE_INTERRUPT;
 8025798:	7401      	strb	r1, [r0, #16]

	if (!(Endpoint_ConfigureEndpointTable(&CDCInterfaceInfo->Config.DataINEndpoint, 1)))
 802579a:	2101      	movs	r1, #1




bool CDC_Device_ConfigureEndpoints(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
 802579c:	4604      	mov	r4, r0

	CDCInterfaceInfo->Config.DataINEndpoint.Type       = EP_TYPE_BULK;
	CDCInterfaceInfo->Config.DataOUTEndpoint.Type      = EP_TYPE_BULK;
	CDCInterfaceInfo->Config.NotificationEndpoint.Type = EP_TYPE_INTERRUPT;

	if (!(Endpoint_ConfigureEndpointTable(&CDCInterfaceInfo->Config.DataINEndpoint, 1)))
 802579e:	f000 fbdf 	bl	8025f60 <Endpoint_ConfigureEndpointTable>
	{
		status = false;
	}

	if (!(Endpoint_ConfigureEndpointTable(
 80257a2:	2101      	movs	r1, #1

	CDCInterfaceInfo->Config.DataINEndpoint.Type       = EP_TYPE_BULK;
	CDCInterfaceInfo->Config.DataOUTEndpoint.Type      = EP_TYPE_BULK;
	CDCInterfaceInfo->Config.NotificationEndpoint.Type = EP_TYPE_INTERRUPT;

	if (!(Endpoint_ConfigureEndpointTable(&CDCInterfaceInfo->Config.DataINEndpoint, 1)))
 80257a4:	4605      	mov	r5, r0
	{
		status = false;
	}

	if (!(Endpoint_ConfigureEndpointTable(
 80257a6:	1da0      	adds	r0, r4, #6
 80257a8:	f000 fbda 	bl	8025f60 <Endpoint_ConfigureEndpointTable>
							&CDCInterfaceInfo->Config.DataOUTEndpoint, 1)))
	{
		status = false;
	}

	if (!(Endpoint_ConfigureEndpointTable(
 80257ac:	2101      	movs	r1, #1
	if (!(Endpoint_ConfigureEndpointTable(&CDCInterfaceInfo->Config.DataINEndpoint, 1)))
	{
		status = false;
	}

	if (!(Endpoint_ConfigureEndpointTable(
 80257ae:	2800      	cmp	r0, #0
							&CDCInterfaceInfo->Config.DataOUTEndpoint, 1)))
	{
		status = false;
	}

	if (!(Endpoint_ConfigureEndpointTable(
 80257b0:	f104 000c 	add.w	r0, r4, #12
	}

	if (!(Endpoint_ConfigureEndpointTable(
							&CDCInterfaceInfo->Config.DataOUTEndpoint, 1)))
	{
		status = false;
 80257b4:	bf08      	it	eq
 80257b6:	2500      	moveq	r5, #0
	}

	if (!(Endpoint_ConfigureEndpointTable(
 80257b8:	f000 fbd2 	bl	8025f60 <Endpoint_ConfigureEndpointTable>
 80257bc:	2800      	cmp	r0, #0
	{
		status = false;
	}

	return status;
}
 80257be:	bf14      	ite	ne
 80257c0:	4628      	movne	r0, r5
 80257c2:	2000      	moveq	r0, #0
 80257c4:	bd38      	pop	{r3, r4, r5, pc}
 80257c6:	bf00      	nop

080257c8 <CDC_Device_USBTask>:

void CDC_Device_USBTask(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 80257c8:	4b1c      	ldr	r3, [pc, #112]	; (802583c <CDC_Device_USBTask+0x74>)
 80257ca:	781a      	ldrb	r2, [r3, #0]
 80257cc:	2a04      	cmp	r2, #4
 80257ce:	d000      	beq.n	80257d2 <CDC_Device_USBTask+0xa>
		{
		  CDC_Device_Flush(CDCInterfaceInfo);
		}
		#endif
	}
}
 80257d0:	4770      	bx	lr
	return status;
}

void CDC_Device_USBTask(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 80257d2:	6982      	ldr	r2, [r0, #24]
 80257d4:	2a00      	cmp	r2, #0
 80257d6:	d0fb      	beq.n	80257d0 <CDC_Device_USBTask+0x8>

	return status;
}

void CDC_Device_USBTask(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
 80257d8:	b470      	push	{r4, r5, r6}
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
	{
		#if !defined(NO_CLASS_DRIVER_AUTOFLUSH)
		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataINEndpoint.Address);
 80257da:	7802      	ldrb	r2, [r0, #0]
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 80257dc:	4918      	ldr	r1, [pc, #96]	; (8025840 <CDC_Device_USBTask+0x78>)
 80257de:	f002 040f 	and.w	r4, r2, #15
	 */
	static inline bool Endpoint_IsINReady(void);
	static inline bool Endpoint_IsINReady(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->InInUse == 0 && ep->IsEnabled;
 80257e2:	262c      	movs	r6, #44	; 0x2c
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 80257e4:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
	 */
	static inline bool Endpoint_IsINReady(void);
	static inline bool Endpoint_IsINReady(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->InInUse == 0 && ep->IsEnabled;
 80257e8:	fb06 1504 	mla	r5, r6, r4, r1
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 80257ec:	f881 413c 	strb.w	r4, [r1, #316]	; 0x13c
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 80257f0:	f881 213d 	strb.w	r2, [r1, #317]	; 0x13d
	 */
	static inline bool Endpoint_IsINReady(void);
	static inline bool Endpoint_IsINReady(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->InInUse == 0 && ep->IsEnabled;
 80257f4:	68aa      	ldr	r2, [r5, #8]
 80257f6:	06d4      	lsls	r4, r2, #27
 80257f8:	d405      	bmi.n	8025806 <CDC_Device_USBTask+0x3e>
 80257fa:	68aa      	ldr	r2, [r5, #8]
 80257fc:	0792      	lsls	r2, r2, #30
 80257fe:	d502      	bpl.n	8025806 <CDC_Device_USBTask+0x3e>
}

uint8_t CDC_Device_Flush(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 8025800:	781b      	ldrb	r3, [r3, #0]
 8025802:	2b04      	cmp	r3, #4
 8025804:	d001      	beq.n	802580a <CDC_Device_USBTask+0x42>
		{
		  CDC_Device_Flush(CDCInterfaceInfo);
		}
		#endif
	}
}
 8025806:	bc70      	pop	{r4, r5, r6}
 8025808:	4770      	bx	lr
}

uint8_t CDC_Device_Flush(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 802580a:	6983      	ldr	r3, [r0, #24]
 802580c:	2b00      	cmp	r3, #0
 802580e:	d0fa      	beq.n	8025806 <CDC_Device_USBTask+0x3e>
	{
		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataINEndpoint.Address);
 8025810:	7803      	ldrb	r3, [r0, #0]
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8025812:	f003 020f 	and.w	r2, r3, #15
	 */
	static inline uint16_t Endpoint_BytesInEndpoint(void);
	static inline uint16_t Endpoint_BytesInEndpoint(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		if (ep->Direction)
 8025816:	fb06 1602 	mla	r6, r6, r2, r1
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 802581a:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 802581e:	f881 213c 	strb.w	r2, [r1, #316]	; 0x13c
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 8025822:	f881 313d 	strb.w	r3, [r1, #317]	; 0x13d
	 */
	static inline uint16_t Endpoint_BytesInEndpoint(void);
	static inline uint16_t Endpoint_BytesInEndpoint(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		if (ep->Direction)
 8025826:	7933      	ldrb	r3, [r6, #4]
 8025828:	061b      	lsls	r3, r3, #24
			return (uint16_t)(ep->InBytesAvailable);
 802582a:	bf4c      	ite	mi
 802582c:	8bb3      	ldrhmi	r3, [r6, #28]
		else
			return (uint16_t)(ep->OutBytesAvailable);
 802582e:	89b3      	ldrhpl	r3, [r6, #12]

		if (Endpoint_BytesInEndpoint())
 8025830:	2b00      	cmp	r3, #0
 8025832:	d0e8      	beq.n	8025806 <CDC_Device_USBTask+0x3e>
		{
		  CDC_Device_Flush(CDCInterfaceInfo);
		}
		#endif
	}
}
 8025834:	bc70      	pop	{r4, r5, r6}
	{
		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataINEndpoint.Address);

		if (Endpoint_BytesInEndpoint())
		{
			Endpoint_ClearIN();
 8025836:	f000 baeb 	b.w	8025e10 <Endpoint_ClearIN>
 802583a:	bf00      	nop
 802583c:	2000d6e9 	.word	0x2000d6e9
 8025840:	2000d8f4 	.word	0x2000d8f4

08025844 <CDC_Device_SendData>:
uint8_t CDC_Device_SendData(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo,
                            const void* const Buffer,
                            const uint16_t Length)
{
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 8025844:	4b0c      	ldr	r3, [pc, #48]	; (8025878 <CDC_Device_SendData+0x34>)
 8025846:	781b      	ldrb	r3, [r3, #0]
 8025848:	2b04      	cmp	r3, #4
 802584a:	d001      	beq.n	8025850 <CDC_Device_SendData+0xc>
	else
	{
		status = ENDPOINT_RWSTREAM_DeviceDisconnected;
	}
	return status;
}
 802584c:	2002      	movs	r0, #2
 802584e:	4770      	bx	lr
uint8_t CDC_Device_SendData(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo,
                            const void* const Buffer,
                            const uint16_t Length)
{
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 8025850:	6983      	ldr	r3, [r0, #24]
 8025852:	2b00      	cmp	r3, #0
 8025854:	d0fa      	beq.n	802584c <CDC_Device_SendData+0x8>
}

uint8_t CDC_Device_SendData(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo,
                            const void* const Buffer,
                            const uint16_t Length)
{
 8025856:	b430      	push	{r4, r5}
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
	{

		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataINEndpoint.Address);
 8025858:	7803      	ldrb	r3, [r0, #0]
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 802585a:	4c08      	ldr	r4, [pc, #32]	; (802587c <CDC_Device_SendData+0x38>)
 802585c:	f003 050f 	and.w	r5, r3, #15
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 8025860:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
		status = Endpoint_Write_Stream_LE(Buffer, Length, NULL);
 8025864:	4608      	mov	r0, r1
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8025866:	f884 513c 	strb.w	r5, [r4, #316]	; 0x13c
 802586a:	4611      	mov	r1, r2
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 802586c:	f884 313d 	strb.w	r3, [r4, #317]	; 0x13d
 8025870:	2200      	movs	r2, #0
	else
	{
		status = ENDPOINT_RWSTREAM_DeviceDisconnected;
	}
	return status;
}
 8025872:	bc30      	pop	{r4, r5}
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
	{

		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataINEndpoint.Address);
		status = Endpoint_Write_Stream_LE(Buffer, Length, NULL);
 8025874:	f000 b9b4 	b.w	8025be0 <Endpoint_Write_Stream_LE>
 8025878:	2000d6e9 	.word	0x2000d6e9
 802587c:	2000d8f4 	.word	0x2000d8f4

08025880 <CDC_Device_Flush>:
	return status;

}

uint8_t CDC_Device_Flush(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
 8025880:	b508      	push	{r3, lr}
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 8025882:	4b10      	ldr	r3, [pc, #64]	; (80258c4 <CDC_Device_Flush+0x44>)
 8025884:	781b      	ldrb	r3, [r3, #0]
 8025886:	2b04      	cmp	r3, #4
 8025888:	d001      	beq.n	802588e <CDC_Device_Flush+0xe>

		status = ENDPOINT_READYWAIT_NoError;
	}
	else
	{
		status = ENDPOINT_RWSTREAM_DeviceDisconnected;
 802588a:	2002      	movs	r0, #2
	}

	return status;
}
 802588c:	bd08      	pop	{r3, pc}
}

uint8_t CDC_Device_Flush(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 802588e:	6983      	ldr	r3, [r0, #24]
 8025890:	2b00      	cmp	r3, #0
 8025892:	d0fa      	beq.n	802588a <CDC_Device_Flush+0xa>
	{
		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataINEndpoint.Address);
 8025894:	7803      	ldrb	r3, [r0, #0]
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8025896:	490c      	ldr	r1, [pc, #48]	; (80258c8 <CDC_Device_Flush+0x48>)
 8025898:	f003 000f 	and.w	r0, r3, #15
	 */
	static inline uint16_t Endpoint_BytesInEndpoint(void);
	static inline uint16_t Endpoint_BytesInEndpoint(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		if (ep->Direction)
 802589c:	222c      	movs	r2, #44	; 0x2c
 802589e:	fb02 1200 	mla	r2, r2, r0, r1
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 80258a2:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 80258a6:	f881 013c 	strb.w	r0, [r1, #316]	; 0x13c
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 80258aa:	f881 313d 	strb.w	r3, [r1, #317]	; 0x13d
	 */
	static inline uint16_t Endpoint_BytesInEndpoint(void);
	static inline uint16_t Endpoint_BytesInEndpoint(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		if (ep->Direction)
 80258ae:	7913      	ldrb	r3, [r2, #4]
 80258b0:	061b      	lsls	r3, r3, #24
			return (uint16_t)(ep->InBytesAvailable);
 80258b2:	bf4c      	ite	mi
 80258b4:	8b90      	ldrhmi	r0, [r2, #28]
		else
			return (uint16_t)(ep->OutBytesAvailable);
 80258b6:	8990      	ldrhpl	r0, [r2, #12]

		if (Endpoint_BytesInEndpoint())
 80258b8:	2800      	cmp	r0, #0
 80258ba:	d0e7      	beq.n	802588c <CDC_Device_Flush+0xc>
		{
			Endpoint_ClearIN();
 80258bc:	f000 faa8 	bl	8025e10 <Endpoint_ClearIN>
 80258c0:	2000      	movs	r0, #0
 80258c2:	bd08      	pop	{r3, pc}
 80258c4:	2000d6e9 	.word	0x2000d6e9
 80258c8:	2000d8f4 	.word	0x2000d8f4

080258cc <CDC_Device_BytesReceived>:

	return status;
}

uint16_t CDC_Device_BytesReceived(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
 80258cc:	b508      	push	{r3, lr}
	uint16_t bytes = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 80258ce:	4b13      	ldr	r3, [pc, #76]	; (802591c <CDC_Device_BytesReceived+0x50>)
 80258d0:	781b      	ldrb	r3, [r3, #0]
 80258d2:	2b04      	cmp	r3, #4
 80258d4:	d001      	beq.n	80258da <CDC_Device_BytesReceived+0xe>
		if (Endpoint_IsOUTReceived())
		{
			if (!(Endpoint_BytesInEndpoint()))
			{
				Endpoint_ClearOUT();
				bytes = 0;
 80258d6:	2000      	movs	r0, #0
			bytes = 0;
		}
	}

	return bytes;
}
 80258d8:	bd08      	pop	{r3, pc}
}

uint16_t CDC_Device_BytesReceived(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	uint16_t bytes = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 80258da:	6983      	ldr	r3, [r0, #24]
 80258dc:	2b00      	cmp	r3, #0
 80258de:	d0fa      	beq.n	80258d6 <CDC_Device_BytesReceived+0xa>
	{

		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataOUTEndpoint.Address);
 80258e0:	7982      	ldrb	r2, [r0, #6]
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 80258e2:	490f      	ldr	r1, [pc, #60]	; (8025920 <CDC_Device_BytesReceived+0x54>)
 80258e4:	f002 000f 	and.w	r0, r2, #15
	 */
	static inline bool Endpoint_IsOUTReceived(void);
	static inline bool Endpoint_IsOUTReceived(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->IsOutRecieved;
 80258e8:	232c      	movs	r3, #44	; 0x2c
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 80258ea:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
	 */
	static inline bool Endpoint_IsOUTReceived(void);
	static inline bool Endpoint_IsOUTReceived(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->IsOutRecieved;
 80258ee:	fb03 1300 	mla	r3, r3, r0, r1
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 80258f2:	f881 213d 	strb.w	r2, [r1, #317]	; 0x13d
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 80258f6:	f881 013c 	strb.w	r0, [r1, #316]	; 0x13c
	 */
	static inline bool Endpoint_IsOUTReceived(void);
	static inline bool Endpoint_IsOUTReceived(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->IsOutRecieved;
 80258fa:	689a      	ldr	r2, [r3, #8]

		if (Endpoint_IsOUTReceived())
 80258fc:	0691      	lsls	r1, r2, #26
 80258fe:	d5ea      	bpl.n	80258d6 <CDC_Device_BytesReceived+0xa>
	 */
	static inline uint16_t Endpoint_BytesInEndpoint(void);
	static inline uint16_t Endpoint_BytesInEndpoint(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		if (ep->Direction)
 8025900:	791a      	ldrb	r2, [r3, #4]
 8025902:	0612      	lsls	r2, r2, #24
 8025904:	d505      	bpl.n	8025912 <CDC_Device_BytesReceived+0x46>
			return (uint16_t)(ep->InBytesAvailable);
 8025906:	8b98      	ldrh	r0, [r3, #28]
		{
			if (!(Endpoint_BytesInEndpoint()))
 8025908:	2800      	cmp	r0, #0
 802590a:	d1e5      	bne.n	80258d8 <CDC_Device_BytesReceived+0xc>
			{
				Endpoint_ClearOUT();
 802590c:	f000 fa54 	bl	8025db8 <Endpoint_ClearOUT>
 8025910:	e7e1      	b.n	80258d6 <CDC_Device_BytesReceived+0xa>
		else
			return (uint16_t)(ep->OutBytesAvailable);
 8025912:	8998      	ldrh	r0, [r3, #12]

		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataOUTEndpoint.Address);

		if (Endpoint_IsOUTReceived())
		{
			if (!(Endpoint_BytesInEndpoint()))
 8025914:	2800      	cmp	r0, #0
 8025916:	d1df      	bne.n	80258d8 <CDC_Device_BytesReceived+0xc>
 8025918:	e7f8      	b.n	802590c <CDC_Device_BytesReceived+0x40>
 802591a:	bf00      	nop
 802591c:	2000d6e9 	.word	0x2000d6e9
 8025920:	2000d8f4 	.word	0x2000d8f4

08025924 <USBD_VCOM_CDCClass_Event_LineEncodingChanged>:
 * as a parameter.*/
void USBD_VCOM_CDCClass_Event_LineEncodingChanged(USB_ClassInfo_CDC_Device_t* const cdc_interface_info)
{
  /*set here the global volatile flag(which can be polled from the top level application) to indicate
   * the event. */
  cdc_event_flags.line_encoding_event_flag = 1U;
 8025924:	4b01      	ldr	r3, [pc, #4]	; (802592c <USBD_VCOM_CDCClass_Event_LineEncodingChanged+0x8>)
 8025926:	2201      	movs	r2, #1
 8025928:	701a      	strb	r2, [r3, #0]
 802592a:	4770      	bx	lr
 802592c:	2000d644 	.word	0x2000d644

08025930 <USBD_VCOM_CDCClass_Event_ControlLineStateChanged>:
 * line states, such as DTR).The new control line states are available in the ControlLineStates.HostToDevice
 * value inside the CDC interface structure passed as a parameter. */
void USBD_VCOM_CDCClass_Event_ControlLineStateChanged(USB_ClassInfo_CDC_Device_t* const cdc_interface_info)
{
  /*set here the global volatile flag(which can be polled from the top level application) to indicate the event */
  cdc_event_flags.control_line_state_change_event_flag = 1U;
 8025930:	4b01      	ldr	r3, [pc, #4]	; (8025938 <USBD_VCOM_CDCClass_Event_ControlLineStateChanged+0x8>)
 8025932:	2201      	movs	r2, #1
 8025934:	705a      	strb	r2, [r3, #1]
 8025936:	4770      	bx	lr
 8025938:	2000d644 	.word	0x2000d644

0802593c <USBD_VCOM_CDCClass_Event_BreakSent>:
/*CDC class driver event for a send break request sent to the device from the host.
 * This is generally used to separate data or to indicate a special condition to the receiving device.*/
void USBD_VCOM_CDCClass_Event_BreakSent(USB_ClassInfo_CDC_Device_t* const cdc_interface_info,	const uint8_t duration)
{
  /*set here the global volatile flag(which can be polled from the top level application) to indicate the event */
  cdc_event_flags.break_event_flag = 1U;
 802593c:	4b01      	ldr	r3, [pc, #4]	; (8025944 <USBD_VCOM_CDCClass_Event_BreakSent+0x8>)
 802593e:	2201      	movs	r2, #1
 8025940:	709a      	strb	r2, [r3, #2]
 8025942:	4770      	bx	lr
 8025944:	2000d644 	.word	0x2000d644

08025948 <USBD_VCOM_Event_ConfigurationChanged>:

}

/* Event handler for the USB Configuration Changed event. */
void USBD_VCOM_Event_ConfigurationChanged(void)
{
 8025948:	b508      	push	{r3, lr}
  USBD_SetEndpointBuffer(((uint8_t)CDC_IN_EP_MASK|(uint8_t)CDC_NOTIFICATION_EPNUM), notification_ep_buf, 
 802594a:	2081      	movs	r0, #129	; 0x81
 802594c:	490e      	ldr	r1, [pc, #56]	; (8025988 <USBD_VCOM_Event_ConfigurationChanged+0x40>)
 802594e:	2240      	movs	r2, #64	; 0x40
 8025950:	f000 fff6 	bl	8026940 <USBD_SetEndpointBuffer>
  (uint16_t)USB_FS_MAXPKT_SIZE);
  USBD_SetEndpointBuffer(((uint8_t)CDC_IN_EP_MASK|(uint8_t)CDC_TX_EPNUM), tx_ep_buf, (uint16_t)USB_FS_MAXPKT_SIZE);
 8025954:	2082      	movs	r0, #130	; 0x82
 8025956:	490d      	ldr	r1, [pc, #52]	; (802598c <USBD_VCOM_Event_ConfigurationChanged+0x44>)
 8025958:	2240      	movs	r2, #64	; 0x40
 802595a:	f000 fff1 	bl	8026940 <USBD_SetEndpointBuffer>
  USBD_SetEndpointBuffer((CDC_RX_EPNUM), rx_ep_buf, (uint16_t)USB_FS_MAXPKT_SIZE);
 802595e:	2003      	movs	r0, #3
 8025960:	490b      	ldr	r1, [pc, #44]	; (8025990 <USBD_VCOM_Event_ConfigurationChanged+0x48>)
 8025962:	2240      	movs	r2, #64	; 0x40
 8025964:	f000 ffec 	bl	8026940 <USBD_SetEndpointBuffer>
  if (true == CDC_Device_ConfigureEndpoints(&USBD_VCOM_cdc_interface))
 8025968:	480a      	ldr	r0, [pc, #40]	; (8025994 <USBD_VCOM_Event_ConfigurationChanged+0x4c>)
 802596a:	f7ff ff03 	bl	8025774 <CDC_Device_ConfigureEndpoints>
 802596e:	b148      	cbz	r0, 8025984 <USBD_VCOM_Event_ConfigurationChanged+0x3c>
  {
    device.IsConfigured = 1U;
 8025970:	4a09      	ldr	r2, [pc, #36]	; (8025998 <USBD_VCOM_Event_ConfigurationChanged+0x50>)
    USB_DeviceState = (uint8_t)DEVICE_STATE_Configured;
 8025972:	490a      	ldr	r1, [pc, #40]	; (802599c <USBD_VCOM_Event_ConfigurationChanged+0x54>)
  (uint16_t)USB_FS_MAXPKT_SIZE);
  USBD_SetEndpointBuffer(((uint8_t)CDC_IN_EP_MASK|(uint8_t)CDC_TX_EPNUM), tx_ep_buf, (uint16_t)USB_FS_MAXPKT_SIZE);
  USBD_SetEndpointBuffer((CDC_RX_EPNUM), rx_ep_buf, (uint16_t)USB_FS_MAXPKT_SIZE);
  if (true == CDC_Device_ConfigureEndpoints(&USBD_VCOM_cdc_interface))
  {
    device.IsConfigured = 1U;
 8025974:	f892 313e 	ldrb.w	r3, [r2, #318]	; 0x13e
    USB_DeviceState = (uint8_t)DEVICE_STATE_Configured;
 8025978:	2004      	movs	r0, #4
  (uint16_t)USB_FS_MAXPKT_SIZE);
  USBD_SetEndpointBuffer(((uint8_t)CDC_IN_EP_MASK|(uint8_t)CDC_TX_EPNUM), tx_ep_buf, (uint16_t)USB_FS_MAXPKT_SIZE);
  USBD_SetEndpointBuffer((CDC_RX_EPNUM), rx_ep_buf, (uint16_t)USB_FS_MAXPKT_SIZE);
  if (true == CDC_Device_ConfigureEndpoints(&USBD_VCOM_cdc_interface))
  {
    device.IsConfigured = 1U;
 802597a:	f043 0301 	orr.w	r3, r3, #1
 802597e:	f882 313e 	strb.w	r3, [r2, #318]	; 0x13e
    USB_DeviceState = (uint8_t)DEVICE_STATE_Configured;
 8025982:	7008      	strb	r0, [r1, #0]
 8025984:	bd08      	pop	{r3, pc}
 8025986:	bf00      	nop
 8025988:	2000d648 	.word	0x2000d648
 802598c:	2000d604 	.word	0x2000d604
 8025990:	2000d688 	.word	0x2000d688
 8025994:	2000d6c8 	.word	0x2000d6c8
 8025998:	2000d8f4 	.word	0x2000d8f4
 802599c:	2000d6e9 	.word	0x2000d6e9

080259a0 <USBD_VCOM_Event_ControlRequest>:
}

/* Event handler for the USB Control Request reception event. */
void USBD_VCOM_Event_ControlRequest(void)
{
  CDC_Device_ProcessControlRequest(&USBD_VCOM_cdc_interface);
 80259a0:	4801      	ldr	r0, [pc, #4]	; (80259a8 <USBD_VCOM_Event_ControlRequest+0x8>)
 80259a2:	f7ff be53 	b.w	802564c <CDC_Device_ProcessControlRequest>
 80259a6:	bf00      	nop
 80259a8:	2000d6c8 	.word	0x2000d6c8

080259ac <USBD_VCOM_Event_Reset>:

/* Event handler for the USB reset event. */
void USBD_VCOM_Event_Reset(void)
{
  /*For self powered devices, reinitialize USB*/
  if (device.IsConfigured)
 80259ac:	492d      	ldr	r1, [pc, #180]	; (8025a64 <USBD_VCOM_Event_Reset+0xb8>)
 80259ae:	f891 213e 	ldrb.w	r2, [r1, #318]	; 0x13e
 80259b2:	07d3      	lsls	r3, r2, #31
 80259b4:	d400      	bmi.n	80259b8 <USBD_VCOM_Event_Reset+0xc>
 80259b6:	4770      	bx	lr

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 80259b8:	482b      	ldr	r0, [pc, #172]	; (8025a68 <USBD_VCOM_Event_Reset+0xbc>)
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
 80259ba:	4b2c      	ldr	r3, [pc, #176]	; (8025a6c <USBD_VCOM_Event_Reset+0xc0>)

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 80259bc:	6800      	ldr	r0, [r0, #0]
  CDC_Device_ProcessControlRequest(&USBD_VCOM_cdc_interface);
}

/* Event handler for the USB reset event. */
void USBD_VCOM_Event_Reset(void)
{
 80259be:	e92d 4ef0 	stmdb	sp!, {r4, r5, r6, r7, r9, sl, fp, lr}
  /*For self powered devices, reinitialize USB*/
  if (device.IsConfigured)
  {
    device.IsConfigured = 0U;
 80259c2:	f36f 0200 	bfc	r2, #0, #1
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
 80259c6:	f04f 0a00 	mov.w	sl, #0
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
 80259ca:	f04f 0903 	mov.w	r9, #3

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 80259ce:	4c28      	ldr	r4, [pc, #160]	; (8025a70 <USBD_VCOM_Event_Reset+0xc4>)
void USBD_VCOM_Event_Reset(void)
{
  /*For self powered devices, reinitialize USB*/
  if (device.IsConfigured)
  {
    device.IsConfigured = 0U;
 80259d0:	f881 213e 	strb.w	r2, [r1, #318]	; 0x13e
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
 80259d4:	f883 a012 	strb.w	sl, [r3, #18]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Size = CDC_NOTIFICATION_EPSIZE;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Type = (uint8_t)EP_TYPE_INTERRUPT;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Banks = 0U;
 80259d8:	f883 a011 	strb.w	sl, [r3, #17]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Size = CDC_NOTIFICATION_EPSIZE;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Type = (uint8_t)EP_TYPE_INTERRUPT;
 80259dc:	f883 9010 	strb.w	r9, [r3, #16]

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 80259e0:	6902      	ldr	r2, [r0, #16]
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
 80259e2:	6966      	ldr	r6, [r4, #20]
 80259e4:	6156      	str	r6, [r2, #20]
    USBD_handle->event_cb->suspend = event_callback->suspend;
 80259e6:	69e6      	ldr	r6, [r4, #28]
 80259e8:	61d6      	str	r6, [r2, #28]
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
 80259ea:	69a6      	ldr	r6, [r4, #24]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
 80259ec:	f883 a00b 	strb.w	sl, [r3, #11]
  CDC_Device_ProcessControlRequest(&USBD_VCOM_cdc_interface);
}

/* Event handler for the USB reset event. */
void USBD_VCOM_Event_Reset(void)
{
 80259f0:	b082      	sub	sp, #8
  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
 80259f2:	f883 a005 	strb.w	sl, [r3, #5]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
 80259f6:	f883 9006 	strb.w	r9, [r3, #6]
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
 80259fa:	6196      	str	r6, [r2, #24]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
 80259fc:	f04f 0a81 	mov.w	sl, #129	; 0x81

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8025a00:	6926      	ldr	r6, [r4, #16]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
 8025a02:	f883 a00c 	strb.w	sl, [r3, #12]
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Size = CDC_NOTIFICATION_EPSIZE;
 8025a06:	f04f 0908 	mov.w	r9, #8
 8025a0a:	f8a3 900e 	strh.w	r9, [r3, #14]
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
 8025a0e:	6821      	ldr	r1, [r4, #0]
  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
 8025a10:	68a7      	ldr	r7, [r4, #8]
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
 8025a12:	68e5      	ldr	r5, [r4, #12]

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8025a14:	6116      	str	r6, [r2, #16]
  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
 8025a16:	f04f 0b40 	mov.w	fp, #64	; 0x40
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
    USBD_handle->event_cb->start_of_frame = event_callback->start_of_frame;
 8025a1a:	6a26      	ldr	r6, [r4, #32]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
 8025a1c:	f8a3 b008 	strh.w	fp, [r3, #8]

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
 8025a20:	f04f 0a02 	mov.w	sl, #2

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
 8025a24:	f04f 0982 	mov.w	r9, #130	; 0x82
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
 8025a28:	f883 a00a 	strb.w	sl, [r3, #10]
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
 8025a2c:	9101      	str	r1, [sp, #4]
  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
 8025a2e:	f8a3 b002 	strh.w	fp, [r3, #2]
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
 8025a32:	6861      	ldr	r1, [r4, #4]

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
 8025a34:	f883 a004 	strb.w	sl, [r3, #4]

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
 8025a38:	f883 9000 	strb.w	r9, [r3]
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
    USBD_handle->event_cb->start_of_frame = event_callback->start_of_frame;
 8025a3c:	6216      	str	r6, [r2, #32]
  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
 8025a3e:	6097      	str	r7, [r2, #8]
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
 8025a40:	60d5      	str	r5, [r2, #12]
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
 8025a42:	9b01      	ldr	r3, [sp, #4]
 8025a44:	6013      	str	r3, [r2, #0]
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
    USBD_handle->event_cb->start_of_frame = event_callback->start_of_frame;
    USBD_handle->event_cb->reset = event_callback->reset;
 8025a46:	6a63      	ldr	r3, [r4, #36]	; 0x24
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
 8025a48:	6051      	str	r1, [r2, #4]
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
    USBD_handle->event_cb->start_of_frame = event_callback->start_of_frame;
    USBD_handle->event_cb->reset = event_callback->reset;
 8025a4a:	6253      	str	r3, [r2, #36]	; 0x24
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Banks = 0U;

  /*Register the required USB events*/
  if (USBD_VCOM_STATUS_SUCCESS == USBD_VCOM_Register_USBEvent_CB(&usbd_vcom_events))
  {
    if (USBD_VCOM_STATUS_SUCCESS != (USBD_VCOM_STATUS_t)USBD_Init(USBD_handle))
 8025a4c:	f000 fee2 	bl	8026814 <USBD_Init>
 8025a50:	b110      	cbz	r0, 8025a58 <USBD_VCOM_Event_Reset+0xac>
      if (USBD_VCOM_STATUS_SUCCESS != USBD_VCOM_Connect())
      {
      }
    }
  }
}
 8025a52:	b002      	add	sp, #8
 8025a54:	e8bd 8ef0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, sl, fp, pc}
 8025a58:	b002      	add	sp, #8
 8025a5a:	e8bd 4ef0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, sl, fp, lr}
}

/*The API to connect the VCOM device to USB host*/
USBD_VCOM_STATUS_t USBD_VCOM_Connect(void)
{
  return (USBD_VCOM_STATUS_t)USBD_Connect();
 8025a5e:	f000 bf63 	b.w	8026928 <USBD_Connect>
 8025a62:	bf00      	nop
 8025a64:	2000d8f4 	.word	0x2000d8f4
 8025a68:	1ffe88e0 	.word	0x1ffe88e0
 8025a6c:	2000d6c8 	.word	0x2000d6c8
 8025a70:	1ffe88b8 	.word	0x1ffe88b8

08025a74 <USBD_VCOM_Init>:

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8025a74:	4a26      	ldr	r2, [pc, #152]	; (8025b10 <USBD_VCOM_Init+0x9c>)
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
 8025a76:	4b27      	ldr	r3, [pc, #156]	; (8025b14 <USBD_VCOM_Init+0xa0>)

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8025a78:	6810      	ldr	r0, [r2, #0]
 8025a7a:	4927      	ldr	r1, [pc, #156]	; (8025b18 <USBD_VCOM_Init+0xa4>)
}


/*The function initializes the USB core layer and register USB event call backs. */
USBD_VCOM_STATUS_t USBD_VCOM_Init(USBD_VCOM_t *vcom_handle)
{
 8025a7c:	e92d 4ef0 	stmdb	sp!, {r4, r5, r6, r7, r9, sl, fp, lr}
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
 8025a80:	f04f 0a00 	mov.w	sl, #0
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
 8025a84:	f04f 0903 	mov.w	r9, #3
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
 8025a88:	f883 a012 	strb.w	sl, [r3, #18]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Size = CDC_NOTIFICATION_EPSIZE;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Type = (uint8_t)EP_TYPE_INTERRUPT;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Banks = 0U;
 8025a8c:	f883 a011 	strb.w	sl, [r3, #17]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Size = CDC_NOTIFICATION_EPSIZE;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Type = (uint8_t)EP_TYPE_INTERRUPT;
 8025a90:	f883 9010 	strb.w	r9, [r3, #16]

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8025a94:	6902      	ldr	r2, [r0, #16]
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
 8025a96:	694e      	ldr	r6, [r1, #20]
 8025a98:	6156      	str	r6, [r2, #20]
    USBD_handle->event_cb->suspend = event_callback->suspend;
 8025a9a:	69ce      	ldr	r6, [r1, #28]
 8025a9c:	61d6      	str	r6, [r2, #28]
}


/*The function initializes the USB core layer and register USB event call backs. */
USBD_VCOM_STATUS_t USBD_VCOM_Init(USBD_VCOM_t *vcom_handle)
{
 8025a9e:	b082      	sub	sp, #8
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
 8025aa0:	698e      	ldr	r6, [r1, #24]
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
 8025aa2:	680c      	ldr	r4, [r1, #0]
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
 8025aa4:	6196      	str	r6, [r2, #24]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
 8025aa6:	f883 a00b 	strb.w	sl, [r3, #11]

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8025aaa:	690e      	ldr	r6, [r1, #16]
  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
 8025aac:	f883 a005 	strb.w	sl, [r3, #5]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
 8025ab0:	f883 9006 	strb.w	r9, [r3, #6]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
 8025ab4:	f04f 0a81 	mov.w	sl, #129	; 0x81
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Size = CDC_NOTIFICATION_EPSIZE;
 8025ab8:	f04f 0908 	mov.w	r9, #8
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
 8025abc:	68cd      	ldr	r5, [r1, #12]
  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
 8025abe:	688f      	ldr	r7, [r1, #8]

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8025ac0:	6116      	str	r6, [r2, #16]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
 8025ac2:	f883 a00c 	strb.w	sl, [r3, #12]
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
    USBD_handle->event_cb->start_of_frame = event_callback->start_of_frame;
 8025ac6:	6a0e      	ldr	r6, [r1, #32]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Size = CDC_NOTIFICATION_EPSIZE;
 8025ac8:	f8a3 900e 	strh.w	r9, [r3, #14]
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
 8025acc:	9401      	str	r4, [sp, #4]
  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
 8025ace:	f04f 0b40 	mov.w	fp, #64	; 0x40
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
 8025ad2:	f04f 0a02 	mov.w	sl, #2

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
 8025ad6:	f04f 0982 	mov.w	r9, #130	; 0x82
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
 8025ada:	684c      	ldr	r4, [r1, #4]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
 8025adc:	f8a3 b008 	strh.w	fp, [r3, #8]
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
    USBD_handle->event_cb->start_of_frame = event_callback->start_of_frame;
 8025ae0:	6216      	str	r6, [r2, #32]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
 8025ae2:	f883 a00a 	strb.w	sl, [r3, #10]
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
 8025ae6:	60d5      	str	r5, [r2, #12]
  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
 8025ae8:	6097      	str	r7, [r2, #8]
  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
 8025aea:	f8a3 b002 	strh.w	fp, [r3, #2]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
 8025aee:	f883 a004 	strb.w	sl, [r3, #4]

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
 8025af2:	f883 9000 	strb.w	r9, [r3]
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
 8025af6:	9b01      	ldr	r3, [sp, #4]
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
 8025af8:	e882 0018 	stmia.w	r2, {r3, r4}
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
    USBD_handle->event_cb->start_of_frame = event_callback->start_of_frame;
    USBD_handle->event_cb->reset = event_callback->reset;
 8025afc:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8025afe:	6253      	str	r3, [r2, #36]	; 0x24
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Banks = 0U;

  /*Register the required USB events*/
  if (USBD_VCOM_STATUS_SUCCESS == USBD_VCOM_Register_USBEvent_CB(&usbd_vcom_events))
  {
    if (USBD_VCOM_STATUS_SUCCESS != (USBD_VCOM_STATUS_t)USBD_Init(USBD_handle))
 8025b00:	f000 fe88 	bl	8026814 <USBD_Init>
  }
  /*Remove the compilation warning*/
  (void)vcom_handle;

  return status;
}
 8025b04:	3000      	adds	r0, #0
 8025b06:	bf18      	it	ne
 8025b08:	2001      	movne	r0, #1
 8025b0a:	b002      	add	sp, #8
 8025b0c:	e8bd 8ef0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, sl, fp, pc}
 8025b10:	1ffe88e0 	.word	0x1ffe88e0
 8025b14:	2000d6c8 	.word	0x2000d6c8
 8025b18:	1ffe88b8 	.word	0x1ffe88b8

08025b1c <USBD_VCOM_IsEnumDone>:

/*The function check if the enumeration has been done already. */
uint32_t USBD_VCOM_IsEnumDone(void)
{
 8025b1c:	b508      	push	{r3, lr}
  return (uint32_t)(USBD_IsEnumDone() && (USB_DeviceState == (uint8_t)DEVICE_STATE_Configured));
 8025b1e:	f000 ff09 	bl	8026934 <USBD_IsEnumDone>
 8025b22:	b130      	cbz	r0, 8025b32 <USBD_VCOM_IsEnumDone+0x16>
 8025b24:	4b03      	ldr	r3, [pc, #12]	; (8025b34 <USBD_VCOM_IsEnumDone+0x18>)
 8025b26:	7818      	ldrb	r0, [r3, #0]
 8025b28:	f1a0 0004 	sub.w	r0, r0, #4
 8025b2c:	fab0 f080 	clz	r0, r0
 8025b30:	0940      	lsrs	r0, r0, #5
}
 8025b32:	bd08      	pop	{r3, pc}
 8025b34:	2000d6e9 	.word	0x2000d6e9

08025b38 <USBD_VCOM_SendData>:
  return status;
}

/* This function sends multiple bytes to the USB host. */
USBD_VCOM_STATUS_t USBD_VCOM_SendData(const int8_t* const data_buffer, const uint16_t length)
{
 8025b38:	b510      	push	{r4, lr}
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  if ((length == 0U) || (data_buffer == NULL))
 8025b3a:	b911      	cbnz	r1, 8025b42 <USBD_VCOM_SendData+0xa>
  {
    status = USBD_VCOM_STATUS_CDC_ERROR;		  
 8025b3c:	2406      	movs	r4, #6
    {
      status = USBD_VCOM_STATUS_CDC_ERROR;
    }
  }
  return status;
}
 8025b3e:	4620      	mov	r0, r4
 8025b40:	bd10      	pop	{r4, pc}
/* This function sends multiple bytes to the USB host. */
USBD_VCOM_STATUS_t USBD_VCOM_SendData(const int8_t* const data_buffer, const uint16_t length)
{
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  if ((length == 0U) || (data_buffer == NULL))
 8025b42:	2800      	cmp	r0, #0
 8025b44:	d0fa      	beq.n	8025b3c <USBD_VCOM_SendData+0x4>
 8025b46:	460a      	mov	r2, r1
 8025b48:	4601      	mov	r1, r0
  }
  else
  {
    /* Send data to USB host.*/
    if ((uint8_t)ENDPOINT_RWSTREAM_NoError !=
        CDC_Device_SendData(&USBD_VCOM_cdc_interface, (const int8_t *)data_buffer, length))
 8025b4a:	4807      	ldr	r0, [pc, #28]	; (8025b68 <USBD_VCOM_SendData+0x30>)
 8025b4c:	f7ff fe7a 	bl	8025844 <CDC_Device_SendData>
    status = USBD_VCOM_STATUS_CDC_ERROR;		  
  }
  else
  {
    /* Send data to USB host.*/
    if ((uint8_t)ENDPOINT_RWSTREAM_NoError !=
 8025b50:	2800      	cmp	r0, #0
        CDC_Device_SendData(&USBD_VCOM_cdc_interface, (const int8_t *)data_buffer, length))
    {
      status = USBD_VCOM_STATUS_CDC_ERROR;
    }
    if ((uint8_t)ENDPOINT_READYWAIT_NoError != CDC_Device_Flush(&USBD_VCOM_cdc_interface))
 8025b52:	4805      	ldr	r0, [pc, #20]	; (8025b68 <USBD_VCOM_SendData+0x30>)
  {
    /* Send data to USB host.*/
    if ((uint8_t)ENDPOINT_RWSTREAM_NoError !=
        CDC_Device_SendData(&USBD_VCOM_cdc_interface, (const int8_t *)data_buffer, length))
    {
      status = USBD_VCOM_STATUS_CDC_ERROR;
 8025b54:	bf14      	ite	ne
 8025b56:	2406      	movne	r4, #6
 8025b58:	2400      	moveq	r4, #0
    }
    if ((uint8_t)ENDPOINT_READYWAIT_NoError != CDC_Device_Flush(&USBD_VCOM_cdc_interface))
 8025b5a:	f7ff fe91 	bl	8025880 <CDC_Device_Flush>
 8025b5e:	2800      	cmp	r0, #0
    {
      status = USBD_VCOM_STATUS_CDC_ERROR;
 8025b60:	bf18      	it	ne
 8025b62:	2406      	movne	r4, #6
    }
  }
  return status;
}
 8025b64:	4620      	mov	r0, r4
 8025b66:	bd10      	pop	{r4, pc}
 8025b68:	2000d6c8 	.word	0x2000d6c8

08025b6c <USBD_VCOM_ReceiveData>:
  return status;
}

/* This function receives number of bytes from the USB host.*/
USBD_VCOM_STATUS_t USBD_VCOM_ReceiveData(int8_t* data_buffer, uint16_t data_byte)
{
 8025b6c:	b530      	push	{r4, r5, lr}
 8025b6e:	b083      	sub	sp, #12
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;
  uint16_t bytes_processed = 0U;
 8025b70:	2300      	movs	r3, #0
 8025b72:	f8ad 3006 	strh.w	r3, [sp, #6]
  uint8_t ret = 0U;

  if ((data_byte > 0U) && (data_buffer != NULL))
 8025b76:	b911      	cbnz	r1, 8025b7e <USBD_VCOM_ReceiveData+0x12>
      status = USBD_VCOM_STATUS_CDC_ERROR;
    }
  }
  else
  {
    status = USBD_VCOM_STATUS_CDC_ERROR;
 8025b78:	2006      	movs	r0, #6
  }

  return status;
}
 8025b7a:	b003      	add	sp, #12
 8025b7c:	bd30      	pop	{r4, r5, pc}
{
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;
  uint16_t bytes_processed = 0U;
  uint8_t ret = 0U;

  if ((data_byte > 0U) && (data_buffer != NULL))
 8025b7e:	2800      	cmp	r0, #0
 8025b80:	d0fa      	beq.n	8025b78 <USBD_VCOM_ReceiveData+0xc>
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8025b82:	4a0b      	ldr	r2, [pc, #44]	; (8025bb0 <USBD_VCOM_ReceiveData+0x44>)
 8025b84:	460c      	mov	r4, r1
 8025b86:	2103      	movs	r1, #3
 8025b88:	4605      	mov	r5, r0
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 8025b8a:	f882 313d 	strb.w	r3, [r2, #317]	; 0x13d
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8025b8e:	f882 113c 	strb.w	r1, [r2, #316]	; 0x13c
  {
    /* Fix for new read/write */
    Endpoint_SelectEndpoint(CDC_RX_EPNUM);
    while ((uint8_t)ENDPOINT_RWSTREAM_IncompleteTransfer == 
 8025b92:	4628      	mov	r0, r5
 8025b94:	4621      	mov	r1, r4
 8025b96:	f10d 0206 	add.w	r2, sp, #6
 8025b9a:	f000 f871 	bl	8025c80 <Endpoint_Read_Stream_LE>
 8025b9e:	2805      	cmp	r0, #5
 8025ba0:	d0f7      	beq.n	8025b92 <USBD_VCOM_ReceiveData+0x26>
    (ret = Endpoint_Read_Stream_LE(data_buffer, data_byte,	&bytes_processed)))
    {      
    }      
    if ((uint8_t)ENDPOINT_RWSTREAM_NoError != ret )
    {
      status = USBD_VCOM_STATUS_CDC_ERROR;
 8025ba2:	2800      	cmp	r0, #0
 8025ba4:	bf0c      	ite	eq
 8025ba6:	2000      	moveq	r0, #0
 8025ba8:	2006      	movne	r0, #6
  {
    status = USBD_VCOM_STATUS_CDC_ERROR;
  }

  return status;
}
 8025baa:	b003      	add	sp, #12
 8025bac:	bd30      	pop	{r4, r5, pc}
 8025bae:	bf00      	nop
 8025bb0:	2000d8f4 	.word	0x2000d8f4

08025bb4 <USBD_VCOM_BytesReceived>:
  return status;
}

/* This function checks number of bytes received from the USB host. */
uint16_t USBD_VCOM_BytesReceived(void)
{
 8025bb4:	b538      	push	{r3, r4, r5, lr}
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8025bb6:	4c07      	ldr	r4, [pc, #28]	; (8025bd4 <USBD_VCOM_BytesReceived+0x20>)
 8025bb8:	f44f 6500 	mov.w	r5, #2048	; 0x800
 8025bbc:	f8c4 508c 	str.w	r5, [r4, #140]	; 0x8c
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8025bc0:	f3bf 8f4f 	dsb	sy
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 8025bc4:	f3bf 8f6f 	isb	sy
  uint16_t bytes = 0U;

  /* Check if bytes are received from host */
  NVIC_DisableIRQ(USB0_0_IRQn);
  bytes = CDC_Device_BytesReceived(&USBD_VCOM_cdc_interface);
 8025bc8:	4803      	ldr	r0, [pc, #12]	; (8025bd8 <USBD_VCOM_BytesReceived+0x24>)
 8025bca:	f7ff fe7f 	bl	80258cc <CDC_Device_BytesReceived>
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8025bce:	60e5      	str	r5, [r4, #12]
  NVIC_EnableIRQ(USB0_0_IRQn);	
    
  return bytes;
}
 8025bd0:	bd38      	pop	{r3, r4, r5, pc}
 8025bd2:	bf00      	nop
 8025bd4:	e000e100 	.word	0xe000e100
 8025bd8:	2000d6c8 	.word	0x2000d6c8

08025bdc <USBD_VCOM_Connect>:
}

/*The API to connect the VCOM device to USB host*/
USBD_VCOM_STATUS_t USBD_VCOM_Connect(void)
{
  return (USBD_VCOM_STATUS_t)USBD_Connect();
 8025bdc:	f000 bea4 	b.w	8026928 <USBD_Connect>

08025be0 <Endpoint_Write_Stream_LE>:
/*Flag to indicate the zlp to be sent or not*/
volatile uint8_t zlp_flag = 0;

uint8_t Endpoint_Write_Stream_LE (const void *const Buffer, uint16_t Length,
											uint16_t *const BytesProcessed)
{
 8025be0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	USBD_Endpoint_t* ep = &device.Endpoints[device.CurrentEndpoint];
 8025be4:	4b25      	ldr	r3, [pc, #148]	; (8025c7c <Endpoint_Write_Stream_LE+0x9c>)
/*Flag to indicate the zlp to be sent or not*/
volatile uint8_t zlp_flag = 0;

uint8_t Endpoint_Write_Stream_LE (const void *const Buffer, uint16_t Length,
											uint16_t *const BytesProcessed)
{
 8025be6:	460c      	mov	r4, r1
 8025be8:	4680      	mov	r8, r0
	USBD_Endpoint_t* ep = &device.Endpoints[device.CurrentEndpoint];
 8025bea:	f893 113c 	ldrb.w	r1, [r3, #316]	; 0x13c
	uint16_t Bytes = 0;
	uint16_t BytesTransfered = 0;
	uint8_t ErrorCode;

	if (BytesProcessed!=NULL) 
 8025bee:	4691      	mov	r9, r2
 8025bf0:	2a00      	cmp	r2, #0
 8025bf2:	d03b      	beq.n	8025c6c <Endpoint_Write_Stream_LE+0x8c>
	{
		Length -= *BytesProcessed;
 8025bf4:	8817      	ldrh	r7, [r2, #0]
 8025bf6:	1be4      	subs	r4, r4, r7
 8025bf8:	b2a4      	uxth	r4, r4
		BytesTransfered = *BytesProcessed;
	}

	while (Length) 
	{
		if (ep->InInUse)
 8025bfa:	262c      	movs	r6, #44	; 0x2c
 8025bfc:	fb06 3601 	mla	r6, r6, r1, r3
	{
		Length -= *BytesProcessed;
		BytesTransfered = *BytesProcessed;
	}

	while (Length) 
 8025c00:	b1f4      	cbz	r4, 8025c40 <Endpoint_Write_Stream_LE+0x60>
	{
		if (ep->InInUse)
 8025c02:	68b3      	ldr	r3, [r6, #8]
 8025c04:	06db      	lsls	r3, r3, #27
 8025c06:	d4fc      	bmi.n	8025c02 <Endpoint_Write_Stream_LE+0x22>
		{
			continue;
		}
		if (Endpoint_IsReadWriteAllowed()) 
 8025c08:	f000 f93a 	bl	8025e80 <Endpoint_IsReadWriteAllowed>
 8025c0c:	b1f8      	cbz	r0, 8025c4e <Endpoint_Write_Stream_LE+0x6e>
		{
			if((ep->InBufferLength - ep->InBytesAvailable)  > Length)
 8025c0e:	6a75      	ldr	r5, [r6, #36]	; 0x24
 8025c10:	69f0      	ldr	r0, [r6, #28]
 8025c12:	1a2d      	subs	r5, r5, r0
 8025c14:	42a5      	cmp	r5, r4
 8025c16:	d816      	bhi.n	8025c46 <Endpoint_Write_Stream_LE+0x66>
			{
				Bytes = Length;
			}
			else
			{
				Bytes = (ep->InBufferLength - ep->InBytesAvailable);
 8025c18:	b2ad      	uxth	r5, r5
 8025c1a:	1b64      	subs	r4, r4, r5
 8025c1c:	fa1f fb84 	uxth.w	fp, r4
 8025c20:	462c      	mov	r4, r5
			}
			memcpy(ep->InBuffer + ep->InBytesAvailable,(uint8_t*)Buffer + BytesTransfered,Bytes);
 8025c22:	6a33      	ldr	r3, [r6, #32]
 8025c24:	eb08 0107 	add.w	r1, r8, r7
 8025c28:	462a      	mov	r2, r5
 8025c2a:	4418      	add	r0, r3
 8025c2c:	f008 ffbc 	bl	802eba8 <memcpy>
			ep->InBytesAvailable += Bytes;
 8025c30:	69f3      	ldr	r3, [r6, #28]
			BytesTransfered += Bytes;
 8025c32:	4427      	add	r7, r4
			else
			{
				Bytes = (ep->InBufferLength - ep->InBytesAvailable);
			}
			memcpy(ep->InBuffer + ep->InBytesAvailable,(uint8_t*)Buffer + BytesTransfered,Bytes);
			ep->InBytesAvailable += Bytes;
 8025c34:	441d      	add	r5, r3
			BytesTransfered += Bytes;
			Length -= Bytes;
 8025c36:	465c      	mov	r4, fp
			{
				Bytes = (ep->InBufferLength - ep->InBytesAvailable);
			}
			memcpy(ep->InBuffer + ep->InBytesAvailable,(uint8_t*)Buffer + BytesTransfered,Bytes);
			ep->InBytesAvailable += Bytes;
			BytesTransfered += Bytes;
 8025c38:	b2bf      	uxth	r7, r7
			else
			{
				Bytes = (ep->InBufferLength - ep->InBytesAvailable);
			}
			memcpy(ep->InBuffer + ep->InBytesAvailable,(uint8_t*)Buffer + BytesTransfered,Bytes);
			ep->InBytesAvailable += Bytes;
 8025c3a:	61f5      	str	r5, [r6, #28]
	{
		Length -= *BytesProcessed;
		BytesTransfered = *BytesProcessed;
	}

	while (Length) 
 8025c3c:	2c00      	cmp	r4, #0
 8025c3e:	d1e0      	bne.n	8025c02 <Endpoint_Write_Stream_LE+0x22>
				return ErrorCode;
			}
		}
	}
	
	return ENDPOINT_RWSTREAM_NoError;
 8025c40:	4620      	mov	r0, r4
}
 8025c42:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8025c46:	4625      	mov	r5, r4
 8025c48:	f04f 0b00 	mov.w	fp, #0
 8025c4c:	e7e9      	b.n	8025c22 <Endpoint_Write_Stream_LE+0x42>
			BytesTransfered += Bytes;
			Length -= Bytes;
		}
		else 
		{
			Endpoint_ClearIN();
 8025c4e:	f000 f8df 	bl	8025e10 <Endpoint_ClearIN>
			if(Length < ep->MaxPacketSize)
 8025c52:	8933      	ldrh	r3, [r6, #8]
 8025c54:	f3c3 1386 	ubfx	r3, r3, #6, #7
 8025c58:	429c      	cmp	r4, r3
 8025c5a:	da02      	bge.n	8025c62 <Endpoint_Write_Stream_LE+0x82>
			{
				if (BytesProcessed!=NULL) 
 8025c5c:	f1b9 0f00 	cmp.w	r9, #0
 8025c60:	d106      	bne.n	8025c70 <Endpoint_Write_Stream_LE+0x90>
					*BytesProcessed = BytesTransfered;
					return ENDPOINT_RWSTREAM_IncompleteTransfer;
				}
			}

			ErrorCode = Endpoint_WaitUntilReady();
 8025c62:	f000 f85d 	bl	8025d20 <Endpoint_WaitUntilReady>
			if (ErrorCode) 
 8025c66:	2800      	cmp	r0, #0
 8025c68:	d0ca      	beq.n	8025c00 <Endpoint_Write_Stream_LE+0x20>
 8025c6a:	e7ea      	b.n	8025c42 <Endpoint_Write_Stream_LE+0x62>
uint8_t Endpoint_Write_Stream_LE (const void *const Buffer, uint16_t Length,
											uint16_t *const BytesProcessed)
{
	USBD_Endpoint_t* ep = &device.Endpoints[device.CurrentEndpoint];
	uint16_t Bytes = 0;
	uint16_t BytesTransfered = 0;
 8025c6c:	4617      	mov	r7, r2
 8025c6e:	e7c4      	b.n	8025bfa <Endpoint_Write_Stream_LE+0x1a>
			Endpoint_ClearIN();
			if(Length < ep->MaxPacketSize)
			{
				if (BytesProcessed!=NULL) 
				{
					*BytesProcessed = BytesTransfered;
 8025c70:	f8a9 7000 	strh.w	r7, [r9]
					return ENDPOINT_RWSTREAM_IncompleteTransfer;
 8025c74:	2005      	movs	r0, #5
 8025c76:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8025c7a:	bf00      	nop
 8025c7c:	2000d8f4 	.word	0x2000d8f4

08025c80 <Endpoint_Read_Stream_LE>:
	return ENDPOINT_RWSTREAM_NoError;
}

uint8_t	Endpoint_Read_Stream_LE (void *const Buffer, uint16_t Length,
									uint16_t *const BytesProcessed)
{
 8025c80:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	USBD_Endpoint_t* ep = &device.Endpoints[device.CurrentEndpoint];
 8025c84:	4b25      	ldr	r3, [pc, #148]	; (8025d1c <Endpoint_Read_Stream_LE+0x9c>)
	return ENDPOINT_RWSTREAM_NoError;
}

uint8_t	Endpoint_Read_Stream_LE (void *const Buffer, uint16_t Length,
									uint16_t *const BytesProcessed)
{
 8025c86:	460c      	mov	r4, r1
 8025c88:	4681      	mov	r9, r0
	USBD_Endpoint_t* ep = &device.Endpoints[device.CurrentEndpoint];
 8025c8a:	f893 113c 	ldrb.w	r1, [r3, #316]	; 0x13c
	uint16_t Bytes = 0;
	uint16_t BytesTransfered = 0;
	uint8_t ErrorCode;

	if (BytesProcessed!=NULL) 
 8025c8e:	4692      	mov	sl, r2
 8025c90:	2a00      	cmp	r2, #0
 8025c92:	d03b      	beq.n	8025d0c <Endpoint_Read_Stream_LE+0x8c>
	{
		Length -= *BytesProcessed;
 8025c94:	f8b2 8000 	ldrh.w	r8, [r2]
 8025c98:	ebc8 0404 	rsb	r4, r8, r4
 8025c9c:	b2a4      	uxth	r4, r4
		BytesTransfered = *BytesProcessed;
	}

	while (Length) 
	{
		if (ep->OutInUse)
 8025c9e:	252c      	movs	r5, #44	; 0x2c
 8025ca0:	fb05 3501 	mla	r5, r5, r1, r3
	{
		Length -= *BytesProcessed;
		BytesTransfered = *BytesProcessed;
	}

	while (Length) 
 8025ca4:	b30c      	cbz	r4, 8025cea <Endpoint_Read_Stream_LE+0x6a>
	{
		if (ep->OutInUse)
 8025ca6:	68ab      	ldr	r3, [r5, #8]
 8025ca8:	071b      	lsls	r3, r3, #28
 8025caa:	d4fc      	bmi.n	8025ca6 <Endpoint_Read_Stream_LE+0x26>
		{
			continue;
		}
		if (Endpoint_IsReadWriteAllowed()) 
 8025cac:	f000 f8e8 	bl	8025e80 <Endpoint_IsReadWriteAllowed>
 8025cb0:	b310      	cbz	r0, 8025cf8 <Endpoint_Read_Stream_LE+0x78>
		{
			if(ep->OutBytesAvailable  > Length)
 8025cb2:	68ee      	ldr	r6, [r5, #12]
 8025cb4:	42a6      	cmp	r6, r4
 8025cb6:	d81b      	bhi.n	8025cf0 <Endpoint_Read_Stream_LE+0x70>
			{
				Bytes = Length;
			}
			else
			{
				Bytes = (uint16_t)ep->OutBytesAvailable;
 8025cb8:	b2b3      	uxth	r3, r6
 8025cba:	1ae4      	subs	r4, r4, r3
 8025cbc:	fa1f fb84 	uxth.w	fp, r4
 8025cc0:	461c      	mov	r4, r3
			}

			memcpy((uint8_t*)Buffer + BytesTransfered,
									ep->OutBuffer + ep->OutOffset,Bytes);
 8025cc2:	692b      	ldr	r3, [r5, #16]
 8025cc4:	6969      	ldr	r1, [r5, #20]
			else
			{
				Bytes = (uint16_t)ep->OutBytesAvailable;
			}

			memcpy((uint8_t*)Buffer + BytesTransfered,
 8025cc6:	4632      	mov	r2, r6
 8025cc8:	eb09 0008 	add.w	r0, r9, r8
 8025ccc:	4419      	add	r1, r3
 8025cce:	f008 ff6b 	bl	802eba8 <memcpy>
									ep->OutBuffer + ep->OutOffset,Bytes);
			ep->OutBytesAvailable -= Bytes;
 8025cd2:	68ea      	ldr	r2, [r5, #12]
			ep->OutOffset += Bytes;
 8025cd4:	692b      	ldr	r3, [r5, #16]
			BytesTransfered += Bytes;
 8025cd6:	44a0      	add	r8, r4
				Bytes = (uint16_t)ep->OutBytesAvailable;
			}

			memcpy((uint8_t*)Buffer + BytesTransfered,
									ep->OutBuffer + ep->OutOffset,Bytes);
			ep->OutBytesAvailable -= Bytes;
 8025cd8:	1b92      	subs	r2, r2, r6
			ep->OutOffset += Bytes;
			BytesTransfered += Bytes;
			Length -= Bytes;
 8025cda:	465c      	mov	r4, fp
			}

			memcpy((uint8_t*)Buffer + BytesTransfered,
									ep->OutBuffer + ep->OutOffset,Bytes);
			ep->OutBytesAvailable -= Bytes;
			ep->OutOffset += Bytes;
 8025cdc:	441e      	add	r6, r3
			BytesTransfered += Bytes;
 8025cde:	fa1f f888 	uxth.w	r8, r8
				Bytes = (uint16_t)ep->OutBytesAvailable;
			}

			memcpy((uint8_t*)Buffer + BytesTransfered,
									ep->OutBuffer + ep->OutOffset,Bytes);
			ep->OutBytesAvailable -= Bytes;
 8025ce2:	60ea      	str	r2, [r5, #12]
			ep->OutOffset += Bytes;
 8025ce4:	612e      	str	r6, [r5, #16]
	{
		Length -= *BytesProcessed;
		BytesTransfered = *BytesProcessed;
	}

	while (Length) 
 8025ce6:	2c00      	cmp	r4, #0
 8025ce8:	d1dd      	bne.n	8025ca6 <Endpoint_Read_Stream_LE+0x26>
			{
				return ErrorCode;
			}
		}
	}
	return ENDPOINT_RWSTREAM_NoError;
 8025cea:	4620      	mov	r0, r4
}
 8025cec:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8025cf0:	4626      	mov	r6, r4
 8025cf2:	f04f 0b00 	mov.w	fp, #0
 8025cf6:	e7e4      	b.n	8025cc2 <Endpoint_Read_Stream_LE+0x42>
			BytesTransfered += Bytes;
			Length -= Bytes;
		}
		else 
		{
			Endpoint_ClearOUT();
 8025cf8:	f000 f85e 	bl	8025db8 <Endpoint_ClearOUT>
			if (BytesProcessed != NULL) 
 8025cfc:	f1ba 0f00 	cmp.w	sl, #0
 8025d00:	d106      	bne.n	8025d10 <Endpoint_Read_Stream_LE+0x90>
			{
				*BytesProcessed = BytesTransfered;
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			ErrorCode = Endpoint_WaitUntilReady();
 8025d02:	f000 f80d 	bl	8025d20 <Endpoint_WaitUntilReady>
			if (ErrorCode) 
 8025d06:	2800      	cmp	r0, #0
 8025d08:	d0cc      	beq.n	8025ca4 <Endpoint_Read_Stream_LE+0x24>
 8025d0a:	e7ef      	b.n	8025cec <Endpoint_Read_Stream_LE+0x6c>
uint8_t	Endpoint_Read_Stream_LE (void *const Buffer, uint16_t Length,
									uint16_t *const BytesProcessed)
{
	USBD_Endpoint_t* ep = &device.Endpoints[device.CurrentEndpoint];
	uint16_t Bytes = 0;
	uint16_t BytesTransfered = 0;
 8025d0c:	4690      	mov	r8, r2
 8025d0e:	e7c6      	b.n	8025c9e <Endpoint_Read_Stream_LE+0x1e>
		else 
		{
			Endpoint_ClearOUT();
			if (BytesProcessed != NULL) 
			{
				*BytesProcessed = BytesTransfered;
 8025d10:	f8aa 8000 	strh.w	r8, [sl]
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
 8025d14:	2005      	movs	r0, #5
 8025d16:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8025d1a:	bf00      	nop
 8025d1c:	2000d8f4 	.word	0x2000d8f4

08025d20 <Endpoint_WaitUntilReady>:

#define USB_STREAM_TIMEOUT_MS 100


uint8_t Endpoint_WaitUntilReady(void)
{
 8025d20:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 *
 *  \return Current USB frame number from the USB controller.
 */
static inline uint16_t USB_Device_GetFrameNumber(void);
static inline uint16_t USB_Device_GetFrameNumber() {
	return device.Driver->GetFrameNumber();
 8025d24:	4c22      	ldr	r4, [pc, #136]	; (8025db0 <Endpoint_WaitUntilReady+0x90>)
			{
			  return ENDPOINT_READYWAIT_NoError;
			}
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
 8025d26:	4d23      	ldr	r5, [pc, #140]	; (8025db4 <Endpoint_WaitUntilReady+0x94>)
 8025d28:	6823      	ldr	r3, [r4, #0]
 8025d2a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8025d2c:	4798      	blx	r3
	 */
	static inline bool Endpoint_IsStalled(void);
	static inline bool Endpoint_IsStalled(void)
	{
		bool status = false;
		if(device.Endpoints[device.CurrentEndpoint].IsHalted == 1)
 8025d2e:	46a1      	mov	r9, r4
 8025d30:	4680      	mov	r8, r0


uint8_t Endpoint_WaitUntilReady(void)
{
	#if (USB_STREAM_TIMEOUT_MS < 0xFF)
	uint8_t  TimeoutMSRem = USB_STREAM_TIMEOUT_MS;
 8025d32:	2664      	movs	r6, #100	; 0x64
	 */
	static inline uint8_t Endpoint_GetEndpointDirection(void);
	static inline uint8_t Endpoint_GetEndpointDirection(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->Address & ENDPOINT_DIR_MASK;
 8025d34:	272c      	movs	r7, #44	; 0x2c
	 *  \c ENDPOINT_DIR_* mask.
	 */
	static inline uint8_t Endpoint_GetEndpointDirection(void);
	static inline uint8_t Endpoint_GetEndpointDirection(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
 8025d36:	f894 313c 	ldrb.w	r3, [r4, #316]	; 0x13c
		return ep->Address & ENDPOINT_DIR_MASK;
 8025d3a:	fb07 4203 	mla	r2, r7, r3, r4
 8025d3e:	7911      	ldrb	r1, [r2, #4]

	uint16_t PreviousFrameNumber = USB_Device_GetFrameNumber();

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
 8025d40:	0608      	lsls	r0, r1, #24
 8025d42:	d41a      	bmi.n	8025d7a <Endpoint_WaitUntilReady+0x5a>
	 */
	static inline bool Endpoint_IsOUTReceived(void);
	static inline bool Endpoint_IsOUTReceived(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->IsOutRecieved;
 8025d44:	6892      	ldr	r2, [r2, #8]
			  return ENDPOINT_READYWAIT_NoError;
			}
		}
		else
		{
			if (Endpoint_IsOUTReceived())
 8025d46:	0692      	lsls	r2, r2, #26
 8025d48:	d42b      	bmi.n	8025da2 <Endpoint_WaitUntilReady+0x82>
			{
			  return ENDPOINT_READYWAIT_NoError;
			}
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
 8025d4a:	782a      	ldrb	r2, [r5, #0]

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
 8025d4c:	f002 01ff 	and.w	r1, r2, #255	; 0xff
 8025d50:	b322      	cbz	r2, 8025d9c <Endpoint_WaitUntilReady+0x7c>
		{
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		}
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
 8025d52:	2905      	cmp	r1, #5
 8025d54:	d01f      	beq.n	8025d96 <Endpoint_WaitUntilReady+0x76>
	 */
	static inline bool Endpoint_IsStalled(void);
	static inline bool Endpoint_IsStalled(void)
	{
		bool status = false;
		if(device.Endpoints[device.CurrentEndpoint].IsHalted == 1)
 8025d56:	fb07 4303 	mla	r3, r7, r3, r4
 8025d5a:	6898      	ldr	r0, [r3, #8]
 8025d5c:	f3c0 0080 	ubfx	r0, r0, #2, #1
 8025d60:	b9a8      	cbnz	r0, 8025d8e <Endpoint_WaitUntilReady+0x6e>
 8025d62:	f8d9 3000 	ldr.w	r3, [r9]
 8025d66:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8025d68:	4798      	blx	r3
		  return ENDPOINT_READYWAIT_EndpointStalled;
		}

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
 8025d6a:	4580      	cmp	r8, r0
 8025d6c:	d011      	beq.n	8025d92 <Endpoint_WaitUntilReady+0x72>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
 8025d6e:	1e73      	subs	r3, r6, #1
 8025d70:	b2db      	uxtb	r3, r3
 8025d72:	b1ce      	cbz	r6, 8025da8 <Endpoint_WaitUntilReady+0x88>
 8025d74:	4680      	mov	r8, r0
 8025d76:	461e      	mov	r6, r3
 8025d78:	e7dd      	b.n	8025d36 <Endpoint_WaitUntilReady+0x16>
	 */
	static inline bool Endpoint_IsINReady(void);
	static inline bool Endpoint_IsINReady(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->InInUse == 0 && ep->IsEnabled;
 8025d7a:	6890      	ldr	r0, [r2, #8]
 8025d7c:	f3c0 1000 	ubfx	r0, r0, #4, #1
 8025d80:	2800      	cmp	r0, #0
 8025d82:	d1e2      	bne.n	8025d4a <Endpoint_WaitUntilReady+0x2a>
 8025d84:	6892      	ldr	r2, [r2, #8]
 8025d86:	0791      	lsls	r1, r2, #30
 8025d88:	d5df      	bpl.n	8025d4a <Endpoint_WaitUntilReady+0x2a>
			{
			  return ENDPOINT_READYWAIT_Timeout;
			}
		}
	}
}
 8025d8a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8025d8e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8025d92:	4633      	mov	r3, r6
 8025d94:	e7ee      	b.n	8025d74 <Endpoint_WaitUntilReady+0x54>
		{
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		}
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		{
		  return ENDPOINT_READYWAIT_BusSuspended;
 8025d96:	2003      	movs	r0, #3
 8025d98:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		{
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
 8025d9c:	2002      	movs	r0, #2
 8025d9e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			{
			  return ENDPOINT_READYWAIT_NoError;
 8025da2:	2000      	movs	r0, #0
 8025da4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
			{
			  return ENDPOINT_READYWAIT_Timeout;
 8025da8:	2004      	movs	r0, #4
 8025daa:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8025dae:	bf00      	nop
 8025db0:	2000d8f4 	.word	0x2000d8f4
 8025db4:	2000d6e9 	.word	0x2000d6e9

08025db8 <Endpoint_ClearOUT>:
		}
	}
}

void Endpoint_ClearOUT(void) 
{
 8025db8:	b570      	push	{r4, r5, r6, lr}
	USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
 8025dba:	4d14      	ldr	r5, [pc, #80]	; (8025e0c <Endpoint_ClearOUT+0x54>)
 8025dbc:	f895 313c 	ldrb.w	r3, [r5, #316]	; 0x13c
	/* if we have data left which isn't read yet, we leave this routine to
	 * not override it */
	if (ep->IsEnabled == 0)
 8025dc0:	242c      	movs	r4, #44	; 0x2c
 8025dc2:	fb04 5403 	mla	r4, r4, r3, r5
 8025dc6:	68a3      	ldr	r3, [r4, #8]
 8025dc8:	079a      	lsls	r2, r3, #30
 8025dca:	d400      	bmi.n	8025dce <Endpoint_ClearOUT+0x16>
 8025dcc:	bd70      	pop	{r4, r5, r6, pc}
	{
		return;
	}
	/* First Check whether we have data in the driver */
	ep->OutBytesAvailable = device.Driver->EndpointRead(ep->Address,ep->OutBuffer,ep->OutBufferLength);
 8025dce:	682b      	ldr	r3, [r5, #0]
 8025dd0:	6961      	ldr	r1, [r4, #20]
 8025dd2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8025dd4:	69a2      	ldr	r2, [r4, #24]
 8025dd6:	7920      	ldrb	r0, [r4, #4]
 8025dd8:	4798      	blx	r3
	ep->OutOffset = 0;
	/* If we didn't request new data and all data has been read, request new */
	if (!ep->OutInUse && !ep->OutBytesAvailable) 
 8025dda:	68a3      	ldr	r3, [r4, #8]
	if (ep->IsEnabled == 0)
	{
		return;
	}
	/* First Check whether we have data in the driver */
	ep->OutBytesAvailable = device.Driver->EndpointRead(ep->Address,ep->OutBuffer,ep->OutBufferLength);
 8025ddc:	60e0      	str	r0, [r4, #12]
	ep->OutOffset = 0;
 8025dde:	2100      	movs	r1, #0
	/* If we didn't request new data and all data has been read, request new */
	if (!ep->OutInUse && !ep->OutBytesAvailable) 
 8025de0:	071b      	lsls	r3, r3, #28
	if (ep->IsEnabled == 0)
	{
		return;
	}
	/* First Check whether we have data in the driver */
	ep->OutBytesAvailable = device.Driver->EndpointRead(ep->Address,ep->OutBuffer,ep->OutBufferLength);
 8025de2:	4602      	mov	r2, r0
	ep->OutOffset = 0;
 8025de4:	6121      	str	r1, [r4, #16]
	/* If we didn't request new data and all data has been read, request new */
	if (!ep->OutInUse && !ep->OutBytesAvailable) 
 8025de6:	d4f1      	bmi.n	8025dcc <Endpoint_ClearOUT+0x14>
 8025de8:	2800      	cmp	r0, #0
 8025dea:	d1ef      	bne.n	8025dcc <Endpoint_ClearOUT+0x14>
	{
		ep->OutInUse = true;
 8025dec:	8923      	ldrh	r3, [r4, #8]
		ep->IsOutRecieved = 0;
		device.Driver->EndpointReadStart(ep->Address,ep->OutBufferLength);
 8025dee:	7920      	ldrb	r0, [r4, #4]
 8025df0:	69a1      	ldr	r1, [r4, #24]
	ep->OutBytesAvailable = device.Driver->EndpointRead(ep->Address,ep->OutBuffer,ep->OutBufferLength);
	ep->OutOffset = 0;
	/* If we didn't request new data and all data has been read, request new */
	if (!ep->OutInUse && !ep->OutBytesAvailable) 
	{
		ep->OutInUse = true;
 8025df2:	f043 0308 	orr.w	r3, r3, #8
 8025df6:	8123      	strh	r3, [r4, #8]
		ep->IsOutRecieved = 0;
 8025df8:	8923      	ldrh	r3, [r4, #8]
 8025dfa:	f362 1345 	bfi	r3, r2, #5, #1
 8025dfe:	8123      	strh	r3, [r4, #8]
		device.Driver->EndpointReadStart(ep->Address,ep->OutBufferLength);
 8025e00:	682b      	ldr	r3, [r5, #0]
	}
}
 8025e02:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	/* If we didn't request new data and all data has been read, request new */
	if (!ep->OutInUse && !ep->OutBytesAvailable) 
	{
		ep->OutInUse = true;
		ep->IsOutRecieved = 0;
		device.Driver->EndpointReadStart(ep->Address,ep->OutBufferLength);
 8025e06:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8025e08:	4718      	bx	r3
 8025e0a:	bf00      	nop
 8025e0c:	2000d8f4 	.word	0x2000d8f4

08025e10 <Endpoint_ClearIN>:
	}
}

void Endpoint_ClearIN(void)
{
 8025e10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
 8025e12:	4919      	ldr	r1, [pc, #100]	; (8025e78 <Endpoint_ClearIN+0x68>)
 8025e14:	f891 313c 	ldrb.w	r3, [r1, #316]	; 0x13c
	int32_t data_count;
	/* don't clear if in use or not enabled */
	if (ep->InInUse == 1 || ep->IsEnabled == 0)
 8025e18:	222c      	movs	r2, #44	; 0x2c
 8025e1a:	fb02 1303 	mla	r3, r2, r3, r1
 8025e1e:	689a      	ldr	r2, [r3, #8]
 8025e20:	06d0      	lsls	r0, r2, #27
 8025e22:	d402      	bmi.n	8025e2a <Endpoint_ClearIN+0x1a>
 8025e24:	689a      	ldr	r2, [r3, #8]
 8025e26:	0792      	lsls	r2, r2, #30
 8025e28:	d400      	bmi.n	8025e2c <Endpoint_ClearIN+0x1c>
 8025e2a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return;
	ep->InInUse = true;
 8025e2c:	8918      	ldrh	r0, [r3, #8]
	/* store transfer information to loop over, if underlying is smaller */
	ep->InDataBuffer = ep->InBuffer;
 8025e2e:	6a1f      	ldr	r7, [r3, #32]
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8025e30:	4e12      	ldr	r6, [pc, #72]	; (8025e7c <Endpoint_ClearIN+0x6c>)
	USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
	int32_t data_count;
	/* don't clear if in use or not enabled */
	if (ep->InInUse == 1 || ep->IsEnabled == 0)
		return;
	ep->InInUse = true;
 8025e32:	f040 0010 	orr.w	r0, r0, #16
	/* store transfer information to loop over, if underlying is smaller */
	ep->InDataBuffer = ep->InBuffer;
 8025e36:	f103 0528 	add.w	r5, r3, #40	; 0x28
	ep->InDataLeft = ep->InBytesAvailable;
 8025e3a:	f103 0420 	add.w	r4, r3, #32
	USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
	int32_t data_count;
	/* don't clear if in use or not enabled */
	if (ep->InInUse == 1 || ep->IsEnabled == 0)
		return;
	ep->InInUse = true;
 8025e3e:	8118      	strh	r0, [r3, #8]
	/* store transfer information to loop over, if underlying is smaller */
	ep->InDataBuffer = ep->InBuffer;
	ep->InDataLeft = ep->InBytesAvailable;
 8025e40:	69d8      	ldr	r0, [r3, #28]
 8025e42:	60a0      	str	r0, [r4, #8]
	/* don't clear if in use or not enabled */
	if (ep->InInUse == 1 || ep->IsEnabled == 0)
		return;
	ep->InInUse = true;
	/* store transfer information to loop over, if underlying is smaller */
	ep->InDataBuffer = ep->InBuffer;
 8025e44:	606f      	str	r7, [r5, #4]
	ep->InDataLeft = ep->InBytesAvailable;
	ep->InBytesAvailable = 0;
 8025e46:	2000      	movs	r0, #0
 8025e48:	f44f 6700 	mov.w	r7, #2048	; 0x800
 8025e4c:	61d8      	str	r0, [r3, #28]
 8025e4e:	f8c6 708c 	str.w	r7, [r6, #140]	; 0x8c
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8025e52:	f3bf 8f4f 	dsb	sy
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 8025e56:	f3bf 8f6f 	isb	sy
	/* make next 3 operations atomic. Do not get interrupted.*/
	NVIC_DisableIRQ(USB0_0_IRQn);
	data_count = device.Driver->EndpointWrite(ep->Address,
 8025e5a:	680a      	ldr	r2, [r1, #0]
 8025e5c:	7918      	ldrb	r0, [r3, #4]
 8025e5e:	6869      	ldr	r1, [r5, #4]
 8025e60:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8025e62:	68a2      	ldr	r2, [r4, #8]
 8025e64:	4798      	blx	r3
			ep->InDataBuffer,ep->InDataLeft);
	ep->InDataBuffer += data_count;
 8025e66:	686a      	ldr	r2, [r5, #4]
	ep->InDataLeft -= data_count;
 8025e68:	68a3      	ldr	r3, [r4, #8]
	ep->InBytesAvailable = 0;
	/* make next 3 operations atomic. Do not get interrupted.*/
	NVIC_DisableIRQ(USB0_0_IRQn);
	data_count = device.Driver->EndpointWrite(ep->Address,
			ep->InDataBuffer,ep->InDataLeft);
	ep->InDataBuffer += data_count;
 8025e6a:	4402      	add	r2, r0
	ep->InDataLeft -= data_count;
 8025e6c:	1a1b      	subs	r3, r3, r0
	ep->InBytesAvailable = 0;
	/* make next 3 operations atomic. Do not get interrupted.*/
	NVIC_DisableIRQ(USB0_0_IRQn);
	data_count = device.Driver->EndpointWrite(ep->Address,
			ep->InDataBuffer,ep->InDataLeft);
	ep->InDataBuffer += data_count;
 8025e6e:	606a      	str	r2, [r5, #4]
	ep->InDataLeft -= data_count;
 8025e70:	60a3      	str	r3, [r4, #8]
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8025e72:	60f7      	str	r7, [r6, #12]
 8025e74:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8025e76:	bf00      	nop
 8025e78:	2000d8f4 	.word	0x2000d8f4
 8025e7c:	e000e100 	.word	0xe000e100

08025e80 <Endpoint_IsReadWriteAllowed>:
	NVIC_EnableIRQ(USB0_0_IRQn);

}

bool Endpoint_IsReadWriteAllowed() {
	USBD_Endpoint_t *EndPoint = &device.Endpoints[device.CurrentEndpoint];
 8025e80:	4b0a      	ldr	r3, [pc, #40]	; (8025eac <Endpoint_IsReadWriteAllowed+0x2c>)
 8025e82:	f893 213c 	ldrb.w	r2, [r3, #316]	; 0x13c
	bool Retval = false;

	if(EndPoint->Direction)
 8025e86:	212c      	movs	r1, #44	; 0x2c
 8025e88:	fb01 3302 	mla	r3, r1, r2, r3
 8025e8c:	791a      	ldrb	r2, [r3, #4]
 8025e8e:	0612      	lsls	r2, r2, #24
 8025e90:	d404      	bmi.n	8025e9c <Endpoint_IsReadWriteAllowed+0x1c>
		Retval = (EndPoint->InBytesAvailable < EndPoint->InBufferLength)
														? true : false;
	}
	else
	{
		Retval = (EndPoint->OutBytesAvailable > 0) ? true : false;
 8025e92:	68d8      	ldr	r0, [r3, #12]
 8025e94:	3000      	adds	r0, #0
 8025e96:	bf18      	it	ne
 8025e98:	2001      	movne	r0, #1
	}
	return Retval;
}
 8025e9a:	4770      	bx	lr
	USBD_Endpoint_t *EndPoint = &device.Endpoints[device.CurrentEndpoint];
	bool Retval = false;

	if(EndPoint->Direction)
	{
		Retval = (EndPoint->InBytesAvailable < EndPoint->InBufferLength)
 8025e9c:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8025e9e:	69da      	ldr	r2, [r3, #28]
 8025ea0:	4282      	cmp	r2, r0
 8025ea2:	bf2c      	ite	cs
 8025ea4:	2000      	movcs	r0, #0
 8025ea6:	2001      	movcc	r0, #1
 8025ea8:	4770      	bx	lr
 8025eaa:	bf00      	nop
 8025eac:	2000d8f4 	.word	0x2000d8f4

08025eb0 <Endpoint_Write_8>:
	}
	return Retval;
}

void Endpoint_Write_8(const uint8_t Data) {
	USBD_Endpoint_t *EndPoint = &device.Endpoints[device.CurrentEndpoint];
 8025eb0:	4a09      	ldr	r2, [pc, #36]	; (8025ed8 <Endpoint_Write_8+0x28>)
 8025eb2:	f892 313c 	ldrb.w	r3, [r2, #316]	; 0x13c
 8025eb6:	212c      	movs	r1, #44	; 0x2c
 8025eb8:	fb01 2203 	mla	r2, r1, r3, r2
 8025ebc:	f102 0318 	add.w	r3, r2, #24
 8025ec0:	6a51      	ldr	r1, [r2, #36]	; 0x24
 8025ec2:	685a      	ldr	r2, [r3, #4]
 8025ec4:	428a      	cmp	r2, r1
 8025ec6:	d300      	bcc.n	8025eca <Endpoint_Write_8+0x1a>
 8025ec8:	e7fe      	b.n	8025ec8 <Endpoint_Write_8+0x18>

	 do
	  {
	    if(EndPoint->InBytesAvailable < EndPoint->InBufferLength)
	    {
	      EndPoint->InBuffer[EndPoint->InBytesAvailable] = Data;
 8025eca:	6899      	ldr	r1, [r3, #8]
 8025ecc:	5488      	strb	r0, [r1, r2]
	      EndPoint->InBytesAvailable++;
 8025ece:	685a      	ldr	r2, [r3, #4]
 8025ed0:	3201      	adds	r2, #1
 8025ed2:	605a      	str	r2, [r3, #4]
 8025ed4:	4770      	bx	lr
 8025ed6:	bf00      	nop
 8025ed8:	2000d8f4 	.word	0x2000d8f4

08025edc <Endpoint_Read_8>:
	    }
	  }while(!Success);
}

uint8_t Endpoint_Read_8() {
	USBD_Endpoint_t *EndPoint = &device.Endpoints[device.CurrentEndpoint];
 8025edc:	4b09      	ldr	r3, [pc, #36]	; (8025f04 <Endpoint_Read_8+0x28>)
 8025ede:	f893 213c 	ldrb.w	r2, [r3, #316]	; 0x13c
 8025ee2:	212c      	movs	r1, #44	; 0x2c
 8025ee4:	fb01 3302 	mla	r3, r1, r2, r3
 8025ee8:	f103 0208 	add.w	r2, r3, #8
 8025eec:	6851      	ldr	r1, [r2, #4]
 8025eee:	b901      	cbnz	r1, 8025ef2 <Endpoint_Read_8+0x16>
 8025ef0:	e7fe      	b.n	8025ef0 <Endpoint_Read_8+0x14>

	 do
	  {
		if(EndPoint->OutBytesAvailable > 0)
		{
		  data = EndPoint->OutBuffer[EndPoint->OutOffset];
 8025ef2:	6958      	ldr	r0, [r3, #20]
 8025ef4:	6893      	ldr	r3, [r2, #8]
		  EndPoint->OutOffset++;
		  EndPoint->OutBytesAvailable--;
 8025ef6:	3901      	subs	r1, #1

	 do
	  {
		if(EndPoint->OutBytesAvailable > 0)
		{
		  data = EndPoint->OutBuffer[EndPoint->OutOffset];
 8025ef8:	5cc0      	ldrb	r0, [r0, r3]
		  EndPoint->OutOffset++;
		  EndPoint->OutBytesAvailable--;
 8025efa:	6051      	str	r1, [r2, #4]
	 do
	  {
		if(EndPoint->OutBytesAvailable > 0)
		{
		  data = EndPoint->OutBuffer[EndPoint->OutOffset];
		  EndPoint->OutOffset++;
 8025efc:	3301      	adds	r3, #1
 8025efe:	6093      	str	r3, [r2, #8]

		  Success = true;
		}
	  }while(!Success);
	 return data;
}
 8025f00:	4770      	bx	lr
 8025f02:	bf00      	nop
 8025f04:	2000d8f4 	.word	0x2000d8f4

08025f08 <Endpoint_Write_32_LE>:

void Endpoint_Write_32_LE(const uint32_t Data) {
	USBD_Endpoint_t *EndPoint = &device.Endpoints[device.CurrentEndpoint];
 8025f08:	4a09      	ldr	r2, [pc, #36]	; (8025f30 <Endpoint_Write_32_LE+0x28>)
 8025f0a:	f892 313c 	ldrb.w	r3, [r2, #316]	; 0x13c
 8025f0e:	212c      	movs	r1, #44	; 0x2c
 8025f10:	fb01 2203 	mla	r2, r1, r3, r2
 8025f14:	f102 0318 	add.w	r3, r2, #24
 8025f18:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8025f1a:	6859      	ldr	r1, [r3, #4]
 8025f1c:	3a03      	subs	r2, #3
 8025f1e:	4291      	cmp	r1, r2
 8025f20:	d300      	bcc.n	8025f24 <Endpoint_Write_32_LE+0x1c>
 8025f22:	e7fe      	b.n	8025f22 <Endpoint_Write_32_LE+0x1a>
	bool Success = false;

	do {
		if(EndPoint->InBytesAvailable < (EndPoint->InBufferLength - 3)) {
			*(uint32_t*)(EndPoint->InBuffer + EndPoint->InBytesAvailable) =
 8025f24:	689a      	ldr	r2, [r3, #8]
 8025f26:	5050      	str	r0, [r2, r1]
																		Data;
			EndPoint->InBytesAvailable+=4;
 8025f28:	685a      	ldr	r2, [r3, #4]
 8025f2a:	3204      	adds	r2, #4
 8025f2c:	605a      	str	r2, [r3, #4]
 8025f2e:	4770      	bx	lr
 8025f30:	2000d8f4 	.word	0x2000d8f4

08025f34 <Endpoint_Read_32_LE>:
		}
	}while(!Success);
}

uint32_t Endpoint_Read_32_LE() {
	USBD_Endpoint_t *EndPoint = &device.Endpoints[device.CurrentEndpoint];
 8025f34:	4b09      	ldr	r3, [pc, #36]	; (8025f5c <Endpoint_Read_32_LE+0x28>)
 8025f36:	f893 213c 	ldrb.w	r2, [r3, #316]	; 0x13c
 8025f3a:	212c      	movs	r1, #44	; 0x2c
 8025f3c:	fb01 3302 	mla	r3, r1, r2, r3
 8025f40:	f103 0208 	add.w	r2, r3, #8
 8025f44:	6851      	ldr	r1, [r2, #4]
 8025f46:	2903      	cmp	r1, #3
 8025f48:	d800      	bhi.n	8025f4c <Endpoint_Read_32_LE+0x18>
 8025f4a:	e7fe      	b.n	8025f4a <Endpoint_Read_32_LE+0x16>
	bool Success = false;
	uint32_t data = 0;

	do {
		if(EndPoint->OutBytesAvailable > 3) {
			data = *(uint32_t*)(EndPoint->OutBuffer + EndPoint->OutOffset);
 8025f4c:	6958      	ldr	r0, [r3, #20]
 8025f4e:	6893      	ldr	r3, [r2, #8]
			EndPoint->OutOffset+=4;
			EndPoint->OutBytesAvailable-=4;
 8025f50:	3904      	subs	r1, #4
	bool Success = false;
	uint32_t data = 0;

	do {
		if(EndPoint->OutBytesAvailable > 3) {
			data = *(uint32_t*)(EndPoint->OutBuffer + EndPoint->OutOffset);
 8025f52:	58c0      	ldr	r0, [r0, r3]
			EndPoint->OutOffset+=4;
			EndPoint->OutBytesAvailable-=4;
 8025f54:	6051      	str	r1, [r2, #4]
	uint32_t data = 0;

	do {
		if(EndPoint->OutBytesAvailable > 3) {
			data = *(uint32_t*)(EndPoint->OutBuffer + EndPoint->OutOffset);
			EndPoint->OutOffset+=4;
 8025f56:	3304      	adds	r3, #4
 8025f58:	6093      	str	r3, [r2, #8]

			Success = true;
		}
	} while(!Success);
	return data;
}
 8025f5a:	4770      	bx	lr
 8025f5c:	2000d8f4 	.word	0x2000d8f4

08025f60 <Endpoint_ConfigureEndpointTable>:

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
			                                     const uint8_t Entries) {
	uint8_t i;
	uint8_t Number;
	for (i=0;i<Entries;i++) {
 8025f60:	2900      	cmp	r1, #0
 8025f62:	d042      	beq.n	8025fea <Endpoint_ConfigureEndpointTable+0x8a>
	} while(!Success);
	return data;
}

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
			                                     const uint8_t Entries) {
 8025f64:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8025f68:	1e4d      	subs	r5, r1, #1
 8025f6a:	b2e9      	uxtb	r1, r5
 8025f6c:	4f20      	ldr	r7, [pc, #128]	; (8025ff0 <Endpoint_ConfigureEndpointTable+0x90>)
 8025f6e:	2506      	movs	r5, #6
 8025f70:	fb05 0501 	mla	r5, r5, r1, r0
 8025f74:	350a      	adds	r5, #10
 8025f76:	f100 0904 	add.w	r9, r0, #4
	uint8_t i;
	uint8_t Number;
	for (i=0;i<Entries;i++) {
		Number = Table[i].Address & ENDPOINT_EPNUM_MASK;
		/* Configure endpoint in device controller driver */
		if (device.Driver->EndpointConfigure(Table[i].Address,
 8025f7a:	463e      	mov	r6, r7
				(XMC_USBD_ENDPOINT_TYPE_t)Table[i].Type,Table[i].Size) !=
																XMC_USBD_STATUS_OK)
			return false;
		/* Set device core values */
		device.Endpoints[Number].Address = Table[i].Address;
 8025f7c:	f04f 082c 	mov.w	r8, #44	; 0x2c
 8025f80:	e01c      	b.n	8025fbc <Endpoint_ConfigureEndpointTable+0x5c>
 8025f82:	f819 2c04 	ldrb.w	r2, [r9, #-4]
 8025f86:	711a      	strb	r2, [r3, #4]
		device.Endpoints[Number].MaxPacketSize = Table[i].Size;
 8025f88:	f839 2c02 	ldrh.w	r2, [r9, #-2]
 8025f8c:	8919      	ldrh	r1, [r3, #8]
 8025f8e:	f362 118c 	bfi	r1, r2, #6, #7
		device.Endpoints[Number].IsConfigured = 1;
 8025f92:	b2ca      	uxtb	r2, r1
 8025f94:	f042 0201 	orr.w	r2, r2, #1
				(XMC_USBD_ENDPOINT_TYPE_t)Table[i].Type,Table[i].Size) !=
																XMC_USBD_STATUS_OK)
			return false;
		/* Set device core values */
		device.Endpoints[Number].Address = Table[i].Address;
		device.Endpoints[Number].MaxPacketSize = Table[i].Size;
 8025f98:	8119      	strh	r1, [r3, #8]
		device.Endpoints[Number].IsConfigured = 1;
 8025f9a:	721a      	strb	r2, [r3, #8]
		device.Endpoints[Number].IsEnabled = 1;
 8025f9c:	891a      	ldrh	r2, [r3, #8]
 8025f9e:	f042 0202 	orr.w	r2, r2, #2
 8025fa2:	811a      	strh	r2, [r3, #8]
		/* Start read for out endpoints */
		if (!(Table[i].Address & ENDPOINT_DIR_MASK))
 8025fa4:	f819 0c04 	ldrb.w	r0, [r9, #-4]
 8025fa8:	0602      	lsls	r2, r0, #24
 8025faa:	f109 0906 	add.w	r9, r9, #6
 8025fae:	d403      	bmi.n	8025fb8 <Endpoint_ConfigureEndpointTable+0x58>
			device.Driver->EndpointReadStart(Table[i].Address,
 8025fb0:	6832      	ldr	r2, [r6, #0]
 8025fb2:	6999      	ldr	r1, [r3, #24]
 8025fb4:	6a93      	ldr	r3, [r2, #40]	; 0x28
 8025fb6:	4798      	blx	r3

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
			                                     const uint8_t Entries) {
	uint8_t i;
	uint8_t Number;
	for (i=0;i<Entries;i++) {
 8025fb8:	45a9      	cmp	r9, r5
 8025fba:	d013      	beq.n	8025fe4 <Endpoint_ConfigureEndpointTable+0x84>
		Number = Table[i].Address & ENDPOINT_EPNUM_MASK;
 8025fbc:	f819 3c04 	ldrb.w	r3, [r9, #-4]
		/* Configure endpoint in device controller driver */
		if (device.Driver->EndpointConfigure(Table[i].Address,
 8025fc0:	683a      	ldr	r2, [r7, #0]
 8025fc2:	f899 1000 	ldrb.w	r1, [r9]
 8025fc6:	f8d2 c01c 	ldr.w	ip, [r2, #28]
 8025fca:	f839 2c02 	ldrh.w	r2, [r9, #-2]
 8025fce:	4618      	mov	r0, r3
bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
			                                     const uint8_t Entries) {
	uint8_t i;
	uint8_t Number;
	for (i=0;i<Entries;i++) {
		Number = Table[i].Address & ENDPOINT_EPNUM_MASK;
 8025fd0:	f003 040f 	and.w	r4, r3, #15
		/* Configure endpoint in device controller driver */
		if (device.Driver->EndpointConfigure(Table[i].Address,
 8025fd4:	47e0      	blx	ip
				(XMC_USBD_ENDPOINT_TYPE_t)Table[i].Type,Table[i].Size) !=
																XMC_USBD_STATUS_OK)
			return false;
		/* Set device core values */
		device.Endpoints[Number].Address = Table[i].Address;
 8025fd6:	fb08 6304 	mla	r3, r8, r4, r6
	uint8_t i;
	uint8_t Number;
	for (i=0;i<Entries;i++) {
		Number = Table[i].Address & ENDPOINT_EPNUM_MASK;
		/* Configure endpoint in device controller driver */
		if (device.Driver->EndpointConfigure(Table[i].Address,
 8025fda:	2800      	cmp	r0, #0
 8025fdc:	d0d1      	beq.n	8025f82 <Endpoint_ConfigureEndpointTable+0x22>
				(XMC_USBD_ENDPOINT_TYPE_t)Table[i].Type,Table[i].Size) !=
																XMC_USBD_STATUS_OK)
			return false;
 8025fde:	2000      	movs	r0, #0
		if (!(Table[i].Address & ENDPOINT_DIR_MASK))
			device.Driver->EndpointReadStart(Table[i].Address,
					device.Endpoints[Number].OutBufferLength);
	}
	return true;
}
 8025fe0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		/* Start read for out endpoints */
		if (!(Table[i].Address & ENDPOINT_DIR_MASK))
			device.Driver->EndpointReadStart(Table[i].Address,
					device.Endpoints[Number].OutBufferLength);
	}
	return true;
 8025fe4:	2001      	movs	r0, #1
 8025fe6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8025fea:	2001      	movs	r0, #1
}
 8025fec:	4770      	bx	lr
 8025fee:	bf00      	nop
 8025ff0:	2000d8f4 	.word	0x2000d8f4

08025ff4 <USBD_SignalDeviceEventHandler>:
 */
static void USBD_SignalDeviceEventHandler(XMC_USBD_EVENT_t event)
{
  uint32_t i;

  switch (event)
 8025ff4:	2809      	cmp	r0, #9
 8025ff6:	d80e      	bhi.n	8026016 <USBD_SignalDeviceEventHandler+0x22>
 8025ff8:	e8df f010 	tbh	[pc, r0, lsl #1]
 8025ffc:	0019000a 	.word	0x0019000a
 8026000:	002a0023 	.word	0x002a0023
 8026004:	000d0034 	.word	0x000d0034
 8026008:	000e00e8 	.word	0x000e00e8
 802600c:	00f6000d 	.word	0x00f6000d
      {
        device.events->disconnect();
      }
      break;
    case XMC_USBD_EVENT_POWER_ON:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Powered;
 8026010:	4bb7      	ldr	r3, [pc, #732]	; (80262f0 <USBD_SignalDeviceEventHandler+0x2fc>)
 8026012:	2201      	movs	r2, #1
 8026014:	701a      	strb	r2, [r3, #0]
 8026016:	4770      	bx	lr
      break;
    case XMC_USBD_EVENT_REMOTE_WAKEUP:
      break;
    case XMC_USBD_EVENT_RESUME:
      USB_DeviceState = (uint8_t)device.pre_suspend_device_state;
 8026018:	4bb6      	ldr	r3, [pc, #728]	; (80262f4 <USBD_SignalDeviceEventHandler+0x300>)
 802601a:	4ab5      	ldr	r2, [pc, #724]	; (80262f0 <USBD_SignalDeviceEventHandler+0x2fc>)
      if (NULL != device.events->wakeup)
 802601c:	f8d3 0140 	ldr.w	r0, [r3, #320]	; 0x140
      USB_DeviceState = (uint8_t)DEVICE_STATE_Powered;
      break;
    case XMC_USBD_EVENT_REMOTE_WAKEUP:
      break;
    case XMC_USBD_EVENT_RESUME:
      USB_DeviceState = (uint8_t)device.pre_suspend_device_state;
 8026020:	f893 113a 	ldrb.w	r1, [r3, #314]	; 0x13a
      if (NULL != device.events->wakeup)
 8026024:	6983      	ldr	r3, [r0, #24]
      USB_DeviceState = (uint8_t)DEVICE_STATE_Powered;
      break;
    case XMC_USBD_EVENT_REMOTE_WAKEUP:
      break;
    case XMC_USBD_EVENT_RESUME:
      USB_DeviceState = (uint8_t)device.pre_suspend_device_state;
 8026026:	7011      	strb	r1, [r2, #0]
      if (NULL != device.events->wakeup)
 8026028:	2b00      	cmp	r3, #0
 802602a:	d0f4      	beq.n	8026016 <USBD_SignalDeviceEventHandler+0x22>
      {
        device.events->wakeup();
 802602c:	4718      	bx	r3
        device.events->disconnect();
      }
      break;
    case XMC_USBD_EVENT_POWER_OFF:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
      if (NULL != device.events->disconnect)
 802602e:	4bb1      	ldr	r3, [pc, #708]	; (80262f4 <USBD_SignalDeviceEventHandler+0x300>)
      {
        device.events->disconnect();
      }
      break;
    case XMC_USBD_EVENT_POWER_OFF:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
 8026030:	4aaf      	ldr	r2, [pc, #700]	; (80262f0 <USBD_SignalDeviceEventHandler+0x2fc>)
      if (NULL != device.events->disconnect)
 8026032:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 8026036:	685b      	ldr	r3, [r3, #4]
      {
        device.events->disconnect();
      }
      break;
    case XMC_USBD_EVENT_POWER_OFF:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
 8026038:	2100      	movs	r1, #0
 802603a:	7011      	strb	r1, [r2, #0]
      if (NULL != device.events->disconnect)
 802603c:	2b00      	cmp	r3, #0
 802603e:	d1f5      	bne.n	802602c <USBD_SignalDeviceEventHandler+0x38>
 8026040:	e7e9      	b.n	8026016 <USBD_SignalDeviceEventHandler+0x22>
      {
        device.events->start_of_frame();
      }
      break;
    case XMC_USBD_EVENT_CONNECT:
      if (NULL != device.events->connect)
 8026042:	4bac      	ldr	r3, [pc, #688]	; (80262f4 <USBD_SignalDeviceEventHandler+0x300>)
 8026044:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 8026048:	681b      	ldr	r3, [r3, #0]
 802604a:	2b00      	cmp	r3, #0
 802604c:	d1ee      	bne.n	802602c <USBD_SignalDeviceEventHandler+0x38>
 802604e:	e7e2      	b.n	8026016 <USBD_SignalDeviceEventHandler+0x22>
        device.events->connect();
      }
      break;
    case XMC_USBD_EVENT_DISCONNECT:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Powered;
      if (NULL != device.events->disconnect)
 8026050:	4ba8      	ldr	r3, [pc, #672]	; (80262f4 <USBD_SignalDeviceEventHandler+0x300>)
      {
        device.events->connect();
      }
      break;
    case XMC_USBD_EVENT_DISCONNECT:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Powered;
 8026052:	4aa7      	ldr	r2, [pc, #668]	; (80262f0 <USBD_SignalDeviceEventHandler+0x2fc>)
      if (NULL != device.events->disconnect)
 8026054:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 8026058:	685b      	ldr	r3, [r3, #4]
      {
        device.events->connect();
      }
      break;
    case XMC_USBD_EVENT_DISCONNECT:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Powered;
 802605a:	2101      	movs	r1, #1
 802605c:	7011      	strb	r1, [r2, #0]
      if (NULL != device.events->disconnect)
 802605e:	2b00      	cmp	r3, #0
 8026060:	d1e4      	bne.n	802602c <USBD_SignalDeviceEventHandler+0x38>
 8026062:	e7d8      	b.n	8026016 <USBD_SignalDeviceEventHandler+0x22>
 * The device can have several events, by which it notifies the application about the occurance of event.
 * Not all events are available on all chip series. (Power Events are only supported on XMC4500)
 *
 */
static void USBD_SignalDeviceEventHandler(XMC_USBD_EVENT_t event)
{
 8026064:	b570      	push	{r4, r5, r6, lr}
  uint32_t i;

  switch (event)
  {
    case XMC_USBD_EVENT_RESET:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
 8026066:	4ba2      	ldr	r3, [pc, #648]	; (80262f0 <USBD_SignalDeviceEventHandler+0x2fc>)
      device.ep0_state = USBD_EP0_STATE_IDLE;
 8026068:	4ca2      	ldr	r4, [pc, #648]	; (80262f4 <USBD_SignalDeviceEventHandler+0x300>)
  uint32_t i;

  switch (event)
  {
    case XMC_USBD_EVENT_RESET:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
 802606a:	2202      	movs	r2, #2
 802606c:	701a      	strb	r2, [r3, #0]
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 802606e:	8922      	ldrh	r2, [r4, #8]
  switch (event)
  {
    case XMC_USBD_EVENT_RESET:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
 8026070:	f894 313e 	ldrb.w	r3, [r4, #318]	; 0x13e
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 8026074:	f36f 1204 	bfc	r2, #4, #1
 8026078:	8122      	strh	r2, [r4, #8]
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
 802607a:	8922      	ldrh	r2, [r4, #8]
 802607c:	f36f 02c3 	bfc	r2, #3, #1
 8026080:	8122      	strh	r2, [r4, #8]
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
 8026082:	8922      	ldrh	r2, [r4, #8]
 8026084:	f36f 0282 	bfc	r2, #2, #1
 8026088:	8122      	strh	r2, [r4, #8]
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 802608a:	8ea2      	ldrh	r2, [r4, #52]	; 0x34
 802608c:	f36f 1204 	bfc	r2, #4, #1
 8026090:	86a2      	strh	r2, [r4, #52]	; 0x34
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
 8026092:	8ea2      	ldrh	r2, [r4, #52]	; 0x34
 8026094:	f36f 02c3 	bfc	r2, #3, #1
 8026098:	86a2      	strh	r2, [r4, #52]	; 0x34
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
 802609a:	8ea2      	ldrh	r2, [r4, #52]	; 0x34
 802609c:	f36f 0282 	bfc	r2, #2, #1
 80260a0:	86a2      	strh	r2, [r4, #52]	; 0x34
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
 80260a2:	f894 2034 	ldrb.w	r2, [r4, #52]	; 0x34
  switch (event)
  {
    case XMC_USBD_EVENT_RESET:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
 80260a6:	f36f 0382 	bfc	r3, #2, #1

  switch (event)
  {
    case XMC_USBD_EVENT_RESET:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
      device.ep0_state = USBD_EP0_STATE_IDLE;
 80260aa:	2101      	movs	r1, #1
      device.remote_wakeup = (uint8_t)0;
 80260ac:	f884 313e 	strb.w	r3, [r4, #318]	; 0x13e
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
 80260b0:	07d3      	lsls	r3, r2, #31

  switch (event)
  {
    case XMC_USBD_EVENT_RESET:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
      device.ep0_state = USBD_EP0_STATE_IDLE;
 80260b2:	f884 113b 	strb.w	r1, [r4, #315]	; 0x13b
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
 80260b6:	f100 809f 	bmi.w	80261f8 <USBD_SignalDeviceEventHandler+0x204>
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 80260ba:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
 80260be:	4d8d      	ldr	r5, [pc, #564]	; (80262f4 <USBD_SignalDeviceEventHandler+0x300>)
 80260c0:	f36f 1304 	bfc	r3, #4, #1
 80260c4:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
 80260c8:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
 80260cc:	f36f 03c3 	bfc	r3, #3, #1
 80260d0:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
 80260d4:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
 80260d8:	f36f 0382 	bfc	r3, #2, #1
 80260dc:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
 80260e0:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
 80260e4:	07de      	lsls	r6, r3, #31
 80260e6:	f100 80ec 	bmi.w	80262c2 <USBD_SignalDeviceEventHandler+0x2ce>
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 80260ea:	f8b4 308c 	ldrh.w	r3, [r4, #140]	; 0x8c
 80260ee:	4d81      	ldr	r5, [pc, #516]	; (80262f4 <USBD_SignalDeviceEventHandler+0x300>)
 80260f0:	f36f 1304 	bfc	r3, #4, #1
 80260f4:	f8a4 308c 	strh.w	r3, [r4, #140]	; 0x8c
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
 80260f8:	f8b4 308c 	ldrh.w	r3, [r4, #140]	; 0x8c
 80260fc:	f36f 03c3 	bfc	r3, #3, #1
 8026100:	f8a4 308c 	strh.w	r3, [r4, #140]	; 0x8c
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
 8026104:	f8b4 308c 	ldrh.w	r3, [r4, #140]	; 0x8c
 8026108:	f36f 0382 	bfc	r3, #2, #1
 802610c:	f8a4 308c 	strh.w	r3, [r4, #140]	; 0x8c
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
 8026110:	f894 308c 	ldrb.w	r3, [r4, #140]	; 0x8c
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
 8026114:	07d8      	lsls	r0, r3, #31
 8026116:	f100 80bf 	bmi.w	8026298 <USBD_SignalDeviceEventHandler+0x2a4>
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 802611a:	f8b4 30b8 	ldrh.w	r3, [r4, #184]	; 0xb8
 802611e:	4d75      	ldr	r5, [pc, #468]	; (80262f4 <USBD_SignalDeviceEventHandler+0x300>)
 8026120:	f36f 1304 	bfc	r3, #4, #1
 8026124:	f8a4 30b8 	strh.w	r3, [r4, #184]	; 0xb8
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
 8026128:	f8b4 30b8 	ldrh.w	r3, [r4, #184]	; 0xb8
 802612c:	f36f 03c3 	bfc	r3, #3, #1
 8026130:	f8a4 30b8 	strh.w	r3, [r4, #184]	; 0xb8
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
 8026134:	f8b4 30b8 	ldrh.w	r3, [r4, #184]	; 0xb8
 8026138:	f36f 0382 	bfc	r3, #2, #1
 802613c:	f8a4 30b8 	strh.w	r3, [r4, #184]	; 0xb8
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
 8026140:	f894 30b8 	ldrb.w	r3, [r4, #184]	; 0xb8
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
 8026144:	07d9      	lsls	r1, r3, #31
 8026146:	f100 8092 	bmi.w	802626e <USBD_SignalDeviceEventHandler+0x27a>
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 802614a:	f8b4 30e4 	ldrh.w	r3, [r4, #228]	; 0xe4
 802614e:	4d69      	ldr	r5, [pc, #420]	; (80262f4 <USBD_SignalDeviceEventHandler+0x300>)
 8026150:	f36f 1304 	bfc	r3, #4, #1
 8026154:	f8a4 30e4 	strh.w	r3, [r4, #228]	; 0xe4
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
 8026158:	f8b4 30e4 	ldrh.w	r3, [r4, #228]	; 0xe4
 802615c:	f36f 03c3 	bfc	r3, #3, #1
 8026160:	f8a4 30e4 	strh.w	r3, [r4, #228]	; 0xe4
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
 8026164:	f8b4 30e4 	ldrh.w	r3, [r4, #228]	; 0xe4
 8026168:	f36f 0382 	bfc	r3, #2, #1
 802616c:	f8a4 30e4 	strh.w	r3, [r4, #228]	; 0xe4
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
 8026170:	f894 30e4 	ldrb.w	r3, [r4, #228]	; 0xe4
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
 8026174:	07da      	lsls	r2, r3, #31
 8026176:	d466      	bmi.n	8026246 <USBD_SignalDeviceEventHandler+0x252>
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 8026178:	f8b4 3110 	ldrh.w	r3, [r4, #272]	; 0x110
 802617c:	4d5d      	ldr	r5, [pc, #372]	; (80262f4 <USBD_SignalDeviceEventHandler+0x300>)
 802617e:	f36f 1304 	bfc	r3, #4, #1
 8026182:	f8a4 3110 	strh.w	r3, [r4, #272]	; 0x110
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
 8026186:	f8b4 3110 	ldrh.w	r3, [r4, #272]	; 0x110
 802618a:	f36f 03c3 	bfc	r3, #3, #1
 802618e:	f8a4 3110 	strh.w	r3, [r4, #272]	; 0x110
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
 8026192:	f8b4 3110 	ldrh.w	r3, [r4, #272]	; 0x110
 8026196:	f36f 0382 	bfc	r3, #2, #1
 802619a:	f8a4 3110 	strh.w	r3, [r4, #272]	; 0x110
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
 802619e:	f894 3110 	ldrb.w	r3, [r4, #272]	; 0x110
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
 80261a2:	07db      	lsls	r3, r3, #31
 80261a4:	d43b      	bmi.n	802621e <USBD_SignalDeviceEventHandler+0x22a>
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
          }
        }
      }
      device.configuration = (uint8_t)0;
 80261a6:	2300      	movs	r3, #0
      for (i = ((uint32_t)NUM_INTERFACES); i > 0U; i--)
      {
        device.interface_settings[((uint32_t)NUM_INTERFACES - i)] = (uint8_t)0;
      }
      device.Driver->EndpointReadStart((uint8_t)device.Endpoints[0].Address,(uint32_t)USBD_EP0_3SETUP_PKT_SIZE);
 80261a8:	6822      	ldr	r2, [r4, #0]
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
          }
        }
      }
      device.configuration = (uint8_t)0;
 80261aa:	f884 3139 	strb.w	r3, [r4, #313]	; 0x139
      for (i = ((uint32_t)NUM_INTERFACES); i > 0U; i--)
      {
        device.interface_settings[((uint32_t)NUM_INTERFACES - i)] = (uint8_t)0;
 80261ae:	f884 3138 	strb.w	r3, [r4, #312]	; 0x138
      }
      device.Driver->EndpointReadStart((uint8_t)device.Endpoints[0].Address,(uint32_t)USBD_EP0_3SETUP_PKT_SIZE);
 80261b2:	6a93      	ldr	r3, [r2, #40]	; 0x28
 80261b4:	7920      	ldrb	r0, [r4, #4]
 80261b6:	2118      	movs	r1, #24
 80261b8:	4798      	blx	r3
      if (NULL != device.events->reset)
 80261ba:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
 80261be:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80261c0:	2b00      	cmp	r3, #0
 80261c2:	f000 8093 	beq.w	80262ec <USBD_SignalDeviceEventHandler+0x2f8>
      }
      break;
    default:
      break;
  }
}
 80261c6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        device.interface_settings[((uint32_t)NUM_INTERFACES - i)] = (uint8_t)0;
      }
      device.Driver->EndpointReadStart((uint8_t)device.Endpoints[0].Address,(uint32_t)USBD_EP0_3SETUP_PKT_SIZE);
      if (NULL != device.events->reset)
      {
        device.events->reset();
 80261ca:	4718      	bx	r3
      {
        device.events->wakeup();
      }
      break;
    case XMC_USBD_EVENT_SUSPEND:
      device.pre_suspend_device_state = USB_DeviceState;
 80261cc:	4a49      	ldr	r2, [pc, #292]	; (80262f4 <USBD_SignalDeviceEventHandler+0x300>)
 80261ce:	4b48      	ldr	r3, [pc, #288]	; (80262f0 <USBD_SignalDeviceEventHandler+0x2fc>)
      USB_DeviceState = (uint8_t)DEVICE_STATE_Suspended;
      if (NULL != device.events->suspend)
 80261d0:	f8d2 1140 	ldr.w	r1, [r2, #320]	; 0x140
      {
        device.events->wakeup();
      }
      break;
    case XMC_USBD_EVENT_SUSPEND:
      device.pre_suspend_device_state = USB_DeviceState;
 80261d4:	7818      	ldrb	r0, [r3, #0]
 80261d6:	f882 013a 	strb.w	r0, [r2, #314]	; 0x13a
      USB_DeviceState = (uint8_t)DEVICE_STATE_Suspended;
      if (NULL != device.events->suspend)
 80261da:	69ca      	ldr	r2, [r1, #28]
        device.events->wakeup();
      }
      break;
    case XMC_USBD_EVENT_SUSPEND:
      device.pre_suspend_device_state = USB_DeviceState;
      USB_DeviceState = (uint8_t)DEVICE_STATE_Suspended;
 80261dc:	2105      	movs	r1, #5
 80261de:	7019      	strb	r1, [r3, #0]
      if (NULL != device.events->suspend)
 80261e0:	2a00      	cmp	r2, #0
 80261e2:	f43f af18 	beq.w	8026016 <USBD_SignalDeviceEventHandler+0x22>
      {
        device.events->suspend();
 80261e6:	4710      	bx	r2
      {
        device.events->reset();
      }
      break;
    case XMC_USBD_EVENT_SOF:
      if (NULL != device.events->start_of_frame)
 80261e8:	4b42      	ldr	r3, [pc, #264]	; (80262f4 <USBD_SignalDeviceEventHandler+0x300>)
 80261ea:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 80261ee:	6a1b      	ldr	r3, [r3, #32]
 80261f0:	2b00      	cmp	r3, #0
 80261f2:	f47f af1b 	bne.w	802602c <USBD_SignalDeviceEventHandler+0x38>
 80261f6:	e70e      	b.n	8026016 <USBD_SignalDeviceEventHandler+0x22>
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
 80261f8:	6823      	ldr	r3, [r4, #0]
 80261fa:	f894 0030 	ldrb.w	r0, [r4, #48]	; 0x30
 80261fe:	6a1b      	ldr	r3, [r3, #32]
 8026200:	4798      	blx	r3
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
 8026202:	2800      	cmp	r0, #0
 8026204:	f47f af59 	bne.w	80260ba <USBD_SignalDeviceEventHandler+0xc6>
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
          ((uint8_t)device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].Address))
          {
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
 8026208:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 802620c:	f360 0300 	bfi	r3, r0, #0, #1
 8026210:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
 8026214:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
 8026216:	f360 0341 	bfi	r3, r0, #1, #1
 802621a:	86a3      	strh	r3, [r4, #52]	; 0x34
 802621c:	e74d      	b.n	80260ba <USBD_SignalDeviceEventHandler+0xc6>
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
 802621e:	682b      	ldr	r3, [r5, #0]
 8026220:	f895 010c 	ldrb.w	r0, [r5, #268]	; 0x10c
 8026224:	6a1b      	ldr	r3, [r3, #32]
 8026226:	4798      	blx	r3
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
 8026228:	2800      	cmp	r0, #0
 802622a:	d1bc      	bne.n	80261a6 <USBD_SignalDeviceEventHandler+0x1b2>
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
          ((uint8_t)device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].Address))
          {
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
 802622c:	f895 3110 	ldrb.w	r3, [r5, #272]	; 0x110
 8026230:	f360 0300 	bfi	r3, r0, #0, #1
 8026234:	f885 3110 	strb.w	r3, [r5, #272]	; 0x110
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
 8026238:	f8b5 3110 	ldrh.w	r3, [r5, #272]	; 0x110
 802623c:	f360 0341 	bfi	r3, r0, #1, #1
 8026240:	f8a5 3110 	strh.w	r3, [r5, #272]	; 0x110
 8026244:	e7af      	b.n	80261a6 <USBD_SignalDeviceEventHandler+0x1b2>
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
 8026246:	682b      	ldr	r3, [r5, #0]
 8026248:	f895 00e0 	ldrb.w	r0, [r5, #224]	; 0xe0
 802624c:	6a1b      	ldr	r3, [r3, #32]
 802624e:	4798      	blx	r3
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
 8026250:	2800      	cmp	r0, #0
 8026252:	d191      	bne.n	8026178 <USBD_SignalDeviceEventHandler+0x184>
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
          ((uint8_t)device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].Address))
          {
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
 8026254:	f895 30e4 	ldrb.w	r3, [r5, #228]	; 0xe4
 8026258:	f360 0300 	bfi	r3, r0, #0, #1
 802625c:	f885 30e4 	strb.w	r3, [r5, #228]	; 0xe4
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
 8026260:	f8b5 30e4 	ldrh.w	r3, [r5, #228]	; 0xe4
 8026264:	f360 0341 	bfi	r3, r0, #1, #1
 8026268:	f8a5 30e4 	strh.w	r3, [r5, #228]	; 0xe4
 802626c:	e784      	b.n	8026178 <USBD_SignalDeviceEventHandler+0x184>
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
 802626e:	682b      	ldr	r3, [r5, #0]
 8026270:	f895 00b4 	ldrb.w	r0, [r5, #180]	; 0xb4
 8026274:	6a1b      	ldr	r3, [r3, #32]
 8026276:	4798      	blx	r3
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
 8026278:	2800      	cmp	r0, #0
 802627a:	f47f af66 	bne.w	802614a <USBD_SignalDeviceEventHandler+0x156>
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
          ((uint8_t)device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].Address))
          {
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
 802627e:	f895 30b8 	ldrb.w	r3, [r5, #184]	; 0xb8
 8026282:	f360 0300 	bfi	r3, r0, #0, #1
 8026286:	f885 30b8 	strb.w	r3, [r5, #184]	; 0xb8
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
 802628a:	f8b5 30b8 	ldrh.w	r3, [r5, #184]	; 0xb8
 802628e:	f360 0341 	bfi	r3, r0, #1, #1
 8026292:	f8a5 30b8 	strh.w	r3, [r5, #184]	; 0xb8
 8026296:	e758      	b.n	802614a <USBD_SignalDeviceEventHandler+0x156>
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
 8026298:	682b      	ldr	r3, [r5, #0]
 802629a:	f895 0088 	ldrb.w	r0, [r5, #136]	; 0x88
 802629e:	6a1b      	ldr	r3, [r3, #32]
 80262a0:	4798      	blx	r3
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
 80262a2:	2800      	cmp	r0, #0
 80262a4:	f47f af39 	bne.w	802611a <USBD_SignalDeviceEventHandler+0x126>
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
          ((uint8_t)device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].Address))
          {
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
 80262a8:	f895 308c 	ldrb.w	r3, [r5, #140]	; 0x8c
 80262ac:	f360 0300 	bfi	r3, r0, #0, #1
 80262b0:	f885 308c 	strb.w	r3, [r5, #140]	; 0x8c
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
 80262b4:	f8b5 308c 	ldrh.w	r3, [r5, #140]	; 0x8c
 80262b8:	f360 0341 	bfi	r3, r0, #1, #1
 80262bc:	f8a5 308c 	strh.w	r3, [r5, #140]	; 0x8c
 80262c0:	e72b      	b.n	802611a <USBD_SignalDeviceEventHandler+0x126>
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
 80262c2:	682b      	ldr	r3, [r5, #0]
 80262c4:	f895 005c 	ldrb.w	r0, [r5, #92]	; 0x5c
 80262c8:	6a1b      	ldr	r3, [r3, #32]
 80262ca:	4798      	blx	r3
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
 80262cc:	2800      	cmp	r0, #0
 80262ce:	f47f af0c 	bne.w	80260ea <USBD_SignalDeviceEventHandler+0xf6>
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
          ((uint8_t)device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].Address))
          {
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
 80262d2:	f895 3060 	ldrb.w	r3, [r5, #96]	; 0x60
 80262d6:	f360 0300 	bfi	r3, r0, #0, #1
 80262da:	f885 3060 	strb.w	r3, [r5, #96]	; 0x60
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
 80262de:	f8b5 3060 	ldrh.w	r3, [r5, #96]	; 0x60
 80262e2:	f360 0341 	bfi	r3, r0, #1, #1
 80262e6:	f8a5 3060 	strh.w	r3, [r5, #96]	; 0x60
 80262ea:	e6fe      	b.n	80260ea <USBD_SignalDeviceEventHandler+0xf6>
 80262ec:	bd70      	pop	{r4, r5, r6, pc}
 80262ee:	bf00      	nop
 80262f0:	2000d6e9 	.word	0x2000d6e9
 80262f4:	2000d8f4 	.word	0x2000d8f4

080262f8 <USBD_HandleEP0_Stall>:
 *
 * Stalls EP0 and then restarts a new transfer including setting EP0 state to
 * 																\ref USBD_EP0_STATE_IDLE.
 */
static void USBD_HandleEP0_Stall(void)
{
 80262f8:	b510      	push	{r4, lr}
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
 80262fa:	4c08      	ldr	r4, [pc, #32]	; (802631c <USBD_HandleEP0_Stall+0x24>)
 80262fc:	6823      	ldr	r3, [r4, #0]
 80262fe:	2080      	movs	r0, #128	; 0x80
 8026300:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8026302:	2101      	movs	r1, #1
 8026304:	4798      	blx	r3
 8026306:	b100      	cbz	r0, 802630a <USBD_HandleEP0_Stall+0x12>
 8026308:	bd10      	pop	{r4, pc}
  {
    device.ep0_state = USBD_EP0_STATE_IDLE;
    if ( USBD_STATUS_SUCCESS != (USBD_STATUS_t)device.Driver->EndpointReadStart(0U,USBD_EP0_3SETUP_PKT_SIZE))
 802630a:	6823      	ldr	r3, [r4, #0]
{
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
  {
    device.ep0_state = USBD_EP0_STATE_IDLE;
 802630c:	2201      	movs	r2, #1
    if ( USBD_STATUS_SUCCESS != (USBD_STATUS_t)device.Driver->EndpointReadStart(0U,USBD_EP0_3SETUP_PKT_SIZE))
 802630e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
{
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
  {
    device.ep0_state = USBD_EP0_STATE_IDLE;
 8026310:	f884 213b 	strb.w	r2, [r4, #315]	; 0x13b
    if ( USBD_STATUS_SUCCESS != (USBD_STATUS_t)device.Driver->EndpointReadStart(0U,USBD_EP0_3SETUP_PKT_SIZE))
 8026314:	2118      	movs	r1, #24
    {
      XMC_ASSERT("USBD_HandleEP0_Stall: EndpointReadStart failed", 0);
    }
  }
}
 8026316:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
  {
    device.ep0_state = USBD_EP0_STATE_IDLE;
    if ( USBD_STATUS_SUCCESS != (USBD_STATUS_t)device.Driver->EndpointReadStart(0U,USBD_EP0_3SETUP_PKT_SIZE))
 802631a:	4718      	bx	r3
 802631c:	2000d8f4 	.word	0x2000d8f4

08026320 <USBD_Handle_DeviceRequest>:
 * handle some custom request or override the request handling in this function.
 * If the user has handled the request, he has to call \ref Endpoint_ClearSETUP.
 *
 */
static void USBD_Handle_DeviceRequest(void)
{
 8026320:	b570      	push	{r4, r5, r6, lr}
  

  value = (uint32_t)USB_ControlRequest.wValue & (uint32_t)USBD_BYTE_MASK;

  /* Handling of class/vendor requests */
  if (NULL != device.events->control_request)
 8026322:	4ca2      	ldr	r4, [pc, #648]	; (80265ac <USBD_Handle_DeviceRequest+0x28c>)
  uint32_t value;
  uint32_t tmp_value;
  uint32_t tmp_index;
  

  value = (uint32_t)USB_ControlRequest.wValue & (uint32_t)USBD_BYTE_MASK;
 8026324:	4ea2      	ldr	r6, [pc, #648]	; (80265b0 <USBD_Handle_DeviceRequest+0x290>)

  /* Handling of class/vendor requests */
  if (NULL != device.events->control_request)
 8026326:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
  uint32_t value;
  uint32_t tmp_value;
  uint32_t tmp_index;
  

  value = (uint32_t)USB_ControlRequest.wValue & (uint32_t)USBD_BYTE_MASK;
 802632a:	8870      	ldrh	r0, [r6, #2]

  /* Handling of class/vendor requests */
  if (NULL != device.events->control_request)
 802632c:	68da      	ldr	r2, [r3, #12]
 * handle some custom request or override the request handling in this function.
 * If the user has handled the request, he has to call \ref Endpoint_ClearSETUP.
 *
 */
static void USBD_Handle_DeviceRequest(void)
{
 802632e:	b082      	sub	sp, #8
  uint32_t length = 0U;
  uint32_t ret;
  void *buffer = NULL;
 8026330:	2300      	movs	r3, #0
  uint32_t value;
  uint32_t tmp_value;
  uint32_t tmp_index;
  

  value = (uint32_t)USB_ControlRequest.wValue & (uint32_t)USBD_BYTE_MASK;
 8026332:	b285      	uxth	r5, r0
 */
static void USBD_Handle_DeviceRequest(void)
{
  uint32_t length = 0U;
  uint32_t ret;
  void *buffer = NULL;
 8026334:	9300      	str	r3, [sp, #0]
  uint32_t status = 0U;
 8026336:	9301      	str	r3, [sp, #4]
  

  value = (uint32_t)USB_ControlRequest.wValue & (uint32_t)USBD_BYTE_MASK;

  /* Handling of class/vendor requests */
  if (NULL != device.events->control_request)
 8026338:	b102      	cbz	r2, 802633c <USBD_Handle_DeviceRequest+0x1c>
  {
    device.events->control_request();
 802633a:	4790      	blx	r2
  }

  if (1U == device.IsSetupRecieved)
 802633c:	f894 313e 	ldrb.w	r3, [r4, #318]	; 0x13e
 8026340:	079b      	lsls	r3, r3, #30
 8026342:	d407      	bmi.n	8026354 <USBD_Handle_DeviceRequest+0x34>
      default:
        USBD_HandleEP0_Stall();
        break;
    }
  }
  device.IsSetupRecieved = 0U;
 8026344:	f894 313e 	ldrb.w	r3, [r4, #318]	; 0x13e
 8026348:	f023 0302 	bic.w	r3, r3, #2
 802634c:	f884 313e 	strb.w	r3, [r4, #318]	; 0x13e
}
 8026350:	b002      	add	sp, #8
 8026352:	bd70      	pop	{r4, r5, r6, pc}
  }

  if (1U == device.IsSetupRecieved)
  {
    /* default request handling */
    switch (USB_ControlRequest.bRequest)
 8026354:	7873      	ldrb	r3, [r6, #1]
  uint32_t value;
  uint32_t tmp_value;
  uint32_t tmp_index;
  

  value = (uint32_t)USB_ControlRequest.wValue & (uint32_t)USBD_BYTE_MASK;
 8026356:	b2ed      	uxtb	r5, r5
  }

  if (1U == device.IsSetupRecieved)
  {
    /* default request handling */
    switch (USB_ControlRequest.bRequest)
 8026358:	2b0c      	cmp	r3, #12
 802635a:	d816      	bhi.n	802638a <USBD_Handle_DeviceRequest+0x6a>
 802635c:	e8df f013 	tbh	[pc, r3, lsl #1]
 8026360:	00be0025 	.word	0x00be0025
 8026364:	009d0015 	.word	0x009d0015
 8026368:	00d00015 	.word	0x00d00015
 802636c:	00150056 	.word	0x00150056
 8026370:	008a0083 	.word	0x008a0083
 8026374:	0078000d 	.word	0x0078000d
 8026378:	0015      	.short	0x0015
          device.Endpoints[0].InDataBuffer = (uint8_t *)buffer + ret;
        }
        break;

      case REQ_GetInterface:
        if ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState)
 802637a:	4b8e      	ldr	r3, [pc, #568]	; (80265b4 <USBD_Handle_DeviceRequest+0x294>)
 802637c:	781a      	ldrb	r2, [r3, #0]
 802637e:	2a04      	cmp	r2, #4
 8026380:	f000 8136 	beq.w	80265f0 <USBD_Handle_DeviceRequest+0x2d0>
          tmp_value = (uint32_t)USB_ControlRequest.wValue;
          tmp_index = (uint32_t)USB_ControlRequest.wIndex;
          device.interface_settings[tmp_index] =	(uint8_t)tmp_value;
          break;
        }
        if ((uint8_t)DEVICE_STATE_Addressed == USB_DeviceState)
 8026384:	781b      	ldrb	r3, [r3, #0]
 8026386:	2b03      	cmp	r3, #3
 8026388:	d1dc      	bne.n	8026344 <USBD_Handle_DeviceRequest+0x24>
 */
static void USBD_HandleEP0_Stall(void)
{
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
 802638a:	6823      	ldr	r3, [r4, #0]
 802638c:	4d87      	ldr	r5, [pc, #540]	; (80265ac <USBD_Handle_DeviceRequest+0x28c>)
 802638e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8026390:	2080      	movs	r0, #128	; 0x80
 8026392:	2101      	movs	r1, #1
 8026394:	4798      	blx	r3
 8026396:	2800      	cmp	r0, #0
 8026398:	d1d4      	bne.n	8026344 <USBD_Handle_DeviceRequest+0x24>
  {
    device.ep0_state = USBD_EP0_STATE_IDLE;
    if ( USBD_STATUS_SUCCESS != (USBD_STATUS_t)device.Driver->EndpointReadStart(0U,USBD_EP0_3SETUP_PKT_SIZE))
 802639a:	682b      	ldr	r3, [r5, #0]
{
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
  {
    device.ep0_state = USBD_EP0_STATE_IDLE;
 802639c:	2201      	movs	r2, #1
    if ( USBD_STATUS_SUCCESS != (USBD_STATUS_t)device.Driver->EndpointReadStart(0U,USBD_EP0_3SETUP_PKT_SIZE))
 802639e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
{
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
  {
    device.ep0_state = USBD_EP0_STATE_IDLE;
 80263a0:	f885 213b 	strb.w	r2, [r5, #315]	; 0x13b
    if ( USBD_STATUS_SUCCESS != (USBD_STATUS_t)device.Driver->EndpointReadStart(0U,USBD_EP0_3SETUP_PKT_SIZE))
 80263a4:	2118      	movs	r1, #24
 80263a6:	4798      	blx	r3
 80263a8:	e7cc      	b.n	8026344 <USBD_Handle_DeviceRequest+0x24>
          break;
        }
        break;

      case REQ_GetStatus:
        if (REQREC_DEVICE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
 80263aa:	7830      	ldrb	r0, [r6, #0]
 80263ac:	4b80      	ldr	r3, [pc, #512]	; (80265b0 <USBD_Handle_DeviceRequest+0x290>)
 80263ae:	f010 0003 	ands.w	r0, r0, #3
 80263b2:	f000 8103 	beq.w	80265bc <USBD_Handle_DeviceRequest+0x29c>
          {
            XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetStatus", 0);
          }          
          break;
        }
        if ((REQREC_INTERFACE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK)) &&
 80263b6:	781b      	ldrb	r3, [r3, #0]
 80263b8:	f003 0303 	and.w	r3, r3, #3
 80263bc:	2b01      	cmp	r3, #1
 80263be:	f000 80e7 	beq.w	8026590 <USBD_Handle_DeviceRequest+0x270>
            XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetStatus- REQREC_INTERFACE", 0);
          }          
          break;
        }

        if (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
 80263c2:	7833      	ldrb	r3, [r6, #0]
 80263c4:	4a7a      	ldr	r2, [pc, #488]	; (80265b0 <USBD_Handle_DeviceRequest+0x290>)
 80263c6:	f003 0303 	and.w	r3, r3, #3
 80263ca:	2b02      	cmp	r3, #2
 80263cc:	d1dd      	bne.n	802638a <USBD_Handle_DeviceRequest+0x6a>
        {
          index = (uint32_t)(USB_ControlRequest.wIndex & USBD_BYTE_MASK & ENDPOINT_EPNUM_MASK);
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0 == USB_ControlRequest.wIndex)) &&
 80263ce:	4979      	ldr	r1, [pc, #484]	; (80265b4 <USBD_Handle_DeviceRequest+0x294>)
          break;
        }

        if (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)(USB_ControlRequest.wIndex & USBD_BYTE_MASK & ENDPOINT_EPNUM_MASK);
 80263d0:	8893      	ldrh	r3, [r2, #4]
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0 == USB_ControlRequest.wIndex)) &&
 80263d2:	7809      	ldrb	r1, [r1, #0]
 80263d4:	2904      	cmp	r1, #4
          break;
        }

        if (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)(USB_ControlRequest.wIndex & USBD_BYTE_MASK & ENDPOINT_EPNUM_MASK);
 80263d6:	b29b      	uxth	r3, r3
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0 == USB_ControlRequest.wIndex)) &&
 80263d8:	d003      	beq.n	80263e2 <USBD_Handle_DeviceRequest+0xc2>
 80263da:	8892      	ldrh	r2, [r2, #4]
 80263dc:	b292      	uxth	r2, r2
 80263de:	2a00      	cmp	r2, #0
 80263e0:	d1d3      	bne.n	802638a <USBD_Handle_DeviceRequest+0x6a>
              (1U == device.Endpoints[index].IsConfigured))
 80263e2:	222c      	movs	r2, #44	; 0x2c
          break;
        }

        if (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)(USB_ControlRequest.wIndex & USBD_BYTE_MASK & ENDPOINT_EPNUM_MASK);
 80263e4:	f003 030f 	and.w	r3, r3, #15
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0 == USB_ControlRequest.wIndex)) &&
              (1U == device.Endpoints[index].IsConfigured))
 80263e8:	fb02 4303 	mla	r3, r2, r3, r4
 80263ec:	496f      	ldr	r1, [pc, #444]	; (80265ac <USBD_Handle_DeviceRequest+0x28c>)
 80263ee:	7a1a      	ldrb	r2, [r3, #8]
        }

        if (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)(USB_ControlRequest.wIndex & USBD_BYTE_MASK & ENDPOINT_EPNUM_MASK);
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0 == USB_ControlRequest.wIndex)) &&
 80263f0:	07d0      	lsls	r0, r2, #31
 80263f2:	d5ca      	bpl.n	802638a <USBD_Handle_DeviceRequest+0x6a>
              (1U == device.Endpoints[index].IsConfigured))
          {
            status = (uint32_t)device.Endpoints[index].IsHalted;
 80263f4:	689b      	ldr	r3, [r3, #8]
            if (0U == (uint32_t)device.Driver->EndpointWrite(0U, (uint8_t*)&status, USBD_WORD_SIZE))
 80263f6:	680a      	ldr	r2, [r1, #0]
        {
          index = (uint32_t)(USB_ControlRequest.wIndex & USBD_BYTE_MASK & ENDPOINT_EPNUM_MASK);
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0 == USB_ControlRequest.wIndex)) &&
              (1U == device.Endpoints[index].IsConfigured))
          {
            status = (uint32_t)device.Endpoints[index].IsHalted;
 80263f8:	a902      	add	r1, sp, #8
 80263fa:	f3c3 0380 	ubfx	r3, r3, #2, #1
 80263fe:	f841 3d04 	str.w	r3, [r1, #-4]!
            if (0U == (uint32_t)device.Driver->EndpointWrite(0U, (uint8_t*)&status, USBD_WORD_SIZE))
 8026402:	2000      	movs	r0, #0
 8026404:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8026406:	2202      	movs	r2, #2
 8026408:	4798      	blx	r3
            {
              XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetStatus- REQREC_ENDPOINT", 0);
            }              
            break;
 802640a:	e79b      	b.n	8026344 <USBD_Handle_DeviceRequest+0x24>
          XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on get configuration request", 0);
        }
        break;

      case REQ_GetDescriptor:
        if (NULL != device.events->get_descriptor)
 802640c:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
 8026410:	695b      	ldr	r3, [r3, #20]
 8026412:	2b00      	cmp	r3, #0
 8026414:	d0b9      	beq.n	802638a <USBD_Handle_DeviceRequest+0x6a>
        {
          tmp_value = (uint32_t)USB_ControlRequest.wValue;
 8026416:	8870      	ldrh	r0, [r6, #2]
          tmp_index = (uint32_t)USB_ControlRequest.wIndex;
 8026418:	88b1      	ldrh	r1, [r6, #4]
        break;

      case REQ_GetDescriptor:
        if (NULL != device.events->get_descriptor)
        {
          tmp_value = (uint32_t)USB_ControlRequest.wValue;
 802641a:	4e65      	ldr	r6, [pc, #404]	; (80265b0 <USBD_Handle_DeviceRequest+0x290>)
          tmp_index = (uint32_t)USB_ControlRequest.wIndex;
          length = (uint32_t)device.events->get_descriptor((uint16_t)tmp_value, (uint16_t)tmp_index, (void*)&buffer);
 802641c:	b280      	uxth	r0, r0
 802641e:	b289      	uxth	r1, r1
 8026420:	466a      	mov	r2, sp
 8026422:	4798      	blx	r3
        }

        if (0U == length)
 8026424:	4605      	mov	r5, r0
 8026426:	2800      	cmp	r0, #0
 8026428:	d0af      	beq.n	802638a <USBD_Handle_DeviceRequest+0x6a>
        {
          USBD_HandleEP0_Stall();
        }
        else
        {
          if (length >= (uint32_t)USB_ControlRequest.wLength)
 802642a:	88f3      	ldrh	r3, [r6, #6]
          {
            length = (uint32_t)USB_ControlRequest.wLength;
          }

          ret = (uint32_t)device.Driver->EndpointWrite(0U,buffer,length);
 802642c:	9900      	ldr	r1, [sp, #0]
        {
          USBD_HandleEP0_Stall();
        }
        else
        {
          if (length >= (uint32_t)USB_ControlRequest.wLength)
 802642e:	b29b      	uxth	r3, r3
 8026430:	4298      	cmp	r0, r3
          {
            length = (uint32_t)USB_ControlRequest.wLength;
 8026432:	bf28      	it	cs
 8026434:	88f5      	ldrhcs	r5, [r6, #6]
          }

          ret = (uint32_t)device.Driver->EndpointWrite(0U,buffer,length);
 8026436:	6823      	ldr	r3, [r4, #0]
        }
        else
        {
          if (length >= (uint32_t)USB_ControlRequest.wLength)
          {
            length = (uint32_t)USB_ControlRequest.wLength;
 8026438:	bf28      	it	cs
 802643a:	b2ad      	uxthcs	r5, r5
          }

          ret = (uint32_t)device.Driver->EndpointWrite(0U,buffer,length);
 802643c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802643e:	462a      	mov	r2, r5
 8026440:	2000      	movs	r0, #0
 8026442:	4798      	blx	r3
          device.Endpoints[0].InDataLeft = length - ret;
          device.Endpoints[0].InDataBuffer = (uint8_t *)buffer + ret;
 8026444:	9b00      	ldr	r3, [sp, #0]
          {
            length = (uint32_t)USB_ControlRequest.wLength;
          }

          ret = (uint32_t)device.Driver->EndpointWrite(0U,buffer,length);
          device.Endpoints[0].InDataLeft = length - ret;
 8026446:	1a2d      	subs	r5, r5, r0
          device.Endpoints[0].InDataBuffer = (uint8_t *)buffer + ret;
 8026448:	4418      	add	r0, r3
          {
            length = (uint32_t)USB_ControlRequest.wLength;
          }

          ret = (uint32_t)device.Driver->EndpointWrite(0U,buffer,length);
          device.Endpoints[0].InDataLeft = length - ret;
 802644a:	62a5      	str	r5, [r4, #40]	; 0x28
          device.Endpoints[0].InDataBuffer = (uint8_t *)buffer + ret;
 802644c:	62e0      	str	r0, [r4, #44]	; 0x2c
 802644e:	e779      	b.n	8026344 <USBD_Handle_DeviceRequest+0x24>
        /* Set Descriptor not supported, so stall */
        USBD_HandleEP0_Stall();
        break;

      case REQ_SetInterface:
        if ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState)
 8026450:	4b58      	ldr	r3, [pc, #352]	; (80265b4 <USBD_Handle_DeviceRequest+0x294>)
 8026452:	781a      	ldrb	r2, [r3, #0]
 8026454:	2a04      	cmp	r2, #4
 8026456:	d195      	bne.n	8026384 <USBD_Handle_DeviceRequest+0x64>
        {
          tmp_value = (uint32_t)USB_ControlRequest.wValue;
 8026458:	8872      	ldrh	r2, [r6, #2]
          tmp_index = (uint32_t)USB_ControlRequest.wIndex;
 802645a:	88b3      	ldrh	r3, [r6, #4]
          device.interface_settings[tmp_index] =	(uint8_t)tmp_value;
 802645c:	fa14 f383 	uxtah	r3, r4, r3
 8026460:	f883 2138 	strb.w	r2, [r3, #312]	; 0x138
          break;
 8026464:	e76e      	b.n	8026344 <USBD_Handle_DeviceRequest+0x24>
        }
        USBD_HandleEP0_Stall();
        break;

      case REQ_GetConfiguration:
        if (0U == (uint32_t)device.Driver->EndpointWrite(0U,&device.configuration,1U))
 8026466:	6823      	ldr	r3, [r4, #0]
 8026468:	4953      	ldr	r1, [pc, #332]	; (80265b8 <USBD_Handle_DeviceRequest+0x298>)
 802646a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802646c:	2201      	movs	r2, #1
 802646e:	2000      	movs	r0, #0
 8026470:	4798      	blx	r3
        {
          XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on get configuration request", 0);
        }
        break;
 8026472:	e767      	b.n	8026344 <USBD_Handle_DeviceRequest+0x24>

      case REQ_SetConfiguration:
        /* Regardless the state update the configuration to unconfigure
         * endpoints */
        device.configuration = (uint8_t)value;
        if (NULL != device.events->config_changed)
 8026474:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
        break;

      case REQ_SetConfiguration:
        /* Regardless the state update the configuration to unconfigure
         * endpoints */
        device.configuration = (uint8_t)value;
 8026478:	f884 5139 	strb.w	r5, [r4, #313]	; 0x139
        if (NULL != device.events->config_changed)
 802647c:	689b      	ldr	r3, [r3, #8]
 802647e:	b103      	cbz	r3, 8026482 <USBD_Handle_DeviceRequest+0x162>
        {
          device.events->config_changed();
 8026480:	4798      	blx	r3
        }

        /* when config 0 is choosen, we are back in address state */
        if (0U == value)
 8026482:	2d00      	cmp	r5, #0
 8026484:	d054      	beq.n	8026530 <USBD_Handle_DeviceRequest+0x210>
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Addressed;
          break;
        }
        /* go ahead only with vailid config. (must be set in event) */
        if (1U == device.IsConfigured)
 8026486:	f894 313e 	ldrb.w	r3, [r4, #318]	; 0x13e
 802648a:	4d48      	ldr	r5, [pc, #288]	; (80265ac <USBD_Handle_DeviceRequest+0x28c>)
 802648c:	07d9      	lsls	r1, r3, #31
 802648e:	f140 80a6 	bpl.w	80265de <USBD_Handle_DeviceRequest+0x2be>
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Configured;
 8026492:	4b48      	ldr	r3, [pc, #288]	; (80265b4 <USBD_Handle_DeviceRequest+0x294>)
 8026494:	2204      	movs	r2, #4
 8026496:	701a      	strb	r2, [r3, #0]
 8026498:	e754      	b.n	8026344 <USBD_Handle_DeviceRequest+0x24>
        }
        break;

      case REQ_SetFeature:
        /* we do not support test mode */
        if ((uint32_t)FEATURE_SEL_TestMode == value)
 802649a:	2d02      	cmp	r5, #2
 802649c:	f43f af75 	beq.w	802638a <USBD_Handle_DeviceRequest+0x6a>
        {
          USBD_HandleEP0_Stall();
          break;
        }
        /* configured state */
        if ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState)
 80264a0:	4b44      	ldr	r3, [pc, #272]	; (80265b4 <USBD_Handle_DeviceRequest+0x294>)
 80264a2:	781a      	ldrb	r2, [r3, #0]
 80264a4:	2a04      	cmp	r2, #4
 80264a6:	d067      	beq.n	8026578 <USBD_Handle_DeviceRequest+0x258>
              break;
          }
          break;
        }
        /* when addressed, only ep0 can be halted */
        if ((uint8_t)DEVICE_STATE_Addressed == USB_DeviceState)
 80264a8:	781b      	ldrb	r3, [r3, #0]
 80264aa:	2b03      	cmp	r3, #3
 80264ac:	f47f af6d 	bne.w	802638a <USBD_Handle_DeviceRequest+0x6a>
        {
          if (((uint32_t)FEATURE_SEL_EndpointHalt == value) &&
 80264b0:	2d00      	cmp	r5, #0
 80264b2:	f47f af6a 	bne.w	802638a <USBD_Handle_DeviceRequest+0x6a>
              (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK)) &&
 80264b6:	7833      	ldrb	r3, [r6, #0]
 80264b8:	4a3d      	ldr	r2, [pc, #244]	; (80265b0 <USBD_Handle_DeviceRequest+0x290>)
          break;
        }
        /* when addressed, only ep0 can be halted */
        if ((uint8_t)DEVICE_STATE_Addressed == USB_DeviceState)
        {
          if (((uint32_t)FEATURE_SEL_EndpointHalt == value) &&
 80264ba:	f003 0303 	and.w	r3, r3, #3
 80264be:	2b02      	cmp	r3, #2
 80264c0:	f47f af63 	bne.w	802638a <USBD_Handle_DeviceRequest+0x6a>
              (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK)) &&
              ((uint16_t)0 == ((uint16_t)USB_ControlRequest.wIndex & (uint16_t)USBD_BYTE_MASK)))
 80264c4:	8893      	ldrh	r3, [r2, #4]
        }
        /* when addressed, only ep0 can be halted */
        if ((uint8_t)DEVICE_STATE_Addressed == USB_DeviceState)
        {
          if (((uint32_t)FEATURE_SEL_EndpointHalt == value) &&
              (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK)) &&
 80264c6:	f013 0fff 	tst.w	r3, #255	; 0xff
 80264ca:	f47f af5e 	bne.w	802638a <USBD_Handle_DeviceRequest+0x6a>
              ((uint16_t)0 == ((uint16_t)USB_ControlRequest.wIndex & (uint16_t)USBD_BYTE_MASK)))
          {
            device.Endpoints[0].IsHalted = 1U;
 80264ce:	8923      	ldrh	r3, [r4, #8]
 80264d0:	f043 0304 	orr.w	r3, r3, #4
 80264d4:	8123      	strh	r3, [r4, #8]
            USBD_HandleEP0_Stall();
 80264d6:	f7ff ff0f 	bl	80262f8 <USBD_HandleEP0_Stall>
            break;
 80264da:	e733      	b.n	8026344 <USBD_Handle_DeviceRequest+0x24>
  {
    /* default request handling */
    switch (USB_ControlRequest.bRequest)
    {
      case REQ_ClearFeature:
        if ((uint8_t)REQREC_ENDPOINT == (USB_ControlRequest.bmRequestType & (uint8_t)REQ_RECIPIENT_MASK))
 80264dc:	7833      	ldrb	r3, [r6, #0]
 80264de:	4a34      	ldr	r2, [pc, #208]	; (80265b0 <USBD_Handle_DeviceRequest+0x290>)
 80264e0:	f003 0303 	and.w	r3, r3, #3
 80264e4:	2b02      	cmp	r3, #2
 80264e6:	d027      	beq.n	8026538 <USBD_Handle_DeviceRequest+0x218>
          {
            USBD_HandleEP0_Stall();
          }
          break;
        }
        if (REQREC_DEVICE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
 80264e8:	7813      	ldrb	r3, [r2, #0]
 80264ea:	f013 0303 	ands.w	r3, r3, #3
 80264ee:	f47f af4c 	bne.w	802638a <USBD_Handle_DeviceRequest+0x6a>
        {
          device.remote_wakeup = 0U;
 80264f2:	f894 213e 	ldrb.w	r2, [r4, #318]	; 0x13e
 80264f6:	f363 0282 	bfi	r2, r3, #2, #1
 80264fa:	f884 213e 	strb.w	r2, [r4, #318]	; 0x13e
          break;
 80264fe:	e721      	b.n	8026344 <USBD_Handle_DeviceRequest+0x24>
        break;

      case REQ_SetAddress:
        if (0U == value)
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
 8026500:	4b2c      	ldr	r3, [pc, #176]	; (80265b4 <USBD_Handle_DeviceRequest+0x294>)
        /* default stall */
        USBD_HandleEP0_Stall();
        break;

      case REQ_SetAddress:
        if (0U == value)
 8026502:	b995      	cbnz	r5, 802652a <USBD_Handle_DeviceRequest+0x20a>
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
 8026504:	2202      	movs	r2, #2
 8026506:	701a      	strb	r2, [r3, #0]
        }
        else
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Addressed;
        }
        if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->DeviceSetAddress((uint8_t)value,
 8026508:	6823      	ldr	r3, [r4, #0]
 802650a:	4e28      	ldr	r6, [pc, #160]	; (80265ac <USBD_Handle_DeviceRequest+0x28c>)
 802650c:	699b      	ldr	r3, [r3, #24]
 802650e:	4628      	mov	r0, r5
 8026510:	2100      	movs	r1, #0
 8026512:	4798      	blx	r3
 8026514:	2800      	cmp	r0, #0
 8026516:	f47f af15 	bne.w	8026344 <USBD_Handle_DeviceRequest+0x24>
                                   XMC_USBD_SET_ADDRESS_STAGE_SETUP))
        {
          if (NULL != device.events->set_address)
 802651a:	f8d6 3140 	ldr.w	r3, [r6, #320]	; 0x140
 802651e:	691b      	ldr	r3, [r3, #16]
 8026520:	2b00      	cmp	r3, #0
 8026522:	f43f af0f 	beq.w	8026344 <USBD_Handle_DeviceRequest+0x24>
          {
            device.events->set_address();
 8026526:	4798      	blx	r3
 8026528:	e70c      	b.n	8026344 <USBD_Handle_DeviceRequest+0x24>
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
        }
        else
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Addressed;
 802652a:	2203      	movs	r2, #3
 802652c:	701a      	strb	r2, [r3, #0]
 802652e:	e7eb      	b.n	8026508 <USBD_Handle_DeviceRequest+0x1e8>
        }

        /* when config 0 is choosen, we are back in address state */
        if (0U == value)
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Addressed;
 8026530:	4b20      	ldr	r3, [pc, #128]	; (80265b4 <USBD_Handle_DeviceRequest+0x294>)
 8026532:	2203      	movs	r2, #3
 8026534:	701a      	strb	r2, [r3, #0]
          break;
 8026536:	e705      	b.n	8026344 <USBD_Handle_DeviceRequest+0x24>
    {
      case REQ_ClearFeature:
        if ((uint8_t)REQREC_ENDPOINT == (USB_ControlRequest.bmRequestType & (uint8_t)REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)USB_ControlRequest.wIndex & (uint32_t)ENDPOINT_EPNUM_MASK;
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0U == USB_ControlRequest.wIndex)) &&
 8026538:	491e      	ldr	r1, [pc, #120]	; (80265b4 <USBD_Handle_DeviceRequest+0x294>)
    switch (USB_ControlRequest.bRequest)
    {
      case REQ_ClearFeature:
        if ((uint8_t)REQREC_ENDPOINT == (USB_ControlRequest.bmRequestType & (uint8_t)REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)USB_ControlRequest.wIndex & (uint32_t)ENDPOINT_EPNUM_MASK;
 802653a:	8893      	ldrh	r3, [r2, #4]
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0U == USB_ControlRequest.wIndex)) &&
 802653c:	7809      	ldrb	r1, [r1, #0]
 802653e:	2904      	cmp	r1, #4
    switch (USB_ControlRequest.bRequest)
    {
      case REQ_ClearFeature:
        if ((uint8_t)REQREC_ENDPOINT == (USB_ControlRequest.bmRequestType & (uint8_t)REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)USB_ControlRequest.wIndex & (uint32_t)ENDPOINT_EPNUM_MASK;
 8026540:	b29b      	uxth	r3, r3
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0U == USB_ControlRequest.wIndex)) &&
 8026542:	d004      	beq.n	802654e <USBD_Handle_DeviceRequest+0x22e>
 8026544:	8892      	ldrh	r2, [r2, #4]
 8026546:	b292      	uxth	r2, r2
 8026548:	2a00      	cmp	r2, #0
 802654a:	f47f af1e 	bne.w	802638a <USBD_Handle_DeviceRequest+0x6a>
                  (1U == device.Endpoints[index].IsConfigured))
 802654e:	222c      	movs	r2, #44	; 0x2c
    switch (USB_ControlRequest.bRequest)
    {
      case REQ_ClearFeature:
        if ((uint8_t)REQREC_ENDPOINT == (USB_ControlRequest.bmRequestType & (uint8_t)REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)USB_ControlRequest.wIndex & (uint32_t)ENDPOINT_EPNUM_MASK;
 8026550:	f003 030f 	and.w	r3, r3, #15
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0U == USB_ControlRequest.wIndex)) &&
                  (1U == device.Endpoints[index].IsConfigured))
 8026554:	fb02 4303 	mla	r3, r2, r3, r4
 8026558:	4914      	ldr	r1, [pc, #80]	; (80265ac <USBD_Handle_DeviceRequest+0x28c>)
 802655a:	7a1a      	ldrb	r2, [r3, #8]
    {
      case REQ_ClearFeature:
        if ((uint8_t)REQREC_ENDPOINT == (USB_ControlRequest.bmRequestType & (uint8_t)REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)USB_ControlRequest.wIndex & (uint32_t)ENDPOINT_EPNUM_MASK;
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0U == USB_ControlRequest.wIndex)) &&
 802655c:	07d5      	lsls	r5, r2, #31
 802655e:	f57f af14 	bpl.w	802638a <USBD_Handle_DeviceRequest+0x6a>
                  (1U == device.Endpoints[index].IsConfigured))
          {
            device.Endpoints[index].IsHalted = 0U;
 8026562:	891a      	ldrh	r2, [r3, #8]
 8026564:	f36f 0282 	bfc	r2, #2, #1
 8026568:	811a      	strh	r2, [r3, #8]
            if (USBD_STATUS_SUCCESS != 
                                 (USBD_STATUS_t)device.Driver->EndpointStall((uint8_t)USB_ControlRequest.wIndex,false))
 802656a:	88b0      	ldrh	r0, [r6, #4]
 802656c:	680b      	ldr	r3, [r1, #0]
 802656e:	b2c0      	uxtb	r0, r0
 8026570:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8026572:	2100      	movs	r1, #0
 8026574:	4798      	blx	r3
          index = (uint32_t)USB_ControlRequest.wIndex & (uint32_t)ENDPOINT_EPNUM_MASK;
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0U == USB_ControlRequest.wIndex)) &&
                  (1U == device.Endpoints[index].IsConfigured))
          {
            device.Endpoints[index].IsHalted = 0U;
            if (USBD_STATUS_SUCCESS != 
 8026576:	e6e5      	b.n	8026344 <USBD_Handle_DeviceRequest+0x24>
          break;
        }
        /* configured state */
        if ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState)
        {
          switch (value)
 8026578:	2d00      	cmp	r5, #0
 802657a:	d044      	beq.n	8026606 <USBD_Handle_DeviceRequest+0x2e6>
 802657c:	2d01      	cmp	r5, #1
 802657e:	f47f aee1 	bne.w	8026344 <USBD_Handle_DeviceRequest+0x24>
          {
            case FEATURE_SEL_DeviceRemoteWakeup:
              device.remote_wakeup = 1U;
 8026582:	f894 313e 	ldrb.w	r3, [r4, #318]	; 0x13e
 8026586:	f043 0304 	orr.w	r3, r3, #4
 802658a:	f884 313e 	strb.w	r3, [r4, #318]	; 0x13e
              break;
 802658e:	e6d9      	b.n	8026344 <USBD_Handle_DeviceRequest+0x24>
            XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetStatus", 0);
          }          
          break;
        }
        if ((REQREC_INTERFACE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK)) &&
            ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState))
 8026590:	4b08      	ldr	r3, [pc, #32]	; (80265b4 <USBD_Handle_DeviceRequest+0x294>)
 8026592:	781b      	ldrb	r3, [r3, #0]
          {
            XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetStatus", 0);
          }          
          break;
        }
        if ((REQREC_INTERFACE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK)) &&
 8026594:	2b04      	cmp	r3, #4
 8026596:	f47f af14 	bne.w	80263c2 <USBD_Handle_DeviceRequest+0xa2>
            ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState))
        {
          status = 0U;
 802659a:	a902      	add	r1, sp, #8
          if (0U == (uint32_t)device.Driver->EndpointWrite(0U, (uint8_t*)&status, USBD_WORD_SIZE))
 802659c:	6823      	ldr	r3, [r4, #0]
          break;
        }
        if ((REQREC_INTERFACE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK)) &&
            ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState))
        {
          status = 0U;
 802659e:	2000      	movs	r0, #0
 80265a0:	f841 0d04 	str.w	r0, [r1, #-4]!
          if (0U == (uint32_t)device.Driver->EndpointWrite(0U, (uint8_t*)&status, USBD_WORD_SIZE))
 80265a4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80265a6:	2202      	movs	r2, #2
 80265a8:	4798      	blx	r3
          {
            XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetStatus- REQREC_INTERFACE", 0);
          }          
          break;
 80265aa:	e6cb      	b.n	8026344 <USBD_Handle_DeviceRequest+0x24>
 80265ac:	2000d8f4 	.word	0x2000d8f4
 80265b0:	2000d6ec 	.word	0x2000d6ec
 80265b4:	2000d6e9 	.word	0x2000d6e9
 80265b8:	2000da2d 	.word	0x2000da2d
        break;

      case REQ_GetStatus:
        if (REQREC_DEVICE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
        {
          status = (uint32_t)((uint8_t)(device.remote_wakeup << (uint8_t)1) | device.self_powered);					
 80265bc:	f894 313e 	ldrb.w	r3, [r4, #318]	; 0x13e
          if (0U == (uint32_t)device.Driver->EndpointWrite(0U, (uint8_t*)&status, USBD_WORD_SIZE))
 80265c0:	6822      	ldr	r2, [r4, #0]
        break;

      case REQ_GetStatus:
        if (REQREC_DEVICE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
        {
          status = (uint32_t)((uint8_t)(device.remote_wakeup << (uint8_t)1) | device.self_powered);					
 80265c2:	f3c3 0580 	ubfx	r5, r3, #2, #1
 80265c6:	006d      	lsls	r5, r5, #1
 80265c8:	b2ed      	uxtb	r5, r5
 80265ca:	a902      	add	r1, sp, #8
 80265cc:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 80265d0:	432b      	orrs	r3, r5
 80265d2:	f841 3d04 	str.w	r3, [r1, #-4]!
          if (0U == (uint32_t)device.Driver->EndpointWrite(0U, (uint8_t*)&status, USBD_WORD_SIZE))
 80265d6:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80265d8:	2202      	movs	r2, #2
 80265da:	4798      	blx	r3
          {
            XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetStatus", 0);
          }          
          break;
 80265dc:	e6b2      	b.n	8026344 <USBD_Handle_DeviceRequest+0x24>
 */
static void USBD_HandleEP0_Stall(void)
{
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
 80265de:	682b      	ldr	r3, [r5, #0]
 80265e0:	2080      	movs	r0, #128	; 0x80
 80265e2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80265e4:	2101      	movs	r1, #1
 80265e6:	4798      	blx	r3
 80265e8:	2800      	cmp	r0, #0
 80265ea:	f47f aeab 	bne.w	8026344 <USBD_Handle_DeviceRequest+0x24>
 80265ee:	e6d4      	b.n	802639a <USBD_Handle_DeviceRequest+0x7a>

      case REQ_GetInterface:
        if ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState)
        {          
          if (0U == (uint32_t)device.Driver->EndpointWrite(0U, 
             &device.interface_settings[USB_ControlRequest.wIndex], 1U))
 80265f0:	88b1      	ldrh	r1, [r6, #4]
        break;

      case REQ_GetInterface:
        if ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState)
        {          
          if (0U == (uint32_t)device.Driver->EndpointWrite(0U, 
 80265f2:	6823      	ldr	r3, [r4, #0]
             &device.interface_settings[USB_ControlRequest.wIndex], 1U))
 80265f4:	b289      	uxth	r1, r1
 80265f6:	f501 719c 	add.w	r1, r1, #312	; 0x138
        break;

      case REQ_GetInterface:
        if ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState)
        {          
          if (0U == (uint32_t)device.Driver->EndpointWrite(0U, 
 80265fa:	4421      	add	r1, r4
 80265fc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80265fe:	2201      	movs	r2, #1
 8026600:	2000      	movs	r0, #0
 8026602:	4798      	blx	r3
             &device.interface_settings[USB_ControlRequest.wIndex], 1U))
          {
            XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetInterface", 0);
          }
          break;
 8026604:	e69e      	b.n	8026344 <USBD_Handle_DeviceRequest+0x24>
          {
            case FEATURE_SEL_DeviceRemoteWakeup:
              device.remote_wakeup = 1U;
              break;
            case FEATURE_SEL_EndpointHalt:
              index = ((uint32_t)USB_ControlRequest.wIndex & (uint32_t)USBD_BYTE_MASK & 
 8026606:	88b3      	ldrh	r3, [r6, #4]
 8026608:	480a      	ldr	r0, [pc, #40]	; (8026634 <USBD_Handle_DeviceRequest+0x314>)
                      (uint32_t)XMC_USBD_ENDPOINT_NUMBER_MASK);
              if (0U == device.Endpoints[index].IsConfigured)
 802660a:	490b      	ldr	r1, [pc, #44]	; (8026638 <USBD_Handle_DeviceRequest+0x318>)
 802660c:	222c      	movs	r2, #44	; 0x2c
          {
            case FEATURE_SEL_DeviceRemoteWakeup:
              device.remote_wakeup = 1U;
              break;
            case FEATURE_SEL_EndpointHalt:
              index = ((uint32_t)USB_ControlRequest.wIndex & (uint32_t)USBD_BYTE_MASK & 
 802660e:	f003 030f 	and.w	r3, r3, #15
                      (uint32_t)XMC_USBD_ENDPOINT_NUMBER_MASK);
              if (0U == device.Endpoints[index].IsConfigured)
 8026612:	fb02 4303 	mla	r3, r2, r3, r4
 8026616:	7a1a      	ldrb	r2, [r3, #8]
 8026618:	07d2      	lsls	r2, r2, #31
 802661a:	f57f af5c 	bpl.w	80264d6 <USBD_Handle_DeviceRequest+0x1b6>
              {
                USBD_HandleEP0_Stall();
              }
              else
              {
                device.Endpoints[index].IsHalted = 1U;
 802661e:	891a      	ldrh	r2, [r3, #8]
 8026620:	f042 0204 	orr.w	r2, r2, #4
 8026624:	811a      	strh	r2, [r3, #8]
                if (USBD_STATUS_SUCCESS != 
                                  (USBD_STATUS_t)device.Driver->EndpointStall((uint8_t)USB_ControlRequest.wIndex,true))
 8026626:	680b      	ldr	r3, [r1, #0]
 8026628:	8880      	ldrh	r0, [r0, #4]
 802662a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 802662c:	2101      	movs	r1, #1
 802662e:	b2c0      	uxtb	r0, r0
 8026630:	4798      	blx	r3
 8026632:	e687      	b.n	8026344 <USBD_Handle_DeviceRequest+0x24>
 8026634:	2000d6ec 	.word	0x2000d6ec
 8026638:	2000d8f4 	.word	0x2000d8f4

0802663c <USBD_SignalEndpointEvent_Handler>:
 * If the driver detects an event (See XMC_USBD_EP_EVENT_t) for a specified endpoint it calls this function.
 * Based on the event some further action is taken, e.g. process control request or update transfer information
 * and read data from the driver into the core buffer.
 */
static void USBD_SignalEndpointEvent_Handler(uint8_t ep_addr, XMC_USBD_EP_EVENT_t ep_event)
{
 802663c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  uint32_t temp_num;
  uint32_t temp_dir;

  ep =  &device.Endpoints[(ep_addr & ENDPOINT_EPNUM_MASK)];
  /* store CurrentEndpoint and direction for restore after handling */
  temp_num = (uint32_t)device.CurrentEndpoint;
 8026640:	4c72      	ldr	r4, [pc, #456]	; (802680c <USBD_SignalEndpointEvent_Handler+0x1d0>)
  USBD_Endpoint_t *ep;
  int32_t data_count;
  uint32_t temp_num;
  uint32_t temp_dir;

  ep =  &device.Endpoints[(ep_addr & ENDPOINT_EPNUM_MASK)];
 8026642:	f000 050f 	and.w	r5, r0, #15
  temp_dir = (uint32_t)device.CurrentDirection;
  /* select the given endpoint */
  device.CurrentEndpoint = ep_addr & ENDPOINT_EPNUM_MASK;
  device.CurrentDirection = ep_addr & (uint8_t)ENDPOINT_DIR_MASK;
  /* choose what to do based on the event */
  switch (ep_event)
 8026646:	2901      	cmp	r1, #1
  /* store CurrentEndpoint and direction for restore after handling */
  temp_num = (uint32_t)device.CurrentEndpoint;
  temp_dir = (uint32_t)device.CurrentDirection;
  /* select the given endpoint */
  device.CurrentEndpoint = ep_addr & ENDPOINT_EPNUM_MASK;
  device.CurrentDirection = ep_addr & (uint8_t)ENDPOINT_DIR_MASK;
 8026648:	f020 007f 	bic.w	r0, r0, #127	; 0x7f
  uint32_t temp_dir;

  ep =  &device.Endpoints[(ep_addr & ENDPOINT_EPNUM_MASK)];
  /* store CurrentEndpoint and direction for restore after handling */
  temp_num = (uint32_t)device.CurrentEndpoint;
  temp_dir = (uint32_t)device.CurrentDirection;
 802664c:	f894 713d 	ldrb.w	r7, [r4, #317]	; 0x13d
  uint32_t temp_num;
  uint32_t temp_dir;

  ep =  &device.Endpoints[(ep_addr & ENDPOINT_EPNUM_MASK)];
  /* store CurrentEndpoint and direction for restore after handling */
  temp_num = (uint32_t)device.CurrentEndpoint;
 8026650:	f894 813c 	ldrb.w	r8, [r4, #316]	; 0x13c
  temp_dir = (uint32_t)device.CurrentDirection;
  /* select the given endpoint */
  device.CurrentEndpoint = ep_addr & ENDPOINT_EPNUM_MASK;
  device.CurrentDirection = ep_addr & (uint8_t)ENDPOINT_DIR_MASK;
 8026654:	f884 013d 	strb.w	r0, [r4, #317]	; 0x13d
  USBD_Endpoint_t *ep;
  int32_t data_count;
  uint32_t temp_num;
  uint32_t temp_dir;

  ep =  &device.Endpoints[(ep_addr & ENDPOINT_EPNUM_MASK)];
 8026658:	462e      	mov	r6, r5
  /* store CurrentEndpoint and direction for restore after handling */
  temp_num = (uint32_t)device.CurrentEndpoint;
  temp_dir = (uint32_t)device.CurrentDirection;
  /* select the given endpoint */
  device.CurrentEndpoint = ep_addr & ENDPOINT_EPNUM_MASK;
 802665a:	f884 513c 	strb.w	r5, [r4, #316]	; 0x13c
  device.CurrentDirection = ep_addr & (uint8_t)ENDPOINT_DIR_MASK;
  /* choose what to do based on the event */
  switch (ep_event)
 802665e:	d067      	beq.n	8026730 <USBD_SignalEndpointEvent_Handler+0xf4>
 8026660:	d33a      	bcc.n	80266d8 <USBD_SignalEndpointEvent_Handler+0x9c>
 8026662:	2902      	cmp	r1, #2
 8026664:	d132      	bne.n	80266cc <USBD_SignalEndpointEvent_Handler+0x90>
          break;
      }
      break;
    case XMC_USBD_EP_EVENT_IN:
      /* loop write transfers */
      if (ep->InDataLeft > 0U)
 8026666:	232c      	movs	r3, #44	; 0x2c
 8026668:	fb03 4305 	mla	r3, r3, r5, r4
 802666c:	f103 0920 	add.w	r9, r3, #32
 8026670:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8026672:	2a00      	cmp	r2, #0
 8026674:	f040 8091 	bne.w	802679a <USBD_SignalEndpointEvent_Handler+0x15e>
        data_count = device.Driver->EndpointWrite((uint8_t)ep->Address,ep->InDataBuffer,ep->InDataLeft);
        ep->InDataLeft -= (uint32_t)data_count;
        ep->InDataBuffer += (uint32_t)data_count;
        break;
      }
      else if (((uint32_t)ep->Number == 0U) && (ep->InBytesAvailable > 0U) &&
 8026678:	7918      	ldrb	r0, [r3, #4]
 802667a:	0702      	lsls	r2, r0, #28
 802667c:	d114      	bne.n	80266a8 <USBD_SignalEndpointEvent_Handler+0x6c>
 802667e:	69da      	ldr	r2, [r3, #28]
 8026680:	b192      	cbz	r2, 80266a8 <USBD_SignalEndpointEvent_Handler+0x6c>
              (ep->InBytesAvailable != (uint32_t)USB_ControlRequest.wLength) &&
 8026682:	4963      	ldr	r1, [pc, #396]	; (8026810 <USBD_SignalEndpointEvent_Handler+0x1d4>)
 8026684:	88c9      	ldrh	r1, [r1, #6]
 8026686:	b289      	uxth	r1, r1
        data_count = device.Driver->EndpointWrite((uint8_t)ep->Address,ep->InDataBuffer,ep->InDataLeft);
        ep->InDataLeft -= (uint32_t)data_count;
        ep->InDataBuffer += (uint32_t)data_count;
        break;
      }
      else if (((uint32_t)ep->Number == 0U) && (ep->InBytesAvailable > 0U) &&
 8026688:	428a      	cmp	r2, r1
 802668a:	d00d      	beq.n	80266a8 <USBD_SignalEndpointEvent_Handler+0x6c>
              (ep->InBytesAvailable != (uint32_t)USB_ControlRequest.wLength) &&
              ((ep->InBytesAvailable % (uint32_t)ep->MaxPacketSize) == 0U))
 802668c:	891b      	ldrh	r3, [r3, #8]
 802668e:	f3c3 1386 	ubfx	r3, r3, #6, #7
 8026692:	fbb2 f1f3 	udiv	r1, r2, r3
 8026696:	fb03 2111 	mls	r1, r3, r1, r2
        ep->InDataLeft -= (uint32_t)data_count;
        ep->InDataBuffer += (uint32_t)data_count;
        break;
      }
      else if (((uint32_t)ep->Number == 0U) && (ep->InBytesAvailable > 0U) &&
              (ep->InBytesAvailable != (uint32_t)USB_ControlRequest.wLength) &&
 802669a:	b929      	cbnz	r1, 80266a8 <USBD_SignalEndpointEvent_Handler+0x6c>
              ((ep->InBytesAvailable % (uint32_t)ep->MaxPacketSize) == 0U))
      {
        /* if the amount of data for endpoint 0 is exact the requested
         * amount, then no zlp has to be send */
        device.Driver->EndpointWrite((uint8_t)ep->Address,0,0U);
 802669c:	6823      	ldr	r3, [r4, #0]
 802669e:	460a      	mov	r2, r1
 80266a0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80266a2:	4798      	blx	r3
 80266a4:	f894 513c 	ldrb.w	r5, [r4, #316]	; 0x13c
      }
      else
      {
      }
      ep->InBytesAvailable = 0U;
 80266a8:	f8df 9160 	ldr.w	r9, [pc, #352]	; 802680c <USBD_SignalEndpointEvent_Handler+0x1d0>
 80266ac:	232c      	movs	r3, #44	; 0x2c
 80266ae:	fb03 4606 	mla	r6, r3, r6, r4
 80266b2:	2200      	movs	r2, #0
      ep->InInUse = (uint8_t)0;
 80266b4:	8933      	ldrh	r3, [r6, #8]
        device.Driver->EndpointWrite((uint8_t)ep->Address,0,0U);
      }
      else
      {
      }
      ep->InBytesAvailable = 0U;
 80266b6:	61f2      	str	r2, [r6, #28]
      ep->InInUse = (uint8_t)0;
 80266b8:	f362 1304 	bfi	r3, r2, #4, #1
 80266bc:	8133      	strh	r3, [r6, #8]
      switch (device.CurrentEndpoint)
 80266be:	b92d      	cbnz	r5, 80266cc <USBD_SignalEndpointEvent_Handler+0x90>
 * In USBD_EP0_STATE_IN_STATUS state it starts a new read of setup packets and switches
 * to USBD_EP0_STATE_IDLE.
 */
static void USBD_HandleEP0_IN()
{
  if (USBD_EP0_STATE_IN_DATA == device.ep0_state)
 80266c0:	f899 313b 	ldrb.w	r3, [r9, #315]	; 0x13b
 80266c4:	2b02      	cmp	r3, #2
 80266c6:	d078      	beq.n	80267ba <USBD_SignalEndpointEvent_Handler+0x17e>
  {
    /* Read zero length out data packet */
    device.Driver->EndpointReadStart((uint8_t)0,0U);
    device.ep0_state = USBD_EP0_STATE_OUT_STATUS;
  }
  else if (USBD_EP0_STATE_IN_STATUS == device.ep0_state)
 80266c8:	2b03      	cmp	r3, #3
 80266ca:	d04e      	beq.n	802676a <USBD_SignalEndpointEvent_Handler+0x12e>
      }
      break;
    default:
      break;
  }
  device.CurrentEndpoint = (uint8_t)temp_num;
 80266cc:	f884 813c 	strb.w	r8, [r4, #316]	; 0x13c
  device.CurrentDirection = (uint8_t)temp_dir;
 80266d0:	f884 713d 	strb.w	r7, [r4, #317]	; 0x13d
 80266d4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  device.CurrentDirection = ep_addr & (uint8_t)ENDPOINT_DIR_MASK;
  /* choose what to do based on the event */
  switch (ep_event)
  {
    case XMC_USBD_EP_EVENT_SETUP:
      ep->OutInUse = 0U;
 80266d8:	232c      	movs	r3, #44	; 0x2c
 80266da:	fb03 4305 	mla	r3, r3, r5, r4
 80266de:	891a      	ldrh	r2, [r3, #8]
 80266e0:	f36f 02c3 	bfc	r2, #3, #1
 80266e4:	811a      	strh	r2, [r3, #8]
      switch (device.CurrentEndpoint)
 80266e6:	2d00      	cmp	r5, #0
 80266e8:	d1f0      	bne.n	80266cc <USBD_SignalEndpointEvent_Handler+0x90>
static void USBD_HandleEP0_SETUP()
{
  /* read setup packet from ep0 */
  uint32_t ret_val;

  ret_val = (uint32_t)device.Driver->EndpointRead((uint8_t)0,(void*)&USB_ControlRequest,
 80266ea:	6823      	ldr	r3, [r4, #0]
 80266ec:	4e48      	ldr	r6, [pc, #288]	; (8026810 <USBD_SignalEndpointEvent_Handler+0x1d4>)
 80266ee:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80266f0:	4631      	mov	r1, r6
 80266f2:	4628      	mov	r0, r5
 80266f4:	2208      	movs	r2, #8
 80266f6:	4798      	blx	r3
            (uint32_t)USBD_EP0_SETUP_PKT_SIZE);
  device.IsSetupRecieved = (uint8_t)true;
 80266f8:	f894 313e 	ldrb.w	r3, [r4, #318]	; 0x13e

  if ((uint32_t)USBD_EP0_SETUP_PKT_SIZE == ret_val)
 80266fc:	2808      	cmp	r0, #8
  /* read setup packet from ep0 */
  uint32_t ret_val;

  ret_val = (uint32_t)device.Driver->EndpointRead((uint8_t)0,(void*)&USB_ControlRequest,
            (uint32_t)USBD_EP0_SETUP_PKT_SIZE);
  device.IsSetupRecieved = (uint8_t)true;
 80266fe:	f043 0302 	orr.w	r3, r3, #2
 8026702:	f884 313e 	strb.w	r3, [r4, #318]	; 0x13e

  if ((uint32_t)USBD_EP0_SETUP_PKT_SIZE == ret_val)
 8026706:	d1e1      	bne.n	80266cc <USBD_SignalEndpointEvent_Handler+0x90>
  {
    /* if length is zero we have only a in_status phase */
    if (0U == (uint32_t)USB_ControlRequest.wLength)
 8026708:	f8b6 9006 	ldrh.w	r9, [r6, #6]
 802670c:	fa1f f989 	uxth.w	r9, r9
 8026710:	f1b9 0f00 	cmp.w	r9, #0
 8026714:	d068      	beq.n	80267e8 <USBD_SignalEndpointEvent_Handler+0x1ac>
      USBD_Handle_DeviceRequest();
      device.Driver->EndpointWrite((uint8_t)0, (uint8_t*)0, (uint32_t)0);
    }
    else
    {
      if (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_DIRECTION)
 8026716:	7833      	ldrb	r3, [r6, #0]
 8026718:	0619      	lsls	r1, r3, #24
 802671a:	d471      	bmi.n	8026800 <USBD_SignalEndpointEvent_Handler+0x1c4>
      }
      else
      {
        device.ep0_state = USBD_EP0_STATE_OUT_DATA;
        /* Do not process request here, first read data */
        device.Driver->EndpointReadStart((uint8_t)0, (uint32_t)USB_ControlRequest.wLength);
 802671c:	88f1      	ldrh	r1, [r6, #6]
 802671e:	6823      	ldr	r3, [r4, #0]
        device.ep0_state = USBD_EP0_STATE_IN_DATA;
        USBD_Handle_DeviceRequest();
      }
      else
      {
        device.ep0_state = USBD_EP0_STATE_OUT_DATA;
 8026720:	2204      	movs	r2, #4
        /* Do not process request here, first read data */
        device.Driver->EndpointReadStart((uint8_t)0, (uint32_t)USB_ControlRequest.wLength);
 8026722:	6a9b      	ldr	r3, [r3, #40]	; 0x28
        device.ep0_state = USBD_EP0_STATE_IN_DATA;
        USBD_Handle_DeviceRequest();
      }
      else
      {
        device.ep0_state = USBD_EP0_STATE_OUT_DATA;
 8026724:	f884 213b 	strb.w	r2, [r4, #315]	; 0x13b
        /* Do not process request here, first read data */
        device.Driver->EndpointReadStart((uint8_t)0, (uint32_t)USB_ControlRequest.wLength);
 8026728:	b289      	uxth	r1, r1
 802672a:	4628      	mov	r0, r5
 802672c:	4798      	blx	r3
 802672e:	e7cd      	b.n	80266cc <USBD_SignalEndpointEvent_Handler+0x90>
        default:
          break;
      }
      break;
    case XMC_USBD_EP_EVENT_OUT:
      ep->IsOutRecieved = 1U;
 8026730:	232c      	movs	r3, #44	; 0x2c
 8026732:	fb03 4305 	mla	r3, r3, r5, r4
 8026736:	4699      	mov	r9, r3
 8026738:	891a      	ldrh	r2, [r3, #8]
 802673a:	f042 0220 	orr.w	r2, r2, #32
 802673e:	f829 2f08 	strh.w	r2, [r9, #8]!
      if (ep->OutBytesAvailable == 0U)
 8026742:	f8d9 2004 	ldr.w	r2, [r9, #4]
 8026746:	b1da      	cbz	r2, 8026780 <USBD_SignalEndpointEvent_Handler+0x144>
      {
        ep->OutOffset = 0U; /* clear offset, new data is there */
        ep->OutBytesAvailable = (uint32_t)device.Driver->EndpointRead((uint8_t)ep->Address,
                                ep->OutBuffer,ep->OutBufferLength);
      }
      ep->OutInUse = (uint8_t)0;
 8026748:	232c      	movs	r3, #44	; 0x2c
 802674a:	fb03 4606 	mla	r6, r3, r6, r4
 802674e:	f8df 90bc 	ldr.w	r9, [pc, #188]	; 802680c <USBD_SignalEndpointEvent_Handler+0x1d0>
 8026752:	8933      	ldrh	r3, [r6, #8]
 8026754:	f36f 03c3 	bfc	r3, #3, #1
 8026758:	8133      	strh	r3, [r6, #8]
      switch (device.CurrentEndpoint)
 802675a:	2d00      	cmp	r5, #0
 802675c:	d1b6      	bne.n	80266cc <USBD_SignalEndpointEvent_Handler+0x90>
 * USBD_EP0_STATE_OUT_DATA state, it handles the received data and starts a write
 * transaction for \ref USBD_EP0_STATE_IN_STATUS.
 */
static void USBD_HandleEP0_OUT()
{
  if (USBD_EP0_STATE_OUT_DATA == device.ep0_state)
 802675e:	f899 313b 	ldrb.w	r3, [r9, #315]	; 0x13b
 8026762:	2b04      	cmp	r3, #4
 8026764:	d033      	beq.n	80267ce <USBD_SignalEndpointEvent_Handler+0x192>
    USBD_Handle_DeviceRequest();
    /* Zero length packet for status stage */
    device.Driver->EndpointWrite((uint8_t)0,(uint8_t*)0,(uint32_t)0);
    device.ep0_state = USBD_EP0_STATE_IN_STATUS;
  }
  else if (USBD_EP0_STATE_OUT_STATUS == device.ep0_state)
 8026766:	2b05      	cmp	r3, #5
 8026768:	d1b0      	bne.n	80266cc <USBD_SignalEndpointEvent_Handler+0x90>
    device.ep0_state = USBD_EP0_STATE_OUT_STATUS;
  }
  else if (USBD_EP0_STATE_IN_STATUS == device.ep0_state)
  {
    /* Request new setup packet */
    device.Driver->EndpointReadStart((uint8_t)device.Endpoints[0].Address,(uint32_t)USBD_EP0_3SETUP_PKT_SIZE);
 802676a:	f8d9 3000 	ldr.w	r3, [r9]
 802676e:	f899 0004 	ldrb.w	r0, [r9, #4]
 8026772:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8026774:	2118      	movs	r1, #24
 8026776:	4798      	blx	r3
    device.ep0_state = USBD_EP0_STATE_IDLE;
 8026778:	2301      	movs	r3, #1
 802677a:	f889 313b 	strb.w	r3, [r9, #315]	; 0x13b
 802677e:	e7a5      	b.n	80266cc <USBD_SignalEndpointEvent_Handler+0x90>
    case XMC_USBD_EP_EVENT_OUT:
      ep->IsOutRecieved = 1U;
      if (ep->OutBytesAvailable == 0U)
      {
        ep->OutOffset = 0U; /* clear offset, new data is there */
        ep->OutBytesAvailable = (uint32_t)device.Driver->EndpointRead((uint8_t)ep->Address,
 8026780:	6821      	ldr	r1, [r4, #0]
      break;
    case XMC_USBD_EP_EVENT_OUT:
      ep->IsOutRecieved = 1U;
      if (ep->OutBytesAvailable == 0U)
      {
        ep->OutOffset = 0U; /* clear offset, new data is there */
 8026782:	f8c9 2008 	str.w	r2, [r9, #8]
        ep->OutBytesAvailable = (uint32_t)device.Driver->EndpointRead((uint8_t)ep->Address,
 8026786:	6acd      	ldr	r5, [r1, #44]	; 0x2c
 8026788:	7918      	ldrb	r0, [r3, #4]
 802678a:	6959      	ldr	r1, [r3, #20]
 802678c:	699a      	ldr	r2, [r3, #24]
 802678e:	47a8      	blx	r5
 8026790:	f894 513c 	ldrb.w	r5, [r4, #316]	; 0x13c
 8026794:	f8c9 0004 	str.w	r0, [r9, #4]
 8026798:	e7d6      	b.n	8026748 <USBD_SignalEndpointEvent_Handler+0x10c>
      break;
    case XMC_USBD_EP_EVENT_IN:
      /* loop write transfers */
      if (ep->InDataLeft > 0U)
      {
        data_count = device.Driver->EndpointWrite((uint8_t)ep->Address,ep->InDataBuffer,ep->InDataLeft);
 802679a:	6821      	ldr	r1, [r4, #0]
 802679c:	7918      	ldrb	r0, [r3, #4]
 802679e:	6b0e      	ldr	r6, [r1, #48]	; 0x30
 80267a0:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 80267a2:	f103 0528 	add.w	r5, r3, #40	; 0x28
 80267a6:	47b0      	blx	r6
        ep->InDataLeft -= (uint32_t)data_count;
        ep->InDataBuffer += (uint32_t)data_count;
 80267a8:	686a      	ldr	r2, [r5, #4]
    case XMC_USBD_EP_EVENT_IN:
      /* loop write transfers */
      if (ep->InDataLeft > 0U)
      {
        data_count = device.Driver->EndpointWrite((uint8_t)ep->Address,ep->InDataBuffer,ep->InDataLeft);
        ep->InDataLeft -= (uint32_t)data_count;
 80267aa:	f8d9 3008 	ldr.w	r3, [r9, #8]
        ep->InDataBuffer += (uint32_t)data_count;
 80267ae:	4402      	add	r2, r0
    case XMC_USBD_EP_EVENT_IN:
      /* loop write transfers */
      if (ep->InDataLeft > 0U)
      {
        data_count = device.Driver->EndpointWrite((uint8_t)ep->Address,ep->InDataBuffer,ep->InDataLeft);
        ep->InDataLeft -= (uint32_t)data_count;
 80267b0:	1a1b      	subs	r3, r3, r0
        ep->InDataBuffer += (uint32_t)data_count;
 80267b2:	606a      	str	r2, [r5, #4]
    case XMC_USBD_EP_EVENT_IN:
      /* loop write transfers */
      if (ep->InDataLeft > 0U)
      {
        data_count = device.Driver->EndpointWrite((uint8_t)ep->Address,ep->InDataBuffer,ep->InDataLeft);
        ep->InDataLeft -= (uint32_t)data_count;
 80267b4:	f8c9 3008 	str.w	r3, [r9, #8]
        ep->InDataBuffer += (uint32_t)data_count;
        break;
 80267b8:	e788      	b.n	80266cc <USBD_SignalEndpointEvent_Handler+0x90>
static void USBD_HandleEP0_IN()
{
  if (USBD_EP0_STATE_IN_DATA == device.ep0_state)
  {
    /* Read zero length out data packet */
    device.Driver->EndpointReadStart((uint8_t)0,0U);
 80267ba:	f8d9 3000 	ldr.w	r3, [r9]
 80267be:	4628      	mov	r0, r5
 80267c0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80267c2:	4629      	mov	r1, r5
 80267c4:	4798      	blx	r3
    device.ep0_state = USBD_EP0_STATE_OUT_STATUS;
 80267c6:	2305      	movs	r3, #5
 80267c8:	f889 313b 	strb.w	r3, [r9, #315]	; 0x13b
 80267cc:	e77e      	b.n	80266cc <USBD_SignalEndpointEvent_Handler+0x90>
static void USBD_HandleEP0_OUT()
{
  if (USBD_EP0_STATE_OUT_DATA == device.ep0_state)
  {
    /* Now we have the data for handling the request */
    USBD_Handle_DeviceRequest();
 80267ce:	f7ff fda7 	bl	8026320 <USBD_Handle_DeviceRequest>
    /* Zero length packet for status stage */
    device.Driver->EndpointWrite((uint8_t)0,(uint8_t*)0,(uint32_t)0);
 80267d2:	f8d9 3000 	ldr.w	r3, [r9]
 80267d6:	4628      	mov	r0, r5
 80267d8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80267da:	4629      	mov	r1, r5
 80267dc:	462a      	mov	r2, r5
 80267de:	4798      	blx	r3
    device.ep0_state = USBD_EP0_STATE_IN_STATUS;
 80267e0:	2303      	movs	r3, #3
 80267e2:	f889 313b 	strb.w	r3, [r9, #315]	; 0x13b
 80267e6:	e771      	b.n	80266cc <USBD_SignalEndpointEvent_Handler+0x90>
  if ((uint32_t)USBD_EP0_SETUP_PKT_SIZE == ret_val)
  {
    /* if length is zero we have only a in_status phase */
    if (0U == (uint32_t)USB_ControlRequest.wLength)
    {
      device.ep0_state = USBD_EP0_STATE_IN_STATUS;
 80267e8:	2303      	movs	r3, #3
 80267ea:	f884 313b 	strb.w	r3, [r4, #315]	; 0x13b
      USBD_Handle_DeviceRequest();
 80267ee:	f7ff fd97 	bl	8026320 <USBD_Handle_DeviceRequest>
      device.Driver->EndpointWrite((uint8_t)0, (uint8_t*)0, (uint32_t)0);
 80267f2:	6823      	ldr	r3, [r4, #0]
 80267f4:	4648      	mov	r0, r9
 80267f6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80267f8:	4649      	mov	r1, r9
 80267fa:	464a      	mov	r2, r9
 80267fc:	4798      	blx	r3
 80267fe:	e765      	b.n	80266cc <USBD_SignalEndpointEvent_Handler+0x90>
    }
    else
    {
      if (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_DIRECTION)
      {
        device.ep0_state = USBD_EP0_STATE_IN_DATA;
 8026800:	2302      	movs	r3, #2
 8026802:	f884 313b 	strb.w	r3, [r4, #315]	; 0x13b
        USBD_Handle_DeviceRequest();
 8026806:	f7ff fd8b 	bl	8026320 <USBD_Handle_DeviceRequest>
 802680a:	e75f      	b.n	80266cc <USBD_SignalEndpointEvent_Handler+0x90>
 802680c:	2000d8f4 	.word	0x2000d8f4
 8026810:	2000d6ec 	.word	0x2000d6ec

08026814 <USBD_Init>:
 * Intializes the USB driver core data structures and sets it into default
 * state. Afterwards it initializes the USB device controller driver and prepare
 *  it for connection via USBD_Connect.
 */
USBD_STATUS_t USBD_Init(USBD_t *handle)
{
 8026814:	b570      	push	{r4, r5, r6, lr}
	/* Disable USB to resolve the disconnect issue on self powered devices.
	 * Later in the XMC_USBD_Init() it enables the USB.
	 */
	XMC_USBD_Disable();

	memset(&device,0x0,sizeof(USB_Device_t));
 8026816:	4c3b      	ldr	r4, [pc, #236]	; (8026904 <USBD_Init+0xf0>)
 * Intializes the USB driver core data structures and sets it into default
 * state. Afterwards it initializes the USB device controller driver and prepare
 *  it for connection via USBD_Connect.
 */
USBD_STATUS_t USBD_Init(USBD_t *handle)
{
 8026818:	4605      	mov	r5, r0


	/* Disable USB to resolve the disconnect issue on self powered devices.
	 * Later in the XMC_USBD_Init() it enables the USB.
	 */
	XMC_USBD_Disable();
 802681a:	f7fc ffa9 	bl	8023770 <XMC_USBD_Disable>

	memset(&device,0x0,sizeof(USB_Device_t));
 802681e:	2100      	movs	r1, #0
 8026820:	f44f 72a2 	mov.w	r2, #324	; 0x144
 8026824:	4620      	mov	r0, r4
 8026826:	f008 f9ca 	bl	802ebbe <memset>
	USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
 802682a:	4b37      	ldr	r3, [pc, #220]	; (8026908 <USBD_Init+0xf4>)
	device.Driver = &Driver_USBD0;
 802682c:	4837      	ldr	r0, [pc, #220]	; (802690c <USBD_Init+0xf8>)
 802682e:	6020      	str	r0, [r4, #0]
	device.Endpoints[0].InBuffer = endpoint0_in_buffer;
	device.Endpoints[0].InBufferLength = USBD_EP0_BUF_SIZE;
	device.Endpoints[0].OutBuffer = endpoint0_out_buffer;
	device.Endpoints[0].OutBufferLength = USBD_EP0_BUF_SIZE;
	device.Endpoints[0].Direction = (uint8_t)0;
	device.Endpoints[0].IsConfigured = (uint8_t)1;
 8026830:	2601      	movs	r6, #1
	 * Later in the XMC_USBD_Init() it enables the USB.
	 */
	XMC_USBD_Disable();

	memset(&device,0x0,sizeof(USB_Device_t));
	USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
 8026832:	2000      	movs	r0, #0
 8026834:	7018      	strb	r0, [r3, #0]
	device.Endpoints[0].InBuffer = endpoint0_in_buffer;
	device.Endpoints[0].InBufferLength = USBD_EP0_BUF_SIZE;
	device.Endpoints[0].OutBuffer = endpoint0_out_buffer;
	device.Endpoints[0].OutBufferLength = USBD_EP0_BUF_SIZE;
	device.Endpoints[0].Direction = (uint8_t)0;
	device.Endpoints[0].IsConfigured = (uint8_t)1;
 8026836:	7226      	strb	r6, [r4, #8]
	device.Endpoints[0].IsEnabled = (uint8_t)1;
 8026838:	8923      	ldrh	r3, [r4, #8]
	USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
	device.Driver = &Driver_USBD0;
	device.ep0_state = USBD_EP0_STATE_IDLE;
	device.Endpoints[0].InBuffer = endpoint0_in_buffer;
	device.Endpoints[0].InBufferLength = USBD_EP0_BUF_SIZE;
	device.Endpoints[0].OutBuffer = endpoint0_out_buffer;
 802683a:	4a35      	ldr	r2, [pc, #212]	; (8026910 <USBD_Init+0xfc>)
 802683c:	6162      	str	r2, [r4, #20]
	device.Endpoints[0].OutBufferLength = USBD_EP0_BUF_SIZE;
	device.Endpoints[0].Direction = (uint8_t)0;
	device.Endpoints[0].IsConfigured = (uint8_t)1;
	device.Endpoints[0].IsEnabled = (uint8_t)1;
 802683e:	f043 0302 	orr.w	r3, r3, #2
 8026842:	8123      	strh	r3, [r4, #8]
	device.Endpoints[0].MaxPacketSize = (uint8_t)USBD_EP0_MAX_PKT_SIZE;
 8026844:	8923      	ldrh	r3, [r4, #8]

	memset(&device,0x0,sizeof(USB_Device_t));
	USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
	device.Driver = &Driver_USBD0;
	device.ep0_state = USBD_EP0_STATE_IDLE;
	device.Endpoints[0].InBuffer = endpoint0_in_buffer;
 8026846:	4933      	ldr	r1, [pc, #204]	; (8026914 <USBD_Init+0x100>)
 8026848:	6221      	str	r1, [r4, #32]
	device.Endpoints[0].OutBuffer = endpoint0_out_buffer;
	device.Endpoints[0].OutBufferLength = USBD_EP0_BUF_SIZE;
	device.Endpoints[0].Direction = (uint8_t)0;
	device.Endpoints[0].IsConfigured = (uint8_t)1;
	device.Endpoints[0].IsEnabled = (uint8_t)1;
	device.Endpoints[0].MaxPacketSize = (uint8_t)USBD_EP0_MAX_PKT_SIZE;
 802684a:	2240      	movs	r2, #64	; 0x40
 802684c:	f362 138c 	bfi	r3, r2, #6, #7
 8026850:	8123      	strh	r3, [r4, #8]

	if ((handle->event_cb->control_request == 0) ||
 8026852:	692b      	ldr	r3, [r5, #16]
 8026854:	68d9      	ldr	r1, [r3, #12]
	XMC_USBD_Disable();

	memset(&device,0x0,sizeof(USB_Device_t));
	USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
	device.Driver = &Driver_USBD0;
	device.ep0_state = USBD_EP0_STATE_IDLE;
 8026856:	f884 613b 	strb.w	r6, [r4, #315]	; 0x13b
	device.Endpoints[0].InBuffer = endpoint0_in_buffer;
	device.Endpoints[0].InBufferLength = USBD_EP0_BUF_SIZE;
 802685a:	f44f 7280 	mov.w	r2, #256	; 0x100
	XMC_USBD_Disable();

	memset(&device,0x0,sizeof(USB_Device_t));
	USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
	device.Driver = &Driver_USBD0;
	device.ep0_state = USBD_EP0_STATE_IDLE;
 802685e:	4630      	mov	r0, r6
	device.Endpoints[0].InBuffer = endpoint0_in_buffer;
	device.Endpoints[0].InBufferLength = USBD_EP0_BUF_SIZE;
 8026860:	6262      	str	r2, [r4, #36]	; 0x24
	device.Endpoints[0].OutBuffer = endpoint0_out_buffer;
	device.Endpoints[0].OutBufferLength = USBD_EP0_BUF_SIZE;
 8026862:	61a2      	str	r2, [r4, #24]
	device.Endpoints[0].Direction = (uint8_t)0;
	device.Endpoints[0].IsConfigured = (uint8_t)1;
	device.Endpoints[0].IsEnabled = (uint8_t)1;
	device.Endpoints[0].MaxPacketSize = (uint8_t)USBD_EP0_MAX_PKT_SIZE;

	if ((handle->event_cb->control_request == 0) ||
 8026864:	b321      	cbz	r1, 80268b0 <USBD_Init+0x9c>
 8026866:	695a      	ldr	r2, [r3, #20]
 8026868:	b312      	cbz	r2, 80268b0 <USBD_Init+0x9c>
	    (handle->event_cb->get_descriptor == 0) ||
 802686a:	689a      	ldr	r2, [r3, #8]
 802686c:	b302      	cbz	r2, 80268b0 <USBD_Init+0x9c>
	{
	  status = USBD_STATUS_FAILURE;
	}
	else
	{
	  device.events = handle->event_cb;
 802686e:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140

	  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_USB);
 8026872:	f7fa ffa3 	bl	80217bc <XMC_SCU_CLOCK_EnableClock>

	  /* First initalize the device */
	  handle->usb_init.cb_xmc_device_event = USBD_SignalDeviceEventHandler;
	  handle->usb_init.cb_endpoint_event = USBD_SignalEndpointEvent_Handler;

	  status = (USBD_STATUS_t)device.Driver->Initialize(&handle->usb_init);
 8026876:	6823      	ldr	r3, [r4, #0]
	  device.events = handle->event_cb;

	  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_USB);

	  /* First initalize the device */
	  handle->usb_init.cb_xmc_device_event = USBD_SignalDeviceEventHandler;
 8026878:	4927      	ldr	r1, [pc, #156]	; (8026918 <USBD_Init+0x104>)
	  handle->usb_init.cb_endpoint_event = USBD_SignalEndpointEvent_Handler;
 802687a:	4a28      	ldr	r2, [pc, #160]	; (802691c <USBD_Init+0x108>)

	  status = (USBD_STATUS_t)device.Driver->Initialize(&handle->usb_init);
 802687c:	685b      	ldr	r3, [r3, #4]
	  device.events = handle->event_cb;

	  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_USB);

	  /* First initalize the device */
	  handle->usb_init.cb_xmc_device_event = USBD_SignalDeviceEventHandler;
 802687e:	6069      	str	r1, [r5, #4]
	  handle->usb_init.cb_endpoint_event = USBD_SignalEndpointEvent_Handler;
 8026880:	60aa      	str	r2, [r5, #8]

	  status = (USBD_STATUS_t)device.Driver->Initialize(&handle->usb_init);
 8026882:	4628      	mov	r0, r5
 8026884:	4798      	blx	r3
	  if (USBD_STATUS_SUCCESS == status)
 8026886:	4605      	mov	r5, r0
 8026888:	b1a8      	cbz	r0, 80268b6 <USBD_Init+0xa2>
	       (uint16_t)XMC_USBD_MAX_PACKET_SIZE);
	  }

	  if (USBD_STATUS_SUCCESS != status)
	  {
	  XMC_USBD_Disable();
 802688a:	f7fc ff71 	bl	8023770 <XMC_USBD_Disable>
	  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->Uninitialize())
 802688e:	6823      	ldr	r3, [r4, #0]
 8026890:	689b      	ldr	r3, [r3, #8]
 8026892:	4798      	blx	r3
 8026894:	b950      	cbnz	r0, 80268ac <USBD_Init+0x98>
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8026896:	4b22      	ldr	r3, [pc, #136]	; (8026920 <USBD_Init+0x10c>)
 8026898:	f44f 6200 	mov.w	r2, #2048	; 0x800
 802689c:	f8c3 218c 	str.w	r2, [r3, #396]	; 0x18c
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80268a0:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 80268a4:	f3bf 8f4f 	dsb	sy
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 80268a8:	f3bf 8f6f 	isb	sy
	  }
	}


	return status;
}
 80268ac:	4628      	mov	r0, r5
 80268ae:	bd70      	pop	{r4, r5, r6, pc}

	if ((handle->event_cb->control_request == 0) ||
	    (handle->event_cb->get_descriptor == 0) ||
	    (handle->event_cb->config_changed == 0))
	{
	  status = USBD_STATUS_FAILURE;
 80268b0:	4605      	mov	r5, r0
	  }
	}


	return status;
}
 80268b2:	4628      	mov	r0, r5
 80268b4:	bd70      	pop	{r4, r5, r6, pc}
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80268b6:	4b1b      	ldr	r3, [pc, #108]	; (8026924 <USBD_Init+0x110>)
 80268b8:	68db      	ldr	r3, [r3, #12]
 80268ba:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80268be:	f1c3 0107 	rsb	r1, r3, #7
 80268c2:	2906      	cmp	r1, #6
 80268c4:	bf28      	it	cs
 80268c6:	2106      	movcs	r1, #6
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80268c8:	b1cb      	cbz	r3, 80268fe <USBD_Init+0xea>
 80268ca:	1e5a      	subs	r2, r3, #1

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80268cc:	2301      	movs	r3, #1
 80268ce:	408b      	lsls	r3, r1
 80268d0:	3b01      	subs	r3, #1
 80268d2:	4093      	lsls	r3, r2
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80268d4:	009b      	lsls	r3, r3, #2
 80268d6:	4a12      	ldr	r2, [pc, #72]	; (8026920 <USBD_Init+0x10c>)
 80268d8:	b2db      	uxtb	r3, r3
 80268da:	f882 336b 	strb.w	r3, [r2, #875]	; 0x36b
	  {
	  /* Enable Interrupts in NVIC */
	  USB_EnableUSBInterrupt();

	  /* then configure endpoint 0 */
	  status = (USBD_STATUS_t)device.Driver->EndpointConfigure((uint8_t)0,XMC_USBD_ENDPOINT_TYPE_CONTROL,
 80268de:	6823      	ldr	r3, [r4, #0]
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80268e0:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80268e4:	2000      	movs	r0, #0
 80268e6:	f8c2 118c 	str.w	r1, [r2, #396]	; 0x18c
 80268ea:	69db      	ldr	r3, [r3, #28]
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80268ec:	60d1      	str	r1, [r2, #12]
 80268ee:	4601      	mov	r1, r0
 80268f0:	2240      	movs	r2, #64	; 0x40
 80268f2:	4798      	blx	r3
	       (uint16_t)XMC_USBD_MAX_PACKET_SIZE);
	  }

	  if (USBD_STATUS_SUCCESS != status)
 80268f4:	4605      	mov	r5, r0
 80268f6:	2800      	cmp	r0, #0
 80268f8:	d1c7      	bne.n	802688a <USBD_Init+0x76>
	  }
	}


	return status;
}
 80268fa:	4628      	mov	r0, r5
 80268fc:	bd70      	pop	{r4, r5, r6, pc}
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80268fe:	461a      	mov	r2, r3
 8026900:	e7e4      	b.n	80268cc <USBD_Init+0xb8>
 8026902:	bf00      	nop
 8026904:	2000d8f4 	.word	0x2000d8f4
 8026908:	2000d6e9 	.word	0x2000d6e9
 802690c:	080309f4 	.word	0x080309f4
 8026910:	2000d7f4 	.word	0x2000d7f4
 8026914:	2000d6f4 	.word	0x2000d6f4
 8026918:	08025ff5 	.word	0x08025ff5
 802691c:	0802663d 	.word	0x0802663d
 8026920:	e000e100 	.word	0xe000e100
 8026924:	e000ed00 	.word	0xe000ed00

08026928 <USBD_Connect>:
 * Tell the USB device controller driver to connect to the bus. Successful connection will be shown
 * through update of the device status ( USB_DeviceState) and a firing of the USB device connect event.
 */
USBD_STATUS_t USBD_Connect(void)
{
  return (USBD_STATUS_t)device.Driver->DeviceConnect();
 8026928:	4b01      	ldr	r3, [pc, #4]	; (8026930 <USBD_Connect+0x8>)
 802692a:	681b      	ldr	r3, [r3, #0]
 802692c:	68db      	ldr	r3, [r3, #12]
 802692e:	4718      	bx	r3
 8026930:	2000d8f4 	.word	0x2000d8f4

08026934 <USBD_IsEnumDone>:
 * Check with the USB device controller driver if the enumeration is done.
 * Returns 1 on completion of enumeration.
 */
uint32_t USBD_IsEnumDone(void)
{
  return device.Driver->IsEnumDone();
 8026934:	4b01      	ldr	r3, [pc, #4]	; (802693c <USBD_IsEnumDone+0x8>)
 8026936:	681b      	ldr	r3, [r3, #0]
 8026938:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 802693a:	4718      	bx	r3
 802693c:	2000d8f4 	.word	0x2000d8f4

08026940 <USBD_SetEndpointBuffer>:
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid buffer", (buf != NULL));

  number = (uint32_t)addr & (uint32_t)ENDPOINT_EPNUM_MASK;
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid ep address", (number < (uint8_t)USBD_MAX_NUM_EPS));

  if (addr & (uint8_t)ENDPOINT_DIR_MASK)
 8026940:	f010 0f80 	tst.w	r0, #128	; 0x80
 *
 * The user has to ensure that an endpoint has a valid buffer for proper data transfer.
 *
 */
void USBD_SetEndpointBuffer(uint8_t addr, uint8_t *buf, uint16_t len)
{
 8026944:	b410      	push	{r4}
  number = (uint32_t)addr & (uint32_t)ENDPOINT_EPNUM_MASK;
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid ep address", (number < (uint8_t)USBD_MAX_NUM_EPS));

  if (addr & (uint8_t)ENDPOINT_DIR_MASK)
  {
    device.Endpoints[number].InBuffer = buf;
 8026946:	4b0a      	ldr	r3, [pc, #40]	; (8026970 <USBD_SetEndpointBuffer+0x30>)
void USBD_SetEndpointBuffer(uint8_t addr, uint8_t *buf, uint16_t len)
{
  uint32_t number;
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid buffer", (buf != NULL));

  number = (uint32_t)addr & (uint32_t)ENDPOINT_EPNUM_MASK;
 8026948:	f000 040f 	and.w	r4, r0, #15
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid ep address", (number < (uint8_t)USBD_MAX_NUM_EPS));

  if (addr & (uint8_t)ENDPOINT_DIR_MASK)
  {
    device.Endpoints[number].InBuffer = buf;
 802694c:	f04f 002c 	mov.w	r0, #44	; 0x2c
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid buffer", (buf != NULL));

  number = (uint32_t)addr & (uint32_t)ENDPOINT_EPNUM_MASK;
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid ep address", (number < (uint8_t)USBD_MAX_NUM_EPS));

  if (addr & (uint8_t)ENDPOINT_DIR_MASK)
 8026950:	d106      	bne.n	8026960 <USBD_SetEndpointBuffer+0x20>
    device.Endpoints[number].InBuffer = buf;
    device.Endpoints[number].InBufferLength = len;
  }
  else
  {
    device.Endpoints[number].OutBuffer = buf;
 8026952:	fb00 3304 	mla	r3, r0, r4, r3
    device.Endpoints[number].OutBufferLength = len;
  }

}
 8026956:	f85d 4b04 	ldr.w	r4, [sp], #4
    device.Endpoints[number].InBuffer = buf;
    device.Endpoints[number].InBufferLength = len;
  }
  else
  {
    device.Endpoints[number].OutBuffer = buf;
 802695a:	6159      	str	r1, [r3, #20]
    device.Endpoints[number].OutBufferLength = len;
 802695c:	619a      	str	r2, [r3, #24]
  }

}
 802695e:	4770      	bx	lr
  number = (uint32_t)addr & (uint32_t)ENDPOINT_EPNUM_MASK;
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid ep address", (number < (uint8_t)USBD_MAX_NUM_EPS));

  if (addr & (uint8_t)ENDPOINT_DIR_MASK)
  {
    device.Endpoints[number].InBuffer = buf;
 8026960:	fb00 3404 	mla	r4, r0, r4, r3
 8026964:	6221      	str	r1, [r4, #32]
    device.Endpoints[number].InBufferLength = len;
 8026966:	6262      	str	r2, [r4, #36]	; 0x24
  {
    device.Endpoints[number].OutBuffer = buf;
    device.Endpoints[number].OutBufferLength = len;
  }

}
 8026968:	f85d 4b04 	ldr.w	r4, [sp], #4
 802696c:	4770      	bx	lr
 802696e:	bf00      	nop
 8026970:	2000d8f4 	.word	0x2000d8f4

08026974 <USB0_0_IRQHandler>:
 * This function gets called, if a USB exception (interrupt) was thrown and
 * dispatches it to XMC_USBD_IRQHandler.
 */
void USB0_0_IRQHandler(void)
{
  XMC_USBD_IRQHandler(&(USBD_handle->usb_init));
 8026974:	4b01      	ldr	r3, [pc, #4]	; (802697c <USB0_0_IRQHandler+0x8>)
 8026976:	6818      	ldr	r0, [r3, #0]
 8026978:	f7fc ba8e 	b.w	8022e98 <XMC_USBD_IRQHandler>
 802697c:	1ffe88e0 	.word	0x1ffe88e0

08026980 <TIMER_Init>:
/*
 * This function initializes a TIMER APP based on user configuration.
 *
 */
TIMER_STATUS_t TIMER_Init(TIMER_t* const handle_ptr)
{
 8026980:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  XMC_ASSERT("TIMER_Init:handle_ptr NULL" , (handle_ptr != NULL));

  status = TIMER_STATUS_SUCCESS;
  /* Check for APP instance is initialized or not */
  if (false == handle_ptr->initialized)
 8026982:	f890 303a 	ldrb.w	r3, [r0, #58]	; 0x3a
 8026986:	b943      	cbnz	r3, 802699a <TIMER_Init+0x1a>
  {
#ifdef TIMER_CCU4_USED
    if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8026988:	f890 5035 	ldrb.w	r5, [r0, #53]	; 0x35
 802698c:	4604      	mov	r4, r0
 802698e:	b13d      	cbz	r5, 80269a0 <TIMER_Init+0x20>
      status = TIMER_CCU4_lInit(handle_ptr);
    }
#endif

#ifdef TIMER_CCU8_USED
    if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
 8026990:	2d01      	cmp	r5, #1
{
  TIMER_STATUS_t status;

  XMC_ASSERT("TIMER_Init:handle_ptr NULL" , (handle_ptr != NULL));

  status = TIMER_STATUS_SUCCESS;
 8026992:	461e      	mov	r6, r3
      status = TIMER_CCU4_lInit(handle_ptr);
    }
#endif

#ifdef TIMER_CCU8_USED
    if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
 8026994:	d02f      	beq.n	80269f6 <TIMER_Init+0x76>
    }
#endif
  }

  return (status);
}
 8026996:	4630      	mov	r0, r6
 8026998:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
{
  TIMER_STATUS_t status;

  XMC_ASSERT("TIMER_Init:handle_ptr NULL" , (handle_ptr != NULL));

  status = TIMER_STATUS_SUCCESS;
 802699a:	2600      	movs	r6, #0
    }
#endif
  }

  return (status);
}
 802699c:	4630      	mov	r0, r6
 802699e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
TIMER_STATUS_t TIMER_CCU4_lInit(TIMER_t* const handle_ptr)
{
  TIMER_STATUS_t status;
  /* Initialize the global registers */
  status = (TIMER_STATUS_t)GLOBAL_CCU4_Init(handle_ptr->global_ccu4_handler);
 80269a0:	6900      	ldr	r0, [r0, #16]
 80269a2:	f000 fbdd 	bl	8027160 <GLOBAL_CCU4_Init>

  /* Enable the clock for selected timer */
  XMC_CCU4_EnableClock(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->ccu4_slice_number);
 80269a6:	6923      	ldr	r3, [r4, #16]
__STATIC_INLINE void XMC_CCU4_EnableClock(XMC_CCU4_MODULE_t *const module, const uint8_t slice_number)
{
  XMC_ASSERT("XMC_CCU4_EnableClock:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  XMC_ASSERT("XMC_CCU4_EnableClock:Invalid Slice Number", (slice_number < 4U));

  module->GIDLC |= ((uint32_t) 1) << slice_number;
 80269a8:	f894 e018 	ldrb.w	lr, [r4, #24]
 80269ac:	689f      	ldr	r7, [r3, #8]
  /* Configure the timer with required settings */
  XMC_CCU4_SLICE_CompareInit(handle_ptr->ccu4_slice_ptr, handle_ptr->ccu4_slice_config_ptr);
 80269ae:	69e1      	ldr	r1, [r4, #28]
 80269b0:	68fa      	ldr	r2, [r7, #12]
 80269b2:	2301      	movs	r3, #1
 80269b4:	fa03 f30e 	lsl.w	r3, r3, lr
 80269b8:	4313      	orrs	r3, r2
 */
TIMER_STATUS_t TIMER_CCU4_lInit(TIMER_t* const handle_ptr)
{
  TIMER_STATUS_t status;
  /* Initialize the global registers */
  status = (TIMER_STATUS_t)GLOBAL_CCU4_Init(handle_ptr->global_ccu4_handler);
 80269ba:	4606      	mov	r6, r0

  /* Enable the clock for selected timer */
  XMC_CCU4_EnableClock(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->ccu4_slice_number);
  /* Configure the timer with required settings */
  XMC_CCU4_SLICE_CompareInit(handle_ptr->ccu4_slice_ptr, handle_ptr->ccu4_slice_config_ptr);
 80269bc:	6960      	ldr	r0, [r4, #20]
 80269be:	60fb      	str	r3, [r7, #12]
 80269c0:	f7fb f986 	bl	8021cd0 <XMC_CCU4_SLICE_CompareInit>
  /* programs the timer period register according to time interval value */
  XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr, handle_ptr->period_value);
  /* programs the timer compare register for 50% duty cycle */
  XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr, TIMER_CMP_100_DUTY);
  /* Transfers value from shadow timer registers to actual timer registers */
  XMC_CCU4_EnableShadowTransfer(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->shadow_mask);
 80269c4:	6923      	ldr	r3, [r4, #16]
 * This function configures timer period and compare values and triggers the shadow transfer operation
 */
void TIMER_CCU4_lShadowTransfer(TIMER_t* const handle_ptr)
{
  /* programs the timer period register according to time interval value */
  XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr, handle_ptr->period_value);
 80269c6:	6960      	ldr	r0, [r4, #20]
  /* programs the timer compare register for 50% duty cycle */
  XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr, TIMER_CMP_100_DUTY);
  /* Transfers value from shadow timer registers to actual timer registers */
  XMC_CCU4_EnableShadowTransfer(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->shadow_mask);
 80269c8:	689a      	ldr	r2, [r3, #8]
  XMC_CCU4_SLICE_CompareInit(handle_ptr->ccu4_slice_ptr, handle_ptr->ccu4_slice_config_ptr);
  /* programs the timer period and compare register according to time interval value and do the shadow transfer */
  TIMER_CCU4_lShadowTransfer(handle_ptr);

#ifdef  TIMER_INTERRUPT
  if (true == handle_ptr->period_match_enable)
 80269ca:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerPeriodMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t period_val)
{
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->PRS = (uint32_t) period_val;
 80269ce:	8ee7      	ldrh	r7, [r4, #54]	; 0x36
  /* programs the timer period register according to time interval value */
  XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr, handle_ptr->period_value);
  /* programs the timer compare register for 50% duty cycle */
  XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr, TIMER_CMP_100_DUTY);
  /* Transfers value from shadow timer registers to actual timer registers */
  XMC_CCU4_EnableShadowTransfer(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->shadow_mask);
 80269d0:	68e1      	ldr	r1, [r4, #12]
 80269d2:	6347      	str	r7, [r0, #52]	; 0x34
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerCompareMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t compare_val)
{
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->CRS = (uint32_t) compare_val;
 80269d4:	63c5      	str	r5, [r0, #60]	; 0x3c
 *  None.
 */
__STATIC_INLINE void XMC_CCU4_EnableShadowTransfer(XMC_CCU4_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
  XMC_ASSERT("XMC_CCU4_EnableShadowTransfer:Invalid Slice Pointer", XMC_CCU4_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;  
 80269d6:	6111      	str	r1, [r2, #16]
  XMC_CCU4_SLICE_CompareInit(handle_ptr->ccu4_slice_ptr, handle_ptr->ccu4_slice_config_ptr);
  /* programs the timer period and compare register according to time interval value and do the shadow transfer */
  TIMER_CCU4_lShadowTransfer(handle_ptr);

#ifdef  TIMER_INTERRUPT
  if (true == handle_ptr->period_match_enable)
 80269d8:	2b00      	cmp	r3, #0
 80269da:	d138      	bne.n	8026a4e <TIMER_Init+0xce>

  /* update the initialization flag as true for particular instance*/
  handle_ptr->initialized = true;

  /* Check whether the start of the timer is enabled during initialization or not */
  if (handle_ptr->start_control == true)
 80269dc:	f894 2038 	ldrb.w	r2, [r4, #56]	; 0x38
 *  XMC_CCU4_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_ClearTimer(XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_ClearTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TCC_Msk;
 80269e0:	2102      	movs	r1, #2
#endif
  /* Clears the timer register */
  XMC_CCU4_SLICE_ClearTimer(handle_ptr->ccu4_slice_ptr);

  /* update the initialization flag as true for particular instance*/
  handle_ptr->initialized = true;
 80269e2:	2301      	movs	r3, #1
 80269e4:	6101      	str	r1, [r0, #16]
 80269e6:	f884 303a 	strb.w	r3, [r4, #58]	; 0x3a

  /* Check whether the start of the timer is enabled during initialization or not */
  if (handle_ptr->start_control == true)
 80269ea:	b102      	cbz	r2, 80269ee <TIMER_Init+0x6e>
 *  XMC_CCU4_SLICE_StopTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_StartTimer(XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_StartTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCSET = CCU4_CC4_TCSET_TRBS_Msk;
 80269ec:	60c3      	str	r3, [r0, #12]
 80269ee:	f894 5035 	ldrb.w	r5, [r4, #53]	; 0x35
      status = TIMER_CCU4_lInit(handle_ptr);
    }
#endif

#ifdef TIMER_CCU8_USED
    if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
 80269f2:	2d01      	cmp	r5, #1
 80269f4:	d1cf      	bne.n	8026996 <TIMER_Init+0x16>
 */
TIMER_STATUS_t TIMER_CCU8_lInit(TIMER_t* const handle_ptr)
{
  TIMER_STATUS_t status;
  /* Initialize the global registers */
  status = (TIMER_STATUS_t)GLOBAL_CCU8_Init(handle_ptr->global_ccu8_handler);
 80269f6:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80269f8:	f000 fb9e 	bl	8027138 <GLOBAL_CCU8_Init>

  /* Enable the clock for selected timer */
  XMC_CCU8_EnableClock(handle_ptr->global_ccu8_handler->module_ptr, handle_ptr->ccu8_slice_number);
 80269fc:	6a63      	ldr	r3, [r4, #36]	; 0x24
__STATIC_INLINE void XMC_CCU8_EnableClock(XMC_CCU8_MODULE_t *const module, const uint8_t slice_number)
{
  XMC_ASSERT("XMC_CCU8_EnableClock:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));
  XMC_ASSERT("XMC_CCU8_EnableClock:Invalid Slice Number", (slice_number < 4U));

  module->GIDLC |= ((uint32_t) 1 << slice_number);
 80269fe:	f894 702c 	ldrb.w	r7, [r4, #44]	; 0x2c
 8026a02:	689a      	ldr	r2, [r3, #8]
  /* Configure the timer with required settings */
  XMC_CCU8_SLICE_CompareInit(handle_ptr->ccu8_slice_ptr, handle_ptr->ccu8_slice_config_ptr);
 8026a04:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8026a06:	68d3      	ldr	r3, [r2, #12]
 8026a08:	40bd      	lsls	r5, r7
 8026a0a:	431d      	orrs	r5, r3
 */
TIMER_STATUS_t TIMER_CCU8_lInit(TIMER_t* const handle_ptr)
{
  TIMER_STATUS_t status;
  /* Initialize the global registers */
  status = (TIMER_STATUS_t)GLOBAL_CCU8_Init(handle_ptr->global_ccu8_handler);
 8026a0c:	4606      	mov	r6, r0

  /* Enable the clock for selected timer */
  XMC_CCU8_EnableClock(handle_ptr->global_ccu8_handler->module_ptr, handle_ptr->ccu8_slice_number);
  /* Configure the timer with required settings */
  XMC_CCU8_SLICE_CompareInit(handle_ptr->ccu8_slice_ptr, handle_ptr->ccu8_slice_config_ptr);
 8026a0e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8026a10:	60d5      	str	r5, [r2, #12]
 8026a12:	f7fb fa1f 	bl	8021e54 <XMC_CCU8_SLICE_CompareInit>
 * This function configures timer period and compare values and triggers the shadow transfer operation
 */
void TIMER_CCU8_lShadowTransfer(TIMER_t* const handle_ptr)
{
  /* programs the timer period register according to time interval value */
  XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, handle_ptr->period_value);
 8026a16:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8026a18:	8ee1      	ldrh	r1, [r4, #54]	; 0x36
 8026a1a:	f7fb fa39 	bl	8021e90 <XMC_CCU8_SLICE_SetTimerPeriodMatch>
  /* programs the timer compare register for 50% duty cycle in compare channel 1*/
  XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr,
 8026a1e:	2100      	movs	r1, #0
 8026a20:	460a      	mov	r2, r1
 8026a22:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8026a24:	f7fb fa3e 	bl	8021ea4 <XMC_CCU8_SLICE_SetTimerCompareMatch>
                                      XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
                                      TIMER_CMP_100_DUTY);
  /* Transfers value from shadow timer registers to actual timer registers */
  XMC_CCU8_EnableShadowTransfer(handle_ptr->global_ccu8_handler->module_ptr, handle_ptr->shadow_mask);
 8026a28:	6a62      	ldr	r2, [r4, #36]	; 0x24
  XMC_CCU8_SLICE_CompareInit(handle_ptr->ccu8_slice_ptr, handle_ptr->ccu8_slice_config_ptr);
  /* programs the timer period and compare register according to time interval value and do the shadow transfer */
  TIMER_CCU8_lShadowTransfer(handle_ptr);

#ifdef  TIMER_INTERRUPT
  if (true == handle_ptr->period_match_enable)
 8026a2a:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
  /* programs the timer compare register for 50% duty cycle in compare channel 1*/
  XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr,
                                      XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
                                      TIMER_CMP_100_DUTY);
  /* Transfers value from shadow timer registers to actual timer registers */
  XMC_CCU8_EnableShadowTransfer(handle_ptr->global_ccu8_handler->module_ptr, handle_ptr->shadow_mask);
 8026a2e:	6892      	ldr	r2, [r2, #8]
 8026a30:	68e1      	ldr	r1, [r4, #12]
 *  None.
 */
__STATIC_INLINE void XMC_CCU8_EnableShadowTransfer(XMC_CCU8_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
  XMC_ASSERT("XMC_CCU8_EnableShadowTransfer:Invalid module Pointer", XMC_CCU8_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;  
 8026a32:	6111      	str	r1, [r2, #16]
  XMC_CCU8_SLICE_CompareInit(handle_ptr->ccu8_slice_ptr, handle_ptr->ccu8_slice_config_ptr);
  /* programs the timer period and compare register according to time interval value and do the shadow transfer */
  TIMER_CCU8_lShadowTransfer(handle_ptr);

#ifdef  TIMER_INTERRUPT
  if (true == handle_ptr->period_match_enable)
 8026a34:	b9c3      	cbnz	r3, 8026a68 <TIMER_Init+0xe8>
 8026a36:	6aa3      	ldr	r3, [r4, #40]	; 0x28

  /* update the initialization flag as true for particular instance*/
  handle_ptr->initialized = true;

  /* Check whether the start of the timer is enabled during initialization or not */
  if (handle_ptr->start_control == true)
 8026a38:	f894 1038 	ldrb.w	r1, [r4, #56]	; 0x38
 *  XMC_CCU8_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_ClearTimer(XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_ClearTimer:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU8_CC8_TCCLR_TCC_Msk;
 8026a3c:	2002      	movs	r0, #2
#endif
  /* Clears the timer register */
  XMC_CCU8_SLICE_ClearTimer(handle_ptr->ccu8_slice_ptr);

  /* update the initialization flag as true for particular instance*/
  handle_ptr->initialized = true;
 8026a3e:	2201      	movs	r2, #1
 8026a40:	6118      	str	r0, [r3, #16]
 8026a42:	f884 203a 	strb.w	r2, [r4, #58]	; 0x3a

  /* Check whether the start of the timer is enabled during initialization or not */
  if (handle_ptr->start_control == true)
 8026a46:	2900      	cmp	r1, #0
 8026a48:	d0a5      	beq.n	8026996 <TIMER_Init+0x16>
 *  XMC_CCU8_SLICE_StopTimer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_StartTimer(XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_StartTimer:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TCSET = CCU8_CC8_TCSET_TRBS_Msk;
 8026a4a:	60da      	str	r2, [r3, #12]
 8026a4c:	e7a3      	b.n	8026996 <TIMER_Init+0x16>

#ifdef  TIMER_INTERRUPT
  if (true == handle_ptr->period_match_enable)
  {
    /* Binds a period match event to an NVIC node  */
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH,
 8026a4e:	4629      	mov	r1, r5
 8026a50:	f894 2020 	ldrb.w	r2, [r4, #32]
 8026a54:	f7fb f9b6 	bl	8021dc4 <XMC_CCU4_SLICE_SetInterruptNode>
                                    handle_ptr->ccu4_period_match_node);
    /* Enables a timer(period match) event  */
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
 8026a58:	6960      	ldr	r0, [r4, #20]
__STATIC_INLINE void XMC_CCU4_SLICE_EnableEvent(XMC_CCU4_SLICE_t *const slice,
                                                const XMC_CCU4_SLICE_IRQ_ID_t event)
{
  XMC_ASSERT("XMC_CCU4_SLICE_EnableEvent:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_EnableEvent:Invalid SR event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  slice->INTE |= ((uint32_t) 1) << ((uint32_t) event);
 8026a5a:	f8d0 30a4 	ldr.w	r3, [r0, #164]	; 0xa4
 8026a5e:	f043 0301 	orr.w	r3, r3, #1
 8026a62:	f8c0 30a4 	str.w	r3, [r0, #164]	; 0xa4
 8026a66:	e7b9      	b.n	80269dc <TIMER_Init+0x5c>

#ifdef  TIMER_INTERRUPT
  if (true == handle_ptr->period_match_enable)
  {
    /* Binds a period match event to an NVIC node  */
    XMC_CCU8_SLICE_SetInterruptNode(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH,
 8026a68:	f894 2034 	ldrb.w	r2, [r4, #52]	; 0x34
 8026a6c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8026a6e:	2100      	movs	r1, #0
 8026a70:	f7fb fa1e 	bl	8021eb0 <XMC_CCU8_SLICE_SetInterruptNode>
                                    handle_ptr->ccu8_period_match_node);
    /* Enables a timer(period match) event  */
    XMC_CCU8_SLICE_EnableEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH);
 8026a74:	6aa3      	ldr	r3, [r4, #40]	; 0x28
__STATIC_INLINE void XMC_CCU8_SLICE_EnableEvent(XMC_CCU8_SLICE_t *const slice, const XMC_CCU8_SLICE_IRQ_ID_t event)
{
  XMC_ASSERT("XMC_CCU8_SLICE_EnableEvent:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_EnableEvent:Invalid SR event", XMC_CCU8_SLICE_CHECK_INTERRUPT(event));

  slice->INTE |= ((uint32_t) 1) << ((uint32_t) event);
 8026a76:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
 8026a7a:	f042 0201 	orr.w	r2, r2, #1
 8026a7e:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
 8026a82:	e7d9      	b.n	8026a38 <TIMER_Init+0xb8>

08026a84 <TIMER_Start>:
  TIMER_STATUS_t status;

  XMC_ASSERT("TIMER_Start:handle_ptr NULL" , (handle_ptr != NULL));

  /* Check for APP instance is initialized or not */
  if (true == handle_ptr->initialized)
 8026a84:	f890 303a 	ldrb.w	r3, [r0, #58]	; 0x3a
 8026a88:	b16b      	cbz	r3, 8026aa6 <TIMER_Start+0x22>
  {
#ifdef TIMER_CCU4_USED
    if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8026a8a:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 8026a8e:	b12b      	cbz	r3, 8026a9c <TIMER_Start+0x18>
      XMC_CCU4_SLICE_StartTimer(handle_ptr->ccu4_slice_ptr);
    }
#endif

#ifdef TIMER_CCU8_USED
    if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
 8026a90:	2b01      	cmp	r3, #1
 8026a92:	d10a      	bne.n	8026aaa <TIMER_Start+0x26>
       {
      /* Start the timer manually */
      XMC_CCU8_SLICE_StartTimer(handle_ptr->ccu8_slice_ptr);
 8026a94:	6a82      	ldr	r2, [r0, #40]	; 0x28
       }
#endif
    status = TIMER_STATUS_SUCCESS;
 8026a96:	2000      	movs	r0, #0
 *  XMC_CCU8_SLICE_StopTimer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_StartTimer(XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_StartTimer:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TCSET = CCU8_CC8_TCSET_TRBS_Msk;
 8026a98:	60d3      	str	r3, [r2, #12]
 8026a9a:	4770      	bx	lr
  {
#ifdef TIMER_CCU4_USED
    if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
    {
      /* Start the timer manually */
      XMC_CCU4_SLICE_StartTimer(handle_ptr->ccu4_slice_ptr);
 8026a9c:	6942      	ldr	r2, [r0, #20]
 *  XMC_CCU4_SLICE_StopTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_StartTimer(XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_StartTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCSET = CCU4_CC4_TCSET_TRBS_Msk;
 8026a9e:	2101      	movs	r1, #1
       {
      /* Start the timer manually */
      XMC_CCU8_SLICE_StartTimer(handle_ptr->ccu8_slice_ptr);
       }
#endif
    status = TIMER_STATUS_SUCCESS;
 8026aa0:	4618      	mov	r0, r3
 8026aa2:	60d1      	str	r1, [r2, #12]
 8026aa4:	4770      	bx	lr
  }
  else
  {
    status = TIMER_STATUS_FAILURE;
 8026aa6:	2001      	movs	r0, #1
 8026aa8:	4770      	bx	lr
       {
      /* Start the timer manually */
      XMC_CCU8_SLICE_StartTimer(handle_ptr->ccu8_slice_ptr);
       }
#endif
    status = TIMER_STATUS_SUCCESS;
 8026aaa:	2000      	movs	r0, #0
  {
    status = TIMER_STATUS_FAILURE;
  }

  return (status);
}
 8026aac:	4770      	bx	lr
 8026aae:	bf00      	nop

08026ab0 <TIMER_Stop>:
  XMC_ASSERT("TIMER_GetTimerStatus:handle_ptr NULL" , (handle_ptr != NULL));

  status = false;

#ifdef TIMER_CCU4_USED
  if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8026ab0:	f890 2035 	ldrb.w	r2, [r0, #53]	; 0x35
 8026ab4:	b972      	cbnz	r2, 8026ad4 <TIMER_Stop+0x24>
  {
    /* Returns the current status of the timer */
    status = XMC_CCU4_SLICE_IsTimerRunning(handle_ptr->ccu4_slice_ptr);
 8026ab6:	6943      	ldr	r3, [r0, #20]
 *  XMC_CCU4_SLICE_StartTimer()<BR> XMC_CCU4_SLICE_StopTimer().
 */
__STATIC_INLINE bool XMC_CCU4_SLICE_IsTimerRunning(const XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_GetTimerStatus:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  return (bool)(((slice->TCST) & CCU4_CC4_TCST_TRB_Msk) == CCU4_CC4_TCST_TRB_Msk);
 8026ab8:	689b      	ldr	r3, [r3, #8]
 8026aba:	f003 0301 	and.w	r3, r3, #1
  TIMER_STATUS_t status;

  XMC_ASSERT("TIMER_Stop:handle_ptr NULL" , (handle_ptr != NULL));

  /* Check whether timer is initialized and in running state */
  if ((TIMER_GetTimerStatus(handle_ptr)) && (true == handle_ptr->initialized))
 8026abe:	b15b      	cbz	r3, 8026ad8 <TIMER_Stop+0x28>
 8026ac0:	f890 303a 	ldrb.w	r3, [r0, #58]	; 0x3a
 8026ac4:	b143      	cbz	r3, 8026ad8 <TIMER_Stop+0x28>
  {
#ifdef TIMER_CCU4_USED
    if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8026ac6:	b172      	cbz	r2, 8026ae6 <TIMER_Stop+0x36>
      XMC_CCU4_SLICE_StopTimer(handle_ptr->ccu4_slice_ptr);
    }
#endif

#ifdef TIMER_CCU8_USED
    if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
 8026ac8:	2a01      	cmp	r2, #1
 8026aca:	d111      	bne.n	8026af0 <TIMER_Stop+0x40>
       {
      /* Stops the timer */
      XMC_CCU8_SLICE_StopTimer(handle_ptr->ccu8_slice_ptr);
 8026acc:	6a83      	ldr	r3, [r0, #40]	; 0x28
       }
#endif
    status = TIMER_STATUS_SUCCESS;
 8026ace:	2000      	movs	r0, #0
 *  XMC_CCU8_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_StopTimer(XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_StopTimer:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU8_CC8_TCCLR_TRBC_Msk;
 8026ad0:	611a      	str	r2, [r3, #16]
 8026ad2:	4770      	bx	lr
    status = XMC_CCU4_SLICE_IsTimerRunning(handle_ptr->ccu4_slice_ptr);
  }
#endif

#ifdef TIMER_CCU8_USED
  if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
 8026ad4:	2a01      	cmp	r2, #1
 8026ad6:	d001      	beq.n	8026adc <TIMER_Stop+0x2c>
#endif
    status = TIMER_STATUS_SUCCESS;
  }
  else
  {
    status = TIMER_STATUS_FAILURE;
 8026ad8:	2001      	movs	r0, #1
 8026ada:	4770      	bx	lr

#ifdef TIMER_CCU8_USED
  if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
  {
    /* Returns the current status of the timer */
    status = XMC_CCU8_SLICE_IsTimerRunning(handle_ptr->ccu8_slice_ptr);
 8026adc:	6a83      	ldr	r3, [r0, #40]	; 0x28
 *  XMC_CCU8_SLICE_StartTimer()<BR>  XMC_CCU8_SLICE_StopTimer().
 */
__STATIC_INLINE bool XMC_CCU8_SLICE_IsTimerRunning(const XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_GetTimerStatus:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  return(bool)(((slice->TCST) & CCU8_CC8_TCST_TRB_Msk) == (uint32_t)CCU8_CC8_TCST_TRB_Msk);
 8026ade:	689b      	ldr	r3, [r3, #8]
 8026ae0:	f003 0301 	and.w	r3, r3, #1
 8026ae4:	e7eb      	b.n	8026abe <TIMER_Stop+0xe>
  {
#ifdef TIMER_CCU4_USED
    if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
    {
      /* Stops the timer */
      XMC_CCU4_SLICE_StopTimer(handle_ptr->ccu4_slice_ptr);
 8026ae6:	6943      	ldr	r3, [r0, #20]
 *  XMC_CCU4_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_StopTimer(XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_StopTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TRBC_Msk;
 8026ae8:	2101      	movs	r1, #1
       {
      /* Stops the timer */
      XMC_CCU8_SLICE_StopTimer(handle_ptr->ccu8_slice_ptr);
       }
#endif
    status = TIMER_STATUS_SUCCESS;
 8026aea:	4610      	mov	r0, r2
 8026aec:	6119      	str	r1, [r3, #16]
 8026aee:	4770      	bx	lr
 8026af0:	2000      	movs	r0, #0
  {
    status = TIMER_STATUS_FAILURE;
  }

  return (status);
}
 8026af2:	4770      	bx	lr

08026af4 <TIMER_GetTimerStatus>:
  XMC_ASSERT("TIMER_GetTimerStatus:handle_ptr NULL" , (handle_ptr != NULL));

  status = false;

#ifdef TIMER_CCU4_USED
  if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8026af4:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 8026af8:	b923      	cbnz	r3, 8026b04 <TIMER_GetTimerStatus+0x10>
  {
    /* Returns the current status of the timer */
    status = XMC_CCU4_SLICE_IsTimerRunning(handle_ptr->ccu4_slice_ptr);
 8026afa:	6943      	ldr	r3, [r0, #20]
 *  XMC_CCU4_SLICE_StartTimer()<BR> XMC_CCU4_SLICE_StopTimer().
 */
__STATIC_INLINE bool XMC_CCU4_SLICE_IsTimerRunning(const XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_GetTimerStatus:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  return (bool)(((slice->TCST) & CCU4_CC4_TCST_TRB_Msk) == CCU4_CC4_TCST_TRB_Msk);
 8026afc:	6898      	ldr	r0, [r3, #8]
 8026afe:	f000 0001 	and.w	r0, r0, #1
 8026b02:	4770      	bx	lr
  }
#endif

#ifdef TIMER_CCU8_USED
  if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
 8026b04:	2b01      	cmp	r3, #1
  {
    /* Returns the current status of the timer */
    status = XMC_CCU8_SLICE_IsTimerRunning(handle_ptr->ccu8_slice_ptr);
 8026b06:	bf03      	ittte	eq
 8026b08:	6a83      	ldreq	r3, [r0, #40]	; 0x28
 8026b0a:	6898      	ldreq	r0, [r3, #8]
 8026b0c:	f000 0001 	andeq.w	r0, r0, #1
{
  bool status;

  XMC_ASSERT("TIMER_GetTimerStatus:handle_ptr NULL" , (handle_ptr != NULL));

  status = false;
 8026b10:	2000      	movne	r0, #0
    status = XMC_CCU8_SLICE_IsTimerRunning(handle_ptr->ccu8_slice_ptr);
  }
#endif

  return (status);
}
 8026b12:	4770      	bx	lr
 8026b14:	0000      	movs	r0, r0
	...

08026b18 <TIMER_SetTimeInterval>:
/*
 * This function changes the PWM period which in turn changes the time tick interval value by checking that
 * the given time tick value is within supported range.
 */
TIMER_STATUS_t TIMER_SetTimeInterval(TIMER_t  *const handle_ptr, uint32_t time_interval)
{
 8026b18:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  XMC_ASSERT("TIMER_GetTimerStatus:handle_ptr NULL" , (handle_ptr != NULL));

  status = false;

#ifdef TIMER_CCU4_USED
  if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8026b1c:	f890 6035 	ldrb.w	r6, [r0, #53]	; 0x35
 8026b20:	2e00      	cmp	r6, #0
 8026b22:	d15f      	bne.n	8026be4 <TIMER_SetTimeInterval+0xcc>
  {
    /* Returns the current status of the timer */
    status = XMC_CCU4_SLICE_IsTimerRunning(handle_ptr->ccu4_slice_ptr);
 8026b24:	6943      	ldr	r3, [r0, #20]
 8026b26:	689b      	ldr	r3, [r3, #8]
 8026b28:	f003 0301 	and.w	r3, r3, #1

  XMC_ASSERT("TIMER_SetTimeInterval:handle_ptr NULL" , (handle_ptr != NULL));

  status = TIMER_STATUS_FAILURE;

  if (false == TIMER_GetTimerStatus(handle_ptr))
 8026b2c:	2b00      	cmp	r3, #0
 8026b2e:	d156      	bne.n	8026bde <TIMER_SetTimeInterval+0xc6>
  {
    /* check for time_interval range */
    if ((time_interval >= handle_ptr->timer_min_value_us) && (time_interval <= handle_ptr->timer_max_value_us))
 8026b30:	6883      	ldr	r3, [r0, #8]
 8026b32:	428b      	cmp	r3, r1
 8026b34:	d853      	bhi.n	8026bde <TIMER_SetTimeInterval+0xc6>
 8026b36:	6845      	ldr	r5, [r0, #4]
 8026b38:	42a9      	cmp	r1, r5
 8026b3a:	d850      	bhi.n	8026bde <TIMER_SetTimeInterval+0xc6>
    {
      /* Initialize the prescaler */
      lprescaler = 0U;
      while (time_interval > (handle_ptr->timer_max_value_us >> (TIMER_PRESCALER_MAX - lprescaler)))
 8026b3c:	ebb1 3fd5 	cmp.w	r1, r5, lsr #15
 8026b40:	f240 8091 	bls.w	8026c66 <TIMER_SetTimeInterval+0x14e>
 8026b44:	2300      	movs	r3, #0
 8026b46:	f1c3 020e 	rsb	r2, r3, #14
 8026b4a:	fa25 f202 	lsr.w	r2, r5, r2
      {
        lprescaler++;
 8026b4e:	1c5c      	adds	r4, r3, #1
    /* check for time_interval range */
    if ((time_interval >= handle_ptr->timer_min_value_us) && (time_interval <= handle_ptr->timer_max_value_us))
    {
      /* Initialize the prescaler */
      lprescaler = 0U;
      while (time_interval > (handle_ptr->timer_max_value_us >> (TIMER_PRESCALER_MAX - lprescaler)))
 8026b50:	4291      	cmp	r1, r2
      {
        lprescaler++;
 8026b52:	4623      	mov	r3, r4
    /* check for time_interval range */
    if ((time_interval >= handle_ptr->timer_min_value_us) && (time_interval <= handle_ptr->timer_max_value_us))
    {
      /* Initialize the prescaler */
      lprescaler = 0U;
      while (time_interval > (handle_ptr->timer_max_value_us >> (TIMER_PRESCALER_MAX - lprescaler)))
 8026b54:	d8f7      	bhi.n	8026b46 <TIMER_SetTimeInterval+0x2e>
 8026b56:	460d      	mov	r5, r1
 8026b58:	4607      	mov	r7, r0
      {
        lprescaler++;
      }
#ifdef TIMER_CCU4_USED
      if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8026b5a:	2e00      	cmp	r6, #0
 8026b5c:	d04b      	beq.n	8026bf6 <TIMER_SetTimeInterval+0xde>
  uint32_t lfrequency;
  uint32_t lprescaler;

  XMC_ASSERT("TIMER_SetTimeInterval:handle_ptr NULL" , (handle_ptr != NULL));

  status = TIMER_STATUS_FAILURE;
 8026b5e:	2001      	movs	r0, #1
        status = TIMER_STATUS_SUCCESS;
      }
#endif

#ifdef TIMER_CCU8_USED
      if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
 8026b60:	2e01      	cmp	r6, #1
 8026b62:	d13d      	bne.n	8026be0 <TIMER_SetTimeInterval+0xc8>
      {
        handle_ptr->ccu8_slice_config_ptr->prescaler_initval = lprescaler;
        lfrequency = handle_ptr->global_ccu8_handler->module_frequency;
 8026b64:	6a7b      	ldr	r3, [r7, #36]	; 0x24
#endif

#ifdef TIMER_CCU8_USED
      if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
      {
        handle_ptr->ccu8_slice_config_ptr->prescaler_initval = lprescaler;
 8026b66:	f8d7 e030 	ldr.w	lr, [r7, #48]	; 0x30
        lfrequency = handle_ptr->global_ccu8_handler->module_frequency;
 8026b6a:	681a      	ldr	r2, [r3, #0]
#endif

#ifdef TIMER_CCU8_USED
      if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
      {
        handle_ptr->ccu8_slice_config_ptr->prescaler_initval = lprescaler;
 8026b6c:	f89e c00c 	ldrb.w	ip, [lr, #12]
 8026b70:	f004 060f 	and.w	r6, r4, #15
        lfrequency = handle_ptr->global_ccu8_handler->module_frequency;
        /* Calculate the period register for the required time_interval value */
        handle_ptr->period_value = (uint16_t)((((uint64_t)time_interval * lfrequency) >> \
 8026b74:	fba5 2302 	umull	r2, r3, r5, r2
 8026b78:	f1c6 0120 	rsb	r1, r6, #32
 8026b7c:	fa22 f006 	lsr.w	r0, r2, r6
 8026b80:	fa03 f101 	lsl.w	r1, r3, r1
 8026b84:	f1a6 0220 	sub.w	r2, r6, #32
#endif

#ifdef TIMER_CCU8_USED
      if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
      {
        handle_ptr->ccu8_slice_config_ptr->prescaler_initval = lprescaler;
 8026b88:	f364 0c03 	bfi	ip, r4, #0, #4
        lfrequency = handle_ptr->global_ccu8_handler->module_frequency;
        /* Calculate the period register for the required time_interval value */
        handle_ptr->period_value = (uint16_t)((((uint64_t)time_interval * lfrequency) >> \
 8026b8c:	4308      	orrs	r0, r1
 8026b8e:	fa23 f202 	lsr.w	r2, r3, r2
#endif

#ifdef TIMER_CCU8_USED
      if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
      {
        handle_ptr->ccu8_slice_config_ptr->prescaler_initval = lprescaler;
 8026b92:	f88e c00c 	strb.w	ip, [lr, #12]
        lfrequency = handle_ptr->global_ccu8_handler->module_frequency;
        /* Calculate the period register for the required time_interval value */
        handle_ptr->period_value = (uint16_t)((((uint64_t)time_interval * lfrequency) >> \
                                               handle_ptr->ccu8_slice_config_ptr->prescaler_initval) / \
 8026b96:	fa23 f106 	lsr.w	r1, r3, r6
 8026b9a:	4310      	orrs	r0, r2
 8026b9c:	a334      	add	r3, pc, #208	; (adr r3, 8026c70 <TIMER_SetTimeInterval+0x158>)
 8026b9e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8026ba2:	f007 fce3 	bl	802e56c <__aeabi_uldivmod>
      if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
      {
        handle_ptr->ccu8_slice_config_ptr->prescaler_initval = lprescaler;
        lfrequency = handle_ptr->global_ccu8_handler->module_frequency;
        /* Calculate the period register for the required time_interval value */
        handle_ptr->period_value = (uint16_t)((((uint64_t)time_interval * lfrequency) >> \
 8026ba6:	b280      	uxth	r0, r0
                                               handle_ptr->ccu8_slice_config_ptr->prescaler_initval) / \
                                              TIMER_RESOLUTION_SEC_TO_MICRO);
        /* Actual timer period values is Period_reg_val+1U */
        if (handle_ptr->period_value > TIMER_PERIOD_MIN)
 8026ba8:	2801      	cmp	r0, #1
        {
          (handle_ptr->period_value)--;
 8026baa:	bf88      	it	hi
 8026bac:	f100 30ff 	addhi.w	r0, r0, #4294967295
#endif

#ifdef TIMER_CCU8_USED
      if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
      {
        handle_ptr->ccu8_slice_config_ptr->prescaler_initval = lprescaler;
 8026bb0:	b2e1      	uxtb	r1, r4
                                               handle_ptr->ccu8_slice_config_ptr->prescaler_initval) / \
                                              TIMER_RESOLUTION_SEC_TO_MICRO);
        /* Actual timer period values is Period_reg_val+1U */
        if (handle_ptr->period_value > TIMER_PERIOD_MIN)
        {
          (handle_ptr->period_value)--;
 8026bb2:	86f8      	strh	r0, [r7, #54]	; 0x36
        }
        /* Update the prescaler */
        XMC_CCU8_SLICE_SetPrescaler(handle_ptr->ccu8_slice_ptr, handle_ptr->ccu8_slice_config_ptr->prescaler_initval);
 8026bb4:	f001 010f 	and.w	r1, r1, #15
 8026bb8:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8026bba:	f7fb f96b 	bl	8021e94 <XMC_CCU8_SLICE_SetPrescaler>
 * This function configures timer period and compare values and triggers the shadow transfer operation
 */
void TIMER_CCU8_lShadowTransfer(TIMER_t* const handle_ptr)
{
  /* programs the timer period register according to time interval value */
  XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, handle_ptr->period_value);
 8026bbe:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8026bc0:	8ef9      	ldrh	r1, [r7, #54]	; 0x36
 8026bc2:	f7fb f965 	bl	8021e90 <XMC_CCU8_SLICE_SetTimerPeriodMatch>
  /* programs the timer compare register for 50% duty cycle in compare channel 1*/
  XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr,
 8026bc6:	2100      	movs	r1, #0
 8026bc8:	460a      	mov	r2, r1
 8026bca:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8026bcc:	f7fb f96a 	bl	8021ea4 <XMC_CCU8_SLICE_SetTimerCompareMatch>
                                      XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
                                      TIMER_CMP_100_DUTY);
  /* Transfers value from shadow timer registers to actual timer registers */
  XMC_CCU8_EnableShadowTransfer(handle_ptr->global_ccu8_handler->module_ptr, handle_ptr->shadow_mask);
 8026bd0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8026bd2:	68fa      	ldr	r2, [r7, #12]
 8026bd4:	689b      	ldr	r3, [r3, #8]
        /* Update the prescaler */
        XMC_CCU8_SLICE_SetPrescaler(handle_ptr->ccu8_slice_ptr, handle_ptr->ccu8_slice_config_ptr->prescaler_initval);
        /* update period, compare and prescaler values */
        TIMER_CCU8_lShadowTransfer(handle_ptr);
        /* Update the status */
        status = TIMER_STATUS_SUCCESS;
 8026bd6:	2000      	movs	r0, #0
 *  None.
 */
__STATIC_INLINE void XMC_CCU8_EnableShadowTransfer(XMC_CCU8_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
  XMC_ASSERT("XMC_CCU8_EnableShadowTransfer:Invalid module Pointer", XMC_CCU8_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;  
 8026bd8:	611a      	str	r2, [r3, #16]
 8026bda:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  uint32_t lfrequency;
  uint32_t lprescaler;

  XMC_ASSERT("TIMER_SetTimeInterval:handle_ptr NULL" , (handle_ptr != NULL));

  status = TIMER_STATUS_FAILURE;
 8026bde:	2001      	movs	r0, #1
      }
#endif
    }
  }
  return (status);
}
 8026be0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    status = XMC_CCU4_SLICE_IsTimerRunning(handle_ptr->ccu4_slice_ptr);
  }
#endif

#ifdef TIMER_CCU8_USED
  if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
 8026be4:	2e01      	cmp	r6, #1
 8026be6:	d1a3      	bne.n	8026b30 <TIMER_SetTimeInterval+0x18>
  {
    /* Returns the current status of the timer */
    status = XMC_CCU8_SLICE_IsTimerRunning(handle_ptr->ccu8_slice_ptr);
 8026be8:	6a83      	ldr	r3, [r0, #40]	; 0x28
 *  XMC_CCU8_SLICE_StartTimer()<BR>  XMC_CCU8_SLICE_StopTimer().
 */
__STATIC_INLINE bool XMC_CCU8_SLICE_IsTimerRunning(const XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_GetTimerStatus:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  return(bool)(((slice->TCST) & CCU8_CC8_TCST_TRB_Msk) == (uint32_t)CCU8_CC8_TCST_TRB_Msk);
 8026bea:	689b      	ldr	r3, [r3, #8]
 8026bec:	f003 0301 	and.w	r3, r3, #1

  XMC_ASSERT("TIMER_SetTimeInterval:handle_ptr NULL" , (handle_ptr != NULL));

  status = TIMER_STATUS_FAILURE;

  if (false == TIMER_GetTimerStatus(handle_ptr))
 8026bf0:	2b00      	cmp	r3, #0
 8026bf2:	d09d      	beq.n	8026b30 <TIMER_SetTimeInterval+0x18>
 8026bf4:	e7f3      	b.n	8026bde <TIMER_SetTimeInterval+0xc6>
        lprescaler++;
      }
#ifdef TIMER_CCU4_USED
      if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
      {
        lfrequency = handle_ptr->global_ccu4_handler->module_frequency;
 8026bf6:	6903      	ldr	r3, [r0, #16]
        handle_ptr->ccu4_slice_config_ptr->prescaler_initval = lprescaler;
 8026bf8:	69c6      	ldr	r6, [r0, #28]
        lprescaler++;
      }
#ifdef TIMER_CCU4_USED
      if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
      {
        lfrequency = handle_ptr->global_ccu4_handler->module_frequency;
 8026bfa:	681a      	ldr	r2, [r3, #0]
        handle_ptr->ccu4_slice_config_ptr->prescaler_initval = lprescaler;
 8026bfc:	f896 e004 	ldrb.w	lr, [r6, #4]
 8026c00:	f004 030f 	and.w	r3, r4, #15
        /* Calculate the period register for the required time_interval value */
        handle_ptr->period_value = (uint16_t)((((uint64_t)time_interval * lfrequency) >> \
 8026c04:	fba1 8902 	umull	r8, r9, r1, r2
 8026c08:	f1c3 0120 	rsb	r1, r3, #32
 8026c0c:	fa28 f003 	lsr.w	r0, r8, r3
 8026c10:	fa09 f101 	lsl.w	r1, r9, r1
 8026c14:	f1a3 0220 	sub.w	r2, r3, #32
      }
#ifdef TIMER_CCU4_USED
      if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
      {
        lfrequency = handle_ptr->global_ccu4_handler->module_frequency;
        handle_ptr->ccu4_slice_config_ptr->prescaler_initval = lprescaler;
 8026c18:	f364 0e03 	bfi	lr, r4, #0, #4
        /* Calculate the period register for the required time_interval value */
        handle_ptr->period_value = (uint16_t)((((uint64_t)time_interval * lfrequency) >> \
 8026c1c:	4308      	orrs	r0, r1
 8026c1e:	fa29 f202 	lsr.w	r2, r9, r2
      }
#ifdef TIMER_CCU4_USED
      if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
      {
        lfrequency = handle_ptr->global_ccu4_handler->module_frequency;
        handle_ptr->ccu4_slice_config_ptr->prescaler_initval = lprescaler;
 8026c22:	f886 e004 	strb.w	lr, [r6, #4]
        /* Calculate the period register for the required time_interval value */
        handle_ptr->period_value = (uint16_t)((((uint64_t)time_interval * lfrequency) >> \
                                               handle_ptr->ccu4_slice_config_ptr->prescaler_initval) / \
 8026c26:	4310      	orrs	r0, r2
 8026c28:	fa29 f103 	lsr.w	r1, r9, r3
 8026c2c:	a310      	add	r3, pc, #64	; (adr r3, 8026c70 <TIMER_SetTimeInterval+0x158>)
 8026c2e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8026c32:	f007 fc9b 	bl	802e56c <__aeabi_uldivmod>
      if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
      {
        lfrequency = handle_ptr->global_ccu4_handler->module_frequency;
        handle_ptr->ccu4_slice_config_ptr->prescaler_initval = lprescaler;
        /* Calculate the period register for the required time_interval value */
        handle_ptr->period_value = (uint16_t)((((uint64_t)time_interval * lfrequency) >> \
 8026c36:	b280      	uxth	r0, r0
                                               handle_ptr->ccu4_slice_config_ptr->prescaler_initval) / \
                                              TIMER_RESOLUTION_SEC_TO_MICRO);
        /* Actual timer period values is Period_reg_val+1U */
        if (handle_ptr->period_value > TIMER_PERIOD_MIN)
 8026c38:	2801      	cmp	r0, #1
        {
          (handle_ptr->period_value)--;
 8026c3a:	bf88      	it	hi
 8026c3c:	f100 30ff 	addhi.w	r0, r0, #4294967295
      }
#ifdef TIMER_CCU4_USED
      if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
      {
        lfrequency = handle_ptr->global_ccu4_handler->module_frequency;
        handle_ptr->ccu4_slice_config_ptr->prescaler_initval = lprescaler;
 8026c40:	b2e1      	uxtb	r1, r4
                                               handle_ptr->ccu4_slice_config_ptr->prescaler_initval) / \
                                              TIMER_RESOLUTION_SEC_TO_MICRO);
        /* Actual timer period values is Period_reg_val+1U */
        if (handle_ptr->period_value > TIMER_PERIOD_MIN)
        {
          (handle_ptr->period_value)--;
 8026c42:	86f8      	strh	r0, [r7, #54]	; 0x36
        }
        /* Update the prescaler */
        XMC_CCU4_SLICE_SetPrescaler(handle_ptr->ccu4_slice_ptr, handle_ptr->ccu4_slice_config_ptr->prescaler_initval);
 8026c44:	f001 010f 	and.w	r1, r1, #15
 8026c48:	6978      	ldr	r0, [r7, #20]
 8026c4a:	f7fb f8b3 	bl	8021db4 <XMC_CCU4_SLICE_SetPrescaler>
  /* programs the timer period register according to time interval value */
  XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr, handle_ptr->period_value);
  /* programs the timer compare register for 50% duty cycle */
  XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr, TIMER_CMP_100_DUTY);
  /* Transfers value from shadow timer registers to actual timer registers */
  XMC_CCU4_EnableShadowTransfer(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->shadow_mask);
 8026c4e:	693a      	ldr	r2, [r7, #16]
 * This function configures timer period and compare values and triggers the shadow transfer operation
 */
void TIMER_CCU4_lShadowTransfer(TIMER_t* const handle_ptr)
{
  /* programs the timer period register according to time interval value */
  XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr, handle_ptr->period_value);
 8026c50:	697b      	ldr	r3, [r7, #20]
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerPeriodMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t period_val)
{
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->PRS = (uint32_t) period_val;
 8026c52:	8ef8      	ldrh	r0, [r7, #54]	; 0x36
  /* programs the timer compare register for 50% duty cycle */
  XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr, TIMER_CMP_100_DUTY);
  /* Transfers value from shadow timer registers to actual timer registers */
  XMC_CCU4_EnableShadowTransfer(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->shadow_mask);
 8026c54:	6892      	ldr	r2, [r2, #8]
 8026c56:	68f9      	ldr	r1, [r7, #12]
 8026c58:	6358      	str	r0, [r3, #52]	; 0x34
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerCompareMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t compare_val)
{
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->CRS = (uint32_t) compare_val;
 8026c5a:	2000      	movs	r0, #0
 8026c5c:	63d8      	str	r0, [r3, #60]	; 0x3c
 8026c5e:	f897 6035 	ldrb.w	r6, [r7, #53]	; 0x35
 *  None.
 */
__STATIC_INLINE void XMC_CCU4_EnableShadowTransfer(XMC_CCU4_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
  XMC_ASSERT("XMC_CCU4_EnableShadowTransfer:Invalid Slice Pointer", XMC_CCU4_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;  
 8026c62:	6111      	str	r1, [r2, #16]
 8026c64:	e77c      	b.n	8026b60 <TIMER_SetTimeInterval+0x48>
    /* check for time_interval range */
    if ((time_interval >= handle_ptr->timer_min_value_us) && (time_interval <= handle_ptr->timer_max_value_us))
    {
      /* Initialize the prescaler */
      lprescaler = 0U;
      while (time_interval > (handle_ptr->timer_max_value_us >> (TIMER_PRESCALER_MAX - lprescaler)))
 8026c66:	2400      	movs	r4, #0
 8026c68:	e775      	b.n	8026b56 <TIMER_SetTimeInterval+0x3e>
 8026c6a:	bf00      	nop
 8026c6c:	f3af 8000 	nop.w
 8026c70:	05f5e100 	.word	0x05f5e100
 8026c74:	00000000 	.word	0x00000000

08026c78 <TIMER_GetInterruptStatus>:
{
  bool status;
  XMC_ASSERT("TIMER_GetInterruptStatus:handle_ptr NULL" , (handle_ptr != NULL));
  status = false;
#ifdef TIMER_CCU4_USED
  if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8026c78:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 8026c7c:	b92b      	cbnz	r3, 8026c8a <TIMER_GetInterruptStatus+0x12>
  {
    /* Reads the interrupt status */
    status = XMC_CCU4_SLICE_GetEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
 8026c7e:	6943      	ldr	r3, [r0, #20]
__STATIC_INLINE bool XMC_CCU4_SLICE_GetEvent(const XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_IRQ_ID_t event)
{
  XMC_ASSERT("XMC_CCU4_SLICE_GetEvent:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_GetEvent:Invalid SR event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));

  return(((uint32_t)(slice->INTS & ((uint32_t)1 << (uint32_t)event))) != 0U);
 8026c80:	f8d3 00a0 	ldr.w	r0, [r3, #160]	; 0xa0
 8026c84:	f000 0001 	and.w	r0, r0, #1
 8026c88:	4770      	bx	lr
  }
#endif

#ifdef TIMER_CCU8_USED
  if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
 8026c8a:	2b01      	cmp	r3, #1
  {
    /* Reads the interrupt status */
    status = XMC_CCU8_SLICE_GetEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH);
 8026c8c:	bf03      	ittte	eq
 8026c8e:	6a83      	ldreq	r3, [r0, #40]	; 0x28
 */
__STATIC_INLINE bool XMC_CCU8_SLICE_GetEvent(const XMC_CCU8_SLICE_t *const slice, const XMC_CCU8_SLICE_IRQ_ID_t event)
{
  XMC_ASSERT("XMC_CCU8_SLICE_GetEvent:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_GetEvent:Invalid SR event", XMC_CCU8_SLICE_CHECK_INTERRUPT(event));
  return(((uint32_t)(slice->INTS & ((uint32_t)1 << event))) != 0U);
 8026c90:	f8d3 00a0 	ldreq.w	r0, [r3, #160]	; 0xa0
 8026c94:	f000 0001 	andeq.w	r0, r0, #1
 */
bool TIMER_GetInterruptStatus(TIMER_t * const handle_ptr)
{
  bool status;
  XMC_ASSERT("TIMER_GetInterruptStatus:handle_ptr NULL" , (handle_ptr != NULL));
  status = false;
 8026c98:	2000      	movne	r0, #0
    /* Reads the interrupt status */
    status = XMC_CCU8_SLICE_GetEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH);
  }
#endif
  return (status);
}
 8026c9a:	4770      	bx	lr

08026c9c <TIMER_ClearEvent>:
void TIMER_ClearEvent(TIMER_t *const handle_ptr)
{
  XMC_ASSERT("TIME_CCU_AcknowledgeInterrupt:handle_ptr NULL" , (handle_ptr != NULL));

#ifdef TIMER_CCU4_USED
  if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8026c9c:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 8026ca0:	b93b      	cbnz	r3, 8026cb2 <TIMER_ClearEvent+0x16>
  {
    /* clears the timer event(period match interrupt) */
    XMC_CCU4_SLICE_ClearEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
 8026ca2:	6942      	ldr	r2, [r0, #20]
 */
__STATIC_INLINE void XMC_CCU4_SLICE_ClearEvent(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_IRQ_ID_t event)
{
  XMC_ASSERT("XMC_CCU4_SLICE_ClearEvent:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_ClearEvent:Invalid SR event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  slice->SWR |= ((uint32_t) 1) << ((uint32_t) event);
 8026ca4:	f8d2 30b0 	ldr.w	r3, [r2, #176]	; 0xb0
 8026ca8:	f043 0301 	orr.w	r3, r3, #1
 8026cac:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
 8026cb0:	4770      	bx	lr
  }
#endif

#ifdef TIMER_CCU8_USED
  if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
 8026cb2:	2b01      	cmp	r3, #1
 8026cb4:	d106      	bne.n	8026cc4 <TIMER_ClearEvent+0x28>
  {
    /* clears the timer event(period match interrupt) */
    XMC_CCU8_SLICE_ClearEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH);
 8026cb6:	6a82      	ldr	r2, [r0, #40]	; 0x28
 */
__STATIC_INLINE void XMC_CCU8_SLICE_ClearEvent(XMC_CCU8_SLICE_t *const slice, const XMC_CCU8_SLICE_IRQ_ID_t event)
{
  XMC_ASSERT("XMC_CCU8_SLICE_ClearEvent:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_ClearEvent:Invalid SR event", XMC_CCU8_SLICE_CHECK_INTERRUPT(event));
  slice->SWR |= ((uint32_t) 1) << ((uint32_t) event);
 8026cb8:	f8d2 30b0 	ldr.w	r3, [r2, #176]	; 0xb0
 8026cbc:	f043 0301 	orr.w	r3, r3, #1
 8026cc0:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
 8026cc4:	4770      	bx	lr
 8026cc6:	bf00      	nop

08026cc8 <TIMER_Clear>:
  TIMER_STATUS_t status;

  XMC_ASSERT("TIMER_Clear:handle_ptr NULL" , (handle_ptr != NULL));

  /* Check for APP instance is initialized or not */
  if (true == handle_ptr->initialized)
 8026cc8:	f890 303a 	ldrb.w	r3, [r0, #58]	; 0x3a
 8026ccc:	b173      	cbz	r3, 8026cec <TIMER_Clear+0x24>
  {
#ifdef TIMER_CCU4_USED
    if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8026cce:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 8026cd2:	b133      	cbz	r3, 8026ce2 <TIMER_Clear+0x1a>
      XMC_CCU4_SLICE_ClearTimer(handle_ptr->ccu4_slice_ptr);
    }
#endif

#ifdef TIMER_CCU8_USED
    if (TIMER_MODULE_CCU8 == handle_ptr->timer_module)
 8026cd4:	2b01      	cmp	r3, #1
 8026cd6:	d10b      	bne.n	8026cf0 <TIMER_Clear+0x28>
    {
      /* Clear the timer register */
      XMC_CCU8_SLICE_ClearTimer(handle_ptr->ccu8_slice_ptr);
 8026cd8:	6a83      	ldr	r3, [r0, #40]	; 0x28
 *  XMC_CCU8_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_ClearTimer(XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_ClearTimer:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU8_CC8_TCCLR_TCC_Msk;
 8026cda:	2202      	movs	r2, #2
 8026cdc:	611a      	str	r2, [r3, #16]
    }
#endif
    status = TIMER_STATUS_SUCCESS;
 8026cde:	2000      	movs	r0, #0
 8026ce0:	4770      	bx	lr
  {
#ifdef TIMER_CCU4_USED
    if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
    {
      /* Clear the timer register */
      XMC_CCU4_SLICE_ClearTimer(handle_ptr->ccu4_slice_ptr);
 8026ce2:	6942      	ldr	r2, [r0, #20]
 *  XMC_CCU4_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_ClearTimer(XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_ClearTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TCC_Msk;
 8026ce4:	2102      	movs	r1, #2
    {
      /* Clear the timer register */
      XMC_CCU8_SLICE_ClearTimer(handle_ptr->ccu8_slice_ptr);
    }
#endif
    status = TIMER_STATUS_SUCCESS;
 8026ce6:	4618      	mov	r0, r3
 8026ce8:	6111      	str	r1, [r2, #16]
 8026cea:	4770      	bx	lr
  }
  else
  {
    status = TIMER_STATUS_FAILURE;
 8026cec:	2001      	movs	r0, #1
 8026cee:	4770      	bx	lr
    {
      /* Clear the timer register */
      XMC_CCU8_SLICE_ClearTimer(handle_ptr->ccu8_slice_ptr);
    }
#endif
    status = TIMER_STATUS_SUCCESS;
 8026cf0:	2000      	movs	r0, #0
  {
    status = TIMER_STATUS_FAILURE;
  }

  return (status);
}
 8026cf2:	4770      	bx	lr

08026cf4 <SysTick_Handler>:
 */
void SysTick_Handler(void)
{
  SYSTIMER_OBJECT_t *object_ptr;
  object_ptr = g_timer_list;
  g_systick_count++;
 8026cf4:	4999      	ldr	r1, [pc, #612]	; (8026f5c <SysTick_Handler+0x268>)

/*
 *  SysTick Event Handler.
 */
void SysTick_Handler(void)
{
 8026cf6:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  SYSTIMER_OBJECT_t *object_ptr;
  object_ptr = g_timer_list;
 8026cfa:	4d99      	ldr	r5, [pc, #612]	; (8026f60 <SysTick_Handler+0x26c>)
  g_systick_count++;
 8026cfc:	680a      	ldr	r2, [r1, #0]
 *  SysTick Event Handler.
 */
void SysTick_Handler(void)
{
  SYSTIMER_OBJECT_t *object_ptr;
  object_ptr = g_timer_list;
 8026cfe:	682b      	ldr	r3, [r5, #0]
  g_systick_count++;
 8026d00:	3201      	adds	r2, #1
 8026d02:	600a      	str	r2, [r1, #0]

  if (NULL != object_ptr)
 8026d04:	b133      	cbz	r3, 8026d14 <SysTick_Handler+0x20>
  {
    if (object_ptr->count > 1UL)
 8026d06:	699a      	ldr	r2, [r3, #24]
 8026d08:	2a01      	cmp	r2, #1
 8026d0a:	d905      	bls.n	8026d18 <SysTick_Handler+0x24>
    {
      object_ptr->count--;
 8026d0c:	3a01      	subs	r2, #1
 8026d0e:	619a      	str	r2, [r3, #24]
 8026d10:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8026d14:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    }
    else
    {
      object_ptr->count = 0U;
 8026d18:	2200      	movs	r2, #0
static void SYSTIMER_lRemoveTimerList(uint32_t tbl_index)
{
  SYSTIMER_OBJECT_t *object_ptr;
  object_ptr = &g_timer_tbl[tbl_index];
  /* Check whether only one timer available */
  if ((NULL == object_ptr->prev) && (NULL == object_ptr->next ))
 8026d1a:	4c92      	ldr	r4, [pc, #584]	; (8026f64 <SysTick_Handler+0x270>)
    {
      object_ptr->count--;
    }
    else
    {
      object_ptr->count = 0U;
 8026d1c:	619a      	str	r2, [r3, #24]
 8026d1e:	e007      	b.n	8026d30 <SysTick_Handler+0x3c>
      g_timer_tracker &= ~(1U << object_ptr->id);
    }
    /* Check whether timer is a one shot timer */
    else if (SYSTIMER_MODE_ONE_SHOT == object_ptr->mode)
    {
      if (SYSTIMER_STATE_RUNNING == object_ptr->state)
 8026d20:	7b5a      	ldrb	r2, [r3, #13]
 8026d22:	2a01      	cmp	r2, #1
 8026d24:	f000 80a1 	beq.w	8026e6a <SysTick_Handler+0x176>
static void SYSTIMER_lTimerHandler(void)
{
  SYSTIMER_OBJECT_t *object_ptr;
  /* Get first item of timer list */
  object_ptr = g_timer_list;
  while ((NULL != object_ptr) && (0U == object_ptr->count))
 8026d28:	699a      	ldr	r2, [r3, #24]
 8026d2a:	2a00      	cmp	r2, #0
 8026d2c:	f040 80d4 	bne.w	8026ed8 <SysTick_Handler+0x1e4>
  {
    if (true == object_ptr->delete_swtmr)
 8026d30:	f893 2020 	ldrb.w	r2, [r3, #32]
 8026d34:	2a00      	cmp	r2, #0
 8026d36:	d16d      	bne.n	8026e14 <SysTick_Handler+0x120>
      object_ptr->state = SYSTIMER_STATE_NOT_INITIALIZED;
      /* Release resource which are hold by this timer */
      g_timer_tracker &= ~(1U << object_ptr->id);
    }
    /* Check whether timer is a one shot timer */
    else if (SYSTIMER_MODE_ONE_SHOT == object_ptr->mode)
 8026d38:	7b19      	ldrb	r1, [r3, #12]
 8026d3a:	2900      	cmp	r1, #0
 8026d3c:	d0f0      	beq.n	8026d20 <SysTick_Handler+0x2c>
        /* Call timer callback function */
        (object_ptr->callback)(object_ptr->args);
      }
    }
    /* Check whether timer is periodic timer */
    else if (SYSTIMER_MODE_PERIODIC == object_ptr->mode)
 8026d3e:	2901      	cmp	r1, #1
 8026d40:	d1e8      	bne.n	8026d14 <SysTick_Handler+0x20>
    {
      if (SYSTIMER_STATE_RUNNING == object_ptr->state)
 8026d42:	7b59      	ldrb	r1, [r3, #13]
 8026d44:	2901      	cmp	r1, #1
 8026d46:	d1ef      	bne.n	8026d28 <SysTick_Handler+0x34>
      {
        /* Yes, remove this timer from timer list */
        SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
 8026d48:	6959      	ldr	r1, [r3, #20]
static void SYSTIMER_lRemoveTimerList(uint32_t tbl_index)
{
  SYSTIMER_OBJECT_t *object_ptr;
  object_ptr = &g_timer_tbl[tbl_index];
  /* Check whether only one timer available */
  if ((NULL == object_ptr->prev) && (NULL == object_ptr->next ))
 8026d4a:	ea4f 0ec1 	mov.w	lr, r1, lsl #3
 8026d4e:	eb0e 0901 	add.w	r9, lr, r1
 8026d52:	eb04 0889 	add.w	r8, r4, r9, lsl #2
 8026d56:	f8d8 a004 	ldr.w	sl, [r8, #4]
 8026d5a:	f1ba 0f00 	cmp.w	sl, #0
 8026d5e:	f000 80d6 	beq.w	8026f0e <SysTick_Handler+0x21a>
    g_timer_list->prev = NULL;
    g_timer_list->count += object_ptr->count;
    object_ptr->next    = NULL;
  }
  /* Check if the last item in timer list */
  else if (NULL == object_ptr->next)
 8026d62:	f854 0029 	ldr.w	r0, [r4, r9, lsl #2]
  {
    /* Remove timer from list */
    object_ptr->prev->next = NULL;
 8026d66:	f8ca 0000 	str.w	r0, [sl]
    g_timer_list->prev = NULL;
    g_timer_list->count += object_ptr->count;
    object_ptr->next    = NULL;
  }
  /* Check if the last item in timer list */
  else if (NULL == object_ptr->next)
 8026d6a:	2800      	cmp	r0, #0
 8026d6c:	f000 80f0 	beq.w	8026f50 <SysTick_Handler+0x25c>
  else                       
  {
    /* Remove timer from list */
    object_ptr->prev->next  =  object_ptr->next;
    object_ptr->next->prev  =  object_ptr->prev;
    object_ptr->next->count += object_ptr->count;
 8026d70:	f854 e029 	ldr.w	lr, [r4, r9, lsl #2]
 8026d74:	f8d8 0018 	ldr.w	r0, [r8, #24]
 8026d78:	f8de b018 	ldr.w	fp, [lr, #24]
  }
  else                       
  {
    /* Remove timer from list */
    object_ptr->prev->next  =  object_ptr->next;
    object_ptr->next->prev  =  object_ptr->prev;
 8026d7c:	f8ce a004 	str.w	sl, [lr, #4]
    object_ptr->next->count += object_ptr->count;
 8026d80:	4458      	add	r0, fp
 8026d82:	f8ce 0018 	str.w	r0, [lr, #24]
 8026d86:	682f      	ldr	r7, [r5, #0]
    object_ptr->next = NULL;
 8026d88:	f844 2029 	str.w	r2, [r4, r9, lsl #2]
    object_ptr->prev = NULL;
 8026d8c:	f8c8 2004 	str.w	r2, [r8, #4]
  SYSTIMER_OBJECT_t *object_ptr;
  int32_t delta_ticks;
  int32_t timer_count;
  bool found_flag = false;
   /* Get timer time */
  timer_count = (int32_t)g_timer_tbl[tbl_index].count;
 8026d90:	ea4f 0ec1 	mov.w	lr, r1, lsl #3
 8026d94:	eb0e 0001 	add.w	r0, lr, r1
 8026d98:	eb04 0080 	add.w	r0, r4, r0, lsl #2
      if (SYSTIMER_STATE_RUNNING == object_ptr->state)
      {
        /* Yes, remove this timer from timer list */
        SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
        /* Reset timer tick */
        object_ptr->count = object_ptr->reload;
 8026d9c:	69da      	ldr	r2, [r3, #28]
 8026d9e:	619a      	str	r2, [r3, #24]
  SYSTIMER_OBJECT_t *object_ptr;
  int32_t delta_ticks;
  int32_t timer_count;
  bool found_flag = false;
   /* Get timer time */
  timer_count = (int32_t)g_timer_tbl[tbl_index].count;
 8026da0:	6980      	ldr	r0, [r0, #24]
  /* Check if Timer list is NULL */
  if (NULL == g_timer_list)
 8026da2:	2f00      	cmp	r7, #0
 8026da4:	f000 80ca 	beq.w	8026f3c <SysTick_Handler+0x248>
 8026da8:	f8d5 c000 	ldr.w	ip, [r5]
 8026dac:	463a      	mov	r2, r7
    delta_ticks = timer_count;
    /* Find correct place for inserting the timer */
    while ((NULL != object_ptr) && (false == found_flag))
    {
      /* Get timer Count Difference */
      delta_ticks -= (int32_t)object_ptr->count;
 8026dae:	6997      	ldr	r7, [r2, #24]
 8026db0:	1bc0      	subs	r0, r0, r7
      /* Check for delta ticks < 0 */
      if (delta_ticks <= 0)
 8026db2:	2800      	cmp	r0, #0
 8026db4:	dd08      	ble.n	8026dc8 <SysTick_Handler+0xd4>
        found_flag = true;
      }
      /* Check for last item in list */
      else
      {
        if ((delta_ticks > 0) && (NULL == object_ptr->next))
 8026db6:	6817      	ldr	r7, [r2, #0]
 8026db8:	2f00      	cmp	r7, #0
 8026dba:	f000 8086 	beq.w	8026eca <SysTick_Handler+0x1d6>
 8026dbe:	463a      	mov	r2, r7
    delta_ticks = timer_count;
    /* Find correct place for inserting the timer */
    while ((NULL != object_ptr) && (false == found_flag))
    {
      /* Get timer Count Difference */
      delta_ticks -= (int32_t)object_ptr->count;
 8026dc0:	6997      	ldr	r7, [r2, #24]
 8026dc2:	1bc0      	subs	r0, r0, r7
      /* Check for delta ticks < 0 */
      if (delta_ticks <= 0)
 8026dc4:	2800      	cmp	r0, #0
 8026dc6:	dcf6      	bgt.n	8026db6 <SysTick_Handler+0xc2>
      {
        /* Check If head item */
        if (NULL != object_ptr->prev)
 8026dc8:	6857      	ldr	r7, [r2, #4]
 8026dca:	2f00      	cmp	r7, #0
 8026dcc:	f000 808a 	beq.w	8026ee4 <SysTick_Handler+0x1f0>
        {
          /* If Insert to list */
          object_ptr->prev->next = &g_timer_tbl[tbl_index];
 8026dd0:	eb0e 0901 	add.w	r9, lr, r1
 8026dd4:	eb04 0889 	add.w	r8, r4, r9, lsl #2
 8026dd8:	f8c7 8000 	str.w	r8, [r7]
          g_timer_tbl[tbl_index].prev = object_ptr->prev;
 8026ddc:	f8c8 7004 	str.w	r7, [r8, #4]
          g_timer_tbl[tbl_index].next = object_ptr;
 8026de0:	f844 2029 	str.w	r2, [r4, r9, lsl #2]
          object_ptr->prev = &g_timer_tbl[tbl_index];
 8026de4:	f8c2 8004 	str.w	r8, [r2, #4]
          /* Set Timer as first item */
          g_timer_tbl[tbl_index].next = g_timer_list;
          g_timer_list->prev = &g_timer_tbl[tbl_index];
          g_timer_list = &g_timer_tbl[tbl_index];
        }
        g_timer_tbl[tbl_index].count = g_timer_tbl[tbl_index].next->count + (uint32_t)delta_ticks;
 8026de8:	4471      	add	r1, lr
 8026dea:	eb04 0e81 	add.w	lr, r4, r1, lsl #2
 8026dee:	f854 1021 	ldr.w	r1, [r4, r1, lsl #2]
 8026df2:	698a      	ldr	r2, [r1, #24]
 8026df4:	4410      	add	r0, r2
 8026df6:	f8ce 0018 	str.w	r0, [lr, #24]
        g_timer_tbl[tbl_index].next->count  -= g_timer_tbl[tbl_index].count;
 8026dfa:	698a      	ldr	r2, [r1, #24]
 8026dfc:	1a10      	subs	r0, r2, r0
 8026dfe:	6188      	str	r0, [r1, #24]
 8026e00:	f8c5 c000 	str.w	ip, [r5]
        /* Reset timer tick */
        object_ptr->count = object_ptr->reload;
        /* Insert timer into timer list */
        SYSTIMER_lInsertTimerList((uint32_t)object_ptr->id);
        /* Call timer callback function */
        (object_ptr->callback)(object_ptr->args);
 8026e04:	689a      	ldr	r2, [r3, #8]
 8026e06:	6918      	ldr	r0, [r3, #16]
 8026e08:	4790      	blx	r2
 8026e0a:	682a      	ldr	r2, [r5, #0]
static void SYSTIMER_lTimerHandler(void)
{
  SYSTIMER_OBJECT_t *object_ptr;
  /* Get first item of timer list */
  object_ptr = g_timer_list;
  while ((NULL != object_ptr) && (0U == object_ptr->count))
 8026e0c:	2a00      	cmp	r2, #0
 8026e0e:	d081      	beq.n	8026d14 <SysTick_Handler+0x20>
 8026e10:	4613      	mov	r3, r2
 8026e12:	e789      	b.n	8026d28 <SysTick_Handler+0x34>
  {
    if (true == object_ptr->delete_swtmr)
    {
      /* Yes, remove this timer from timer list */
      SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
 8026e14:	6959      	ldr	r1, [r3, #20]
static void SYSTIMER_lRemoveTimerList(uint32_t tbl_index)
{
  SYSTIMER_OBJECT_t *object_ptr;
  object_ptr = &g_timer_tbl[tbl_index];
  /* Check whether only one timer available */
  if ((NULL == object_ptr->prev) && (NULL == object_ptr->next ))
 8026e16:	eb01 0ec1 	add.w	lr, r1, r1, lsl #3
 8026e1a:	eb04 088e 	add.w	r8, r4, lr, lsl #2
 8026e1e:	f8d8 c004 	ldr.w	ip, [r8, #4]
 8026e22:	f1bc 0f00 	cmp.w	ip, #0
 8026e26:	d041      	beq.n	8026eac <SysTick_Handler+0x1b8>
    g_timer_list->prev = NULL;
    g_timer_list->count += object_ptr->count;
    object_ptr->next    = NULL;
  }
  /* Check if the last item in timer list */
  else if (NULL == object_ptr->next)
 8026e28:	f854 002e 	ldr.w	r0, [r4, lr, lsl #2]
  {
    /* Remove timer from list */
    object_ptr->prev->next = NULL;
 8026e2c:	f8cc 0000 	str.w	r0, [ip]
    g_timer_list->prev = NULL;
    g_timer_list->count += object_ptr->count;
    object_ptr->next    = NULL;
  }
  /* Check if the last item in timer list */
  else if (NULL == object_ptr->next)
 8026e30:	2800      	cmp	r0, #0
 8026e32:	d053      	beq.n	8026edc <SysTick_Handler+0x1e8>
  else                       
  {
    /* Remove timer from list */
    object_ptr->prev->next  =  object_ptr->next;
    object_ptr->next->prev  =  object_ptr->prev;
    object_ptr->next->count += object_ptr->count;
 8026e34:	f854 002e 	ldr.w	r0, [r4, lr, lsl #2]
 8026e38:	f8d8 2018 	ldr.w	r2, [r8, #24]
 8026e3c:	6987      	ldr	r7, [r0, #24]
  }
  else                       
  {
    /* Remove timer from list */
    object_ptr->prev->next  =  object_ptr->next;
    object_ptr->next->prev  =  object_ptr->prev;
 8026e3e:	f8c0 c004 	str.w	ip, [r0, #4]
    object_ptr->next->count += object_ptr->count;
 8026e42:	443a      	add	r2, r7
    object_ptr->next = NULL;
 8026e44:	2700      	movs	r7, #0
  else                       
  {
    /* Remove timer from list */
    object_ptr->prev->next  =  object_ptr->next;
    object_ptr->next->prev  =  object_ptr->prev;
    object_ptr->next->count += object_ptr->count;
 8026e46:	6182      	str	r2, [r0, #24]
    object_ptr->next = NULL;
 8026e48:	f844 702e 	str.w	r7, [r4, lr, lsl #2]
    object_ptr->prev = NULL;
 8026e4c:	f8c8 7004 	str.w	r7, [r8, #4]
 8026e50:	461a      	mov	r2, r3
      /* Yes, remove this timer from timer list */
      SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
      /* Set timer status as SYSTIMER_STATE_NOT_INITIALIZED */
      object_ptr->state = SYSTIMER_STATE_NOT_INITIALIZED;
      /* Release resource which are hold by this timer */
      g_timer_tracker &= ~(1U << object_ptr->id);
 8026e52:	4845      	ldr	r0, [pc, #276]	; (8026f68 <SysTick_Handler+0x274>)
 8026e54:	4e44      	ldr	r6, [pc, #272]	; (8026f68 <SysTick_Handler+0x274>)
 8026e56:	6800      	ldr	r0, [r0, #0]
 8026e58:	2701      	movs	r7, #1
 8026e5a:	fa07 f101 	lsl.w	r1, r7, r1
 8026e5e:	ea20 0001 	bic.w	r0, r0, r1
    if (true == object_ptr->delete_swtmr)
    {
      /* Yes, remove this timer from timer list */
      SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
      /* Set timer status as SYSTIMER_STATE_NOT_INITIALIZED */
      object_ptr->state = SYSTIMER_STATE_NOT_INITIALIZED;
 8026e62:	2100      	movs	r1, #0
      /* Release resource which are hold by this timer */
      g_timer_tracker &= ~(1U << object_ptr->id);
 8026e64:	6030      	str	r0, [r6, #0]
    if (true == object_ptr->delete_swtmr)
    {
      /* Yes, remove this timer from timer list */
      SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
      /* Set timer status as SYSTIMER_STATE_NOT_INITIALIZED */
      object_ptr->state = SYSTIMER_STATE_NOT_INITIALIZED;
 8026e66:	7359      	strb	r1, [r3, #13]
 8026e68:	e7d0      	b.n	8026e0c <SysTick_Handler+0x118>
    else if (SYSTIMER_MODE_ONE_SHOT == object_ptr->mode)
    {
      if (SYSTIMER_STATE_RUNNING == object_ptr->state)
      {
        /* Yes, remove this timer from timer list */
        SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
 8026e6a:	695a      	ldr	r2, [r3, #20]
static void SYSTIMER_lRemoveTimerList(uint32_t tbl_index)
{
  SYSTIMER_OBJECT_t *object_ptr;
  object_ptr = &g_timer_tbl[tbl_index];
  /* Check whether only one timer available */
  if ((NULL == object_ptr->prev) && (NULL == object_ptr->next ))
 8026e6c:	eb02 0ec2 	add.w	lr, r2, r2, lsl #3
 8026e70:	eb04 088e 	add.w	r8, r4, lr, lsl #2
 8026e74:	f854 202e 	ldr.w	r2, [r4, lr, lsl #2]
 8026e78:	f8d8 7004 	ldr.w	r7, [r8, #4]
 8026e7c:	2f00      	cmp	r7, #0
 8026e7e:	d03b      	beq.n	8026ef8 <SysTick_Handler+0x204>
  }
  /* Check if the last item in timer list */
  else if (NULL == object_ptr->next)
  {
    /* Remove timer from list */
    object_ptr->prev->next = NULL;
 8026e80:	603a      	str	r2, [r7, #0]
    g_timer_list->prev = NULL;
    g_timer_list->count += object_ptr->count;
    object_ptr->next    = NULL;
  }
  /* Check if the last item in timer list */
  else if (NULL == object_ptr->next)
 8026e82:	2a00      	cmp	r2, #0
 8026e84:	d061      	beq.n	8026f4a <SysTick_Handler+0x256>
  else                       
  {
    /* Remove timer from list */
    object_ptr->prev->next  =  object_ptr->next;
    object_ptr->next->prev  =  object_ptr->prev;
    object_ptr->next->count += object_ptr->count;
 8026e86:	f854 002e 	ldr.w	r0, [r4, lr, lsl #2]
 8026e8a:	f8d8 2018 	ldr.w	r2, [r8, #24]
 8026e8e:	6986      	ldr	r6, [r0, #24]
  }
  else                       
  {
    /* Remove timer from list */
    object_ptr->prev->next  =  object_ptr->next;
    object_ptr->next->prev  =  object_ptr->prev;
 8026e90:	6047      	str	r7, [r0, #4]
    object_ptr->next->count += object_ptr->count;
 8026e92:	4432      	add	r2, r6
 8026e94:	6182      	str	r2, [r0, #24]
    object_ptr->next = NULL;
 8026e96:	f844 102e 	str.w	r1, [r4, lr, lsl #2]
    object_ptr->prev = NULL;
 8026e9a:	f8c8 1004 	str.w	r1, [r8, #4]
      if (SYSTIMER_STATE_RUNNING == object_ptr->state)
      {
        /* Yes, remove this timer from timer list */
        SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
        /* Set timer status as SYSTIMER_STATE_STOPPED */
        object_ptr->state = SYSTIMER_STATE_STOPPED;
 8026e9e:	2202      	movs	r2, #2
 8026ea0:	735a      	strb	r2, [r3, #13]
        /* Call timer callback function */
        (object_ptr->callback)(object_ptr->args);
 8026ea2:	6918      	ldr	r0, [r3, #16]
 8026ea4:	689a      	ldr	r2, [r3, #8]
 8026ea6:	4790      	blx	r2
 8026ea8:	682a      	ldr	r2, [r5, #0]
 8026eaa:	e7af      	b.n	8026e0c <SysTick_Handler+0x118>
static void SYSTIMER_lRemoveTimerList(uint32_t tbl_index)
{
  SYSTIMER_OBJECT_t *object_ptr;
  object_ptr = &g_timer_tbl[tbl_index];
  /* Check whether only one timer available */
  if ((NULL == object_ptr->prev) && (NULL == object_ptr->next ))
 8026eac:	f854 202e 	ldr.w	r2, [r4, lr, lsl #2]
 8026eb0:	2a00      	cmp	r2, #0
 8026eb2:	d048      	beq.n	8026f46 <SysTick_Handler+0x252>
  else if (NULL == object_ptr->prev)
  {
    /* Remove timer from list, and reset timer list */
    g_timer_list  = object_ptr->next;
    g_timer_list->prev = NULL;
    g_timer_list->count += object_ptr->count;
 8026eb4:	f8d8 7018 	ldr.w	r7, [r8, #24]
 8026eb8:	6990      	ldr	r0, [r2, #24]
  /* Check if the first item in timer list */
  else if (NULL == object_ptr->prev)
  {
    /* Remove timer from list, and reset timer list */
    g_timer_list  = object_ptr->next;
    g_timer_list->prev = NULL;
 8026eba:	f8c2 c004 	str.w	ip, [r2, #4]
    g_timer_list->count += object_ptr->count;
 8026ebe:	4438      	add	r0, r7
 8026ec0:	6190      	str	r0, [r2, #24]
  }
  /* Check if the first item in timer list */
  else if (NULL == object_ptr->prev)
  {
    /* Remove timer from list, and reset timer list */
    g_timer_list  = object_ptr->next;
 8026ec2:	602a      	str	r2, [r5, #0]
    g_timer_list->prev = NULL;
    g_timer_list->count += object_ptr->count;
    object_ptr->next    = NULL;
 8026ec4:	f844 c02e 	str.w	ip, [r4, lr, lsl #2]
 8026ec8:	e7c3      	b.n	8026e52 <SysTick_Handler+0x15e>
      else
      {
        if ((delta_ticks > 0) && (NULL == object_ptr->next))
        {
          /* Yes, insert into */
          g_timer_tbl[tbl_index].prev = object_ptr;
 8026eca:	4471      	add	r1, lr
 8026ecc:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 8026ed0:	604a      	str	r2, [r1, #4]
          object_ptr->next = &g_timer_tbl[tbl_index];
 8026ed2:	6011      	str	r1, [r2, #0]
          g_timer_tbl[tbl_index].count = (uint32_t)delta_ticks;
 8026ed4:	6188      	str	r0, [r1, #24]
 8026ed6:	e793      	b.n	8026e00 <SysTick_Handler+0x10c>
 8026ed8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8026edc:	682a      	ldr	r2, [r5, #0]
  /* Check if the last item in timer list */
  else if (NULL == object_ptr->next)
  {
    /* Remove timer from list */
    object_ptr->prev->next = NULL;
    object_ptr->prev = NULL;
 8026ede:	f8c8 0004 	str.w	r0, [r8, #4]
 8026ee2:	e7b6      	b.n	8026e52 <SysTick_Handler+0x15e>
          object_ptr->prev = &g_timer_tbl[tbl_index];
        }
        else
        {
          /* Set Timer as first item */
          g_timer_tbl[tbl_index].next = g_timer_list;
 8026ee4:	eb0e 0801 	add.w	r8, lr, r1
 8026ee8:	eb04 0788 	add.w	r7, r4, r8, lsl #2
 8026eec:	f844 c028 	str.w	ip, [r4, r8, lsl #2]
          g_timer_list->prev = &g_timer_tbl[tbl_index];
 8026ef0:	f8cc 7004 	str.w	r7, [ip, #4]
          g_timer_list = &g_timer_tbl[tbl_index];
 8026ef4:	46bc      	mov	ip, r7
 8026ef6:	e777      	b.n	8026de8 <SysTick_Handler+0xf4>
static void SYSTIMER_lRemoveTimerList(uint32_t tbl_index)
{
  SYSTIMER_OBJECT_t *object_ptr;
  object_ptr = &g_timer_tbl[tbl_index];
  /* Check whether only one timer available */
  if ((NULL == object_ptr->prev) && (NULL == object_ptr->next ))
 8026ef8:	b372      	cbz	r2, 8026f58 <SysTick_Handler+0x264>
  else if (NULL == object_ptr->prev)
  {
    /* Remove timer from list, and reset timer list */
    g_timer_list  = object_ptr->next;
    g_timer_list->prev = NULL;
    g_timer_list->count += object_ptr->count;
 8026efa:	f8d8 0018 	ldr.w	r0, [r8, #24]
 8026efe:	6991      	ldr	r1, [r2, #24]
  /* Check if the first item in timer list */
  else if (NULL == object_ptr->prev)
  {
    /* Remove timer from list, and reset timer list */
    g_timer_list  = object_ptr->next;
    g_timer_list->prev = NULL;
 8026f00:	6057      	str	r7, [r2, #4]
    g_timer_list->count += object_ptr->count;
 8026f02:	4401      	add	r1, r0
 8026f04:	6191      	str	r1, [r2, #24]
  }
  /* Check if the first item in timer list */
  else if (NULL == object_ptr->prev)
  {
    /* Remove timer from list, and reset timer list */
    g_timer_list  = object_ptr->next;
 8026f06:	602a      	str	r2, [r5, #0]
    g_timer_list->prev = NULL;
    g_timer_list->count += object_ptr->count;
    object_ptr->next    = NULL;
 8026f08:	f844 702e 	str.w	r7, [r4, lr, lsl #2]
 8026f0c:	e7c7      	b.n	8026e9e <SysTick_Handler+0x1aa>
static void SYSTIMER_lRemoveTimerList(uint32_t tbl_index)
{
  SYSTIMER_OBJECT_t *object_ptr;
  object_ptr = &g_timer_tbl[tbl_index];
  /* Check whether only one timer available */
  if ((NULL == object_ptr->prev) && (NULL == object_ptr->next ))
 8026f0e:	f854 2029 	ldr.w	r2, [r4, r9, lsl #2]
 8026f12:	b18a      	cbz	r2, 8026f38 <SysTick_Handler+0x244>
  else if (NULL == object_ptr->prev)
  {
    /* Remove timer from list, and reset timer list */
    g_timer_list  = object_ptr->next;
    g_timer_list->prev = NULL;
    g_timer_list->count += object_ptr->count;
 8026f14:	6990      	ldr	r0, [r2, #24]
 8026f16:	f8d8 7018 	ldr.w	r7, [r8, #24]
      if (SYSTIMER_STATE_RUNNING == object_ptr->state)
      {
        /* Yes, remove this timer from timer list */
        SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
        /* Reset timer tick */
        object_ptr->count = object_ptr->reload;
 8026f1a:	f8d3 c01c 	ldr.w	ip, [r3, #28]
  /* Check if the first item in timer list */
  else if (NULL == object_ptr->prev)
  {
    /* Remove timer from list, and reset timer list */
    g_timer_list  = object_ptr->next;
    g_timer_list->prev = NULL;
 8026f1e:	f8c2 a004 	str.w	sl, [r2, #4]
    g_timer_list->count += object_ptr->count;
 8026f22:	4438      	add	r0, r7
 8026f24:	6190      	str	r0, [r2, #24]
    object_ptr->next    = NULL;
 8026f26:	f844 a029 	str.w	sl, [r4, r9, lsl #2]
      if (SYSTIMER_STATE_RUNNING == object_ptr->state)
      {
        /* Yes, remove this timer from timer list */
        SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
        /* Reset timer tick */
        object_ptr->count = object_ptr->reload;
 8026f2a:	f8c3 c018 	str.w	ip, [r3, #24]
  }
  /* Check if the first item in timer list */
  else if (NULL == object_ptr->prev)
  {
    /* Remove timer from list, and reset timer list */
    g_timer_list  = object_ptr->next;
 8026f2e:	602a      	str	r2, [r5, #0]
  SYSTIMER_OBJECT_t *object_ptr;
  int32_t delta_ticks;
  int32_t timer_count;
  bool found_flag = false;
   /* Get timer time */
  timer_count = (int32_t)g_timer_tbl[tbl_index].count;
 8026f30:	f8d8 0018 	ldr.w	r0, [r8, #24]
 8026f34:	4694      	mov	ip, r2
 8026f36:	e73a      	b.n	8026dae <SysTick_Handler+0xba>
      if (SYSTIMER_STATE_RUNNING == object_ptr->state)
      {
        /* Yes, remove this timer from timer list */
        SYSTIMER_lRemoveTimerList((uint32_t)object_ptr->id);
        /* Reset timer tick */
        object_ptr->count = object_ptr->reload;
 8026f38:	69da      	ldr	r2, [r3, #28]
 8026f3a:	619a      	str	r2, [r3, #24]
  timer_count = (int32_t)g_timer_tbl[tbl_index].count;
  /* Check if Timer list is NULL */
  if (NULL == g_timer_list)
  {
    /* Set this as first Timer */
    g_timer_list = &g_timer_tbl[tbl_index];
 8026f3c:	4471      	add	r1, lr
 8026f3e:	eb04 0281 	add.w	r2, r4, r1, lsl #2
 8026f42:	602a      	str	r2, [r5, #0]
 8026f44:	e75e      	b.n	8026e04 <SysTick_Handler+0x110>
  object_ptr = &g_timer_tbl[tbl_index];
  /* Check whether only one timer available */
  if ((NULL == object_ptr->prev) && (NULL == object_ptr->next ))
  {
    /* set timer list as NULL */ 
    g_timer_list = NULL;                  
 8026f46:	602a      	str	r2, [r5, #0]
 8026f48:	e783      	b.n	8026e52 <SysTick_Handler+0x15e>
  /* Check if the last item in timer list */
  else if (NULL == object_ptr->next)
  {
    /* Remove timer from list */
    object_ptr->prev->next = NULL;
    object_ptr->prev = NULL;
 8026f4a:	f8c8 2004 	str.w	r2, [r8, #4]
 8026f4e:	e7a6      	b.n	8026e9e <SysTick_Handler+0x1aa>
 8026f50:	682f      	ldr	r7, [r5, #0]
 8026f52:	f8c8 0004 	str.w	r0, [r8, #4]
 8026f56:	e71b      	b.n	8026d90 <SysTick_Handler+0x9c>
  object_ptr = &g_timer_tbl[tbl_index];
  /* Check whether only one timer available */
  if ((NULL == object_ptr->prev) && (NULL == object_ptr->next ))
  {
    /* set timer list as NULL */ 
    g_timer_list = NULL;                  
 8026f58:	602a      	str	r2, [r5, #0]
 8026f5a:	e7a0      	b.n	8026e9e <SysTick_Handler+0x1aa>
 8026f5c:	1fff1a7c 	.word	0x1fff1a7c
 8026f60:	1fff1a84 	.word	0x1fff1a84
 8026f64:	2000da38 	.word	0x2000da38
 8026f68:	1fff1a80 	.word	0x1fff1a80

08026f6c <SYSTIMER_Init>:
  XMC_ASSERT("SYSTIMER_Init: SYSTIMER APP handle pointer uninitialized", (handle != NULL));

  /* Check APP initialization status to ensure whether SYSTIMER_Init called or not, initialize SYSTIMER if
   * SYSTIMER_Init called first time.
   */
  if (false == handle->init_status)
 8026f6c:	7803      	ldrb	r3, [r0, #0]
 8026f6e:	bb43      	cbnz	r3, 8026fc2 <SYSTIMER_Init+0x56>

/*
 * Initialization function which initializes the SYSTIMER APP, configures SysTick timer and SysTick exception.
 */
SYSTIMER_STATUS_t SYSTIMER_Init(SYSTIMER_t *handle)
{
 8026f70:	b470      	push	{r4, r5, r6}
   * SYSTIMER_Init called first time.
   */
  if (false == handle->init_status)
  {
    /* Initialize the header of the list */
    g_timer_list = NULL;
 8026f72:	4c15      	ldr	r4, [pc, #84]	; (8026fc8 <SYSTIMER_Init+0x5c>)
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8026f74:	4a15      	ldr	r2, [pc, #84]	; (8026fcc <SYSTIMER_Init+0x60>)
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8026f76:	4916      	ldr	r1, [pc, #88]	; (8026fd0 <SYSTIMER_Init+0x64>)
 8026f78:	6023      	str	r3, [r4, #0]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8026f7a:	4e16      	ldr	r6, [pc, #88]	; (8026fd4 <SYSTIMER_Init+0x68>)
 8026f7c:	6056      	str	r6, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8026f7e:	2407      	movs	r4, #7
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8026f80:	25fc      	movs	r5, #252	; 0xfc
 8026f82:	f881 5023 	strb.w	r5, [r1, #35]	; 0x23
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8026f86:	6093      	str	r3, [r2, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8026f88:	6014      	str	r4, [r2, #0]
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8026f8a:	68cb      	ldr	r3, [r1, #12]
 8026f8c:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8026f90:	1ae1      	subs	r1, r4, r3
 8026f92:	2906      	cmp	r1, #6
 8026f94:	bf28      	it	cs
 8026f96:	2106      	movcs	r1, #6
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8026f98:	b98b      	cbnz	r3, 8026fbe <SYSTIMER_Init+0x52>
 8026f9a:	461a      	mov	r2, r3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8026f9c:	2401      	movs	r4, #1
 8026f9e:	fa04 f301 	lsl.w	r3, r4, r1
 8026fa2:	3b01      	subs	r3, #1
 8026fa4:	4093      	lsls	r3, r2
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8026fa6:	4d0a      	ldr	r5, [pc, #40]	; (8026fd0 <SYSTIMER_Init+0x64>)
      NVIC_GetPriorityGrouping(), SYSTIMER_PRIORITY, SYSTIMER_SUBPRIORITY));
#elif (UC_FAMILY == XMC1)
      /* setting of priority value for XMC1000 devices */
      NVIC_SetPriority(SysTick_IRQn, SYSTIMER_PRIORITY);
#endif      
      g_timer_tracker = 0U;
 8026fa8:	4a0b      	ldr	r2, [pc, #44]	; (8026fd8 <SYSTIMER_Init+0x6c>)
 8026faa:	009b      	lsls	r3, r3, #2
 8026fac:	b2db      	uxtb	r3, r3
 8026fae:	f885 3023 	strb.w	r3, [r5, #35]	; 0x23
 8026fb2:	2100      	movs	r1, #0
 8026fb4:	6011      	str	r1, [r2, #0]
      /* Update the Initialization status of the SYSTIMER APP instance */
      handle->init_status = true;
 8026fb6:	7004      	strb	r4, [r0, #0]
      status = SYSTIMER_STATUS_SUCCESS;
    }
  }

  return (status);
}
 8026fb8:	2000      	movs	r0, #0
 8026fba:	bc70      	pop	{r4, r5, r6}
 8026fbc:	4770      	bx	lr
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8026fbe:	1e5a      	subs	r2, r3, #1
 8026fc0:	e7ec      	b.n	8026f9c <SYSTIMER_Init+0x30>
 8026fc2:	2000      	movs	r0, #0
 8026fc4:	4770      	bx	lr
 8026fc6:	bf00      	nop
 8026fc8:	1fff1a84 	.word	0x1fff1a84
 8026fcc:	e000e010 	.word	0xe000e010
 8026fd0:	e000ed00 	.word	0xe000ed00
 8026fd4:	000222df 	.word	0x000222df
 8026fd8:	1fff1a80 	.word	0x1fff1a80

08026fdc <SYSTIMER_GetTime>:
/*
 *  API to get the current SysTick time in microsecond.
 */
uint32_t SYSTIMER_GetTime(void)
{
  return (g_systick_count * SYSTIMER_TICK_PERIOD_US);
 8026fdc:	4b03      	ldr	r3, [pc, #12]	; (8026fec <SYSTIMER_GetTime+0x10>)
 8026fde:	681b      	ldr	r3, [r3, #0]
 8026fe0:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
}
 8026fe4:	fb00 f003 	mul.w	r0, r0, r3
 8026fe8:	4770      	bx	lr
 8026fea:	bf00      	nop
 8026fec:	1fff1a7c 	.word	0x1fff1a7c

08026ff0 <INTERRUPT_Init>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8026ff0:	4b20      	ldr	r3, [pc, #128]	; (8027074 <INTERRUPT_Init+0x84>)

/*
 * API to initialize the INTERRUPT APP
 */
INTERRUPT_STATUS_t INTERRUPT_Init(const INTERRUPT_t *const handler)
{
 8026ff2:	b4f0      	push	{r4, r5, r6, r7}
 8026ff4:	68db      	ldr	r3, [r3, #12]
  XMC_ASSERT("INTERRUPT_Init:HandlePtr NULL", (handler != NULL));
  
#if(UC_FAMILY == XMC4)

  NVIC_SetPriority(handler->node,
 8026ff6:	7804      	ldrb	r4, [r0, #0]
 8026ff8:	7841      	ldrb	r1, [r0, #1]
                   NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
                                       handler->priority,
                                       handler->subpriority));
 8026ffa:	7887      	ldrb	r7, [r0, #2]
 8026ffc:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8027000:	f1c3 0507 	rsb	r5, r3, #7
 8027004:	2d06      	cmp	r5, #6
 8027006:	bf28      	it	cs
 8027008:	2506      	movcs	r5, #6
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 802700a:	b34b      	cbz	r3, 8027060 <INTERRUPT_Init+0x70>
 802700c:	1e5e      	subs	r6, r3, #1
 802700e:	2201      	movs	r2, #1
 8027010:	40b2      	lsls	r2, r6
 8027012:	3a01      	subs	r2, #1
 8027014:	ea02 0307 	and.w	r3, r2, r7

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8027018:	2201      	movs	r2, #1
 802701a:	40aa      	lsls	r2, r5
 802701c:	3a01      	subs	r2, #1
 802701e:	400a      	ands	r2, r1
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8027020:	b261      	sxtb	r1, r4

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8027022:	40b2      	lsls	r2, r6
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8027024:	2900      	cmp	r1, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 8027026:	ea43 0302 	orr.w	r3, r3, r2
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 802702a:	db1b      	blt.n	8027064 <INTERRUPT_Init+0x74>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802702c:	f101 4260 	add.w	r2, r1, #3758096384	; 0xe0000000
 8027030:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 8027034:	009b      	lsls	r3, r3, #2
 8027036:	b2db      	uxtb	r3, r3
 8027038:	f882 3300 	strb.w	r3, [r2, #768]	; 0x300
  if (handler->enable_at_init == true)
 802703c:	78c3      	ldrb	r3, [r0, #3]
 802703e:	b163      	cbz	r3, 802705a <INTERRUPT_Init+0x6a>
 8027040:	7802      	ldrb	r2, [r0, #0]
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
 8027042:	b253      	sxtb	r3, r2
 8027044:	2b00      	cmp	r3, #0
 8027046:	db08      	blt.n	802705a <INTERRUPT_Init+0x6a>
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8027048:	f002 021f 	and.w	r2, r2, #31
 802704c:	095b      	lsrs	r3, r3, #5
 802704e:	2101      	movs	r1, #1
 8027050:	4809      	ldr	r0, [pc, #36]	; (8027078 <INTERRUPT_Init+0x88>)
 8027052:	fa01 f202 	lsl.w	r2, r1, r2
 8027056:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
    INTERRUPT_Enable(handler);
  }
#endif

  return (INTERRUPT_STATUS_SUCCESS);
}
 802705a:	2000      	movs	r0, #0
 802705c:	bcf0      	pop	{r4, r5, r6, r7}
 802705e:	4770      	bx	lr
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8027060:	461e      	mov	r6, r3
 8027062:	e7d9      	b.n	8027018 <INTERRUPT_Init+0x28>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8027064:	4a05      	ldr	r2, [pc, #20]	; (802707c <INTERRUPT_Init+0x8c>)
 8027066:	f004 040f 	and.w	r4, r4, #15
 802706a:	009b      	lsls	r3, r3, #2
 802706c:	4422      	add	r2, r4
 802706e:	b2db      	uxtb	r3, r3
 8027070:	7613      	strb	r3, [r2, #24]
 8027072:	e7e3      	b.n	802703c <INTERRUPT_Init+0x4c>
 8027074:	e000ed00 	.word	0xe000ed00
 8027078:	e000e100 	.word	0xe000e100
 802707c:	e000ecfc 	.word	0xe000ecfc

08027080 <GLOBAL_DMA_Init>:
  return version;
}

/* GLOBAL_DMA initialization function */
GLOBAL_DMA_STATUS_t GLOBAL_DMA_Init(GLOBAL_DMA_t *const obj)
{
 8027080:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  XMC_ASSERT("DMA_GLOBAL_Init: NULL DMA_GLOBAL_t object", (obj != NULL));

  if (obj->initialized == false)
 8027082:	7a03      	ldrb	r3, [r0, #8]
 8027084:	b10b      	cbz	r3, 802708a <GLOBAL_DMA_Init+0xa>
    NVIC_EnableIRQ(obj->irq_node);
    obj->initialized = true;
  }

  return GLOBAL_DMA_STATUS_SUCCESS;
}
 8027086:	2000      	movs	r0, #0
 8027088:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802708a:	4604      	mov	r4, r0
  XMC_ASSERT("DMA_GLOBAL_Init: NULL DMA_GLOBAL_t object", (obj != NULL));

  if (obj->initialized == false)
  {
    /* Enable DMA module */
    XMC_DMA_Init(obj->dma);
 802708c:	6800      	ldr	r0, [r0, #0]
 802708e:	f7fa ff2b 	bl	8021ee8 <XMC_DMA_Init>
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8027092:	4a20      	ldr	r2, [pc, #128]	; (8027114 <GLOBAL_DMA_Init+0x94>)

    /* Enable DMA event handling */
    NVIC_SetPriority(obj->irq_node, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
                                                        obj->config->priority,
 8027094:	6863      	ldr	r3, [r4, #4]
 8027096:	68d2      	ldr	r2, [r2, #12]
  {
    /* Enable DMA module */
    XMC_DMA_Init(obj->dma);

    /* Enable DMA event handling */
    NVIC_SetPriority(obj->irq_node, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
 8027098:	7819      	ldrb	r1, [r3, #0]
                                                        obj->config->priority,
                                                        obj->config->sub_priority));
 802709a:	785f      	ldrb	r7, [r3, #1]
  {
    /* Enable DMA module */
    XMC_DMA_Init(obj->dma);

    /* Enable DMA event handling */
    NVIC_SetPriority(obj->irq_node, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
 802709c:	7a60      	ldrb	r0, [r4, #9]
 802709e:	f3c2 2302 	ubfx	r3, r2, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80270a2:	f1c3 0507 	rsb	r5, r3, #7
 80270a6:	2d06      	cmp	r5, #6
 80270a8:	bf28      	it	cs
 80270aa:	2506      	movcs	r5, #6
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80270ac:	bb1b      	cbnz	r3, 80270f6 <GLOBAL_DMA_Init+0x76>
 80270ae:	461e      	mov	r6, r3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80270b0:	2201      	movs	r2, #1
 80270b2:	40aa      	lsls	r2, r5
 80270b4:	3a01      	subs	r2, #1
 80270b6:	400a      	ands	r2, r1
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 80270b8:	b241      	sxtb	r1, r0

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80270ba:	40b2      	lsls	r2, r6
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 80270bc:	2900      	cmp	r1, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 80270be:	ea43 0302 	orr.w	r3, r3, r2
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 80270c2:	db1f      	blt.n	8027104 <GLOBAL_DMA_Init+0x84>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80270c4:	f101 4260 	add.w	r2, r1, #3758096384	; 0xe0000000
 80270c8:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 80270cc:	009b      	lsls	r3, r3, #2
 80270ce:	b2db      	uxtb	r3, r3
 80270d0:	f882 3300 	strb.w	r3, [r2, #768]	; 0x300
                                                        obj->config->priority,
                                                        obj->config->sub_priority));
    NVIC_EnableIRQ(obj->irq_node);
 80270d4:	7a62      	ldrb	r2, [r4, #9]
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
 80270d6:	b253      	sxtb	r3, r2
 80270d8:	2b00      	cmp	r3, #0
 80270da:	db08      	blt.n	80270ee <GLOBAL_DMA_Init+0x6e>
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80270dc:	f002 021f 	and.w	r2, r2, #31
 80270e0:	095b      	lsrs	r3, r3, #5
 80270e2:	2101      	movs	r1, #1
 80270e4:	480c      	ldr	r0, [pc, #48]	; (8027118 <GLOBAL_DMA_Init+0x98>)
 80270e6:	fa01 f202 	lsl.w	r2, r1, r2
 80270ea:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
    obj->initialized = true;
 80270ee:	2301      	movs	r3, #1
 80270f0:	7223      	strb	r3, [r4, #8]
  }

  return GLOBAL_DMA_STATUS_SUCCESS;
}
 80270f2:	2000      	movs	r0, #0
 80270f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80270f6:	1e5e      	subs	r6, r3, #1
 80270f8:	2201      	movs	r2, #1
 80270fa:	40b2      	lsls	r2, r6
 80270fc:	3a01      	subs	r2, #1
 80270fe:	ea02 0307 	and.w	r3, r2, r7
 8027102:	e7d5      	b.n	80270b0 <GLOBAL_DMA_Init+0x30>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8027104:	4a05      	ldr	r2, [pc, #20]	; (802711c <GLOBAL_DMA_Init+0x9c>)
 8027106:	f000 000f 	and.w	r0, r0, #15
 802710a:	009b      	lsls	r3, r3, #2
 802710c:	4402      	add	r2, r0
 802710e:	b2db      	uxtb	r3, r3
 8027110:	7613      	strb	r3, [r2, #24]
 8027112:	e7df      	b.n	80270d4 <GLOBAL_DMA_Init+0x54>
 8027114:	e000ed00 	.word	0xe000ed00
 8027118:	e000e100 	.word	0xe000e100
 802711c:	e000ecfc 	.word	0xe000ecfc

08027120 <GPDMA0_0_IRQHandler>:
  .irq_node = (IRQn_Type)110U /* Allotted DMA IRQ node */
};

void GPDMA0_0_IRQHandler(void)
{
  XMC_DMA_IRQHandler(XMC_DMA0);
 8027120:	4801      	ldr	r0, [pc, #4]	; (8027128 <GPDMA0_0_IRQHandler+0x8>)
 8027122:	f7fb b89b 	b.w	802225c <XMC_DMA_IRQHandler>
 8027126:	bf00      	nop
 8027128:	50014000 	.word	0x50014000

0802712c <GPDMA1_0_IRQHandler>:
}

#ifdef XMC_DMA1
void GPDMA1_0_IRQHandler(void)
{
  XMC_DMA_IRQHandler(XMC_DMA1);
 802712c:	4801      	ldr	r0, [pc, #4]	; (8027134 <GPDMA1_0_IRQHandler+0x8>)
 802712e:	f7fb b895 	b.w	802225c <XMC_DMA_IRQHandler>
 8027132:	bf00      	nop
 8027134:	50018000 	.word	0x50018000

08027138 <GLOBAL_CCU8_Init>:
/* Initializes the slice with the generated configuration */
GLOBAL_CCU8_STATUS_t GLOBAL_CCU8_Init(GLOBAL_CCU8_t* handle)
{
  XMC_ASSERT("GLOBAL_CCU8_Init:NULL handler", (NULL != handle));

  if (false == handle->is_initialized)
 8027138:	7b43      	ldrb	r3, [r0, #13]
 802713a:	b10b      	cbz	r3, 8027140 <GLOBAL_CCU8_Init+0x8>
    /* Restricts multiple initializations */
    handle->is_initialized = true;
  }

  return (GLOBAL_CCU8_STATUS_SUCCESS);
}
 802713c:	2000      	movs	r0, #0
 802713e:	4770      	bx	lr
  return version;
}

/* Initializes the slice with the generated configuration */
GLOBAL_CCU8_STATUS_t GLOBAL_CCU8_Init(GLOBAL_CCU8_t* handle)
{
 8027140:	b510      	push	{r4, lr}
 8027142:	4604      	mov	r4, r0
  XMC_ASSERT("GLOBAL_CCU8_Init:NULL handler", (NULL != handle));

  if (false == handle->is_initialized)
  {
    /* Enable CCU8 module */
    XMC_CCU8_Init(handle->module_ptr,handle->mcs_action);
 8027144:	6880      	ldr	r0, [r0, #8]
 8027146:	7b21      	ldrb	r1, [r4, #12]
 8027148:	f7fa fe58 	bl	8021dfc <XMC_CCU8_Init>
    /* Start the prescaler */
    XMC_CCU8_StartPrescaler(handle->module_ptr);
 802714c:	68a2      	ldr	r2, [r4, #8]
 *  XMC_CCU8_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU8_StartPrescaler(XMC_CCU8_MODULE_t *const module)
{
  XMC_ASSERT("XMC_CCU8_StartPrescaler:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));
  module->GIDLC |= (uint32_t) CCU8_GIDLC_SPRB_Msk;
 802714e:	68d3      	ldr	r3, [r2, #12]
    /* Restricts multiple initializations */
    handle->is_initialized = true;
 8027150:	2101      	movs	r1, #1
 8027152:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8027156:	60d3      	str	r3, [r2, #12]
  }

  return (GLOBAL_CCU8_STATUS_SUCCESS);
}
 8027158:	2000      	movs	r0, #0
    /* Enable CCU8 module */
    XMC_CCU8_Init(handle->module_ptr,handle->mcs_action);
    /* Start the prescaler */
    XMC_CCU8_StartPrescaler(handle->module_ptr);
    /* Restricts multiple initializations */
    handle->is_initialized = true;
 802715a:	7361      	strb	r1, [r4, #13]
  }

  return (GLOBAL_CCU8_STATUS_SUCCESS);
}
 802715c:	bd10      	pop	{r4, pc}
 802715e:	bf00      	nop

08027160 <GLOBAL_CCU4_Init>:
/* Initializes the slice with the generated configuration */
GLOBAL_CCU4_STATUS_t GLOBAL_CCU4_Init(GLOBAL_CCU4_t* handle)
{
  XMC_ASSERT("GLOBAL_CCU4_Init:NULL handler", (NULL != handle));

  if (false == handle->is_initialized)
 8027160:	7b43      	ldrb	r3, [r0, #13]
 8027162:	b10b      	cbz	r3, 8027168 <GLOBAL_CCU4_Init+0x8>
    /* Restricts multiple initializations */
    handle->is_initialized = true;
  }

  return (GLOBAL_CCU4_STATUS_SUCCESS);
}
 8027164:	2000      	movs	r0, #0
 8027166:	4770      	bx	lr
  return version;
}

/* Initializes the slice with the generated configuration */
GLOBAL_CCU4_STATUS_t GLOBAL_CCU4_Init(GLOBAL_CCU4_t* handle)
{
 8027168:	b510      	push	{r4, lr}
 802716a:	4604      	mov	r4, r0
  XMC_ASSERT("GLOBAL_CCU4_Init:NULL handler", (NULL != handle));

  if (false == handle->is_initialized)
  {
    /* Enable CCU4 module */
    XMC_CCU4_Init(handle->module_ptr,handle->mcs_action);
 802716c:	6880      	ldr	r0, [r0, #8]
 802716e:	7b21      	ldrb	r1, [r4, #12]
 8027170:	f7fa fd62 	bl	8021c38 <XMC_CCU4_Init>
    /* Start the prescaler */
    XMC_CCU4_StartPrescaler(handle->module_ptr);
 8027174:	68a2      	ldr	r2, [r4, #8]
 * XMC_CCU4_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU4_StartPrescaler(XMC_CCU4_MODULE_t *const module)
{
  XMC_ASSERT("XMC_CCU4_StartPrescaler:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  module->GIDLC |= (uint32_t) CCU4_GIDLC_SPRB_Msk;
 8027176:	68d3      	ldr	r3, [r2, #12]
    /* Restricts multiple initializations */
    handle->is_initialized = true;
 8027178:	2101      	movs	r1, #1
 802717a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 802717e:	60d3      	str	r3, [r2, #12]
  }

  return (GLOBAL_CCU4_STATUS_SUCCESS);
}
 8027180:	2000      	movs	r0, #0
    /* Enable CCU4 module */
    XMC_CCU4_Init(handle->module_ptr,handle->mcs_action);
    /* Start the prescaler */
    XMC_CCU4_StartPrescaler(handle->module_ptr);
    /* Restricts multiple initializations */
    handle->is_initialized = true;
 8027182:	7361      	strb	r1, [r4, #13]
  }

  return (GLOBAL_CCU4_STATUS_SUCCESS);
}
 8027184:	bd10      	pop	{r4, pc}
 8027186:	bf00      	nop

08027188 <GLOBAL_ADC_Init>:
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/**
 * This function initializes all instances of the ADC Global APP and low level app.
 */
GLOBAL_ADC_STATUS_t GLOBAL_ADC_Init(GLOBAL_ADC_t *const handle_ptr)
{
 8027188:	4603      	mov	r3, r0
  XMC_ASSERT("GLOBAL_ADC_Init:Invalid handle_ptr", (handle_ptr != NULL))
#if (XMC_VADC_GROUP_AVAILABLE == 1U)
  uint32_t group_index;
#endif

  if (GLOBAL_ADC_UNINITIALIZED == handle_ptr->init_state)
 802718a:	7e00      	ldrb	r0, [r0, #24]
 802718c:	2802      	cmp	r0, #2
 802718e:	d000      	beq.n	8027192 <GLOBAL_ADC_Init+0xa>
    	XMC_VADC_GLOBAL_StartupCalibration(handle_ptr->module_ptr);
    }
    handle_ptr->init_state = GLOBAL_ADC_SUCCESS;
  }
  return (handle_ptr->init_state);
}
 8027190:	4770      	bx	lr
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/**
 * This function initializes all instances of the ADC Global APP and low level app.
 */
GLOBAL_ADC_STATUS_t GLOBAL_ADC_Init(GLOBAL_ADC_t *const handle_ptr)
{
 8027192:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
#endif

  if (GLOBAL_ADC_UNINITIALIZED == handle_ptr->init_state)
  {  
    /* Initialize an instance of Global hardware */
    XMC_VADC_GLOBAL_Init(handle_ptr->module_ptr, handle_ptr->global_config_handle);
 8027196:	6958      	ldr	r0, [r3, #20]
 8027198:	6919      	ldr	r1, [r3, #16]
 802719a:	461e      	mov	r6, r3
 802719c:	f7fc faf6 	bl	802378c <XMC_VADC_GLOBAL_Init>
 80271a0:	4634      	mov	r4, r6
 80271a2:	2510      	movs	r5, #16

__STATIC_INLINE void XMC_VADC_GLOBAL_DisablePostCalibration(XMC_VADC_GLOBAL_t *const global_ptr, uint32_t group_number)
{
  XMC_ASSERT("XMC_VADC_GLOBAL_DisablePostCalibration:Wrong Module Pointer", (global_ptr == VADC))

  global_ptr->GLOBCFG |= (uint32_t)((uint32_t)1 << ((uint32_t)VADC_GLOBCFG_DPCAL0_Pos + group_number));
 80271a4:	f04f 0801 	mov.w	r8, #1

#if(XMC_VADC_SHS_AVAILABLE == 1U)
      XMC_VADC_GLOBAL_SHS_EnableAcceleratedMode(handle_ptr->global_shs_ptr, (XMC_VADC_GROUP_INDEX_t)group_index);
#endif

      handle_ptr->group_ptrs_array[group_index]->state = GLOBAL_ADC_SUCCESS;
 80271a8:	2700      	movs	r7, #0
    /* Initialize all the Groups */
#if (XMC_VADC_GROUP_AVAILABLE == 1U)
    for(group_index = (uint32_t)0; group_index < XMC_VADC_MAXIMUM_NUM_GROUPS; group_index++)
    {
      /*Initialize Group*/
      XMC_VADC_GROUP_Init(handle_ptr->group_ptrs_array[group_index]->group_handle,
 80271aa:	6823      	ldr	r3, [r4, #0]
 80271ac:	e893 0003 	ldmia.w	r3, {r0, r1}
 80271b0:	f7fc fb38 	bl	8023824 <XMC_VADC_GROUP_Init>
    		            handle_ptr->group_ptrs_array[group_index]->group_config_handle);

      /* Switch on the converter of the Group[group_index]*/
      XMC_VADC_GROUP_SetPowerMode(handle_ptr->group_ptrs_array[group_index]->group_handle,
 80271b4:	6823      	ldr	r3, [r4, #0]
 80271b6:	2103      	movs	r1, #3
 80271b8:	6818      	ldr	r0, [r3, #0]
 80271ba:	f7fc fbd1 	bl	8023960 <XMC_VADC_GROUP_SetPowerMode>
                                  XMC_VADC_GROUP_POWERMODE_NORMAL);

      /* Disable the post calibration option for the respective group*/
      if ((bool)false == handle_ptr->group_ptrs_array[group_index]->post_calibration)
 80271be:	f854 3b04 	ldr.w	r3, [r4], #4
 80271c2:	7a1a      	ldrb	r2, [r3, #8]
 80271c4:	b93a      	cbnz	r2, 80271d6 <GLOBAL_ADC_Init+0x4e>
      {
        XMC_VADC_GLOBAL_DisablePostCalibration(handle_ptr->module_ptr,group_index);
 80271c6:	6971      	ldr	r1, [r6, #20]
 80271c8:	f8d1 2080 	ldr.w	r2, [r1, #128]	; 0x80
 80271cc:	fa08 f005 	lsl.w	r0, r8, r5
 80271d0:	4302      	orrs	r2, r0
 80271d2:	f8c1 2080 	str.w	r2, [r1, #128]	; 0x80
 80271d6:	3501      	adds	r5, #1
    /* Initialize an instance of Global hardware */
    XMC_VADC_GLOBAL_Init(handle_ptr->module_ptr, handle_ptr->global_config_handle);

    /* Initialize all the Groups */
#if (XMC_VADC_GROUP_AVAILABLE == 1U)
    for(group_index = (uint32_t)0; group_index < XMC_VADC_MAXIMUM_NUM_GROUPS; group_index++)
 80271d8:	2d14      	cmp	r5, #20

#if(XMC_VADC_SHS_AVAILABLE == 1U)
      XMC_VADC_GLOBAL_SHS_EnableAcceleratedMode(handle_ptr->global_shs_ptr, (XMC_VADC_GROUP_INDEX_t)group_index);
#endif

      handle_ptr->group_ptrs_array[group_index]->state = GLOBAL_ADC_SUCCESS;
 80271da:	725f      	strb	r7, [r3, #9]
    /* Initialize an instance of Global hardware */
    XMC_VADC_GLOBAL_Init(handle_ptr->module_ptr, handle_ptr->global_config_handle);

    /* Initialize all the Groups */
#if (XMC_VADC_GROUP_AVAILABLE == 1U)
    for(group_index = (uint32_t)0; group_index < XMC_VADC_MAXIMUM_NUM_GROUPS; group_index++)
 80271dc:	d1e5      	bne.n	80271aa <GLOBAL_ADC_Init+0x22>
#endif
#endif /* _XMC_VADC_GROUP_AVAILABLE_ */
#if(XMC_VADC_SHS_AVAILABLE == 1U)
    XMC_VADC_GLOBAL_SHS_SetAnalogReference(handle_ptr->global_shs_ptr, GLOBAL_ADC_AREF_VALUE);
#endif
    if((bool)true == handle_ptr->enable_startup_calibration)
 80271de:	7e73      	ldrb	r3, [r6, #25]
 80271e0:	b91b      	cbnz	r3, 80271ea <GLOBAL_ADC_Init+0x62>
    {
    	XMC_VADC_GLOBAL_StartupCalibration(handle_ptr->module_ptr);
    }
    handle_ptr->init_state = GLOBAL_ADC_SUCCESS;
 80271e2:	2000      	movs	r0, #0
 80271e4:	7630      	strb	r0, [r6, #24]
  }
  return (handle_ptr->init_state);
}
 80271e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
#if(XMC_VADC_SHS_AVAILABLE == 1U)
    XMC_VADC_GLOBAL_SHS_SetAnalogReference(handle_ptr->global_shs_ptr, GLOBAL_ADC_AREF_VALUE);
#endif
    if((bool)true == handle_ptr->enable_startup_calibration)
    {
    	XMC_VADC_GLOBAL_StartupCalibration(handle_ptr->module_ptr);
 80271ea:	6970      	ldr	r0, [r6, #20]
 80271ec:	f7fc fafc 	bl	80237e8 <XMC_VADC_GLOBAL_StartupCalibration>
 80271f0:	e7f7      	b.n	80271e2 <GLOBAL_ADC_Init+0x5a>
 80271f2:	bf00      	nop

080271f4 <E_EEPROM_XMC4_Init>:

  return (version);
}

E_EEPROM_XMC4_STATUS_t E_EEPROM_XMC4_Init(E_EEPROM_XMC4_t *const handle)
{
 80271f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  XMC_ASSERT("E_EEPROM_XMC4_Init:Invalid handle Pointer", (handle != NULL))

  status = E_EEPROM_XMC4_STATUS_OK;
  
  if (handle->initialized == (bool)false)
 80271f8:	7804      	ldrb	r4, [r0, #0]

  return (version);
}

E_EEPROM_XMC4_STATUS_t E_EEPROM_XMC4_Init(E_EEPROM_XMC4_t *const handle)
{
 80271fa:	b085      	sub	sp, #20

  XMC_ASSERT("E_EEPROM_XMC4_Init:Invalid handle Pointer", (handle != NULL))

  status = E_EEPROM_XMC4_STATUS_OK;
  
  if (handle->initialized == (bool)false)
 80271fc:	b11c      	cbz	r4, 8027206 <E_EEPROM_XMC4_Init+0x12>
  uint32_t sector_count;
  E_EEPROM_XMC4_STATUS_t status ;

  XMC_ASSERT("E_EEPROM_XMC4_Init:Invalid handle Pointer", (handle != NULL))

  status = E_EEPROM_XMC4_STATUS_OK;
 80271fe:	2000      	movs	r0, #0

    handle->initialized = (bool)true;
  }

  return (status);
}
 8027200:	b005      	add	sp, #20
 8027202:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

  status = E_EEPROM_XMC4_STATUS_OK;
  
  if (handle->initialized == (bool)false)
  {
    e_eeprom_xmc4_data_buffer.block_cycle_count = 0U;
 8027206:	4b7a      	ldr	r3, [pc, #488]	; (80273f0 <E_EEPROM_XMC4_Init+0x1fc>)
    e_eeprom_xmc4_sector_info.flash_data_addr = E_EEPROM_XMC4_EMPTY;
 8027208:	f8df 81f4 	ldr.w	r8, [pc, #500]	; 8027400 <E_EEPROM_XMC4_Init+0x20c>
 * \par<b>Related APIs:</b><BR>
 * None
 */
__STATIC_INLINE void XMC_FLASH_SetMargin(const XMC_FLASH_MARGIN_t margin)
{
  FLASH0->MARP = (FLASH0->MARP & (uint32_t)~FLASH_MARP_MARGIN_Msk) | margin;
 802720c:	4979      	ldr	r1, [pc, #484]	; (80273f4 <E_EEPROM_XMC4_Init+0x200>)

  status = E_EEPROM_XMC4_STATUS_OK;
  
  if (handle->initialized == (bool)false)
  {
    e_eeprom_xmc4_data_buffer.block_cycle_count = 0U;
 802720e:	605c      	str	r4, [r3, #4]
 8027210:	f241 0218 	movw	r2, #4120	; 0x1018
    e_eeprom_xmc4_sector_info.flash_data_addr = E_EEPROM_XMC4_EMPTY;
 8027214:	f8c8 4004 	str.w	r4, [r8, #4]
 8027218:	588b      	ldr	r3, [r1, r2]
 802721a:	9001      	str	r0, [sp, #4]
 802721c:	f023 030f 	bic.w	r3, r3, #15
 8027220:	f043 0301 	orr.w	r3, r3, #1
 8027224:	508b      	str	r3, [r1, r2]
 * \par<b>Related APIs:</b><BR>
 * None
 */
__STATIC_INLINE void XMC_FLASH_DisableDoubleBitErrorTrap(void)
{
  FLASH0->MARP |= FLASH_MARP_TRAPDIS_Msk;
 8027226:	588b      	ldr	r3, [r1, r2]
    XMC_FLASH_DisableDoubleBitErrorTrap();
  
    XMC_FCE_Enable();

    /* Initialize FCE module for Hardware calculations */
    (void)XMC_FCE_Init(&e_eeprom_xmc4_fce);
 8027228:	4f73      	ldr	r7, [pc, #460]	; (80273f8 <E_EEPROM_XMC4_Init+0x204>)
 * \par
 * The function sets the initial CRC (seed) value in the CRC register.
 */
__STATIC_INLINE void XMC_FCE_InitializeSeedValue(const XMC_FCE_t *const engine, uint32_t seedvalue)
{
  engine->kernel_ptr->CRC = seedvalue;
 802722a:	f8df b1ec 	ldr.w	fp, [pc, #492]	; 8027418 <E_EEPROM_XMC4_Init+0x224>
 802722e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8027232:	508b      	str	r3, [r1, r2]
    e_eeprom_xmc4_sector_info.flash_data_addr = E_EEPROM_XMC4_EMPTY;
  
    XMC_FLASH_SetMargin(XMC_FLASH_MARGIN_TIGHT0);
    XMC_FLASH_DisableDoubleBitErrorTrap();
  
    XMC_FCE_Enable();
 8027234:	f7fb f8f8 	bl	8022428 <XMC_FCE_Enable>

    /* Initialize FCE module for Hardware calculations */
    (void)XMC_FCE_Init(&e_eeprom_xmc4_fce);
 8027238:	4870      	ldr	r0, [pc, #448]	; (80273fc <E_EEPROM_XMC4_Init+0x208>)
 802723a:	f7fb f8ed 	bl	8022418 <XMC_FCE_Init>
  
    /* Iterate all 4 sectors to find out which is the active sector having the latest data block*/
    for (sector_count = 0U; sector_count < E_EEPROM_XMC4_MAX_SECTORS ; sector_count++)
 802723e:	9400      	str	r4, [sp, #0]
 8027240:	4623      	mov	r3, r4
  uint32_t calculated_crc;

  /* Initialize starting address and last block address of the sector. */
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR + (E_EEPROM_XMC4_SECTOR_SIZE * (uint32_t)sector);
  block_read_addr = (sector_start_addr + E_EEPROM_XMC4_SECTOR_SIZE) - E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;
  free_block_addr = E_EEPROM_XMC4_EMPTY;
 8027242:	f04f 0900 	mov.w	r9, #0

    /* Check if block cycle count is a non zero value*/
    if (block_cycle_count != E_EEPROM_XMC4_EMPTY)
    {
      /* Mark sector as non-empty sector*/
      e_eeprom_xmc4_sector_info.erase_state |= ((uint32_t)1U << sector);
 8027246:	f04f 0a01 	mov.w	sl, #1
 802724a:	fa0a fa03 	lsl.w	sl, sl, r3
  uint32_t calculated_crc;

  /* Initialize starting address and last block address of the sector. */
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR + (E_EEPROM_XMC4_SECTOR_SIZE * (uint32_t)sector);
  block_read_addr = (sector_start_addr + E_EEPROM_XMC4_SECTOR_SIZE) - E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;
  free_block_addr = E_EEPROM_XMC4_EMPTY;
 802724e:	464b      	mov	r3, r9
  uint32_t written_crc;
  uint32_t calculated_crc;

  /* Initialize starting address and last block address of the sector. */
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR + (E_EEPROM_XMC4_SECTOR_SIZE * (uint32_t)sector);
  block_read_addr = (sector_start_addr + E_EEPROM_XMC4_SECTOR_SIZE) - E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;
 8027250:	f507 5440 	add.w	r4, r7, #12288	; 0x3000
  free_block_addr = E_EEPROM_XMC4_EMPTY;
 8027254:	46b9      	mov	r9, r7
 8027256:	461f      	mov	r7, r3
 8027258:	e003      	b.n	8027262 <E_EEPROM_XMC4_Init+0x6e>
          break;
        }
      }
    }
    /* Move the block read address to one block size up starting from the bottom of sector */
    block_read_addr -= E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;
 802725a:	f5a4 5480 	sub.w	r4, r4, #4096	; 0x1000

  /* Iterate the read process until the block read address crosses sector start address or a
   * latest valid block is identified.
   */
  } while ( block_read_addr >= sector_start_addr );
 802725e:	454c      	cmp	r4, r9
 8027260:	d32c      	bcc.n	80272bc <E_EEPROM_XMC4_Init+0xc8>

  do
  {
    /* Read first 32 bit data from the block which indicates the block cycle counter. */
    data_ptr = (uint32_t*)block_read_addr;
    block_cycle_count = *(data_ptr + E_EEPROM_XMC4_BCC_OFFSET);
 8027262:	6865      	ldr	r5, [r4, #4]
  uint32_t result;

  /* Reset the CRC result register before new CRC calculation */
  XMC_FCE_InitializeSeedValue(&e_eeprom_xmc4_fce, 0U);

  (void)XMC_FCE_CalculateCRC32(&e_eeprom_xmc4_fce, data_start_addr, E_EEPROM_XMC4_DATA_SIZE_FOR_CRC, &result);
 8027264:	4865      	ldr	r0, [pc, #404]	; (80273fc <E_EEPROM_XMC4_Init+0x208>)
      {
        free_block_addr = block_read_addr + E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;
      }

      /* Read the second 32bit data which indicates the CRC */
      written_crc = *data_ptr;
 8027266:	4621      	mov	r1, r4
 8027268:	f04f 0e00 	mov.w	lr, #0
  uint32_t result;

  /* Reset the CRC result register before new CRC calculation */
  XMC_FCE_InitializeSeedValue(&e_eeprom_xmc4_fce, 0U);

  (void)XMC_FCE_CalculateCRC32(&e_eeprom_xmc4_fce, data_start_addr, E_EEPROM_XMC4_DATA_SIZE_FOR_CRC, &result);
 802726c:	f640 72fc 	movw	r2, #4092	; 0xffc
 8027270:	ab03      	add	r3, sp, #12
    /* Read first 32 bit data from the block which indicates the block cycle counter. */
    data_ptr = (uint32_t*)block_read_addr;
    block_cycle_count = *(data_ptr + E_EEPROM_XMC4_BCC_OFFSET);

    /* Check if block cycle count is a non zero value*/
    if (block_cycle_count != E_EEPROM_XMC4_EMPTY)
 8027272:	2d00      	cmp	r5, #0
 8027274:	d0f1      	beq.n	802725a <E_EEPROM_XMC4_Init+0x66>
    {
      /* Mark sector as non-empty sector*/
      e_eeprom_xmc4_sector_info.erase_state |= ((uint32_t)1U << sector);
 8027276:	f8d8 600c 	ldr.w	r6, [r8, #12]
 802727a:	ea4a 0606 	orr.w	r6, sl, r6
 802727e:	f8c8 600c 	str.w	r6, [r8, #12]

      /* If this is the first non empty block identified, then store the address as next free address */
      if (free_block_addr == E_EEPROM_XMC4_EMPTY)
 8027282:	b90f      	cbnz	r7, 8027288 <E_EEPROM_XMC4_Init+0x94>
      {
        free_block_addr = block_read_addr + E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;
 8027284:	f504 5780 	add.w	r7, r4, #4096	; 0x1000
      }

      /* Read the second 32bit data which indicates the CRC */
      written_crc = *data_ptr;
 8027288:	f851 6b04 	ldr.w	r6, [r1], #4
 802728c:	f8cb e018 	str.w	lr, [fp, #24]
  uint32_t result;

  /* Reset the CRC result register before new CRC calculation */
  XMC_FCE_InitializeSeedValue(&e_eeprom_xmc4_fce, 0U);

  (void)XMC_FCE_CalculateCRC32(&e_eeprom_xmc4_fce, data_start_addr, E_EEPROM_XMC4_DATA_SIZE_FOR_CRC, &result);
 8027290:	f7fb f8dc 	bl	802244c <XMC_FCE_CalculateCRC32>

  return (result);
 8027294:	9b03      	ldr	r3, [sp, #12]
      /* Read the second 32bit data which indicates the CRC */
      written_crc = *data_ptr;
      /* Calculate the CRC for the written data in flash (3rd word to the last word)*/
      calculated_crc = E_EEPROM_XMC4_lCalculateCRC(data_ptr + E_EEPROM_XMC4_BCC_OFFSET);

      if (calculated_crc == written_crc)
 8027296:	429e      	cmp	r6, r3
 8027298:	d1df      	bne.n	802725a <E_EEPROM_XMC4_Init+0x66>
      {
        /* If both CRC matches and the current block cycle counter is greater than the previous recorded value,
         * Update the Data structure with the current block as the "latest" one and the current sector as "active".
         * Exit from the function.
         */
        if (block_cycle_count > e_eeprom_xmc4_data_buffer.block_cycle_count)
 802729a:	4b55      	ldr	r3, [pc, #340]	; (80273f0 <E_EEPROM_XMC4_Init+0x1fc>)
 802729c:	685b      	ldr	r3, [r3, #4]
 802729e:	429d      	cmp	r5, r3
 80272a0:	d9db      	bls.n	802725a <E_EEPROM_XMC4_Init+0x66>
 80272a2:	463b      	mov	r3, r7
 80272a4:	464f      	mov	r7, r9
 80272a6:	4699      	mov	r9, r3
        {
          e_eeprom_xmc4_data_buffer.block_cycle_count = block_cycle_count;
 80272a8:	4b51      	ldr	r3, [pc, #324]	; (80273f0 <E_EEPROM_XMC4_Init+0x1fc>)
          e_eeprom_xmc4_sector_info.current_sector = sector;
          e_eeprom_xmc4_sector_info.flash_data_addr = block_read_addr;
 80272aa:	f8c8 4004 	str.w	r4, [r8, #4]
         * Update the Data structure with the current block as the "latest" one and the current sector as "active".
         * Exit from the function.
         */
        if (block_cycle_count > e_eeprom_xmc4_data_buffer.block_cycle_count)
        {
          e_eeprom_xmc4_data_buffer.block_cycle_count = block_cycle_count;
 80272ae:	605d      	str	r5, [r3, #4]
          e_eeprom_xmc4_sector_info.current_sector = sector;
 80272b0:	9b00      	ldr	r3, [sp, #0]
 80272b2:	f8c8 3008 	str.w	r3, [r8, #8]
          e_eeprom_xmc4_sector_info.flash_data_addr = block_read_addr;
          e_eeprom_xmc4_sector_info.next_free_start_addr = free_block_addr;
 80272b6:	f8c8 9000 	str.w	r9, [r8]
 80272ba:	e001      	b.n	80272c0 <E_EEPROM_XMC4_Init+0xcc>
 80272bc:	9b00      	ldr	r3, [sp, #0]
 80272be:	464f      	mov	r7, r9

    /* Initialize FCE module for Hardware calculations */
    (void)XMC_FCE_Init(&e_eeprom_xmc4_fce);
  
    /* Iterate all 4 sectors to find out which is the active sector having the latest data block*/
    for (sector_count = 0U; sector_count < E_EEPROM_XMC4_MAX_SECTORS ; sector_count++)
 80272c0:	3301      	adds	r3, #1
 80272c2:	2b04      	cmp	r3, #4
 80272c4:	9300      	str	r3, [sp, #0]
 80272c6:	f507 4780 	add.w	r7, r7, #16384	; 0x4000
 80272ca:	d1ba      	bne.n	8027242 <E_EEPROM_XMC4_Init+0x4e>
 * \par<b>Related APIs:</b><BR>
 * None
 */
__STATIC_INLINE void XMC_FLASH_SetMargin(const XMC_FLASH_MARGIN_t margin)
{
  FLASH0->MARP = (FLASH0->MARP & (uint32_t)~FLASH_MARP_MARGIN_Msk) | margin;
 80272cc:	4949      	ldr	r1, [pc, #292]	; (80273f4 <E_EEPROM_XMC4_Init+0x200>)
  sector_count = 0U;

  do
  {
    /* If the non empty sector is the current active sector, then do not erase it*/
    if (e_eeprom_xmc4_sector_info.current_sector != sector_count)
 80272ce:	f8d8 0008 	ldr.w	r0, [r8, #8]
 80272d2:	4c4b      	ldr	r4, [pc, #300]	; (8027400 <E_EEPROM_XMC4_Init+0x20c>)
 80272d4:	f241 0218 	movw	r2, #4120	; 0x1018
 80272d8:	588b      	ldr	r3, [r1, r2]
 80272da:	f023 030f 	bic.w	r3, r3, #15
 80272de:	508b      	str	r3, [r1, r2]
 80272e0:	b130      	cbz	r0, 80272f0 <E_EEPROM_XMC4_Init+0xfc>
    {
      /* Check if the sector was previously identified as non-empty. i.e It is having old data or corrupted data
       * If so erase the sector and mark it as erase attempted.
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
 80272e2:	68e3      	ldr	r3, [r4, #12]
 80272e4:	07d8      	lsls	r0, r3, #31
 80272e6:	d462      	bmi.n	80273ae <E_EEPROM_XMC4_Init+0x1ba>
  sector_count = 0U;

  do
  {
    /* If the non empty sector is the current active sector, then do not erase it*/
    if (e_eeprom_xmc4_sector_info.current_sector != sector_count)
 80272e8:	f8d8 3008 	ldr.w	r3, [r8, #8]
 80272ec:	2b01      	cmp	r3, #1
 80272ee:	d008      	beq.n	8027302 <E_EEPROM_XMC4_Init+0x10e>
    {
      /* Check if the sector was previously identified as non-empty. i.e It is having old data or corrupted data
       * If so erase the sector and mark it as erase attempted.
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
 80272f0:	f8d8 300c 	ldr.w	r3, [r8, #12]
 80272f4:	4c42      	ldr	r4, [pc, #264]	; (8027400 <E_EEPROM_XMC4_Init+0x20c>)
 80272f6:	0799      	lsls	r1, r3, #30
 80272f8:	d44b      	bmi.n	8027392 <E_EEPROM_XMC4_Init+0x19e>
  sector_count = 0U;

  do
  {
    /* If the non empty sector is the current active sector, then do not erase it*/
    if (e_eeprom_xmc4_sector_info.current_sector != sector_count)
 80272fa:	f8d8 3008 	ldr.w	r3, [r8, #8]
 80272fe:	2b02      	cmp	r3, #2
 8027300:	d008      	beq.n	8027314 <E_EEPROM_XMC4_Init+0x120>
    {
      /* Check if the sector was previously identified as non-empty. i.e It is having old data or corrupted data
       * If so erase the sector and mark it as erase attempted.
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
 8027302:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8027306:	4c3e      	ldr	r4, [pc, #248]	; (8027400 <E_EEPROM_XMC4_Init+0x20c>)
 8027308:	075a      	lsls	r2, r3, #29
 802730a:	d45e      	bmi.n	80273ca <E_EEPROM_XMC4_Init+0x1d6>
  sector_count = 0U;

  do
  {
    /* If the non empty sector is the current active sector, then do not erase it*/
    if (e_eeprom_xmc4_sector_info.current_sector != sector_count)
 802730c:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8027310:	2b03      	cmp	r3, #3
 8027312:	d004      	beq.n	802731e <E_EEPROM_XMC4_Init+0x12a>
    {
      /* Check if the sector was previously identified as non-empty. i.e It is having old data or corrupted data
       * If so erase the sector and mark it as erase attempted.
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
 8027314:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8027318:	4c39      	ldr	r4, [pc, #228]	; (8027400 <E_EEPROM_XMC4_Init+0x20c>)
 802731a:	071b      	lsls	r3, r3, #28
 802731c:	d42b      	bmi.n	8027376 <E_EEPROM_XMC4_Init+0x182>
      {
  
        /* If a valid latest block were not detected, we shall assume that all sectors may be empty.
         * Then make Sector-0 as current sector and next free address as Sector0 start address
         */
        if (e_eeprom_xmc4_sector_info.flash_data_addr == E_EEPROM_XMC4_EMPTY)
 802731e:	f8d8 0004 	ldr.w	r0, [r8, #4]
 8027322:	4b37      	ldr	r3, [pc, #220]	; (8027400 <E_EEPROM_XMC4_Init+0x20c>)
 8027324:	b978      	cbnz	r0, 8027346 <E_EEPROM_XMC4_Init+0x152>
        {
          e_eeprom_xmc4_sector_info.current_sector = E_EEPROM_XMC4_SECTOR_0;
          e_eeprom_xmc4_sector_info.next_free_start_addr =  E_EEPROM_XMC4_SECTOR0_START_ADDR;
 8027326:	4a34      	ldr	r2, [pc, #208]	; (80273f8 <E_EEPROM_XMC4_Init+0x204>)
        /* If a valid latest block were not detected, we shall assume that all sectors may be empty.
         * Then make Sector-0 as current sector and next free address as Sector0 start address
         */
        if (e_eeprom_xmc4_sector_info.flash_data_addr == E_EEPROM_XMC4_EMPTY)
        {
          e_eeprom_xmc4_sector_info.current_sector = E_EEPROM_XMC4_SECTOR_0;
 8027328:	6098      	str	r0, [r3, #8]
          e_eeprom_xmc4_sector_info.next_free_start_addr =  E_EEPROM_XMC4_SECTOR0_START_ADDR;
 802732a:	601a      	str	r2, [r3, #0]
 * \par<b>Related APIs:</b><BR>
 * None
 */
__STATIC_INLINE void XMC_FLASH_EnableDoubleBitErrorTrap(void)
{
  FLASH0->MARP &= (uint32_t)~FLASH_MARP_TRAPDIS_Msk;
 802732c:	4931      	ldr	r1, [pc, #196]	; (80273f4 <E_EEPROM_XMC4_Init+0x200>)
 802732e:	f241 0218 	movw	r2, #4120	; 0x1018
      }
    }

    XMC_FLASH_EnableDoubleBitErrorTrap();

    handle->initialized = (bool)true;
 8027332:	2401      	movs	r4, #1
 8027334:	588b      	ldr	r3, [r1, r2]
 8027336:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 802733a:	508b      	str	r3, [r1, r2]
 802733c:	9b01      	ldr	r3, [sp, #4]
 802733e:	701c      	strb	r4, [r3, #0]
  }

  return (status);
}
 8027340:	b005      	add	sp, #20
 8027342:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8027346:	4a2f      	ldr	r2, [pc, #188]	; (8027404 <E_EEPROM_XMC4_Init+0x210>)
 8027348:	1f03      	subs	r3, r0, #4
 802734a:	f600 74fc 	addw	r4, r0, #4092	; 0xffc
  flash_addr_ptr = (uint32_t*)e_eeprom_xmc4_sector_info.flash_data_addr;
  ram_addr_ptr = (uint32_t*)(void*)&e_eeprom_xmc4_data_buffer;

  for(byte_index = 0U ; byte_index < E_EEPROM_XMC4_MAX_WORDS; byte_index++)
  {
    *(ram_addr_ptr + byte_index) = *(flash_addr_ptr + byte_index);
 802734e:	f853 1f04 	ldr.w	r1, [r3, #4]!
 8027352:	f842 1f04 	str.w	r1, [r2, #4]!
  uint32_t byte_index;

  flash_addr_ptr = (uint32_t*)e_eeprom_xmc4_sector_info.flash_data_addr;
  ram_addr_ptr = (uint32_t*)(void*)&e_eeprom_xmc4_data_buffer;

  for(byte_index = 0U ; byte_index < E_EEPROM_XMC4_MAX_WORDS; byte_index++)
 8027356:	42a3      	cmp	r3, r4
 8027358:	d1f9      	bne.n	802734e <E_EEPROM_XMC4_Init+0x15a>
        else
        {
          /* If a valid latest block was detected, copy the valid block from flash to RAM. */
          E_EEPROM_XMC4_lCopyFlashToRam();
  
          if ((e_eeprom_xmc4_sector_info.next_free_start_addr - e_eeprom_xmc4_sector_info.flash_data_addr) !=
 802735a:	f8d8 3000 	ldr.w	r3, [r8]
              E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE)
          {
            status = E_EEPROM_XMC4_STATUS_ERROR_OLD_DATA;
          }
  
          if (e_eeprom_xmc4_sector_info.next_free_start_addr >= E_EEPROM_XMC4_SECTOR4_START_ADDR)
 802735e:	4a2a      	ldr	r2, [pc, #168]	; (8027408 <E_EEPROM_XMC4_Init+0x214>)
        else
        {
          /* If a valid latest block was detected, copy the valid block from flash to RAM. */
          E_EEPROM_XMC4_lCopyFlashToRam();
  
          if ((e_eeprom_xmc4_sector_info.next_free_start_addr - e_eeprom_xmc4_sector_info.flash_data_addr) !=
 8027360:	4927      	ldr	r1, [pc, #156]	; (8027400 <E_EEPROM_XMC4_Init+0x20c>)
 8027362:	1a18      	subs	r0, r3, r0
              E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE)
          {
            status = E_EEPROM_XMC4_STATUS_ERROR_OLD_DATA;
 8027364:	f5b0 5080 	subs.w	r0, r0, #4096	; 0x1000
 8027368:	bf18      	it	ne
 802736a:	2001      	movne	r0, #1
          }
  
          if (e_eeprom_xmc4_sector_info.next_free_start_addr >= E_EEPROM_XMC4_SECTOR4_START_ADDR)
 802736c:	4293      	cmp	r3, r2
 802736e:	d9dd      	bls.n	802732c <E_EEPROM_XMC4_Init+0x138>
          {
            e_eeprom_xmc4_sector_info.next_free_start_addr =  E_EEPROM_XMC4_SECTOR0_START_ADDR;
 8027370:	4b21      	ldr	r3, [pc, #132]	; (80273f8 <E_EEPROM_XMC4_Init+0x204>)
 8027372:	600b      	str	r3, [r1, #0]
 8027374:	e7da      	b.n	802732c <E_EEPROM_XMC4_Init+0x138>
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
      {
        sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR + (E_EEPROM_XMC4_SECTOR_SIZE * (uint32_t)sector_count);

        XMC_FLASH_ClearStatus();
 8027376:	f7fa f917 	bl	80215a8 <XMC_FLASH_ClearStatus>
        XMC_FLASH_EraseSector((uint32_t*)sector_start_addr);
 802737a:	4824      	ldr	r0, [pc, #144]	; (802740c <E_EEPROM_XMC4_Init+0x218>)
 802737c:	f7fa f94c 	bl	8021618 <XMC_FLASH_EraseSector>

        if (XMC_FLASH_GetStatus() != (uint32_t)XMC_FLASH_STATUS_ERASE_STATE)
 8027380:	f7fa f918 	bl	80215b4 <XMC_FLASH_GetStatus>
 8027384:	2820      	cmp	r0, #32
 8027386:	d12e      	bne.n	80273e6 <E_EEPROM_XMC4_Init+0x1f2>
        {
          status = E_EEPROM_XMC4_STATUS_ERASE_ERROR;
          break;
        }
        e_eeprom_xmc4_sector_info.erase_state &= ~(((uint32_t)1U << sector_count));
 8027388:	68e3      	ldr	r3, [r4, #12]
 802738a:	f023 0308 	bic.w	r3, r3, #8
 802738e:	60e3      	str	r3, [r4, #12]
 8027390:	e7c5      	b.n	802731e <E_EEPROM_XMC4_Init+0x12a>
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
      {
        sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR + (E_EEPROM_XMC4_SECTOR_SIZE * (uint32_t)sector_count);

        XMC_FLASH_ClearStatus();
 8027392:	f7fa f909 	bl	80215a8 <XMC_FLASH_ClearStatus>
        XMC_FLASH_EraseSector((uint32_t*)sector_start_addr);
 8027396:	481e      	ldr	r0, [pc, #120]	; (8027410 <E_EEPROM_XMC4_Init+0x21c>)
 8027398:	f7fa f93e 	bl	8021618 <XMC_FLASH_EraseSector>

        if (XMC_FLASH_GetStatus() != (uint32_t)XMC_FLASH_STATUS_ERASE_STATE)
 802739c:	f7fa f90a 	bl	80215b4 <XMC_FLASH_GetStatus>
 80273a0:	2820      	cmp	r0, #32
 80273a2:	d120      	bne.n	80273e6 <E_EEPROM_XMC4_Init+0x1f2>
        {
          status = E_EEPROM_XMC4_STATUS_ERASE_ERROR;
          break;
        }
        e_eeprom_xmc4_sector_info.erase_state &= ~(((uint32_t)1U << sector_count));
 80273a4:	68e3      	ldr	r3, [r4, #12]
 80273a6:	f023 0302 	bic.w	r3, r3, #2
 80273aa:	60e3      	str	r3, [r4, #12]
 80273ac:	e7a5      	b.n	80272fa <E_EEPROM_XMC4_Init+0x106>
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
      {
        sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR + (E_EEPROM_XMC4_SECTOR_SIZE * (uint32_t)sector_count);

        XMC_FLASH_ClearStatus();
 80273ae:	f7fa f8fb 	bl	80215a8 <XMC_FLASH_ClearStatus>
        XMC_FLASH_EraseSector((uint32_t*)sector_start_addr);
 80273b2:	4811      	ldr	r0, [pc, #68]	; (80273f8 <E_EEPROM_XMC4_Init+0x204>)
 80273b4:	f7fa f930 	bl	8021618 <XMC_FLASH_EraseSector>

        if (XMC_FLASH_GetStatus() != (uint32_t)XMC_FLASH_STATUS_ERASE_STATE)
 80273b8:	f7fa f8fc 	bl	80215b4 <XMC_FLASH_GetStatus>
 80273bc:	2820      	cmp	r0, #32
 80273be:	d114      	bne.n	80273ea <E_EEPROM_XMC4_Init+0x1f6>
        {
          status = E_EEPROM_XMC4_STATUS_ERASE_ERROR;
          break;
        }
        e_eeprom_xmc4_sector_info.erase_state &= ~(((uint32_t)1U << sector_count));
 80273c0:	68e3      	ldr	r3, [r4, #12]
 80273c2:	f023 0301 	bic.w	r3, r3, #1
 80273c6:	60e3      	str	r3, [r4, #12]
 80273c8:	e78e      	b.n	80272e8 <E_EEPROM_XMC4_Init+0xf4>
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
      {
        sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR + (E_EEPROM_XMC4_SECTOR_SIZE * (uint32_t)sector_count);

        XMC_FLASH_ClearStatus();
 80273ca:	f7fa f8ed 	bl	80215a8 <XMC_FLASH_ClearStatus>
        XMC_FLASH_EraseSector((uint32_t*)sector_start_addr);
 80273ce:	4811      	ldr	r0, [pc, #68]	; (8027414 <E_EEPROM_XMC4_Init+0x220>)
 80273d0:	f7fa f922 	bl	8021618 <XMC_FLASH_EraseSector>

        if (XMC_FLASH_GetStatus() != (uint32_t)XMC_FLASH_STATUS_ERASE_STATE)
 80273d4:	f7fa f8ee 	bl	80215b4 <XMC_FLASH_GetStatus>
 80273d8:	2820      	cmp	r0, #32
 80273da:	d104      	bne.n	80273e6 <E_EEPROM_XMC4_Init+0x1f2>
        {
          status = E_EEPROM_XMC4_STATUS_ERASE_ERROR;
          break;
        }
        e_eeprom_xmc4_sector_info.erase_state &= ~(((uint32_t)1U << sector_count));
 80273dc:	68e3      	ldr	r3, [r4, #12]
 80273de:	f023 0304 	bic.w	r3, r3, #4
 80273e2:	60e3      	str	r3, [r4, #12]
 80273e4:	e792      	b.n	802730c <E_EEPROM_XMC4_Init+0x118>
        XMC_FLASH_ClearStatus();
        XMC_FLASH_EraseSector((uint32_t*)sector_start_addr);

        if (XMC_FLASH_GetStatus() != (uint32_t)XMC_FLASH_STATUS_ERASE_STATE)
        {
          status = E_EEPROM_XMC4_STATUS_ERASE_ERROR;
 80273e6:	2004      	movs	r0, #4
 80273e8:	e7a0      	b.n	802732c <E_EEPROM_XMC4_Init+0x138>
 80273ea:	9800      	ldr	r0, [sp, #0]
 80273ec:	e79e      	b.n	802732c <E_EEPROM_XMC4_Init+0x138>
 80273ee:	bf00      	nop
 80273f0:	1fff1a8c 	.word	0x1fff1a8c
 80273f4:	58001000 	.word	0x58001000
 80273f8:	0c010000 	.word	0x0c010000
 80273fc:	08030c54 	.word	0x08030c54
 8027400:	1ffe8a38 	.word	0x1ffe8a38
 8027404:	1fff1a88 	.word	0x1fff1a88
 8027408:	0c01ffff 	.word	0x0c01ffff
 802740c:	0c01c000 	.word	0x0c01c000
 8027410:	0c014000 	.word	0x0c014000
 8027414:	0c018000 	.word	0x0c018000
 8027418:	50020020 	.word	0x50020020

0802741c <E_EEPROM_XMC4_WriteArray>:



/* Update a set of bytes to RAM buffer*/
bool E_EEPROM_XMC4_WriteArray(const uint16_t offset_address, const uint8_t *const data, const uint16_t length)
{
 802741c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  XMC_ASSERT("E_EEPROM_XMC4_WriteArray: Wrong offset address", (offset_address  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))
  XMC_ASSERT("E_EEPROM_XMC4_WriteArray: Wrong length",
                                                    ((offset_address + length)  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))

  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;
 8027420:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 80274cc <E_EEPROM_XMC4_WriteArray+0xb0>
 8027424:	f100 0408 	add.w	r4, r0, #8
 8027428:	4444      	add	r4, r8



/* Update a set of bytes to RAM buffer*/
bool E_EEPROM_XMC4_WriteArray(const uint16_t offset_address, const uint8_t *const data, const uint16_t length)
{
 802742a:	4607      	mov	r7, r0
  XMC_ASSERT("E_EEPROM_XMC4_WriteArray: Wrong offset address", (offset_address  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))
  XMC_ASSERT("E_EEPROM_XMC4_WriteArray: Wrong length",
                                                    ((offset_address + length)  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))

  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;
  status = (memcmp(address_ptr, data, length) != 0);
 802742c:	4620      	mov	r0, r4



/* Update a set of bytes to RAM buffer*/
bool E_EEPROM_XMC4_WriteArray(const uint16_t offset_address, const uint8_t *const data, const uint16_t length)
{
 802742e:	460d      	mov	r5, r1
 8027430:	4616      	mov	r6, r2
  XMC_ASSERT("E_EEPROM_XMC4_WriteArray: Wrong offset address", (offset_address  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))
  XMC_ASSERT("E_EEPROM_XMC4_WriteArray: Wrong length",
                                                    ((offset_address + length)  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))

  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;
  status = (memcmp(address_ptr, data, length) != 0);
 8027432:	f007 fba9 	bl	802eb88 <memcmp>
 8027436:	3000      	adds	r0, #0
 8027438:	bf18      	it	ne
 802743a:	2001      	movne	r0, #1

  for (i = 0U; i < length; i++)
 802743c:	2e00      	cmp	r6, #0
 802743e:	d041      	beq.n	80274c4 <E_EEPROM_XMC4_WriteArray+0xa8>
 8027440:	370c      	adds	r7, #12
 8027442:	4447      	add	r7, r8
 8027444:	1d2b      	adds	r3, r5, #4
 8027446:	42bd      	cmp	r5, r7
 8027448:	bf38      	it	cc
 802744a:	429c      	cmpcc	r4, r3
 802744c:	bf2c      	ite	cs
 802744e:	2701      	movcs	r7, #1
 8027450:	2700      	movcc	r7, #0
 8027452:	2e09      	cmp	r6, #9
 8027454:	bf94      	ite	ls
 8027456:	2700      	movls	r7, #0
 8027458:	f007 0701 	andhi.w	r7, r7, #1
 802745c:	46a6      	mov	lr, r4
 802745e:	b337      	cbz	r7, 80274ae <E_EEPROM_XMC4_WriteArray+0x92>
 8027460:	ea44 0305 	orr.w	r3, r4, r5
 8027464:	079b      	lsls	r3, r3, #30
 8027466:	d122      	bne.n	80274ae <E_EEPROM_XMC4_WriteArray+0x92>
 8027468:	1f32      	subs	r2, r6, #4
 802746a:	f3c2 028d 	ubfx	r2, r2, #2, #14
 802746e:	3201      	adds	r2, #1
 8027470:	0093      	lsls	r3, r2, #2
 8027472:	b29b      	uxth	r3, r3
 8027474:	1f2f      	subs	r7, r5, #4
 8027476:	2100      	movs	r1, #0
 8027478:	3101      	adds	r1, #1
 802747a:	fa1f fc81 	uxth.w	ip, r1
  {
      *(address_ptr + i) = *(data + i);
 802747e:	f857 8f04 	ldr.w	r8, [r7, #4]!
 8027482:	f84e 8b04 	str.w	r8, [lr], #4
 8027486:	4562      	cmp	r2, ip
 8027488:	d8f6      	bhi.n	8027478 <E_EEPROM_XMC4_WriteArray+0x5c>
 802748a:	429e      	cmp	r6, r3
 802748c:	d01a      	beq.n	80274c4 <E_EEPROM_XMC4_WriteArray+0xa8>
                                                    ((offset_address + length)  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))

  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;
  status = (memcmp(address_ptr, data, length) != 0);

  for (i = 0U; i < length; i++)
 802748e:	1c5a      	adds	r2, r3, #1
 8027490:	b292      	uxth	r2, r2
  {
      *(address_ptr + i) = *(data + i);
 8027492:	5ce9      	ldrb	r1, [r5, r3]
 8027494:	54e1      	strb	r1, [r4, r3]
                                                    ((offset_address + length)  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))

  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;
  status = (memcmp(address_ptr, data, length) != 0);

  for (i = 0U; i < length; i++)
 8027496:	4296      	cmp	r6, r2
 8027498:	d914      	bls.n	80274c4 <E_EEPROM_XMC4_WriteArray+0xa8>
 802749a:	3302      	adds	r3, #2
 802749c:	b29b      	uxth	r3, r3
  {
      *(address_ptr + i) = *(data + i);
 802749e:	5ca9      	ldrb	r1, [r5, r2]
 80274a0:	54a1      	strb	r1, [r4, r2]
                                                    ((offset_address + length)  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))

  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;
  status = (memcmp(address_ptr, data, length) != 0);

  for (i = 0U; i < length; i++)
 80274a2:	429e      	cmp	r6, r3
 80274a4:	d910      	bls.n	80274c8 <E_EEPROM_XMC4_WriteArray+0xac>
  {
      *(address_ptr + i) = *(data + i);
 80274a6:	5cea      	ldrb	r2, [r5, r3]
 80274a8:	54e2      	strb	r2, [r4, r3]
 80274aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80274ae:	3e01      	subs	r6, #1
 80274b0:	fa15 f686 	uxtah	r6, r5, r6
 80274b4:	3c01      	subs	r4, #1
 80274b6:	3d01      	subs	r5, #1
 80274b8:	f815 3f01 	ldrb.w	r3, [r5, #1]!
 80274bc:	f804 3f01 	strb.w	r3, [r4, #1]!
                                                    ((offset_address + length)  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))

  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;
  status = (memcmp(address_ptr, data, length) != 0);

  for (i = 0U; i < length; i++)
 80274c0:	42b5      	cmp	r5, r6
 80274c2:	d1f9      	bne.n	80274b8 <E_EEPROM_XMC4_WriteArray+0x9c>
  {
      *(address_ptr + i) = *(data + i);
  }

  return status;
}
 80274c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80274c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80274cc:	1fff1a8c 	.word	0x1fff1a8c

080274d0 <E_EEPROM_XMC4_ReadArray>:



/* Read a set of bytes from RAM Buffer */
void E_EEPROM_XMC4_ReadArray(const uint16_t offset_address, uint8_t *const data, const uint16_t length)
{
 80274d0:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint16_t i;
  uint8_t  *address_ptr;
  XMC_ASSERT("E_EEPROM_XMC4_ReadArray: Wrong offset address", (offset_address  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))
  XMC_ASSERT("E_EEPROM_XMC4_ReadArray: Wrong length",
                                                    ((offset_address + length)  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))
  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;
 80274d2:	4c24      	ldr	r4, [pc, #144]	; (8027564 <E_EEPROM_XMC4_ReadArray+0x94>)
 80274d4:	f100 0308 	add.w	r3, r0, #8
 80274d8:	4423      	add	r3, r4

  for (i=0U; i<length; i++)
 80274da:	2a00      	cmp	r2, #0
 80274dc:	d040      	beq.n	8027560 <E_EEPROM_XMC4_ReadArray+0x90>
 80274de:	300c      	adds	r0, #12
 80274e0:	4420      	add	r0, r4
 80274e2:	1d0c      	adds	r4, r1, #4
 80274e4:	4281      	cmp	r1, r0
 80274e6:	bf38      	it	cc
 80274e8:	42a3      	cmpcc	r3, r4
 80274ea:	bf2c      	ite	cs
 80274ec:	2001      	movcs	r0, #1
 80274ee:	2000      	movcc	r0, #0
 80274f0:	2a09      	cmp	r2, #9
 80274f2:	bf94      	ite	ls
 80274f4:	2000      	movls	r0, #0
 80274f6:	f000 0001 	andhi.w	r0, r0, #1
 80274fa:	b330      	cbz	r0, 802754a <E_EEPROM_XMC4_ReadArray+0x7a>
 80274fc:	ea43 0001 	orr.w	r0, r3, r1
 8027500:	0780      	lsls	r0, r0, #30
 8027502:	d122      	bne.n	802754a <E_EEPROM_XMC4_ReadArray+0x7a>
 8027504:	1f14      	subs	r4, r2, #4
 8027506:	f3c4 048d 	ubfx	r4, r4, #2, #14
 802750a:	3401      	adds	r4, #1
 802750c:	00a0      	lsls	r0, r4, #2
 802750e:	b280      	uxth	r0, r0
 8027510:	1f1f      	subs	r7, r3, #4
 8027512:	460e      	mov	r6, r1
 8027514:	2500      	movs	r5, #0
 8027516:	3501      	adds	r5, #1
 8027518:	fa1f fe85 	uxth.w	lr, r5
  {
    *(data + i) = *(address_ptr + i);
 802751c:	f857 cf04 	ldr.w	ip, [r7, #4]!
 8027520:	f846 cb04 	str.w	ip, [r6], #4
 8027524:	4574      	cmp	r4, lr
 8027526:	d8f6      	bhi.n	8027516 <E_EEPROM_XMC4_ReadArray+0x46>
 8027528:	4282      	cmp	r2, r0
 802752a:	d019      	beq.n	8027560 <E_EEPROM_XMC4_ReadArray+0x90>
  XMC_ASSERT("E_EEPROM_XMC4_ReadArray: Wrong offset address", (offset_address  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))
  XMC_ASSERT("E_EEPROM_XMC4_ReadArray: Wrong length",
                                                    ((offset_address + length)  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))
  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;

  for (i=0U; i<length; i++)
 802752c:	1c44      	adds	r4, r0, #1
 802752e:	b2a4      	uxth	r4, r4
  {
    *(data + i) = *(address_ptr + i);
 8027530:	5c1d      	ldrb	r5, [r3, r0]
 8027532:	540d      	strb	r5, [r1, r0]
  XMC_ASSERT("E_EEPROM_XMC4_ReadArray: Wrong offset address", (offset_address  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))
  XMC_ASSERT("E_EEPROM_XMC4_ReadArray: Wrong length",
                                                    ((offset_address + length)  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))
  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;

  for (i=0U; i<length; i++)
 8027534:	42a2      	cmp	r2, r4
 8027536:	d913      	bls.n	8027560 <E_EEPROM_XMC4_ReadArray+0x90>
 8027538:	3002      	adds	r0, #2
 802753a:	b280      	uxth	r0, r0
  {
    *(data + i) = *(address_ptr + i);
 802753c:	5d1d      	ldrb	r5, [r3, r4]
 802753e:	550d      	strb	r5, [r1, r4]
  XMC_ASSERT("E_EEPROM_XMC4_ReadArray: Wrong offset address", (offset_address  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))
  XMC_ASSERT("E_EEPROM_XMC4_ReadArray: Wrong length",
                                                    ((offset_address + length)  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))
  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;

  for (i=0U; i<length; i++)
 8027540:	4282      	cmp	r2, r0
 8027542:	d90e      	bls.n	8027562 <E_EEPROM_XMC4_ReadArray+0x92>
  {
    *(data + i) = *(address_ptr + i);
 8027544:	5c1b      	ldrb	r3, [r3, r0]
 8027546:	540b      	strb	r3, [r1, r0]
 8027548:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802754a:	3a01      	subs	r2, #1
 802754c:	fa13 f282 	uxtah	r2, r3, r2
 8027550:	3901      	subs	r1, #1
 8027552:	3b01      	subs	r3, #1
 8027554:	f813 0f01 	ldrb.w	r0, [r3, #1]!
 8027558:	f801 0f01 	strb.w	r0, [r1, #1]!
  XMC_ASSERT("E_EEPROM_XMC4_ReadArray: Wrong offset address", (offset_address  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))
  XMC_ASSERT("E_EEPROM_XMC4_ReadArray: Wrong length",
                                                    ((offset_address + length)  < E_EEPROM_XMC4_DATA_BLOCK_SIZE))
  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;

  for (i=0U; i<length; i++)
 802755c:	4293      	cmp	r3, r2
 802755e:	d1f9      	bne.n	8027554 <E_EEPROM_XMC4_ReadArray+0x84>
 8027560:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8027562:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8027564:	1fff1a8c 	.word	0x1fff1a8c

08027568 <E_EEPROM_XMC4_UpdateFlashContents>:



/* Copy data blocks from RAM to FLASH */
E_EEPROM_XMC4_STATUS_t E_EEPROM_XMC4_UpdateFlashContents(void)
{
 8027568:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Calculate the starting address of the active sector from where the first write started for the current cycle*/
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR +
                     (E_EEPROM_XMC4_SECTOR_SIZE * e_eeprom_xmc4_sector_info.current_sector);

  /* If the next free address crosses current active sector starting address, then all the sectors are fully written*/
  if ((e_eeprom_xmc4_sector_info.next_free_start_addr == sector_start_addr) &&
 802756a:	4e4c      	ldr	r6, [pc, #304]	; (802769c <E_EEPROM_XMC4_UpdateFlashContents+0x134>)
     (e_eeprom_xmc4_data_buffer.block_cycle_count != 0U))
 802756c:	4f4c      	ldr	r7, [pc, #304]	; (80276a0 <E_EEPROM_XMC4_UpdateFlashContents+0x138>)
  uint32_t sector_start_addr;

  status = E_EEPROM_XMC4_STATUS_OK;

  /* Calculate the starting address of the active sector from where the first write started for the current cycle*/
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR +
 802756e:	68b3      	ldr	r3, [r6, #8]
                     (E_EEPROM_XMC4_SECTOR_SIZE * e_eeprom_xmc4_sector_info.current_sector);

  /* If the next free address crosses current active sector starting address, then all the sectors are fully written*/
  if ((e_eeprom_xmc4_sector_info.next_free_start_addr == sector_start_addr) &&
 8027570:	6834      	ldr	r4, [r6, #0]
  uint32_t sector_start_addr;

  status = E_EEPROM_XMC4_STATUS_OK;

  /* Calculate the starting address of the active sector from where the first write started for the current cycle*/
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR +
 8027572:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8027576:	3304      	adds	r3, #4
                     (E_EEPROM_XMC4_SECTOR_SIZE * e_eeprom_xmc4_sector_info.current_sector);

  /* If the next free address crosses current active sector starting address, then all the sectors are fully written*/
  if ((e_eeprom_xmc4_sector_info.next_free_start_addr == sector_start_addr) &&
 8027578:	ebb4 3f83 	cmp.w	r4, r3, lsl #14



/* Copy data blocks from RAM to FLASH */
E_EEPROM_XMC4_STATUS_t E_EEPROM_XMC4_UpdateFlashContents(void)
{
 802757c:	b083      	sub	sp, #12
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR +
                     (E_EEPROM_XMC4_SECTOR_SIZE * e_eeprom_xmc4_sector_info.current_sector);

  /* If the next free address crosses current active sector starting address, then all the sectors are fully written*/
  if ((e_eeprom_xmc4_sector_info.next_free_start_addr == sector_start_addr) &&
     (e_eeprom_xmc4_data_buffer.block_cycle_count != 0U))
 802757e:	687b      	ldr	r3, [r7, #4]
  /* Calculate the starting address of the active sector from where the first write started for the current cycle*/
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR +
                     (E_EEPROM_XMC4_SECTOR_SIZE * e_eeprom_xmc4_sector_info.current_sector);

  /* If the next free address crosses current active sector starting address, then all the sectors are fully written*/
  if ((e_eeprom_xmc4_sector_info.next_free_start_addr == sector_start_addr) &&
 8027580:	d030      	beq.n	80275e4 <E_EEPROM_XMC4_UpdateFlashContents+0x7c>
 8027582:	f8df e13c 	ldr.w	lr, [pc, #316]	; 80276c0 <E_EEPROM_XMC4_UpdateFlashContents+0x158>
  uint32_t result;

  /* Reset the CRC result register before new CRC calculation */
  XMC_FCE_InitializeSeedValue(&e_eeprom_xmc4_fce, 0U);

  (void)XMC_FCE_CalculateCRC32(&e_eeprom_xmc4_fce, data_start_addr, E_EEPROM_XMC4_DATA_SIZE_FOR_CRC, &result);
 8027586:	4947      	ldr	r1, [pc, #284]	; (80276a4 <E_EEPROM_XMC4_UpdateFlashContents+0x13c>)
 8027588:	4847      	ldr	r0, [pc, #284]	; (80276a8 <E_EEPROM_XMC4_UpdateFlashContents+0x140>)
    status = E_EEPROM_XMC4_lInitEraseStateMachine();
  }

  if (status ==  E_EEPROM_XMC4_STATUS_OK)
  {
    e_eeprom_xmc4_data_buffer.block_cycle_count++;
 802758a:	3301      	adds	r3, #1
 802758c:	f04f 0c00 	mov.w	ip, #0
 8027590:	607b      	str	r3, [r7, #4]
  uint32_t result;

  /* Reset the CRC result register before new CRC calculation */
  XMC_FCE_InitializeSeedValue(&e_eeprom_xmc4_fce, 0U);

  (void)XMC_FCE_CalculateCRC32(&e_eeprom_xmc4_fce, data_start_addr, E_EEPROM_XMC4_DATA_SIZE_FOR_CRC, &result);
 8027592:	f640 72fc 	movw	r2, #4092	; 0xffc
 8027596:	ab01      	add	r3, sp, #4
 8027598:	f8ce c018 	str.w	ip, [lr, #24]
  uint32_t  page_index;
  E_EEPROM_XMC4_STATUS_t status;

  status = E_EEPROM_XMC4_STATUS_OK;
  flash_addr_ptr = (uint32_t*)e_eeprom_xmc4_sector_info.next_free_start_addr;
  ram_addr_ptr   = (uint32_t*)(void*)&e_eeprom_xmc4_data_buffer;
 802759c:	1f0d      	subs	r5, r1, #4
  uint32_t result;

  /* Reset the CRC result register before new CRC calculation */
  XMC_FCE_InitializeSeedValue(&e_eeprom_xmc4_fce, 0U);

  (void)XMC_FCE_CalculateCRC32(&e_eeprom_xmc4_fce, data_start_addr, E_EEPROM_XMC4_DATA_SIZE_FOR_CRC, &result);
 802759e:	f7fa ff55 	bl	802244c <XMC_FCE_CalculateCRC32>

  return (result);
 80275a2:	9b01      	ldr	r3, [sp, #4]

  status = E_EEPROM_XMC4_STATUS_OK;
  flash_addr_ptr = (uint32_t*)e_eeprom_xmc4_sector_info.next_free_start_addr;
  ram_addr_ptr   = (uint32_t*)(void*)&e_eeprom_xmc4_data_buffer;

  e_eeprom_xmc4_data_buffer.crc = E_EEPROM_XMC4_lCalculateCRC((uint32_t*)(void*)
 80275a4:	603b      	str	r3, [r7, #0]
 80275a6:	f504 5780 	add.w	r7, r4, #4096	; 0x1000
                                                             (&(e_eeprom_xmc4_data_buffer.block_cycle_count)));

  for (page_index = 0U ; page_index < E_EEPROM_XMC4_MAX_PAGES; page_index++)
  {
    XMC_FLASH_ClearStatus();
 80275aa:	f7f9 fffd 	bl	80215a8 <XMC_FLASH_ClearStatus>

    XMC_FLASH_ProgramPage(flash_addr_ptr,ram_addr_ptr);
 80275ae:	4620      	mov	r0, r4
 80275b0:	4629      	mov	r1, r5
 80275b2:	f7fa f807 	bl	80215c4 <XMC_FLASH_ProgramPage>

    if (XMC_FLASH_GetStatus() == (uint32_t)XMC_FLASH_STATUS_VERIFY_ERROR)
 80275b6:	f7f9 fffd 	bl	80215b4 <XMC_FLASH_GetStatus>
 80275ba:	f1b0 4f00 	cmp.w	r0, #2147483648	; 0x80000000
    {
      status = E_EEPROM_XMC4_STATUS_WRITE_ERROR;
      break;
    }
    ram_addr_ptr   += E_EEPROM_XMC4_MIN_WORDS_PER_PAGE ;
    flash_addr_ptr += E_EEPROM_XMC4_MIN_WORDS_PER_PAGE ;
 80275be:	f504 7480 	add.w	r4, r4, #256	; 0x100
    if (XMC_FLASH_GetStatus() == (uint32_t)XMC_FLASH_STATUS_VERIFY_ERROR)
    {
      status = E_EEPROM_XMC4_STATUS_WRITE_ERROR;
      break;
    }
    ram_addr_ptr   += E_EEPROM_XMC4_MIN_WORDS_PER_PAGE ;
 80275c2:	f505 7580 	add.w	r5, r5, #256	; 0x100
  {
    XMC_FLASH_ClearStatus();

    XMC_FLASH_ProgramPage(flash_addr_ptr,ram_addr_ptr);

    if (XMC_FLASH_GetStatus() == (uint32_t)XMC_FLASH_STATUS_VERIFY_ERROR)
 80275c6:	d039      	beq.n	802763c <E_EEPROM_XMC4_UpdateFlashContents+0xd4>
  ram_addr_ptr   = (uint32_t*)(void*)&e_eeprom_xmc4_data_buffer;

  e_eeprom_xmc4_data_buffer.crc = E_EEPROM_XMC4_lCalculateCRC((uint32_t*)(void*)
                                                             (&(e_eeprom_xmc4_data_buffer.block_cycle_count)));

  for (page_index = 0U ; page_index < E_EEPROM_XMC4_MAX_PAGES; page_index++)
 80275c8:	42bc      	cmp	r4, r7
 80275ca:	d1ee      	bne.n	80275aa <E_EEPROM_XMC4_UpdateFlashContents+0x42>
    status = E_EEPROM_XMC4_lWriteToFlash();

    /* If the flash write succeeds, update the latest flash data location in RAM for reference */
    if (status == E_EEPROM_XMC4_STATUS_OK)
    {
      e_eeprom_xmc4_sector_info.flash_data_addr = e_eeprom_xmc4_sector_info.next_free_start_addr;
 80275cc:	6833      	ldr	r3, [r6, #0]
 80275ce:	6073      	str	r3, [r6, #4]
  uint32_t *flash_addr_ptr;
  uint32_t *ram_addr_ptr;
  uint32_t  page_index;
  E_EEPROM_XMC4_STATUS_t status;

  status = E_EEPROM_XMC4_STATUS_OK;
 80275d0:	2000      	movs	r0, #0

    /* Update the next free address to write the new data block*/
    e_eeprom_xmc4_sector_info.next_free_start_addr += E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;

    /* If the next free address crosses 3rd sector end address relocate the address to 0th sector starting address*/
    if (e_eeprom_xmc4_sector_info.next_free_start_addr >= E_EEPROM_XMC4_SECTOR4_START_ADDR)
 80275d2:	4a36      	ldr	r2, [pc, #216]	; (80276ac <E_EEPROM_XMC4_UpdateFlashContents+0x144>)
    {
      e_eeprom_xmc4_sector_info.flash_data_addr = e_eeprom_xmc4_sector_info.next_free_start_addr;
    }

    /* Update the next free address to write the new data block*/
    e_eeprom_xmc4_sector_info.next_free_start_addr += E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;
 80275d4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000

    /* If the next free address crosses 3rd sector end address relocate the address to 0th sector starting address*/
    if (e_eeprom_xmc4_sector_info.next_free_start_addr >= E_EEPROM_XMC4_SECTOR4_START_ADDR)
 80275d8:	4293      	cmp	r3, r2
    {
      e_eeprom_xmc4_sector_info.next_free_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR;
 80275da:	bf88      	it	hi
 80275dc:	4b34      	ldrhi	r3, [pc, #208]	; (80276b0 <E_EEPROM_XMC4_UpdateFlashContents+0x148>)
 80275de:	6033      	str	r3, [r6, #0]
    }
  }

  return (status);
}
 80275e0:	b003      	add	sp, #12
 80275e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  /* Calculate the starting address of the active sector from where the first write started for the current cycle*/
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR +
                     (E_EEPROM_XMC4_SECTOR_SIZE * e_eeprom_xmc4_sector_info.current_sector);

  /* If the next free address crosses current active sector starting address, then all the sectors are fully written*/
  if ((e_eeprom_xmc4_sector_info.next_free_start_addr == sector_start_addr) &&
 80275e4:	2b00      	cmp	r3, #0
 80275e6:	d0cc      	beq.n	8027582 <E_EEPROM_XMC4_UpdateFlashContents+0x1a>
     (e_eeprom_xmc4_data_buffer.block_cycle_count != 0U))
  {
    /* Update the current sector to the latest sector on which the last write was executed. */
    e_eeprom_xmc4_sector_info.current_sector =  ((e_eeprom_xmc4_sector_info.flash_data_addr &
 80275e8:	6873      	ldr	r3, [r6, #4]
                                                E_EEPROM_XMC4_SECTOR_POSITION_MASK) >>
                                                E_EEPROM_XMC4_SECTOR_POSITION);

    /* Mark all the sectors as filled with data */
    e_eeprom_xmc4_sector_info.erase_state = E_EEPROM_XMC4_ALL_SECTORS_FILLED ;
 80275ea:	220f      	movs	r2, #15
  if ((e_eeprom_xmc4_sector_info.next_free_start_addr == sector_start_addr) &&
     (e_eeprom_xmc4_data_buffer.block_cycle_count != 0U))
  {
    /* Update the current sector to the latest sector on which the last write was executed. */
    e_eeprom_xmc4_sector_info.current_sector =  ((e_eeprom_xmc4_sector_info.flash_data_addr &
                                                E_EEPROM_XMC4_SECTOR_POSITION_MASK) >>
 80275ec:	f3c3 3381 	ubfx	r3, r3, #14, #2
  /* If the next free address crosses current active sector starting address, then all the sectors are fully written*/
  if ((e_eeprom_xmc4_sector_info.next_free_start_addr == sector_start_addr) &&
     (e_eeprom_xmc4_data_buffer.block_cycle_count != 0U))
  {
    /* Update the current sector to the latest sector on which the last write was executed. */
    e_eeprom_xmc4_sector_info.current_sector =  ((e_eeprom_xmc4_sector_info.flash_data_addr &
 80275f0:	60b3      	str	r3, [r6, #8]
                                                E_EEPROM_XMC4_SECTOR_POSITION_MASK) >>
                                                E_EEPROM_XMC4_SECTOR_POSITION);

    /* Mark all the sectors as filled with data */
    e_eeprom_xmc4_sector_info.erase_state = E_EEPROM_XMC4_ALL_SECTORS_FILLED ;
 80275f2:	60f2      	str	r2, [r6, #12]
  sector_count = 0U;

  do
  {
    /* If the non empty sector is the current active sector, then do not erase it*/
    if (e_eeprom_xmc4_sector_info.current_sector != sector_count)
 80275f4:	b32b      	cbz	r3, 8027642 <E_EEPROM_XMC4_UpdateFlashContents+0xda>
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
      {
        sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR + (E_EEPROM_XMC4_SECTOR_SIZE * (uint32_t)sector_count);

        XMC_FLASH_ClearStatus();
 80275f6:	f7f9 ffd7 	bl	80215a8 <XMC_FLASH_ClearStatus>
        XMC_FLASH_EraseSector((uint32_t*)sector_start_addr);
 80275fa:	482d      	ldr	r0, [pc, #180]	; (80276b0 <E_EEPROM_XMC4_UpdateFlashContents+0x148>)
 80275fc:	f7fa f80c 	bl	8021618 <XMC_FLASH_EraseSector>

        if (XMC_FLASH_GetStatus() != (uint32_t)XMC_FLASH_STATUS_ERASE_STATE)
 8027600:	f7f9 ffd8 	bl	80215b4 <XMC_FLASH_GetStatus>
 8027604:	2820      	cmp	r0, #32
 8027606:	d146      	bne.n	8027696 <E_EEPROM_XMC4_UpdateFlashContents+0x12e>
        {
          status = E_EEPROM_XMC4_STATUS_ERASE_ERROR;
          break;
        }
        e_eeprom_xmc4_sector_info.erase_state &= ~(((uint32_t)1U << sector_count));
 8027608:	68f3      	ldr	r3, [r6, #12]
  sector_count = 0U;

  do
  {
    /* If the non empty sector is the current active sector, then do not erase it*/
    if (e_eeprom_xmc4_sector_info.current_sector != sector_count)
 802760a:	68b2      	ldr	r2, [r6, #8]
        if (XMC_FLASH_GetStatus() != (uint32_t)XMC_FLASH_STATUS_ERASE_STATE)
        {
          status = E_EEPROM_XMC4_STATUS_ERASE_ERROR;
          break;
        }
        e_eeprom_xmc4_sector_info.erase_state &= ~(((uint32_t)1U << sector_count));
 802760c:	f023 0301 	bic.w	r3, r3, #1
  sector_count = 0U;

  do
  {
    /* If the non empty sector is the current active sector, then do not erase it*/
    if (e_eeprom_xmc4_sector_info.current_sector != sector_count)
 8027610:	2a01      	cmp	r2, #1
        if (XMC_FLASH_GetStatus() != (uint32_t)XMC_FLASH_STATUS_ERASE_STATE)
        {
          status = E_EEPROM_XMC4_STATUS_ERASE_ERROR;
          break;
        }
        e_eeprom_xmc4_sector_info.erase_state &= ~(((uint32_t)1U << sector_count));
 8027612:	60f3      	str	r3, [r6, #12]
  sector_count = 0U;

  do
  {
    /* If the non empty sector is the current active sector, then do not erase it*/
    if (e_eeprom_xmc4_sector_info.current_sector != sector_count)
 8027614:	d004      	beq.n	8027620 <E_EEPROM_XMC4_UpdateFlashContents+0xb8>
    {
      /* Check if the sector was previously identified as non-empty. i.e It is having old data or corrupted data
       * If so erase the sector and mark it as erase attempted.
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
 8027616:	0799      	lsls	r1, r3, #30
 8027618:	d413      	bmi.n	8027642 <E_EEPROM_XMC4_UpdateFlashContents+0xda>
  sector_count = 0U;

  do
  {
    /* If the non empty sector is the current active sector, then do not erase it*/
    if (e_eeprom_xmc4_sector_info.current_sector != sector_count)
 802761a:	68b3      	ldr	r3, [r6, #8]
 802761c:	2b02      	cmp	r3, #2
 802761e:	d006      	beq.n	802762e <E_EEPROM_XMC4_UpdateFlashContents+0xc6>
    {
      /* Check if the sector was previously identified as non-empty. i.e It is having old data or corrupted data
       * If so erase the sector and mark it as erase attempted.
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
 8027620:	68f3      	ldr	r3, [r6, #12]
 8027622:	4c1e      	ldr	r4, [pc, #120]	; (802769c <E_EEPROM_XMC4_UpdateFlashContents+0x134>)
 8027624:	075a      	lsls	r2, r3, #29
 8027626:	d428      	bmi.n	802767a <E_EEPROM_XMC4_UpdateFlashContents+0x112>
  sector_count = 0U;

  do
  {
    /* If the non empty sector is the current active sector, then do not erase it*/
    if (e_eeprom_xmc4_sector_info.current_sector != sector_count)
 8027628:	68b3      	ldr	r3, [r6, #8]
 802762a:	2b03      	cmp	r3, #3
 802762c:	d003      	beq.n	8027636 <E_EEPROM_XMC4_UpdateFlashContents+0xce>
    {
      /* Check if the sector was previously identified as non-empty. i.e It is having old data or corrupted data
       * If so erase the sector and mark it as erase attempted.
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
 802762e:	68f3      	ldr	r3, [r6, #12]
 8027630:	4c1a      	ldr	r4, [pc, #104]	; (802769c <E_EEPROM_XMC4_UpdateFlashContents+0x134>)
 8027632:	071b      	lsls	r3, r3, #28
 8027634:	d413      	bmi.n	802765e <E_EEPROM_XMC4_UpdateFlashContents+0xf6>
 8027636:	6834      	ldr	r4, [r6, #0]
 8027638:	687b      	ldr	r3, [r7, #4]
 802763a:	e7a2      	b.n	8027582 <E_EEPROM_XMC4_UpdateFlashContents+0x1a>
 802763c:	6833      	ldr	r3, [r6, #0]

    XMC_FLASH_ProgramPage(flash_addr_ptr,ram_addr_ptr);

    if (XMC_FLASH_GetStatus() == (uint32_t)XMC_FLASH_STATUS_VERIFY_ERROR)
    {
      status = E_EEPROM_XMC4_STATUS_WRITE_ERROR;
 802763e:	2003      	movs	r0, #3
 8027640:	e7c7      	b.n	80275d2 <E_EEPROM_XMC4_UpdateFlashContents+0x6a>
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
      {
        sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR + (E_EEPROM_XMC4_SECTOR_SIZE * (uint32_t)sector_count);

        XMC_FLASH_ClearStatus();
 8027642:	f7f9 ffb1 	bl	80215a8 <XMC_FLASH_ClearStatus>
        XMC_FLASH_EraseSector((uint32_t*)sector_start_addr);
 8027646:	481b      	ldr	r0, [pc, #108]	; (80276b4 <E_EEPROM_XMC4_UpdateFlashContents+0x14c>)
 8027648:	f7f9 ffe6 	bl	8021618 <XMC_FLASH_EraseSector>

        if (XMC_FLASH_GetStatus() != (uint32_t)XMC_FLASH_STATUS_ERASE_STATE)
 802764c:	f7f9 ffb2 	bl	80215b4 <XMC_FLASH_GetStatus>
 8027650:	2820      	cmp	r0, #32
 8027652:	d120      	bne.n	8027696 <E_EEPROM_XMC4_UpdateFlashContents+0x12e>
        {
          status = E_EEPROM_XMC4_STATUS_ERASE_ERROR;
          break;
        }
        e_eeprom_xmc4_sector_info.erase_state &= ~(((uint32_t)1U << sector_count));
 8027654:	68f3      	ldr	r3, [r6, #12]
 8027656:	f023 0302 	bic.w	r3, r3, #2
 802765a:	60f3      	str	r3, [r6, #12]
 802765c:	e7dd      	b.n	802761a <E_EEPROM_XMC4_UpdateFlashContents+0xb2>
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
      {
        sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR + (E_EEPROM_XMC4_SECTOR_SIZE * (uint32_t)sector_count);

        XMC_FLASH_ClearStatus();
 802765e:	f7f9 ffa3 	bl	80215a8 <XMC_FLASH_ClearStatus>
        XMC_FLASH_EraseSector((uint32_t*)sector_start_addr);
 8027662:	4815      	ldr	r0, [pc, #84]	; (80276b8 <E_EEPROM_XMC4_UpdateFlashContents+0x150>)
 8027664:	f7f9 ffd8 	bl	8021618 <XMC_FLASH_EraseSector>

        if (XMC_FLASH_GetStatus() != (uint32_t)XMC_FLASH_STATUS_ERASE_STATE)
 8027668:	f7f9 ffa4 	bl	80215b4 <XMC_FLASH_GetStatus>
 802766c:	2820      	cmp	r0, #32
 802766e:	d112      	bne.n	8027696 <E_EEPROM_XMC4_UpdateFlashContents+0x12e>
        {
          status = E_EEPROM_XMC4_STATUS_ERASE_ERROR;
          break;
        }
        e_eeprom_xmc4_sector_info.erase_state &= ~(((uint32_t)1U << sector_count));
 8027670:	68e3      	ldr	r3, [r4, #12]
 8027672:	f023 0308 	bic.w	r3, r3, #8
 8027676:	60e3      	str	r3, [r4, #12]
 8027678:	e7dd      	b.n	8027636 <E_EEPROM_XMC4_UpdateFlashContents+0xce>
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
      {
        sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR + (E_EEPROM_XMC4_SECTOR_SIZE * (uint32_t)sector_count);

        XMC_FLASH_ClearStatus();
 802767a:	f7f9 ff95 	bl	80215a8 <XMC_FLASH_ClearStatus>
        XMC_FLASH_EraseSector((uint32_t*)sector_start_addr);
 802767e:	480f      	ldr	r0, [pc, #60]	; (80276bc <E_EEPROM_XMC4_UpdateFlashContents+0x154>)
 8027680:	f7f9 ffca 	bl	8021618 <XMC_FLASH_EraseSector>

        if (XMC_FLASH_GetStatus() != (uint32_t)XMC_FLASH_STATUS_ERASE_STATE)
 8027684:	f7f9 ff96 	bl	80215b4 <XMC_FLASH_GetStatus>
 8027688:	2820      	cmp	r0, #32
 802768a:	d104      	bne.n	8027696 <E_EEPROM_XMC4_UpdateFlashContents+0x12e>
        {
          status = E_EEPROM_XMC4_STATUS_ERASE_ERROR;
          break;
        }
        e_eeprom_xmc4_sector_info.erase_state &= ~(((uint32_t)1U << sector_count));
 802768c:	68e3      	ldr	r3, [r4, #12]
 802768e:	f023 0304 	bic.w	r3, r3, #4
 8027692:	60e3      	str	r3, [r4, #12]
 8027694:	e7c8      	b.n	8027628 <E_EEPROM_XMC4_UpdateFlashContents+0xc0>
        XMC_FLASH_ClearStatus();
        XMC_FLASH_EraseSector((uint32_t*)sector_start_addr);

        if (XMC_FLASH_GetStatus() != (uint32_t)XMC_FLASH_STATUS_ERASE_STATE)
        {
          status = E_EEPROM_XMC4_STATUS_ERASE_ERROR;
 8027696:	2004      	movs	r0, #4
 8027698:	e7a2      	b.n	80275e0 <E_EEPROM_XMC4_UpdateFlashContents+0x78>
 802769a:	bf00      	nop
 802769c:	1ffe8a38 	.word	0x1ffe8a38
 80276a0:	1fff1a8c 	.word	0x1fff1a8c
 80276a4:	1fff1a90 	.word	0x1fff1a90
 80276a8:	08030c54 	.word	0x08030c54
 80276ac:	0c01ffff 	.word	0x0c01ffff
 80276b0:	0c010000 	.word	0x0c010000
 80276b4:	0c014000 	.word	0x0c014000
 80276b8:	0c01c000 	.word	0x0c01c000
 80276bc:	0c018000 	.word	0x0c018000
 80276c0:	50020020 	.word	0x50020020

080276c4 <E_EEPROM_XMC4_IsFlashEmpty>:
bool E_EEPROM_XMC4_IsFlashEmpty(void)
{
  bool status = false;

  /* If data available flash_data_addr will have a valid address*/
  if (e_eeprom_xmc4_sector_info.flash_data_addr == 0U)
 80276c4:	4b02      	ldr	r3, [pc, #8]	; (80276d0 <E_EEPROM_XMC4_IsFlashEmpty+0xc>)
 80276c6:	6858      	ldr	r0, [r3, #4]
  {
    status = true;
  }
  return (status);
}
 80276c8:	fab0 f080 	clz	r0, r0
 80276cc:	0940      	lsrs	r0, r0, #5
 80276ce:	4770      	bx	lr
 80276d0:	1ffe8a38 	.word	0x1ffe8a38

080276d4 <EVENT_GENERATOR_Init>:
{
  /* Checking for null handle */
  XMC_ASSERT("EVENT_GENERATOR_Init:handle NULL" , (handle != NULL));
  
  /* Checking for initialization state of the instance */
  if (false == handle->init_status)
 80276d4:	7b43      	ldrb	r3, [r0, #13]
 80276d6:	b10b      	cbz	r3, 80276dc <EVENT_GENERATOR_Init+0x8>
    /* Update the init status of the instance */
    handle->init_status = true;
  }
  
  return EVENT_GENERATOR_STATUS_SUCCESS;
}
 80276d8:	2000      	movs	r0, #0
 80276da:	4770      	bx	lr

/*
 * This function Initializes a EVENT_GENERATOR APP instances based on user configuration.
 */
EVENT_GENERATOR_STATUS_t EVENT_GENERATOR_Init(EVENT_GENERATOR_t *const handle)
{
 80276dc:	b510      	push	{r4, lr}
 80276de:	4604      	mov	r4, r0
  
  /* Checking for initialization state of the instance */
  if (false == handle->init_status)
  {
    /* Hardware initialization based on UI */
    XMC_ERU_OGU_Init(handle->eru, handle->channel, handle->config);
 80276e0:	6800      	ldr	r0, [r0, #0]
 80276e2:	7b21      	ldrb	r1, [r4, #12]
 80276e4:	6862      	ldr	r2, [r4, #4]
 80276e6:	f7fa fe8b 	bl	8022400 <XMC_ERU_OGU_Init>
    #if (EVENT_GENERATOR_NMI_SUPPORTED == 1U)
    /* Promote the eru event as NMI, Applicable only for XMC4000 devices */
    XMC_SCU_INTERRUPT_EnableNmiRequest(handle->nmi_eru_msk);
 80276ea:	68a0      	ldr	r0, [r4, #8]
 80276ec:	f7f9 fff4 	bl	80216d8 <XMC_SCU_INTERRUPT_EnableNmiRequest>
    #endif
    /* Update the init status of the instance */
    handle->init_status = true;
 80276f0:	2301      	movs	r3, #1
 80276f2:	7363      	strb	r3, [r4, #13]
  }
  
  return EVENT_GENERATOR_STATUS_SUCCESS;
}
 80276f4:	2000      	movs	r0, #0
 80276f6:	bd10      	pop	{r4, pc}

080276f8 <EVENT_DETECTOR_Init>:
{
  /* Checking for null handle */
  XMC_ASSERT("EVENT_DETECTOR_Init:handle NULL" , (handle != NULL));

  /* Checking for initialization state of the instance */
  if (false == handle->init_status)
 80276f8:	7b03      	ldrb	r3, [r0, #12]
 80276fa:	b10b      	cbz	r3, 8027700 <EVENT_DETECTOR_Init+0x8>
    /* Update the init status of the instance */
    handle->init_status = true;
  }
  
  return EVENT_DETECTOR_STATUS_SUCCESS;
}
 80276fc:	2000      	movs	r0, #0
 80276fe:	4770      	bx	lr

/*
 * This function Initializes a EVENT_DETECTOR APP instances (ERSx+ETLx) based on user configuration.
 */
EVENT_DETECTOR_STATUS_t EVENT_DETECTOR_Init(EVENT_DETECTOR_t *const handle)
{
 8027700:	b510      	push	{r4, lr}
 8027702:	4604      	mov	r4, r0

  /* Checking for initialization state of the instance */
  if (false == handle->init_status)
  {
    /* Hardware initialization based on UI */
    XMC_ERU_ETL_Init(handle->eru, handle->channel, handle->config);
 8027704:	6800      	ldr	r0, [r0, #0]
 8027706:	7921      	ldrb	r1, [r4, #4]
 8027708:	68a2      	ldr	r2, [r4, #8]
 802770a:	f7fa fe63 	bl	80223d4 <XMC_ERU_ETL_Init>
    /* Update the init status of the instance */
    handle->init_status = true;
 802770e:	2301      	movs	r3, #1
 8027710:	7323      	strb	r3, [r4, #12]
  }
  
  return EVENT_DETECTOR_STATUS_SUCCESS;
}
 8027712:	2000      	movs	r0, #0
 8027714:	bd10      	pop	{r4, pc}
 8027716:	bf00      	nop

08027718 <DMA_CH_Init>:
  return version;
}

/* DMA_CH initialization function */
DMA_CH_STATUS_t DMA_CH_Init(DMA_CH_t *const obj)
{
 8027718:	b510      	push	{r4, lr}
 802771a:	4604      	mov	r4, r0
  DMA_CH_STATUS_t status;

  XMC_ASSERT("DMA_CH_Init: NULL DMA_CH_t object", (obj != NULL));

  /* This cannot possibly fail! */
  GLOBAL_DMA_Init(obj->dma_global);
 802771c:	6800      	ldr	r0, [r0, #0]
 802771e:	f7ff fcaf 	bl	8027080 <GLOBAL_DMA_Init>

  if (XMC_DMA_CH_Init(obj->dma_global->dma, obj->ch_num, &obj->config->ch_config) == XMC_DMA_CH_STATUS_OK)
 8027722:	6823      	ldr	r3, [r4, #0]
 8027724:	7b21      	ldrb	r1, [r4, #12]
 8027726:	6818      	ldr	r0, [r3, #0]
 8027728:	6862      	ldr	r2, [r4, #4]
 802772a:	f7fa fc09 	bl	8021f40 <XMC_DMA_CH_Init>
 802772e:	b938      	cbnz	r0, 8027740 <DMA_CH_Init+0x28>
  {
	if(obj->config->events)
 8027730:	6863      	ldr	r3, [r4, #4]
 8027732:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8027734:	b932      	cbnz	r2, 8027744 <DMA_CH_Init+0x2c>
	{
		XMC_DMA_CH_EnableEvent(obj->dma_global->dma, obj->ch_num, obj->config->events);
		XMC_DMA_CH_SetEventHandler(obj->dma_global->dma, obj->ch_num, obj->config->callback);
	}
    obj->reload(obj);
 8027736:	4620      	mov	r0, r4
 8027738:	68a3      	ldr	r3, [r4, #8]
 802773a:	4798      	blx	r3
    status = DMA_CH_STATUS_SUCCESS;
 802773c:	2000      	movs	r0, #0
 802773e:	bd10      	pop	{r4, pc}
  }
  else
  {
    status = DMA_CH_STATUS_FAILURE;
 8027740:	2001      	movs	r0, #1
  }

  return status;
}
 8027742:	bd10      	pop	{r4, pc}

  if (XMC_DMA_CH_Init(obj->dma_global->dma, obj->ch_num, &obj->config->ch_config) == XMC_DMA_CH_STATUS_OK)
  {
	if(obj->config->events)
	{
		XMC_DMA_CH_EnableEvent(obj->dma_global->dma, obj->ch_num, obj->config->events);
 8027744:	6823      	ldr	r3, [r4, #0]
 8027746:	7b21      	ldrb	r1, [r4, #12]
 8027748:	6818      	ldr	r0, [r3, #0]
 802774a:	f7fa fd45 	bl	80221d8 <XMC_DMA_CH_EnableEvent>
		XMC_DMA_CH_SetEventHandler(obj->dma_global->dma, obj->ch_num, obj->config->callback);
 802774e:	e894 000c 	ldmia.w	r4, {r2, r3}
 8027752:	7b21      	ldrb	r1, [r4, #12]
 8027754:	6810      	ldr	r0, [r2, #0]
 8027756:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8027758:	f7fa fd56 	bl	8022208 <XMC_DMA_CH_SetEventHandler>
 802775c:	e7eb      	b.n	8027736 <DMA_CH_Init+0x1e>
 802775e:	bf00      	nop

08027760 <DMA_CH_I1_reload>:

extern uint32_t* pDMA_dst_I1; /* Destination address symbol */

void DMA_CH_I1_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
 8027760:	6802      	ldr	r2, [r0, #0]
 * see ::XMC_DMA_CH_Enable() for more information.
 *
 */
__STATIC_INLINE void XMC_DMA_CH_SetBlockSize(XMC_DMA_t *const dma, const uint8_t channel, uint32_t block_size)
{
  dma->CH[channel].CTLH = block_size;
 8027762:	7b03      	ldrb	r3, [r0, #12]
 8027764:	6811      	ldr	r1, [r2, #0]
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_I1);
 8027766:	4a0a      	ldr	r2, [pc, #40]	; (8027790 <DMA_CH_I1_reload+0x30>)
extern uint32_t* pDMA_src_I1; /* Source address symbol */

extern uint32_t* pDMA_dst_I1; /* Destination address symbol */

void DMA_CH_I1_reload(DMA_CH_t *obj)
{
 8027768:	b470      	push	{r4, r5, r6}
 802776a:	2458      	movs	r4, #88	; 0x58
 802776c:	fb04 1303 	mla	r3, r4, r3, r1
 8027770:	f44f 7680 	mov.w	r6, #256	; 0x100
 8027774:	61de      	str	r6, [r3, #28]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetDestinationAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetSourceAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].SAR = addr;
 8027776:	7b03      	ldrb	r3, [r0, #12]
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_I1);
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_I1);
 8027778:	4d06      	ldr	r5, [pc, #24]	; (8027794 <DMA_CH_I1_reload+0x34>)
extern uint32_t* pDMA_dst_I1; /* Destination address symbol */

void DMA_CH_I1_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_I1);
 802777a:	6812      	ldr	r2, [r2, #0]
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_I1);
 802777c:	682d      	ldr	r5, [r5, #0]
 802777e:	fb04 f303 	mul.w	r3, r4, r3
 8027782:	50ca      	str	r2, [r1, r3]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetSourceAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetDestinationAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].DAR = addr;
 8027784:	7b02      	ldrb	r2, [r0, #12]
 8027786:	fb04 1302 	mla	r3, r4, r2, r1
 802778a:	609d      	str	r5, [r3, #8]
}
 802778c:	bc70      	pop	{r4, r5, r6}
 802778e:	4770      	bx	lr
 8027790:	1fff2aa4 	.word	0x1fff2aa4
 8027794:	1fff2abc 	.word	0x1fff2abc

08027798 <DMA_CH_Q1_reload>:

extern uint32_t* pDMA_dst_Q1; /* Destination address symbol */

void DMA_CH_Q1_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
 8027798:	6802      	ldr	r2, [r0, #0]
 * see ::XMC_DMA_CH_Enable() for more information.
 *
 */
__STATIC_INLINE void XMC_DMA_CH_SetBlockSize(XMC_DMA_t *const dma, const uint8_t channel, uint32_t block_size)
{
  dma->CH[channel].CTLH = block_size;
 802779a:	7b03      	ldrb	r3, [r0, #12]
 802779c:	6811      	ldr	r1, [r2, #0]
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_Q1);
 802779e:	4a0a      	ldr	r2, [pc, #40]	; (80277c8 <DMA_CH_Q1_reload+0x30>)
extern uint32_t* pDMA_src_Q1; /* Source address symbol */

extern uint32_t* pDMA_dst_Q1; /* Destination address symbol */

void DMA_CH_Q1_reload(DMA_CH_t *obj)
{
 80277a0:	b470      	push	{r4, r5, r6}
 80277a2:	2458      	movs	r4, #88	; 0x58
 80277a4:	fb04 1303 	mla	r3, r4, r3, r1
 80277a8:	f44f 7680 	mov.w	r6, #256	; 0x100
 80277ac:	61de      	str	r6, [r3, #28]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetDestinationAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetSourceAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].SAR = addr;
 80277ae:	7b03      	ldrb	r3, [r0, #12]
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_Q1);
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_Q1);
 80277b0:	4d06      	ldr	r5, [pc, #24]	; (80277cc <DMA_CH_Q1_reload+0x34>)
extern uint32_t* pDMA_dst_Q1; /* Destination address symbol */

void DMA_CH_Q1_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_Q1);
 80277b2:	6812      	ldr	r2, [r2, #0]
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_Q1);
 80277b4:	682d      	ldr	r5, [r5, #0]
 80277b6:	fb04 f303 	mul.w	r3, r4, r3
 80277ba:	50ca      	str	r2, [r1, r3]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetSourceAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetDestinationAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].DAR = addr;
 80277bc:	7b02      	ldrb	r2, [r0, #12]
 80277be:	fb04 1302 	mla	r3, r4, r2, r1
 80277c2:	609d      	str	r5, [r3, #8]
}
 80277c4:	bc70      	pop	{r4, r5, r6}
 80277c6:	4770      	bx	lr
 80277c8:	1fff2ac0 	.word	0x1fff2ac0
 80277cc:	1fff2ae0 	.word	0x1fff2ae0

080277d0 <DMA_CH_I2_reload>:

extern uint32_t* pDMA_dst_I2; /* Destination address symbol */

void DMA_CH_I2_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
 80277d0:	6802      	ldr	r2, [r0, #0]
 * see ::XMC_DMA_CH_Enable() for more information.
 *
 */
__STATIC_INLINE void XMC_DMA_CH_SetBlockSize(XMC_DMA_t *const dma, const uint8_t channel, uint32_t block_size)
{
  dma->CH[channel].CTLH = block_size;
 80277d2:	7b03      	ldrb	r3, [r0, #12]
 80277d4:	6811      	ldr	r1, [r2, #0]
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_I2);
 80277d6:	4a0a      	ldr	r2, [pc, #40]	; (8027800 <DMA_CH_I2_reload+0x30>)
extern uint32_t* pDMA_src_I2; /* Source address symbol */

extern uint32_t* pDMA_dst_I2; /* Destination address symbol */

void DMA_CH_I2_reload(DMA_CH_t *obj)
{
 80277d8:	b470      	push	{r4, r5, r6}
 80277da:	2458      	movs	r4, #88	; 0x58
 80277dc:	fb04 1303 	mla	r3, r4, r3, r1
 80277e0:	f44f 7680 	mov.w	r6, #256	; 0x100
 80277e4:	61de      	str	r6, [r3, #28]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetDestinationAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetSourceAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].SAR = addr;
 80277e6:	7b03      	ldrb	r3, [r0, #12]
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_I2);
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_I2);
 80277e8:	4d06      	ldr	r5, [pc, #24]	; (8027804 <DMA_CH_I2_reload+0x34>)
extern uint32_t* pDMA_dst_I2; /* Destination address symbol */

void DMA_CH_I2_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_I2);
 80277ea:	6812      	ldr	r2, [r2, #0]
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_I2);
 80277ec:	682d      	ldr	r5, [r5, #0]
 80277ee:	fb04 f303 	mul.w	r3, r4, r3
 80277f2:	50ca      	str	r2, [r1, r3]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetSourceAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetDestinationAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].DAR = addr;
 80277f4:	7b02      	ldrb	r2, [r0, #12]
 80277f6:	fb04 1302 	mla	r3, r4, r2, r1
 80277fa:	609d      	str	r5, [r3, #8]
}
 80277fc:	bc70      	pop	{r4, r5, r6}
 80277fe:	4770      	bx	lr
 8027800:	1fff2aa8 	.word	0x1fff2aa8
 8027804:	1fff2ab4 	.word	0x1fff2ab4

08027808 <DMA_CH_Q2_reload>:

extern uint32_t* pDMA_dst_Q2; /* Destination address symbol */

void DMA_CH_Q2_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
 8027808:	6802      	ldr	r2, [r0, #0]
 * see ::XMC_DMA_CH_Enable() for more information.
 *
 */
__STATIC_INLINE void XMC_DMA_CH_SetBlockSize(XMC_DMA_t *const dma, const uint8_t channel, uint32_t block_size)
{
  dma->CH[channel].CTLH = block_size;
 802780a:	7b03      	ldrb	r3, [r0, #12]
 802780c:	6811      	ldr	r1, [r2, #0]
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_Q2);
 802780e:	4a0a      	ldr	r2, [pc, #40]	; (8027838 <DMA_CH_Q2_reload+0x30>)
extern uint32_t* pDMA_src_Q2; /* Source address symbol */

extern uint32_t* pDMA_dst_Q2; /* Destination address symbol */

void DMA_CH_Q2_reload(DMA_CH_t *obj)
{
 8027810:	b470      	push	{r4, r5, r6}
 8027812:	2458      	movs	r4, #88	; 0x58
 8027814:	fb04 1303 	mla	r3, r4, r3, r1
 8027818:	f44f 7680 	mov.w	r6, #256	; 0x100
 802781c:	61de      	str	r6, [r3, #28]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetDestinationAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetSourceAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].SAR = addr;
 802781e:	7b03      	ldrb	r3, [r0, #12]
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_Q2);
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_Q2);
 8027820:	4d06      	ldr	r5, [pc, #24]	; (802783c <DMA_CH_Q2_reload+0x34>)
extern uint32_t* pDMA_dst_Q2; /* Destination address symbol */

void DMA_CH_Q2_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_Q2);
 8027822:	6812      	ldr	r2, [r2, #0]
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_Q2);
 8027824:	682d      	ldr	r5, [r5, #0]
 8027826:	fb04 f303 	mul.w	r3, r4, r3
 802782a:	50ca      	str	r2, [r1, r3]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetSourceAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetDestinationAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].DAR = addr;
 802782c:	7b02      	ldrb	r2, [r0, #12]
 802782e:	fb04 1302 	mla	r3, r4, r2, r1
 8027832:	609d      	str	r5, [r3, #8]
}
 8027834:	bc70      	pop	{r4, r5, r6}
 8027836:	4770      	bx	lr
 8027838:	1fff2ac4 	.word	0x1fff2ac4
 802783c:	1fff2adc 	.word	0x1fff2adc

08027840 <DIGITAL_IO_Init>:
* @param handler Pointer pointing to APP data structure.
* @return DIGITAL_IO_STATUS_t DIGITAL_IO APP status.
*/

DIGITAL_IO_STATUS_t DIGITAL_IO_Init(const DIGITAL_IO_t *const handler)
{
 8027840:	b510      	push	{r4, lr}
 8027842:	4604      	mov	r4, r0
  XMC_ASSERT("DIGITAL_IO_Init: handler null pointer", handler != NULL);

  /* Initializes input / output characteristics */
  XMC_GPIO_Init(handler->gpio_port, handler->gpio_pin, &handler->gpio_config);
 8027844:	1d02      	adds	r2, r0, #4
 8027846:	7c21      	ldrb	r1, [r4, #16]
 8027848:	6800      	ldr	r0, [r0, #0]
 802784a:	f7f9 ff01 	bl	8021650 <XMC_GPIO_Init>

  /*Configure hardware port control*/
  XMC_GPIO_SetHardwareControl(handler->gpio_port, handler->gpio_pin, handler->hwctrl);
 802784e:	6820      	ldr	r0, [r4, #0]
 8027850:	7c21      	ldrb	r1, [r4, #16]
 8027852:	7c62      	ldrb	r2, [r4, #17]
 8027854:	f7fa fe0e 	bl	8022474 <XMC_GPIO_SetHardwareControl>

  return (DIGITAL_IO_STATUS_OK);
}
 8027858:	2000      	movs	r0, #0
 802785a:	bd10      	pop	{r4, pc}

0802785c <SystemCoreSetup>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 802785c:	4b18      	ldr	r3, [pc, #96]	; (80278c0 <SystemCoreSetup+0x64>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 802785e:	4a19      	ldr	r2, [pc, #100]	; (80278c4 <SystemCoreSetup+0x68>)
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8027860:	68d8      	ldr	r0, [r3, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8027862:	f64f 01ff 	movw	r1, #63743	; 0xf8ff
 8027866:	4001      	ands	r1, r0
  reg_value  =  (reg_value                                   |
 8027868:	430a      	orrs	r2, r1
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 802786a:	60da      	str	r2, [r3, #12]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 802786c:	b672      	cpsid	i
	
  /* relocate vector table */
  __disable_irq();

#if !defined(__TASKING__)
  SCB->VTOR = (uint32_t)(&__Vectors);
 802786e:	4a16      	ldr	r2, [pc, #88]	; (80278c8 <SystemCoreSetup+0x6c>)
 8027870:	609a      	str	r2, [r3, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8027872:	f3bf 8f4f 	dsb	sy
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8027876:	b662      	cpsie	i

  __DSB();
  __enable_irq();
	
#if ((__FPU_PRESENT == 1) && (__FPU_USED == 1))
  SCB->CPACR |= ((3UL << 10*2) |                 /* set CP10 Full Access */
 8027878:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
				 (3UL << 11*2)  );               /* set CP11 Full Access */
#endif
  /* Set flash wait states */
  temp = FLASH0->FCON;
 802787c:	4813      	ldr	r0, [pc, #76]	; (80278cc <SystemCoreSetup+0x70>)

  __DSB();
  __enable_irq();
	
#if ((__FPU_PRESENT == 1) && (__FPU_USED == 1))
  SCB->CPACR |= ((3UL << 10*2) |                 /* set CP10 Full Access */
 802787e:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
				 (3UL << 11*2)  );               /* set CP11 Full Access */
#endif
  /* Set flash wait states */
  temp = FLASH0->FCON;
 8027882:	f241 0114 	movw	r1, #4116	; 0x1014

  __DSB();
  __enable_irq();
	
#if ((__FPU_PRESENT == 1) && (__FPU_USED == 1))
  SCB->CPACR |= ((3UL << 10*2) |                 /* set CP10 Full Access */
 8027886:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
				 (3UL << 11*2)  );               /* set CP11 Full Access */
#endif
  /* Set flash wait states */
  temp = FLASH0->FCON;
 802788a:	5842      	ldr	r2, [r0, r1]
  temp &= ~FLASH_FCON_WSPFLASH_Msk;
 802788c:	f022 020f 	bic.w	r2, r2, #15
  temp |= PMU_FLASH_WS;
 8027890:	f042 0204 	orr.w	r2, r2, #4
  FLASH0->FCON = temp;
 8027894:	5042      	str	r2, [r0, r1]


  /* Disable divide by zero trap */
  SCB->CCR &= ~SCB_CCR_DIV_0_TRP_Msk; 
 8027896:	695a      	ldr	r2, [r3, #20]
 8027898:	f022 0210 	bic.w	r2, r2, #16
 802789c:	615a      	str	r2, [r3, #20]

  /* Disable unaligned memory access trap */
  SCB->CCR &= ~SCB_CCR_UNALIGN_TRP_Msk; 
 802789e:	695a      	ldr	r2, [r3, #20]
 80278a0:	f022 0208 	bic.w	r2, r2, #8
 80278a4:	615a      	str	r2, [r3, #20]

  /* Disable memory management fault */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 80278a6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80278a8:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80278ac:	625a      	str	r2, [r3, #36]	; 0x24

  /* Disable bus fault */
  SCB->SHCSR &= ~SCB_SHCSR_BUSFAULTENA_Msk;
 80278ae:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80278b0:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 80278b4:	625a      	str	r2, [r3, #36]	; 0x24

  /* Disable usage fault */
  SCB->SHCSR &= ~SCB_SHCSR_USGFAULTENA_Msk;
 80278b6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80278b8:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80278bc:	625a      	str	r2, [r3, #36]	; 0x24
 80278be:	4770      	bx	lr
 80278c0:	e000ed00 	.word	0xe000ed00
 80278c4:	05fa0100 	.word	0x05fa0100
 80278c8:	08000000 	.word	0x08000000
 80278cc:	58001000 	.word	0x58001000

080278d0 <arm_bitreversal_32>:
	ENDP

#else

arm_bitreversal_32 PROC
	ADDS     r3,r1,#1
 80278d0:	1c4b      	adds	r3, r1, #1
	CMP      r3,#1
 80278d2:	2b01      	cmp	r3, #1
	IT       LS
 80278d4:	bf98      	it	ls
	BXLS     lr
 80278d6:	4770      	bxls	lr
	PUSH     {r4-r9}
 80278d8:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
	ADDS     r1,r2,#2
 80278dc:	1c91      	adds	r1, r2, #2
	LSRS     r3,r3,#2
 80278de:	089b      	lsrs	r3, r3, #2

080278e0 <arm_bitreversal_32_0>:
arm_bitreversal_32_0 LABEL       ;/* loop unrolled by 2 */
	LDRH     r8,[r1,#4]
 80278e0:	f8b1 8004 	ldrh.w	r8, [r1, #4]
	LDRH     r9,[r1,#2]
 80278e4:	f8b1 9002 	ldrh.w	r9, [r1, #2]
	LDRH     r2,[r1,#0]
 80278e8:	880a      	ldrh	r2, [r1, #0]
	LDRH     r12,[r1,#-2]
 80278ea:	f831 cc02 	ldrh.w	ip, [r1, #-2]
	ADD      r8,r0,r8
 80278ee:	4480      	add	r8, r0
	ADD      r9,r0,r9
 80278f0:	4481      	add	r9, r0
	ADD      r2,r0,r2
 80278f2:	4402      	add	r2, r0
	ADD      r12,r0,r12
 80278f4:	4484      	add	ip, r0
	LDR      r7,[r9,#0]
 80278f6:	f8d9 7000 	ldr.w	r7, [r9]
	LDR      r6,[r8,#0]
 80278fa:	f8d8 6000 	ldr.w	r6, [r8]
	LDR      r5,[r2,#0]
 80278fe:	6815      	ldr	r5, [r2, #0]
	LDR      r4,[r12,#0]
 8027900:	f8dc 4000 	ldr.w	r4, [ip]
	STR      r6,[r9,#0]
 8027904:	f8c9 6000 	str.w	r6, [r9]
	STR      r7,[r8,#0]
 8027908:	f8c8 7000 	str.w	r7, [r8]
	STR      r5,[r12,#0]
 802790c:	f8cc 5000 	str.w	r5, [ip]
	STR      r4,[r2,#0]
 8027910:	6014      	str	r4, [r2, #0]
	LDR      r7,[r9,#4]
 8027912:	f8d9 7004 	ldr.w	r7, [r9, #4]
	LDR      r6,[r8,#4]
 8027916:	f8d8 6004 	ldr.w	r6, [r8, #4]
	LDR      r5,[r2,#4]
 802791a:	6855      	ldr	r5, [r2, #4]
	LDR      r4,[r12,#4]
 802791c:	f8dc 4004 	ldr.w	r4, [ip, #4]
	STR      r6,[r9,#4]
 8027920:	f8c9 6004 	str.w	r6, [r9, #4]
	STR      r7,[r8,#4]
 8027924:	f8c8 7004 	str.w	r7, [r8, #4]
	STR      r5,[r12,#4]
 8027928:	f8cc 5004 	str.w	r5, [ip, #4]
	STR      r4,[r2,#4]
 802792c:	6054      	str	r4, [r2, #4]
	ADDS     r1,r1,#8
 802792e:	3108      	adds	r1, #8
	SUBS     r3,r3,#1
 8027930:	3b01      	subs	r3, #1
	BNE      arm_bitreversal_32_0
 8027932:	d1d5      	bne.n	80278e0 <arm_bitreversal_32_0>
	POP      {r4-r9}
 8027934:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
	BX       lr
 8027938:	4770      	bx	lr

0802793a <arm_bitreversal_16>:
	ENDP

arm_bitreversal_16 PROC
	ADDS     r3,r1,#1
 802793a:	1c4b      	adds	r3, r1, #1
	CMP      r3,#1
 802793c:	2b01      	cmp	r3, #1
	IT       LS
 802793e:	bf98      	it	ls
	BXLS     lr
 8027940:	4770      	bxls	lr
	PUSH     {r4-r9}
 8027942:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
	ADDS     r1,r2,#2
 8027946:	1c91      	adds	r1, r2, #2
	LSRS     r3,r3,#2
 8027948:	089b      	lsrs	r3, r3, #2

0802794a <arm_bitreversal_16_0>:
arm_bitreversal_16_0 LABEL       ;/* loop unrolled by 2 */
	LDRH     r8,[r1,#4]
 802794a:	f8b1 8004 	ldrh.w	r8, [r1, #4]
	LDRH     r9,[r1,#2]
 802794e:	f8b1 9002 	ldrh.w	r9, [r1, #2]
	LDRH     r2,[r1,#0]
 8027952:	880a      	ldrh	r2, [r1, #0]
	LDRH     r12,[r1,#-2]
 8027954:	f831 cc02 	ldrh.w	ip, [r1, #-2]
	ADD      r8,r0,r8,LSR #1
 8027958:	eb00 0858 	add.w	r8, r0, r8, lsr #1
	ADD      r9,r0,r9,LSR #1
 802795c:	eb00 0959 	add.w	r9, r0, r9, lsr #1
	ADD      r2,r0,r2,LSR #1
 8027960:	eb00 0252 	add.w	r2, r0, r2, lsr #1
	ADD      r12,r0,r12,LSR #1
 8027964:	eb00 0c5c 	add.w	ip, r0, ip, lsr #1
	LDR      r7,[r9,#0]
 8027968:	f8d9 7000 	ldr.w	r7, [r9]
	LDR      r6,[r8,#0]
 802796c:	f8d8 6000 	ldr.w	r6, [r8]
	LDR      r5,[r2,#0]
 8027970:	6815      	ldr	r5, [r2, #0]
	LDR      r4,[r12,#0]
 8027972:	f8dc 4000 	ldr.w	r4, [ip]
	STR      r6,[r9,#0]
 8027976:	f8c9 6000 	str.w	r6, [r9]
	STR      r7,[r8,#0]
 802797a:	f8c8 7000 	str.w	r7, [r8]
	STR      r5,[r12,#0]
 802797e:	f8cc 5000 	str.w	r5, [ip]
	STR      r4,[r2,#0]
 8027982:	6014      	str	r4, [r2, #0]
	ADDS     r1,r1,#8
 8027984:	3108      	adds	r1, #8
	SUBS     r3,r3,#1
 8027986:	3b01      	subs	r3, #1
	BNE      arm_bitreversal_16_0
 8027988:	d1df      	bne.n	802794a <arm_bitreversal_16_0>
	POP      {r4-r9}
 802798a:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
	BX       lr
 802798e:	4770      	bx	lr

08027990 <arm_cfft_radix8by2_f32>:
* \endcode
*
*/

void arm_cfft_radix8by2_f32( arm_cfft_instance_f32 * S, float32_t * p1)
{
 8027990:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    uint32_t    L  = S->fftLen;
 8027994:	f8b0 e000 	ldrh.w	lr, [r0]
    float32_t * pCol1, * pCol2, * pMid1, * pMid2;
    float32_t * p2 = p1 + L;
    const float32_t * tw = (float32_t *) S->pTwiddle;
 8027998:	6842      	ldr	r2, [r0, #4]
* \endcode
*
*/

void arm_cfft_radix8by2_f32( arm_cfft_instance_f32 * S, float32_t * p1)
{
 802799a:	4680      	mov	r8, r0
    uint32_t    L  = S->fftLen;
    float32_t * pCol1, * pCol2, * pMid1, * pMid2;
    float32_t * p2 = p1 + L;
 802799c:	eb01 098e 	add.w	r9, r1, lr, lsl #2

    pCol1 = p1;
    pCol2 = p2;

    //    Define new length
    L >>= 1;
 80279a0:	ea4f 005e 	mov.w	r0, lr, lsr #1
    //    Initialize mid pointers
    pMid1 = p1 + L;
    pMid2 = p2 + L;

    // do two dot Fourier transform
    for ( l = L >> 2; l > 0; l-- )
 80279a4:	ea5f 0ede 	movs.w	lr, lr, lsr #3
* \endcode
*
*/

void arm_cfft_radix8by2_f32( arm_cfft_instance_f32 * S, float32_t * p1)
{
 80279a8:	ed2d 8b08 	vpush	{d8-d11}
    pCol2 = p2;

    //    Define new length
    L >>= 1;
    //    Initialize mid pointers
    pMid1 = p1 + L;
 80279ac:	ea4f 0380 	mov.w	r3, r0, lsl #2
    pMid2 = p2 + L;

    // do two dot Fourier transform
    for ( l = L >> 2; l > 0; l-- )
 80279b0:	f000 809f 	beq.w	8027af2 <arm_cfft_radix8by2_f32+0x162>
 80279b4:	3310      	adds	r3, #16
 80279b6:	18ce      	adds	r6, r1, r3
 80279b8:	f101 0510 	add.w	r5, r1, #16
 80279bc:	444b      	add	r3, r9
 80279be:	f102 0710 	add.w	r7, r2, #16
 80279c2:	f109 0410 	add.w	r4, r9, #16
        t1[0] = p1[0];
        t1[1] = p1[1];
        t1[2] = p1[2];
        t1[3] = p1[3];

        t2[0] = p2[0];
 80279c6:	ed14 2a04 	vldr	s4, [r4, #-16]
        t2[1] = p2[1];
 80279ca:	ed54 2a03 	vldr	s5, [r4, #-12]
        t3[0] = pMid1[0];
        t3[1] = pMid1[1];
        t3[2] = pMid1[2];
        t3[3] = pMid1[3];

        t4[0] = pMid2[0];
 80279ce:	ed13 5a04 	vldr	s10, [r3, #-16]
        t4[1] = pMid2[1];
 80279d2:	ed53 5a03 	vldr	s11, [r3, #-12]
        t1[2] = p1[2];
        t1[3] = p1[3];

        t2[0] = p2[0];
        t2[1] = p2[1];
        t2[2] = p2[2];
 80279d6:	ed54 8a02 	vldr	s17, [r4, #-8]
        t2[3] = p2[3];

        t3[0] = pMid1[0];
 80279da:	ed16 3a04 	vldr	s6, [r6, #-16]
        t3[1] = pMid1[1];
 80279de:	ed56 3a03 	vldr	s7, [r6, #-12]
        t3[2] = pMid1[2];
        t3[3] = pMid1[3];

        t4[0] = pMid2[0];
        t4[1] = pMid2[1];
        t4[2] = pMid2[2];
 80279e2:	ed13 7a02 	vldr	s14, [r3, #-8]
        t4[3] = pMid2[3];
 80279e6:	ed53 7a01 	vldr	s15, [r3, #-4]
    pMid2 = p2 + L;

    // do two dot Fourier transform
    for ( l = L >> 2; l > 0; l-- )
    {
        t1[0] = p1[0];
 80279ea:	ed55 4a04 	vldr	s9, [r5, #-16]
        t1[3] = p1[3];

        t2[0] = p2[0];
        t2[1] = p2[1];
        t2[2] = p2[2];
        t2[3] = p2[3];
 80279ee:	ed14 8a01 	vldr	s16, [r4, #-4]

        t3[0] = pMid1[0];
        t3[1] = pMid1[1];
        t3[2] = pMid1[2];
 80279f2:	ed16 0a02 	vldr	s0, [r6, #-8]
        t3[3] = pMid1[3];
 80279f6:	ed56 0a01 	vldr	s1, [r6, #-4]

    // do two dot Fourier transform
    for ( l = L >> 2; l > 0; l-- )
    {
        t1[0] = p1[0];
        t1[1] = p1[1];
 80279fa:	ed15 4a03 	vldr	s8, [r5, #-12]
        t1[2] = p1[2];
 80279fe:	ed55 6a02 	vldr	s13, [r5, #-8]
        t1[3] = p1[3];
 8027a02:	ed15 6a01 	vldr	s12, [r5, #-4]
        t4[0] = pMid2[0];
        t4[1] = pMid2[1];
        t4[2] = pMid2[2];
        t4[3] = pMid2[3];

        *p1++ = t1[0] + t2[0];
 8027a06:	ee74 ba82 	vadd.f32	s23, s9, s4
        *p1++ = t1[1] + t2[1];
 8027a0a:	ee34 ba22 	vadd.f32	s22, s8, s5
        t2[0] = t1[0] - t2[0];
        t2[1] = t1[1] - t2[1];
        t2[2] = t1[2] - t2[2];
        t2[3] = t1[3] - t2[3];    // for col 2

        *pMid1++ = t3[0] + t4[0];
 8027a0e:	ee73 9a05 	vadd.f32	s19, s6, s10
        *pMid1++ = t3[1] + t4[1];
 8027a12:	ee33 9aa5 	vadd.f32	s18, s7, s11
        *pMid1++ = t3[2] + t4[2];
 8027a16:	ee30 1a07 	vadd.f32	s2, s0, s14
        *pMid1++ = t3[3] + t4[3]; // col 1
 8027a1a:	ee70 1aa7 	vadd.f32	s3, s1, s15
        t4[2] = pMid2[2];
        t4[3] = pMid2[3];

        *p1++ = t1[0] + t2[0];
        *p1++ = t1[1] + t2[1];
        *p1++ = t1[2] + t2[2];
 8027a1e:	ee76 aaa8 	vadd.f32	s21, s13, s17
        *p1++ = t1[3] + t2[3];    // col 1
 8027a22:	ee36 aa08 	vadd.f32	s20, s12, s16
        t4[0] = pMid2[0];
        t4[1] = pMid2[1];
        t4[2] = pMid2[2];
        t4[3] = pMid2[3];

        *p1++ = t1[0] + t2[0];
 8027a26:	ed45 ba04 	vstr	s23, [r5, #-16]
        *p1++ = t1[1] + t2[1];
 8027a2a:	ed05 ba03 	vstr	s22, [r5, #-12]
        *p1++ = t1[2] + t2[2];
 8027a2e:	ed45 aa02 	vstr	s21, [r5, #-8]
        *p1++ = t1[3] + t2[3];    // col 1
 8027a32:	ed05 aa01 	vstr	s20, [r5, #-4]
        t2[2] = t1[2] - t2[2];
        t2[3] = t1[3] - t2[3];    // for col 2

        *pMid1++ = t3[0] + t4[0];
        *pMid1++ = t3[1] + t4[1];
        *pMid1++ = t3[2] + t4[2];
 8027a36:	ed06 1a02 	vstr	s2, [r6, #-8]
        *pMid1++ = t3[3] + t4[3]; // col 1
 8027a3a:	ed46 1a01 	vstr	s3, [r6, #-4]
        t2[0] = t1[0] - t2[0];
        t2[1] = t1[1] - t2[1];
        t2[2] = t1[2] - t2[2];
        t2[3] = t1[3] - t2[3];    // for col 2

        *pMid1++ = t3[0] + t4[0];
 8027a3e:	ed46 9a04 	vstr	s19, [r6, #-16]
        *pMid1++ = t3[1] + t4[1];
 8027a42:	ed06 9a03 	vstr	s18, [r6, #-12]
        *p1++ = t1[0] + t2[0];
        *p1++ = t1[1] + t2[1];
        *p1++ = t1[2] + t2[2];
        *p1++ = t1[3] + t2[3];    // col 1

        t2[0] = t1[0] - t2[0];
 8027a46:	ee74 4ac2 	vsub.f32	s9, s9, s4
        t2[1] = t1[1] - t2[1];
 8027a4a:	ee34 4a62 	vsub.f32	s8, s8, s5
        *pMid1++ = t3[0] + t4[0];
        *pMid1++ = t3[1] + t4[1];
        *pMid1++ = t3[2] + t4[2];
        *pMid1++ = t3[3] + t4[3]; // col 1

        t4[0] = t4[0] - t3[0];
 8027a4e:	ee35 5a43 	vsub.f32	s10, s10, s6
        t4[1] = t4[1] - t3[1];
 8027a52:	ee75 5ae3 	vsub.f32	s11, s11, s7
        t4[2] = t4[2] - t3[2];
        t4[3] = t4[3] - t3[3];    // for col 2

        twR = *tw++;
 8027a56:	ed17 3a04 	vldr	s6, [r7, #-16]
        twI = *tw++;
 8027a5a:	ed57 3a03 	vldr	s7, [r7, #-12]
 8027a5e:	ee23 2a65 	vnmul.f32	s4, s6, s11

        // multiply by twiddle factors
        m0 = t2[0] * twR;
        m1 = t2[1] * twI;
 8027a62:	ee64 1a23 	vmul.f32	s3, s8, s7
 8027a66:	ee23 1ae4 	vnmul.f32	s2, s7, s9
        // use vertical symmetry
        //  0.9988 - 0.0491i <==> -0.0491 - 0.9988i
        m0 = t4[0] * twI;
        m1 = t4[1] * twR;
        m2 = t4[1] * twI;
        m3 = t4[0] * twR;
 8027a6a:	ee65 2a03 	vmul.f32	s5, s10, s6
        m3 = t2[0] * twI;

        // R  =  R  *  Tr - I * Ti
        *p2++ = m0 + m1;
        // I  =  I  *  Tr + R * Ti
        *p2++ = m2 - m3;
 8027a6e:	eea4 1a03 	vfma.f32	s2, s8, s6
    //    Initialize mid pointers
    pMid1 = p1 + L;
    pMid2 = p2 + L;

    // do two dot Fourier transform
    for ( l = L >> 2; l > 0; l-- )
 8027a72:	f1be 0e01 	subs.w	lr, lr, #1
 8027a76:	f105 0510 	add.w	r5, r5, #16
        m1 = t2[1] * twI;
        m2 = t2[1] * twR;
        m3 = t2[0] * twI;

        // R  =  R  *  Tr - I * Ti
        *p2++ = m0 + m1;
 8027a7a:	eee4 1a83 	vfma.f32	s3, s9, s6
 8027a7e:	f106 0610 	add.w	r6, r6, #16
 8027a82:	f107 0710 	add.w	r7, r7, #16
        m0 = t4[0] * twI;
        m1 = t4[1] * twR;
        m2 = t4[1] * twI;
        m3 = t4[0] * twR;

        *pMid2++ = m0 - m1;
 8027a86:	eea5 2a23 	vfma.f32	s4, s10, s7
 8027a8a:	f104 0410 	add.w	r4, r4, #16
 8027a8e:	f103 0310 	add.w	r3, r3, #16
        *pMid2++ = m2 + m3;
 8027a92:	eee5 2aa3 	vfma.f32	s5, s11, s7
        m3 = t2[0] * twI;

        // R  =  R  *  Tr - I * Ti
        *p2++ = m0 + m1;
        // I  =  I  *  Tr + R * Ti
        *p2++ = m2 - m3;
 8027a96:	ed04 1a07 	vstr	s2, [r4, #-28]	; 0xffffffe4
        m1 = t2[1] * twI;
        m2 = t2[1] * twR;
        m3 = t2[0] * twI;

        // R  =  R  *  Tr - I * Ti
        *p2++ = m0 + m1;
 8027a9a:	ed44 1a08 	vstr	s3, [r4, #-32]	; 0xffffffe0
        m0 = t4[0] * twI;
        m1 = t4[1] * twR;
        m2 = t4[1] * twI;
        m3 = t4[0] * twR;

        *pMid2++ = m0 - m1;
 8027a9e:	ed03 2a08 	vstr	s4, [r3, #-32]	; 0xffffffe0
        *pMid2++ = m2 + m3;
 8027aa2:	ed43 2a07 	vstr	s5, [r3, #-28]	; 0xffffffe4

        twR = *tw++;
        twI = *tw++;
 8027aa6:	ed57 5a05 	vldr	s11, [r7, #-20]	; 0xffffffec
        m3 = t4[0] * twR;

        *pMid2++ = m0 - m1;
        *pMid2++ = m2 + m3;

        twR = *tw++;
 8027aaa:	ed17 5a06 	vldr	s10, [r7, #-24]	; 0xffffffe8
        *p1++ = t1[2] + t2[2];
        *p1++ = t1[3] + t2[3];    // col 1

        t2[0] = t1[0] - t2[0];
        t2[1] = t1[1] - t2[1];
        t2[2] = t1[2] - t2[2];
 8027aae:	ee76 6ae8 	vsub.f32	s13, s13, s17
        t2[3] = t1[3] - t2[3];    // for col 2
 8027ab2:	ee36 6a48 	vsub.f32	s12, s12, s16
        *pMid1++ = t3[2] + t4[2];
        *pMid1++ = t3[3] + t4[3]; // col 1

        t4[0] = t4[0] - t3[0];
        t4[1] = t4[1] - t3[1];
        t4[2] = t4[2] - t3[2];
 8027ab6:	ee37 7a40 	vsub.f32	s14, s14, s0
        t4[3] = t4[3] - t3[3];    // for col 2
 8027aba:	ee77 7ae0 	vsub.f32	s15, s15, s1

        twR = *tw++;
        twI = *tw++;

        m0 = t2[2] * twR;
        m1 = t2[3] * twI;
 8027abe:	ee26 3a25 	vmul.f32	s6, s12, s11
 8027ac2:	ee65 3ae6 	vnmul.f32	s7, s11, s13
 8027ac6:	ee25 4a67 	vnmul.f32	s8, s10, s15
        *p2++ = m2 - m3;

        m0 = t4[2] * twI;
        m1 = t4[3] * twR;
        m2 = t4[3] * twI;
        m3 = t4[2] * twR;
 8027aca:	ee67 4a05 	vmul.f32	s9, s14, s10
        m1 = t2[3] * twI;
        m2 = t2[3] * twR;
        m3 = t2[2] * twI;

        *p2++ = m0 + m1;
        *p2++ = m2 - m3;
 8027ace:	eee6 3a05 	vfma.f32	s7, s12, s10
        m0 = t2[2] * twR;
        m1 = t2[3] * twI;
        m2 = t2[3] * twR;
        m3 = t2[2] * twI;

        *p2++ = m0 + m1;
 8027ad2:	eea6 3a85 	vfma.f32	s6, s13, s10
        m0 = t4[2] * twI;
        m1 = t4[3] * twR;
        m2 = t4[3] * twI;
        m3 = t4[2] * twR;

        *pMid2++ = m0 - m1;
 8027ad6:	eea7 4a25 	vfma.f32	s8, s14, s11
        *pMid2++ = m2 + m3;
 8027ada:	eee7 4aa5 	vfma.f32	s9, s15, s11
        m0 = t2[2] * twR;
        m1 = t2[3] * twI;
        m2 = t2[3] * twR;
        m3 = t2[2] * twI;

        *p2++ = m0 + m1;
 8027ade:	ed04 3a06 	vstr	s6, [r4, #-24]	; 0xffffffe8
        *p2++ = m2 - m3;
 8027ae2:	ed44 3a05 	vstr	s7, [r4, #-20]	; 0xffffffec
        m0 = t4[2] * twI;
        m1 = t4[3] * twR;
        m2 = t4[3] * twI;
        m3 = t4[2] * twR;

        *pMid2++ = m0 - m1;
 8027ae6:	ed03 4a06 	vstr	s8, [r3, #-24]	; 0xffffffe8
        *pMid2++ = m2 + m3;
 8027aea:	ed43 4a05 	vstr	s9, [r3, #-20]	; 0xffffffec
    //    Initialize mid pointers
    pMid1 = p1 + L;
    pMid2 = p2 + L;

    // do two dot Fourier transform
    for ( l = L >> 2; l > 0; l-- )
 8027aee:	f47f af6a 	bne.w	80279c6 <arm_cfft_radix8by2_f32+0x36>
        *pMid2++ = m0 - m1;
        *pMid2++ = m2 + m3;
    }

    // first col
    arm_radix8_butterfly_f32( pCol1, L, (float32_t *) S->pTwiddle, 2u);
 8027af2:	b284      	uxth	r4, r0
 8027af4:	2302      	movs	r3, #2
 8027af6:	4608      	mov	r0, r1
 8027af8:	4621      	mov	r1, r4
 8027afa:	f000 fac5 	bl	8028088 <arm_radix8_butterfly_f32>
    // second col
    arm_radix8_butterfly_f32( pCol2, L, (float32_t *) S->pTwiddle, 2u);
}
 8027afe:	ecbd 8b08 	vpop	{d8-d11}
    }

    // first col
    arm_radix8_butterfly_f32( pCol1, L, (float32_t *) S->pTwiddle, 2u);
    // second col
    arm_radix8_butterfly_f32( pCol2, L, (float32_t *) S->pTwiddle, 2u);
 8027b02:	4648      	mov	r0, r9
 8027b04:	4621      	mov	r1, r4
 8027b06:	f8d8 2004 	ldr.w	r2, [r8, #4]
 8027b0a:	2302      	movs	r3, #2
}
 8027b0c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    }

    // first col
    arm_radix8_butterfly_f32( pCol1, L, (float32_t *) S->pTwiddle, 2u);
    // second col
    arm_radix8_butterfly_f32( pCol2, L, (float32_t *) S->pTwiddle, 2u);
 8027b10:	f000 baba 	b.w	8028088 <arm_radix8_butterfly_f32>

08027b14 <arm_cfft_radix8by4_f32>:
}

void arm_cfft_radix8by4_f32( arm_cfft_instance_f32 * S, float32_t * p1)
{
 8027b14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8027b18:	ed2d 8b0a 	vpush	{d8-d12}
    uint32_t    L  = S->fftLen >> 1;
 8027b1c:	8804      	ldrh	r4, [r0, #0]
    pEnd1 = p2 - 1;     // points to imaginary values by default
    pEnd2 = p3 - 1;
    pEnd3 = p4 - 1;
    pEnd4 = pEnd3 + L;

    tw2 = tw3 = tw4 = (float32_t *) S->pTwiddle;
 8027b1e:	6843      	ldr	r3, [r0, #4]
    twMod2 = 2;
    twMod3 = 4;
    twMod4 = 6;

    // TOP
    p1ap3_0 = p1[0] + p3[0];
 8027b20:	ed91 6a00 	vldr	s12, [r1]
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
 8027b24:	ed91 7a01 	vldr	s14, [r1, #4]
    // second col
    arm_radix8_butterfly_f32( pCol2, L, (float32_t *) S->pTwiddle, 2u);
}

void arm_cfft_radix8by4_f32( arm_cfft_instance_f32 * S, float32_t * p1)
{
 8027b28:	b08f      	sub	sp, #60	; 0x3c
    uint32_t    L  = S->fftLen >> 1;
 8027b2a:	0864      	lsrs	r4, r4, #1
    pEnd1 = p2 - 1;     // points to imaginary values by default
    pEnd2 = p3 - 1;
    pEnd3 = p4 - 1;
    pEnd4 = pEnd3 + L;

    tw2 = tw3 = tw4 = (float32_t *) S->pTwiddle;
 8027b2c:	9301      	str	r3, [sp, #4]
    twMod4 = 6;

    // TOP
    p1ap3_0 = p1[0] + p3[0];
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
 8027b2e:	460a      	mov	r2, r1
void arm_cfft_radix8by4_f32( arm_cfft_instance_f32 * S, float32_t * p1)
{
    uint32_t    L  = S->fftLen >> 1;
    float32_t * pCol1, *pCol2, *pCol3, *pCol4, *pEnd1, *pEnd2, *pEnd3, *pEnd4;
    const float32_t *tw2, *tw3, *tw4;
    float32_t * p2 = p1 + L;
 8027b30:	00a3      	lsls	r3, r4, #2
 8027b32:	441a      	add	r2, r3
 8027b34:	4615      	mov	r5, r2
 8027b36:	9208      	str	r2, [sp, #32]
    float32_t * p3 = p2 + L;
 8027b38:	441a      	add	r2, r3
    twMod2 = 2;
    twMod3 = 4;
    twMod4 = 6;

    // TOP
    p1ap3_0 = p1[0] + p3[0];
 8027b3a:	edd2 6a00 	vldr	s13, [r2]
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8027b3e:	edd5 3a00 	vldr	s7, [r5]
    // second col
    arm_radix8_butterfly_f32( pCol2, L, (float32_t *) S->pTwiddle, 2u);
}

void arm_cfft_radix8by4_f32( arm_cfft_instance_f32 * S, float32_t * p1)
{
 8027b42:	910c      	str	r1, [sp, #48]	; 0x30
 8027b44:	460e      	mov	r6, r1
    twMod2 = 2;
    twMod3 = 4;
    twMod4 = 6;

    // TOP
    p1ap3_0 = p1[0] + p3[0];
 8027b46:	ee76 5a26 	vadd.f32	s11, s12, s13
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
 8027b4a:	4611      	mov	r1, r2
    // second col
    arm_radix8_butterfly_f32( pCol2, L, (float32_t *) S->pTwiddle, 2u);
}

void arm_cfft_radix8by4_f32( arm_cfft_instance_f32 * S, float32_t * p1)
{
 8027b4c:	900b      	str	r0, [sp, #44]	; 0x2c
    uint32_t    L  = S->fftLen >> 1;
    float32_t * pCol1, *pCol2, *pCol3, *pCol4, *pEnd1, *pEnd2, *pEnd3, *pEnd4;
    const float32_t *tw2, *tw3, *tw4;
    float32_t * p2 = p1 + L;
    float32_t * p3 = p2 + L;
    float32_t * p4 = p3 + L;
 8027b4e:	4608      	mov	r0, r1
 8027b50:	4419      	add	r1, r3
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8027b52:	ed91 4a00 	vldr	s8, [r1]
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8027b56:	edd5 2a01 	vldr	s5, [r5, #4]
    twMod4 = 6;

    // TOP
    p1ap3_0 = p1[0] + p3[0];
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
 8027b5a:	edd2 7a01 	vldr	s15, [r2, #4]
{
    uint32_t    L  = S->fftLen >> 1;
    float32_t * pCol1, *pCol2, *pCol3, *pCol4, *pEnd1, *pEnd2, *pEnd3, *pEnd4;
    const float32_t *tw2, *tw3, *tw4;
    float32_t * p2 = p1 + L;
    float32_t * p3 = p2 + L;
 8027b5e:	9209      	str	r2, [sp, #36]	; 0x24
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8027b60:	ee75 4aa3 	vadd.f32	s9, s11, s7
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8027b64:	462a      	mov	r2, r5
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8027b66:	ee74 4a24 	vadd.f32	s9, s8, s9
 8027b6a:	4635      	mov	r5, r6
 8027b6c:	ee14 ea90 	vmov	lr, s9
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8027b70:	ed91 5a01 	vldr	s10, [r1, #4]
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8027b74:	f845 eb08 	str.w	lr, [r5], #8
    twMod3 = 4;
    twMod4 = 6;

    // TOP
    p1ap3_0 = p1[0] + p3[0];
    p1sp3_0 = p1[0] - p3[0];
 8027b78:	ee76 6a66 	vsub.f32	s13, s12, s13
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8027b7c:	edd2 4a01 	vldr	s9, [r2, #4]
    uint32_t    L  = S->fftLen >> 1;
    float32_t * pCol1, *pCol2, *pCol3, *pCol4, *pEnd1, *pEnd2, *pEnd3, *pEnd4;
    const float32_t *tw2, *tw3, *tw4;
    float32_t * p2 = p1 + L;
    float32_t * p3 = p2 + L;
    float32_t * p4 = p3 + L;
 8027b80:	9100      	str	r1, [sp, #0]
    twMod4 = 6;

    // TOP
    p1ap3_0 = p1[0] + p3[0];
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
 8027b82:	ee37 6a27 	vadd.f32	s12, s14, s15
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8027b86:	460f      	mov	r7, r1
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8027b88:	ed97 2a01 	vldr	s4, [r7, #4]
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8027b8c:	9503      	str	r5, [sp, #12]

    // TOP
    p1ap3_0 = p1[0] + p3[0];
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];
 8027b8e:	ee77 7a67 	vsub.f32	s15, s14, s15

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8027b92:	ee32 3aa6 	vadd.f32	s6, s5, s13
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8027b96:	ee36 7a24 	vadd.f32	s14, s12, s9

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
 8027b9a:	ee75 5ae3 	vsub.f32	s11, s11, s7
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8027b9e:	ee77 4ae3 	vsub.f32	s9, s15, s7
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
    t3[1] = p1ap3_1 - p2[1] - p4[1];
 8027ba2:	ee36 6a62 	vsub.f32	s12, s12, s5
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
 8027ba6:	ee77 7aa3 	vadd.f32	s15, s15, s7
    t2[1] = p1sp3_1 - p2[0] + p4[0];
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
 8027baa:	ee76 6ae2 	vsub.f32	s13, s13, s5
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8027bae:	ee73 3a45 	vsub.f32	s7, s6, s10
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8027bb2:	ee37 7a02 	vadd.f32	s14, s14, s4
 8027bb6:	4611      	mov	r1, r2
 8027bb8:	ed86 7a01 	vstr	s14, [r6, #4]
    pEnd3 = p4 - 1;
    pEnd4 = pEnd3 + L;

    tw2 = tw3 = tw4 = (float32_t *) S->pTwiddle;

    L >>= 1;
 8027bbc:	0862      	lsrs	r2, r4, #1
    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
    t3[1] = p1ap3_1 - p2[1] - p4[1];
 8027bbe:	ee36 6a45 	vsub.f32	s12, s12, s10
    *p3++ = t3[0];
    *p3++ = t3[1];
    *p4++ = t4[0];
    *p4++ = t4[1];

    tw2 += twMod2;
 8027bc2:	9c01      	ldr	r4, [sp, #4]
    pEnd3 = p4 - 1;
    pEnd4 = pEnd3 + L;

    tw2 = tw3 = tw4 = (float32_t *) S->pTwiddle;

    L >>= 1;
 8027bc4:	920a      	str	r2, [sp, #40]	; 0x28
    t2[1] = p1sp3_1 - p2[0] + p4[0];
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
 8027bc6:	ee75 6a26 	vadd.f32	s13, s10, s13
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];

    // Twiddle factors are ones
    *p2++ = t2[0];
 8027bca:	4688      	mov	r8, r1
    *p2++ = t2[1];
    *p3++ = t3[0];
    *p3++ = t3[1];
    *p4++ = t4[0];
 8027bcc:	46bc      	mov	ip, r7
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8027bce:	ee34 5a84 	vadd.f32	s10, s9, s8
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8027bd2:	4635      	mov	r5, r6
    pCol2 = p2;
    pCol3 = p3;
    pCol4 = p4;
    pEnd1 = p2 - 1;     // points to imaginary values by default
    pEnd2 = p3 - 1;
    pEnd3 = p4 - 1;
 8027bd4:	1f3e      	subs	r6, r7, #4
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];

    // Twiddle factors are ones
    *p2++ = t2[0];
 8027bd6:	ee13 7a90 	vmov	r7, s7
 8027bda:	468e      	mov	lr, r1

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
 8027bdc:	ee75 5ac4 	vsub.f32	s11, s11, s8
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];

    // Twiddle factors are ones
    *p2++ = t2[0];
 8027be0:	f848 7b08 	str.w	r7, [r8], #8
    *p2++ = t2[1];
 8027be4:	ed8e 5a01 	vstr	s10, [lr, #4]

    pCol1 = p1;         // points to real values by default
    pCol2 = p2;
    pCol3 = p3;
    pCol4 = p4;
    pEnd1 = p2 - 1;     // points to imaginary values by default
 8027be8:	f1ae 0704 	sub.w	r7, lr, #4
    *p3++ = t3[0];
    *p3++ = t3[1];
    *p4++ = t4[0];
    *p4++ = t4[1];

    tw2 += twMod2;
 8027bec:	f104 0e08 	add.w	lr, r4, #8
    *p1++ = p1ap3_1 + p2[1] + p4[1];

    // Twiddle factors are ones
    *p2++ = t2[0];
    *p2++ = t2[1];
    *p3++ = t3[0];
 8027bf0:	4601      	mov	r1, r0
    *p3++ = t3[1];
    *p4++ = t4[0];
    *p4++ = t4[1];

    tw2 += twMod2;
 8027bf2:	f8cd e010 	str.w	lr, [sp, #16]
    *p1++ = p1ap3_1 + p2[1] + p4[1];

    // Twiddle factors are ones
    *p2++ = t2[0];
    *p2++ = t2[1];
    *p3++ = t3[0];
 8027bf6:	ee15 ea90 	vmov	lr, s11
 8027bfa:	f841 eb08 	str.w	lr, [r1], #8
 8027bfe:	9106      	str	r1, [sp, #24]
    *p3++ = t3[1];
    *p4++ = t4[0];
    *p4++ = t4[1];

    tw2 += twMod2;
    tw3 += twMod3;
 8027c00:	9901      	ldr	r1, [sp, #4]

    // Twiddle factors are ones
    *p2++ = t2[0];
    *p2++ = t2[1];
    *p3++ = t3[0];
    *p3++ = t3[1];
 8027c02:	ed80 6a01 	vstr	s12, [r0, #4]
    *p4++ = t4[0];
    *p4++ = t4[1];

    tw2 += twMod2;
    tw3 += twMod3;
 8027c06:	f101 0e10 	add.w	lr, r1, #16
 8027c0a:	f8cd e008 	str.w	lr, [sp, #8]
    tw4 += twMod4;
 8027c0e:	f101 0e18 	add.w	lr, r1, #24
 8027c12:	f8cd e014 	str.w	lr, [sp, #20]
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
 8027c16:	ee77 7ac4 	vsub.f32	s15, s15, s8

    tw2 += twMod2;
    tw3 += twMod3;
    tw4 += twMod4;

    for (l = (L - 2) >> 1; l > 0; l-- )
 8027c1a:	3a02      	subs	r2, #2
    // Twiddle factors are ones
    *p2++ = t2[0];
    *p2++ = t2[1];
    *p3++ = t3[0];
    *p3++ = t3[1];
    *p4++ = t4[0];
 8027c1c:	ee16 ea90 	vmov	lr, s13
    *p4++ = t4[1];
 8027c20:	9c00      	ldr	r4, [sp, #0]
    // Twiddle factors are ones
    *p2++ = t2[0];
    *p2++ = t2[1];
    *p3++ = t3[0];
    *p3++ = t3[1];
    *p4++ = t4[0];
 8027c22:	f84c eb08 	str.w	lr, [ip], #8

    tw2 += twMod2;
    tw3 += twMod3;
    tw4 += twMod4;

    for (l = (L - 2) >> 1; l > 0; l-- )
 8027c26:	0852      	lsrs	r2, r2, #1
    *p2++ = t2[0];
    *p2++ = t2[1];
    *p3++ = t3[0];
    *p3++ = t3[1];
    *p4++ = t4[0];
    *p4++ = t4[1];
 8027c28:	edc4 7a01 	vstr	s15, [r4, #4]

    tw2 += twMod2;
    tw3 += twMod3;
    tw4 += twMod4;

    for (l = (L - 2) >> 1; l > 0; l-- )
 8027c2c:	9207      	str	r2, [sp, #28]
 8027c2e:	f000 811b 	beq.w	8027e68 <arm_cfft_radix8by4_f32+0x354>
 8027c32:	4604      	mov	r4, r0
 8027c34:	3b08      	subs	r3, #8
 8027c36:	f8dd a008 	ldr.w	sl, [sp, #8]
 8027c3a:	f8cd c034 	str.w	ip, [sp, #52]	; 0x34
 8027c3e:	4693      	mov	fp, r2
 8027c40:	f101 0920 	add.w	r9, r1, #32
 8027c44:	f1a0 020c 	sub.w	r2, r0, #12
 8027c48:	f101 0e30 	add.w	lr, r1, #48	; 0x30
 8027c4c:	4433      	add	r3, r6
 8027c4e:	3510      	adds	r5, #16
 8027c50:	3410      	adds	r4, #16
 8027c52:	4660      	mov	r0, ip
 8027c54:	4641      	mov	r1, r8
    {
        // TOP
        p1ap3_0 = p1[0] + p3[0];
 8027c56:	ed14 7a02 	vldr	s14, [r4, #-8]
 8027c5a:	ed55 3a02 	vldr	s7, [r5, #-8]
        p1sp3_0 = p1[0] - p3[0];
        p1ap3_1 = p1[1] + p3[1];
        p1sp3_1 = p1[1] - p3[1];
        // col 2
        t2[0] = p1sp3_0 + p2[1] - p4[1];
        t2[1] = p1sp3_1 - p2[0] + p4[0];
 8027c5e:	edd1 5a00 	vldr	s11, [r1]
 8027c62:	ed90 6a00 	vldr	s12, [r0]
    for (l = (L - 2) >> 1; l > 0; l-- )
    {
        // TOP
        p1ap3_0 = p1[0] + p3[0];
        p1sp3_0 = p1[0] - p3[0];
        p1ap3_1 = p1[1] + p3[1];
 8027c66:	ed54 6a01 	vldr	s13, [r4, #-4]
 8027c6a:	ed15 5a01 	vldr	s10, [r5, #-4]
        p1sp3_1 = p1[1] - p3[1];
        // col 2
        t2[0] = p1sp3_0 + p2[1] - p4[1];
 8027c6e:	edd0 4a01 	vldr	s9, [r0, #4]
 8027c72:	ed91 4a01 	vldr	s8, [r1, #4]
    tw4 += twMod4;

    for (l = (L - 2) >> 1; l > 0; l-- )
    {
        // TOP
        p1ap3_0 = p1[0] + p3[0];
 8027c76:	ee33 0a87 	vadd.f32	s0, s7, s14
        p1sp3_0 = p1[0] - p3[0];
        p1ap3_1 = p1[1] + p3[1];
 8027c7a:	ee35 8a26 	vadd.f32	s16, s10, s13
        t3[1] = p1ap3_1 - p2[1] - p4[1];
        // col 4
        t4[0] = p1sp3_0 - p2[1] + p4[1];
        t4[1] = p1sp3_1 + p2[0] - p4[0];
        // col 1 - top
        *p1++ = p1ap3_0 + p2[0] + p4[0];
 8027c7e:	ee70 7a25 	vadd.f32	s15, s0, s11

    for (l = (L - 2) >> 1; l > 0; l-- )
    {
        // TOP
        p1ap3_0 = p1[0] + p3[0];
        p1sp3_0 = p1[0] - p3[0];
 8027c82:	ee73 3ac7 	vsub.f32	s7, s7, s14
        t3[1] = p1ap3_1 - p2[1] - p4[1];
        // col 4
        t4[0] = p1sp3_0 - p2[1] + p4[1];
        t4[1] = p1sp3_1 + p2[0] - p4[0];
        // col 1 - top
        *p1++ = p1ap3_0 + p2[0] + p4[0];
 8027c86:	ee76 7a27 	vadd.f32	s15, s12, s15
    {
        // TOP
        p1ap3_0 = p1[0] + p3[0];
        p1sp3_0 = p1[0] - p3[0];
        p1ap3_1 = p1[1] + p3[1];
        p1sp3_1 = p1[1] - p3[1];
 8027c8a:	ee35 5a66 	vsub.f32	s10, s10, s13
        t3[1] = p1ap3_1 - p2[1] - p4[1];
        // col 4
        t4[0] = p1sp3_0 - p2[1] + p4[1];
        t4[1] = p1sp3_1 + p2[0] - p4[0];
        // col 1 - top
        *p1++ = p1ap3_0 + p2[0] + p4[0];
 8027c8e:	ed45 7a02 	vstr	s15, [r5, #-8]
        *p1++ = p1ap3_1 + p2[1] + p4[1];
 8027c92:	edd1 7a01 	vldr	s15, [r1, #4]
 8027c96:	ed90 7a01 	vldr	s14, [r0, #4]
 8027c9a:	ee78 7a27 	vadd.f32	s15, s16, s15
        p1sp3_0 = p1[0] - p3[0];
        p1ap3_1 = p1[1] + p3[1];
        p1sp3_1 = p1[1] - p3[1];
        // col 2
        t2[0] = p1sp3_0 + p2[1] - p4[1];
        t2[1] = p1sp3_1 - p2[0] + p4[0];
 8027c9e:	ee35 aa65 	vsub.f32	s20, s10, s11
        // col 4
        t4[0] = p1sp3_0 - p2[1] + p4[1];
        t4[1] = p1sp3_1 + p2[0] - p4[0];
        // col 1 - top
        *p1++ = p1ap3_0 + p2[0] + p4[0];
        *p1++ = p1ap3_1 + p2[1] + p4[1];
 8027ca2:	ee77 7a87 	vadd.f32	s15, s15, s14
        p1sp3_0 = p1[0] - p3[0];
        p1ap3_1 = p1[1] + p3[1];
        p1sp3_1 = p1[1] - p3[1];
        // col 2
        t2[0] = p1sp3_0 + p2[1] - p4[1];
        t2[1] = p1sp3_1 - p2[0] + p4[0];
 8027ca6:	ee3a aa06 	vadd.f32	s20, s20, s12
        // col 4
        t4[0] = p1sp3_0 - p2[1] + p4[1];
        t4[1] = p1sp3_1 + p2[0] - p4[0];
        // col 1 - top
        *p1++ = p1ap3_0 + p2[0] + p4[0];
        *p1++ = p1ap3_1 + p2[1] + p4[1];
 8027caa:	ed45 7a01 	vstr	s15, [r5, #-4]

        // BOTTOM
        p1ap3_1 = pEnd1[-1] + pEnd3[-1];
        p1sp3_1 = pEnd1[-1] - pEnd3[-1];
        p1ap3_0 = pEnd1[0] + pEnd3[0];
 8027cae:	ed96 2a00 	vldr	s4, [r6]
 8027cb2:	ed97 1a00 	vldr	s2, [r7]
        p1sp3_0 = pEnd1[0] - pEnd3[0];
        // col 2
        t2[2] = pEnd2[0]  - pEnd4[0] + p1sp3_1;
 8027cb6:	edd2 7a02 	vldr	s15, [r2, #8]
 8027cba:	ed93 7a02 	vldr	s14, [r3, #8]
        t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
 8027cbe:	edd3 2a01 	vldr	s5, [r3, #4]
        // col 1 - top
        *p1++ = p1ap3_0 + p2[0] + p4[0];
        *p1++ = p1ap3_1 + p2[1] + p4[1];

        // BOTTOM
        p1ap3_1 = pEnd1[-1] + pEnd3[-1];
 8027cc2:	ed56 1a01 	vldr	s3, [r6, #-4]
        p1sp3_1 = pEnd1[-1] - pEnd3[-1];
        p1ap3_0 = pEnd1[0] + pEnd3[0];
        p1sp3_0 = pEnd1[0] - pEnd3[0];
        // col 2
        t2[2] = pEnd2[0]  - pEnd4[0] + p1sp3_1;
        t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
 8027cc6:	ed92 3a01 	vldr	s6, [r2, #4]
        // col 1 - top
        *p1++ = p1ap3_0 + p2[0] + p4[0];
        *p1++ = p1ap3_1 + p2[1] + p4[1];

        // BOTTOM
        p1ap3_1 = pEnd1[-1] + pEnd3[-1];
 8027cca:	ed57 9a01 	vldr	s19, [r7, #-4]
        p1sp3_1 = pEnd1[-1] - pEnd3[-1];
        p1ap3_0 = pEnd1[0] + pEnd3[0];
 8027cce:	ee71 6a02 	vadd.f32	s13, s2, s4
        // col 1 - top
        *p1++ = p1ap3_0 + p2[0] + p4[0];
        *p1++ = p1ap3_1 + p2[1] + p4[1];

        // BOTTOM
        p1ap3_1 = pEnd1[-1] + pEnd3[-1];
 8027cd2:	ee79 0aa1 	vadd.f32	s1, s19, s3
        t3[3] = p1ap3_0 - pEnd2[0]  - pEnd4[0];
        // col 4
        t4[2] = pEnd2[0]  - pEnd4[0]  - p1sp3_1;
        t4[3] = pEnd4[-1] - pEnd2[-1] - p1sp3_0;
        // col 1 - Bottom
        *pEnd1-- = p1ap3_0 + pEnd2[0] + pEnd4[0];
 8027cd6:	ee76 8aa7 	vadd.f32	s17, s13, s15

        // BOTTOM
        p1ap3_1 = pEnd1[-1] + pEnd3[-1];
        p1sp3_1 = pEnd1[-1] - pEnd3[-1];
        p1ap3_0 = pEnd1[0] + pEnd3[0];
        p1sp3_0 = pEnd1[0] - pEnd3[0];
 8027cda:	ee31 2a42 	vsub.f32	s4, s2, s4
        t3[3] = p1ap3_0 - pEnd2[0]  - pEnd4[0];
        // col 4
        t4[2] = pEnd2[0]  - pEnd4[0]  - p1sp3_1;
        t4[3] = pEnd4[-1] - pEnd2[-1] - p1sp3_0;
        // col 1 - Bottom
        *pEnd1-- = p1ap3_0 + pEnd2[0] + pEnd4[0];
 8027cde:	ee77 8a28 	vadd.f32	s17, s14, s17
        p1ap3_0 = p1[0] + p3[0];
        p1sp3_0 = p1[0] - p3[0];
        p1ap3_1 = p1[1] + p3[1];
        p1sp3_1 = p1[1] - p3[1];
        // col 2
        t2[0] = p1sp3_0 + p2[1] - p4[1];
 8027ce2:	ee74 aa23 	vadd.f32	s21, s8, s7
        t3[3] = p1ap3_0 - pEnd2[0]  - pEnd4[0];
        // col 4
        t4[2] = pEnd2[0]  - pEnd4[0]  - p1sp3_1;
        t4[3] = pEnd4[-1] - pEnd2[-1] - p1sp3_0;
        // col 1 - Bottom
        *pEnd1-- = p1ap3_0 + pEnd2[0] + pEnd4[0];
 8027ce6:	ee18 ca90 	vmov	ip, s17
 8027cea:	f847 c908 	str.w	ip, [r7], #-8
        *pEnd1-- = p1ap3_1 + pEnd2[-1] + pEnd4[-1];
 8027cee:	edd2 8a01 	vldr	s17, [r2, #4]
 8027cf2:	ed93 9a01 	vldr	s18, [r3, #4]
 8027cf6:	ee70 8aa8 	vadd.f32	s17, s1, s17
        p1ap3_1 = pEnd1[-1] + pEnd3[-1];
        p1sp3_1 = pEnd1[-1] - pEnd3[-1];
        p1ap3_0 = pEnd1[0] + pEnd3[0];
        p1sp3_0 = pEnd1[0] - pEnd3[0];
        // col 2
        t2[2] = pEnd2[0]  - pEnd4[0] + p1sp3_1;
 8027cfa:	ee37 1ac7 	vsub.f32	s2, s15, s14
        // col 4
        t4[2] = pEnd2[0]  - pEnd4[0]  - p1sp3_1;
        t4[3] = pEnd4[-1] - pEnd2[-1] - p1sp3_0;
        // col 1 - Bottom
        *pEnd1-- = p1ap3_0 + pEnd2[0] + pEnd4[0];
        *pEnd1-- = p1ap3_1 + pEnd2[-1] + pEnd4[-1];
 8027cfe:	ee78 8a89 	vadd.f32	s17, s17, s18
        p1ap3_0 = p1[0] + p3[0];
        p1sp3_0 = p1[0] - p3[0];
        p1ap3_1 = p1[1] + p3[1];
        p1sp3_1 = p1[1] - p3[1];
        // col 2
        t2[0] = p1sp3_0 + p2[1] - p4[1];
 8027d02:	ee7a aae4 	vsub.f32	s21, s21, s9
        // col 4
        t4[2] = pEnd2[0]  - pEnd4[0]  - p1sp3_1;
        t4[3] = pEnd4[-1] - pEnd2[-1] - p1sp3_0;
        // col 1 - Bottom
        *pEnd1-- = p1ap3_0 + pEnd2[0] + pEnd4[0];
        *pEnd1-- = p1ap3_1 + pEnd2[-1] + pEnd4[-1];
 8027d06:	edc7 8a01 	vstr	s17, [r7, #4]

        // COL 2
        // read twiddle factors
        twR = *tw2++;
        twI = *tw2++;
 8027d0a:	ed5a 8a01 	vldr	s17, [sl, #-4]
        *p1++ = p1ap3_0 + p2[0] + p4[0];
        *p1++ = p1ap3_1 + p2[1] + p4[1];

        // BOTTOM
        p1ap3_1 = pEnd1[-1] + pEnd3[-1];
        p1sp3_1 = pEnd1[-1] - pEnd3[-1];
 8027d0e:	ee79 1ae1 	vsub.f32	s3, s19, s3
        //  let    Z1 = a + i(b),   Z2 = c + i(d)
        //   =>  Z1 * Z2  =  (a*c - b*d) + i(b*c + a*d)

        // Top
        m0 = t2[0] * twR;
        m1 = t2[1] * twI;
 8027d12:	ee2a ca28 	vmul.f32	s24, s20, s17
        *pEnd1-- = p1ap3_0 + pEnd2[0] + pEnd4[0];
        *pEnd1-- = p1ap3_1 + pEnd2[-1] + pEnd4[-1];

        // COL 2
        // read twiddle factors
        twR = *tw2++;
 8027d16:	ed5a 9a02 	vldr	s19, [sl, #-8]
        p1sp3_1 = pEnd1[-1] - pEnd3[-1];
        p1ap3_0 = pEnd1[0] + pEnd3[0];
        p1sp3_0 = pEnd1[0] - pEnd3[0];
        // col 2
        t2[2] = pEnd2[0]  - pEnd4[0] + p1sp3_1;
        t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
 8027d1a:	ee32 9a43 	vsub.f32	s18, s4, s6
        m0 = t2[0] * twR;
        m1 = t2[1] * twI;
        m2 = t2[1] * twR;
        m3 = t2[0] * twI;

        *p2++ = m0 + m1;
 8027d1e:	eeaa caa9 	vfma.f32	s24, s21, s19

    tw2 += twMod2;
    tw3 += twMod3;
    tw4 += twMod4;

    for (l = (L - 2) >> 1; l > 0; l-- )
 8027d22:	f1bb 0b01 	subs.w	fp, fp, #1
 8027d26:	f105 0508 	add.w	r5, r5, #8
        p1sp3_1 = pEnd1[-1] - pEnd3[-1];
        p1ap3_0 = pEnd1[0] + pEnd3[0];
        p1sp3_0 = pEnd1[0] - pEnd3[0];
        // col 2
        t2[2] = pEnd2[0]  - pEnd4[0] + p1sp3_1;
        t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
 8027d2a:	ee39 9a22 	vadd.f32	s18, s18, s5
        p1ap3_1 = pEnd1[-1] + pEnd3[-1];
        p1sp3_1 = pEnd1[-1] - pEnd3[-1];
        p1ap3_0 = pEnd1[0] + pEnd3[0];
        p1sp3_0 = pEnd1[0] - pEnd3[0];
        // col 2
        t2[2] = pEnd2[0]  - pEnd4[0] + p1sp3_1;
 8027d2e:	ee71 ca21 	vadd.f32	s25, s2, s3
 8027d32:	ee68 baea 	vnmul.f32	s23, s17, s21
 8027d36:	ee29 baec 	vnmul.f32	s22, s19, s25
        // 0.9997 - 0.0245i  <==>  0.0245 - 0.9997i
        // Bottom
        m0 = t2[3] * twI;
        m1 = t2[2] * twR;
        m2 = t2[2] * twI;
        m3 = t2[3] * twR;
 8027d3a:	ee69 aa29 	vmul.f32	s21, s18, s19

        *pEnd2-- = m0 - m1;
 8027d3e:	eea9 ba28 	vfma.f32	s22, s18, s17
 8027d42:	f10a 0a08 	add.w	sl, sl, #8
 8027d46:	f1a2 0208 	sub.w	r2, r2, #8
        m1 = t2[1] * twI;
        m2 = t2[1] * twR;
        m3 = t2[0] * twI;

        *p2++ = m0 + m1;
        *p2++ = m2 - m3;
 8027d4a:	eeea ba29 	vfma.f32	s23, s20, s19
 8027d4e:	f109 0910 	add.w	r9, r9, #16
 8027d52:	f104 0408 	add.w	r4, r4, #8
        m0 = t2[0] * twR;
        m1 = t2[1] * twI;
        m2 = t2[1] * twR;
        m3 = t2[0] * twI;

        *p2++ = m0 + m1;
 8027d56:	ee1c ca10 	vmov	ip, s24
        m1 = t2[2] * twR;
        m2 = t2[2] * twI;
        m3 = t2[3] * twR;

        *pEnd2-- = m0 - m1;
        *pEnd2-- = m2 + m3;
 8027d5a:	eeec aaa8 	vfma.f32	s21, s25, s17
        m0 = t2[0] * twR;
        m1 = t2[1] * twI;
        m2 = t2[1] * twR;
        m3 = t2[0] * twI;

        *p2++ = m0 + m1;
 8027d5e:	f841 cb08 	str.w	ip, [r1], #8
        p1sp3_0 = pEnd1[0] - pEnd3[0];
        // col 2
        t2[2] = pEnd2[0]  - pEnd4[0] + p1sp3_1;
        t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
        // col 3
        t3[2] = p1ap3_1 - pEnd2[-1] - pEnd4[-1];
 8027d62:	ee70 0ac3 	vsub.f32	s1, s1, s6
        m1 = t2[1] * twI;
        m2 = t2[1] * twR;
        m3 = t2[0] * twI;

        *p2++ = m0 + m1;
        *p2++ = m2 - m3;
 8027d66:	ed41 ba01 	vstr	s23, [r1, #-4]
        m0 = t2[3] * twI;
        m1 = t2[2] * twR;
        m2 = t2[2] * twI;
        m3 = t2[3] * twR;

        *pEnd2-- = m0 - m1;
 8027d6a:	ed82 ba04 	vstr	s22, [r2, #16]
        *pEnd2-- = m2 + m3;
 8027d6e:	edc2 aa03 	vstr	s21, [r2, #12]
        // col 2
        t2[2] = pEnd2[0]  - pEnd4[0] + p1sp3_1;
        t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
        // col 3
        t3[2] = p1ap3_1 - pEnd2[-1] - pEnd4[-1];
        t3[3] = p1ap3_0 - pEnd2[0]  - pEnd4[0];
 8027d72:	ee76 6ae7 	vsub.f32	s13, s13, s15
        p1sp3_1 = p1[1] - p3[1];
        // col 2
        t2[0] = p1sp3_0 + p2[1] - p4[1];
        t2[1] = p1sp3_1 - p2[0] + p4[0];
        // col 3
        t3[0] = p1ap3_0 - p2[0] - p4[0];
 8027d76:	ee30 0a65 	vsub.f32	s0, s0, s11
        *pEnd2-- = m0 - m1;
        *pEnd2-- = m2 + m3;

        // COL 3
        twR = tw3[0];
        twI = tw3[1];
 8027d7a:	ed59 7a07 	vldr	s15, [r9, #-28]	; 0xffffffe4

        *pEnd2-- = m0 - m1;
        *pEnd2-- = m2 + m3;

        // COL 3
        twR = tw3[0];
 8027d7e:	ed59 8a08 	vldr	s17, [r9, #-32]	; 0xffffffe0
        // col 2
        t2[0] = p1sp3_0 + p2[1] - p4[1];
        t2[1] = p1sp3_1 - p2[0] + p4[0];
        // col 3
        t3[0] = p1ap3_0 - p2[0] - p4[0];
        t3[1] = p1ap3_1 - p2[1] - p4[1];
 8027d82:	ee38 8a44 	vsub.f32	s16, s16, s8
        p1sp3_0 = pEnd1[0] - pEnd3[0];
        // col 2
        t2[2] = pEnd2[0]  - pEnd4[0] + p1sp3_1;
        t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
        // col 3
        t3[2] = p1ap3_1 - pEnd2[-1] - pEnd4[-1];
 8027d86:	ee70 0ae2 	vsub.f32	s1, s1, s5
        t3[3] = p1ap3_0 - pEnd2[0]  - pEnd4[0];
 8027d8a:	ee36 7ac7 	vsub.f32	s14, s13, s14
        p1sp3_1 = p1[1] - p3[1];
        // col 2
        t2[0] = p1sp3_0 + p2[1] - p4[1];
        t2[1] = p1sp3_1 - p2[0] + p4[0];
        // col 3
        t3[0] = p1ap3_0 - p2[0] - p4[0];
 8027d8e:	ee30 0a46 	vsub.f32	s0, s0, s12
        t3[1] = p1ap3_1 - p2[1] - p4[1];
 8027d92:	ee38 8a64 	vsub.f32	s16, s16, s9
 8027d96:	ee67 6ae0 	vnmul.f32	s13, s15, s1
        twR = tw3[0];
        twI = tw3[1];
        tw3 += twMod3;
        // Top
        m0 = t3[0] * twR;
        m1 = t3[1] * twI;
 8027d9a:	ee68 9a27 	vmul.f32	s19, s16, s15
        m0 = -t3[3] * twR;
        m1 = t3[2] * twI;
        m2 = t3[2] * twR;
        m3 = t3[3] * twI;

        *pEnd3-- = m0 - m1;
 8027d9e:	eee7 6a68 	vfms.f32	s13, s14, s17
 8027da2:	f10e 0e18 	add.w	lr, lr, #24
 8027da6:	f1a3 0308 	sub.w	r3, r3, #8
 8027daa:	ee27 9ac0 	vnmul.f32	s18, s15, s0
        m0 = t3[0] * twR;
        m1 = t3[1] * twI;
        m2 = t3[1] * twR;
        m3 = t3[0] * twI;

        *p3++ = m0 + m1;
 8027dae:	eee0 9a28 	vfma.f32	s19, s0, s17
        // 0.9988 - 0.0491i  <==>  -0.9988 - 0.0491i
        // Bottom
        m0 = -t3[3] * twR;
        m1 = t3[2] * twI;
        m2 = t3[2] * twR;
        m3 = t3[3] * twI;
 8027db2:	ee67 7a27 	vmul.f32	s15, s14, s15
        m1 = t3[1] * twI;
        m2 = t3[1] * twR;
        m3 = t3[0] * twI;

        *p3++ = m0 + m1;
        *p3++ = m2 - m3;
 8027db6:	eea8 9a28 	vfma.f32	s18, s16, s17
        m0 = -t3[3] * twR;
        m1 = t3[2] * twI;
        m2 = t3[2] * twR;
        m3 = t3[3] * twI;

        *pEnd3-- = m0 - m1;
 8027dba:	ee16 ca90 	vmov	ip, s13
        *pEnd3-- = m3 - m2;
 8027dbe:	eee0 7ae8 	vfms.f32	s15, s1, s17
        m0 = t3[0] * twR;
        m1 = t3[1] * twI;
        m2 = t3[1] * twR;
        m3 = t3[0] * twI;

        *p3++ = m0 + m1;
 8027dc2:	ed44 9a04 	vstr	s19, [r4, #-16]
        *p3++ = m2 - m3;
 8027dc6:	ed04 9a03 	vstr	s18, [r4, #-12]
        m0 = -t3[3] * twR;
        m1 = t3[2] * twI;
        m2 = t3[2] * twR;
        m3 = t3[3] * twI;

        *pEnd3-- = m0 - m1;
 8027dca:	f846 c908 	str.w	ip, [r6], #-8
        // col 3
        t3[0] = p1ap3_0 - p2[0] - p4[0];
        t3[1] = p1ap3_1 - p2[1] - p4[1];
        // col 4
        t4[0] = p1sp3_0 - p2[1] + p4[1];
        t4[1] = p1sp3_1 + p2[0] - p4[0];
 8027dce:	ee75 5a25 	vadd.f32	s11, s10, s11
        m1 = t3[2] * twI;
        m2 = t3[2] * twR;
        m3 = t3[3] * twI;

        *pEnd3-- = m0 - m1;
        *pEnd3-- = m3 - m2;
 8027dd2:	edc6 7a01 	vstr	s15, [r6, #4]

        // COL 4
        twR = tw4[0];
        twI = tw4[1];
 8027dd6:	ed5e 6a0b 	vldr	s13, [lr, #-44]	; 0xffffffd4
        // col 3
        t3[0] = p1ap3_0 - p2[0] - p4[0];
        t3[1] = p1ap3_1 - p2[1] - p4[1];
        // col 4
        t4[0] = p1sp3_0 - p2[1] + p4[1];
        t4[1] = p1sp3_1 + p2[0] - p4[0];
 8027dda:	ee35 6ac6 	vsub.f32	s12, s11, s12
        t2[1] = p1sp3_1 - p2[0] + p4[0];
        // col 3
        t3[0] = p1ap3_0 - p2[0] - p4[0];
        t3[1] = p1ap3_1 - p2[1] - p4[1];
        // col 4
        t4[0] = p1sp3_0 - p2[1] + p4[1];
 8027dde:	ee33 4ac4 	vsub.f32	s8, s7, s8
        // col 3
        t3[2] = p1ap3_1 - pEnd2[-1] - pEnd4[-1];
        t3[3] = p1ap3_0 - pEnd2[0]  - pEnd4[0];
        // col 4
        t4[2] = pEnd2[0]  - pEnd4[0]  - p1sp3_1;
        t4[3] = pEnd4[-1] - pEnd2[-1] - p1sp3_0;
 8027de2:	ee72 7ac3 	vsub.f32	s15, s5, s6

        *pEnd3-- = m0 - m1;
        *pEnd3-- = m3 - m2;

        // COL 4
        twR = tw4[0];
 8027de6:	ed5e 5a0c 	vldr	s11, [lr, #-48]	; 0xffffffd0
        t2[1] = p1sp3_1 - p2[0] + p4[0];
        // col 3
        t3[0] = p1ap3_0 - p2[0] - p4[0];
        t3[1] = p1ap3_1 - p2[1] - p4[1];
        // col 4
        t4[0] = p1sp3_0 - p2[1] + p4[1];
 8027dea:	ee74 4a84 	vadd.f32	s9, s9, s8
        t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
        // col 3
        t3[2] = p1ap3_1 - pEnd2[-1] - pEnd4[-1];
        t3[3] = p1ap3_0 - pEnd2[0]  - pEnd4[0];
        // col 4
        t4[2] = pEnd2[0]  - pEnd4[0]  - p1sp3_1;
 8027dee:	ee31 7a61 	vsub.f32	s14, s2, s3
        twR = tw4[0];
        twI = tw4[1];
        tw4 += twMod4;
        // Top
        m0 = t4[0] * twR;
        m1 = t4[1] * twI;
 8027df2:	ee66 3a26 	vmul.f32	s7, s12, s13
        // col 3
        t3[2] = p1ap3_1 - pEnd2[-1] - pEnd4[-1];
        t3[3] = p1ap3_0 - pEnd2[0]  - pEnd4[0];
        // col 4
        t4[2] = pEnd2[0]  - pEnd4[0]  - p1sp3_1;
        t4[3] = pEnd4[-1] - pEnd2[-1] - p1sp3_0;
 8027df6:	ee77 7ac2 	vsub.f32	s15, s15, s4
 8027dfa:	ee26 4ae4 	vnmul.f32	s8, s13, s9
        m0 = t4[0] * twR;
        m1 = t4[1] * twI;
        m2 = t4[1] * twR;
        m3 = t4[0] * twI;

        *p4++ = m0 + m1;
 8027dfe:	eee4 3aa5 	vfma.f32	s7, s9, s11
 8027e02:	ee65 4ac7 	vnmul.f32	s9, s11, s14
        // 0.9973 - 0.0736i  <==>  -0.0736 + 0.9973i
        // Bottom
        m0 = t4[3] * twI;
        m1 = t4[2] * twR;
        m2 = t4[2] * twI;
        m3 = t4[3] * twR;
 8027e06:	ee27 5aa5 	vmul.f32	s10, s15, s11
        m1 = t4[1] * twI;
        m2 = t4[1] * twR;
        m3 = t4[0] * twI;

        *p4++ = m0 + m1;
        *p4++ = m2 - m3;
 8027e0a:	eea6 4a25 	vfma.f32	s8, s12, s11
        m0 = t4[3] * twI;
        m1 = t4[2] * twR;
        m2 = t4[2] * twI;
        m3 = t4[3] * twR;

        *pEnd4-- = m0 - m1;
 8027e0e:	eeb0 6a64 	vmov.f32	s12, s9
 8027e12:	eea7 6aa6 	vfma.f32	s12, s15, s13
        *pEnd4-- = m2 + m3;
 8027e16:	eef0 7a45 	vmov.f32	s15, s10
        m0 = t4[0] * twR;
        m1 = t4[1] * twI;
        m2 = t4[1] * twR;
        m3 = t4[0] * twI;

        *p4++ = m0 + m1;
 8027e1a:	ee13 ca90 	vmov	ip, s7
        m1 = t4[2] * twR;
        m2 = t4[2] * twI;
        m3 = t4[3] * twR;

        *pEnd4-- = m0 - m1;
        *pEnd4-- = m2 + m3;
 8027e1e:	eee7 7a26 	vfma.f32	s15, s14, s13
        m0 = t4[0] * twR;
        m1 = t4[1] * twI;
        m2 = t4[1] * twR;
        m3 = t4[0] * twI;

        *p4++ = m0 + m1;
 8027e22:	f840 cb08 	str.w	ip, [r0], #8
        *p4++ = m2 - m3;
 8027e26:	ed00 4a01 	vstr	s8, [r0, #-4]
        m0 = t4[3] * twI;
        m1 = t4[2] * twR;
        m2 = t4[2] * twI;
        m3 = t4[3] * twR;

        *pEnd4-- = m0 - m1;
 8027e2a:	ed83 6a04 	vstr	s12, [r3, #16]
        *pEnd4-- = m2 + m3;
 8027e2e:	edc3 7a03 	vstr	s15, [r3, #12]

    tw2 += twMod2;
    tw3 += twMod3;
    tw4 += twMod4;

    for (l = (L - 2) >> 1; l > 0; l-- )
 8027e32:	f47f af10 	bne.w	8027c56 <arm_cfft_radix8by4_f32+0x142>
 8027e36:	9907      	ldr	r1, [sp, #28]
 8027e38:	9802      	ldr	r0, [sp, #8]
 8027e3a:	f8dd c034 	ldr.w	ip, [sp, #52]	; 0x34
 8027e3e:	00cb      	lsls	r3, r1, #3
 8027e40:	eb01 0241 	add.w	r2, r1, r1, lsl #1
 8027e44:	eb00 1101 	add.w	r1, r0, r1, lsl #4
 8027e48:	9102      	str	r1, [sp, #8]
 8027e4a:	9903      	ldr	r1, [sp, #12]
 8027e4c:	4419      	add	r1, r3
 8027e4e:	9103      	str	r1, [sp, #12]
 8027e50:	9904      	ldr	r1, [sp, #16]
 8027e52:	4419      	add	r1, r3
 8027e54:	9104      	str	r1, [sp, #16]
 8027e56:	9906      	ldr	r1, [sp, #24]
 8027e58:	4498      	add	r8, r3
 8027e5a:	4419      	add	r1, r3
 8027e5c:	449c      	add	ip, r3
 8027e5e:	9b05      	ldr	r3, [sp, #20]
 8027e60:	9106      	str	r1, [sp, #24]
 8027e62:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8027e66:	9305      	str	r3, [sp, #20]
    }

    //MIDDLE
    // Twiddle factors are
    //  1.0000  0.7071-0.7071i  -1.0000i  -0.7071-0.7071i
    p1ap3_0 = p1[0] + p3[0];
 8027e68:	9a03      	ldr	r2, [sp, #12]
 8027e6a:	9e06      	ldr	r6, [sp, #24]
 8027e6c:	ed92 3a00 	vldr	s6, [r2]
 8027e70:	edd6 6a00 	vldr	s13, [r6]
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8027e74:	edd8 7a00 	vldr	s15, [r8]
 8027e78:	ed9c 4a00 	vldr	s8, [ip]
    //MIDDLE
    // Twiddle factors are
    //  1.0000  0.7071-0.7071i  -1.0000i  -0.7071-0.7071i
    p1ap3_0 = p1[0] + p3[0];
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
 8027e7c:	ed96 7a01 	vldr	s14, [r6, #4]
 8027e80:	edd2 3a01 	vldr	s7, [r2, #4]
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8027e84:	edd8 2a01 	vldr	s5, [r8, #4]
 8027e88:	eddc 4a01 	vldr	s9, [ip, #4]

    *p2++ = m0 + m1;
    *p2++ = m2 - m3;
    // COL 3
    twR = tw3[0];
    twI = tw3[1];
 8027e8c:	9d02      	ldr	r5, [sp, #8]

    *p4++ = m0 + m1;
    *p4++ = m2 - m3;

    // first col
    arm_radix8_butterfly_f32( pCol1, L, (float32_t *) S->pTwiddle, 4u);
 8027e8e:	f8bd 4028 	ldrh.w	r4, [sp, #40]	; 0x28
 8027e92:	980c      	ldr	r0, [sp, #48]	; 0x30
    }

    //MIDDLE
    // Twiddle factors are
    //  1.0000  0.7071-0.7071i  -1.0000i  -0.7071-0.7071i
    p1ap3_0 = p1[0] + p3[0];
 8027e94:	ee73 5a26 	vadd.f32	s11, s6, s13
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
 8027e98:	ee33 6a87 	vadd.f32	s12, s7, s14
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1 - Top
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8027e9c:	ee35 5aa7 	vadd.f32	s10, s11, s15

    //MIDDLE
    // Twiddle factors are
    //  1.0000  0.7071-0.7071i  -1.0000i  -0.7071-0.7071i
    p1ap3_0 = p1[0] + p3[0];
    p1sp3_0 = p1[0] - p3[0];
 8027ea0:	ee73 6a66 	vsub.f32	s13, s6, s13
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1 - Top
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8027ea4:	ee34 5a05 	vadd.f32	s10, s8, s10
    // Twiddle factors are
    //  1.0000  0.7071-0.7071i  -1.0000i  -0.7071-0.7071i
    p1ap3_0 = p1[0] + p3[0];
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];
 8027ea8:	ee33 7ac7 	vsub.f32	s14, s7, s14
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1 - Top
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8027eac:	ed82 5a00 	vstr	s10, [r2]
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8027eb0:	ed98 5a01 	vldr	s10, [r8, #4]
 8027eb4:	ed9c 3a01 	vldr	s6, [ip, #4]
 8027eb8:	ee36 5a05 	vadd.f32	s10, s12, s10
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8027ebc:	ee77 3a67 	vsub.f32	s7, s14, s15
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1 - Top
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8027ec0:	ee35 5a03 	vadd.f32	s10, s10, s6
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8027ec4:	ee32 3aa6 	vadd.f32	s6, s5, s13
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1 - Top
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8027ec8:	ed82 5a01 	vstr	s10, [r2, #4]

    // COL 2
    twR = tw2[0];
    twI = tw2[1];
 8027ecc:	9a04      	ldr	r2, [sp, #16]
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8027ece:	ee73 3a84 	vadd.f32	s7, s7, s8
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];

    // COL 2
    twR = tw2[0];
    twI = tw2[1];
 8027ed2:	ed92 5a01 	vldr	s10, [r2, #4]
    // col 1 - Top
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];

    // COL 2
    twR = tw2[0];
 8027ed6:	edd2 1a00 	vldr	s3, [r2]

    *p4++ = m0 + m1;
    *p4++ = m2 - m3;

    // first col
    arm_radix8_butterfly_f32( pCol1, L, (float32_t *) S->pTwiddle, 4u);
 8027eda:	9a01      	ldr	r2, [sp, #4]
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8027edc:	ee33 3a64 	vsub.f32	s6, s6, s9
    // COL 2
    twR = tw2[0];
    twI = tw2[1];

    m0 = t2[0] * twR;
    m1 = t2[1] * twI;
 8027ee0:	ee23 2a85 	vmul.f32	s4, s7, s10
 8027ee4:	ee25 5a43 	vnmul.f32	s10, s10, s6
    m2 = t2[1] * twR;
    m3 = t2[0] * twI;

    *p2++ = m0 + m1;
 8027ee8:	eea3 2a21 	vfma.f32	s4, s6, s3

    *p4++ = m0 + m1;
    *p4++ = m2 - m3;

    // first col
    arm_radix8_butterfly_f32( pCol1, L, (float32_t *) S->pTwiddle, 4u);
 8027eec:	4621      	mov	r1, r4
 8027eee:	2304      	movs	r3, #4
    m1 = t2[1] * twI;
    m2 = t2[1] * twR;
    m3 = t2[0] * twI;

    *p2++ = m0 + m1;
    *p2++ = m2 - m3;
 8027ef0:	eea3 5aa1 	vfma.f32	s10, s7, s3
    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
    t3[1] = p1ap3_1 - p2[1] - p4[1];
 8027ef4:	ee36 6a62 	vsub.f32	s12, s12, s5

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
 8027ef8:	ee75 5ae7 	vsub.f32	s11, s11, s15
    m0 = t2[0] * twR;
    m1 = t2[1] * twI;
    m2 = t2[1] * twR;
    m3 = t2[0] * twI;

    *p2++ = m0 + m1;
 8027efc:	ed88 2a00 	vstr	s4, [r8]
    *p2++ = m2 - m3;
 8027f00:	ed88 5a01 	vstr	s10, [r8, #4]

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
 8027f04:	ee75 5ac4 	vsub.f32	s11, s11, s8
    t3[1] = p1ap3_1 - p2[1] - p4[1];
 8027f08:	ee36 6a64 	vsub.f32	s12, s12, s9

    *p2++ = m0 + m1;
    *p2++ = m2 - m3;
    // COL 3
    twR = tw3[0];
    twI = tw3[1];
 8027f0c:	ed95 5a01 	vldr	s10, [r5, #4]
    m3 = t2[0] * twI;

    *p2++ = m0 + m1;
    *p2++ = m2 - m3;
    // COL 3
    twR = tw3[0];
 8027f10:	ed95 3a00 	vldr	s6, [r5]
    twI = tw3[1];

    m0 = t3[0] * twR;
    m1 = t3[1] * twI;
 8027f14:	ee66 3a05 	vmul.f32	s7, s12, s10
 8027f18:	ee25 5a65 	vnmul.f32	s10, s10, s11
    m2 = t3[1] * twR;
    m3 = t3[0] * twI;

    *p3++ = m0 + m1;
 8027f1c:	eee5 3a83 	vfma.f32	s7, s11, s6
 8027f20:	4635      	mov	r5, r6
    *p3++ = m2 - m3;
 8027f22:	eea6 5a03 	vfma.f32	s10, s12, s6
    m0 = t3[0] * twR;
    m1 = t3[1] * twI;
    m2 = t3[1] * twR;
    m3 = t3[0] * twI;

    *p3++ = m0 + m1;
 8027f26:	edc5 3a00 	vstr	s7, [r5]
    t2[1] = p1sp3_1 - p2[0] + p4[0];
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
 8027f2a:	ee76 6ae2 	vsub.f32	s13, s13, s5
    m1 = t3[1] * twI;
    m2 = t3[1] * twR;
    m3 = t3[0] * twI;

    *p3++ = m0 + m1;
    *p3++ = m2 - m3;
 8027f2e:	ed86 5a01 	vstr	s10, [r6, #4]
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
 8027f32:	ee37 7a27 	vadd.f32	s14, s14, s15

    *p3++ = m0 + m1;
    *p3++ = m2 - m3;
    // COL 4
    twR = tw4[0];
    twI = tw4[1];
 8027f36:	9e05      	ldr	r6, [sp, #20]
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
 8027f38:	ee77 7a44 	vsub.f32	s15, s14, s8
    t2[1] = p1sp3_1 - p2[0] + p4[0];
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
 8027f3c:	ee74 6aa6 	vadd.f32	s13, s9, s13

    *p3++ = m0 + m1;
    *p3++ = m2 - m3;
    // COL 4
    twR = tw4[0];
    twI = tw4[1];
 8027f40:	ed96 7a01 	vldr	s14, [r6, #4]
    m3 = t3[0] * twI;

    *p3++ = m0 + m1;
    *p3++ = m2 - m3;
    // COL 4
    twR = tw4[0];
 8027f44:	edd6 5a00 	vldr	s11, [r6]
    twI = tw4[1];

    m0 = t4[0] * twR;
    m1 = t4[1] * twI;
 8027f48:	ee27 6a87 	vmul.f32	s12, s15, s14
 8027f4c:	ee27 7a66 	vnmul.f32	s14, s14, s13
    m2 = t4[1] * twR;
    m3 = t4[0] * twI;

    *p4++ = m0 + m1;
 8027f50:	eea6 6aa5 	vfma.f32	s12, s13, s11
    *p4++ = m2 - m3;
 8027f54:	eea7 7aa5 	vfma.f32	s14, s15, s11
    m0 = t4[0] * twR;
    m1 = t4[1] * twI;
    m2 = t4[1] * twR;
    m3 = t4[0] * twI;

    *p4++ = m0 + m1;
 8027f58:	ed8c 6a00 	vstr	s12, [ip]
    *p4++ = m2 - m3;
 8027f5c:	ed8c 7a01 	vstr	s14, [ip, #4]

    // first col
    arm_radix8_butterfly_f32( pCol1, L, (float32_t *) S->pTwiddle, 4u);
 8027f60:	f000 f892 	bl	8028088 <arm_radix8_butterfly_f32>
    // second col
    arm_radix8_butterfly_f32( pCol2, L, (float32_t *) S->pTwiddle, 4u);
 8027f64:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8027f66:	9808      	ldr	r0, [sp, #32]
 8027f68:	686a      	ldr	r2, [r5, #4]
 8027f6a:	4621      	mov	r1, r4
 8027f6c:	2304      	movs	r3, #4
 8027f6e:	f000 f88b 	bl	8028088 <arm_radix8_butterfly_f32>
    // third col
    arm_radix8_butterfly_f32( pCol3, L, (float32_t *) S->pTwiddle, 4u);
 8027f72:	9809      	ldr	r0, [sp, #36]	; 0x24
 8027f74:	686a      	ldr	r2, [r5, #4]
 8027f76:	4621      	mov	r1, r4
 8027f78:	2304      	movs	r3, #4
 8027f7a:	f000 f885 	bl	8028088 <arm_radix8_butterfly_f32>
    // fourth col
    arm_radix8_butterfly_f32( pCol4, L, (float32_t *) S->pTwiddle, 4u);
 8027f7e:	9800      	ldr	r0, [sp, #0]
 8027f80:	686a      	ldr	r2, [r5, #4]
 8027f82:	4621      	mov	r1, r4
 8027f84:	2304      	movs	r3, #4
}
 8027f86:	b00f      	add	sp, #60	; 0x3c
 8027f88:	ecbd 8b0a 	vpop	{d8-d12}
 8027f8c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    // second col
    arm_radix8_butterfly_f32( pCol2, L, (float32_t *) S->pTwiddle, 4u);
    // third col
    arm_radix8_butterfly_f32( pCol3, L, (float32_t *) S->pTwiddle, 4u);
    // fourth col
    arm_radix8_butterfly_f32( pCol4, L, (float32_t *) S->pTwiddle, 4u);
 8027f90:	f000 b87a 	b.w	8028088 <arm_radix8_butterfly_f32>

08027f94 <arm_cfft_f32>:
    uint8_t bitReverseFlag)
{
    uint32_t  L = S->fftLen, l;
    float32_t invL, * pSrc;

    if (ifftFlag == 1u)
 8027f94:	2a01      	cmp	r2, #1
void arm_cfft_f32(
    const arm_cfft_instance_f32 * S,
    float32_t * p1,
    uint8_t ifftFlag,
    uint8_t bitReverseFlag)
{
 8027f96:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8027f9a:	4606      	mov	r6, r0
 8027f9c:	4617      	mov	r7, r2
 8027f9e:	460c      	mov	r4, r1
 8027fa0:	4698      	mov	r8, r3
    uint32_t  L = S->fftLen, l;
 8027fa2:	8805      	ldrh	r5, [r0, #0]
    float32_t invL, * pSrc;

    if (ifftFlag == 1u)
 8027fa4:	d054      	beq.n	8028050 <arm_cfft_f32+0xbc>
            *pSrc = -*pSrc;
            pSrc += 2;
        }
    }

    switch (L)
 8027fa6:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
 8027faa:	d04c      	beq.n	8028046 <arm_cfft_f32+0xb2>
 8027fac:	d916      	bls.n	8027fdc <arm_cfft_f32+0x48>
 8027fae:	f5b5 6f80 	cmp.w	r5, #1024	; 0x400
 8027fb2:	d01a      	beq.n	8027fea <arm_cfft_f32+0x56>
 8027fb4:	d95c      	bls.n	8028070 <arm_cfft_f32+0xdc>
 8027fb6:	f5b5 6f00 	cmp.w	r5, #2048	; 0x800
 8027fba:	d044      	beq.n	8028046 <arm_cfft_f32+0xb2>
 8027fbc:	f5b5 5f80 	cmp.w	r5, #4096	; 0x1000
 8027fc0:	d105      	bne.n	8027fce <arm_cfft_f32+0x3a>
        arm_cfft_radix8by4_f32  ( (arm_cfft_instance_f32 *) S, p1);
        break;
    case 64:
    case 512:
    case 4096:
        arm_radix8_butterfly_f32( p1, L, (float32_t *) S->pTwiddle, 1);
 8027fc2:	4620      	mov	r0, r4
 8027fc4:	4629      	mov	r1, r5
 8027fc6:	6872      	ldr	r2, [r6, #4]
 8027fc8:	2301      	movs	r3, #1
 8027fca:	f000 f85d 	bl	8028088 <arm_radix8_butterfly_f32>
        break;
    }

    if ( bitReverseFlag )
 8027fce:	f1b8 0f00 	cmp.w	r8, #0
 8027fd2:	d111      	bne.n	8027ff8 <arm_cfft_f32+0x64>
        arm_bitreversal_32((uint32_t*)p1,S->bitRevLength,S->pBitRevTable);

    if (ifftFlag == 1u)
 8027fd4:	2f01      	cmp	r7, #1
 8027fd6:	d016      	beq.n	8028006 <arm_cfft_f32+0x72>
 8027fd8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            *pSrc = -*pSrc;
            pSrc += 2;
        }
    }

    switch (L)
 8027fdc:	2d20      	cmp	r5, #32
 8027fde:	d032      	beq.n	8028046 <arm_cfft_f32+0xb2>
 8027fe0:	d94a      	bls.n	8028078 <arm_cfft_f32+0xe4>
 8027fe2:	2d40      	cmp	r5, #64	; 0x40
 8027fe4:	d0ed      	beq.n	8027fc2 <arm_cfft_f32+0x2e>
 8027fe6:	2d80      	cmp	r5, #128	; 0x80
 8027fe8:	d1f1      	bne.n	8027fce <arm_cfft_f32+0x3a>
    {
    case 16:
    case 128:
    case 1024:
        arm_cfft_radix8by2_f32  ( (arm_cfft_instance_f32 *) S, p1);
 8027fea:	4630      	mov	r0, r6
 8027fec:	4621      	mov	r1, r4
 8027fee:	f7ff fccf 	bl	8027990 <arm_cfft_radix8by2_f32>
    case 4096:
        arm_radix8_butterfly_f32( p1, L, (float32_t *) S->pTwiddle, 1);
        break;
    }

    if ( bitReverseFlag )
 8027ff2:	f1b8 0f00 	cmp.w	r8, #0
 8027ff6:	d0ed      	beq.n	8027fd4 <arm_cfft_f32+0x40>
        arm_bitreversal_32((uint32_t*)p1,S->bitRevLength,S->pBitRevTable);
 8027ff8:	4620      	mov	r0, r4
 8027ffa:	89b1      	ldrh	r1, [r6, #12]
 8027ffc:	68b2      	ldr	r2, [r6, #8]
 8027ffe:	f7ff fc67 	bl	80278d0 <arm_bitreversal_32>

    if (ifftFlag == 1u)
 8028002:	2f01      	cmp	r7, #1
 8028004:	d1e8      	bne.n	8027fd8 <arm_cfft_f32+0x44>
    {
        invL = 1.0f/(float32_t)L;
 8028006:	ee07 5a90 	vmov	s15, r5
 802800a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 802800e:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
 8028012:	eec7 6aa6 	vdiv.f32	s13, s15, s13
        /*  Conjugate and scale output data */
        pSrc = p1;
        for(l=0; l<L; l++)
 8028016:	2d00      	cmp	r5, #0
 8028018:	d0de      	beq.n	8027fd8 <arm_cfft_f32+0x44>
 802801a:	f104 0108 	add.w	r1, r4, #8
 802801e:	2300      	movs	r3, #0
 8028020:	3301      	adds	r3, #1
 8028022:	429d      	cmp	r5, r3
 8028024:	f101 0108 	add.w	r1, r1, #8
        {
            *pSrc++ *=   invL ;
 8028028:	ed11 7a04 	vldr	s14, [r1, #-16]
            *pSrc  = -(*pSrc) * invL;
 802802c:	ed51 7a03 	vldr	s15, [r1, #-12]
        invL = 1.0f/(float32_t)L;
        /*  Conjugate and scale output data */
        pSrc = p1;
        for(l=0; l<L; l++)
        {
            *pSrc++ *=   invL ;
 8028030:	ee27 7a26 	vmul.f32	s14, s14, s13
            *pSrc  = -(*pSrc) * invL;
 8028034:	ee67 7ae6 	vnmul.f32	s15, s15, s13
        invL = 1.0f/(float32_t)L;
        /*  Conjugate and scale output data */
        pSrc = p1;
        for(l=0; l<L; l++)
        {
            *pSrc++ *=   invL ;
 8028038:	ed01 7a04 	vstr	s14, [r1, #-16]
            *pSrc  = -(*pSrc) * invL;
 802803c:	ed41 7a03 	vstr	s15, [r1, #-12]
    if (ifftFlag == 1u)
    {
        invL = 1.0f/(float32_t)L;
        /*  Conjugate and scale output data */
        pSrc = p1;
        for(l=0; l<L; l++)
 8028040:	d1ee      	bne.n	8028020 <arm_cfft_f32+0x8c>
 8028042:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        arm_cfft_radix8by2_f32  ( (arm_cfft_instance_f32 *) S, p1);
        break;
    case 32:
    case 256:
    case 2048:
        arm_cfft_radix8by4_f32  ( (arm_cfft_instance_f32 *) S, p1);
 8028046:	4630      	mov	r0, r6
 8028048:	4621      	mov	r1, r4
 802804a:	f7ff fd63 	bl	8027b14 <arm_cfft_radix8by4_f32>
        break;
 802804e:	e7be      	b.n	8027fce <arm_cfft_f32+0x3a>

    if (ifftFlag == 1u)
    {
        /*  Conjugate input data  */
        pSrc = p1 + 1;
        for(l=0; l<L; l++)
 8028050:	b1ad      	cbz	r5, 802807e <arm_cfft_f32+0xea>
 8028052:	f101 030c 	add.w	r3, r1, #12
 8028056:	2200      	movs	r2, #0
        {
            *pSrc = -*pSrc;
 8028058:	ed53 7a02 	vldr	s15, [r3, #-8]

    if (ifftFlag == 1u)
    {
        /*  Conjugate input data  */
        pSrc = p1 + 1;
        for(l=0; l<L; l++)
 802805c:	3201      	adds	r2, #1
        {
            *pSrc = -*pSrc;
 802805e:	eef1 7a67 	vneg.f32	s15, s15

    if (ifftFlag == 1u)
    {
        /*  Conjugate input data  */
        pSrc = p1 + 1;
        for(l=0; l<L; l++)
 8028062:	4295      	cmp	r5, r2
        {
            *pSrc = -*pSrc;
 8028064:	ed43 7a02 	vstr	s15, [r3, #-8]
 8028068:	f103 0308 	add.w	r3, r3, #8

    if (ifftFlag == 1u)
    {
        /*  Conjugate input data  */
        pSrc = p1 + 1;
        for(l=0; l<L; l++)
 802806c:	d1f4      	bne.n	8028058 <arm_cfft_f32+0xc4>
 802806e:	e79a      	b.n	8027fa6 <arm_cfft_f32+0x12>
            *pSrc = -*pSrc;
            pSrc += 2;
        }
    }

    switch (L)
 8028070:	f5b5 7f00 	cmp.w	r5, #512	; 0x200
 8028074:	d0a5      	beq.n	8027fc2 <arm_cfft_f32+0x2e>
 8028076:	e7aa      	b.n	8027fce <arm_cfft_f32+0x3a>
 8028078:	2d10      	cmp	r5, #16
 802807a:	d0b6      	beq.n	8027fea <arm_cfft_f32+0x56>
 802807c:	e7a7      	b.n	8027fce <arm_cfft_f32+0x3a>
 802807e:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
 8028082:	d894      	bhi.n	8027fae <arm_cfft_f32+0x1a>
 8028084:	e7aa      	b.n	8027fdc <arm_cfft_f32+0x48>
 8028086:	bf00      	nop

08028088 <arm_radix8_butterfly_f32>:
void arm_radix8_butterfly_f32(
float32_t * pSrc,
uint16_t fftLen,
const float32_t * pCoef,
uint16_t twidCoefModifier)
{
 8028088:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802808c:	ed2d 8b10 	vpush	{d8-d15}
 8028090:	b09d      	sub	sp, #116	; 0x74
 8028092:	461c      	mov	r4, r3
         pSrc[2 * i7 + 1] = t2 + r3;
         r1 = (r6 - r8) * C81;
         r6 = (r6 + r8) * C81;
         r2 = (s6 - s8) * C81;
         s6 = (s6 + s8) * C81;
         t1 = r5 - r1;
 8028094:	eddf aac9 	vldr	s21, [pc, #804]	; 80283bc <arm_radix8_butterfly_f32+0x334>
void arm_radix8_butterfly_f32(
float32_t * pSrc,
uint16_t fftLen,
const float32_t * pCoef,
uint16_t twidCoefModifier)
{
 8028098:	921a      	str	r2, [sp, #104]	; 0x68
 802809a:	1d03      	adds	r3, r0, #4
 802809c:	4682      	mov	sl, r0
 802809e:	4689      	mov	r9, r1
   float32_t p1, p2, p3, p4;
   float32_t co2, co3, co4, co5, co6, co7, co8;
   float32_t si2, si3, si4, si5, si6, si7, si8;
   const float32_t C81 = 0.70710678118f;

   n2 = fftLen;
 80280a0:	468b      	mov	fp, r1
 80280a2:	931b      	str	r3, [sp, #108]	; 0x6c
 80280a4:	9400      	str	r4, [sp, #0]
 80280a6:	469e      	mov	lr, r3

   do
   {
      n1 = n2;
      n2 = n2 >> 3;
 80280a8:	ea4f 03db 	mov.w	r3, fp, lsr #3
 80280ac:	005a      	lsls	r2, r3, #1
 80280ae:	18d6      	adds	r6, r2, r3
 80280b0:	18f5      	adds	r5, r6, r3
 80280b2:	9204      	str	r2, [sp, #16]
 80280b4:	195a      	adds	r2, r3, r5
 80280b6:	18d0      	adds	r0, r2, r3
 80280b8:	00df      	lsls	r7, r3, #3
 80280ba:	1819      	adds	r1, r3, r0
 80280bc:	463c      	mov	r4, r7
 80280be:	9702      	str	r7, [sp, #8]
 80280c0:	4457      	add	r7, sl
 80280c2:	930c      	str	r3, [sp, #48]	; 0x30
 80280c4:	eb0a 02c2 	add.w	r2, sl, r2, lsl #3
 80280c8:	011b      	lsls	r3, r3, #4
 80280ca:	eb0a 01c1 	add.w	r1, sl, r1, lsl #3
 80280ce:	eb07 0c04 	add.w	ip, r7, r4
      i1 = 0;
 80280d2:	9c00      	ldr	r4, [sp, #0]
 80280d4:	9303      	str	r3, [sp, #12]
 80280d6:	eb0a 06c6 	add.w	r6, sl, r6, lsl #3
 80280da:	eb0a 05c5 	add.w	r5, sl, r5, lsl #3
 80280de:	3204      	adds	r2, #4
 80280e0:	3104      	adds	r1, #4
 80280e2:	eb0a 00c0 	add.w	r0, sl, r0, lsl #3
 80280e6:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 80280ea:	f04f 0800 	mov.w	r8, #0
         i4 = i3 + n2;
         i5 = i4 + n2;
         i6 = i5 + n2;
         i7 = i6 + n2;
         i8 = i7 + n2;
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
 80280ee:	ed5e 1a01 	vldr	s3, [lr, #-4]
         r5 = pSrc[2 * i1] - pSrc[2 * i5];
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
         r6 = pSrc[2 * i2] - pSrc[2 * i6];
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
 80280f2:	ed90 2a00 	vldr	s4, [r0]
         i6 = i5 + n2;
         i7 = i6 + n2;
         i8 = i7 + n2;
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
         r5 = pSrc[2 * i1] - pSrc[2 * i5];
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
 80280f6:	ed97 4a00 	vldr	s8, [r7]
 80280fa:	ed52 6a01 	vldr	s13, [r2, #-4]
         r6 = pSrc[2 * i2] - pSrc[2 * i6];
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
         r7 = pSrc[2 * i3] - pSrc[2 * i7];
         r4 = pSrc[2 * i4] + pSrc[2 * i8];
 80280fe:	ed96 3a00 	vldr	s6, [r6]
 8028102:	ed51 0a01 	vldr	s1, [r1, #-4]
         i4 = i3 + n2;
         i5 = i4 + n2;
         i6 = i5 + n2;
         i7 = i6 + n2;
         i8 = i7 + n2;
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
 8028106:	edd5 2a00 	vldr	s5, [r5]
         r5 = pSrc[2 * i1] - pSrc[2 * i5];
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
         r6 = pSrc[2 * i2] - pSrc[2 * i6];
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
 802810a:	ed9c 1a00 	vldr	s2, [ip]
         i4 = i3 + n2;
         i5 = i4 + n2;
         i6 = i5 + n2;
         i7 = i6 + n2;
         i8 = i7 + n2;
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
 802810e:	ee31 0aa2 	vadd.f32	s0, s3, s5
         r5 = pSrc[2 * i1] - pSrc[2 * i5];
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
         r6 = pSrc[2 * i2] - pSrc[2 * i6];
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
 8028112:	ee71 9a02 	vadd.f32	s19, s2, s4
         i6 = i5 + n2;
         i7 = i6 + n2;
         i8 = i7 + n2;
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
         r5 = pSrc[2 * i1] - pSrc[2 * i5];
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
 8028116:	ee34 6a26 	vadd.f32	s12, s8, s13
         r6 = pSrc[2 * i2] - pSrc[2 * i6];
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
         r7 = pSrc[2 * i3] - pSrc[2 * i7];
         r4 = pSrc[2 * i4] + pSrc[2 * i8];
 802811a:	ee33 9a20 	vadd.f32	s18, s6, s1
         r8 = pSrc[2 * i4] - pSrc[2 * i8];
         t1 = r1 - r3;
         r1 = r1 + r3;
 802811e:	ee30 7a29 	vadd.f32	s14, s0, s19
         r3 = r2 - r4;
         r2 = r2 + r4;
 8028122:	ee76 7a09 	vadd.f32	s15, s12, s18
         i7 = i6 + n2;
         i8 = i7 + n2;
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
         r5 = pSrc[2 * i1] - pSrc[2 * i5];
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
         r6 = pSrc[2 * i2] - pSrc[2 * i6];
 8028126:	ee74 3a66 	vsub.f32	s7, s8, s13
         r8 = pSrc[2 * i4] - pSrc[2 * i8];
         t1 = r1 - r3;
         r1 = r1 + r3;
         r3 = r2 - r4;
         r2 = r2 + r4;
         pSrc[2 * i1] = r1 + r2;
 802812a:	ee77 6a27 	vadd.f32	s13, s14, s15
         pSrc[2 * i5] = r1 - r2;
 802812e:	ee37 7a67 	vsub.f32	s14, s14, s15
         r8 = pSrc[2 * i4] - pSrc[2 * i8];
         t1 = r1 - r3;
         r1 = r1 + r3;
         r3 = r2 - r4;
         r2 = r2 + r4;
         pSrc[2 * i1] = r1 + r2;
 8028132:	ed4e 6a01 	vstr	s13, [lr, #-4]
         pSrc[2 * i5] = r1 - r2;
 8028136:	ed85 7a00 	vstr	s14, [r5]
         r1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
         s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
         r2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
 802813a:	edd7 5a01 	vldr	s11, [r7, #4]
 802813e:	edd2 6a00 	vldr	s13, [r2]
         s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
         s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
         s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
         r4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 8028142:	edd6 4a01 	vldr	s9, [r6, #4]
 8028146:	ed91 ba00 	vldr	s22, [r1]
         r1 = r1 + r3;
         r3 = r2 - r4;
         r2 = r2 + r4;
         pSrc[2 * i1] = r1 + r2;
         pSrc[2 * i5] = r1 - r2;
         r1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
 802814a:	edd5 8a01 	vldr	s17, [r5, #4]
 802814e:	ed9e 7a00 	vldr	s14, [lr]
         s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
         r2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
         s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
         s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
 8028152:	edd0 7a01 	vldr	s15, [r0, #4]
 8028156:	ed9c 5a01 	vldr	s10, [ip, #4]
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
         r6 = pSrc[2 * i2] - pSrc[2 * i6];
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
         r7 = pSrc[2 * i3] - pSrc[2 * i7];
         r4 = pSrc[2 * i4] + pSrc[2 * i8];
         r8 = pSrc[2 * i4] - pSrc[2 * i8];
 802815a:	ee33 4a60 	vsub.f32	s8, s6, s1
         pSrc[2 * i1] = r1 + r2;
         pSrc[2 * i5] = r1 - r2;
         r1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
         s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
         r2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
         s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
 802815e:	ee35 3ae6 	vsub.f32	s6, s11, s13
         s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
         s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
         r4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
         s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
 8028162:	ee74 0acb 	vsub.f32	s1, s9, s22
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
         r5 = pSrc[2 * i1] - pSrc[2 * i5];
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
         r6 = pSrc[2 * i2] - pSrc[2 * i6];
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
         r7 = pSrc[2 * i3] - pSrc[2 * i7];
 8028166:	ee31 1a42 	vsub.f32	s2, s2, s4
         r1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
         s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
         r2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
         s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
         s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
         s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
 802816a:	ee35 8a67 	vsub.f32	s16, s10, s15
         r3 = r2 - r4;
         r2 = r2 + r4;
         pSrc[2 * i1] = r1 + r2;
         pSrc[2 * i5] = r1 - r2;
         r1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
         s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
 802816e:	ee37 2a68 	vsub.f32	s4, s14, s17
         i5 = i4 + n2;
         i6 = i5 + n2;
         i7 = i6 + n2;
         i8 = i7 + n2;
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
         r5 = pSrc[2 * i1] - pSrc[2 * i5];
 8028172:	ee71 2ae2 	vsub.f32	s5, s3, s5
         pSrc[2 * i3 + 1] = t2 - r3;
         pSrc[2 * i7 + 1] = t2 + r3;
         r1 = (r6 - r8) * C81;
         r6 = (r6 + r8) * C81;
         r2 = (s6 - s8) * C81;
         s6 = (s6 + s8) * C81;
 8028176:	ee73 1a20 	vadd.f32	s3, s6, s1
         pSrc[2 * i7]     = t1 - s3;
         pSrc[2 * i3 + 1] = t2 - r3;
         pSrc[2 * i7 + 1] = t2 + r3;
         r1 = (r6 - r8) * C81;
         r6 = (r6 + r8) * C81;
         r2 = (s6 - s8) * C81;
 802817a:	ee33 3a60 	vsub.f32	s6, s6, s1
         pSrc[2 * i5 + 1] = r1 - r2;
         pSrc[2 * i3]     = t1 + s3;
         pSrc[2 * i7]     = t1 - s3;
         pSrc[2 * i3 + 1] = t2 - r3;
         pSrc[2 * i7 + 1] = t2 + r3;
         r1 = (r6 - r8) * C81;
 802817e:	ee33 aac4 	vsub.f32	s20, s7, s8
         r2 = r2 + r4;
         pSrc[2 * i1] = r1 + r2;
         pSrc[2 * i5] = r1 - r2;
         r1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
         s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
         r2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
 8028182:	ee75 0aa6 	vadd.f32	s1, s11, s13
         pSrc[2 * i3]     = t1 + s3;
         pSrc[2 * i7]     = t1 - s3;
         pSrc[2 * i3 + 1] = t2 - r3;
         pSrc[2 * i7 + 1] = t2 + r3;
         r1 = (r6 - r8) * C81;
         r6 = (r6 + r8) * C81;
 8028186:	ee33 4a84 	vadd.f32	s8, s7, s8
         r1 = r1 + r3;
         r3 = r2 - r4;
         r2 = r2 + r4;
         pSrc[2 * i1] = r1 + r2;
         pSrc[2 * i5] = r1 - r2;
         r1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
 802818a:	ee37 7a28 	vadd.f32	s14, s14, s17
         s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
         r2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
         s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
         s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
         s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
         r4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 802818e:	ee74 5a8b 	vadd.f32	s11, s9, s22
         r8 = r7 - r6;
         r7 = r7 + r6;
         t2 = s5 - r2;
         s5 = s5 + r2;
         s8 = s7 - s6;
         s7 = s7 + s6;
 8028192:	eef0 8a48 	vmov.f32	s17, s16
         t1 = r5 - r1;
         r5 = r5 + r1;
         r8 = r7 - r6;
         r7 = r7 + r6;
         t2 = s5 - r2;
         s5 = s5 + r2;
 8028196:	eef0 3a42 	vmov.f32	s7, s4
         s6 = (s6 + s8) * C81;
         t1 = r5 - r1;
         r5 = r5 + r1;
         r8 = r7 - r6;
         r7 = r7 + r6;
         t2 = s5 - r2;
 802819a:	eef0 4a42 	vmov.f32	s9, s4
         s5 = s5 + r2;
         s8 = s7 - s6;
         s7 = s7 + s6;
 802819e:	eee1 8aaa 	vfma.f32	s17, s3, s21
         pSrc[2 * i2 + 1] = s5 - r7;
         pSrc[2 * i8 + 1] = s5 + r7;
         pSrc[2 * i6 + 1] = t2 - r8;
         pSrc[2 * i4 + 1] = t2 + r8;

         i1 += n1;
 80281a2:	44d8      	add	r8, fp
      } while (i1 < fftLen);
 80281a4:	45c1      	cmp	r9, r8
         r5 = r5 + r1;
         r8 = r7 - r6;
         r7 = r7 + r6;
         t2 = s5 - r2;
         s5 = s5 + r2;
         s8 = s7 - s6;
 80281a6:	eea1 8aea 	vfms.f32	s16, s3, s21
         t1 = r5 - r1;
         r5 = r5 + r1;
         r8 = r7 - r6;
         r7 = r7 + r6;
         t2 = s5 - r2;
         s5 = s5 + r2;
 80281aa:	eee3 3a2a 	vfma.f32	s7, s6, s21
         s6 = (s6 + s8) * C81;
         t1 = r5 - r1;
         r5 = r5 + r1;
         r8 = r7 - r6;
         r7 = r7 + r6;
         t2 = s5 - r2;
 80281ae:	eee3 4a6a 	vfms.f32	s9, s6, s21
         r1 = (r6 - r8) * C81;
         r6 = (r6 + r8) * C81;
         r2 = (s6 - s8) * C81;
         s6 = (s6 + s8) * C81;
         t1 = r5 - r1;
         r5 = r5 + r1;
 80281b2:	eef0 1a62 	vmov.f32	s3, s5
         r8 = r7 - r6;
         r7 = r7 + r6;
 80281b6:	eeb0 2a41 	vmov.f32	s4, s2
         r6 = (r6 + r8) * C81;
         r2 = (s6 - s8) * C81;
         s6 = (s6 + s8) * C81;
         t1 = r5 - r1;
         r5 = r5 + r1;
         r8 = r7 - r6;
 80281ba:	eeb0 3a41 	vmov.f32	s6, s2
         pSrc[2 * i5] = r1 - r2;
         r1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
         s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
         r2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
         s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
         s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
 80281be:	ee35 5a27 	vadd.f32	s10, s10, s15
         r2 = (s6 - s8) * C81;
         s6 = (s6 + s8) * C81;
         t1 = r5 - r1;
         r5 = r5 + r1;
         r8 = r7 - r6;
         r7 = r7 + r6;
 80281c2:	eea4 2a2a 	vfma.f32	s4, s8, s21
         r6 = (r6 + r8) * C81;
         r2 = (s6 - s8) * C81;
         s6 = (s6 + s8) * C81;
         t1 = r5 - r1;
         r5 = r5 + r1;
         r8 = r7 - r6;
 80281c6:	eea4 3a6a 	vfms.f32	s6, s8, s21
         r1 = (r6 - r8) * C81;
         r6 = (r6 + r8) * C81;
         r2 = (s6 - s8) * C81;
         s6 = (s6 + s8) * C81;
         t1 = r5 - r1;
         r5 = r5 + r1;
 80281ca:	eeea 1a2a 	vfma.f32	s3, s20, s21
         pSrc[2 * i7 + 1] = t2 + r3;
         r1 = (r6 - r8) * C81;
         r6 = (r6 + r8) * C81;
         r2 = (s6 - s8) * C81;
         s6 = (s6 + s8) * C81;
         t1 = r5 - r1;
 80281ce:	eeea 2a6a 	vfms.f32	s5, s20, s21
         r4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
         s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
         t2 = r1 - s3;
         r1 = r1 + s3;
         s3 = r2 - r4;
         r2 = r2 + r4;
 80281d2:	ee30 1aa5 	vadd.f32	s2, s1, s11
         s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
         s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
         r4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
         s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
         t2 = r1 - s3;
         r1 = r1 + s3;
 80281d6:	ee37 4a05 	vadd.f32	s8, s14, s10
         s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
         s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
         s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
         r4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
         s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
         t2 = r1 - s3;
 80281da:	ee77 7a45 	vsub.f32	s15, s14, s10
         r6 = pSrc[2 * i2] - pSrc[2 * i6];
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
         r7 = pSrc[2 * i3] - pSrc[2 * i7];
         r4 = pSrc[2 * i4] + pSrc[2 * i8];
         r8 = pSrc[2 * i4] - pSrc[2 * i8];
         t1 = r1 - r3;
 80281de:	ee70 6a69 	vsub.f32	s13, s0, s19
         r1 = r1 + r3;
         r3 = r2 - r4;
 80281e2:	ee36 6a49 	vsub.f32	s12, s12, s18
         s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
         r4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
         s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
         t2 = r1 - s3;
         r1 = r1 + s3;
         s3 = r2 - r4;
 80281e6:	ee70 5ae5 	vsub.f32	s11, s1, s11
         r2 = r2 + r4;
         pSrc[2 * i1 + 1] = r1 + r2;
 80281ea:	ee34 0a01 	vadd.f32	s0, s8, s2
         pSrc[2 * i5 + 1] = r1 - r2;
         pSrc[2 * i3]     = t1 + s3;
 80281ee:	ee76 0aa5 	vadd.f32	s1, s13, s11
         t2 = r1 - s3;
         r1 = r1 + s3;
         s3 = r2 - r4;
         r2 = r2 + r4;
         pSrc[2 * i1 + 1] = r1 + r2;
         pSrc[2 * i5 + 1] = r1 - r2;
 80281f2:	ee34 4a41 	vsub.f32	s8, s8, s2
         pSrc[2 * i3]     = t1 + s3;
         pSrc[2 * i7]     = t1 - s3;
 80281f6:	ee76 6ae5 	vsub.f32	s13, s13, s11
         pSrc[2 * i3 + 1] = t2 - r3;
 80281fa:	ee37 1ac6 	vsub.f32	s2, s15, s12
         r7 = r7 + r6;
         t2 = s5 - r2;
         s5 = s5 + r2;
         s8 = s7 - s6;
         s7 = s7 + s6;
         pSrc[2 * i2]     = r5 + s7;
 80281fe:	ee31 5aa8 	vadd.f32	s10, s3, s17
         pSrc[2 * i1 + 1] = r1 + r2;
         pSrc[2 * i5 + 1] = r1 - r2;
         pSrc[2 * i3]     = t1 + s3;
         pSrc[2 * i7]     = t1 - s3;
         pSrc[2 * i3 + 1] = t2 - r3;
         pSrc[2 * i7 + 1] = t2 + r3;
 8028202:	ee77 7a86 	vadd.f32	s15, s15, s12
         s5 = s5 + r2;
         s8 = s7 - s6;
         s7 = s7 + s6;
         pSrc[2 * i2]     = r5 + s7;
         pSrc[2 * i8]     = r5 - s7;
         pSrc[2 * i6]     = t1 + s8;
 8028206:	ee72 5a88 	vadd.f32	s11, s5, s16
         pSrc[2 * i4]     = t1 - s8;
         pSrc[2 * i2 + 1] = s5 - r7;
 802820a:	ee33 6ac2 	vsub.f32	s12, s7, s4
         pSrc[2 * i8 + 1] = s5 + r7;
         pSrc[2 * i6 + 1] = t2 - r8;
 802820e:	ee34 7ac3 	vsub.f32	s14, s9, s6
         t2 = s5 - r2;
         s5 = s5 + r2;
         s8 = s7 - s6;
         s7 = s7 + s6;
         pSrc[2 * i2]     = r5 + s7;
         pSrc[2 * i8]     = r5 - s7;
 8028212:	ee71 1ae8 	vsub.f32	s3, s3, s17
         pSrc[2 * i6]     = t1 + s8;
         pSrc[2 * i4]     = t1 - s8;
 8028216:	ee72 2ac8 	vsub.f32	s5, s5, s16
         pSrc[2 * i2 + 1] = s5 - r7;
         pSrc[2 * i8 + 1] = s5 + r7;
 802821a:	ee73 3a82 	vadd.f32	s7, s7, s4
         pSrc[2 * i6 + 1] = t2 - r8;
         pSrc[2 * i4 + 1] = t2 + r8;
 802821e:	ee74 4a83 	vadd.f32	s9, s9, s6
         s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
         t2 = r1 - s3;
         r1 = r1 + s3;
         s3 = r2 - r4;
         r2 = r2 + r4;
         pSrc[2 * i1 + 1] = r1 + r2;
 8028222:	ed8e 0a00 	vstr	s0, [lr]
         pSrc[2 * i5 + 1] = r1 - r2;
 8028226:	ed85 4a01 	vstr	s8, [r5, #4]
 802822a:	449e      	add	lr, r3
         pSrc[2 * i3]     = t1 + s3;
 802822c:	edcc 0a00 	vstr	s1, [ip]
 8028230:	441d      	add	r5, r3
         pSrc[2 * i7]     = t1 - s3;
 8028232:	edc0 6a00 	vstr	s13, [r0]
         pSrc[2 * i3 + 1] = t2 - r3;
 8028236:	ed8c 1a01 	vstr	s2, [ip, #4]
         pSrc[2 * i7 + 1] = t2 + r3;
 802823a:	edc0 7a01 	vstr	s15, [r0, #4]
 802823e:	449c      	add	ip, r3
         r7 = r7 + r6;
         t2 = s5 - r2;
         s5 = s5 + r2;
         s8 = s7 - s6;
         s7 = s7 + s6;
         pSrc[2 * i2]     = r5 + s7;
 8028240:	ed87 5a00 	vstr	s10, [r7]
 8028244:	4418      	add	r0, r3
         pSrc[2 * i8]     = r5 - s7;
 8028246:	ed41 1a01 	vstr	s3, [r1, #-4]
         pSrc[2 * i6]     = t1 + s8;
 802824a:	ed42 5a01 	vstr	s11, [r2, #-4]
         pSrc[2 * i4]     = t1 - s8;
 802824e:	edc6 2a00 	vstr	s5, [r6]
         pSrc[2 * i2 + 1] = s5 - r7;
 8028252:	ed87 6a01 	vstr	s12, [r7, #4]
         pSrc[2 * i8 + 1] = s5 + r7;
 8028256:	edc1 3a00 	vstr	s7, [r1]
 802825a:	441f      	add	r7, r3
         pSrc[2 * i6 + 1] = t2 - r8;
 802825c:	ed82 7a00 	vstr	s14, [r2]
 8028260:	4419      	add	r1, r3
         pSrc[2 * i4 + 1] = t2 + r8;
 8028262:	edc6 4a01 	vstr	s9, [r6, #4]
 8028266:	441a      	add	r2, r3
 8028268:	441e      	add	r6, r3

         i1 += n1;
      } while (i1 < fftLen);
 802826a:	f63f af40 	bhi.w	80280ee <arm_radix8_butterfly_f32+0x66>

      if (n2 < 8)
 802826e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8028270:	9301      	str	r3, [sp, #4]
 8028272:	2a07      	cmp	r2, #7
 8028274:	4623      	mov	r3, r4
 8028276:	f240 81ca 	bls.w	802860e <arm_radix8_butterfly_f32+0x586>
 802827a:	eb04 0e44 	add.w	lr, r4, r4, lsl #1
 802827e:	eb0e 0703 	add.w	r7, lr, r3
 8028282:	18fd      	adds	r5, r7, r3
 8028284:	18e8      	adds	r0, r5, r3
 8028286:	9c04      	ldr	r4, [sp, #16]
 8028288:	9300      	str	r3, [sp, #0]
 802828a:	eb00 0c03 	add.w	ip, r0, r3
 802828e:	00c0      	lsls	r0, r0, #3
 8028290:	9010      	str	r0, [sp, #64]	; 0x40
 8028292:	9800      	ldr	r0, [sp, #0]
 8028294:	18a1      	adds	r1, r4, r2
 8028296:	1c66      	adds	r6, r4, #1
 8028298:	ea4f 04ce 	mov.w	r4, lr, lsl #3
 802829c:	940f      	str	r4, [sp, #60]	; 0x3c
 802829e:	00c4      	lsls	r4, r0, #3
 80282a0:	940d      	str	r4, [sp, #52]	; 0x34
 80282a2:	9c02      	ldr	r4, [sp, #8]
 80282a4:	3408      	adds	r4, #8
 80282a6:	9417      	str	r4, [sp, #92]	; 0x5c
 80282a8:	9c03      	ldr	r4, [sp, #12]
 80282aa:	3408      	adds	r4, #8
 80282ac:	00ed      	lsls	r5, r5, #3
 80282ae:	9416      	str	r4, [sp, #88]	; 0x58
 80282b0:	9c1a      	ldr	r4, [sp, #104]	; 0x68
 80282b2:	9513      	str	r5, [sp, #76]	; 0x4c
 80282b4:	462b      	mov	r3, r5
 80282b6:	ea4f 05cc 	mov.w	r5, ip, lsl #3
 80282ba:	9512      	str	r5, [sp, #72]	; 0x48
 80282bc:	1965      	adds	r5, r4, r5
 80282be:	9507      	str	r5, [sp, #28]
 80282c0:	9d10      	ldr	r5, [sp, #64]	; 0x40
 80282c2:	eb06 0682 	add.w	r6, r6, r2, lsl #2
 80282c6:	4416      	add	r6, r2
 80282c8:	1965      	adds	r5, r4, r5
 80282ca:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 80282ce:	0100      	lsls	r0, r0, #4
 80282d0:	00d2      	lsls	r2, r2, #3
 80282d2:	9508      	str	r5, [sp, #32]
 80282d4:	18e5      	adds	r5, r4, r3
 80282d6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80282d8:	900e      	str	r0, [sp, #56]	; 0x38
 80282da:	320c      	adds	r2, #12
 80282dc:	eb0a 06c6 	add.w	r6, sl, r6, lsl #3
 80282e0:	980c      	ldr	r0, [sp, #48]	; 0x30
 80282e2:	9214      	str	r2, [sp, #80]	; 0x50
 80282e4:	18e2      	adds	r2, r4, r3
 80282e6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80282e8:	9509      	str	r5, [sp, #36]	; 0x24
 80282ea:	00ff      	lsls	r7, r7, #3
 80282ec:	1d35      	adds	r5, r6, #4
 80282ee:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
 80282f0:	950a      	str	r5, [sp, #40]	; 0x28
 80282f2:	18e3      	adds	r3, r4, r3
 80282f4:	19e5      	adds	r5, r4, r7
 80282f6:	0140      	lsls	r0, r0, #5
 80282f8:	ea4f 0ec1 	mov.w	lr, r1, lsl #3
 80282fc:	9506      	str	r5, [sp, #24]
 80282fe:	0109      	lsls	r1, r1, #4
 8028300:	19a5      	adds	r5, r4, r6
 8028302:	9305      	str	r3, [sp, #20]
 8028304:	f100 0308 	add.w	r3, r0, #8
 8028308:	9504      	str	r5, [sp, #16]
 802830a:	310c      	adds	r1, #12
 802830c:	f10e 0508 	add.w	r5, lr, #8
 8028310:	9318      	str	r3, [sp, #96]	; 0x60
 8028312:	9b01      	ldr	r3, [sp, #4]
 8028314:	9203      	str	r2, [sp, #12]
 8028316:	9711      	str	r7, [sp, #68]	; 0x44
 8028318:	9519      	str	r5, [sp, #100]	; 0x64
 802831a:	9115      	str	r1, [sp, #84]	; 0x54
 802831c:	2200      	movs	r2, #0
 802831e:	f04f 0801 	mov.w	r8, #1
 8028322:	f102 0108 	add.w	r1, r2, #8
 8028326:	460f      	mov	r7, r1
 8028328:	910b      	str	r1, [sp, #44]	; 0x2c
 802832a:	9918      	ldr	r1, [sp, #96]	; 0x60
 802832c:	188e      	adds	r6, r1, r2
 802832e:	9917      	ldr	r1, [sp, #92]	; 0x5c
 8028330:	188d      	adds	r5, r1, r2
 8028332:	9916      	ldr	r1, [sp, #88]	; 0x58
 8028334:	188c      	adds	r4, r1, r2
 8028336:	9919      	ldr	r1, [sp, #100]	; 0x64
 8028338:	1888      	adds	r0, r1, r2
 802833a:	9914      	ldr	r1, [sp, #80]	; 0x50
 802833c:	eb01 0c02 	add.w	ip, r1, r2
 8028340:	9915      	ldr	r1, [sp, #84]	; 0x54
 8028342:	440a      	add	r2, r1
         ia4 = ia3 + id;
         ia5 = ia4 + id;
         ia6 = ia5 + id;
         ia7 = ia6 + id;

         co2 = pCoef[2 * ia1];
 8028344:	9903      	ldr	r1, [sp, #12]
 8028346:	ed91 fa00 	vldr	s30, [r1]
         co3 = pCoef[2 * ia2];
 802834a:	9905      	ldr	r1, [sp, #20]
 802834c:	edd1 ea00 	vldr	s29, [r1]
         co4 = pCoef[2 * ia3];
 8028350:	9904      	ldr	r1, [sp, #16]
 8028352:	ed91 ea00 	vldr	s28, [r1]
         co5 = pCoef[2 * ia4];
 8028356:	9906      	ldr	r1, [sp, #24]
 8028358:	edd1 da00 	vldr	s27, [r1]
         co6 = pCoef[2 * ia5];
 802835c:	9909      	ldr	r1, [sp, #36]	; 0x24
 802835e:	ed91 da00 	vldr	s26, [r1]
         co7 = pCoef[2 * ia6];
 8028362:	9908      	ldr	r1, [sp, #32]
 8028364:	edd1 ca00 	vldr	s25, [r1]
         co8 = pCoef[2 * ia7];
 8028368:	9907      	ldr	r1, [sp, #28]
 802836a:	ed91 ca00 	vldr	s24, [r1]
         si2 = pCoef[2 * ia1 + 1];
 802836e:	9903      	ldr	r1, [sp, #12]
 8028370:	edd1 ba01 	vldr	s23, [r1, #4]
         si3 = pCoef[2 * ia2 + 1];
 8028374:	9905      	ldr	r1, [sp, #20]
 8028376:	ed91 ba01 	vldr	s22, [r1, #4]
         si4 = pCoef[2 * ia3 + 1];
 802837a:	9904      	ldr	r1, [sp, #16]
 802837c:	ed91 aa01 	vldr	s20, [r1, #4]
         si5 = pCoef[2 * ia4 + 1];
 8028380:	9906      	ldr	r1, [sp, #24]
 8028382:	edd1 9a01 	vldr	s19, [r1, #4]
         si6 = pCoef[2 * ia5 + 1];
 8028386:	9909      	ldr	r1, [sp, #36]	; 0x24
 8028388:	edd1 7a01 	vldr	s15, [r1, #4]
         si7 = pCoef[2 * ia6 + 1];
 802838c:	9908      	ldr	r1, [sp, #32]
         co8 = pCoef[2 * ia7];
         si2 = pCoef[2 * ia1 + 1];
         si3 = pCoef[2 * ia2 + 1];
         si4 = pCoef[2 * ia3 + 1];
         si5 = pCoef[2 * ia4 + 1];
         si6 = pCoef[2 * ia5 + 1];
 802838e:	edcd 7a00 	vstr	s15, [sp]
         si7 = pCoef[2 * ia6 + 1];
 8028392:	edd1 7a01 	vldr	s15, [r1, #4]
         si8 = pCoef[2 * ia7 + 1];
 8028396:	9907      	ldr	r1, [sp, #28]
         si2 = pCoef[2 * ia1 + 1];
         si3 = pCoef[2 * ia2 + 1];
         si4 = pCoef[2 * ia3 + 1];
         si5 = pCoef[2 * ia4 + 1];
         si6 = pCoef[2 * ia5 + 1];
         si7 = pCoef[2 * ia6 + 1];
 8028398:	edcd 7a01 	vstr	s15, [sp, #4]
         si8 = pCoef[2 * ia7 + 1];
 802839c:	edd1 7a01 	vldr	s15, [r1, #4]
 80283a0:	eb0a 0e07 	add.w	lr, sl, r7
 80283a4:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 80283a6:	edcd 7a02 	vstr	s15, [sp, #8]
 80283aa:	eb0c 010a 	add.w	r1, ip, sl
 80283ae:	4456      	add	r6, sl
 80283b0:	4455      	add	r5, sl
 80283b2:	4454      	add	r4, sl
 80283b4:	4450      	add	r0, sl
 80283b6:	4452      	add	r2, sl

         i1 = j;
 80283b8:	46c4      	mov	ip, r8
 80283ba:	e001      	b.n	80283c0 <arm_radix8_butterfly_f32+0x338>
 80283bc:	3f3504f3 	.word	0x3f3504f3
            i4 = i3 + n2;
            i5 = i4 + n2;
            i6 = i5 + n2;
            i7 = i6 + n2;
            i8 = i7 + n2;
            r1 = pSrc[2 * i1] + pSrc[2 * i5];
 80283c0:	edde fa00 	vldr	s31, [lr]
            r5 = pSrc[2 * i1] - pSrc[2 * i5];
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
            r6 = pSrc[2 * i2] - pSrc[2 * i6];
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
 80283c4:	ed52 2a01 	vldr	s5, [r2, #-4]
            i6 = i5 + n2;
            i7 = i6 + n2;
            i8 = i7 + n2;
            r1 = pSrc[2 * i1] + pSrc[2 * i5];
            r5 = pSrc[2 * i1] - pSrc[2 * i5];
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
 80283c8:	ed11 6a01 	vldr	s12, [r1, #-4]
            r6 = pSrc[2 * i2] - pSrc[2 * i6];
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
            r7 = pSrc[2 * i3] - pSrc[2 * i7];
            r4 = pSrc[2 * i4] + pSrc[2 * i8];
 80283cc:	edd0 5a00 	vldr	s11, [r0]
 80283d0:	ed57 6a01 	vldr	s13, [r7, #-4]
            i4 = i3 + n2;
            i5 = i4 + n2;
            i6 = i5 + n2;
            i7 = i6 + n2;
            i8 = i7 + n2;
            r1 = pSrc[2 * i1] + pSrc[2 * i5];
 80283d4:	ed96 7a00 	vldr	s14, [r6]
            r5 = pSrc[2 * i1] - pSrc[2 * i5];
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
            r6 = pSrc[2 * i2] - pSrc[2 * i6];
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
 80283d8:	edd4 7a00 	vldr	s15, [r4]
            i6 = i5 + n2;
            i7 = i6 + n2;
            i8 = i7 + n2;
            r1 = pSrc[2 * i1] + pSrc[2 * i5];
            r5 = pSrc[2 * i1] - pSrc[2 * i5];
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
 80283dc:	ed95 2a00 	vldr	s4, [r5]
            r1 = r1 + r3;
            r3 = r2 - r4;
            r2 = r2 + r4;
            pSrc[2 * i1] = r1 + r2;
            r2 = r1 - r2;
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
 80283e0:	ed9e 8a01 	vldr	s16, [lr, #4]
            i4 = i3 + n2;
            i5 = i4 + n2;
            i6 = i5 + n2;
            i7 = i6 + n2;
            i8 = i7 + n2;
            r1 = pSrc[2 * i1] + pSrc[2 * i5];
 80283e4:	ee7f 0a87 	vadd.f32	s1, s31, s14
            r5 = pSrc[2 * i1] - pSrc[2 * i5];
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
 80283e8:	ee32 1a06 	vadd.f32	s2, s4, s12
            r6 = pSrc[2 * i2] - pSrc[2 * i6];
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
 80283ec:	ee37 4aa2 	vadd.f32	s8, s15, s5
            r7 = pSrc[2 * i3] - pSrc[2 * i7];
            r4 = pSrc[2 * i4] + pSrc[2 * i8];
 80283f0:	ee75 4aa6 	vadd.f32	s9, s11, s13
            r8 = pSrc[2 * i4] - pSrc[2 * i8];
            t1 = r1 - r3;
            r1 = r1 + r3;
 80283f4:	ee70 1a84 	vadd.f32	s3, s1, s8
            r3 = r2 - r4;
            r2 = r2 + r4;
 80283f8:	ee31 5a24 	vadd.f32	s10, s2, s9
            i7 = i6 + n2;
            i8 = i7 + n2;
            r1 = pSrc[2 * i1] + pSrc[2 * i5];
            r5 = pSrc[2 * i1] - pSrc[2 * i5];
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
            r6 = pSrc[2 * i2] - pSrc[2 * i6];
 80283fc:	ee32 2a46 	vsub.f32	s4, s4, s12
            r8 = pSrc[2 * i4] - pSrc[2 * i8];
            t1 = r1 - r3;
            r1 = r1 + r3;
            r3 = r2 - r4;
            r2 = r2 + r4;
            pSrc[2 * i1] = r1 + r2;
 8028400:	ee31 6a85 	vadd.f32	s12, s3, s10
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
            r6 = pSrc[2 * i2] - pSrc[2 * i6];
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
            r7 = pSrc[2 * i3] - pSrc[2 * i7];
            r4 = pSrc[2 * i4] + pSrc[2 * i8];
            r8 = pSrc[2 * i4] - pSrc[2 * i8];
 8028404:	ee75 5ae6 	vsub.f32	s11, s11, s13
            t1 = r1 - r3;
            r1 = r1 + r3;
            r3 = r2 - r4;
            r2 = r2 + r4;
            pSrc[2 * i1] = r1 + r2;
 8028408:	ed8e 6a00 	vstr	s12, [lr]
            s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
            s2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
            s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
            s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 802840c:	edd0 8a01 	vldr	s17, [r0, #4]
            r2 = r2 + r4;
            pSrc[2 * i1] = r1 + r2;
            r2 = r1 - r2;
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
            s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
            s2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
 8028410:	ed95 9a01 	vldr	s18, [r5, #4]
 8028414:	ed91 3a00 	vldr	s6, [r1]
            s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
            s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 8028418:	ed97 6a00 	vldr	s12, [r7]
            r2 = r1 - r2;
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
            s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
            s2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
            s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
 802841c:	ed94 0a01 	vldr	s0, [r4, #4]
 8028420:	edd2 6a00 	vldr	s13, [r2]
            r1 = r1 + r3;
            r3 = r2 - r4;
            r2 = r2 + r4;
            pSrc[2 * i1] = r1 + r2;
            r2 = r1 - r2;
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
 8028424:	edd6 3a01 	vldr	s7, [r6, #4]
            i5 = i4 + n2;
            i6 = i5 + n2;
            i7 = i6 + n2;
            i8 = i7 + n2;
            r1 = pSrc[2 * i1] + pSrc[2 * i5];
            r5 = pSrc[2 * i1] - pSrc[2 * i5];
 8028428:	ee3f 7ac7 	vsub.f32	s14, s31, s14
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
            r6 = pSrc[2 * i2] - pSrc[2 * i6];
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
            r7 = pSrc[2 * i3] - pSrc[2 * i7];
 802842c:	ee77 7ae2 	vsub.f32	s15, s15, s5
            s2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
            s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
            s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
            s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
 8028430:	ee78 fac6 	vsub.f32	s31, s17, s12
            pSrc[2 * i1] = r1 + r2;
            r2 = r1 - r2;
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
            s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
            s2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
            s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
 8028434:	ee79 2a43 	vsub.f32	s5, s18, s6
            r2 = r2 + r4;
            pSrc[2 * i1] = r1 + r2;
            r2 = r1 - r2;
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
            s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
            s2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
 8028438:	ee39 3a03 	vadd.f32	s6, s18, s6
            s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
            s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
 802843c:	ee30 9a66 	vsub.f32	s18, s0, s13
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 8028440:	ee38 6a86 	vadd.f32	s12, s17, s12
            r2 = r1 - r2;
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
            s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
            s2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
            s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
 8028444:	ee70 6a26 	vadd.f32	s13, s0, s13
            r3 = r2 - r4;
            r2 = r2 + r4;
            pSrc[2 * i1] = r1 + r2;
            r2 = r1 - r2;
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
            s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
 8028448:	ee78 8a63 	vsub.f32	s17, s16, s7
            p4 = si7 * t1;
            pSrc[2 * i7]     = p1 + p2;
            pSrc[2 * i7 + 1] = p3 - p4;
            r1 = (r6 - r8) * C81;
            r6 = (r6 + r8) * C81;
            s1 = (s6 - s8) * C81;
 802844c:	ee32 0aef 	vsub.f32	s0, s5, s31
            s6 = (s6 + s8) * C81;
 8028450:	ee72 2aaf 	vadd.f32	s5, s5, s31
            r1 = r1 + r3;
            r3 = r2 - r4;
            r2 = r2 + r4;
            pSrc[2 * i1] = r1 + r2;
            r2 = r1 - r2;
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
 8028454:	ee78 3a23 	vadd.f32	s7, s16, s7
            r6 = pSrc[2 * i2] - pSrc[2 * i6];
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
            r7 = pSrc[2 * i3] - pSrc[2 * i7];
            r4 = pSrc[2 * i4] + pSrc[2 * i8];
            r8 = pSrc[2 * i4] - pSrc[2 * i8];
            t1 = r1 - r3;
 8028458:	ee30 4ac4 	vsub.f32	s8, s1, s8
            p3 = co7 * t2;
            p4 = si7 * t1;
            pSrc[2 * i7]     = p1 + p2;
            pSrc[2 * i7 + 1] = p3 - p4;
            r1 = (r6 - r8) * C81;
            r6 = (r6 + r8) * C81;
 802845c:	ee32 8a25 	vadd.f32	s16, s4, s11
            r8 = r7 - r6;
            r7 = r7 + r6;
            t2 = s5 - s1;
            s5 = s5 + s1;
            s8 = s7 - s6;
            s7 = s7 + s6;
 8028460:	eef0 0a49 	vmov.f32	s1, s18
            p2 = si7 * t2;
            p3 = co7 * t2;
            p4 = si7 * t1;
            pSrc[2 * i7]     = p1 + p2;
            pSrc[2 * i7 + 1] = p3 - p4;
            r1 = (r6 - r8) * C81;
 8028464:	ee72 5a65 	vsub.f32	s11, s4, s11
            r8 = r7 - r6;
            r7 = r7 + r6;
            t2 = s5 - s1;
            s5 = s5 + s1;
            s8 = s7 - s6;
            s7 = s7 + s6;
 8028468:	eee2 0aaa 	vfma.f32	s1, s5, s21
            p3 = co4 * t2;
            p4 = si4 * t1;
            pSrc[2 * i4]     = p1 + p2;
            pSrc[2 * i4 + 1] = p3 - p4;

            i1 += n1;
 802846c:	44dc      	add	ip, fp
         } while (i1 < fftLen);
 802846e:	45e1      	cmp	r9, ip
            r5 = r5 + r1;
            r8 = r7 - r6;
            r7 = r7 + r6;
            t2 = s5 - s1;
            s5 = s5 + s1;
            s8 = s7 - s6;
 8028470:	eea2 9aea 	vfms.f32	s18, s5, s21
            t1 = r5 - r1;
            r5 = r5 + r1;
            r8 = r7 - r6;
            r7 = r7 + r6;
            t2 = s5 - s1;
            s5 = s5 + s1;
 8028474:	eeb0 2a68 	vmov.f32	s4, s17
            r1 = (r6 - r8) * C81;
            r6 = (r6 + r8) * C81;
            s1 = (s6 - s8) * C81;
            s6 = (s6 + s8) * C81;
            t1 = r5 - r1;
            r5 = r5 + r1;
 8028478:	eef0 2a47 	vmov.f32	s5, s14
 802847c:	eee5 2aaa 	vfma.f32	s5, s11, s21
            pSrc[2 * i7 + 1] = p3 - p4;
            r1 = (r6 - r8) * C81;
            r6 = (r6 + r8) * C81;
            s1 = (s6 - s8) * C81;
            s6 = (s6 + s8) * C81;
            t1 = r5 - r1;
 8028480:	eea5 7aea 	vfms.f32	s14, s11, s21
            r5 = r5 + r1;
            r8 = r7 - r6;
            r7 = r7 + r6;
            t2 = s5 - s1;
            s5 = s5 + s1;
 8028484:	eea0 2a2a 	vfma.f32	s4, s0, s21
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
            s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
            t2 = s1 - s3;
            s1 = s1 + s3;
            s3 = s2 - s4;
            s2 = s2 + s4;
 8028488:	ee73 5a06 	vadd.f32	s11, s6, s12
            s6 = (s6 + s8) * C81;
            t1 = r5 - r1;
            r5 = r5 + r1;
            r8 = r7 - r6;
            r7 = r7 + r6;
            t2 = s5 - s1;
 802848c:	eee0 8a6a 	vfms.f32	s17, s0, s21
            s1 = (s6 - s8) * C81;
            s6 = (s6 + s8) * C81;
            t1 = r5 - r1;
            r5 = r5 + r1;
            r8 = r7 - r6;
            r7 = r7 + r6;
 8028490:	eef0 fa67 	vmov.f32	s31, s15
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
            s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
            s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
            t2 = s1 - s3;
            s1 = s1 + s3;
 8028494:	ee33 0aa6 	vadd.f32	s0, s7, s13
            r6 = (r6 + r8) * C81;
            s1 = (s6 - s8) * C81;
            s6 = (s6 + s8) * C81;
            t1 = r5 - r1;
            r5 = r5 + r1;
            r8 = r7 - r6;
 8028498:	eee8 7a6a 	vfms.f32	s15, s16, s21
            r7 = pSrc[2 * i3] - pSrc[2 * i7];
            r4 = pSrc[2 * i4] + pSrc[2 * i8];
            r8 = pSrc[2 * i4] - pSrc[2 * i8];
            t1 = r1 - r3;
            r1 = r1 + r3;
            r3 = r2 - r4;
 802849c:	ee71 4a64 	vsub.f32	s9, s2, s9
            r2 = r2 + r4;
            pSrc[2 * i1] = r1 + r2;
            r2 = r1 - r2;
 80284a0:	ee31 5ac5 	vsub.f32	s10, s3, s10
            s1 = (s6 - s8) * C81;
            s6 = (s6 + s8) * C81;
            t1 = r5 - r1;
            r5 = r5 + r1;
            r8 = r7 - r6;
            r7 = r7 + r6;
 80284a4:	eee8 fa2a 	vfma.f32	s31, s16, s21
            s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
            s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
            t2 = s1 - s3;
            s1 = s1 + s3;
            s3 = s2 - s4;
 80284a8:	ee33 3a46 	vsub.f32	s6, s6, s12
            s2 = s2 + s4;
            r1 = t1 + s3;
            t1 = t1 - s3;
            pSrc[2 * i1 + 1] = s1 + s2;
            s2 = s1 - s2;
 80284ac:	ee30 8a65 	vsub.f32	s16, s0, s11
            s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
            s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
            s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
            t2 = s1 - s3;
 80284b0:	ee73 3ae6 	vsub.f32	s7, s7, s13
            s1 = s1 + s3;
            s3 = s2 - s4;
            s2 = s2 + s4;
            r1 = t1 + s3;
 80284b4:	ee34 6a03 	vadd.f32	s12, s8, s6
            r7 = r7 + r6;
            t2 = s5 - s1;
            s5 = s5 + s1;
            s8 = s7 - s6;
            s7 = s7 + s6;
            r1 = r5 + s7;
 80284b8:	ee72 6aa0 	vadd.f32	s13, s5, s1
            t2 = s1 - s3;
            s1 = s1 + s3;
            s3 = s2 - s4;
            s2 = s2 + s4;
            r1 = t1 + s3;
            t1 = t1 - s3;
 80284bc:	ee34 4a43 	vsub.f32	s8, s8, s6
            t2 = s5 - s1;
            s5 = s5 + s1;
            s8 = s7 - s6;
            s7 = s7 + s6;
            r1 = r5 + s7;
            r5 = r5 - s7;
 80284c0:	ee72 0ae0 	vsub.f32	s1, s5, s1
            s2 = s2 + s4;
            r1 = t1 + s3;
            t1 = t1 - s3;
            pSrc[2 * i1 + 1] = s1 + s2;
            s2 = s1 - s2;
            s1 = t2 - r3;
 80284c4:	ee33 3ae4 	vsub.f32	s6, s7, s9
 80284c8:	ee65 2a69 	vnmul.f32	s5, s10, s19
            t2 = t2 + r3;
 80284cc:	ee73 3aa4 	vadd.f32	s7, s7, s9
            s5 = s5 + s1;
            s8 = s7 - s6;
            s7 = s7 + s6;
            r1 = r5 + s7;
            r5 = r5 - s7;
            r6 = t1 + s8;
 80284d0:	ee77 4a09 	vadd.f32	s9, s14, s18
            t1 = t1 - s8;
 80284d4:	ee37 9a49 	vsub.f32	s18, s14, s18
            s1 = s5 - r7;
            s5 = s5 + r7;
            s6 = t2 - r8;
 80284d8:	ee38 7ae7 	vsub.f32	s14, s17, s15
            t2 = t2 + r8;
 80284dc:	ee78 8aa7 	vadd.f32	s17, s17, s15
            pSrc[2 * i1 + 1] = s1 + s2;
            s2 = s1 - s2;
            s1 = t2 - r3;
            t2 = t2 + r3;
            p1 = co5 * r2;
            p2 = si5 * s2;
 80284e0:	ee69 7a88 	vmul.f32	s15, s19, s16
            p3 = co5 * s2;
            p4 = si5 * r2;
            pSrc[2 * i5]     = p1 + p2;
            pSrc[2 * i5 + 1] = p3 - p4;
 80284e4:	eeed 2a88 	vfma.f32	s5, s27, s16
            t2 = t2 + r3;
            p1 = co5 * r2;
            p2 = si5 * s2;
            p3 = co5 * s2;
            p4 = si5 * r2;
            pSrc[2 * i5]     = p1 + p2;
 80284e8:	eeed 7a85 	vfma.f32	s15, s27, s10
            p3 = co3 * s1;
            p4 = si3 * r1;
            pSrc[2 * i3]     = p1 + p2;
            pSrc[2 * i3 + 1] = p3 - p4;
            p1 = co7 * t1;
            p2 = si7 * t2;
 80284ec:	ed9d 8a01 	vldr	s16, [sp, #4]
 80284f0:	ee26 5a4b 	vnmul.f32	s10, s12, s22
            p3 = co5 * s2;
            p4 = si5 * r2;
            pSrc[2 * i5]     = p1 + p2;
            pSrc[2 * i5 + 1] = p3 - p4;
            p1 = co3 * r1;
            p2 = si3 * s1;
 80284f4:	ee2b 1a03 	vmul.f32	s2, s22, s6
            s7 = s7 + s6;
            r1 = r5 + s7;
            r5 = r5 - s7;
            r6 = t1 + s8;
            t1 = t1 - s8;
            s1 = s5 - r7;
 80284f8:	ee72 1a6f 	vsub.f32	s3, s4, s31
            p1 = co3 * r1;
            p2 = si3 * s1;
            p3 = co3 * s1;
            p4 = si3 * r1;
            pSrc[2 * i3]     = p1 + p2;
            pSrc[2 * i3 + 1] = p3 - p4;
 80284fc:	eeae 5a83 	vfma.f32	s10, s29, s6
            pSrc[2 * i5 + 1] = p3 - p4;
            p1 = co3 * r1;
            p2 = si3 * s1;
            p3 = co3 * s1;
            p4 = si3 * r1;
            pSrc[2 * i3]     = p1 + p2;
 8028500:	eeae 1a86 	vfma.f32	s2, s29, s12
            pSrc[2 * i3 + 1] = p3 - p4;
            p1 = co7 * t1;
            p2 = si7 * t2;
 8028504:	ee28 3a23 	vmul.f32	s6, s16, s7
 8028508:	ee24 6a48 	vnmul.f32	s12, s8, s16
            r1 = r5 + s7;
            r5 = r5 - s7;
            r6 = t1 + s8;
            t1 = t1 - s8;
            s1 = s5 - r7;
            s5 = s5 + r7;
 802850c:	ee32 2a2f 	vadd.f32	s4, s4, s31
            p3 = co2 * s1;
            p4 = si2 * r1;
            pSrc[2 * i2]     = p1 + p2;
            pSrc[2 * i2 + 1] = p3 - p4;
            p1 = co8 * r5;
            p2 = si8 * s5;
 8028510:	ed9d 8a02 	vldr	s16, [sp, #8]
            pSrc[2 * i3 + 1] = p3 - p4;
            p1 = co7 * t1;
            p2 = si7 * t2;
            p3 = co7 * t2;
            p4 = si7 * t1;
            pSrc[2 * i7]     = p1 + p2;
 8028514:	eeac 3a84 	vfma.f32	s6, s25, s8
            pSrc[2 * i7 + 1] = p3 - p4;
 8028518:	eeac 6aa3 	vfma.f32	s12, s25, s7
            s1 = s5 - r7;
            s5 = s5 + r7;
            s6 = t2 - r8;
            t2 = t2 + r8;
            p1 = co2 * r1;
            p2 = si2 * s1;
 802851c:	ee2b 4aa1 	vmul.f32	s8, s23, s3
 8028520:	ee66 3aeb 	vnmul.f32	s7, s13, s23
            p3 = co2 * s1;
            p4 = si2 * r1;
            pSrc[2 * i2]     = p1 + p2;
 8028524:	eeaf 4a26 	vfma.f32	s8, s30, s13
            pSrc[2 * i2 + 1] = p3 - p4;
 8028528:	eeef 3a21 	vfma.f32	s7, s30, s3
            p1 = co8 * r5;
            p2 = si8 * s5;
 802852c:	ee68 6a02 	vmul.f32	s13, s16, s4
 8028530:	ee60 1ac8 	vnmul.f32	s3, s1, s16
 8028534:	ed9d 8a00 	vldr	s16, [sp]
            p3 = co8 * s5;
            p4 = si8 * r5;
            pSrc[2 * i8]     = p1 + p2;
 8028538:	eeec 6a20 	vfma.f32	s13, s24, s1
            pSrc[2 * i8 + 1] = p3 - p4;
 802853c:	eeec 1a02 	vfma.f32	s3, s24, s4
 8028540:	ee64 0ac8 	vnmul.f32	s1, s9, s16
            p1 = co6 * r6;
            p2 = si6 * s6;
 8028544:	ee28 2a07 	vmul.f32	s4, s16, s14
            p3 = co6 * s6;
            p4 = si6 * r6;
            pSrc[2 * i6]     = p1 + p2;
            pSrc[2 * i6 + 1] = p3 - p4;
 8028548:	eeed 0a07 	vfma.f32	s1, s26, s14
            pSrc[2 * i8 + 1] = p3 - p4;
            p1 = co6 * r6;
            p2 = si6 * s6;
            p3 = co6 * s6;
            p4 = si6 * r6;
            pSrc[2 * i6]     = p1 + p2;
 802854c:	eead 2a24 	vfma.f32	s4, s26, s9
            pSrc[2 * i6 + 1] = p3 - p4;
            p1 = co4 * t1;
            p2 = si4 * t2;
 8028550:	ee2a 7a28 	vmul.f32	s14, s20, s17
 8028554:	ee69 4a4a 	vnmul.f32	s9, s18, s20
            p3 = co4 * t2;
            p4 = si4 * t1;
            pSrc[2 * i4]     = p1 + p2;
 8028558:	eeae 7a09 	vfma.f32	s14, s28, s18
            pSrc[2 * i4 + 1] = p3 - p4;
 802855c:	eeee 4a28 	vfma.f32	s9, s28, s17
            s1 = s1 + s3;
            s3 = s2 - s4;
            s2 = s2 + s4;
            r1 = t1 + s3;
            t1 = t1 - s3;
            pSrc[2 * i1 + 1] = s1 + s2;
 8028560:	ee70 5a25 	vadd.f32	s11, s0, s11
 8028564:	edce 5a01 	vstr	s11, [lr, #4]
            t2 = t2 + r3;
            p1 = co5 * r2;
            p2 = si5 * s2;
            p3 = co5 * s2;
            p4 = si5 * r2;
            pSrc[2 * i5]     = p1 + p2;
 8028568:	edc6 7a00 	vstr	s15, [r6]
            pSrc[2 * i5 + 1] = p3 - p4;
 802856c:	edc6 2a01 	vstr	s5, [r6, #4]
 8028570:	449e      	add	lr, r3
            p1 = co3 * r1;
            p2 = si3 * s1;
            p3 = co3 * s1;
            p4 = si3 * r1;
            pSrc[2 * i3]     = p1 + p2;
 8028572:	ed84 1a00 	vstr	s2, [r4]
            pSrc[2 * i3 + 1] = p3 - p4;
 8028576:	ed84 5a01 	vstr	s10, [r4, #4]
 802857a:	441e      	add	r6, r3
            p1 = co7 * t1;
            p2 = si7 * t2;
            p3 = co7 * t2;
            p4 = si7 * t1;
            pSrc[2 * i7]     = p1 + p2;
 802857c:	ed02 3a01 	vstr	s6, [r2, #-4]
            pSrc[2 * i7 + 1] = p3 - p4;
 8028580:	ed82 6a00 	vstr	s12, [r2]
 8028584:	441c      	add	r4, r3
            t2 = t2 + r8;
            p1 = co2 * r1;
            p2 = si2 * s1;
            p3 = co2 * s1;
            p4 = si2 * r1;
            pSrc[2 * i2]     = p1 + p2;
 8028586:	ed85 4a00 	vstr	s8, [r5]
            pSrc[2 * i2 + 1] = p3 - p4;
 802858a:	edc5 3a01 	vstr	s7, [r5, #4]
 802858e:	441a      	add	r2, r3
            p1 = co8 * r5;
            p2 = si8 * s5;
            p3 = co8 * s5;
            p4 = si8 * r5;
            pSrc[2 * i8]     = p1 + p2;
 8028590:	ed47 6a01 	vstr	s13, [r7, #-4]
            pSrc[2 * i8 + 1] = p3 - p4;
 8028594:	edc7 1a00 	vstr	s3, [r7]
 8028598:	441d      	add	r5, r3
            p1 = co6 * r6;
            p2 = si6 * s6;
            p3 = co6 * s6;
            p4 = si6 * r6;
            pSrc[2 * i6]     = p1 + p2;
 802859a:	ed01 2a01 	vstr	s4, [r1, #-4]
            pSrc[2 * i6 + 1] = p3 - p4;
 802859e:	edc1 0a00 	vstr	s1, [r1]
 80285a2:	441f      	add	r7, r3
            p1 = co4 * t1;
            p2 = si4 * t2;
            p3 = co4 * t2;
            p4 = si4 * t1;
            pSrc[2 * i4]     = p1 + p2;
 80285a4:	ed80 7a00 	vstr	s14, [r0]
 80285a8:	4419      	add	r1, r3
            pSrc[2 * i4 + 1] = p3 - p4;
 80285aa:	edc0 4a01 	vstr	s9, [r0, #4]
 80285ae:	4418      	add	r0, r3

            i1 += n1;
         } while (i1 < fftLen);
 80285b0:	f63f af06 	bhi.w	80283c0 <arm_radix8_butterfly_f32+0x338>
 80285b4:	9a03      	ldr	r2, [sp, #12]
 80285b6:	990d      	ldr	r1, [sp, #52]	; 0x34
 80285b8:	440a      	add	r2, r1
 80285ba:	9203      	str	r2, [sp, #12]
 80285bc:	990e      	ldr	r1, [sp, #56]	; 0x38
 80285be:	9a05      	ldr	r2, [sp, #20]
 80285c0:	440a      	add	r2, r1
 80285c2:	9205      	str	r2, [sp, #20]
 80285c4:	990f      	ldr	r1, [sp, #60]	; 0x3c
 80285c6:	9a04      	ldr	r2, [sp, #16]
 80285c8:	440a      	add	r2, r1
 80285ca:	9204      	str	r2, [sp, #16]
 80285cc:	9911      	ldr	r1, [sp, #68]	; 0x44
 80285ce:	9a06      	ldr	r2, [sp, #24]
 80285d0:	440a      	add	r2, r1
 80285d2:	9206      	str	r2, [sp, #24]
 80285d4:	9913      	ldr	r1, [sp, #76]	; 0x4c
 80285d6:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80285d8:	440a      	add	r2, r1
 80285da:	9209      	str	r2, [sp, #36]	; 0x24
 80285dc:	9910      	ldr	r1, [sp, #64]	; 0x40
 80285de:	9a08      	ldr	r2, [sp, #32]
 80285e0:	440a      	add	r2, r1
 80285e2:	9208      	str	r2, [sp, #32]
 80285e4:	9912      	ldr	r1, [sp, #72]	; 0x48
 80285e6:	9a07      	ldr	r2, [sp, #28]
 80285e8:	440a      	add	r2, r1
 80285ea:	9207      	str	r2, [sp, #28]

         j++;
      } while (j < n2);
 80285ec:	990c      	ldr	r1, [sp, #48]	; 0x30
 80285ee:	9a0a      	ldr	r2, [sp, #40]	; 0x28
            pSrc[2 * i4 + 1] = p3 - p4;

            i1 += n1;
         } while (i1 < fftLen);

         j++;
 80285f0:	f108 0801 	add.w	r8, r8, #1
 80285f4:	3208      	adds	r2, #8
      } while (j < n2);
 80285f6:	4588      	cmp	r8, r1
 80285f8:	920a      	str	r2, [sp, #40]	; 0x28
 80285fa:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80285fc:	f47f ae91 	bne.w	8028322 <arm_radix8_butterfly_f32+0x29a>

      twidCoefModifier <<= 3;
 8028600:	f8bd 3034 	ldrh.w	r3, [sp, #52]	; 0x34
 8028604:	9300      	str	r3, [sp, #0]
 8028606:	46c3      	mov	fp, r8
 8028608:	f8dd e06c 	ldr.w	lr, [sp, #108]	; 0x6c
 802860c:	e54c      	b.n	80280a8 <arm_radix8_butterfly_f32+0x20>
   } while (n2 > 7);
}
 802860e:	b01d      	add	sp, #116	; 0x74
 8028610:	ecbd 8b10 	vpop	{d8-d15}
 8028614:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08028618 <arm_max_f32>:
void arm_max_f32(
  float32_t * pSrc,
  uint32_t blockSize,
  float32_t * pResult,
  uint32_t * pIndex)
{
 8028618:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  outIndex = 0u;
  /* Load first input value that act as reference value for comparision */
  out = *pSrc++;

  /* Loop unrolling */
  blkCnt = (blockSize - 1u) >> 2u;
 802861c:	1e4f      	subs	r7, r1, #1

  while (blkCnt > 0u)
 802861e:	ea5f 0897 	movs.w	r8, r7, lsr #2
  /* Initialise the count value. */
  count = 0u;
  /* Initialise the index value to zero. */
  outIndex = 0u;
  /* Load first input value that act as reference value for comparision */
  out = *pSrc++;
 8028622:	f100 0e04 	add.w	lr, r0, #4
 8028626:	edd0 7a00 	vldr	s15, [r0]

  /* Loop unrolling */
  blkCnt = (blockSize - 1u) >> 2u;

  while (blkCnt > 0u)
 802862a:	d058      	beq.n	80286de <arm_max_f32+0xc6>
 802862c:	3014      	adds	r0, #20
 802862e:	46c4      	mov	ip, r8
 8028630:	2604      	movs	r6, #4
 8028632:	2400      	movs	r4, #0
  {
    /* Initialize maxVal to the next consecutive values one by one */
    maxVal1 = *pSrc++;
 8028634:	ed10 6a04 	vldr	s12, [r0, #-16]
    maxVal2 = *pSrc++;
 8028638:	ed50 6a03 	vldr	s13, [r0, #-12]
      out = maxVal2;
      outIndex = count + 2u;
    }

    /* Initialize maxVal to the next consecutive values one by one */
    maxVal1 = *pSrc++;
 802863c:	ed10 7a02 	vldr	s14, [r0, #-8]
    maxVal2 = *pSrc++;
 8028640:	ed50 5a01 	vldr	s11, [r0, #-4]
 8028644:	eeb4 6ae7 	vcmpe.f32	s12, s15
 8028648:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802864c:	bfc8      	it	gt
 802864e:	eef0 7a46 	vmovgt.f32	s15, s12
    /* compare for the maximum value */
    if (out < maxVal1)
    {
      /* Update the maximum value and its index */
      out = maxVal1;
      outIndex = count + 1u;
 8028652:	f1a6 0503 	sub.w	r5, r6, #3
 8028656:	eef4 7ae6 	vcmpe.f32	s15, s13
 802865a:	bfc8      	it	gt
 802865c:	462c      	movgt	r4, r5
 802865e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8028662:	bf48      	it	mi
 8028664:	eef0 7a66 	vmovmi.f32	s15, s13
    /* compare for the maximum value */
    if (out < maxVal2)
    {
      /* Update the maximum value and its index */
      out = maxVal2;
      outIndex = count + 2u;
 8028668:	f1a6 0502 	sub.w	r5, r6, #2
 802866c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8028670:	bf48      	it	mi
 8028672:	462c      	movmi	r4, r5
 8028674:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8028678:	bf48      	it	mi
 802867a:	eef0 7a47 	vmovmi.f32	s15, s14
    /* compare for the maximum value */
    if (out < maxVal1)
    {
      /* Update the maximum value and its index */
      out = maxVal1;
      outIndex = count + 3u;
 802867e:	f106 35ff 	add.w	r5, r6, #4294967295
 8028682:	eef4 7ae5 	vcmpe.f32	s15, s11
 8028686:	bf48      	it	mi
 8028688:	462c      	movmi	r4, r5
 802868a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802868e:	bf48      	it	mi
 8028690:	4634      	movmi	r4, r6
 8028692:	bf48      	it	mi
 8028694:	eef0 7a65 	vmovmi.f32	s15, s11
  out = *pSrc++;

  /* Loop unrolling */
  blkCnt = (blockSize - 1u) >> 2u;

  while (blkCnt > 0u)
 8028698:	f1bc 0c01 	subs.w	ip, ip, #1
 802869c:	f106 0604 	add.w	r6, r6, #4
 80286a0:	f100 0010 	add.w	r0, r0, #16
 80286a4:	d1c6      	bne.n	8028634 <arm_max_f32+0x1c>
 80286a6:	eb0e 1e08 	add.w	lr, lr, r8, lsl #4

  blkCnt = (blockSize - 1u);

#endif /* #if defined (ARM_MATH_DSP) */

  while (blkCnt > 0u)
 80286aa:	f017 0003 	ands.w	r0, r7, #3
 80286ae:	d018      	beq.n	80286e2 <arm_max_f32+0xca>
 80286b0:	1a08      	subs	r0, r1, r0
  {
    /* Initialize maxVal to the next consecutive values one by one */
    maxVal1 = *pSrc++;
 80286b2:	ecbe 7a01 	vldmia	lr!, {s14}
 80286b6:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80286ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80286be:	bfc8      	it	gt
 80286c0:	4604      	movgt	r4, r0
 80286c2:	f100 0001 	add.w	r0, r0, #1
 80286c6:	bfd8      	it	le
 80286c8:	eeb0 7a67 	vmovle.f32	s14, s15

  blkCnt = (blockSize - 1u);

#endif /* #if defined (ARM_MATH_DSP) */

  while (blkCnt > 0u)
 80286cc:	4288      	cmp	r0, r1
 80286ce:	eef0 7a47 	vmov.f32	s15, s14
 80286d2:	d1ee      	bne.n	80286b2 <arm_max_f32+0x9a>
    /* Decrement the loop counter */
    blkCnt--;
  }

  /* Store the maximum value and it's index into destination pointers */
  *pResult = out;
 80286d4:	ed82 7a00 	vstr	s14, [r2]
  *pIndex = outIndex;
 80286d8:	601c      	str	r4, [r3, #0]
 80286da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  uint32_t blkCnt, outIndex, count;              /* loop counter */

  /* Initialise the count value. */
  count = 0u;
  /* Initialise the index value to zero. */
  outIndex = 0u;
 80286de:	4644      	mov	r4, r8
 80286e0:	e7e3      	b.n	80286aa <arm_max_f32+0x92>

  blkCnt = (blockSize - 1u);

#endif /* #if defined (ARM_MATH_DSP) */

  while (blkCnt > 0u)
 80286e2:	eeb0 7a67 	vmov.f32	s14, s15
 80286e6:	e7f5      	b.n	80286d4 <arm_max_f32+0xbc>

080286e8 <arm_mean_f32>:

void arm_mean_f32(
  float32_t * pSrc,
  uint32_t blockSize,
  float32_t * pResult)
{
 80286e8:	b430      	push	{r4, r5}
  /*loop Unrolling */
  blkCnt = blockSize >> 2u;

  /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.
   ** a second loop below computes the remaining 1 to 3 samples. */
  while (blkCnt > 0u)
 80286ea:	088d      	lsrs	r5, r1, #2
 80286ec:	eddf 7a17 	vldr	s15, [pc, #92]	; 802874c <arm_mean_f32+0x64>
 80286f0:	d018      	beq.n	8028724 <arm_mean_f32+0x3c>
 80286f2:	f100 0310 	add.w	r3, r0, #16
 80286f6:	462c      	mov	r4, r5
    in1 = *pSrc++;
    in2 = *pSrc++;
    in3 = *pSrc++;
    in4 = *pSrc++;

    sum += in1;
 80286f8:	ed13 7a04 	vldr	s14, [r3, #-16]
    sum += in2;
 80286fc:	ed53 5a03 	vldr	s11, [r3, #-12]
    sum += in3;
 8028700:	ed13 6a02 	vldr	s12, [r3, #-8]
    sum += in4;
 8028704:	ed53 6a01 	vldr	s13, [r3, #-4]
    in1 = *pSrc++;
    in2 = *pSrc++;
    in3 = *pSrc++;
    in4 = *pSrc++;

    sum += in1;
 8028708:	ee37 7a87 	vadd.f32	s14, s15, s14
  /*loop Unrolling */
  blkCnt = blockSize >> 2u;

  /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.
   ** a second loop below computes the remaining 1 to 3 samples. */
  while (blkCnt > 0u)
 802870c:	3c01      	subs	r4, #1
    in2 = *pSrc++;
    in3 = *pSrc++;
    in4 = *pSrc++;

    sum += in1;
    sum += in2;
 802870e:	ee77 7a25 	vadd.f32	s15, s14, s11
 8028712:	f103 0310 	add.w	r3, r3, #16
    sum += in3;
 8028716:	ee77 7a86 	vadd.f32	s15, s15, s12
    sum += in4;
 802871a:	ee77 7aa6 	vadd.f32	s15, s15, s13
  /*loop Unrolling */
  blkCnt = blockSize >> 2u;

  /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.
   ** a second loop below computes the remaining 1 to 3 samples. */
  while (blkCnt > 0u)
 802871e:	d1eb      	bne.n	80286f8 <arm_mean_f32+0x10>
 8028720:	eb00 1005 	add.w	r0, r0, r5, lsl #4
  /* Loop over blockSize number of values */
  blkCnt = blockSize;

#endif /* #if defined (ARM_MATH_DSP) */

  while (blkCnt > 0u)
 8028724:	f011 0303 	ands.w	r3, r1, #3
 8028728:	d005      	beq.n	8028736 <arm_mean_f32+0x4e>
  {
    /* C = (A[0] + A[1] + A[2] + ... + A[blockSize-1]) */
    sum += *pSrc++;
 802872a:	ecb0 7a01 	vldmia	r0!, {s14}
  /* Loop over blockSize number of values */
  blkCnt = blockSize;

#endif /* #if defined (ARM_MATH_DSP) */

  while (blkCnt > 0u)
 802872e:	3b01      	subs	r3, #1
  {
    /* C = (A[0] + A[1] + A[2] + ... + A[blockSize-1]) */
    sum += *pSrc++;
 8028730:	ee77 7a87 	vadd.f32	s15, s15, s14
  /* Loop over blockSize number of values */
  blkCnt = blockSize;

#endif /* #if defined (ARM_MATH_DSP) */

  while (blkCnt > 0u)
 8028734:	d1f9      	bne.n	802872a <arm_mean_f32+0x42>
    blkCnt--;
  }

  /* C = (A[0] + A[1] + A[2] + ... + A[blockSize-1]) / blockSize  */
  /* Store the result to the destination */
  *pResult = sum / (float32_t) blockSize;
 8028736:	ee07 1a10 	vmov	s14, r1
 802873a:	eeb8 7a47 	vcvt.f32.u32	s14, s14
}
 802873e:	bc30      	pop	{r4, r5}
    blkCnt--;
  }

  /* C = (A[0] + A[1] + A[2] + ... + A[blockSize-1]) / blockSize  */
  /* Store the result to the destination */
  *pResult = sum / (float32_t) blockSize;
 8028740:	eec7 7a87 	vdiv.f32	s15, s15, s14
 8028744:	edc2 7a00 	vstr	s15, [r2]
}
 8028748:	4770      	bx	lr
 802874a:	bf00      	nop
 802874c:	00000000 	.word	0x00000000

08028750 <arm_cmplx_mag_f32>:

void arm_cmplx_mag_f32(
  float32_t * pSrc,
  float32_t * pDst,
  uint32_t numSamples)
{
 8028750:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  /*loop Unrolling */
  blkCnt = numSamples >> 2u;

  /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.
   ** a second loop below computes the remaining 1 to 3 samples. */
  while (blkCnt > 0u)
 8028754:	ea5f 0992 	movs.w	r9, r2, lsr #2

void arm_cmplx_mag_f32(
  float32_t * pSrc,
  float32_t * pDst,
  uint32_t numSamples)
{
 8028758:	b083      	sub	sp, #12
 802875a:	4606      	mov	r6, r0
  /*loop Unrolling */
  blkCnt = numSamples >> 2u;

  /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.
   ** a second loop below computes the remaining 1 to 3 samples. */
  while (blkCnt > 0u)
 802875c:	d078      	beq.n	8028850 <arm_cmplx_mag_f32+0x100>
   */
  CMSIS_INLINE __STATIC_INLINE arm_status arm_sqrt_f32(
  float32_t in,
  float32_t * pOut)
  {
    if (in >= 0.0f)
 802875e:	f04f 0800 	mov.w	r8, #0
 8028762:	f100 0420 	add.w	r4, r0, #32
 8028766:	f101 0510 	add.w	r5, r1, #16
 802876a:	464f      	mov	r7, r9
 802876c:	e054      	b.n	8028818 <arm_cmplx_mag_f32+0xc8>
#if   (__FPU_USED == 1) && defined ( __CC_ARM   )
      *pOut = __sqrtf(in);
#elif (__FPU_USED == 1) && (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
      *pOut = __builtin_sqrtf(in);
#elif (__FPU_USED == 1) && defined(__GNUC__)
      *pOut = __builtin_sqrtf(in);
 802876e:	eeb1 7ae7 	vsqrt.f32	s14, s15
 8028772:	eeb4 7a47 	vcmp.f32	s14, s14
 8028776:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802877a:	f040 809a 	bne.w	80288b2 <arm_cmplx_mag_f32+0x162>
 802877e:	ed05 7a04 	vstr	s14, [r5, #-16]
    imagIn = *pSrc++;
    /* store the result in the destination buffer. */
    arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);

    realIn = *pSrc++;
    imagIn = *pSrc++;
 8028782:	ed54 7a05 	vldr	s15, [r4, #-20]	; 0xffffffec
    realIn = *pSrc++;
    imagIn = *pSrc++;
    /* store the result in the destination buffer. */
    arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);

    realIn = *pSrc++;
 8028786:	ed14 7a06 	vldr	s14, [r4, #-24]	; 0xffffffe8
    imagIn = *pSrc++;
    arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);
 802878a:	ee67 7aa7 	vmul.f32	s15, s15, s15
 802878e:	eee7 7a07 	vfma.f32	s15, s14, s14
   */
  CMSIS_INLINE __STATIC_INLINE arm_status arm_sqrt_f32(
  float32_t in,
  float32_t * pOut)
  {
    if (in >= 0.0f)
 8028792:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8028796:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802879a:	f2c0 8087 	blt.w	80288ac <arm_cmplx_mag_f32+0x15c>
#if   (__FPU_USED == 1) && defined ( __CC_ARM   )
      *pOut = __sqrtf(in);
#elif (__FPU_USED == 1) && (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
      *pOut = __builtin_sqrtf(in);
#elif (__FPU_USED == 1) && defined(__GNUC__)
      *pOut = __builtin_sqrtf(in);
 802879e:	eeb1 7ae7 	vsqrt.f32	s14, s15
 80287a2:	eeb4 7a47 	vcmp.f32	s14, s14
 80287a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80287aa:	f040 80ac 	bne.w	8028906 <arm_cmplx_mag_f32+0x1b6>
 80287ae:	ed05 7a03 	vstr	s14, [r5, #-12]

    realIn = *pSrc++;
    imagIn = *pSrc++;
 80287b2:	ed54 7a03 	vldr	s15, [r4, #-12]

    realIn = *pSrc++;
    imagIn = *pSrc++;
    arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);

    realIn = *pSrc++;
 80287b6:	ed14 7a04 	vldr	s14, [r4, #-16]
    imagIn = *pSrc++;
    arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);
 80287ba:	ee67 7aa7 	vmul.f32	s15, s15, s15
 80287be:	eee7 7a07 	vfma.f32	s15, s14, s14
   */
  CMSIS_INLINE __STATIC_INLINE arm_status arm_sqrt_f32(
  float32_t in,
  float32_t * pOut)
  {
    if (in >= 0.0f)
 80287c2:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80287c6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80287ca:	db6c      	blt.n	80288a6 <arm_cmplx_mag_f32+0x156>
#if   (__FPU_USED == 1) && defined ( __CC_ARM   )
      *pOut = __sqrtf(in);
#elif (__FPU_USED == 1) && (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
      *pOut = __builtin_sqrtf(in);
#elif (__FPU_USED == 1) && defined(__GNUC__)
      *pOut = __builtin_sqrtf(in);
 80287cc:	eeb1 7ae7 	vsqrt.f32	s14, s15
 80287d0:	eeb4 7a47 	vcmp.f32	s14, s14
 80287d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80287d8:	f040 808a 	bne.w	80288f0 <arm_cmplx_mag_f32+0x1a0>
 80287dc:	ed05 7a02 	vstr	s14, [r5, #-8]

    realIn = *pSrc++;
    imagIn = *pSrc++;
 80287e0:	ed54 7a01 	vldr	s15, [r4, #-4]

    realIn = *pSrc++;
    imagIn = *pSrc++;
    arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);

    realIn = *pSrc++;
 80287e4:	ed14 7a02 	vldr	s14, [r4, #-8]
    imagIn = *pSrc++;
    arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);
 80287e8:	ee67 7aa7 	vmul.f32	s15, s15, s15
 80287ec:	eee7 7a07 	vfma.f32	s15, s14, s14
   */
  CMSIS_INLINE __STATIC_INLINE arm_status arm_sqrt_f32(
  float32_t in,
  float32_t * pOut)
  {
    if (in >= 0.0f)
 80287f0:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80287f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80287f8:	db1e      	blt.n	8028838 <arm_cmplx_mag_f32+0xe8>
#if   (__FPU_USED == 1) && defined ( __CC_ARM   )
      *pOut = __sqrtf(in);
#elif (__FPU_USED == 1) && (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
      *pOut = __builtin_sqrtf(in);
#elif (__FPU_USED == 1) && defined(__GNUC__)
      *pOut = __builtin_sqrtf(in);
 80287fa:	eeb1 7ae7 	vsqrt.f32	s14, s15
 80287fe:	eeb4 7a47 	vcmp.f32	s14, s14
 8028802:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8028806:	d168      	bne.n	80288da <arm_cmplx_mag_f32+0x18a>
  /*loop Unrolling */
  blkCnt = numSamples >> 2u;

  /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.
   ** a second loop below computes the remaining 1 to 3 samples. */
  while (blkCnt > 0u)
 8028808:	3f01      	subs	r7, #1
 802880a:	ed05 7a01 	vstr	s14, [r5, #-4]
 802880e:	f104 0420 	add.w	r4, r4, #32
 8028812:	f105 0510 	add.w	r5, r5, #16
 8028816:	d017      	beq.n	8028848 <arm_cmplx_mag_f32+0xf8>
  {

    /* C[0] = sqrt(A[0] * A[0] + A[1] * A[1]) */
    realIn = *pSrc++;
    imagIn = *pSrc++;
 8028818:	ed54 7a07 	vldr	s15, [r4, #-28]	; 0xffffffe4
   ** a second loop below computes the remaining 1 to 3 samples. */
  while (blkCnt > 0u)
  {

    /* C[0] = sqrt(A[0] * A[0] + A[1] * A[1]) */
    realIn = *pSrc++;
 802881c:	ed14 7a08 	vldr	s14, [r4, #-32]	; 0xffffffe0
    imagIn = *pSrc++;
    /* store the result in the destination buffer. */
    arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);
 8028820:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8028824:	eee7 7a07 	vfma.f32	s15, s14, s14
   */
  CMSIS_INLINE __STATIC_INLINE arm_status arm_sqrt_f32(
  float32_t in,
  float32_t * pOut)
  {
    if (in >= 0.0f)
 8028828:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 802882c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8028830:	da9d      	bge.n	802876e <arm_cmplx_mag_f32+0x1e>

      return (ARM_MATH_SUCCESS);
    }
    else
    {
      *pOut = 0.0f;
 8028832:	f845 8c10 	str.w	r8, [r5, #-16]
 8028836:	e7a4      	b.n	8028782 <arm_cmplx_mag_f32+0x32>
  /*loop Unrolling */
  blkCnt = numSamples >> 2u;

  /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.
   ** a second loop below computes the remaining 1 to 3 samples. */
  while (blkCnt > 0u)
 8028838:	3f01      	subs	r7, #1
 802883a:	f845 8c04 	str.w	r8, [r5, #-4]
 802883e:	f104 0420 	add.w	r4, r4, #32
 8028842:	f105 0510 	add.w	r5, r5, #16
 8028846:	d1e7      	bne.n	8028818 <arm_cmplx_mag_f32+0xc8>
 8028848:	eb06 1649 	add.w	r6, r6, r9, lsl #5
 802884c:	eb01 1109 	add.w	r1, r1, r9, lsl #4

  /* If the numSamples is not a multiple of 4, compute any remaining output samples here.
   ** No loop unrolling is used. */
  blkCnt = numSamples % 0x4u;

  while (blkCnt > 0u)
 8028850:	f012 0503 	ands.w	r5, r2, #3
 8028854:	d024      	beq.n	80288a0 <arm_cmplx_mag_f32+0x150>
   */
  CMSIS_INLINE __STATIC_INLINE arm_status arm_sqrt_f32(
  float32_t in,
  float32_t * pOut)
  {
    if (in >= 0.0f)
 8028856:	2700      	movs	r7, #0
 8028858:	f106 0408 	add.w	r4, r6, #8
 802885c:	e00c      	b.n	8028878 <arm_cmplx_mag_f32+0x128>
#if   (__FPU_USED == 1) && defined ( __CC_ARM   )
      *pOut = __sqrtf(in);
#elif (__FPU_USED == 1) && (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
      *pOut = __builtin_sqrtf(in);
#elif (__FPU_USED == 1) && defined(__GNUC__)
      *pOut = __builtin_sqrtf(in);
 802885e:	eeb1 7ae7 	vsqrt.f32	s14, s15
 8028862:	eeb4 7a47 	vcmp.f32	s14, s14
 8028866:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802886a:	d12d      	bne.n	80288c8 <arm_cmplx_mag_f32+0x178>
 802886c:	3d01      	subs	r5, #1
 802886e:	ed01 7a01 	vstr	s14, [r1, #-4]
 8028872:	f104 0408 	add.w	r4, r4, #8
 8028876:	d013      	beq.n	80288a0 <arm_cmplx_mag_f32+0x150>
  {
    /* C[0] = sqrt(A[0] * A[0] + A[1] * A[1]) */
    realIn = *pSrc++;
    imagIn = *pSrc++;
 8028878:	ed54 7a01 	vldr	s15, [r4, #-4]
  blkCnt = numSamples % 0x4u;

  while (blkCnt > 0u)
  {
    /* C[0] = sqrt(A[0] * A[0] + A[1] * A[1]) */
    realIn = *pSrc++;
 802887c:	ed14 7a02 	vldr	s14, [r4, #-8]
    imagIn = *pSrc++;
    /* store the result in the destination buffer. */
    arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);
 8028880:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8028884:	3104      	adds	r1, #4
 8028886:	eee7 7a07 	vfma.f32	s15, s14, s14
   */
  CMSIS_INLINE __STATIC_INLINE arm_status arm_sqrt_f32(
  float32_t in,
  float32_t * pOut)
  {
    if (in >= 0.0f)
 802888a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 802888e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8028892:	dae4      	bge.n	802885e <arm_cmplx_mag_f32+0x10e>

  /* If the numSamples is not a multiple of 4, compute any remaining output samples here.
   ** No loop unrolling is used. */
  blkCnt = numSamples % 0x4u;

  while (blkCnt > 0u)
 8028894:	3d01      	subs	r5, #1

      return (ARM_MATH_SUCCESS);
    }
    else
    {
      *pOut = 0.0f;
 8028896:	f841 7c04 	str.w	r7, [r1, #-4]
 802889a:	f104 0408 	add.w	r4, r4, #8
 802889e:	d1eb      	bne.n	8028878 <arm_cmplx_mag_f32+0x128>
    numSamples--;
  }

#endif /* #if defined (ARM_MATH_DSP) */

}
 80288a0:	b003      	add	sp, #12
 80288a2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80288a6:	f845 8c08 	str.w	r8, [r5, #-8]
 80288aa:	e799      	b.n	80287e0 <arm_cmplx_mag_f32+0x90>
 80288ac:	f845 8c0c 	str.w	r8, [r5, #-12]
 80288b0:	e77f      	b.n	80287b2 <arm_cmplx_mag_f32+0x62>
#if   (__FPU_USED == 1) && defined ( __CC_ARM   )
      *pOut = __sqrtf(in);
#elif (__FPU_USED == 1) && (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
      *pOut = __builtin_sqrtf(in);
#elif (__FPU_USED == 1) && defined(__GNUC__)
      *pOut = __builtin_sqrtf(in);
 80288b2:	ee17 0a90 	vmov	r0, s15
 80288b6:	e88d 0006 	stmia.w	sp, {r1, r2}
 80288ba:	f004 fbd5 	bl	802d068 <sqrtf>
 80288be:	e89d 0006 	ldmia.w	sp, {r1, r2}
 80288c2:	ee07 0a10 	vmov	s14, r0
 80288c6:	e75a      	b.n	802877e <arm_cmplx_mag_f32+0x2e>
 80288c8:	ee17 0a90 	vmov	r0, s15
 80288cc:	9100      	str	r1, [sp, #0]
 80288ce:	f004 fbcb 	bl	802d068 <sqrtf>
 80288d2:	9900      	ldr	r1, [sp, #0]
 80288d4:	ee07 0a10 	vmov	s14, r0
 80288d8:	e7c8      	b.n	802886c <arm_cmplx_mag_f32+0x11c>
 80288da:	ee17 0a90 	vmov	r0, s15
 80288de:	e88d 0006 	stmia.w	sp, {r1, r2}
 80288e2:	f004 fbc1 	bl	802d068 <sqrtf>
 80288e6:	e89d 0006 	ldmia.w	sp, {r1, r2}
 80288ea:	ee07 0a10 	vmov	s14, r0
 80288ee:	e78b      	b.n	8028808 <arm_cmplx_mag_f32+0xb8>
 80288f0:	ee17 0a90 	vmov	r0, s15
 80288f4:	e88d 0006 	stmia.w	sp, {r1, r2}
 80288f8:	f004 fbb6 	bl	802d068 <sqrtf>
 80288fc:	e89d 0006 	ldmia.w	sp, {r1, r2}
 8028900:	ee07 0a10 	vmov	s14, r0
 8028904:	e76a      	b.n	80287dc <arm_cmplx_mag_f32+0x8c>
 8028906:	ee17 0a90 	vmov	r0, s15
 802890a:	e88d 0006 	stmia.w	sp, {r1, r2}
 802890e:	f004 fbab 	bl	802d068 <sqrtf>
 8028912:	e89d 0006 	ldmia.w	sp, {r1, r2}
 8028916:	ee07 0a10 	vmov	s14, r0
 802891a:	e748      	b.n	80287ae <arm_cmplx_mag_f32+0x5e>

0802891c <CLOCK_XMC4_Init>:
{
  CLOCK_XMC4_STATUS_t status = CLOCK_XMC4_STATUS_SUCCESS;

  XMC_ASSERT("CLOCK_XMC4 APP handle function pointer uninitialized", (handle != NULL));

  handle->init_status = true;
 802891c:	2301      	movs	r3, #1
 802891e:	7003      	strb	r3, [r0, #0]

  return (status);
}
 8028920:	2000      	movs	r0, #0
 8028922:	4770      	bx	lr

08028924 <OSCHP_GetFrequency>:
#ifdef CLOCK_XMC4_OSCHP_ENABLED
/*  API to retrieve high precision external oscillator frequency */
uint32_t OSCHP_GetFrequency(void)
{
  return (CLOCK_XMC4_OSCHP_FREQUENCY);
}
 8028924:	4800      	ldr	r0, [pc, #0]	; (8028928 <OSCHP_GetFrequency+0x4>)
 8028926:	4770      	bx	lr
 8028928:	02625a00 	.word	0x02625a00

0802892c <SystemCoreClockSetup>:
* @note   -
* @param  None
* @retval None
*/
void SystemCoreClockSetup(void)
{
 802892c:	b530      	push	{r4, r5, lr}
  /* Local data structure for initializing the clock functional block */
  const XMC_SCU_CLOCK_CONFIG_t CLOCK_XMC4_0_CONFIG =
 802892e:	4d11      	ldr	r5, [pc, #68]	; (8028974 <SystemCoreClockSetup+0x48>)
 8028930:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
* @note   -
* @param  None
* @retval None
*/
void SystemCoreClockSetup(void)
{
 8028932:	b087      	sub	sp, #28
  /* Local data structure for initializing the clock functional block */
  const XMC_SCU_CLOCK_CONFIG_t CLOCK_XMC4_0_CONFIG =
 8028934:	ac01      	add	r4, sp, #4
 8028936:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8028938:	682b      	ldr	r3, [r5, #0]
 802893a:	6023      	str	r3, [r4, #0]
#endif
    /* Peripheral Clock Divider Value */
    .fperipheral_clkdiv = 1U
  };
  /* Initialize the SCU clock */
  XMC_SCU_CLOCK_Init(&CLOCK_XMC4_0_CONFIG);
 802893c:	a801      	add	r0, sp, #4
 802893e:	f7f9 f877 	bl	8021a30 <XMC_SCU_CLOCK_Init>
  /* RTC source clock */
  XMC_SCU_HIB_SetRtcClockSource(XMC_SCU_HIB_RTCCLKSRC_OSI);
 8028942:	2000      	movs	r0, #0
 8028944:	f7f8 ff0c 	bl	8021760 <XMC_SCU_HIB_SetRtcClockSource>
  
#ifdef CLOCK_XMC4_USBCLK_ENABLED  
  /* USB/SDMMC source clock */
  XMC_SCU_CLOCK_SetUsbClockSource(XMC_SCU_CLOCK_USBCLKSRC_USBPLL);
 8028948:	2000      	movs	r0, #0
 802894a:	f7f8 fef5 	bl	8021738 <XMC_SCU_CLOCK_SetUsbClockSource>
  /* USB/SDMMC divider setting */
  XMC_SCU_CLOCK_SetUsbClockDivider(4U);
 802894e:	2004      	movs	r0, #4
 8028950:	f7f8 ff16 	bl	8021780 <XMC_SCU_CLOCK_SetUsbClockDivider>
#endif
  /* Start USB PLL */
  XMC_SCU_CLOCK_StartUsbPll(5U, 48U);
 8028954:	2130      	movs	r1, #48	; 0x30
 8028956:	2005      	movs	r0, #5
 8028958:	f7f8 ff5e 	bl	8021818 <XMC_SCU_CLOCK_StartUsbPll>

#ifdef CLOCK_XMC4_WDTCLK_ENABLED    
  /* WDT source clock */
  XMC_SCU_CLOCK_SetWdtClockSource(XMC_SCU_CLOCK_WDTCLKSRC_OFI);
 802895c:	2000      	movs	r0, #0
 802895e:	f7f8 fef5 	bl	802174c <XMC_SCU_CLOCK_SetWdtClockSource>
  /* WDT divider setting */
  XMC_SCU_CLOCK_SetWdtClockDivider(1U);
 8028962:	2001      	movs	r0, #1
 8028964:	f7f8 ff20 	bl	80217a8 <XMC_SCU_CLOCK_SetWdtClockDivider>
#endif

#ifdef CLOCK_XMC4_EBUCLK_ENABLED 
  /* EBU divider setting */
  XMC_SCU_CLOCK_SetEbuClockDivider(1U);
 8028968:	2001      	movs	r0, #1
 802896a:	f7f8 ff13 	bl	8021794 <XMC_SCU_CLOCK_SetEbuClockDivider>
#endif

}
 802896e:	b007      	add	sp, #28
 8028970:	bd30      	pop	{r4, r5, pc}
 8028972:	bf00      	nop
 8028974:	08031b98 	.word	0x08031b98

08028978 <CCU4_SLICE_CONFIG_Init>:
}

/* API to initialize the CCU4 slice */
CCU4_SLICE_CONFIG_STATUS_t CCU4_SLICE_CONFIG_Init(const CCU4_SLICE_CONFIG_t *const handle_ptr)
{
  return handle_ptr->init();
 8028978:	6803      	ldr	r3, [r0, #0]
 802897a:	4718      	bx	r3

0802897c <CCU4_SLICE_CONFIG_ADC_TRIG_lInit>:
  .level               = XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_HIGH,
  .duration            = XMC_CCU4_SLICE_EVENT_FILTER_DISABLED                               
 };
            /* Channel initialization function */
CCU4_SLICE_CONFIG_STATUS_t CCU4_SLICE_CONFIG_ADC_TRIG_lInit(void)
{
 802897c:	b570      	push	{r4, r5, r6, lr}
  GLOBAL_CCU4_Init(&GLOBAL_CCU4_0);
  /* Configure CCU4x_CC4y slice as timer unit */
  XMC_CCU4_SLICE_CompareInit(CCU43_CC43, &CCU4_SLICE_CONFIG_ADC_TRIG_compare_config);
 802897e:	4c21      	ldr	r4, [pc, #132]	; (8028a04 <CCU4_SLICE_CONFIG_ADC_TRIG_lInit+0x88>)
  .duration            = XMC_CCU4_SLICE_EVENT_FILTER_DISABLED                               
 };
            /* Channel initialization function */
CCU4_SLICE_CONFIG_STATUS_t CCU4_SLICE_CONFIG_ADC_TRIG_lInit(void)
{
  GLOBAL_CCU4_Init(&GLOBAL_CCU4_0);
 8028980:	4821      	ldr	r0, [pc, #132]	; (8028a08 <CCU4_SLICE_CONFIG_ADC_TRIG_lInit+0x8c>)
  /* Set timer compare register value */
  XMC_CCU4_SLICE_SetTimerCompareMatch(CCU43_CC43, (uint16_t)32768U);
  /* Set timer period register value */
  XMC_CCU4_SLICE_SetTimerPeriodMatch(CCU43_CC43, (uint16_t)65535U);	
  /* Register value update settings */
  XMC_CCU4_SetMultiChannelShadowTransferMode(CCU43, (uint32_t)XMC_CCU4_MULTI_CHANNEL_SHADOW_TRANSFER_SW_SLICE3);
 8028982:	4d22      	ldr	r5, [pc, #136]	; (8028a0c <CCU4_SLICE_CONFIG_ADC_TRIG_lInit+0x90>)
  .duration            = XMC_CCU4_SLICE_EVENT_FILTER_DISABLED                               
 };
            /* Channel initialization function */
CCU4_SLICE_CONFIG_STATUS_t CCU4_SLICE_CONFIG_ADC_TRIG_lInit(void)
{
  GLOBAL_CCU4_Init(&GLOBAL_CCU4_0);
 8028984:	f7fe fbec 	bl	8027160 <GLOBAL_CCU4_Init>
  /* Configure CCU4x_CC4y slice as timer unit */
  XMC_CCU4_SLICE_CompareInit(CCU43_CC43, &CCU4_SLICE_CONFIG_ADC_TRIG_compare_config);
 8028988:	4620      	mov	r0, r4
 802898a:	4921      	ldr	r1, [pc, #132]	; (8028a10 <CCU4_SLICE_CONFIG_ADC_TRIG_lInit+0x94>)
 802898c:	f7f9 f9a0 	bl	8021cd0 <XMC_CCU4_SLICE_CompareInit>
 *  XMC_CCU4_SLICE_GetTimerValue().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerValue(XMC_CCU4_SLICE_t *const slice, const uint16_t timer_val)
{
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerValue:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TIMER = (uint32_t) timer_val;
 8028990:	2600      	movs	r6, #0
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerCompareMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t compare_val)
{
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->CRS = (uint32_t) compare_val;
 8028992:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerPeriodMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t period_val)
{
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->PRS = (uint32_t) period_val;
 8028996:	f64f 73ff 	movw	r3, #65535	; 0xffff
 *  XMC_CCU4_SLICE_GetTimerValue().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerValue(XMC_CCU4_SLICE_t *const slice, const uint16_t timer_val)
{
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerValue:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TIMER = (uint32_t) timer_val;
 802899a:	6726      	str	r6, [r4, #112]	; 0x70
  /* Set timer compare register value */
  XMC_CCU4_SLICE_SetTimerCompareMatch(CCU43_CC43, (uint16_t)32768U);
  /* Set timer period register value */
  XMC_CCU4_SLICE_SetTimerPeriodMatch(CCU43_CC43, (uint16_t)65535U);	
  /* Register value update settings */
  XMC_CCU4_SetMultiChannelShadowTransferMode(CCU43, (uint32_t)XMC_CCU4_MULTI_CHANNEL_SHADOW_TRANSFER_SW_SLICE3);
 802899c:	4628      	mov	r0, r5
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerCompareMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t compare_val)
{
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->CRS = (uint32_t) compare_val;
 802899e:	63e2      	str	r2, [r4, #60]	; 0x3c
 80289a0:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerPeriodMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t period_val)
{
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->PRS = (uint32_t) period_val;
 80289a4:	6363      	str	r3, [r4, #52]	; 0x34
 80289a6:	f7f9 f98b 	bl	8021cc0 <XMC_CCU4_SetMultiChannelShadowTransferMode>
 *  None.
 */
__STATIC_INLINE void XMC_CCU4_EnableShadowTransfer(XMC_CCU4_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
  XMC_ASSERT("XMC_CCU4_EnableShadowTransfer:Invalid Slice Pointer", XMC_CCU4_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;  
 80289aa:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 80289ae:	612b      	str	r3, [r5, #16]
  /* Transfer value from shadow registers to actual timer registers */
  XMC_CCU4_EnableShadowTransfer(CCU43, (uint32_t)XMC_CCU4_SHADOW_TRANSFER_SLICE_3 |
                                               (uint32_t)XMC_CCU4_SHADOW_TRANSFER_DITHER_SLICE_3 |
                                               (uint32_t)XMC_CCU4_SHADOW_TRANSFER_PRESCALER_SLICE_3);
  /* Events and function settings */
  XMC_CCU4_SLICE_ConfigureEvent(CCU43_CC43, XMC_CCU4_SLICE_EVENT_0, &CCU4_SLICE_CONFIG_ADC_TRIG_event0_config);
 80289b0:	4620      	mov	r0, r4
 80289b2:	2101      	movs	r1, #1
 80289b4:	4a17      	ldr	r2, [pc, #92]	; (8028a14 <CCU4_SLICE_CONFIG_ADC_TRIG_lInit+0x98>)
 80289b6:	f7f9 f9c1 	bl	8021d3c <XMC_CCU4_SLICE_ConfigureEvent>
  XMC_CCU4_SLICE_ConfigureEvent(CCU43_CC43, XMC_CCU4_SLICE_EVENT_1, &CCU4_SLICE_CONFIG_ADC_TRIG_event1_config);
 80289ba:	4620      	mov	r0, r4
 80289bc:	2102      	movs	r1, #2
 80289be:	4a16      	ldr	r2, [pc, #88]	; (8028a18 <CCU4_SLICE_CONFIG_ADC_TRIG_lInit+0x9c>)
 80289c0:	f7f9 f9bc 	bl	8021d3c <XMC_CCU4_SLICE_ConfigureEvent>
  XMC_CCU4_SLICE_ConfigureEvent(CCU43_CC43, XMC_CCU4_SLICE_EVENT_2, &CCU4_SLICE_CONFIG_ADC_TRIG_event2_config);
 80289c4:	4620      	mov	r0, r4
 80289c6:	2103      	movs	r1, #3
 80289c8:	4a14      	ldr	r2, [pc, #80]	; (8028a1c <CCU4_SLICE_CONFIG_ADC_TRIG_lInit+0xa0>)
 80289ca:	f7f9 f9b7 	bl	8021d3c <XMC_CCU4_SLICE_ConfigureEvent>
  XMC_CCU4_SLICE_StartConfig(CCU43_CC43, XMC_CCU4_SLICE_EVENT_0, XMC_CCU4_SLICE_START_MODE_TIMER_START);
 80289ce:	4620      	mov	r0, r4
 80289d0:	4632      	mov	r2, r6
 80289d2:	2101      	movs	r1, #1
 80289d4:	f7f9 f996 	bl	8021d04 <XMC_CCU4_SLICE_StartConfig>
  XMC_CCU4_SLICE_StopConfig(CCU43_CC43, XMC_CCU4_SLICE_EVENT_1, XMC_CCU4_SLICE_END_MODE_TIMER_STOP_CLEAR);
 80289d8:	2102      	movs	r1, #2
 80289da:	4620      	mov	r0, r4
 80289dc:	460a      	mov	r2, r1
 80289de:	f7f9 f99f 	bl	8021d20 <XMC_CCU4_SLICE_StopConfig>
  XMC_CCU4_SLICE_SetInterruptNode(CCU43_CC43, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH, XMC_CCU4_SLICE_SR_ID_3);
 80289e2:	4620      	mov	r0, r4
 80289e4:	4631      	mov	r1, r6
 80289e6:	2203      	movs	r2, #3
 80289e8:	f7f9 f9ec 	bl	8021dc4 <XMC_CCU4_SLICE_SetInterruptNode>
 *  XMC_CCU4_SLICE_DisableMultipleEvents().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_EnableMultipleEvents(XMC_CCU4_SLICE_t *const slice, const uint16_t intr_mask)
{
  XMC_ASSERT("XMC_CCU4_SLICE_EnableMultipleEvents:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->INTE |= (uint32_t)intr_mask;
 80289ec:	f8d4 30a4 	ldr.w	r3, [r4, #164]	; 0xa4
 80289f0:	f043 0301 	orr.w	r3, r3, #1
 80289f4:	f8c4 30a4 	str.w	r3, [r4, #164]	; 0xa4
__STATIC_INLINE void XMC_CCU4_EnableClock(XMC_CCU4_MODULE_t *const module, const uint8_t slice_number)
{
  XMC_ASSERT("XMC_CCU4_EnableClock:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  XMC_ASSERT("XMC_CCU4_EnableClock:Invalid Slice Number", (slice_number < 4U));

  module->GIDLC |= ((uint32_t) 1) << slice_number;
 80289f8:	68eb      	ldr	r3, [r5, #12]
 80289fa:	f043 0308 	orr.w	r3, r3, #8
  XMC_CCU4_SLICE_EnableMultipleEvents(CCU43_CC43, XMC_CCU4_SLICE_MULTI_IRQ_ID_PERIOD_MATCH);
  /* clear IDLE mode for the slice*/
  XMC_CCU4_EnableClock(CCU43, (uint8_t)3);	
  return CCU4_SLICE_CONFIG_STATUS_SUCCESS;
}
 80289fe:	4630      	mov	r0, r6
 8028a00:	60eb      	str	r3, [r5, #12]
 8028a02:	bd70      	pop	{r4, r5, r6, pc}
 8028a04:	48004400 	.word	0x48004400
 8028a08:	1ffe89dc 	.word	0x1ffe89dc
 8028a0c:	48004000 	.word	0x48004000
 8028a10:	08031bc4 	.word	0x08031bc4
 8028a14:	08031bcc 	.word	0x08031bcc
 8028a18:	08031bac 	.word	0x08031bac
 8028a1c:	08031bb0 	.word	0x08031bb0

08028a20 <ADC_MEASUREMENT_ADV_SoftwareTrigger>:
{
  XMC_ASSERT("ADC_MEASUREMENT_ADV_StartConversion:Invalid handle_ptr", (handle_ptr != NULL))

#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8028a20:	7d03      	ldrb	r3, [r0, #20]
  #endif
    {
      XMC_VADC_GROUP_ScanTriggerConversion(group_ptrs[handle_ptr->group_index]);
 8028a22:	7d82      	ldrb	r2, [r0, #22]
{
  XMC_ASSERT("ADC_MEASUREMENT_ADV_StartConversion:Invalid handle_ptr", (handle_ptr != NULL))

#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8028a24:	2b01      	cmp	r3, #1
  #endif
    {
      XMC_VADC_GROUP_ScanTriggerConversion(group_ptrs[handle_ptr->group_index]);
 8028a26:	4b09      	ldr	r3, [pc, #36]	; (8028a4c <ADC_MEASUREMENT_ADV_SoftwareTrigger+0x2c>)
 8028a28:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
{
  XMC_ASSERT("ADC_MEASUREMENT_ADV_StartConversion:Invalid handle_ptr", (handle_ptr != NULL))

#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8028a2c:	d906      	bls.n	8028a3c <ADC_MEASUREMENT_ADV_SoftwareTrigger+0x1c>
 *  XMC_VADC_GROUP_QueueInsertChannel()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_QueueTriggerConversion(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueTriggerConversion:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->QMR0 |= (uint32_t)((uint32_t)1 << VADC_G_QMR0_TREV_Pos);
 8028a2e:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
 8028a32:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8028a36:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
 8028a3a:	4770      	bx	lr
 *  None.
 */
__STATIC_INLINE void XMC_VADC_GROUP_ScanTriggerConversion(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanTriggerConversion:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->ASMR |= (uint32_t)VADC_G_ASMR_LDEV_Msk;
 8028a3c:	f8d2 3124 	ldr.w	r3, [r2, #292]	; 0x124
 8028a40:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8028a44:	f8c2 3124 	str.w	r3, [r2, #292]	; 0x124
 8028a48:	4770      	bx	lr
 8028a4a:	bf00      	nop
 8028a4c:	08031bd0 	.word	0x08031bd0

08028a50 <ADC_MEASUREMENT_ADV_Init>:
#ifdef ADC_MEASUREMENT_ADV_SHS_GAIN_NON_DEFAULT
  uint8_t channel_number;
#endif
  bool arbitration_status = (bool)false;

  if (ADC_MEASUREMENT_ADV_STATUS_UNINITIALIZED == *handle_ptr->init_state)
 8028a50:	6903      	ldr	r3, [r0, #16]
 8028a52:	781b      	ldrb	r3, [r3, #0]
 8028a54:	2b02      	cmp	r3, #2
 8028a56:	d001      	beq.n	8028a5c <ADC_MEASUREMENT_ADV_Init+0xc>
#endif

    *handle_ptr->init_state = status;
  }
  return (*handle_ptr->init_state);
}
 8028a58:	4618      	mov	r0, r3
 8028a5a:	4770      	bx	lr
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Initialization routine to call ADC LLD API's */
ADC_MEASUREMENT_ADV_STATUS_t ADC_MEASUREMENT_ADV_Init(const ADC_MEASUREMENT_ADV_t *const handle_ptr)
{
 8028a5c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8028a60:	4605      	mov	r5, r0
  /* To check if the arbiter is already enabled. Before checking this ensure that clock and reset states are correct */
#if defined(CLOCK_GATING_SUPPORTED) && defined(ADC_MEASUREMENT_ADV_CHECK_CLOCK_GATING)
  clock_reset_check = !XMC_SCU_CLOCK_IsPeripheralClockGated(XMC_SCU_PERIPHERAL_CLOCK_VADC);
#endif
#ifdef PERIPHERAL_RESET_SUPPORTED
  clock_reset_check |= !XMC_SCU_RESET_IsPeripheralResetAsserted(XMC_SCU_PERIPHERAL_RESET_VADC);
 8028a62:	2001      	movs	r0, #1
 8028a64:	f7f8 fe58 	bl	8021718 <XMC_SCU_RESET_IsPeripheralResetAsserted>
#endif
  if(clock_reset_check != (bool)false)
 8028a68:	2800      	cmp	r0, #0
 8028a6a:	f040 80c8 	bne.w	8028bfe <ADC_MEASUREMENT_ADV_Init+0x1ae>
  {
#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8028a6e:	7d2b      	ldrb	r3, [r5, #20]
  #endif
      {
        arbitration_status = XMC_VADC_GROUP_ScanIsArbitrationSlotEnabled(group_ptrs[handle_ptr->group_index]);
 8028a70:	4e94      	ldr	r6, [pc, #592]	; (8028cc4 <ADC_MEASUREMENT_ADV_Init+0x274>)
#endif
  if(clock_reset_check != (bool)false)
  {
#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8028a72:	2b01      	cmp	r3, #1
  #endif
      {
        arbitration_status = XMC_VADC_GROUP_ScanIsArbitrationSlotEnabled(group_ptrs[handle_ptr->group_index]);
 8028a74:	7dab      	ldrb	r3, [r5, #22]
 8028a76:	f856 4023 	ldr.w	r4, [r6, r3, lsl #2]
 */
__STATIC_INLINE bool XMC_VADC_GROUP_ScanIsArbitrationSlotEnabled(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanIsArbitrationSlotEnabled:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  return ((group_ptr->ARBPR & (uint32_t)VADC_G_ARBPR_ASEN1_Msk) >> VADC_G_ARBPR_ASEN1_Pos);
 8028a7a:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
#endif
  if(clock_reset_check != (bool)false)
  {
#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8028a7e:	f240 81fb 	bls.w	8028e78 <ADC_MEASUREMENT_ADV_Init+0x428>
 */
__STATIC_INLINE bool XMC_VADC_GROUP_QueueIsArbitrationSlotEnabled(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueIsArbitrationSlotEnabled:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  return ((group_ptr->ARBPR & (uint32_t)VADC_G_ARBPR_ASEN0_Msk) >> VADC_G_ARBPR_ASEN0_Pos);
 8028a82:	f3c3 6900 	ubfx	r9, r3, #24, #1
                                                           uint8_t group_index)
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

  /*Initialization of APP 'GLOBAL_ADC'*/
  status = (ADC_MEASUREMENT_ADV_STATUS_t) GLOBAL_ADC_Init(ADC_MEASUREMENT_ADV_GLOBAL_HANDLE);
 8028a86:	4890      	ldr	r0, [pc, #576]	; (8028cc8 <ADC_MEASUREMENT_ADV_Init+0x278>)
#ifdef ADC_MEASUREMENT_ADV_LOCAL_QUEUE_USED
  #ifdef ADC_MEASUREMENT_ADV_ADC_QUEUE_USED
      if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_QUEUE != handle_ptr->req_src)
  #endif
      {
        status = ADC_MEASUREMENT_ADV_lQueueInit(handle_ptr->local_queue_handle,handle_ptr->group_index);
 8028a88:	68ef      	ldr	r7, [r5, #12]
                                                           uint8_t group_index)
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

  /*Initialization of APP 'GLOBAL_ADC'*/
  status = (ADC_MEASUREMENT_ADV_STATUS_t) GLOBAL_ADC_Init(ADC_MEASUREMENT_ADV_GLOBAL_HANDLE);
 8028a8a:	f7fe fb7d 	bl	8027188 <GLOBAL_ADC_Init>

  /*Class Configuration*/
  XMC_VADC_GROUP_InputClassInit(group_ptrs[group_index],handle_ptr->iclass_config_handle,
 8028a8e:	7ebb      	ldrb	r3, [r7, #26]
 8028a90:	6939      	ldr	r1, [r7, #16]
 8028a92:	2200      	movs	r2, #0
                                                           uint8_t group_index)
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

  /*Initialization of APP 'GLOBAL_ADC'*/
  status = (ADC_MEASUREMENT_ADV_STATUS_t) GLOBAL_ADC_Init(ADC_MEASUREMENT_ADV_GLOBAL_HANDLE);
 8028a94:	4680      	mov	r8, r0

  /*Class Configuration*/
  XMC_VADC_GROUP_InputClassInit(group_ptrs[group_index],handle_ptr->iclass_config_handle,
 8028a96:	4620      	mov	r0, r4
 8028a98:	f7fa ff3c 	bl	8023914 <XMC_VADC_GROUP_InputClassInit>
                                XMC_VADC_GROUP_CONV_STD,handle_ptr->iclass_num);

  /* Initialize the Queue hardware */
  XMC_VADC_GROUP_QueueInit(group_ptrs[group_index],handle_ptr->queue_config_handle);
 8028a9c:	4620      	mov	r0, r4
 8028a9e:	6979      	ldr	r1, [r7, #20]
 8028aa0:	f7fa fff4 	bl	8023a8c <XMC_VADC_GROUP_QueueInit>
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueSetGatingMode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_QueueSetGatingMode:Wrong mode selected", (mode_sel <= XMC_VADC_GATEMODE_ACTIVELOW))

  /* Clear the existing gate configuration */
  group_ptr->QMR0 &= (uint32_t)(~((uint32_t) VADC_G_QMR0_ENGT_Msk));
 8028aa4:	f8d4 2104 	ldr.w	r2, [r4, #260]	; 0x104

  /* Configure the gating mode for queue*/
  XMC_VADC_GROUP_QueueSetGatingMode(group_ptrs[group_index], handle_ptr->gating_mode);
 8028aa8:	7e38      	ldrb	r0, [r7, #24]

  /*Interrupt Configuration*/
  if ((bool)true == handle_ptr->rs_intr_handle.interrupt_enable)
 8028aaa:	7b39      	ldrb	r1, [r7, #12]
 8028aac:	f022 0203 	bic.w	r2, r2, #3
 8028ab0:	f8c4 2104 	str.w	r2, [r4, #260]	; 0x104
  /* Set the new gating mode */
  group_ptr->QMR0 |= (uint32_t)((uint32_t)mode_sel << VADC_G_QMR0_ENGT_Pos);
 8028ab4:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
 8028ab8:	4303      	orrs	r3, r0
 8028aba:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
 8028abe:	b389      	cbz	r1, 8028b24 <ADC_MEASUREMENT_ADV_Init+0xd4>
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8028ac0:	4b82      	ldr	r3, [pc, #520]	; (8028ccc <ADC_MEASUREMENT_ADV_Init+0x27c>)
  {
#if (UC_FAMILY == XMC1)
    NVIC_SetPriority((IRQn_Type)handle_ptr->rs_intr_handle.node_id, handle_ptr->rs_intr_handle.priority);
#else
    NVIC_SetPriority((IRQn_Type)handle_ptr->rs_intr_handle.node_id,
 8028ac2:	f8d7 e000 	ldr.w	lr, [r7]
 8028ac6:	68db      	ldr	r3, [r3, #12]
 8028ac8:	6878      	ldr	r0, [r7, #4]
 8028aca:	f8d7 c008 	ldr.w	ip, [r7, #8]
 8028ace:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8028ad2:	f1c3 0a07 	rsb	sl, r3, #7
 8028ad6:	f1ba 0f06 	cmp.w	sl, #6
 8028ada:	bf28      	it	cs
 8028adc:	f04f 0a06 	movcs.w	sl, #6
 8028ae0:	fa5f f18e 	uxtb.w	r1, lr
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8028ae4:	2b00      	cmp	r3, #0
 8028ae6:	f040 818d 	bne.w	8028e04 <ADC_MEASUREMENT_ADV_Init+0x3b4>
 8028aea:	461a      	mov	r2, r3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8028aec:	f04f 0c01 	mov.w	ip, #1
 8028af0:	fa0c fc0a 	lsl.w	ip, ip, sl
 8028af4:	f10c 3cff 	add.w	ip, ip, #4294967295
 8028af8:	ea0c 0000 	and.w	r0, ip, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8028afc:	b249      	sxtb	r1, r1

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8028afe:	fa00 f202 	lsl.w	r2, r0, r2
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8028b02:	2900      	cmp	r1, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 8028b04:	ea43 0302 	orr.w	r3, r3, r2
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8028b08:	f2c0 81ae 	blt.w	8028e68 <ADC_MEASUREMENT_ADV_Init+0x418>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8028b0c:	f101 4260 	add.w	r2, r1, #3758096384	; 0xe0000000
 8028b10:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 8028b14:	009b      	lsls	r3, r3, #2
 8028b16:	b2db      	uxtb	r3, r3
 8028b18:	f882 3300 	strb.w	r3, [r2, #768]	; 0x300
    XMC_SCU_SetInterruptControl(handle_ptr->rs_intr_handle.node_id,
                                ((handle_ptr->rs_intr_handle.node_id << 8) | handle_ptr->rs_intr_handle.irqctrl));
#endif

    /* Connect RS Events to NVIC nodes */
    XMC_VADC_GROUP_QueueSetReqSrcEventInterruptNode(group_ptrs[group_index], (XMC_VADC_SR_t)handle_ptr->srv_req_node);
 8028b1c:	4620      	mov	r0, r4
 8028b1e:	7e79      	ldrb	r1, [r7, #25]
 8028b20:	f7fa fff8 	bl	8023b14 <XMC_VADC_GROUP_QueueSetReqSrcEventInterruptNode>

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
__STATIC_INLINE void ADC_MEASUREMENT_ADV_lDisableArbitration(const ADC_MEASUREMENT_ADV_t *const handle_ptr,
                                                             bool arbitration_status)
{
  if(arbitration_status == (bool)false)
 8028b24:	f1b9 0f00 	cmp.w	r9, #0
 8028b28:	d10d      	bne.n	8028b46 <ADC_MEASUREMENT_ADV_Init+0xf6>
  {
#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
      if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8028b2a:	7d2b      	ldrb	r3, [r5, #20]
 8028b2c:	2b01      	cmp	r3, #1
  #endif
      {
        XMC_VADC_GROUP_ScanDisableArbitrationSlot(group_ptrs[handle_ptr->group_index]);
 8028b2e:	7dab      	ldrb	r3, [r5, #22]
 8028b30:	f856 2023 	ldr.w	r2, [r6, r3, lsl #2]
 *  XMC_VADC_GROUP_ScanEnableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_ScanDisableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanDisableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->ARBPR &= ~((uint32_t)VADC_G_ARBPR_ASEN1_Msk);
 8028b34:	f8d2 3084 	ldr.w	r3, [r2, #132]	; 0x84
 8028b38:	bf94      	ite	ls
 8028b3a:	f023 7300 	bicls.w	r3, r3, #33554432	; 0x2000000
 *  XMC_VADC_GROUP_QueueEnableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_QueueDisableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueDisableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr));
  group_ptr->ARBPR &= ~((uint32_t)VADC_G_ARBPR_ASEN0_Msk);
 8028b3e:	f023 7380 	bichi.w	r3, r3, #16777216	; 0x1000000
 8028b42:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
   /* Disable the Arbitration if no other instance has enabled it*/
   ADC_MEASUREMENT_ADV_lDisableArbitration(handle_ptr,arbitration_status);

#ifdef ADC_MEASUREMENT_ADV_SYNC_USED
  #ifdef ADC_MEASUREMENT_ADV_SYNC_NOT_ALL_USED
    if ((uint32_t)0 != handle_ptr->sync_slaves)
 8028b46:	7d6b      	ldrb	r3, [r5, #21]
 8028b48:	2b00      	cmp	r3, #0
 8028b4a:	f040 80c1 	bne.w	8028cd0 <ADC_MEASUREMENT_ADV_Init+0x280>
#endif

    /* Initialize the SR lines for the Channel event and the Result event, if required*/
#ifdef ADC_MEASUREMENT_ADV_MUX_USED
  #ifdef ADC_MEASUREMENT_ADV_MUX_NOT_ALL_USED
    if (handle_ptr->event_config != NULL)
 8028b4e:	68ab      	ldr	r3, [r5, #8]
 8028b50:	b103      	cbz	r3, 8028b54 <ADC_MEASUREMENT_ADV_Init+0x104>
  #endif
    {
      (handle_ptr->event_config)();
 8028b52:	4798      	blx	r3
    }
#endif

    total_number_of_channels = (uint8_t)handle_ptr->total_number_of_channels;
 8028b54:	7e2b      	ldrb	r3, [r5, #24]
    for (ch_num = (uint8_t)0; ch_num < (uint8_t)total_number_of_channels; ch_num++)
 8028b56:	b1fb      	cbz	r3, 8028b98 <ADC_MEASUREMENT_ADV_Init+0x148>
 8028b58:	1e5f      	subs	r7, r3, #1
 8028b5a:	b2ff      	uxtb	r7, r7
 8028b5c:	3701      	adds	r7, #1
 8028b5e:	00bf      	lsls	r7, r7, #2
 8028b60:	f04f 0900 	mov.w	r9, #0
    {
      indexed = handle_ptr->channel_array[ch_num];
 8028b64:	682b      	ldr	r3, [r5, #0]
 8028b66:	f853 4009 	ldr.w	r4, [r3, r9]

      /* Initialize for configured channels*/
      XMC_VADC_GROUP_ChannelInit(group_ptrs[indexed->group_index],(uint32_t)indexed->ch_num, indexed->ch_handle);
 8028b6a:	7a23      	ldrb	r3, [r4, #8]
 8028b6c:	7a61      	ldrb	r1, [r4, #9]
 8028b6e:	f856 0023 	ldr.w	r0, [r6, r3, lsl #2]
 8028b72:	6822      	ldr	r2, [r4, #0]
 8028b74:	f7fa ffd6 	bl	8023b24 <XMC_VADC_GROUP_ChannelInit>
      XMC_VADC_GROUP_ResultInit(group_ptrs[indexed->group_index], (uint32_t)indexed->result_fifo_tail_number,
                                indexed->res_handle[ADC_MEASUREMENT_ADV_TAIL_RESULT_REG_CONFIG]);
  }
#endif
      /* Initialize for configured result registers For FIFO Head configuration*/
      XMC_VADC_GROUP_ResultInit(group_ptrs[indexed->group_index], (uint32_t)indexed->ch_handle->result_reg_number,
 8028b78:	6823      	ldr	r3, [r4, #0]
 8028b7a:	7a22      	ldrb	r2, [r4, #8]
 8028b7c:	789b      	ldrb	r3, [r3, #2]
__STATIC_INLINE void XMC_VADC_GROUP_ResultInit(XMC_VADC_GROUP_t *const group_ptr,
                                               const uint32_t res_reg_num,
                                               const XMC_VADC_RESULT_CONFIG_t *config)
{
  XMC_ASSERT("XMC_VADC_GROUP_ResultInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->RCR[res_reg_num] = config->g_rcr;
 8028b7e:	6861      	ldr	r1, [r4, #4]
 8028b80:	f856 2022 	ldr.w	r2, [r6, r2, lsl #2]
 8028b84:	6809      	ldr	r1, [r1, #0]
 8028b86:	f003 030f 	and.w	r3, r3, #15
 8028b8a:	33a0      	adds	r3, #160	; 0xa0
 8028b8c:	f109 0904 	add.w	r9, r9, #4
      (handle_ptr->event_config)();
    }
#endif

    total_number_of_channels = (uint8_t)handle_ptr->total_number_of_channels;
    for (ch_num = (uint8_t)0; ch_num < (uint8_t)total_number_of_channels; ch_num++)
 8028b90:	45b9      	cmp	r9, r7
 8028b92:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
 8028b96:	d1e5      	bne.n	8028b64 <ADC_MEASUREMENT_ADV_Init+0x114>
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Enables the NVIC(if needed) when scan/queue request source is consumed internally in the APP. */
void ADC_MEASUREMENT_ADC_lNvicEnable(const ADC_MEASUREMENT_ADV_t *const handle_ptr)
{
#ifdef ADC_MEASUREMENT_ADV_LOCAL_SCAN_USED
    if (((bool)true == handle_ptr->local_scan_handle->rs_intr_handle.interrupt_enable) &&
 8028b98:	68ea      	ldr	r2, [r5, #12]
 8028b9a:	7b13      	ldrb	r3, [r2, #12]
 8028b9c:	b36b      	cbz	r3, 8028bfa <ADC_MEASUREMENT_ADV_Init+0x1aa>
        (ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN == handle_ptr->req_src))
 8028b9e:	7d2b      	ldrb	r3, [r5, #20]
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Enables the NVIC(if needed) when scan/queue request source is consumed internally in the APP. */
void ADC_MEASUREMENT_ADC_lNvicEnable(const ADC_MEASUREMENT_ADV_t *const handle_ptr)
{
#ifdef ADC_MEASUREMENT_ADV_LOCAL_SCAN_USED
    if (((bool)true == handle_ptr->local_scan_handle->rs_intr_handle.interrupt_enable) &&
 8028ba0:	2b01      	cmp	r3, #1
 8028ba2:	f000 8145 	beq.w	8028e30 <ADC_MEASUREMENT_ADV_Init+0x3e0>
    {
      NVIC_EnableIRQ((IRQn_Type)handle_ptr->local_scan_handle->rs_intr_handle.node_id);
    }
#endif
#ifdef ADC_MEASUREMENT_ADV_LOCAL_QUEUE_USED
    if (((bool)true == handle_ptr->local_queue_handle->rs_intr_handle.interrupt_enable) &&
 8028ba6:	2b03      	cmp	r3, #3
 8028ba8:	f000 8133 	beq.w	8028e12 <ADC_MEASUREMENT_ADV_Init+0x3c2>
{
  XMC_ASSERT("ADC_MEASUREMENT_ADV_InsertChannels:Invalid handle_ptr", (handle_ptr != NULL))

#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8028bac:	2b01      	cmp	r3, #1
 8028bae:	f240 814b 	bls.w	8028e48 <ADC_MEASUREMENT_ADV_Init+0x3f8>
/* Local function to insert the queue entries into the hardware.*/
__STATIC_INLINE void ADC_MEASUREMENT_ADV_lQueueInsertEntries(const ADC_MEASUREMENT_ADV_t *const handle_ptr)
{
  uint32_t entry_index;

  XMC_VADC_GROUP_t *queue_group_ptr = group_ptrs[handle_ptr->group_index];
 8028bb2:	7daa      	ldrb	r2, [r5, #22]
  const XMC_VADC_QUEUE_ENTRY_t **const entries_array = handle_ptr->local_queue_entries;

  for(entry_index = 0; entry_index < handle_ptr->total_number_of_entries; entry_index++)
 8028bb4:	7deb      	ldrb	r3, [r5, #23]
/* Local function to insert the queue entries into the hardware.*/
__STATIC_INLINE void ADC_MEASUREMENT_ADV_lQueueInsertEntries(const ADC_MEASUREMENT_ADV_t *const handle_ptr)
{
  uint32_t entry_index;

  XMC_VADC_GROUP_t *queue_group_ptr = group_ptrs[handle_ptr->group_index];
 8028bb6:	f856 0022 	ldr.w	r0, [r6, r2, lsl #2]
  const XMC_VADC_QUEUE_ENTRY_t **const entries_array = handle_ptr->local_queue_entries;
 8028bba:	686a      	ldr	r2, [r5, #4]

  for(entry_index = 0; entry_index < handle_ptr->total_number_of_entries; entry_index++)
 8028bbc:	b18b      	cbz	r3, 8028be2 <ADC_MEASUREMENT_ADV_Init+0x192>
 8028bbe:	3a04      	subs	r2, #4
 8028bc0:	2300      	movs	r3, #0
 8028bc2:	f852 1f04 	ldr.w	r1, [r2, #4]!
 8028bc6:	6809      	ldr	r1, [r1, #0]
__STATIC_INLINE void XMC_VADC_GROUP_QueueInsertChannel(XMC_VADC_GROUP_t *const group_ptr,
                                                       const XMC_VADC_QUEUE_ENTRY_t entry)
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueInsertChannel:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  /* Insert the channel physically and get the length of the queue*/
  group_ptr->QINR0 = entry.qinr0;
 8028bc8:	f8c0 1110 	str.w	r1, [r0, #272]	; 0x110
 8028bcc:	7de9      	ldrb	r1, [r5, #23]
 8028bce:	3301      	adds	r3, #1
 8028bd0:	428b      	cmp	r3, r1
 8028bd2:	d3f6      	bcc.n	8028bc2 <ADC_MEASUREMENT_ADV_Init+0x172>
/* Enables the arbiter of the selected request source*/
void ADC_MEASUREMENT_ADV_StartADC(const ADC_MEASUREMENT_ADV_t *const handle_ptr)
{
#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8028bd4:	7d2b      	ldrb	r3, [r5, #20]
 8028bd6:	2b01      	cmp	r3, #1
 8028bd8:	f240 813c 	bls.w	8028e54 <ADC_MEASUREMENT_ADV_Init+0x404>
 8028bdc:	7dab      	ldrb	r3, [r5, #22]
 8028bde:	f856 0023 	ldr.w	r0, [r6, r3, lsl #2]
 *  XMC_VADC_GROUP_QueueDisableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_QueueEnableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueEnableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr));
  group_ptr->ARBPR |= (uint32_t)((uint32_t)1 << VADC_G_ARBPR_ASEN0_Pos);
 8028be2:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
 8028be6:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8028bea:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
    {
      ADC_MEASUREMENT_ADV_StartADC(handle_ptr);
    }
#endif

    *handle_ptr->init_state = status;
 8028bee:	692a      	ldr	r2, [r5, #16]
  }
  return (*handle_ptr->init_state);
}
 8028bf0:	4640      	mov	r0, r8
    {
      ADC_MEASUREMENT_ADV_StartADC(handle_ptr);
    }
#endif

    *handle_ptr->init_state = status;
 8028bf2:	f882 8000 	strb.w	r8, [r2]
  }
  return (*handle_ptr->init_state);
}
 8028bf6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8028bfa:	7d2b      	ldrb	r3, [r5, #20]
 8028bfc:	e7d6      	b.n	8028bac <ADC_MEASUREMENT_ADV_Init+0x15c>
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8028bfe:	7d2b      	ldrb	r3, [r5, #20]
 8028c00:	4e30      	ldr	r6, [pc, #192]	; (8028cc4 <ADC_MEASUREMENT_ADV_Init+0x274>)
 8028c02:	7daa      	ldrb	r2, [r5, #22]
 8028c04:	2b01      	cmp	r3, #1
 8028c06:	f856 4022 	ldr.w	r4, [r6, r2, lsl #2]
  bool arbitration_status;

#if !defined(CLOCK_GATING_SUPPORTED) || !defined(ADC_MEASUREMENT_ADV_CHECK_CLOCK_GATING)
  clock_reset_check = (bool)false;
#endif
  arbitration_status = (bool)false;
 8028c0a:	f04f 0900 	mov.w	r9, #0
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8028c0e:	f63f af3a 	bhi.w	8028a86 <ADC_MEASUREMENT_ADV_Init+0x36>
                                                           uint8_t group_index)
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

  /*Initialization of APP 'ADCGroup'*/
  status = (ADC_MEASUREMENT_ADV_STATUS_t) GLOBAL_ADC_Init(ADC_MEASUREMENT_ADV_GLOBAL_HANDLE);
 8028c12:	482d      	ldr	r0, [pc, #180]	; (8028cc8 <ADC_MEASUREMENT_ADV_Init+0x278>)
#ifdef ADC_MEASUREMENT_ADV_LOCAL_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_ADC_SCAN_USED
      if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_SCAN != handle_ptr->req_src)
  #endif
      {
        status = ADC_MEASUREMENT_ADV_lScanInit(handle_ptr->local_scan_handle,handle_ptr->group_index);
 8028c14:	68ef      	ldr	r7, [r5, #12]
                                                           uint8_t group_index)
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

  /*Initialization of APP 'ADCGroup'*/
  status = (ADC_MEASUREMENT_ADV_STATUS_t) GLOBAL_ADC_Init(ADC_MEASUREMENT_ADV_GLOBAL_HANDLE);
 8028c16:	f7fe fab7 	bl	8027188 <GLOBAL_ADC_Init>

  XMC_VADC_GROUP_InputClassInit(group_ptrs[group_index], handle_ptr->iclass_config_handle,
 8028c1a:	f897 3020 	ldrb.w	r3, [r7, #32]
 8028c1e:	6939      	ldr	r1, [r7, #16]
 8028c20:	2200      	movs	r2, #0
                                                           uint8_t group_index)
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

  /*Initialization of APP 'ADCGroup'*/
  status = (ADC_MEASUREMENT_ADV_STATUS_t) GLOBAL_ADC_Init(ADC_MEASUREMENT_ADV_GLOBAL_HANDLE);
 8028c22:	4680      	mov	r8, r0

  XMC_VADC_GROUP_InputClassInit(group_ptrs[group_index], handle_ptr->iclass_config_handle,
 8028c24:	4620      	mov	r0, r4
 8028c26:	f7fa fe75 	bl	8023914 <XMC_VADC_GROUP_InputClassInit>
                                XMC_VADC_GROUP_CONV_STD, (uint32_t)handle_ptr->iclass_num);


  /*Initialization of scan request source*/
  XMC_VADC_GROUP_ScanInit(group_ptrs[group_index], handle_ptr->scan_config_handle);
 8028c2a:	4620      	mov	r0, r4
 8028c2c:	6979      	ldr	r1, [r7, #20]
 8028c2e:	f7fa fedf 	bl	80239f0 <XMC_VADC_GROUP_ScanInit>
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanSetGatingMode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_ScanSetGatingMode:Wrong mode selected", (mode_sel <= XMC_VADC_GATEMODE_ACTIVELOW))

  /* Clear the existing gate configuration */
  group_ptr->ASMR &= (uint32_t) (~((uint32_t)VADC_G_ASMR_ENGT_Msk));
 8028c32:	f8d4 2124 	ldr.w	r2, [r4, #292]	; 0x124

  /* Configure the gating mode for Scan*/
  XMC_VADC_GROUP_ScanSetGatingMode(group_ptrs[group_index], handle_ptr->gating_mode);
 8028c36:	7e38      	ldrb	r0, [r7, #24]

  /*Interrupt Configuration*/
  if ((bool)true == handle_ptr->rs_intr_handle.interrupt_enable)
 8028c38:	7b39      	ldrb	r1, [r7, #12]
 8028c3a:	f022 0203 	bic.w	r2, r2, #3
 8028c3e:	f8c4 2124 	str.w	r2, [r4, #292]	; 0x124
  /* Set the new gating mode */
  group_ptr->ASMR |= (uint32_t)((uint32_t)mode_sel << VADC_G_ASMR_ENGT_Pos);
 8028c42:	f8d4 3124 	ldr.w	r3, [r4, #292]	; 0x124
 8028c46:	4303      	orrs	r3, r0
 8028c48:	f8c4 3124 	str.w	r3, [r4, #292]	; 0x124
 8028c4c:	2900      	cmp	r1, #0
 8028c4e:	f43f af69 	beq.w	8028b24 <ADC_MEASUREMENT_ADV_Init+0xd4>
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8028c52:	4b1e      	ldr	r3, [pc, #120]	; (8028ccc <ADC_MEASUREMENT_ADV_Init+0x27c>)
  {
#if (UC_FAMILY == XMC1)
    NVIC_SetPriority((IRQn_Type)handle_ptr->rs_intr_handle.node_id, handle_ptr->rs_intr_handle.priority);
#else
    NVIC_SetPriority((IRQn_Type)handle_ptr->rs_intr_handle.node_id,
 8028c54:	f8d7 e000 	ldr.w	lr, [r7]
 8028c58:	68db      	ldr	r3, [r3, #12]
 8028c5a:	6878      	ldr	r0, [r7, #4]
 8028c5c:	f8d7 c008 	ldr.w	ip, [r7, #8]
 8028c60:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8028c64:	f1c3 0a07 	rsb	sl, r3, #7
 8028c68:	f1ba 0f06 	cmp.w	sl, #6
 8028c6c:	bf28      	it	cs
 8028c6e:	f04f 0a06 	movcs.w	sl, #6
 8028c72:	fa5f f18e 	uxtb.w	r1, lr
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8028c76:	2b00      	cmp	r3, #0
 8028c78:	f000 8101 	beq.w	8028e7e <ADC_MEASUREMENT_ADV_Init+0x42e>
 8028c7c:	1e5a      	subs	r2, r3, #1
 8028c7e:	2301      	movs	r3, #1
 8028c80:	4093      	lsls	r3, r2
 8028c82:	3b01      	subs	r3, #1
 8028c84:	ea03 030c 	and.w	r3, r3, ip

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8028c88:	f04f 0c01 	mov.w	ip, #1
 8028c8c:	fa0c fc0a 	lsl.w	ip, ip, sl
 8028c90:	f10c 3cff 	add.w	ip, ip, #4294967295
 8028c94:	ea0c 0000 	and.w	r0, ip, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8028c98:	b249      	sxtb	r1, r1

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8028c9a:	fa00 f202 	lsl.w	r2, r0, r2
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8028c9e:	2900      	cmp	r1, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 8028ca0:	ea43 0302 	orr.w	r3, r3, r2
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8028ca4:	f2c0 811c 	blt.w	8028ee0 <ADC_MEASUREMENT_ADV_Init+0x490>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8028ca8:	f101 4260 	add.w	r2, r1, #3758096384	; 0xe0000000
 8028cac:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 8028cb0:	009b      	lsls	r3, r3, #2
 8028cb2:	b2db      	uxtb	r3, r3
 8028cb4:	f882 3300 	strb.w	r3, [r2, #768]	; 0x300
    XMC_SCU_SetInterruptControl(handle_ptr->rs_intr_handle.node_id,
                                ((handle_ptr->rs_intr_handle.node_id << 8) | handle_ptr->rs_intr_handle.irqctrl));
#endif

    /* Connect RS Events to NVIC nodes */
    XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode(group_ptrs[group_index], handle_ptr->srv_req_node);
 8028cb8:	4620      	mov	r0, r4
 8028cba:	7e79      	ldrb	r1, [r7, #25]
 8028cbc:	f7fa fedc 	bl	8023a78 <XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode>
 8028cc0:	e730      	b.n	8028b24 <ADC_MEASUREMENT_ADV_Init+0xd4>
 8028cc2:	bf00      	nop
 8028cc4:	08031bd0 	.word	0x08031bd0
 8028cc8:	1ffe89f8 	.word	0x1ffe89f8
 8028ccc:	e000ed00 	.word	0xe000ed00
__STATIC_INLINE void ADC_MEASUREMENT_ADV_lSyncInit(const ADC_MEASUREMENT_ADV_t *const handle_ptr)
{
  uint8_t sync_group;

  /* shift to get the 4 bit position needed to or it with the slave groups */
  sync_group = handle_ptr->sync_slaves | ( 1 << handle_ptr->group_index);
 8028cd0:	7daa      	ldrb	r2, [r5, #22]
 8028cd2:	2701      	movs	r7, #1
 8028cd4:	4097      	lsls	r7, r2
 8028cd6:	433b      	orrs	r3, r7
  ADC_MEASUREMENT_ADV_lSyncSequencer(handle_ptr, sync_group, ADC_MEASUREMENT_ADV_SYNC_SEQ_POWER_DOWN);
 8028cd8:	b2df      	uxtb	r7, r3
 8028cda:	2403      	movs	r4, #3
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8028cdc:	fa27 f304 	lsr.w	r3, r7, r4
 8028ce0:	f013 0f01 	tst.w	r3, #1
    {
      switch( sequence)
      {
        case ADC_MEASUREMENT_ADV_SYNC_SEQ_POWER_DOWN:
             XMC_VADC_GROUP_SetPowerMode(group_ptrs[group_index],XMC_VADC_GROUP_POWERMODE_OFF);
 8028ce4:	f04f 0100 	mov.w	r1, #0
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8028ce8:	d003      	beq.n	8028cf2 <ADC_MEASUREMENT_ADV_Init+0x2a2>
    {
      switch( sequence)
      {
        case ADC_MEASUREMENT_ADV_SYNC_SEQ_POWER_DOWN:
             XMC_VADC_GROUP_SetPowerMode(group_ptrs[group_index],XMC_VADC_GROUP_POWERMODE_OFF);
 8028cea:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
 8028cee:	f7fa fe37 	bl	8023960 <XMC_VADC_GROUP_SetPowerMode>
void ADC_MEASUREMENT_ADV_lSyncSequencer(const ADC_MEASUREMENT_ADV_t *const handle_ptr,
                                        uint32_t sync_group,
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
 8028cf2:	f114 34ff 	adds.w	r4, r4, #4294967295
 8028cf6:	d2f1      	bcs.n	8028cdc <ADC_MEASUREMENT_ADV_Init+0x28c>

  /* shift to get the 4 bit position needed to or it with the slave groups */
  sync_group = handle_ptr->sync_slaves | ( 1 << handle_ptr->group_index);
  ADC_MEASUREMENT_ADV_lSyncSequencer(handle_ptr, sync_group, ADC_MEASUREMENT_ADV_SYNC_SEQ_POWER_DOWN);

  sync_group = handle_ptr->sync_slaves;
 8028cf8:	7d6f      	ldrb	r7, [r5, #21]
  ADC_MEASUREMENT_ADV_lSyncSequencer(handle_ptr, sync_group, ADC_MEASUREMENT_ADV_SYNC_SEQ_STSEL_CONFIG);
 8028cfa:	2403      	movs	r4, #3
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8028cfc:	fa27 f304 	lsr.w	r3, r7, r4
 8028d00:	07d8      	lsls	r0, r3, #31
      {
        case ADC_MEASUREMENT_ADV_SYNC_SEQ_POWER_DOWN:
             XMC_VADC_GROUP_SetPowerMode(group_ptrs[group_index],XMC_VADC_GROUP_POWERMODE_OFF);
             break;
        case ADC_MEASUREMENT_ADV_SYNC_SEQ_STSEL_CONFIG:
             XMC_VADC_GROUP_SetSyncSlave(group_ptrs[group_index], handle_ptr->group_index, group_index);
 8028d02:	4622      	mov	r2, r4
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8028d04:	d50a      	bpl.n	8028d1c <ADC_MEASUREMENT_ADV_Init+0x2cc>
      {
        case ADC_MEASUREMENT_ADV_SYNC_SEQ_POWER_DOWN:
             XMC_VADC_GROUP_SetPowerMode(group_ptrs[group_index],XMC_VADC_GROUP_POWERMODE_OFF);
             break;
        case ADC_MEASUREMENT_ADV_SYNC_SEQ_STSEL_CONFIG:
             XMC_VADC_GROUP_SetSyncSlave(group_ptrs[group_index], handle_ptr->group_index, group_index);
 8028d06:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
 8028d0a:	7da9      	ldrb	r1, [r5, #22]
 8028d0c:	f7fa fe30 	bl	8023970 <XMC_VADC_GROUP_SetSyncSlave>
             XMC_VADC_GROUP_CheckSlaveReadiness(group_ptrs[handle_ptr->group_index],group_index);
 8028d10:	7dab      	ldrb	r3, [r5, #22]
 8028d12:	4621      	mov	r1, r4
 8028d14:	f856 0023 	ldr.w	r0, [r6, r3, lsl #2]
 8028d18:	f7fa fe3e 	bl	8023998 <XMC_VADC_GROUP_CheckSlaveReadiness>
void ADC_MEASUREMENT_ADV_lSyncSequencer(const ADC_MEASUREMENT_ADV_t *const handle_ptr,
                                        uint32_t sync_group,
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
 8028d1c:	f114 34ff 	adds.w	r4, r4, #4294967295
 8028d20:	d2ec      	bcs.n	8028cfc <ADC_MEASUREMENT_ADV_Init+0x2ac>
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8028d22:	0739      	lsls	r1, r7, #28
 8028d24:	d510      	bpl.n	8028d48 <ADC_MEASUREMENT_ADV_Init+0x2f8>
/* Helper function to configure the eval bits in the slave*/
void ADC_MEASUREMENT_ADV_lSyncEvalConfig(uint32_t master_group, uint32_t slave_selected,
                                         uint32_t sync_group)
{
  int8_t group_index;
  sync_group |= (1U << master_group);
 8028d26:	7dab      	ldrb	r3, [r5, #22]
 8028d28:	2401      	movs	r4, #1
 8028d2a:	409c      	lsls	r4, r3
 8028d2c:	433c      	orrs	r4, r7
  sync_group &= ~(1U << slave_selected);
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8028d2e:	0762      	lsls	r2, r4, #29
 8028d30:	f100 80b8 	bmi.w	8028ea4 <ADC_MEASUREMENT_ADV_Init+0x454>
 8028d34:	07a3      	lsls	r3, r4, #30
 8028d36:	f100 80af 	bmi.w	8028e98 <ADC_MEASUREMENT_ADV_Init+0x448>
 8028d3a:	07e0      	lsls	r0, r4, #31
 8028d3c:	d504      	bpl.n	8028d48 <ADC_MEASUREMENT_ADV_Init+0x2f8>
    {
      XMC_VADC_GROUP_SetSyncSlaveReadySignal(group_ptrs[slave_selected], slave_selected, group_index);
 8028d3e:	486c      	ldr	r0, [pc, #432]	; (8028ef0 <ADC_MEASUREMENT_ADV_Init+0x4a0>)
 8028d40:	2103      	movs	r1, #3
 8028d42:	2200      	movs	r2, #0
 8028d44:	f7fa fe48 	bl	80239d8 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8028d48:	0779      	lsls	r1, r7, #29
 8028d4a:	d510      	bpl.n	8028d6e <ADC_MEASUREMENT_ADV_Init+0x31e>
/* Helper function to configure the eval bits in the slave*/
void ADC_MEASUREMENT_ADV_lSyncEvalConfig(uint32_t master_group, uint32_t slave_selected,
                                         uint32_t sync_group)
{
  int8_t group_index;
  sync_group |= (1U << master_group);
 8028d4c:	7dab      	ldrb	r3, [r5, #22]
 8028d4e:	2401      	movs	r4, #1
 8028d50:	409c      	lsls	r4, r3
 8028d52:	433c      	orrs	r4, r7
  sync_group &= ~(1U << slave_selected);
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8028d54:	0722      	lsls	r2, r4, #28
 8028d56:	f100 80bd 	bmi.w	8028ed4 <ADC_MEASUREMENT_ADV_Init+0x484>
 8028d5a:	07a3      	lsls	r3, r4, #30
 8028d5c:	f100 80b4 	bmi.w	8028ec8 <ADC_MEASUREMENT_ADV_Init+0x478>
 8028d60:	07e0      	lsls	r0, r4, #31
 8028d62:	d504      	bpl.n	8028d6e <ADC_MEASUREMENT_ADV_Init+0x31e>
    {
      XMC_VADC_GROUP_SetSyncSlaveReadySignal(group_ptrs[slave_selected], slave_selected, group_index);
 8028d64:	4863      	ldr	r0, [pc, #396]	; (8028ef4 <ADC_MEASUREMENT_ADV_Init+0x4a4>)
 8028d66:	2102      	movs	r1, #2
 8028d68:	2200      	movs	r2, #0
 8028d6a:	f7fa fe35 	bl	80239d8 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8028d6e:	07b9      	lsls	r1, r7, #30
 8028d70:	d510      	bpl.n	8028d94 <ADC_MEASUREMENT_ADV_Init+0x344>
/* Helper function to configure the eval bits in the slave*/
void ADC_MEASUREMENT_ADV_lSyncEvalConfig(uint32_t master_group, uint32_t slave_selected,
                                         uint32_t sync_group)
{
  int8_t group_index;
  sync_group |= (1U << master_group);
 8028d72:	7dab      	ldrb	r3, [r5, #22]
 8028d74:	2101      	movs	r1, #1
 8028d76:	fa01 f403 	lsl.w	r4, r1, r3
 8028d7a:	433c      	orrs	r4, r7
  sync_group &= ~(1U << slave_selected);
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8028d7c:	0722      	lsls	r2, r4, #28
 8028d7e:	f100 8086 	bmi.w	8028e8e <ADC_MEASUREMENT_ADV_Init+0x43e>
 8028d82:	0763      	lsls	r3, r4, #29
 8028d84:	d47d      	bmi.n	8028e82 <ADC_MEASUREMENT_ADV_Init+0x432>
 8028d86:	07e4      	lsls	r4, r4, #31
 8028d88:	d504      	bpl.n	8028d94 <ADC_MEASUREMENT_ADV_Init+0x344>
    {
      XMC_VADC_GROUP_SetSyncSlaveReadySignal(group_ptrs[slave_selected], slave_selected, group_index);
 8028d8a:	485b      	ldr	r0, [pc, #364]	; (8028ef8 <ADC_MEASUREMENT_ADV_Init+0x4a8>)
 8028d8c:	2101      	movs	r1, #1
 8028d8e:	2200      	movs	r2, #0
 8028d90:	f7fa fe22 	bl	80239d8 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8028d94:	07f8      	lsls	r0, r7, #31
 8028d96:	d510      	bpl.n	8028dba <ADC_MEASUREMENT_ADV_Init+0x36a>
/* Helper function to configure the eval bits in the slave*/
void ADC_MEASUREMENT_ADV_lSyncEvalConfig(uint32_t master_group, uint32_t slave_selected,
                                         uint32_t sync_group)
{
  int8_t group_index;
  sync_group |= (1U << master_group);
 8028d98:	7daa      	ldrb	r2, [r5, #22]
 8028d9a:	2301      	movs	r3, #1
 8028d9c:	4093      	lsls	r3, r2
 8028d9e:	431f      	orrs	r7, r3
  sync_group &= ~(1U << slave_selected);
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8028da0:	0739      	lsls	r1, r7, #28
 8028da2:	f100 808b 	bmi.w	8028ebc <ADC_MEASUREMENT_ADV_Init+0x46c>
 8028da6:	077a      	lsls	r2, r7, #29
 8028da8:	f100 8082 	bmi.w	8028eb0 <ADC_MEASUREMENT_ADV_Init+0x460>
 8028dac:	07bb      	lsls	r3, r7, #30
 8028dae:	d504      	bpl.n	8028dba <ADC_MEASUREMENT_ADV_Init+0x36a>
    {
      XMC_VADC_GROUP_SetSyncSlaveReadySignal(group_ptrs[slave_selected], slave_selected, group_index);
 8028db0:	4852      	ldr	r0, [pc, #328]	; (8028efc <ADC_MEASUREMENT_ADV_Init+0x4ac>)
 8028db2:	2100      	movs	r1, #0
 8028db4:	2201      	movs	r2, #1
 8028db6:	f7fa fe0f 	bl	80239d8 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
  sync_group = handle_ptr->sync_slaves;
  ADC_MEASUREMENT_ADV_lSyncSequencer(handle_ptr, sync_group, ADC_MEASUREMENT_ADV_SYNC_SEQ_STSEL_CONFIG);
  ADC_MEASUREMENT_ADV_lSyncSequencer(handle_ptr, sync_group, ADC_MEASUREMENT_ADV_SYNC_SEQ_EVAL_CONFIG);

  /* Configure the iclass settings needed for the sync slaves*/
  if( (bool) false != handle_ptr->configure_globiclass1)
 8028dba:	7eab      	ldrb	r3, [r5, #26]
 8028dbc:	b1b3      	cbz	r3, 8028dec <ADC_MEASUREMENT_ADV_Init+0x39c>
{
  XMC_VADC_CHANNEL_CONV_t req_iclass;

#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8028dbe:	7d2b      	ldrb	r3, [r5, #20]
  XMC_VADC_GLOBAL_CLASS_t conv_class_global;

  XMC_ASSERT("ADC_MEASUREMENT_ADV_SetIclass:Invalid handle_ptr", (handle_ptr != NULL))

  req_iclass = ADC_MEASUREMENT_ADV_lGetIclass(handle_ptr);
  conv_class = XMC_VADC_GROUP_GetInputClass(group_ptrs[handle_ptr->group_index], req_iclass);
 8028dc0:	7daa      	ldrb	r2, [r5, #22]
{
  XMC_VADC_CHANNEL_CONV_t req_iclass;

#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8028dc2:	2b01      	cmp	r3, #1
#ifdef ADC_MEASUREMENT_ADV_LOCAL_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_ADC_SCAN_USED
      if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_SCAN != handle_ptr->req_src)
  #endif
      {
        req_iclass = (XMC_VADC_CHANNEL_CONV_t)handle_ptr->local_scan_handle->iclass_num;
 8028dc4:	68eb      	ldr	r3, [r5, #12]
  XMC_VADC_GLOBAL_CLASS_t conv_class_global;

  XMC_ASSERT("ADC_MEASUREMENT_ADV_SetIclass:Invalid handle_ptr", (handle_ptr != NULL))

  req_iclass = ADC_MEASUREMENT_ADV_lGetIclass(handle_ptr);
  conv_class = XMC_VADC_GROUP_GetInputClass(group_ptrs[handle_ptr->group_index], req_iclass);
 8028dc6:	f856 2022 	ldr.w	r2, [r6, r2, lsl #2]
#ifdef ADC_MEASUREMENT_ADV_LOCAL_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_ADC_SCAN_USED
      if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_SCAN != handle_ptr->req_src)
  #endif
      {
        req_iclass = (XMC_VADC_CHANNEL_CONV_t)handle_ptr->local_scan_handle->iclass_num;
 8028dca:	bf94      	ite	ls
 8028dcc:	f893 3020 	ldrbls.w	r3, [r3, #32]
#ifdef ADC_MEASUREMENT_ADV_LOCAL_QUEUE_USED
  #ifdef ADC_MEASUREMENT_ADV_ADC_QUEUE_USED
      if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_QUEUE != handle_ptr->req_src)
  #endif
      {
        req_iclass = (XMC_VADC_CHANNEL_CONV_t)handle_ptr->local_queue_handle->iclass_num;
 8028dd0:	7e9b      	ldrbhi	r3, [r3, #26]
  XMC_ASSERT("XMC_VADC_GROUP_GetInputClass:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_GetInputClass:Wrong conv_class selected", 
             (XMC_VADC_CHANNEL_CONV_GROUP_CLASS0 == conv_class) || (XMC_VADC_CHANNEL_CONV_GROUP_CLASS1 == conv_class))

  input_value.g_iclass0 = (uint32_t) 0xFFFFFFFF;
  if ((XMC_VADC_CHANNEL_CONV_GROUP_CLASS0 == conv_class) || (XMC_VADC_CHANNEL_CONV_GROUP_CLASS1 == conv_class))
 8028dd2:	2b01      	cmp	r3, #1
  {
    input_value.g_iclass0 = group_ptr->ICLASS[(uint32_t)conv_class];
 8028dd4:	bf96      	itet	ls
 8028dd6:	3328      	addls	r3, #40	; 0x28
  XMC_VADC_GROUP_CLASS_t input_value;
  XMC_ASSERT("XMC_VADC_GROUP_GetInputClass:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_GetInputClass:Wrong conv_class selected", 
             (XMC_VADC_CHANNEL_CONV_GROUP_CLASS0 == conv_class) || (XMC_VADC_CHANNEL_CONV_GROUP_CLASS1 == conv_class))

  input_value.g_iclass0 = (uint32_t) 0xFFFFFFFF;
 8028dd8:	f04f 31ff 	movhi.w	r1, #4294967295
  if ((XMC_VADC_CHANNEL_CONV_GROUP_CLASS0 == conv_class) || (XMC_VADC_CHANNEL_CONV_GROUP_CLASS1 == conv_class))
  {
    input_value.g_iclass0 = group_ptr->ICLASS[(uint32_t)conv_class];
 8028ddc:	f852 1023 	ldrls.w	r1, [r2, r3, lsl #2]
  XMC_ASSERT("ADC_MEASUREMENT_ADV_SetIclass:Invalid handle_ptr", (handle_ptr != NULL))

  req_iclass = ADC_MEASUREMENT_ADV_lGetIclass(handle_ptr);
  conv_class = XMC_VADC_GROUP_GetInputClass(group_ptrs[handle_ptr->group_index], req_iclass);
  conv_class_global.globiclass = conv_class.g_iclass0;
  XMC_VADC_GLOBAL_InputClassInit(ADC_MEASUREMENT_ADV_GLOBAL_PTR, conv_class_global,
 8028de0:	f04f 2040 	mov.w	r0, #1073758208	; 0x40004000
 8028de4:	2200      	movs	r2, #0
 8028de6:	2301      	movs	r3, #1
 8028de8:	f7fa fcee 	bl	80237c8 <XMC_VADC_GLOBAL_InputClassInit>
  if( (bool) false != handle_ptr->configure_globiclass1)
  {
    ADC_MEASUREMENT_ADV_SetIclass(handle_ptr);
  }

  XMC_VADC_GROUP_SetSyncMaster(group_ptrs[handle_ptr->group_index]);
 8028dec:	7dab      	ldrb	r3, [r5, #22]
 8028dee:	f856 0023 	ldr.w	r0, [r6, r3, lsl #2]
 8028df2:	f7fa fdc9 	bl	8023988 <XMC_VADC_GROUP_SetSyncMaster>

  XMC_VADC_GROUP_SetPowerMode(group_ptrs[handle_ptr->group_index],XMC_VADC_GROUP_POWERMODE_NORMAL);
 8028df6:	7dab      	ldrb	r3, [r5, #22]
 8028df8:	2103      	movs	r1, #3
 8028dfa:	f856 0023 	ldr.w	r0, [r6, r3, lsl #2]
 8028dfe:	f7fa fdaf 	bl	8023960 <XMC_VADC_GROUP_SetPowerMode>
 8028e02:	e6a4      	b.n	8028b4e <ADC_MEASUREMENT_ADV_Init+0xfe>
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8028e04:	1e5a      	subs	r2, r3, #1
 8028e06:	2301      	movs	r3, #1
 8028e08:	4093      	lsls	r3, r2
 8028e0a:	3b01      	subs	r3, #1
 8028e0c:	ea03 030c 	and.w	r3, r3, ip
 8028e10:	e66c      	b.n	8028aec <ADC_MEASUREMENT_ADV_Init+0x9c>
#endif
#ifdef ADC_MEASUREMENT_ADV_LOCAL_QUEUE_USED
    if (((bool)true == handle_ptr->local_queue_handle->rs_intr_handle.interrupt_enable) &&
        (ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_QUEUE == handle_ptr->req_src))
    {
      NVIC_EnableIRQ((IRQn_Type)handle_ptr->local_queue_handle->rs_intr_handle.node_id);
 8028e12:	6812      	ldr	r2, [r2, #0]
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
 8028e14:	b253      	sxtb	r3, r2
 8028e16:	2b00      	cmp	r3, #0
 8028e18:	f6ff aecb 	blt.w	8028bb2 <ADC_MEASUREMENT_ADV_Init+0x162>
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8028e1c:	f002 021f 	and.w	r2, r2, #31
 8028e20:	095b      	lsrs	r3, r3, #5
 8028e22:	2101      	movs	r1, #1
 8028e24:	4836      	ldr	r0, [pc, #216]	; (8028f00 <ADC_MEASUREMENT_ADV_Init+0x4b0>)
 8028e26:	fa01 f202 	lsl.w	r2, r1, r2
 8028e2a:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
 8028e2e:	e6c0      	b.n	8028bb2 <ADC_MEASUREMENT_ADV_Init+0x162>
{
#ifdef ADC_MEASUREMENT_ADV_LOCAL_SCAN_USED
    if (((bool)true == handle_ptr->local_scan_handle->rs_intr_handle.interrupt_enable) &&
        (ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN == handle_ptr->req_src))
    {
      NVIC_EnableIRQ((IRQn_Type)handle_ptr->local_scan_handle->rs_intr_handle.node_id);
 8028e30:	6810      	ldr	r0, [r2, #0]
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
 8028e32:	b241      	sxtb	r1, r0
 8028e34:	2900      	cmp	r1, #0
 8028e36:	db07      	blt.n	8028e48 <ADC_MEASUREMENT_ADV_Init+0x3f8>
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8028e38:	4a31      	ldr	r2, [pc, #196]	; (8028f00 <ADC_MEASUREMENT_ADV_Init+0x4b0>)
 8028e3a:	f000 001f 	and.w	r0, r0, #31
 8028e3e:	0949      	lsrs	r1, r1, #5
 8028e40:	4083      	lsls	r3, r0
 8028e42:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
 8028e46:	68ea      	ldr	r2, [r5, #12]
#ifdef ADC_MEASUREMENT_ADV_LOCAL_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_ADC_SCAN_USED
      if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_SCAN != handle_ptr->req_src)
  #endif
      {
        XMC_VADC_GROUP_ScanAddMultipleChannels(group_ptrs[handle_ptr->group_index], handle_ptr->local_scan_handle->insert_mask);
 8028e48:	7dab      	ldrb	r3, [r5, #22]
 8028e4a:	69d2      	ldr	r2, [r2, #28]
 8028e4c:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
 *  XMC_VADC_GROUP_ScanAddChannelToSequence()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_ScanAddMultipleChannels(XMC_VADC_GROUP_t *const group_ptr, const uint32_t ch_mask)
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanAddMultipleChannels:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->ASSEL = ch_mask;
 8028e50:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
  #endif
      {
        XMC_VADC_GROUP_ScanEnableArbitrationSlot(group_ptrs[handle_ptr->group_index]);
 8028e54:	7dab      	ldrb	r3, [r5, #22]
 8028e56:	f856 2023 	ldr.w	r2, [r6, r3, lsl #2]
 *  XMC_VADC_GROUP_ScanDisableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_ScanEnableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanEnableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->ARBPR |= (uint32_t)VADC_G_ARBPR_ASEN1_Msk;
 8028e5a:	f8d2 3084 	ldr.w	r3, [r2, #132]	; 0x84
 8028e5e:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8028e62:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
 8028e66:	e6c2      	b.n	8028bee <ADC_MEASUREMENT_ADV_Init+0x19e>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8028e68:	4a26      	ldr	r2, [pc, #152]	; (8028f04 <ADC_MEASUREMENT_ADV_Init+0x4b4>)
 8028e6a:	f00e 0e0f 	and.w	lr, lr, #15
 8028e6e:	009b      	lsls	r3, r3, #2
 8028e70:	4472      	add	r2, lr
 8028e72:	b2db      	uxtb	r3, r3
 8028e74:	7613      	strb	r3, [r2, #24]
 8028e76:	e651      	b.n	8028b1c <ADC_MEASUREMENT_ADV_Init+0xcc>
 */
__STATIC_INLINE bool XMC_VADC_GROUP_ScanIsArbitrationSlotEnabled(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanIsArbitrationSlotEnabled:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  return ((group_ptr->ARBPR & (uint32_t)VADC_G_ARBPR_ASEN1_Msk) >> VADC_G_ARBPR_ASEN1_Pos);
 8028e78:	f3c3 6940 	ubfx	r9, r3, #25, #1
 8028e7c:	e6c9      	b.n	8028c12 <ADC_MEASUREMENT_ADV_Init+0x1c2>
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8028e7e:	461a      	mov	r2, r3
 8028e80:	e702      	b.n	8028c88 <ADC_MEASUREMENT_ADV_Init+0x238>
  sync_group &= ~(1U << slave_selected);
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
    {
      XMC_VADC_GROUP_SetSyncSlaveReadySignal(group_ptrs[slave_selected], slave_selected, group_index);
 8028e82:	481d      	ldr	r0, [pc, #116]	; (8028ef8 <ADC_MEASUREMENT_ADV_Init+0x4a8>)
 8028e84:	2101      	movs	r1, #1
 8028e86:	2202      	movs	r2, #2
 8028e88:	f7fa fda6 	bl	80239d8 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 8028e8c:	e77b      	b.n	8028d86 <ADC_MEASUREMENT_ADV_Init+0x336>
 8028e8e:	481a      	ldr	r0, [pc, #104]	; (8028ef8 <ADC_MEASUREMENT_ADV_Init+0x4a8>)
 8028e90:	2203      	movs	r2, #3
 8028e92:	f7fa fda1 	bl	80239d8 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 8028e96:	e774      	b.n	8028d82 <ADC_MEASUREMENT_ADV_Init+0x332>
 8028e98:	4815      	ldr	r0, [pc, #84]	; (8028ef0 <ADC_MEASUREMENT_ADV_Init+0x4a0>)
 8028e9a:	2103      	movs	r1, #3
 8028e9c:	2201      	movs	r2, #1
 8028e9e:	f7fa fd9b 	bl	80239d8 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 8028ea2:	e74a      	b.n	8028d3a <ADC_MEASUREMENT_ADV_Init+0x2ea>
 8028ea4:	4812      	ldr	r0, [pc, #72]	; (8028ef0 <ADC_MEASUREMENT_ADV_Init+0x4a0>)
 8028ea6:	2103      	movs	r1, #3
 8028ea8:	2202      	movs	r2, #2
 8028eaa:	f7fa fd95 	bl	80239d8 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 8028eae:	e741      	b.n	8028d34 <ADC_MEASUREMENT_ADV_Init+0x2e4>
 8028eb0:	4812      	ldr	r0, [pc, #72]	; (8028efc <ADC_MEASUREMENT_ADV_Init+0x4ac>)
 8028eb2:	2100      	movs	r1, #0
 8028eb4:	2202      	movs	r2, #2
 8028eb6:	f7fa fd8f 	bl	80239d8 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 8028eba:	e777      	b.n	8028dac <ADC_MEASUREMENT_ADV_Init+0x35c>
 8028ebc:	480f      	ldr	r0, [pc, #60]	; (8028efc <ADC_MEASUREMENT_ADV_Init+0x4ac>)
 8028ebe:	2100      	movs	r1, #0
 8028ec0:	2203      	movs	r2, #3
 8028ec2:	f7fa fd89 	bl	80239d8 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 8028ec6:	e76e      	b.n	8028da6 <ADC_MEASUREMENT_ADV_Init+0x356>
 8028ec8:	480a      	ldr	r0, [pc, #40]	; (8028ef4 <ADC_MEASUREMENT_ADV_Init+0x4a4>)
 8028eca:	2102      	movs	r1, #2
 8028ecc:	2201      	movs	r2, #1
 8028ece:	f7fa fd83 	bl	80239d8 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 8028ed2:	e745      	b.n	8028d60 <ADC_MEASUREMENT_ADV_Init+0x310>
 8028ed4:	4807      	ldr	r0, [pc, #28]	; (8028ef4 <ADC_MEASUREMENT_ADV_Init+0x4a4>)
 8028ed6:	2102      	movs	r1, #2
 8028ed8:	2203      	movs	r2, #3
 8028eda:	f7fa fd7d 	bl	80239d8 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 8028ede:	e73c      	b.n	8028d5a <ADC_MEASUREMENT_ADV_Init+0x30a>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8028ee0:	4a08      	ldr	r2, [pc, #32]	; (8028f04 <ADC_MEASUREMENT_ADV_Init+0x4b4>)
 8028ee2:	f00e 0e0f 	and.w	lr, lr, #15
 8028ee6:	009b      	lsls	r3, r3, #2
 8028ee8:	4472      	add	r2, lr
 8028eea:	b2db      	uxtb	r3, r3
 8028eec:	7613      	strb	r3, [r2, #24]
 8028eee:	e6e3      	b.n	8028cb8 <ADC_MEASUREMENT_ADV_Init+0x268>
 8028ef0:	40005000 	.word	0x40005000
 8028ef4:	40004c00 	.word	0x40004c00
 8028ef8:	40004800 	.word	0x40004800
 8028efc:	40004400 	.word	0x40004400
 8028f00:	e000e100 	.word	0xe000e100
 8028f04:	e000ecfc 	.word	0xe000ecfc

08028f08 <ADC_MEASUREMENT_ADV_G1_event_config>:
 */
static void ADC_MEASUREMENT_ADV_G1_event_config(void)
{

	/* Result Event Node Mux Configuration for IF1_I (Group-0 channel-4 Result_Register-15)*/
	XMC_VADC_GROUP_SetResultInterruptNode(VADC_G0, 15U, XMC_VADC_SR_SHARED_SR1);
 8028f08:	4802      	ldr	r0, [pc, #8]	; (8028f14 <ADC_MEASUREMENT_ADV_G1_event_config+0xc>)
 8028f0a:	210f      	movs	r1, #15
 8028f0c:	2205      	movs	r2, #5
 8028f0e:	f7fa be47 	b.w	8023ba0 <XMC_VADC_GROUP_SetResultInterruptNode>
 8028f12:	bf00      	nop
 8028f14:	40004400 	.word	0x40004400

08028f18 <ADC_MEASUREMENT_ADV_G2_event_config>:
 */
static void ADC_MEASUREMENT_ADV_G2_event_config(void)
{

	/* Result Event Node Mux Configuration for IF1_Q (Group-1 channel-6 Result_Register-3)*/
	XMC_VADC_GROUP_SetResultInterruptNode(VADC_G1, 3U, XMC_VADC_SR_SHARED_SR0);
 8028f18:	4802      	ldr	r0, [pc, #8]	; (8028f24 <ADC_MEASUREMENT_ADV_G2_event_config+0xc>)
 8028f1a:	2103      	movs	r1, #3
 8028f1c:	2204      	movs	r2, #4
 8028f1e:	f7fa be3f 	b.w	8023ba0 <XMC_VADC_GROUP_SetResultInterruptNode>
 8028f22:	bf00      	nop
 8028f24:	40004800 	.word	0x40004800

08028f28 <ADC_MEASUREMENT_ADV_G3_event_config>:
 */
static void ADC_MEASUREMENT_ADV_G3_event_config(void)
{

	/* Result Event Node Mux Configuration for IF2_I (Group-2 channel-3 Result_Register-0)*/
	XMC_VADC_GROUP_SetResultInterruptNode(VADC_G2, 0U, XMC_VADC_SR_SHARED_SR3);
 8028f28:	4802      	ldr	r0, [pc, #8]	; (8028f34 <ADC_MEASUREMENT_ADV_G3_event_config+0xc>)
 8028f2a:	2100      	movs	r1, #0
 8028f2c:	2207      	movs	r2, #7
 8028f2e:	f7fa be37 	b.w	8023ba0 <XMC_VADC_GROUP_SetResultInterruptNode>
 8028f32:	bf00      	nop
 8028f34:	40004c00 	.word	0x40004c00

08028f38 <ADC_MEASUREMENT_ADV_G4_event_config>:
 */
static void ADC_MEASUREMENT_ADV_G4_event_config(void)
{

	/* Result Event Node Mux Configuration for IF2_Q (Group-3 channel-0 Result_Register-4)*/
	XMC_VADC_GROUP_SetResultInterruptNode(VADC_G3, 4U, XMC_VADC_SR_GROUP_SR2);
 8028f38:	4802      	ldr	r0, [pc, #8]	; (8028f44 <ADC_MEASUREMENT_ADV_G4_event_config+0xc>)
 8028f3a:	2104      	movs	r1, #4
 8028f3c:	2202      	movs	r2, #2
 8028f3e:	f7fa be2f 	b.w	8023ba0 <XMC_VADC_GROUP_SetResultInterruptNode>
 8028f42:	bf00      	nop
 8028f44:	40005000 	.word	0x40005000

08028f48 <DAVE_Init>:
 * @param[in]  None
 *
 * @return  DAVE_STATUS_t <BR>
 ******************************************************************************/
DAVE_STATUS_t DAVE_Init(void)
{
 8028f48:	b508      	push	{r3, lr}
  DAVE_STATUS_t init_status;
  
  init_status = DAVE_STATUS_SUCCESS;
     /** @Initialization of APPs Init Functions */
     init_status = (DAVE_STATUS_t)CLOCK_XMC4_Init(&CLOCK_XMC4_0);
 8028f4a:	485e      	ldr	r0, [pc, #376]	; (80290c4 <DAVE_Init+0x17c>)
 8028f4c:	f7ff fce6 	bl	802891c <CLOCK_XMC4_Init>

  if (init_status == DAVE_STATUS_SUCCESS)
 8028f50:	b100      	cbz	r0, 8028f54 <DAVE_Init+0xc>
  {
	 /**  Initialization of INTERRUPT APP instance INTERRUPT_WATCHDOG */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&INTERRUPT_WATCHDOG); 
   }  
  return init_status;
} /**  End of function DAVE_Init */
 8028f52:	bd08      	pop	{r3, pc}
     init_status = (DAVE_STATUS_t)CLOCK_XMC4_Init(&CLOCK_XMC4_0);

  if (init_status == DAVE_STATUS_SUCCESS)
  {
	 /**  Initialization of ADC_MEASUREMENT_ADV APP instance ADC_MEASUREMENT_ADV_G1 */
	 init_status = (DAVE_STATUS_t)ADC_MEASUREMENT_ADV_Init(&ADC_MEASUREMENT_ADV_G1); 
 8028f54:	485c      	ldr	r0, [pc, #368]	; (80290c8 <DAVE_Init+0x180>)
 8028f56:	f7ff fd7b 	bl	8028a50 <ADC_MEASUREMENT_ADV_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028f5a:	2800      	cmp	r0, #0
 8028f5c:	d1f9      	bne.n	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_BGT_POWER_ENABLE */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_BGT_POWER_ENABLE); 
 8028f5e:	485b      	ldr	r0, [pc, #364]	; (80290cc <DAVE_Init+0x184>)
 8028f60:	f7fe fc6e 	bl	8027840 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028f64:	2800      	cmp	r0, #0
 8028f66:	d1f4      	bne.n	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_PLL_CE */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_PLL_CE); 
 8028f68:	4859      	ldr	r0, [pc, #356]	; (80290d0 <DAVE_Init+0x188>)
 8028f6a:	f7fe fc69 	bl	8027840 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028f6e:	2800      	cmp	r0, #0
 8028f70:	d1ef      	bne.n	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_PLL_MOD */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_PLL_MOD); 
 8028f72:	4858      	ldr	r0, [pc, #352]	; (80290d4 <DAVE_Init+0x18c>)
 8028f74:	f7fe fc64 	bl	8027840 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028f78:	2800      	cmp	r0, #0
 8028f7a:	d1ea      	bne.n	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_SPI_M_CLK */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_SPI_M_CLK); 
 8028f7c:	4856      	ldr	r0, [pc, #344]	; (80290d8 <DAVE_Init+0x190>)
 8028f7e:	f7fe fc5f 	bl	8027840 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028f82:	2800      	cmp	r0, #0
 8028f84:	d1e5      	bne.n	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_SPI_M_CS_BGT24 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_SPI_M_CS_BGT24); 
 8028f86:	4855      	ldr	r0, [pc, #340]	; (80290dc <DAVE_Init+0x194>)
 8028f88:	f7fe fc5a 	bl	8027840 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028f8c:	2800      	cmp	r0, #0
 8028f8e:	d1e0      	bne.n	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_SPI_M_CS_PLL */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_SPI_M_CS_PLL); 
 8028f90:	4853      	ldr	r0, [pc, #332]	; (80290e0 <DAVE_Init+0x198>)
 8028f92:	f7fe fc55 	bl	8027840 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028f96:	2800      	cmp	r0, #0
 8028f98:	d1db      	bne.n	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_SPI_M_DATA */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_SPI_M_DATA); 
 8028f9a:	4852      	ldr	r0, [pc, #328]	; (80290e4 <DAVE_Init+0x19c>)
 8028f9c:	f7fe fc50 	bl	8027840 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028fa0:	2800      	cmp	r0, #0
 8028fa2:	d1d6      	bne.n	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_PLL_TRIG1 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_PLL_TRIG1); 
 8028fa4:	4850      	ldr	r0, [pc, #320]	; (80290e8 <DAVE_Init+0x1a0>)
 8028fa6:	f7fe fc4b 	bl	8027840 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028faa:	2800      	cmp	r0, #0
 8028fac:	d1d1      	bne.n	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_PLL_TRIG2 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_PLL_TRIG2); 
 8028fae:	484f      	ldr	r0, [pc, #316]	; (80290ec <DAVE_Init+0x1a4>)
 8028fb0:	f7fe fc46 	bl	8027840 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028fb4:	2800      	cmp	r0, #0
 8028fb6:	d1cc      	bne.n	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of E_EEPROM_XMC4 APP instance E_EEPROM_XMC4 */
	 init_status = (DAVE_STATUS_t)E_EEPROM_XMC4_Init(&E_EEPROM_XMC4); 
 8028fb8:	484d      	ldr	r0, [pc, #308]	; (80290f0 <DAVE_Init+0x1a8>)
 8028fba:	f7fe f91b 	bl	80271f4 <E_EEPROM_XMC4_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028fbe:	2800      	cmp	r0, #0
 8028fc0:	d1c7      	bne.n	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of INTERRUPT APP instance INTERRUPT_FRAME */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&INTERRUPT_FRAME); 
 8028fc2:	484c      	ldr	r0, [pc, #304]	; (80290f4 <DAVE_Init+0x1ac>)
 8028fc4:	f7fe f814 	bl	8026ff0 <INTERRUPT_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028fc8:	2800      	cmp	r0, #0
 8028fca:	d1c2      	bne.n	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of SYSTIMER APP instance SYSTIMER_0 */
	 init_status = (DAVE_STATUS_t)SYSTIMER_Init(&SYSTIMER_0); 
 8028fcc:	484a      	ldr	r0, [pc, #296]	; (80290f8 <DAVE_Init+0x1b0>)
 8028fce:	f7fd ffcd 	bl	8026f6c <SYSTIMER_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028fd2:	2800      	cmp	r0, #0
 8028fd4:	d1bd      	bne.n	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of TIMER APP instance TIMER_DELAY */
	 init_status = (DAVE_STATUS_t)TIMER_Init(&TIMER_DELAY); 
 8028fd6:	4849      	ldr	r0, [pc, #292]	; (80290fc <DAVE_Init+0x1b4>)
 8028fd8:	f7fd fcd2 	bl	8026980 <TIMER_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028fdc:	2800      	cmp	r0, #0
 8028fde:	d1b8      	bne.n	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of TIMER APP instance TIMER_FRAME_TRIG */
	 init_status = (DAVE_STATUS_t)TIMER_Init(&TIMER_FRAME_TRIG); 
 8028fe0:	4847      	ldr	r0, [pc, #284]	; (8029100 <DAVE_Init+0x1b8>)
 8028fe2:	f7fd fccd 	bl	8026980 <TIMER_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028fe6:	2800      	cmp	r0, #0
 8028fe8:	d1b3      	bne.n	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of USBD_VCOM APP instance USBD_VCOM_0 */
	 init_status = (DAVE_STATUS_t)USBD_VCOM_Init(&USBD_VCOM_0); 
 8028fea:	4846      	ldr	r0, [pc, #280]	; (8029104 <DAVE_Init+0x1bc>)
 8028fec:	f7fc fd42 	bl	8025a74 <USBD_VCOM_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028ff0:	2800      	cmp	r0, #0
 8028ff2:	d1ae      	bne.n	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_BGT_LDO_ENABLE */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_BGT_LDO_ENABLE); 
 8028ff4:	4844      	ldr	r0, [pc, #272]	; (8029108 <DAVE_Init+0x1c0>)
 8028ff6:	f7fe fc23 	bl	8027840 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028ffa:	2800      	cmp	r0, #0
 8028ffc:	d1a9      	bne.n	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_SPI_DATA_PGA */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_SPI_DATA_PGA); 
 8028ffe:	4843      	ldr	r0, [pc, #268]	; (802910c <DAVE_Init+0x1c4>)
 8029000:	f7fe fc1e 	bl	8027840 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8029004:	2800      	cmp	r0, #0
 8029006:	d1a4      	bne.n	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_SPI_M_CS_PGA */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_SPI_M_CS_PGA); 
 8029008:	4841      	ldr	r0, [pc, #260]	; (8029110 <DAVE_Init+0x1c8>)
 802900a:	f7fe fc19 	bl	8027840 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802900e:	2800      	cmp	r0, #0
 8029010:	d19f      	bne.n	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_PGA_LDO_ENABLE */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_PGA_LDO_ENABLE); 
 8029012:	4840      	ldr	r0, [pc, #256]	; (8029114 <DAVE_Init+0x1cc>)
 8029014:	f7fe fc14 	bl	8027840 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8029018:	2800      	cmp	r0, #0
 802901a:	d19a      	bne.n	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of ADC_MEASUREMENT_ADV APP instance ADC_MEASUREMENT_ADV_G2 */
	 init_status = (DAVE_STATUS_t)ADC_MEASUREMENT_ADV_Init(&ADC_MEASUREMENT_ADV_G2); 
 802901c:	483e      	ldr	r0, [pc, #248]	; (8029118 <DAVE_Init+0x1d0>)
 802901e:	f7ff fd17 	bl	8028a50 <ADC_MEASUREMENT_ADV_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8029022:	2800      	cmp	r0, #0
 8029024:	d195      	bne.n	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of ADC_MEASUREMENT_ADV APP instance ADC_MEASUREMENT_ADV_G3 */
	 init_status = (DAVE_STATUS_t)ADC_MEASUREMENT_ADV_Init(&ADC_MEASUREMENT_ADV_G3); 
 8029026:	483d      	ldr	r0, [pc, #244]	; (802911c <DAVE_Init+0x1d4>)
 8029028:	f7ff fd12 	bl	8028a50 <ADC_MEASUREMENT_ADV_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802902c:	2800      	cmp	r0, #0
 802902e:	d190      	bne.n	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of ADC_MEASUREMENT_ADV APP instance ADC_MEASUREMENT_ADV_G4 */
	 init_status = (DAVE_STATUS_t)ADC_MEASUREMENT_ADV_Init(&ADC_MEASUREMENT_ADV_G4); 
 8029030:	483b      	ldr	r0, [pc, #236]	; (8029120 <DAVE_Init+0x1d8>)
 8029032:	f7ff fd0d 	bl	8028a50 <ADC_MEASUREMENT_ADV_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8029036:	2800      	cmp	r0, #0
 8029038:	d18b      	bne.n	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of DMA_CH APP instance DMA_CH_I1 */
	 init_status = (DAVE_STATUS_t)DMA_CH_Init(&DMA_CH_I1); 
 802903a:	483a      	ldr	r0, [pc, #232]	; (8029124 <DAVE_Init+0x1dc>)
 802903c:	f7fe fb6c 	bl	8027718 <DMA_CH_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8029040:	2800      	cmp	r0, #0
 8029042:	d186      	bne.n	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of DMA_CH APP instance DMA_CH_Q1 */
	 init_status = (DAVE_STATUS_t)DMA_CH_Init(&DMA_CH_Q1); 
 8029044:	4838      	ldr	r0, [pc, #224]	; (8029128 <DAVE_Init+0x1e0>)
 8029046:	f7fe fb67 	bl	8027718 <DMA_CH_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802904a:	2800      	cmp	r0, #0
 802904c:	d181      	bne.n	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of DMA_CH APP instance DMA_CH_I2 */
	 init_status = (DAVE_STATUS_t)DMA_CH_Init(&DMA_CH_I2); 
 802904e:	4837      	ldr	r0, [pc, #220]	; (802912c <DAVE_Init+0x1e4>)
 8029050:	f7fe fb62 	bl	8027718 <DMA_CH_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8029054:	2800      	cmp	r0, #0
 8029056:	f47f af7c 	bne.w	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of DMA_CH APP instance DMA_CH_Q2 */
	 init_status = (DAVE_STATUS_t)DMA_CH_Init(&DMA_CH_Q2); 
 802905a:	4835      	ldr	r0, [pc, #212]	; (8029130 <DAVE_Init+0x1e8>)
 802905c:	f7fe fb5c 	bl	8027718 <DMA_CH_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8029060:	2800      	cmp	r0, #0
 8029062:	f47f af76 	bne.w	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of ADC_MEASUREMENT_ADV APP instance ADC_MEASUREMENT_SCAN */
	 init_status = (DAVE_STATUS_t)ADC_MEASUREMENT_ADV_Init(&ADC_MEASUREMENT_SCAN); 
 8029066:	4833      	ldr	r0, [pc, #204]	; (8029134 <DAVE_Init+0x1ec>)
 8029068:	f7ff fcf2 	bl	8028a50 <ADC_MEASUREMENT_ADV_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802906c:	2800      	cmp	r0, #0
 802906e:	f47f af70 	bne.w	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of EVENT_DETECTOR APP instance EVENT_DETECTOR_PLL_TRIG1 */
	 init_status = (DAVE_STATUS_t)EVENT_DETECTOR_Init(&EVENT_DETECTOR_PLL_TRIG1); 
 8029072:	4831      	ldr	r0, [pc, #196]	; (8029138 <DAVE_Init+0x1f0>)
 8029074:	f7fe fb40 	bl	80276f8 <EVENT_DETECTOR_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8029078:	2800      	cmp	r0, #0
 802907a:	f47f af6a 	bne.w	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of EVENT_GENERATOR APP instance EVENT_GENERATOR_CCU4 */
	 init_status = (DAVE_STATUS_t)EVENT_GENERATOR_Init(&EVENT_GENERATOR_CCU4); 
 802907e:	482f      	ldr	r0, [pc, #188]	; (802913c <DAVE_Init+0x1f4>)
 8029080:	f7fe fb28 	bl	80276d4 <EVENT_GENERATOR_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8029084:	2800      	cmp	r0, #0
 8029086:	f47f af64 	bne.w	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of CCU4_SLICE_CONFIG APP instance CCU4_SLICE_CONFIG_ADC_TRIG */
	 init_status = (DAVE_STATUS_t)CCU4_SLICE_CONFIG_Init(&CCU4_SLICE_CONFIG_ADC_TRIG); 
 802908a:	482d      	ldr	r0, [pc, #180]	; (8029140 <DAVE_Init+0x1f8>)
 802908c:	f7ff fc74 	bl	8028978 <CCU4_SLICE_CONFIG_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8029090:	2800      	cmp	r0, #0
 8029092:	f47f af5e 	bne.w	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_PLL_MUXIN */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_PLL_MUXIN); 
 8029096:	482b      	ldr	r0, [pc, #172]	; (8029144 <DAVE_Init+0x1fc>)
 8029098:	f7fe fbd2 	bl	8027840 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802909c:	2800      	cmp	r0, #0
 802909e:	f47f af58 	bne.w	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_LED1 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_LED1); 
 80290a2:	4829      	ldr	r0, [pc, #164]	; (8029148 <DAVE_Init+0x200>)
 80290a4:	f7fe fbcc 	bl	8027840 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80290a8:	2800      	cmp	r0, #0
 80290aa:	f47f af52 	bne.w	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of TIMER APP instance TIMER_WATCHDOG */
	 init_status = (DAVE_STATUS_t)TIMER_Init(&TIMER_WATCHDOG); 
 80290ae:	4827      	ldr	r0, [pc, #156]	; (802914c <DAVE_Init+0x204>)
 80290b0:	f7fd fc66 	bl	8026980 <TIMER_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80290b4:	2800      	cmp	r0, #0
 80290b6:	f47f af4c 	bne.w	8028f52 <DAVE_Init+0xa>
  {
	 /**  Initialization of INTERRUPT APP instance INTERRUPT_WATCHDOG */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&INTERRUPT_WATCHDOG); 
 80290ba:	4825      	ldr	r0, [pc, #148]	; (8029150 <DAVE_Init+0x208>)
   }  
  return init_status;
} /**  End of function DAVE_Init */
 80290bc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	 init_status = (DAVE_STATUS_t)TIMER_Init(&TIMER_WATCHDOG); 
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
  {
	 /**  Initialization of INTERRUPT APP instance INTERRUPT_WATCHDOG */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&INTERRUPT_WATCHDOG); 
 80290c0:	f7fd bf96 	b.w	8026ff0 <INTERRUPT_Init>
 80290c4:	1fff2a90 	.word	0x1fff2a90
 80290c8:	08031d38 	.word	0x08031d38
 80290cc:	08030d84 	.word	0x08030d84
 80290d0:	08030c80 	.word	0x08030c80
 80290d4:	08030cf8 	.word	0x08030cf8
 80290d8:	08030ca8 	.word	0x08030ca8
 80290dc:	08030d34 	.word	0x08030d34
 80290e0:	08030d0c 	.word	0x08030d0c
 80290e4:	08030d70 	.word	0x08030d70
 80290e8:	08030cd0 	.word	0x08030cd0
 80290ec:	08030ce4 	.word	0x08030ce4
 80290f0:	1fff2a8c 	.word	0x1fff2a8c
 80290f4:	08030be8 	.word	0x08030be8
 80290f8:	1fff1a88 	.word	0x1fff1a88
 80290fc:	1ffe88f8 	.word	0x1ffe88f8
 8029100:	1ffe8978 	.word	0x1ffe8978
 8029104:	1fff1a40 	.word	0x1fff1a40
 8029108:	08030c6c 	.word	0x08030c6c
 802910c:	08030c94 	.word	0x08030c94
 8029110:	08030cbc 	.word	0x08030cbc
 8029114:	08030d5c 	.word	0x08030d5c
 8029118:	08031d54 	.word	0x08031d54
 802911c:	08031d70 	.word	0x08031d70
 8029120:	08031d8c 	.word	0x08031d8c
 8029124:	1ffe8ae0 	.word	0x1ffe8ae0
 8029128:	1ffe8a68 	.word	0x1ffe8a68
 802912c:	1ffe8b48 	.word	0x1ffe8b48
 8029130:	1ffe8a78 	.word	0x1ffe8a78
 8029134:	08031c4c 	.word	0x08031c4c
 8029138:	1ffe8a58 	.word	0x1ffe8a58
 802913c:	1ffe8a48 	.word	0x1ffe8a48
 8029140:	08031bb4 	.word	0x08031bb4
 8029144:	08030d20 	.word	0x08030d20
 8029148:	08030d48 	.word	0x08030d48
 802914c:	1ffe893c 	.word	0x1ffe893c
 8029150:	08030be4 	.word	0x08030be4

08029154 <fft_init>:
#if (RANGE_FFT_SIZE == 1024U)
	fast_time_twiddle_table = &arm_cfft_sR_f32_len1024;		// as FFT_SIZE = 1024 points
#elif (RANGE_FFT_SIZE == 512U)
	fast_time_twiddle_table = &arm_cfft_sR_f32_len512;		// as FFT_SIZE = 512 points
#elif (RANGE_FFT_SIZE == 256U)
	fast_time_twiddle_table = &arm_cfft_sR_f32_len256;		// as FFT_SIZE = 256 points
 8029154:	4903      	ldr	r1, [pc, #12]	; (8029164 <fft_init+0x10>)
	fast_time_twiddle_table = &arm_cfft_sR_f32_len64;		// as FFT_SIZE = 64 points
#endif

	/* Slow Time FFT */
#if (DOPPLER_FFT_SIZE == 64U)
	slow_time_twiddle_table = &arm_cfft_sR_f32_len64;		// as FFT_SIZE = 64 points
 8029156:	4b04      	ldr	r3, [pc, #16]	; (8029168 <fft_init+0x14>)
#if (RANGE_FFT_SIZE == 1024U)
	fast_time_twiddle_table = &arm_cfft_sR_f32_len1024;		// as FFT_SIZE = 1024 points
#elif (RANGE_FFT_SIZE == 512U)
	fast_time_twiddle_table = &arm_cfft_sR_f32_len512;		// as FFT_SIZE = 512 points
#elif (RANGE_FFT_SIZE == 256U)
	fast_time_twiddle_table = &arm_cfft_sR_f32_len256;		// as FFT_SIZE = 256 points
 8029158:	4804      	ldr	r0, [pc, #16]	; (802916c <fft_init+0x18>)
	fast_time_twiddle_table = &arm_cfft_sR_f32_len64;		// as FFT_SIZE = 64 points
#endif

	/* Slow Time FFT */
#if (DOPPLER_FFT_SIZE == 64U)
	slow_time_twiddle_table = &arm_cfft_sR_f32_len64;		// as FFT_SIZE = 64 points
 802915a:	4a05      	ldr	r2, [pc, #20]	; (8029170 <fft_init+0x1c>)
#if (RANGE_FFT_SIZE == 1024U)
	fast_time_twiddle_table = &arm_cfft_sR_f32_len1024;		// as FFT_SIZE = 1024 points
#elif (RANGE_FFT_SIZE == 512U)
	fast_time_twiddle_table = &arm_cfft_sR_f32_len512;		// as FFT_SIZE = 512 points
#elif (RANGE_FFT_SIZE == 256U)
	fast_time_twiddle_table = &arm_cfft_sR_f32_len256;		// as FFT_SIZE = 256 points
 802915c:	6008      	str	r0, [r1, #0]
	fast_time_twiddle_table = &arm_cfft_sR_f32_len64;		// as FFT_SIZE = 64 points
#endif

	/* Slow Time FFT */
#if (DOPPLER_FFT_SIZE == 64U)
	slow_time_twiddle_table = &arm_cfft_sR_f32_len64;		// as FFT_SIZE = 64 points
 802915e:	601a      	str	r2, [r3, #0]
 8029160:	4770      	bx	lr
 8029162:	bf00      	nop
 8029164:	2000da60 	.word	0x2000da60
 8029168:	2000da5c 	.word	0x2000da5c
 802916c:	08031b88 	.word	0x08031b88
 8029170:	08031b78 	.word	0x08031b78

08029174 <compute_fft_signal>:
//============================================================================

void compute_fft_signal(float* i_data, float* q_data, uint16_t Nd, uint16_t Nf, float if_scale,
						FFT_Input_t fft_type, FFT_Direction_t fft_direction,
						float* i_mean, float* q_mean, float* complex_fft_signal)
{
 8029174:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8029178:	ed2d 8b02 	vpush	{d8}
 802917c:	b087      	sub	sp, #28
 802917e:	ed9d 8a12 	vldr	s16, [sp, #72]	; 0x48
 8029182:	f89d 5050 	ldrb.w	r5, [sp, #80]	; 0x50
 8029186:	f89d c04c 	ldrb.w	ip, [sp, #76]	; 0x4c
 802918a:	f8dd a054 	ldr.w	sl, [sp, #84]	; 0x54
 802918e:	f8dd 9058 	ldr.w	r9, [sp, #88]	; 0x58
 8029192:	f8dd b05c 	ldr.w	fp, [sp, #92]	; 0x5c
 8029196:	9302      	str	r3, [sp, #8]
 8029198:	4607      	mov	r7, r0
 802919a:	460e      	mov	r6, r1
 802919c:	4614      	mov	r4, r2
	uint32_t dec_idx;   // decimation index of FFT window in case selected data points are less than Window length
	float *fft_window;
	const arm_cfft_instance_f32 *cfft_twiddle_table;


	if (fft_direction == FFT_FAST_TIME)
 802919e:	2d00      	cmp	r5, #0
 80291a0:	f040 809b 	bne.w	80292da <compute_fft_signal+0x166>
	{
		fft_window = FastTime_Window;

		cfft_twiddle_table = fast_time_twiddle_table;
 80291a4:	4b72      	ldr	r3, [pc, #456]	; (8029370 <compute_fft_signal+0x1fc>)
	const arm_cfft_instance_f32 *cfft_twiddle_table;


	if (fft_direction == FFT_FAST_TIME)
	{
		fft_window = FastTime_Window;
 80291a6:	4d73      	ldr	r5, [pc, #460]	; (8029374 <compute_fft_signal+0x200>)

		cfft_twiddle_table = fast_time_twiddle_table;
 80291a8:	681b      	ldr	r3, [r3, #0]
 80291aa:	9303      	str	r3, [sp, #12]

		dec_idx = FAST_TIME_FFT_WIN_LEN / Nd;
 80291ac:	f44f 7880 	mov.w	r8, #256	; 0x100
 80291b0:	fbb8 f8f2 	udiv	r8, r8, r2

		dec_idx = SLOW_TIME_FFT_WIN_LEN / Nd;
	}

	/* Find the mean in i_data */
	arm_mean_f32(i_data, Nd, i_mean);
 80291b4:	4638      	mov	r0, r7
 80291b6:	4621      	mov	r1, r4
 80291b8:	4652      	mov	r2, sl
 80291ba:	f8cd c000 	str.w	ip, [sp]
 80291be:	f7ff fa93 	bl	80286e8 <arm_mean_f32>

	/* Find the mean in q_data */
	arm_mean_f32(q_data, Nd, q_mean);
 80291c2:	4630      	mov	r0, r6
 80291c4:	4621      	mov	r1, r4
 80291c6:	464a      	mov	r2, r9
 80291c8:	f7ff fa8e 	bl	80286e8 <arm_mean_f32>

	if (fft_type == FFT_INPUT_REAL_I)
 80291cc:	f8dd c000 	ldr.w	ip, [sp]
 80291d0:	f1bc 0f00 	cmp.w	ip, #0
 80291d4:	d155      	bne.n	8029282 <compute_fft_signal+0x10e>
	{
		/* Interleaved (re = I & im = 0) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
 80291d6:	2c00      	cmp	r4, #0
 80291d8:	d03b      	beq.n	8029252 <compute_fft_signal+0xde>
 80291da:	ee18 0a10 	vmov	r0, s16
 80291de:	f004 fe3f 	bl	802de60 <__aeabi_f2d>
 80291e2:	e9cd 0100 	strd	r0, r1, [sp]
 80291e6:	eb0b 02c4 	add.w	r2, fp, r4, lsl #3
 80291ea:	ea4f 0388 	mov.w	r3, r8, lsl #2
		{
			complex_fft_signal[2 * idx + 0] = 2.0 * (float)(i_data[idx] - *i_mean) * if_scale * fft_window[idx*dec_idx];	// additional scaling by 2 for real input FFT
			complex_fft_signal[2 * idx + 1] = 0;
 80291ee:	ed9f 8a62 	vldr	s16, [pc, #392]	; 8029378 <compute_fft_signal+0x204>
 80291f2:	9404      	str	r4, [sp, #16]
 80291f4:	465e      	mov	r6, fp
 80291f6:	f8cd b014 	str.w	fp, [sp, #20]
 80291fa:	461c      	mov	r4, r3
 80291fc:	4693      	mov	fp, r2
	if (fft_type == FFT_INPUT_REAL_I)
	{
		/* Interleaved (re = I & im = 0) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
		{
			complex_fft_signal[2 * idx + 0] = 2.0 * (float)(i_data[idx] - *i_mean) * if_scale * fft_window[idx*dec_idx];	// additional scaling by 2 for real input FFT
 80291fe:	ecb7 7a01 	vldmia	r7!, {s14}
 8029202:	edda 7a00 	vldr	s15, [sl]
 8029206:	ee77 7a67 	vsub.f32	s15, s14, s15
 802920a:	3608      	adds	r6, #8
 802920c:	ee17 0a90 	vmov	r0, s15
 8029210:	f004 fe26 	bl	802de60 <__aeabi_f2d>
 8029214:	4602      	mov	r2, r0
 8029216:	460b      	mov	r3, r1
 8029218:	f004 fcc4 	bl	802dba4 <__adddf3>
 802921c:	e9dd 2300 	ldrd	r2, r3, [sp]
 8029220:	f004 fe72 	bl	802df08 <__aeabi_dmul>
 8029224:	4680      	mov	r8, r0
 8029226:	6828      	ldr	r0, [r5, #0]
 8029228:	4689      	mov	r9, r1
 802922a:	f004 fe19 	bl	802de60 <__aeabi_f2d>
 802922e:	4602      	mov	r2, r0
 8029230:	460b      	mov	r3, r1
 8029232:	4640      	mov	r0, r8
 8029234:	4649      	mov	r1, r9
 8029236:	f004 fe67 	bl	802df08 <__aeabi_dmul>
 802923a:	f005 f947 	bl	802e4cc <__aeabi_d2f>
			complex_fft_signal[2 * idx + 1] = 0;
 802923e:	ed06 8a01 	vstr	s16, [r6, #-4]
	if (fft_type == FFT_INPUT_REAL_I)
	{
		/* Interleaved (re = I & im = 0) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
		{
			complex_fft_signal[2 * idx + 0] = 2.0 * (float)(i_data[idx] - *i_mean) * if_scale * fft_window[idx*dec_idx];	// additional scaling by 2 for real input FFT
 8029242:	f846 0c08 	str.w	r0, [r6, #-8]
	arm_mean_f32(q_data, Nd, q_mean);

	if (fft_type == FFT_INPUT_REAL_I)
	{
		/* Interleaved (re = I & im = 0) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
 8029246:	455e      	cmp	r6, fp
 8029248:	4425      	add	r5, r4
 802924a:	d1d8      	bne.n	80291fe <compute_fft_signal+0x8a>
 802924c:	9c04      	ldr	r4, [sp, #16]
 802924e:	f8dd b014 	ldr.w	fp, [sp, #20]
			complex_fft_signal[2 * idx + 1] = (float)(q_data[idx] - *q_mean) * if_scale * fft_window[idx*dec_idx];
		}
	}

	/* Zero Padding */
	for (uint16_t idx = Nd; idx < Nf; idx++)
 8029252:	9b02      	ldr	r3, [sp, #8]
 8029254:	429c      	cmp	r4, r3
 8029256:	d209      	bcs.n	802926c <compute_fft_signal+0xf8>
 8029258:	4618      	mov	r0, r3
	{
		complex_fft_signal[2 * idx + 0] = 0;
 802925a:	2200      	movs	r2, #0
			complex_fft_signal[2 * idx + 1] = (float)(q_data[idx] - *q_mean) * if_scale * fft_window[idx*dec_idx];
		}
	}

	/* Zero Padding */
	for (uint16_t idx = Nd; idx < Nf; idx++)
 802925c:	1c61      	adds	r1, r4, #1
	{
		complex_fft_signal[2 * idx + 0] = 0;
 802925e:	eb0b 03c4 	add.w	r3, fp, r4, lsl #3
			complex_fft_signal[2 * idx + 1] = (float)(q_data[idx] - *q_mean) * if_scale * fft_window[idx*dec_idx];
		}
	}

	/* Zero Padding */
	for (uint16_t idx = Nd; idx < Nf; idx++)
 8029262:	b28c      	uxth	r4, r1
 8029264:	4284      	cmp	r4, r0
	{
		complex_fft_signal[2 * idx + 0] = 0;
 8029266:	601a      	str	r2, [r3, #0]
		complex_fft_signal[2 * idx + 1] = 0;
 8029268:	605a      	str	r2, [r3, #4]
			complex_fft_signal[2 * idx + 1] = (float)(q_data[idx] - *q_mean) * if_scale * fft_window[idx*dec_idx];
		}
	}

	/* Zero Padding */
	for (uint16_t idx = Nd; idx < Nf; idx++)
 802926a:	d1f7      	bne.n	802925c <compute_fft_signal+0xe8>
		complex_fft_signal[2 * idx + 0] = 0;
		complex_fft_signal[2 * idx + 1] = 0;
	}

	/* Processing the floating-point complex FFT. */
	arm_cfft_f32(cfft_twiddle_table, complex_fft_signal, 0, 1);
 802926c:	9803      	ldr	r0, [sp, #12]
 802926e:	4659      	mov	r1, fp
 8029270:	2200      	movs	r2, #0
 8029272:	2301      	movs	r3, #1
}
 8029274:	b007      	add	sp, #28
 8029276:	ecbd 8b02 	vpop	{d8}
 802927a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		complex_fft_signal[2 * idx + 0] = 0;
		complex_fft_signal[2 * idx + 1] = 0;
	}

	/* Processing the floating-point complex FFT. */
	arm_cfft_f32(cfft_twiddle_table, complex_fft_signal, 0, 1);
 802927e:	f7fe be89 	b.w	8027f94 <arm_cfft_f32>
		{
			complex_fft_signal[2 * idx + 0] = 2.0 * (float)(i_data[idx] - *i_mean) * if_scale * fft_window[idx*dec_idx];	// additional scaling by 2 for real input FFT
			complex_fft_signal[2 * idx + 1] = 0;
		}
	}
	else if (fft_type == FFT_INPUT_REAL_Q)
 8029282:	f1bc 0f01 	cmp.w	ip, #1
 8029286:	d031      	beq.n	80292ec <compute_fft_signal+0x178>
		}
	}
	else
	{
		/* Interleaved (re = I & im = Q) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
 8029288:	2c00      	cmp	r4, #0
 802928a:	d0e2      	beq.n	8029252 <compute_fft_signal+0xde>
 802928c:	ea4f 0888 	mov.w	r8, r8, lsl #2
 8029290:	eb07 0284 	add.w	r2, r7, r4, lsl #2
 8029294:	465b      	mov	r3, fp
		{
			complex_fft_signal[2 * idx + 0] = (float)(i_data[idx] - *i_mean) * if_scale * fft_window[idx*dec_idx];
 8029296:	ecf7 6a01 	vldmia	r7!, {s13}
 802929a:	edda 7a00 	vldr	s15, [sl]
 802929e:	ed95 7a00 	vldr	s14, [r5]
 80292a2:	ee76 7ae7 	vsub.f32	s15, s13, s15
		}
	}
	else
	{
		/* Interleaved (re = I & im = Q) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
 80292a6:	4297      	cmp	r7, r2
		{
			complex_fft_signal[2 * idx + 0] = (float)(i_data[idx] - *i_mean) * if_scale * fft_window[idx*dec_idx];
 80292a8:	ee67 7a88 	vmul.f32	s15, s15, s16
 80292ac:	f103 0308 	add.w	r3, r3, #8
 80292b0:	ee67 7a87 	vmul.f32	s15, s15, s14
 80292b4:	ed43 7a02 	vstr	s15, [r3, #-8]
			complex_fft_signal[2 * idx + 1] = (float)(q_data[idx] - *q_mean) * if_scale * fft_window[idx*dec_idx];
 80292b8:	ecf6 6a01 	vldmia	r6!, {s13}
 80292bc:	edd9 7a00 	vldr	s15, [r9]
 80292c0:	ed95 7a00 	vldr	s14, [r5]
 80292c4:	ee76 7ae7 	vsub.f32	s15, s13, s15
 80292c8:	4445      	add	r5, r8
 80292ca:	ee67 7a88 	vmul.f32	s15, s15, s16
 80292ce:	ee67 7a87 	vmul.f32	s15, s15, s14
 80292d2:	ed43 7a01 	vstr	s15, [r3, #-4]
		}
	}
	else
	{
		/* Interleaved (re = I & im = Q) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
 80292d6:	d1de      	bne.n	8029296 <compute_fft_signal+0x122>
 80292d8:	e7bb      	b.n	8029252 <compute_fft_signal+0xde>
	}
	else /* fft_direction == FFT_SLOW_TIME */
	{
		fft_window = SlowTime_Window;

		cfft_twiddle_table = slow_time_twiddle_table;
 80292da:	4b28      	ldr	r3, [pc, #160]	; (802937c <compute_fft_signal+0x208>)

		dec_idx = FAST_TIME_FFT_WIN_LEN / Nd;
	}
	else /* fft_direction == FFT_SLOW_TIME */
	{
		fft_window = SlowTime_Window;
 80292dc:	4d28      	ldr	r5, [pc, #160]	; (8029380 <compute_fft_signal+0x20c>)

		cfft_twiddle_table = slow_time_twiddle_table;
 80292de:	681b      	ldr	r3, [r3, #0]
 80292e0:	9303      	str	r3, [sp, #12]

		dec_idx = SLOW_TIME_FFT_WIN_LEN / Nd;
 80292e2:	f04f 0810 	mov.w	r8, #16
 80292e6:	fbb8 f8f2 	udiv	r8, r8, r2
 80292ea:	e763      	b.n	80291b4 <compute_fft_signal+0x40>
		}
	}
	else if (fft_type == FFT_INPUT_REAL_Q)
	{
		/* Interleaved (re = Q & im = 0) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
 80292ec:	2c00      	cmp	r4, #0
 80292ee:	d0b0      	beq.n	8029252 <compute_fft_signal+0xde>
 80292f0:	ee18 0a10 	vmov	r0, s16
 80292f4:	f004 fdb4 	bl	802de60 <__aeabi_f2d>
 80292f8:	e9cd 0100 	strd	r0, r1, [sp]
 80292fc:	ea4f 0388 	mov.w	r3, r8, lsl #2
 8029300:	eb0b 02c4 	add.w	r2, fp, r4, lsl #3
		{
			complex_fft_signal[2 * idx + 0] = 2.0 * (float)(q_data[idx] - *q_mean) * if_scale * fft_window[idx*dec_idx];	// additional scaling by 2 for real input FFT
			complex_fft_signal[2 * idx + 1] = 0;
 8029304:	ed9f 8a1c 	vldr	s16, [pc, #112]	; 8029378 <compute_fft_signal+0x204>
 8029308:	9404      	str	r4, [sp, #16]
 802930a:	46a8      	mov	r8, r5
 802930c:	f8cd b014 	str.w	fp, [sp, #20]
 8029310:	465d      	mov	r5, fp
 8029312:	46b2      	mov	sl, r6
 8029314:	461c      	mov	r4, r3
 8029316:	4693      	mov	fp, r2
	else if (fft_type == FFT_INPUT_REAL_Q)
	{
		/* Interleaved (re = Q & im = 0) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
		{
			complex_fft_signal[2 * idx + 0] = 2.0 * (float)(q_data[idx] - *q_mean) * if_scale * fft_window[idx*dec_idx];	// additional scaling by 2 for real input FFT
 8029318:	ecba 7a01 	vldmia	sl!, {s14}
 802931c:	edd9 7a00 	vldr	s15, [r9]
 8029320:	ee77 7a67 	vsub.f32	s15, s14, s15
 8029324:	3508      	adds	r5, #8
 8029326:	ee17 0a90 	vmov	r0, s15
 802932a:	f004 fd99 	bl	802de60 <__aeabi_f2d>
 802932e:	4602      	mov	r2, r0
 8029330:	460b      	mov	r3, r1
 8029332:	f004 fc37 	bl	802dba4 <__adddf3>
 8029336:	e9dd 2300 	ldrd	r2, r3, [sp]
 802933a:	f004 fde5 	bl	802df08 <__aeabi_dmul>
 802933e:	4606      	mov	r6, r0
 8029340:	f8d8 0000 	ldr.w	r0, [r8]
 8029344:	460f      	mov	r7, r1
 8029346:	f004 fd8b 	bl	802de60 <__aeabi_f2d>
 802934a:	4602      	mov	r2, r0
 802934c:	460b      	mov	r3, r1
 802934e:	4630      	mov	r0, r6
 8029350:	4639      	mov	r1, r7
 8029352:	f004 fdd9 	bl	802df08 <__aeabi_dmul>
 8029356:	f005 f8b9 	bl	802e4cc <__aeabi_d2f>
			complex_fft_signal[2 * idx + 1] = 0;
 802935a:	ed05 8a01 	vstr	s16, [r5, #-4]
	else if (fft_type == FFT_INPUT_REAL_Q)
	{
		/* Interleaved (re = Q & im = 0) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
		{
			complex_fft_signal[2 * idx + 0] = 2.0 * (float)(q_data[idx] - *q_mean) * if_scale * fft_window[idx*dec_idx];	// additional scaling by 2 for real input FFT
 802935e:	f845 0c08 	str.w	r0, [r5, #-8]
		}
	}
	else if (fft_type == FFT_INPUT_REAL_Q)
	{
		/* Interleaved (re = Q & im = 0) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
 8029362:	455d      	cmp	r5, fp
 8029364:	44a0      	add	r8, r4
 8029366:	d1d7      	bne.n	8029318 <compute_fft_signal+0x1a4>
 8029368:	9c04      	ldr	r4, [sp, #16]
 802936a:	f8dd b014 	ldr.w	fp, [sp, #20]
 802936e:	e770      	b.n	8029252 <compute_fft_signal+0xde>
 8029370:	2000da60 	.word	0x2000da60
 8029374:	1ffe8b84 	.word	0x1ffe8b84
 8029378:	00000000 	.word	0x00000000
 802937c:	2000da5c 	.word	0x2000da5c
 8029380:	1ffe8f84 	.word	0x1ffe8f84

08029384 <compute_fft_spectrum>:
}

//============================================================================

void compute_fft_spectrum(float* fft_input_signal, uint32_t Nf, float* fft_output_spectrum)
{
 8029384:	460b      	mov	r3, r1
	/* Convert to real magnitude data */
	arm_cmplx_mag_f32(fft_input_signal, fft_output_spectrum, Nf);
 8029386:	4611      	mov	r1, r2
 8029388:	461a      	mov	r2, r3
 802938a:	f7ff b9e1 	b.w	8028750 <arm_cmplx_mag_f32>
 802938e:	bf00      	nop

08029390 <compute_angle>:
}
//============================================================================

target_angle_data compute_angle(float if1_i, float if1_q, float if2_i, float if2_q, double d_old, int16_t angle_offset_deg, float wave_length_ant_spacing_ratio)
{
 8029390:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8029392:	ed2d 8b04 	vpush	{d8-d9}
 8029396:	ee08 1a10 	vmov	s16, r1
double get_phase(float real, float imag)
{
	double phi;

	/* Phase angle (0 to 2Pi) */
	if((real > 0) && (imag >= 0))		// 1st quadrant
 802939a:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 802939e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	arm_cmplx_mag_f32(fft_input_signal, fft_output_spectrum, Nf);
}
//============================================================================

target_angle_data compute_angle(float if1_i, float if1_q, float if2_i, float if2_q, double d_old, int16_t angle_offset_deg, float wave_length_ant_spacing_ratio)
{
 80293a2:	4604      	mov	r4, r0
 80293a4:	ee07 2a90 	vmov	s15, r2
 80293a8:	ee09 3a10 	vmov	s18, r3
 80293ac:	eddd 9a0a 	vldr	s19, [sp, #40]	; 0x28
 80293b0:	f9bd 5038 	ldrsh.w	r5, [sp, #56]	; 0x38
 80293b4:	eddd 8a0f 	vldr	s17, [sp, #60]	; 0x3c
double get_phase(float real, float imag)
{
	double phi;

	/* Phase angle (0 to 2Pi) */
	if((real > 0) && (imag >= 0))		// 1st quadrant
 80293b8:	f340 80bf 	ble.w	802953a <compute_angle+0x1aa>
 80293bc:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80293c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80293c4:	f2c0 80b9 	blt.w	802953a <compute_angle+0x1aa>
	{
		phi = atan((double)imag / (double)real);
 80293c8:	4610      	mov	r0, r2
 80293ca:	f004 fd49 	bl	802de60 <__aeabi_f2d>
 80293ce:	4606      	mov	r6, r0
 80293d0:	ee18 0a10 	vmov	r0, s16
 80293d4:	460f      	mov	r7, r1
 80293d6:	f004 fd43 	bl	802de60 <__aeabi_f2d>
 80293da:	4602      	mov	r2, r0
 80293dc:	460b      	mov	r3, r1
 80293de:	4630      	mov	r0, r6
 80293e0:	4639      	mov	r1, r7
 80293e2:	f004 febb 	bl	802e15c <__aeabi_ddiv>
 80293e6:	f003 fb6f 	bl	802cac8 <atan>
 80293ea:	f005 f86f 	bl	802e4cc <__aeabi_d2f>
 80293ee:	ee08 0a10 	vmov	s16, r0
double get_phase(float real, float imag)
{
	double phi;

	/* Phase angle (0 to 2Pi) */
	if((real > 0) && (imag >= 0))		// 1st quadrant
 80293f2:	eeb5 9ac0 	vcmpe.f32	s18, #0.0
 80293f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80293fa:	f340 80c2 	ble.w	8029582 <compute_angle+0x1f2>
 80293fe:	eef5 9ac0 	vcmpe.f32	s19, #0.0
 8029402:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8029406:	f2c0 80bc 	blt.w	8029582 <compute_angle+0x1f2>
	{
		phi = atan((double)imag / (double)real);
 802940a:	ee19 0a90 	vmov	r0, s19
 802940e:	f004 fd27 	bl	802de60 <__aeabi_f2d>
 8029412:	4606      	mov	r6, r0
 8029414:	ee19 0a10 	vmov	r0, s18
 8029418:	460f      	mov	r7, r1
 802941a:	f004 fd21 	bl	802de60 <__aeabi_f2d>
 802941e:	4602      	mov	r2, r0
 8029420:	460b      	mov	r3, r1
 8029422:	4630      	mov	r0, r6
 8029424:	4639      	mov	r1, r7
 8029426:	f004 fe99 	bl	802e15c <__aeabi_ddiv>
 802942a:	f003 fb4d 	bl	802cac8 <atan>
 802942e:	f005 f84d 	bl	802e4cc <__aeabi_d2f>
 8029432:	ee07 0a90 	vmov	s15, r0

	rx1_ang = get_phase(if1_i, if1_q); //- (double)(0.13 * PI);

	rx2_ang = get_phase(if2_i, if2_q);

	d_phi = (rx1_ang - rx2_ang);
 8029436:	ee78 7a67 	vsub.f32	s15, s16, s15

	if (d_phi <= 0)
	{
		d_phi += 2*PI;
	}
	d_phi -= PI;
 802943a:	ed9f 8ab3 	vldr	s16, [pc, #716]	; 8029708 <compute_angle+0x378>

	rx2_ang = get_phase(if2_i, if2_q);

	d_phi = (rx1_ang - rx2_ang);

	if (d_phi <= 0)
 802943e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8029442:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	{
		d_phi += 2*PI;
 8029446:	bf9c      	itt	ls
 8029448:	ed9f 7ab0 	vldrls	s14, [pc, #704]	; 802970c <compute_angle+0x37c>
 802944c:	ee77 7a87 	vaddls.f32	s15, s15, s14
	}
	d_phi -= PI;

	if ((uint32_t)d_old == IGNORE_NAN)
 8029450:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30

	if (d_phi <= 0)
	{
		d_phi += 2*PI;
	}
	d_phi -= PI;
 8029454:	ee37 8ac8 	vsub.f32	s16, s15, s16

	if ((uint32_t)d_old == IGNORE_NAN)
 8029458:	f005 f818 	bl	802e48c <__aeabi_d2uiz>
 802945c:	f240 232b 	movw	r3, #555	; 0x22b
 8029460:	4298      	cmp	r0, r3
 8029462:	d027      	beq.n	80294b4 <compute_angle+0x124>
	{
		target_angle = 0;
	}
	else if (d_phi > d_old + 0.9* PI || d_phi < d_old - 0.9* PI)
 8029464:	ee18 0a10 	vmov	r0, s16
 8029468:	f004 fcfa 	bl	802de60 <__aeabi_f2d>
 802946c:	a3a0      	add	r3, pc, #640	; (adr r3, 80296f0 <compute_angle+0x360>)
 802946e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8029472:	4606      	mov	r6, r0
 8029474:	460f      	mov	r7, r1
 8029476:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 802947a:	f004 fb93 	bl	802dba4 <__adddf3>
 802947e:	4602      	mov	r2, r0
 8029480:	460b      	mov	r3, r1
 8029482:	4630      	mov	r0, r6
 8029484:	4639      	mov	r1, r7
 8029486:	f004 ffcf 	bl	802e428 <__aeabi_dcmpgt>
 802948a:	b968      	cbnz	r0, 80294a8 <compute_angle+0x118>
 802948c:	a398      	add	r3, pc, #608	; (adr r3, 80296f0 <compute_angle+0x360>)
 802948e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8029492:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 8029496:	f004 fb83 	bl	802dba0 <__aeabi_dsub>
 802949a:	4602      	mov	r2, r0
 802949c:	460b      	mov	r3, r1
 802949e:	4630      	mov	r0, r6
 80294a0:	4639      	mov	r1, r7
 80294a2:	f004 ffa3 	bl	802e3ec <__aeabi_dcmplt>
 80294a6:	b128      	cbz	r0, 80294b4 <compute_angle+0x124>
	{
	   d_phi = d_old;
 80294a8:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 80294ac:	f005 f80e 	bl	802e4cc <__aeabi_d2f>
 80294b0:	ee08 0a10 	vmov	s16, r0
	}

	/* Arcus sinus (-PI/2 to PI/2), input= -1..1 */
	target_angle = asin(d_phi * wave_length_ant_spacing_ratio / (2*PI));
 80294b4:	ee68 8a28 	vmul.f32	s17, s16, s17
 80294b8:	eddf 7a94 	vldr	s15, [pc, #592]	; 802970c <compute_angle+0x37c>
 80294bc:	eec8 7aa7 	vdiv.f32	s15, s17, s15
 80294c0:	ee17 0a90 	vmov	r0, s15
 80294c4:	f004 fccc 	bl	802de60 <__aeabi_f2d>
 80294c8:	f003 fca2 	bl	802ce10 <asin>
 80294cc:	f004 fffe 	bl	802e4cc <__aeabi_d2f>

	target_angle = target_angle * 180 / PI;	// Angle (-90...90)
 80294d0:	eddf 7a8f 	vldr	s15, [pc, #572]	; 8029710 <compute_angle+0x380>
 80294d4:	ed9f 7a8c 	vldr	s14, [pc, #560]	; 8029708 <compute_angle+0x378>
 80294d8:	ee06 0a90 	vmov	s13, r0
 80294dc:	ee66 7aa7 	vmul.f32	s15, s13, s15

	target_angle = target_angle + (double)((int32_t) angle_offset_deg + ANGLE_QUANTIZATION * 0.5);
 80294e0:	eec7 7a87 	vdiv.f32	s15, s15, s14
 80294e4:	ee17 0a90 	vmov	r0, s15
 80294e8:	f004 fcba 	bl	802de60 <__aeabi_f2d>
 80294ec:	4606      	mov	r6, r0
 80294ee:	4628      	mov	r0, r5
 80294f0:	460f      	mov	r7, r1
 80294f2:	f004 fca3 	bl	802de3c <__aeabi_i2d>
 80294f6:	2200      	movs	r2, #0
 80294f8:	4b86      	ldr	r3, [pc, #536]	; (8029714 <compute_angle+0x384>)
 80294fa:	f004 fb53 	bl	802dba4 <__adddf3>
 80294fe:	4602      	mov	r2, r0
 8029500:	460b      	mov	r3, r1
 8029502:	4630      	mov	r0, r6
 8029504:	4639      	mov	r1, r7
 8029506:	f004 fb4d 	bl	802dba4 <__adddf3>
 802950a:	f004 ffdf 	bl	802e4cc <__aeabi_d2f>

	delta_angle  = fmodf(target_angle , (double)ANGLE_QUANTIZATION);
 802950e:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
	/* Arcus sinus (-PI/2 to PI/2), input= -1..1 */
	target_angle = asin(d_phi * wave_length_ant_spacing_ratio / (2*PI));

	target_angle = target_angle * 180 / PI;	// Angle (-90...90)

	target_angle = target_angle + (double)((int32_t) angle_offset_deg + ANGLE_QUANTIZATION * 0.5);
 8029512:	ee08 0a90 	vmov	s17, r0

	delta_angle  = fmodf(target_angle , (double)ANGLE_QUANTIZATION);
 8029516:	f003 fccf 	bl	802ceb8 <fmodf>
 802951a:	ee09 0a10 	vmov	s18, r0

	target_angle -= delta_angle;
 802951e:	ee78 8ac9 	vsub.f32	s17, s17, s18

	temp.d_phi = d_phi;
 8029522:	ee18 0a10 	vmov	r0, s16
 8029526:	f004 fc9b 	bl	802de60 <__aeabi_f2d>

	temp.target_angle = target_angle;

	return temp;
 802952a:	edc4 8a02 	vstr	s17, [r4, #8]
}
 802952e:	ecbd 8b04 	vpop	{d8-d9}

	delta_angle  = fmodf(target_angle , (double)ANGLE_QUANTIZATION);

	target_angle -= delta_angle;

	temp.d_phi = d_phi;
 8029532:	e9c4 0100 	strd	r0, r1, [r4]

	temp.target_angle = target_angle;

	return temp;
}
 8029536:	4620      	mov	r0, r4
 8029538:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	/* Phase angle (0 to 2Pi) */
	if((real > 0) && (imag >= 0))		// 1st quadrant
	{
		phi = atan((double)imag / (double)real);
	}
	else if((real < 0) && (imag >= 0))	// 2nd quadrant
 802953a:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 802953e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8029542:	d445      	bmi.n	80295d0 <compute_angle+0x240>
	{
		phi = atan((double)imag / (double)real) + PI;
	}
	else if((real < 0) && (imag <= 0)) 	// 3rd quadrant
 8029544:	f100 808c 	bmi.w	8029660 <compute_angle+0x2d0>
	{
		phi = atan((double)imag / (double)real) + PI;
	}
	else if((real > 0) && (imag <= 0)) 	// 4th quadrant
 8029548:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 802954c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8029550:	dd05      	ble.n	802955e <compute_angle+0x1ce>
 8029552:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8029556:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802955a:	f240 80a4 	bls.w	80296a6 <compute_angle+0x316>
	{
		phi = atan((double)imag / (double)real) + 2*PI;
	}
	else if((real == 0) && (imag > 0))
 802955e:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8029562:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8029566:	d12b      	bne.n	80295c0 <compute_angle+0x230>
 8029568:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 802956c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8029570:	dd24      	ble.n	80295bc <compute_angle+0x22c>
double get_phase(float real, float imag)
{
	double phi;

	/* Phase angle (0 to 2Pi) */
	if((real > 0) && (imag >= 0))		// 1st quadrant
 8029572:	eeb5 9ac0 	vcmpe.f32	s18, #0.0
 8029576:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	}
	else if((real > 0) && (imag <= 0)) 	// 4th quadrant
	{
		phi = atan((double)imag / (double)real) + 2*PI;
	}
	else if((real == 0) && (imag > 0))
 802957a:	ed9f 8a67 	vldr	s16, [pc, #412]	; 8029718 <compute_angle+0x388>
double get_phase(float real, float imag)
{
	double phi;

	/* Phase angle (0 to 2Pi) */
	if((real > 0) && (imag >= 0))		// 1st quadrant
 802957e:	f73f af3e 	bgt.w	80293fe <compute_angle+0x6e>
	{
		phi = atan((double)imag / (double)real);
	}
	else if((real < 0) && (imag >= 0))	// 2nd quadrant
 8029582:	eeb5 9ac0 	vcmpe.f32	s18, #0.0
 8029586:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802958a:	d442      	bmi.n	8029612 <compute_angle+0x282>
	{
		phi = atan((double)imag / (double)real) + PI;
	}
	else if((real < 0) && (imag <= 0)) 	// 3rd quadrant
 802958c:	d462      	bmi.n	8029654 <compute_angle+0x2c4>
	{
		phi = atan((double)imag / (double)real) + PI;
	}
	else if((real > 0) && (imag <= 0)) 	// 4th quadrant
 802958e:	eeb5 9ac0 	vcmpe.f32	s18, #0.0
 8029592:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8029596:	dd04      	ble.n	80295a2 <compute_angle+0x212>
 8029598:	eef5 9ac0 	vcmpe.f32	s19, #0.0
 802959c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80295a0:	d965      	bls.n	802966e <compute_angle+0x2de>
	{
		phi = atan((double)imag / (double)real) + 2*PI;
	}
	else if((real == 0) && (imag > 0))
 80295a2:	eeb5 9a40 	vcmp.f32	s18, #0.0
 80295a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80295aa:	d10e      	bne.n	80295ca <compute_angle+0x23a>
 80295ac:	eef5 9ac0 	vcmpe.f32	s19, #0.0
 80295b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80295b4:	dd07      	ble.n	80295c6 <compute_angle+0x236>
 80295b6:	eddf 7a58 	vldr	s15, [pc, #352]	; 8029718 <compute_angle+0x388>
 80295ba:	e73c      	b.n	8029436 <compute_angle+0xa6>
	{
		phi = PI/2;
	}
	else if((real == 0) && (imag < 0))
 80295bc:	f100 808f 	bmi.w	80296de <compute_angle+0x34e>
	}
	else if((real > 0) && (imag <= 0)) 	// 4th quadrant
	{
		phi = atan((double)imag / (double)real) + 2*PI;
	}
	else if((real == 0) && (imag > 0))
 80295c0:	ed9f 8a56 	vldr	s16, [pc, #344]	; 802971c <compute_angle+0x38c>
 80295c4:	e715      	b.n	80293f2 <compute_angle+0x62>
	{
		phi = PI/2;
	}
	else if((real == 0) && (imag < 0))
 80295c6:	f100 808d 	bmi.w	80296e4 <compute_angle+0x354>
	}
	else if((real > 0) && (imag <= 0)) 	// 4th quadrant
	{
		phi = atan((double)imag / (double)real) + 2*PI;
	}
	else if((real == 0) && (imag > 0))
 80295ca:	eddf 7a54 	vldr	s15, [pc, #336]	; 802971c <compute_angle+0x38c>
 80295ce:	e732      	b.n	8029436 <compute_angle+0xa6>
	/* Phase angle (0 to 2Pi) */
	if((real > 0) && (imag >= 0))		// 1st quadrant
	{
		phi = atan((double)imag / (double)real);
	}
	else if((real < 0) && (imag >= 0))	// 2nd quadrant
 80295d0:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80295d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80295d8:	db42      	blt.n	8029660 <compute_angle+0x2d0>
	{
		phi = atan((double)imag / (double)real) + PI;
 80295da:	ee17 0a90 	vmov	r0, s15
 80295de:	f004 fc3f 	bl	802de60 <__aeabi_f2d>
 80295e2:	4606      	mov	r6, r0
 80295e4:	ee18 0a10 	vmov	r0, s16
 80295e8:	460f      	mov	r7, r1
 80295ea:	f004 fc39 	bl	802de60 <__aeabi_f2d>
 80295ee:	4602      	mov	r2, r0
 80295f0:	460b      	mov	r3, r1
 80295f2:	4630      	mov	r0, r6
 80295f4:	4639      	mov	r1, r7
 80295f6:	f004 fdb1 	bl	802e15c <__aeabi_ddiv>
 80295fa:	f003 fa65 	bl	802cac8 <atan>
 80295fe:	a33e      	add	r3, pc, #248	; (adr r3, 80296f8 <compute_angle+0x368>)
 8029600:	e9d3 2300 	ldrd	r2, r3, [r3]
 8029604:	f004 face 	bl	802dba4 <__adddf3>
 8029608:	f004 ff60 	bl	802e4cc <__aeabi_d2f>
 802960c:	ee08 0a10 	vmov	s16, r0
 8029610:	e6ef      	b.n	80293f2 <compute_angle+0x62>
	/* Phase angle (0 to 2Pi) */
	if((real > 0) && (imag >= 0))		// 1st quadrant
	{
		phi = atan((double)imag / (double)real);
	}
	else if((real < 0) && (imag >= 0))	// 2nd quadrant
 8029612:	eef5 9ac0 	vcmpe.f32	s19, #0.0
 8029616:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802961a:	db1b      	blt.n	8029654 <compute_angle+0x2c4>
	{
		phi = atan((double)imag / (double)real) + PI;
 802961c:	ee19 0a90 	vmov	r0, s19
 8029620:	f004 fc1e 	bl	802de60 <__aeabi_f2d>
 8029624:	4606      	mov	r6, r0
 8029626:	ee19 0a10 	vmov	r0, s18
 802962a:	460f      	mov	r7, r1
 802962c:	f004 fc18 	bl	802de60 <__aeabi_f2d>
 8029630:	4602      	mov	r2, r0
 8029632:	460b      	mov	r3, r1
 8029634:	4630      	mov	r0, r6
 8029636:	4639      	mov	r1, r7
 8029638:	f004 fd90 	bl	802e15c <__aeabi_ddiv>
 802963c:	f003 fa44 	bl	802cac8 <atan>
 8029640:	a32d      	add	r3, pc, #180	; (adr r3, 80296f8 <compute_angle+0x368>)
 8029642:	e9d3 2300 	ldrd	r2, r3, [r3]
 8029646:	f004 faad 	bl	802dba4 <__adddf3>
 802964a:	f004 ff3f 	bl	802e4cc <__aeabi_d2f>
 802964e:	ee07 0a90 	vmov	s15, r0
 8029652:	e6f0      	b.n	8029436 <compute_angle+0xa6>
	}
	else if((real < 0) && (imag <= 0)) 	// 3rd quadrant
 8029654:	eef5 9ac0 	vcmpe.f32	s19, #0.0
 8029658:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802965c:	d897      	bhi.n	802958e <compute_angle+0x1fe>
 802965e:	e7dd      	b.n	802961c <compute_angle+0x28c>
 8029660:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8029664:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8029668:	f63f af6e 	bhi.w	8029548 <compute_angle+0x1b8>
 802966c:	e7b5      	b.n	80295da <compute_angle+0x24a>
	{
		phi = atan((double)imag / (double)real) + PI;
	}
	else if((real > 0) && (imag <= 0)) 	// 4th quadrant
	{
		phi = atan((double)imag / (double)real) + 2*PI;
 802966e:	ee19 0a90 	vmov	r0, s19
 8029672:	f004 fbf5 	bl	802de60 <__aeabi_f2d>
 8029676:	4606      	mov	r6, r0
 8029678:	ee19 0a10 	vmov	r0, s18
 802967c:	460f      	mov	r7, r1
 802967e:	f004 fbef 	bl	802de60 <__aeabi_f2d>
 8029682:	4602      	mov	r2, r0
 8029684:	460b      	mov	r3, r1
 8029686:	4630      	mov	r0, r6
 8029688:	4639      	mov	r1, r7
 802968a:	f004 fd67 	bl	802e15c <__aeabi_ddiv>
 802968e:	f003 fa1b 	bl	802cac8 <atan>
 8029692:	a31b      	add	r3, pc, #108	; (adr r3, 8029700 <compute_angle+0x370>)
 8029694:	e9d3 2300 	ldrd	r2, r3, [r3]
 8029698:	f004 fa84 	bl	802dba4 <__adddf3>
 802969c:	f004 ff16 	bl	802e4cc <__aeabi_d2f>
 80296a0:	ee07 0a90 	vmov	s15, r0
 80296a4:	e6c7      	b.n	8029436 <compute_angle+0xa6>
 80296a6:	ee17 0a90 	vmov	r0, s15
 80296aa:	f004 fbd9 	bl	802de60 <__aeabi_f2d>
 80296ae:	4606      	mov	r6, r0
 80296b0:	ee18 0a10 	vmov	r0, s16
 80296b4:	460f      	mov	r7, r1
 80296b6:	f004 fbd3 	bl	802de60 <__aeabi_f2d>
 80296ba:	4602      	mov	r2, r0
 80296bc:	460b      	mov	r3, r1
 80296be:	4630      	mov	r0, r6
 80296c0:	4639      	mov	r1, r7
 80296c2:	f004 fd4b 	bl	802e15c <__aeabi_ddiv>
 80296c6:	f003 f9ff 	bl	802cac8 <atan>
 80296ca:	a30d      	add	r3, pc, #52	; (adr r3, 8029700 <compute_angle+0x370>)
 80296cc:	e9d3 2300 	ldrd	r2, r3, [r3]
 80296d0:	f004 fa68 	bl	802dba4 <__adddf3>
 80296d4:	f004 fefa 	bl	802e4cc <__aeabi_d2f>
 80296d8:	ee08 0a10 	vmov	s16, r0
 80296dc:	e689      	b.n	80293f2 <compute_angle+0x62>
	}
	else if((real == 0) && (imag > 0))
	{
		phi = PI/2;
	}
	else if((real == 0) && (imag < 0))
 80296de:	ed9f 8a10 	vldr	s16, [pc, #64]	; 8029720 <compute_angle+0x390>
 80296e2:	e686      	b.n	80293f2 <compute_angle+0x62>
 80296e4:	eddf 7a0e 	vldr	s15, [pc, #56]	; 8029720 <compute_angle+0x390>
 80296e8:	e6a5      	b.n	8029436 <compute_angle+0xa6>
 80296ea:	bf00      	nop
 80296ec:	f3af 8000 	nop.w
 80296f0:	70000000 	.word	0x70000000
 80296f4:	40069e95 	.word	0x40069e95
 80296f8:	60000000 	.word	0x60000000
 80296fc:	400921fb 	.word	0x400921fb
 8029700:	60000000 	.word	0x60000000
 8029704:	401921fb 	.word	0x401921fb
 8029708:	40490fdb 	.word	0x40490fdb
 802970c:	40c90fdb 	.word	0x40c90fdb
 8029710:	43340000 	.word	0x43340000
 8029714:	3fe00000 	.word	0x3fe00000
 8029718:	3fc90fdb 	.word	0x3fc90fdb
 802971c:	00000000 	.word	0x00000000
 8029720:	4096cbe4 	.word	0x4096cbe4
 8029724:	f3af 8000 	nop.w

08029728 <bgt_init>:
   3. EXPORTED FUNCTIONS
==============================================================================
 */

void bgt_init(uint32_t lna_gain, uint32_t power_level)
{
 8029728:	b538      	push	{r3, r4, r5, lr}
  /* Set the digital IOs used by SPI interface */
  bgt24mtr1x_spi_pins.spi_device    = BGT_DEVICE;
 802972a:	4b08      	ldr	r3, [pc, #32]	; (802974c <bgt_init+0x24>)
  bgt24mtr1x_spi_pins.gpio_cs_pin   = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_BGT24;
 802972c:	4d08      	ldr	r5, [pc, #32]	; (8029750 <bgt_init+0x28>)
 802972e:	605d      	str	r5, [r3, #4]
  bgt24mtr1x_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_DATA;
 8029730:	4c08      	ldr	r4, [pc, #32]	; (8029754 <bgt_init+0x2c>)
  bgt24mtr1x_spi_pins.gpio_clk_pin  = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;
 8029732:	4a09      	ldr	r2, [pc, #36]	; (8029758 <bgt_init+0x30>)
void bgt_init(uint32_t lna_gain, uint32_t power_level)
{
  /* Set the digital IOs used by SPI interface */
  bgt24mtr1x_spi_pins.spi_device    = BGT_DEVICE;
  bgt24mtr1x_spi_pins.gpio_cs_pin   = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_BGT24;
  bgt24mtr1x_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_DATA;
 8029734:	609c      	str	r4, [r3, #8]
 */

void bgt_init(uint32_t lna_gain, uint32_t power_level)
{
  /* Set the digital IOs used by SPI interface */
  bgt24mtr1x_spi_pins.spi_device    = BGT_DEVICE;
 8029736:	2500      	movs	r5, #0
  bgt24mtr1x_spi_pins.gpio_cs_pin   = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_BGT24;
  bgt24mtr1x_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_DATA;
  bgt24mtr1x_spi_pins.gpio_clk_pin  = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;
  
  bgt24mtr1x_init((Bgt24mtr1x_LNAgain_t)lna_gain, (Bgt24mtr1x_Power_t)power_level);
 8029738:	b2c0      	uxtb	r0, r0
 802973a:	b2c9      	uxtb	r1, r1
 */

void bgt_init(uint32_t lna_gain, uint32_t power_level)
{
  /* Set the digital IOs used by SPI interface */
  bgt24mtr1x_spi_pins.spi_device    = BGT_DEVICE;
 802973c:	701d      	strb	r5, [r3, #0]
  bgt24mtr1x_spi_pins.gpio_cs_pin   = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_BGT24;
  bgt24mtr1x_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_DATA;
  bgt24mtr1x_spi_pins.gpio_clk_pin  = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;
 802973e:	60da      	str	r2, [r3, #12]
  
  bgt24mtr1x_init((Bgt24mtr1x_LNAgain_t)lna_gain, (Bgt24mtr1x_Power_t)power_level);
 8029740:	f001 fc90 	bl	802b064 <bgt24mtr1x_init>
  
  bgt24mtr1x_ana_vref_tx();
}
 8029744:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  bgt24mtr1x_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_DATA;
  bgt24mtr1x_spi_pins.gpio_clk_pin  = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;
  
  bgt24mtr1x_init((Bgt24mtr1x_LNAgain_t)lna_gain, (Bgt24mtr1x_Power_t)power_level);
  
  bgt24mtr1x_ana_vref_tx();
 8029748:	f001 bdd2 	b.w	802b2f0 <bgt24mtr1x_ana_vref_tx>
 802974c:	1fff2a94 	.word	0x1fff2a94
 8029750:	08030d34 	.word	0x08030d34
 8029754:	08030d70 	.word	0x08030d70
 8029758:	08030ca8 	.word	0x08030ca8

0802975c <bgt_start_tx>:

//============================================================================

void bgt_start_tx(void)
{
  bgt24mtr1x_start_tx();
 802975c:	f001 bcfc 	b.w	802b158 <bgt24mtr1x_start_tx>

08029760 <bgt_stop_tx>:

//============================================================================

void bgt_stop_tx(void)
{
  bgt24mtr1x_stop_tx();
 8029760:	f001 bd16 	b.w	802b190 <bgt24mtr1x_stop_tx>

08029764 <bgt_power_up>:
}

//============================================================================

void bgt_power_up(void)
{
 8029764:	b430      	push	{r4, r5}
 8029766:	4a07      	ldr	r2, [pc, #28]	; (8029784 <bgt_power_up+0x20>)
 8029768:	4b07      	ldr	r3, [pc, #28]	; (8029788 <bgt_power_up+0x24>)

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 802976a:	7c15      	ldrb	r5, [r2, #16]

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 802976c:	7c1c      	ldrb	r4, [r3, #16]
 802976e:	6810      	ldr	r0, [r2, #0]
 8029770:	6819      	ldr	r1, [r3, #0]

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 8029772:	2201      	movs	r2, #1

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 8029774:	f44f 3380 	mov.w	r3, #65536	; 0x10000

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 8029778:	40aa      	lsls	r2, r5

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 802977a:	40a3      	lsls	r3, r4

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 802977c:	6042      	str	r2, [r0, #4]
  /* Before turning on BGT, we should keep CE pin high.
   * CE pin is active low, so it should keep high until it is activated.
   */
  DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_SPI_M_CS_BGT24);
  DIGITAL_IO_SetOutputLow(&DIGITAL_IO_BGT_POWER_ENABLE);
}
 802977e:	bc30      	pop	{r4, r5}

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 8029780:	604b      	str	r3, [r1, #4]
 8029782:	4770      	bx	lr
 8029784:	08030d34 	.word	0x08030d34
 8029788:	08030d84 	.word	0x08030d84

0802978c <bgt_power_down>:

//============================================================================

void bgt_power_down(void)
{
 802978c:	b4f0      	push	{r4, r5, r6, r7}
 802978e:	490a      	ldr	r1, [pc, #40]	; (80297b8 <bgt_power_down+0x2c>)
 8029790:	4a0a      	ldr	r2, [pc, #40]	; (80297bc <bgt_power_down+0x30>)
 8029792:	4b0b      	ldr	r3, [pc, #44]	; (80297c0 <bgt_power_down+0x34>)

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 8029794:	7c0f      	ldrb	r7, [r1, #16]

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 8029796:	7c1e      	ldrb	r6, [r3, #16]
 8029798:	7c14      	ldrb	r4, [r2, #16]
 802979a:	680d      	ldr	r5, [r1, #0]
 802979c:	6810      	ldr	r0, [r2, #0]
 802979e:	6819      	ldr	r1, [r3, #0]

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 80297a0:	2201      	movs	r2, #1

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 80297a2:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80297a6:	fa03 f404 	lsl.w	r4, r3, r4

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 80297aa:	40ba      	lsls	r2, r7

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 80297ac:	40b3      	lsls	r3, r6

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 80297ae:	606a      	str	r2, [r5, #4]

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 80297b0:	6044      	str	r4, [r0, #4]
 80297b2:	604b      	str	r3, [r1, #4]
   * It makes offset voltage at BGT's VCC.
   */
  DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_BGT_POWER_ENABLE);
  DIGITAL_IO_SetOutputLow(&DIGITAL_IO_SPI_M_CS_BGT24);
  DIGITAL_IO_SetOutputLow(&DIGITAL_IO_SPI_M_DATA);
}
 80297b4:	bcf0      	pop	{r4, r5, r6, r7}
 80297b6:	4770      	bx	lr
 80297b8:	08030d84 	.word	0x08030d84
 80297bc:	08030d34 	.word	0x08030d34
 80297c0:	08030d70 	.word	0x08030d70

080297c4 <bgt_set_tx_power>:

//============================================================================

void bgt_set_tx_power(uint8_t power_level)
{
  bgt24mtr1x_set_tx_power((Bgt24mtr1x_Power_t)power_level);
 80297c4:	f001 bd00 	b.w	802b1c8 <bgt24mtr1x_set_tx_power>

080297c8 <bgt_lna_gain_enable>:

//============================================================================

void bgt_lna_gain_enable(void)
{
  bgt24mtr1x_lna_gain_enable();
 80297c8:	f001 bd48 	b.w	802b25c <bgt24mtr1x_lna_gain_enable>

080297cc <bgt_lna_gain_disable>:

//============================================================================

void bgt_lna_gain_disable(void)
{
  bgt24mtr1x_lna_gain_disable();
 80297cc:	f001 bd4e 	b.w	802b26c <bgt24mtr1x_lna_gain_disable>

080297d0 <bgt_ana_temp>:

//============================================================================

void bgt_ana_temp(void)
{
  bgt24mtr1x_ana_temp();
 80297d0:	f001 bd6a 	b.w	802b2a8 <bgt24mtr1x_ana_temp>

080297d4 <bgt_ana_vout_tx>:

//============================================================================

void bgt_ana_vout_tx(void)
{
  bgt24mtr1x_ana_vout_tx();
 80297d4:	f001 bd7c 	b.w	802b2d0 <bgt24mtr1x_ana_vout_tx>

080297d8 <bgt_ana_vref_tx>:

//============================================================================

void bgt_ana_vref_tx(void)
{
  bgt24mtr1x_ana_vref_tx();
 80297d8:	f001 bd8a 	b.w	802b2f0 <bgt24mtr1x_ana_vref_tx>

080297dc <bgt_get_ana_config>:

//============================================================================

uint16_t bgt_get_ana_config(void)
{
  return bgt24mtr1x_get_ana_config();
 80297dc:	f001 bd9c 	b.w	802b318 <bgt24mtr1x_get_ana_config>

080297e0 <bgt_lowest_power_with_q2_disable>:

//============================================================================

void bgt_lowest_power_with_q2_disable(void)
{
  bgt24mtr1x_set_config((uint16_t)BGT24MTR1X_POWER_CONF);
 80297e0:	f241 0047 	movw	r0, #4167	; 0x1047
 80297e4:	f001 bd4e 	b.w	802b284 <bgt24mtr1x_set_config>

080297e8 <bgt_ldo_enable>:
}

//============================================================================

void bgt_ldo_enable(void)
{
 80297e8:	4b03      	ldr	r3, [pc, #12]	; (80297f8 <bgt_ldo_enable+0x10>)

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 80297ea:	7c19      	ldrb	r1, [r3, #16]
 80297ec:	681a      	ldr	r2, [r3, #0]
 80297ee:	2301      	movs	r3, #1
 80297f0:	408b      	lsls	r3, r1
 80297f2:	6053      	str	r3, [r2, #4]
 80297f4:	4770      	bx	lr
 80297f6:	bf00      	nop
 80297f8:	08030c6c 	.word	0x08030c6c

080297fc <bsp_init>:
   4. EXPORTED FUNCTIONS
==============================================================================
 */

uint8_t bsp_init(void)
{
 80297fc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  pDMA_src_Q1 = (uint32_t*)&ADC_MEASUREMENT_ADV_G1_IF1_I_RES;
  pDMA_src_I2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G4_IF2_Q_RES;
  pDMA_src_Q2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G3_IF2_I_RES;
  
  /* Set the source address pointers for each DMA transfer */
  XMC_DMA_CH_SetSourceAddress(DMA_CH_I1.dma_global->dma, DMA_CH_I1.ch_num, (uint32_t)pDMA_src_I1);
 8029800:	4fa3      	ldr	r7, [pc, #652]	; (8029a90 <bsp_init+0x294>)
//============================================================================

void bsp_dma_set_source_addr(void)
{
  /* DMA Source/Destination Address setup */
  pDMA_src_I1 = (uint32_t*)&ADC_MEASUREMENT_ADV_G2_IF1_Q_RES;
 8029802:	4ba4      	ldr	r3, [pc, #656]	; (8029a94 <bsp_init+0x298>)
  pDMA_src_Q1 = (uint32_t*)&ADC_MEASUREMENT_ADV_G1_IF1_I_RES;
  pDMA_src_I2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G4_IF2_Q_RES;
  pDMA_src_Q2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G3_IF2_I_RES;
  
  /* Set the source address pointers for each DMA transfer */
  XMC_DMA_CH_SetSourceAddress(DMA_CH_I1.dma_global->dma, DMA_CH_I1.ch_num, (uint32_t)pDMA_src_I1);
 8029804:	6839      	ldr	r1, [r7, #0]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetDestinationAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetSourceAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].SAR = addr;
 8029806:	7b3a      	ldrb	r2, [r7, #12]
 8029808:	6808      	ldr	r0, [r1, #0]
//============================================================================

void bsp_dma_set_source_addr(void)
{
  /* DMA Source/Destination Address setup */
  pDMA_src_I1 = (uint32_t*)&ADC_MEASUREMENT_ADV_G2_IF1_Q_RES;
 802980a:	49a3      	ldr	r1, [pc, #652]	; (8029a98 <bsp_init+0x29c>)
 802980c:	6019      	str	r1, [r3, #0]
 802980e:	2358      	movs	r3, #88	; 0x58
 8029810:	fb03 f202 	mul.w	r2, r3, r2
  pDMA_src_Q1 = (uint32_t*)&ADC_MEASUREMENT_ADV_G1_IF1_I_RES;
 8029814:	4ea1      	ldr	r6, [pc, #644]	; (8029a9c <bsp_init+0x2a0>)
  pDMA_src_I2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G4_IF2_Q_RES;
 8029816:	4da2      	ldr	r5, [pc, #648]	; (8029aa0 <bsp_init+0x2a4>)
  pDMA_src_Q2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G3_IF2_I_RES;
 8029818:	4ca2      	ldr	r4, [pc, #648]	; (8029aa4 <bsp_init+0x2a8>)
void bsp_dma_set_source_addr(void)
{
  /* DMA Source/Destination Address setup */
  pDMA_src_I1 = (uint32_t*)&ADC_MEASUREMENT_ADV_G2_IF1_Q_RES;
  pDMA_src_Q1 = (uint32_t*)&ADC_MEASUREMENT_ADV_G1_IF1_I_RES;
  pDMA_src_I2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G4_IF2_Q_RES;
 802981a:	f8df c2a8 	ldr.w	ip, [pc, #680]	; 8029ac4 <bsp_init+0x2c8>
  pDMA_src_Q2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G3_IF2_I_RES;
 802981e:	f8df e2a8 	ldr.w	lr, [pc, #680]	; 8029ac8 <bsp_init+0x2cc>

void bsp_dma_set_source_addr(void)
{
  /* DMA Source/Destination Address setup */
  pDMA_src_I1 = (uint32_t*)&ADC_MEASUREMENT_ADV_G2_IF1_Q_RES;
  pDMA_src_Q1 = (uint32_t*)&ADC_MEASUREMENT_ADV_G1_IF1_I_RES;
 8029822:	f8df 82a8 	ldr.w	r8, [pc, #680]	; 8029acc <bsp_init+0x2d0>
  pDMA_src_I2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G4_IF2_Q_RES;
 8029826:	f8c5 c000 	str.w	ip, [r5]
  pDMA_src_Q2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G3_IF2_I_RES;
 802982a:	f8c4 e000 	str.w	lr, [r4]

void bsp_dma_set_source_addr(void)
{
  /* DMA Source/Destination Address setup */
  pDMA_src_I1 = (uint32_t*)&ADC_MEASUREMENT_ADV_G2_IF1_Q_RES;
  pDMA_src_Q1 = (uint32_t*)&ADC_MEASUREMENT_ADV_G1_IF1_I_RES;
 802982e:	f8c6 8000 	str.w	r8, [r6]
 8029832:	5081      	str	r1, [r0, r2]
  pDMA_src_I2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G4_IF2_Q_RES;
  pDMA_src_Q2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G3_IF2_I_RES;
  
  /* Set the source address pointers for each DMA transfer */
  XMC_DMA_CH_SetSourceAddress(DMA_CH_I1.dma_global->dma, DMA_CH_I1.ch_num, (uint32_t)pDMA_src_I1);
  XMC_DMA_CH_SetSourceAddress(DMA_CH_Q1.dma_global->dma, DMA_CH_Q1.ch_num, (uint32_t)pDMA_src_Q1);
 8029834:	4e9c      	ldr	r6, [pc, #624]	; (8029aa8 <bsp_init+0x2ac>)
  XMC_DMA_CH_SetSourceAddress(DMA_CH_I2.dma_global->dma, DMA_CH_I2.ch_num, (uint32_t)pDMA_src_I2);
 8029836:	4d9d      	ldr	r5, [pc, #628]	; (8029aac <bsp_init+0x2b0>)
  pDMA_src_I2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G4_IF2_Q_RES;
  pDMA_src_Q2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G3_IF2_I_RES;
  
  /* Set the source address pointers for each DMA transfer */
  XMC_DMA_CH_SetSourceAddress(DMA_CH_I1.dma_global->dma, DMA_CH_I1.ch_num, (uint32_t)pDMA_src_I1);
  XMC_DMA_CH_SetSourceAddress(DMA_CH_Q1.dma_global->dma, DMA_CH_Q1.ch_num, (uint32_t)pDMA_src_Q1);
 8029838:	6831      	ldr	r1, [r6, #0]
 802983a:	7b32      	ldrb	r2, [r6, #12]
  XMC_DMA_CH_SetSourceAddress(DMA_CH_I2.dma_global->dma, DMA_CH_I2.ch_num, (uint32_t)pDMA_src_I2);
  XMC_DMA_CH_SetSourceAddress(DMA_CH_Q2.dma_global->dma, DMA_CH_Q2.ch_num, (uint32_t)pDMA_src_Q2);
 802983c:	4c9c      	ldr	r4, [pc, #624]	; (8029ab0 <bsp_init+0x2b4>)
  pDMA_src_I2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G4_IF2_Q_RES;
  pDMA_src_Q2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G3_IF2_I_RES;
  
  /* Set the source address pointers for each DMA transfer */
  XMC_DMA_CH_SetSourceAddress(DMA_CH_I1.dma_global->dma, DMA_CH_I1.ch_num, (uint32_t)pDMA_src_I1);
  XMC_DMA_CH_SetSourceAddress(DMA_CH_Q1.dma_global->dma, DMA_CH_Q1.ch_num, (uint32_t)pDMA_src_Q1);
 802983e:	f8d1 9000 	ldr.w	r9, [r1]
  XMC_DMA_CH_SetSourceAddress(DMA_CH_I2.dma_global->dma, DMA_CH_I2.ch_num, (uint32_t)pDMA_src_I2);
 8029842:	6828      	ldr	r0, [r5, #0]
  XMC_DMA_CH_SetSourceAddress(DMA_CH_Q2.dma_global->dma, DMA_CH_Q2.ch_num, (uint32_t)pDMA_src_Q2);
 8029844:	6821      	ldr	r1, [r4, #0]
  pDMA_src_Q2 = (uint32_t*)&ADC_MEASUREMENT_ADV_G3_IF2_I_RES;
  
  /* Set the source address pointers for each DMA transfer */
  XMC_DMA_CH_SetSourceAddress(DMA_CH_I1.dma_global->dma, DMA_CH_I1.ch_num, (uint32_t)pDMA_src_I1);
  XMC_DMA_CH_SetSourceAddress(DMA_CH_Q1.dma_global->dma, DMA_CH_Q1.ch_num, (uint32_t)pDMA_src_Q1);
  XMC_DMA_CH_SetSourceAddress(DMA_CH_I2.dma_global->dma, DMA_CH_I2.ch_num, (uint32_t)pDMA_src_I2);
 8029846:	6800      	ldr	r0, [r0, #0]
  XMC_DMA_CH_SetSourceAddress(DMA_CH_Q2.dma_global->dma, DMA_CH_Q2.ch_num, (uint32_t)pDMA_src_Q2);
 8029848:	6809      	ldr	r1, [r1, #0]
uint8_t bsp_init(void)
{
  Pga_Status_t status;
  
  /* Set all data acquisition functions callback to NULL */
  bsp_cb.bsp_acq_started_cb = NULL;
 802984a:	f8df a284 	ldr.w	sl, [pc, #644]	; 8029ad0 <bsp_init+0x2d4>
 802984e:	fb03 f202 	mul.w	r2, r3, r2
 8029852:	f04f 0b00 	mov.w	fp, #0
 8029856:	f849 8002 	str.w	r8, [r9, r2]
 802985a:	7b2a      	ldrb	r2, [r5, #12]
 802985c:	f8ca b000 	str.w	fp, [sl]
 8029860:	fb03 f202 	mul.w	r2, r3, r2
  bsp_cb.bsp_acq_done_cb = NULL;
 8029864:	f8ca b004 	str.w	fp, [sl, #4]
 8029868:	f840 c002 	str.w	ip, [r0, r2]
 802986c:	7b22      	ldrb	r2, [r4, #12]
 802986e:	fb03 f302 	mul.w	r3, r3, r2
 8029872:	f841 e003 	str.w	lr, [r1, r3]
  
  /* Set memory sections to DMA source pointers */
  bsp_dma_set_source_addr();
  
  /* Enable LDO for BGT */
  bgt_ldo_enable();
 8029876:	f7ff ffb7 	bl	80297e8 <bgt_ldo_enable>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 802987a:	488e      	ldr	r0, [pc, #568]	; (8029ab4 <bsp_init+0x2b8>)
 802987c:	f7fd fa0e 	bl	8026c9c <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 8029880:	488c      	ldr	r0, [pc, #560]	; (8029ab4 <bsp_init+0x2b8>)
 8029882:	498d      	ldr	r1, [pc, #564]	; (8029ab8 <bsp_init+0x2bc>)
 8029884:	f7fd f948 	bl	8026b18 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8029888:	488a      	ldr	r0, [pc, #552]	; (8029ab4 <bsp_init+0x2b8>)
 802988a:	f7fd f8fb 	bl	8026a84 <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 802988e:	4889      	ldr	r0, [pc, #548]	; (8029ab4 <bsp_init+0x2b8>)
 8029890:	f7fd f9f2 	bl	8026c78 <TIMER_GetInterruptStatus>
 8029894:	2800      	cmp	r0, #0
 8029896:	d0fa      	beq.n	802988e <bsp_init+0x92>
  
  TIMER_Stop(&TIMER_DELAY);
 8029898:	4886      	ldr	r0, [pc, #536]	; (8029ab4 <bsp_init+0x2b8>)
 802989a:	f7fd f909 	bl	8026ab0 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 802989e:	4885      	ldr	r0, [pc, #532]	; (8029ab4 <bsp_init+0x2b8>)
 80298a0:	f7fd fa12 	bl	8026cc8 <TIMER_Clear>
  /* Enable LDO for BGT */
  bgt_ldo_enable();
  bsp_time_delay_usec(1000U);
  
  /* Enable LDO for PGA */
  pga_ldo_enable();
 80298a4:	f000 fcf2 	bl	802a28c <pga_ldo_enable>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 80298a8:	4882      	ldr	r0, [pc, #520]	; (8029ab4 <bsp_init+0x2b8>)
 80298aa:	f7fd f9f7 	bl	8026c9c <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 80298ae:	4881      	ldr	r0, [pc, #516]	; (8029ab4 <bsp_init+0x2b8>)
 80298b0:	4981      	ldr	r1, [pc, #516]	; (8029ab8 <bsp_init+0x2bc>)
 80298b2:	f7fd f931 	bl	8026b18 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 80298b6:	487f      	ldr	r0, [pc, #508]	; (8029ab4 <bsp_init+0x2b8>)
 80298b8:	f7fd f8e4 	bl	8026a84 <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 80298bc:	487d      	ldr	r0, [pc, #500]	; (8029ab4 <bsp_init+0x2b8>)
 80298be:	f7fd f9db 	bl	8026c78 <TIMER_GetInterruptStatus>
 80298c2:	2800      	cmp	r0, #0
 80298c4:	d0fa      	beq.n	80298bc <bsp_init+0xc0>
  
  TIMER_Stop(&TIMER_DELAY);
 80298c6:	487b      	ldr	r0, [pc, #492]	; (8029ab4 <bsp_init+0x2b8>)
 80298c8:	f7fd f8f2 	bl	8026ab0 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 80298cc:	4879      	ldr	r0, [pc, #484]	; (8029ab4 <bsp_init+0x2b8>)
 80298ce:	f7fd f9fb 	bl	8026cc8 <TIMER_Clear>
  /* Enable LDO for PGA */
  pga_ldo_enable();
  bsp_time_delay_usec(1000U);
  
  /* Power-up BGT */
  bgt_power_up();
 80298d2:	f7ff ff47 	bl	8029764 <bgt_power_up>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 80298d6:	4877      	ldr	r0, [pc, #476]	; (8029ab4 <bsp_init+0x2b8>)
 80298d8:	f7fd f9e0 	bl	8026c9c <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 80298dc:	4875      	ldr	r0, [pc, #468]	; (8029ab4 <bsp_init+0x2b8>)
 80298de:	f242 7110 	movw	r1, #10000	; 0x2710
 80298e2:	f7fd f919 	bl	8026b18 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 80298e6:	4873      	ldr	r0, [pc, #460]	; (8029ab4 <bsp_init+0x2b8>)
 80298e8:	f7fd f8cc 	bl	8026a84 <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 80298ec:	4871      	ldr	r0, [pc, #452]	; (8029ab4 <bsp_init+0x2b8>)
 80298ee:	f7fd f9c3 	bl	8026c78 <TIMER_GetInterruptStatus>
 80298f2:	2800      	cmp	r0, #0
 80298f4:	d0fa      	beq.n	80298ec <bsp_init+0xf0>
  
  TIMER_Stop(&TIMER_DELAY);
 80298f6:	486f      	ldr	r0, [pc, #444]	; (8029ab4 <bsp_init+0x2b8>)
 80298f8:	f7fd f8da 	bl	8026ab0 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 80298fc:	486d      	ldr	r0, [pc, #436]	; (8029ab4 <bsp_init+0x2b8>)
 80298fe:	f7fd f9e3 	bl	8026cc8 <TIMER_Clear>
  
  /* Power-up BGT */
  bgt_power_up();
  bsp_time_delay_usec(100U); /* Delay for BGT power-up */
  
  bgt_lowest_power_with_q2_disable(); /* To avoid out of band spurs */
 8029902:	f7ff ff6d 	bl	80297e0 <bgt_lowest_power_with_q2_disable>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 8029906:	486b      	ldr	r0, [pc, #428]	; (8029ab4 <bsp_init+0x2b8>)
 8029908:	f7fd f9c8 	bl	8026c9c <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 802990c:	4869      	ldr	r0, [pc, #420]	; (8029ab4 <bsp_init+0x2b8>)
 802990e:	f241 3188 	movw	r1, #5000	; 0x1388
 8029912:	f7fd f901 	bl	8026b18 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8029916:	4867      	ldr	r0, [pc, #412]	; (8029ab4 <bsp_init+0x2b8>)
 8029918:	f7fd f8b4 	bl	8026a84 <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 802991c:	4865      	ldr	r0, [pc, #404]	; (8029ab4 <bsp_init+0x2b8>)
 802991e:	f7fd f9ab 	bl	8026c78 <TIMER_GetInterruptStatus>
 8029922:	2800      	cmp	r0, #0
 8029924:	d0fa      	beq.n	802991c <bsp_init+0x120>
  
  TIMER_Stop(&TIMER_DELAY);
 8029926:	4863      	ldr	r0, [pc, #396]	; (8029ab4 <bsp_init+0x2b8>)
 8029928:	f7fd f8c2 	bl	8026ab0 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 802992c:	4861      	ldr	r0, [pc, #388]	; (8029ab4 <bsp_init+0x2b8>)
 802992e:	f7fd f9cb 	bl	8026cc8 <TIMER_Clear>
  
  bgt_lowest_power_with_q2_disable(); /* To avoid out of band spurs */
  bsp_time_delay_usec(50U); /* Delay for BGT Power down SPI settings */
  
  /* Enable PLL power supply */
  pll_power_up();
 8029932:	f000 fe19 	bl	802a568 <pll_power_up>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 8029936:	485f      	ldr	r0, [pc, #380]	; (8029ab4 <bsp_init+0x2b8>)
 8029938:	f7fd f9b0 	bl	8026c9c <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 802993c:	485d      	ldr	r0, [pc, #372]	; (8029ab4 <bsp_init+0x2b8>)
 802993e:	f242 7110 	movw	r1, #10000	; 0x2710
 8029942:	f7fd f8e9 	bl	8026b18 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8029946:	485b      	ldr	r0, [pc, #364]	; (8029ab4 <bsp_init+0x2b8>)
 8029948:	f7fd f89c 	bl	8026a84 <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 802994c:	4859      	ldr	r0, [pc, #356]	; (8029ab4 <bsp_init+0x2b8>)
 802994e:	f7fd f993 	bl	8026c78 <TIMER_GetInterruptStatus>
 8029952:	2800      	cmp	r0, #0
 8029954:	d0fa      	beq.n	802994c <bsp_init+0x150>
  
  TIMER_Stop(&TIMER_DELAY);
 8029956:	4857      	ldr	r0, [pc, #348]	; (8029ab4 <bsp_init+0x2b8>)
  
  /* Initialize BGT */
  bgt_init(LNA_GAIN_ENABLE, BGT_TX_POWER);
  
  /* Initialize PLL */
  pll_init(pll_handle);
 8029958:	f8df 8178 	ldr.w	r8, [pc, #376]	; 8029ad4 <bsp_init+0x2d8>
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
  
  TIMER_Stop(&TIMER_DELAY);
 802995c:	f7fd f8a8 	bl	8026ab0 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 8029960:	4854      	ldr	r0, [pc, #336]	; (8029ab4 <bsp_init+0x2b8>)
 8029962:	f7fd f9b1 	bl	8026cc8 <TIMER_Clear>
  /* Enable PLL power supply */
  pll_power_up();
  bsp_time_delay_usec(100U); /* Delay for PLL power-up */
  
  /* Initialize BGT */
  bgt_init(LNA_GAIN_ENABLE, BGT_TX_POWER);
 8029966:	2107      	movs	r1, #7
 8029968:	2001      	movs	r0, #1
 802996a:	f7ff fedd 	bl	8029728 <bgt_init>
  
  /* Initialize PLL */
  pll_init(pll_handle);
 802996e:	f8d8 0000 	ldr.w	r0, [r8]
 8029972:	f000 fca1 	bl	802a2b8 <pll_init>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 8029976:	484f      	ldr	r0, [pc, #316]	; (8029ab4 <bsp_init+0x2b8>)
 8029978:	f7fd f990 	bl	8026c9c <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 802997c:	484d      	ldr	r0, [pc, #308]	; (8029ab4 <bsp_init+0x2b8>)
 802997e:	f242 7110 	movw	r1, #10000	; 0x2710
 8029982:	f7fd f8c9 	bl	8026b18 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8029986:	484b      	ldr	r0, [pc, #300]	; (8029ab4 <bsp_init+0x2b8>)
 8029988:	f7fd f87c 	bl	8026a84 <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 802998c:	4849      	ldr	r0, [pc, #292]	; (8029ab4 <bsp_init+0x2b8>)
 802998e:	f7fd f973 	bl	8026c78 <TIMER_GetInterruptStatus>
 8029992:	2800      	cmp	r0, #0
 8029994:	d0fa      	beq.n	802998c <bsp_init+0x190>
  
  TIMER_Stop(&TIMER_DELAY);
 8029996:	4847      	ldr	r0, [pc, #284]	; (8029ab4 <bsp_init+0x2b8>)
 8029998:	f7fd f88a 	bl	8026ab0 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 802999c:	4845      	ldr	r0, [pc, #276]	; (8029ab4 <bsp_init+0x2b8>)
 802999e:	f7fd f993 	bl	8026cc8 <TIMER_Clear>
  /* Update PLL configuration */
#if (FW_MODULATION_TYPE == 0U) /* Doppler modulation */
  pll_update_configuration(pll_handle, DOPPLER_MODULATION);
  
#elif (FW_MODULATION_TYPE == 1U) /* FMCW modulation */
  pll_update_configuration(pll_handle, FMCW_MODULATION);
 80299a2:	2101      	movs	r1, #1
 80299a4:	f8d8 0000 	ldr.w	r0, [r8]
 80299a8:	f000 fde2 	bl	802a570 <pll_update_configuration>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 80299ac:	4841      	ldr	r0, [pc, #260]	; (8029ab4 <bsp_init+0x2b8>)
 80299ae:	f7fd f975 	bl	8026c9c <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 80299b2:	4840      	ldr	r0, [pc, #256]	; (8029ab4 <bsp_init+0x2b8>)
 80299b4:	f242 7110 	movw	r1, #10000	; 0x2710
 80299b8:	f7fd f8ae 	bl	8026b18 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 80299bc:	483d      	ldr	r0, [pc, #244]	; (8029ab4 <bsp_init+0x2b8>)
 80299be:	f7fd f861 	bl	8026a84 <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 80299c2:	483c      	ldr	r0, [pc, #240]	; (8029ab4 <bsp_init+0x2b8>)
 80299c4:	f7fd f958 	bl	8026c78 <TIMER_GetInterruptStatus>
 80299c8:	2800      	cmp	r0, #0
 80299ca:	d0fa      	beq.n	80299c2 <bsp_init+0x1c6>
  
  TIMER_Stop(&TIMER_DELAY);
 80299cc:	4839      	ldr	r0, [pc, #228]	; (8029ab4 <bsp_init+0x2b8>)
 80299ce:	f7fd f86f 	bl	8026ab0 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 80299d2:	4838      	ldr	r0, [pc, #224]	; (8029ab4 <bsp_init+0x2b8>)
 80299d4:	f7fd f978 	bl	8026cc8 <TIMER_Clear>
#endif
  
  bsp_time_delay_usec(100U);
  
  /* Initialize PGA and set its gain */
  status = pga_init(PGA_GAIN);
 80299d8:	2004      	movs	r0, #4
 80299da:	f000 fc53 	bl	802a284 <pga_init>
 80299de:	4681      	mov	r9, r0

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 80299e0:	4834      	ldr	r0, [pc, #208]	; (8029ab4 <bsp_init+0x2b8>)
 80299e2:	f7fd f95b 	bl	8026c9c <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 80299e6:	4833      	ldr	r0, [pc, #204]	; (8029ab4 <bsp_init+0x2b8>)
 80299e8:	f241 3188 	movw	r1, #5000	; 0x1388
 80299ec:	f7fd f894 	bl	8026b18 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 80299f0:	4830      	ldr	r0, [pc, #192]	; (8029ab4 <bsp_init+0x2b8>)
 80299f2:	f7fd f847 	bl	8026a84 <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 80299f6:	482f      	ldr	r0, [pc, #188]	; (8029ab4 <bsp_init+0x2b8>)
 80299f8:	f7fd f93e 	bl	8026c78 <TIMER_GetInterruptStatus>
 80299fc:	2800      	cmp	r0, #0
 80299fe:	d0fa      	beq.n	80299f6 <bsp_init+0x1fa>
  
  TIMER_Stop(&TIMER_DELAY);
 8029a00:	482c      	ldr	r0, [pc, #176]	; (8029ab4 <bsp_init+0x2b8>)
 8029a02:	f7fd f855 	bl	8026ab0 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 8029a06:	482b      	ldr	r0, [pc, #172]	; (8029ab4 <bsp_init+0x2b8>)
 8029a08:	f7fd f95e 	bl	8026cc8 <TIMER_Clear>
 */
__STATIC_INLINE void DMA_CH_Disable(DMA_CH_t *const obj)
{
  XMC_ASSERT("DMA_CH_Disable: NULL DMA_CH_t object", (obj != NULL));

  XMC_DMA_CH_Disable(obj->dma_global->dma, obj->ch_num);
 8029a0c:	683b      	ldr	r3, [r7, #0]
 8029a0e:	7b39      	ldrb	r1, [r7, #12]
 8029a10:	6818      	ldr	r0, [r3, #0]
 8029a12:	f7f8 fa89 	bl	8021f28 <XMC_DMA_CH_Disable>
 8029a16:	6833      	ldr	r3, [r6, #0]
 8029a18:	7b31      	ldrb	r1, [r6, #12]
 8029a1a:	6818      	ldr	r0, [r3, #0]
 8029a1c:	f7f8 fa84 	bl	8021f28 <XMC_DMA_CH_Disable>
 8029a20:	682b      	ldr	r3, [r5, #0]
 8029a22:	7b29      	ldrb	r1, [r5, #12]
 8029a24:	6818      	ldr	r0, [r3, #0]
 8029a26:	f7f8 fa7f 	bl	8021f28 <XMC_DMA_CH_Disable>
 8029a2a:	6823      	ldr	r3, [r4, #0]
 8029a2c:	7b21      	ldrb	r1, [r4, #12]
 8029a2e:	6818      	ldr	r0, [r3, #0]
 8029a30:	f7f8 fa7a 	bl	8021f28 <XMC_DMA_CH_Disable>
  
  /* Disable DMA */
  dma_disable();
  
  /* Check if duty cycle is enabled */
  if(bsp_duty_cycle_enable == ENABLED)
 8029a34:	4b21      	ldr	r3, [pc, #132]	; (8029abc <bsp_init+0x2c0>)
 8029a36:	781b      	ldrb	r3, [r3, #0]
 8029a38:	2b01      	cmp	r3, #1
 8029a3a:	d007      	beq.n	8029a4c <bsp_init+0x250>
  {
    bsp_components_power_down();
  }
  else	/* duty cycle disabled */
  {
    bgt_start_tx();
 8029a3c:	f7ff fe8e 	bl	802975c <bgt_start_tx>

//============================================================================

void bsp_reset_frame_counter(void)
{
  bsp_frame_counter = 0;
 8029a40:	4b1f      	ldr	r3, [pc, #124]	; (8029ac0 <bsp_init+0x2c4>)
 8029a42:	2200      	movs	r2, #0
  
  /* Reset the current frame counter */
  bsp_reset_frame_counter();
  
  return (status);
}
 8029a44:	4648      	mov	r0, r9

//============================================================================

void bsp_reset_frame_counter(void)
{
  bsp_frame_counter = 0;
 8029a46:	801a      	strh	r2, [r3, #0]
  
  /* Reset the current frame counter */
  bsp_reset_frame_counter();
  
  return (status);
}
 8029a48:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

//============================================================================

void bsp_components_power_down(void)
{
  pll_disable_ramps(pll_handle);
 8029a4c:	f8d8 0000 	ldr.w	r0, [r8]
 8029a50:	f000 fd82 	bl	802a558 <pll_disable_ramps>
  
  /* To avoid out of band spurs */
  bgt_lowest_power_with_q2_disable();
 8029a54:	f7ff fec4 	bl	80297e0 <bgt_lowest_power_with_q2_disable>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 8029a58:	4816      	ldr	r0, [pc, #88]	; (8029ab4 <bsp_init+0x2b8>)
 8029a5a:	f7fd f91f 	bl	8026c9c <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 8029a5e:	4815      	ldr	r0, [pc, #84]	; (8029ab4 <bsp_init+0x2b8>)
 8029a60:	f241 3188 	movw	r1, #5000	; 0x1388
 8029a64:	f7fd f858 	bl	8026b18 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8029a68:	4812      	ldr	r0, [pc, #72]	; (8029ab4 <bsp_init+0x2b8>)
 8029a6a:	f7fd f80b 	bl	8026a84 <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 8029a6e:	4811      	ldr	r0, [pc, #68]	; (8029ab4 <bsp_init+0x2b8>)
 8029a70:	f7fd f902 	bl	8026c78 <TIMER_GetInterruptStatus>
 8029a74:	2800      	cmp	r0, #0
 8029a76:	d0fa      	beq.n	8029a6e <bsp_init+0x272>
  
  TIMER_Stop(&TIMER_DELAY);
 8029a78:	480e      	ldr	r0, [pc, #56]	; (8029ab4 <bsp_init+0x2b8>)
 8029a7a:	f7fd f819 	bl	8026ab0 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 8029a7e:	480d      	ldr	r0, [pc, #52]	; (8029ab4 <bsp_init+0x2b8>)
 8029a80:	f7fd f922 	bl	8026cc8 <TIMER_Clear>
  /* To avoid out of band spurs */
  bgt_lowest_power_with_q2_disable();
  bsp_time_delay_usec(50U);           /* Delay for BGT Power down SPI settings */
  
  /* Power-down BGT */
  bgt_power_down();
 8029a84:	f7ff fe82 	bl	802978c <bgt_power_down>
  
  /* Disable PLL */
  pll_power_down();
 8029a88:	f000 fd70 	bl	802a56c <pll_power_down>
 8029a8c:	e7d8      	b.n	8029a40 <bsp_init+0x244>
 8029a8e:	bf00      	nop
 8029a90:	1ffe8ae0 	.word	0x1ffe8ae0
 8029a94:	1fff2aa4 	.word	0x1fff2aa4
 8029a98:	40004b0c 	.word	0x40004b0c
 8029a9c:	1fff2ac0 	.word	0x1fff2ac0
 8029aa0:	1fff2aa8 	.word	0x1fff2aa8
 8029aa4:	1fff2ac4 	.word	0x1fff2ac4
 8029aa8:	1ffe8a68 	.word	0x1ffe8a68
 8029aac:	1ffe8b48 	.word	0x1ffe8b48
 8029ab0:	1ffe8a78 	.word	0x1ffe8a78
 8029ab4:	1ffe88f8 	.word	0x1ffe88f8
 8029ab8:	000186a0 	.word	0x000186a0
 8029abc:	1ffe9000 	.word	0x1ffe9000
 8029ac0:	1fff2ab8 	.word	0x1fff2ab8
 8029ac4:	40005310 	.word	0x40005310
 8029ac8:	40004f00 	.word	0x40004f00
 8029acc:	4000473c 	.word	0x4000473c
 8029ad0:	1fff2ae4 	.word	0x1fff2ae4
 8029ad4:	1ffe9004 	.word	0x1ffe9004

08029ad8 <bsp_components_power_up>:
}

//============================================================================

void bsp_components_power_up(void)
{
 8029ad8:	b508      	push	{r3, lr}
  /* Power-up BGT */
  bgt_power_up();
 8029ada:	f7ff fe43 	bl	8029764 <bgt_power_up>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 8029ade:	4852      	ldr	r0, [pc, #328]	; (8029c28 <bsp_components_power_up+0x150>)
 8029ae0:	f7fd f8dc 	bl	8026c9c <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 8029ae4:	4850      	ldr	r0, [pc, #320]	; (8029c28 <bsp_components_power_up+0x150>)
 8029ae6:	f242 7110 	movw	r1, #10000	; 0x2710
 8029aea:	f7fd f815 	bl	8026b18 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8029aee:	484e      	ldr	r0, [pc, #312]	; (8029c28 <bsp_components_power_up+0x150>)
 8029af0:	f7fc ffc8 	bl	8026a84 <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 8029af4:	484c      	ldr	r0, [pc, #304]	; (8029c28 <bsp_components_power_up+0x150>)
 8029af6:	f7fd f8bf 	bl	8026c78 <TIMER_GetInterruptStatus>
 8029afa:	2800      	cmp	r0, #0
 8029afc:	d0fa      	beq.n	8029af4 <bsp_components_power_up+0x1c>
  
  TIMER_Stop(&TIMER_DELAY);
 8029afe:	484a      	ldr	r0, [pc, #296]	; (8029c28 <bsp_components_power_up+0x150>)
 8029b00:	f7fc ffd6 	bl	8026ab0 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 8029b04:	4848      	ldr	r0, [pc, #288]	; (8029c28 <bsp_components_power_up+0x150>)
 8029b06:	f7fd f8df 	bl	8026cc8 <TIMER_Clear>
  bgt_power_up();
  
  /* Delay for BGT power-up */
  bsp_time_delay_usec(100U);
  
  bgt_lowest_power_with_q2_disable();
 8029b0a:	f7ff fe69 	bl	80297e0 <bgt_lowest_power_with_q2_disable>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 8029b0e:	4846      	ldr	r0, [pc, #280]	; (8029c28 <bsp_components_power_up+0x150>)
 8029b10:	f7fd f8c4 	bl	8026c9c <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 8029b14:	4844      	ldr	r0, [pc, #272]	; (8029c28 <bsp_components_power_up+0x150>)
 8029b16:	f649 4140 	movw	r1, #40000	; 0x9c40
 8029b1a:	f7fc fffd 	bl	8026b18 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8029b1e:	4842      	ldr	r0, [pc, #264]	; (8029c28 <bsp_components_power_up+0x150>)
 8029b20:	f7fc ffb0 	bl	8026a84 <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 8029b24:	4840      	ldr	r0, [pc, #256]	; (8029c28 <bsp_components_power_up+0x150>)
 8029b26:	f7fd f8a7 	bl	8026c78 <TIMER_GetInterruptStatus>
 8029b2a:	2800      	cmp	r0, #0
 8029b2c:	d0fa      	beq.n	8029b24 <bsp_components_power_up+0x4c>
  
  TIMER_Stop(&TIMER_DELAY);
 8029b2e:	483e      	ldr	r0, [pc, #248]	; (8029c28 <bsp_components_power_up+0x150>)
 8029b30:	f7fc ffbe 	bl	8026ab0 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 8029b34:	483c      	ldr	r0, [pc, #240]	; (8029c28 <bsp_components_power_up+0x150>)
 8029b36:	f7fd f8c7 	bl	8026cc8 <TIMER_Clear>
  
  bgt_lowest_power_with_q2_disable();
  bsp_time_delay_usec(400U); /* 400us based on PLL pre-charging slope, dependent on board loop filter */
  
  /* Enable PLL */
  pll_power_up();
 8029b3a:	f000 fd15 	bl	802a568 <pll_power_up>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 8029b3e:	483a      	ldr	r0, [pc, #232]	; (8029c28 <bsp_components_power_up+0x150>)
 8029b40:	f7fd f8ac 	bl	8026c9c <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 8029b44:	4838      	ldr	r0, [pc, #224]	; (8029c28 <bsp_components_power_up+0x150>)
 8029b46:	f242 7110 	movw	r1, #10000	; 0x2710
 8029b4a:	f7fc ffe5 	bl	8026b18 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8029b4e:	4836      	ldr	r0, [pc, #216]	; (8029c28 <bsp_components_power_up+0x150>)
 8029b50:	f7fc ff98 	bl	8026a84 <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 8029b54:	4834      	ldr	r0, [pc, #208]	; (8029c28 <bsp_components_power_up+0x150>)
 8029b56:	f7fd f88f 	bl	8026c78 <TIMER_GetInterruptStatus>
 8029b5a:	2800      	cmp	r0, #0
 8029b5c:	d0fa      	beq.n	8029b54 <bsp_components_power_up+0x7c>
  
  TIMER_Stop(&TIMER_DELAY);
 8029b5e:	4832      	ldr	r0, [pc, #200]	; (8029c28 <bsp_components_power_up+0x150>)
 8029b60:	f7fc ffa6 	bl	8026ab0 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 8029b64:	4830      	ldr	r0, [pc, #192]	; (8029c28 <bsp_components_power_up+0x150>)
 8029b66:	f7fd f8af 	bl	8026cc8 <TIMER_Clear>
  
  /* Delay for PLL power-up.
   * This delay depends upon the Charge pump voltage for locking time (linked with first BGT power-up delay) */
  bsp_time_delay_usec(100U);

  if (pll_get_update_config_flag() == ENABLED)
 8029b6a:	f000 fd2f 	bl	802a5cc <pll_get_update_config_flag>
 8029b6e:	2801      	cmp	r0, #1
  {
#if (FW_MODULATION_TYPE == 0U) /* Doppler modulation */
    pll_update_configuration(pll_handle, DOPPLER_MODULATION);
    
#elif (FW_MODULATION_TYPE == 1U) /* FMCW modulation */
    pll_update_configuration(pll_handle, FMCW_MODULATION);
 8029b70:	4b2e      	ldr	r3, [pc, #184]	; (8029c2c <bsp_components_power_up+0x154>)
  
  /* Delay for PLL power-up.
   * This delay depends upon the Charge pump voltage for locking time (linked with first BGT power-up delay) */
  bsp_time_delay_usec(100U);

  if (pll_get_update_config_flag() == ENABLED)
 8029b72:	d054      	beq.n	8029c1e <bsp_components_power_up+0x146>
  }
  
#if (FW_MODULATION_TYPE == 1U) /* FMCW modulation */
  else
  {
    pll_enable_ramps(pll_handle); /* Enable PLL's ramps */
 8029b74:	6818      	ldr	r0, [r3, #0]
 8029b76:	f000 fceb 	bl	802a550 <pll_enable_ramps>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 8029b7a:	482b      	ldr	r0, [pc, #172]	; (8029c28 <bsp_components_power_up+0x150>)
 8029b7c:	f7fd f88e 	bl	8026c9c <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 8029b80:	4829      	ldr	r0, [pc, #164]	; (8029c28 <bsp_components_power_up+0x150>)
 8029b82:	f24c 3150 	movw	r1, #50000	; 0xc350
 8029b86:	f7fc ffc7 	bl	8026b18 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8029b8a:	4827      	ldr	r0, [pc, #156]	; (8029c28 <bsp_components_power_up+0x150>)
 8029b8c:	f7fc ff7a 	bl	8026a84 <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 8029b90:	4825      	ldr	r0, [pc, #148]	; (8029c28 <bsp_components_power_up+0x150>)
 8029b92:	f7fd f871 	bl	8026c78 <TIMER_GetInterruptStatus>
 8029b96:	2800      	cmp	r0, #0
 8029b98:	d0fa      	beq.n	8029b90 <bsp_components_power_up+0xb8>
  
  TIMER_Stop(&TIMER_DELAY);
 8029b9a:	4823      	ldr	r0, [pc, #140]	; (8029c28 <bsp_components_power_up+0x150>)
 8029b9c:	f7fc ff88 	bl	8026ab0 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 8029ba0:	4821      	ldr	r0, [pc, #132]	; (8029c28 <bsp_components_power_up+0x150>)
 8029ba2:	f7fd f891 	bl	8026cc8 <TIMER_Clear>
#endif
  
  bsp_time_delay_usec(500U);

  /* Set the new PGA gain level */
  if(ds_device_get_settings()->isGainlevelUpdated)
 8029ba6:	f7f6 fac5 	bl	8020134 <ds_device_get_settings>
 8029baa:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8029bac:	b143      	cbz	r3, 8029bc0 <bsp_components_power_up+0xe8>
  {
    pga_set_gain(ds_device_get_settings()->pga_rx_gain_level);
 8029bae:	f7f6 fac1 	bl	8020134 <ds_device_get_settings>
 8029bb2:	8c40      	ldrh	r0, [r0, #34]	; 0x22
 8029bb4:	f000 fb68 	bl	802a288 <pga_set_gain>
    ds_device_get_settings()->isGainlevelUpdated = 0;
 8029bb8:	f7f6 fabc 	bl	8020134 <ds_device_get_settings>
 8029bbc:	2300      	movs	r3, #0
 8029bbe:	6343      	str	r3, [r0, #52]	; 0x34

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 8029bc0:	4819      	ldr	r0, [pc, #100]	; (8029c28 <bsp_components_power_up+0x150>)
 8029bc2:	f7fd f86b 	bl	8026c9c <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 8029bc6:	4818      	ldr	r0, [pc, #96]	; (8029c28 <bsp_components_power_up+0x150>)
 8029bc8:	f241 3188 	movw	r1, #5000	; 0x1388
 8029bcc:	f7fc ffa4 	bl	8026b18 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8029bd0:	4815      	ldr	r0, [pc, #84]	; (8029c28 <bsp_components_power_up+0x150>)
 8029bd2:	f7fc ff57 	bl	8026a84 <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 8029bd6:	4814      	ldr	r0, [pc, #80]	; (8029c28 <bsp_components_power_up+0x150>)
 8029bd8:	f7fd f84e 	bl	8026c78 <TIMER_GetInterruptStatus>
 8029bdc:	2800      	cmp	r0, #0
 8029bde:	d0fa      	beq.n	8029bd6 <bsp_components_power_up+0xfe>
  
  TIMER_Stop(&TIMER_DELAY);
 8029be0:	4811      	ldr	r0, [pc, #68]	; (8029c28 <bsp_components_power_up+0x150>)
 8029be2:	f7fc ff65 	bl	8026ab0 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 8029be6:	4810      	ldr	r0, [pc, #64]	; (8029c28 <bsp_components_power_up+0x150>)
 8029be8:	f7fd f86e 	bl	8026cc8 <TIMER_Clear>
  }

  bsp_time_delay_usec(PLL_LOCK_TIME_USEC); /* Delay for PLL Lock */
  
  /* Enable BGT TX Power amplifier */
  bgt_start_tx();
 8029bec:	f7ff fdb6 	bl	802975c <bgt_start_tx>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 8029bf0:	480d      	ldr	r0, [pc, #52]	; (8029c28 <bsp_components_power_up+0x150>)
 8029bf2:	f7fd f853 	bl	8026c9c <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 8029bf6:	480c      	ldr	r0, [pc, #48]	; (8029c28 <bsp_components_power_up+0x150>)
 8029bf8:	490d      	ldr	r1, [pc, #52]	; (8029c30 <bsp_components_power_up+0x158>)
 8029bfa:	f7fc ff8d 	bl	8026b18 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8029bfe:	480a      	ldr	r0, [pc, #40]	; (8029c28 <bsp_components_power_up+0x150>)
 8029c00:	f7fc ff40 	bl	8026a84 <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 8029c04:	4808      	ldr	r0, [pc, #32]	; (8029c28 <bsp_components_power_up+0x150>)
 8029c06:	f7fd f837 	bl	8026c78 <TIMER_GetInterruptStatus>
 8029c0a:	2800      	cmp	r0, #0
 8029c0c:	d0fa      	beq.n	8029c04 <bsp_components_power_up+0x12c>
  
  TIMER_Stop(&TIMER_DELAY);
 8029c0e:	4806      	ldr	r0, [pc, #24]	; (8029c28 <bsp_components_power_up+0x150>)
 8029c10:	f7fc ff4e 	bl	8026ab0 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 8029c14:	4804      	ldr	r0, [pc, #16]	; (8029c28 <bsp_components_power_up+0x150>)
  /* Enable BGT TX Power amplifier */
  bgt_start_tx();
  
  /* Delay for BGT Q2 divider to be zero and VCO to be settled after SPI setting transmitted */
  bsp_time_delay_usec(BGT_VCO_LOCK_TIME_USEC); /* 1ms delay for IQ voltage at ADC close to reference 1.65V */
}
 8029c16:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
  
  TIMER_Stop(&TIMER_DELAY);
  
  TIMER_Clear(&TIMER_DELAY);
 8029c1a:	f7fd b855 	b.w	8026cc8 <TIMER_Clear>
  {
#if (FW_MODULATION_TYPE == 0U) /* Doppler modulation */
    pll_update_configuration(pll_handle, DOPPLER_MODULATION);
    
#elif (FW_MODULATION_TYPE == 1U) /* FMCW modulation */
    pll_update_configuration(pll_handle, FMCW_MODULATION);
 8029c1e:	4601      	mov	r1, r0
 8029c20:	6818      	ldr	r0, [r3, #0]
 8029c22:	f000 fca5 	bl	802a570 <pll_update_configuration>
 8029c26:	e7a8      	b.n	8029b7a <bsp_components_power_up+0xa2>
 8029c28:	1ffe88f8 	.word	0x1ffe88f8
 8029c2c:	1ffe9004 	.word	0x1ffe9004
 8029c30:	000186a0 	.word	0x000186a0

08029c34 <bsp_components_power_down>:
}

//============================================================================

void bsp_components_power_down(void)
{
 8029c34:	b508      	push	{r3, lr}
  pll_disable_ramps(pll_handle);
 8029c36:	4b11      	ldr	r3, [pc, #68]	; (8029c7c <bsp_components_power_down+0x48>)
 8029c38:	6818      	ldr	r0, [r3, #0]
 8029c3a:	f000 fc8d 	bl	802a558 <pll_disable_ramps>
  
  /* To avoid out of band spurs */
  bgt_lowest_power_with_q2_disable();
 8029c3e:	f7ff fdcf 	bl	80297e0 <bgt_lowest_power_with_q2_disable>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 8029c42:	480f      	ldr	r0, [pc, #60]	; (8029c80 <bsp_components_power_down+0x4c>)
 8029c44:	f7fd f82a 	bl	8026c9c <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 8029c48:	480d      	ldr	r0, [pc, #52]	; (8029c80 <bsp_components_power_down+0x4c>)
 8029c4a:	f241 3188 	movw	r1, #5000	; 0x1388
 8029c4e:	f7fc ff63 	bl	8026b18 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8029c52:	480b      	ldr	r0, [pc, #44]	; (8029c80 <bsp_components_power_down+0x4c>)
 8029c54:	f7fc ff16 	bl	8026a84 <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 8029c58:	4809      	ldr	r0, [pc, #36]	; (8029c80 <bsp_components_power_down+0x4c>)
 8029c5a:	f7fd f80d 	bl	8026c78 <TIMER_GetInterruptStatus>
 8029c5e:	2800      	cmp	r0, #0
 8029c60:	d0fa      	beq.n	8029c58 <bsp_components_power_down+0x24>
  
  TIMER_Stop(&TIMER_DELAY);
 8029c62:	4807      	ldr	r0, [pc, #28]	; (8029c80 <bsp_components_power_down+0x4c>)
 8029c64:	f7fc ff24 	bl	8026ab0 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 8029c68:	4805      	ldr	r0, [pc, #20]	; (8029c80 <bsp_components_power_down+0x4c>)
 8029c6a:	f7fd f82d 	bl	8026cc8 <TIMER_Clear>
  /* To avoid out of band spurs */
  bgt_lowest_power_with_q2_disable();
  bsp_time_delay_usec(50U);           /* Delay for BGT Power down SPI settings */
  
  /* Power-down BGT */
  bgt_power_down();
 8029c6e:	f7ff fd8d 	bl	802978c <bgt_power_down>
  
  /* Disable PLL */
  pll_power_down();
}
 8029c72:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  
  /* Power-down BGT */
  bgt_power_down();
  
  /* Disable PLL */
  pll_power_down();
 8029c76:	f000 bc79 	b.w	802a56c <pll_power_down>
 8029c7a:	bf00      	nop
 8029c7c:	1ffe9004 	.word	0x1ffe9004
 8029c80:	1ffe88f8 	.word	0x1ffe88f8

08029c84 <bsp_flash_write_data>:

//============================================================================

void bsp_flash_write_data(const uint16_t offset_address, const uint8_t* data_ptr, uint16_t num_of_bytes)
{
  E_EEPROM_XMC4_WriteArray(offset_address, data_ptr, num_of_bytes);
 8029c84:	f7fd bbca 	b.w	802741c <E_EEPROM_XMC4_WriteArray>

08029c88 <bsp_flash_read_data>:

//============================================================================

void bsp_flash_read_data(const uint16_t offset_address, const uint8_t* data_ptr, uint16_t num_of_bytes)
{
  E_EEPROM_XMC4_ReadArray(offset_address, (uint8_t*)data_ptr, num_of_bytes);
 8029c88:	f7fd bc22 	b.w	80274d0 <E_EEPROM_XMC4_ReadArray>

08029c8c <bsp_flash_flush_data>:

//============================================================================

void bsp_flash_flush_data(void)
{
  E_EEPROM_XMC4_UpdateFlashContents();
 8029c8c:	f7fd bc6c 	b.w	8027568 <E_EEPROM_XMC4_UpdateFlashContents>

08029c90 <bsp_flash_is_empty>:

//============================================================================

bool bsp_flash_is_empty(void)
{
  return (E_EEPROM_XMC4_IsFlashEmpty());
 8029c90:	f7fd bd18 	b.w	80276c4 <E_EEPROM_XMC4_IsFlashEmpty>

08029c94 <bsp_timer_stop_clear>:
}

//============================================================================

TIMER_STATUS_t bsp_timer_stop_clear(TIMER_t* const handle_timer)
{
 8029c94:	b538      	push	{r3, r4, r5, lr}
 8029c96:	4605      	mov	r5, r0
  TIMER_STATUS_t  status;
  
  status = TIMER_Stop(handle_timer);
 8029c98:	f7fc ff0a 	bl	8026ab0 <TIMER_Stop>
 8029c9c:	4604      	mov	r4, r0
  
  status |= TIMER_Clear(handle_timer);
 8029c9e:	4628      	mov	r0, r5
 8029ca0:	f7fd f812 	bl	8026cc8 <TIMER_Clear>
 8029ca4:	4320      	orrs	r0, r4
  
  return (status);
}
 8029ca6:	b2c0      	uxtb	r0, r0
 8029ca8:	bd38      	pop	{r3, r4, r5, pc}
 8029caa:	bf00      	nop

08029cac <bsp_timer_start>:

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8029cac:	f7fc beea 	b.w	8026a84 <TIMER_Start>

08029cb0 <bsp_dma_set_destination_addr_from_acq_buf_obj>:
}

//============================================================================

void bsp_dma_set_destination_addr_from_acq_buf_obj(acq_buf_obj *acq_buf, uint32_t chirp_cnt)
{
 8029cb0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  pDMA_dst_I1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 0, chirp_cnt);
 8029cb4:	460a      	mov	r2, r1
}

//============================================================================

void bsp_dma_set_destination_addr_from_acq_buf_obj(acq_buf_obj *acq_buf, uint32_t chirp_cnt)
{
 8029cb6:	460c      	mov	r4, r1
  pDMA_dst_I1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 0, chirp_cnt);
 8029cb8:	2100      	movs	r1, #0
}

//============================================================================

void bsp_dma_set_destination_addr_from_acq_buf_obj(acq_buf_obj *acq_buf, uint32_t chirp_cnt)
{
 8029cba:	4605      	mov	r5, r0
  pDMA_dst_I1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 0, chirp_cnt);
 8029cbc:	f7f6 fc1a 	bl	80204f4 <get_buffer_address_by_chirp>
 8029cc0:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 8029d64 <bsp_dma_set_destination_addr_from_acq_buf_obj+0xb4>
  pDMA_dst_Q1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 1, chirp_cnt);
 8029cc4:	4f20      	ldr	r7, [pc, #128]	; (8029d48 <bsp_dma_set_destination_addr_from_acq_buf_obj+0x98>)

//============================================================================

void bsp_dma_set_destination_addr_from_acq_buf_obj(acq_buf_obj *acq_buf, uint32_t chirp_cnt)
{
  pDMA_dst_I1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 0, chirp_cnt);
 8029cc6:	f8c8 0000 	str.w	r0, [r8]
  pDMA_dst_Q1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 1, chirp_cnt);
 8029cca:	4622      	mov	r2, r4
 8029ccc:	4628      	mov	r0, r5
 8029cce:	2101      	movs	r1, #1
 8029cd0:	f7f6 fc10 	bl	80204f4 <get_buffer_address_by_chirp>
  pDMA_dst_I2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 2, chirp_cnt);
 8029cd4:	4622      	mov	r2, r4
//============================================================================

void bsp_dma_set_destination_addr_from_acq_buf_obj(acq_buf_obj *acq_buf, uint32_t chirp_cnt)
{
  pDMA_dst_I1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 0, chirp_cnt);
  pDMA_dst_Q1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 1, chirp_cnt);
 8029cd6:	6038      	str	r0, [r7, #0]
  pDMA_dst_I2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 2, chirp_cnt);
 8029cd8:	2102      	movs	r1, #2
 8029cda:	4628      	mov	r0, r5
 8029cdc:	f7f6 fc0a 	bl	80204f4 <get_buffer_address_by_chirp>
 8029ce0:	4e1a      	ldr	r6, [pc, #104]	; (8029d4c <bsp_dma_set_destination_addr_from_acq_buf_obj+0x9c>)
  pDMA_dst_Q2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 3, chirp_cnt);
 8029ce2:	4622      	mov	r2, r4

void bsp_dma_set_destination_addr_from_acq_buf_obj(acq_buf_obj *acq_buf, uint32_t chirp_cnt)
{
  pDMA_dst_I1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 0, chirp_cnt);
  pDMA_dst_Q1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 1, chirp_cnt);
  pDMA_dst_I2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 2, chirp_cnt);
 8029ce4:	6030      	str	r0, [r6, #0]
  pDMA_dst_Q2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 3, chirp_cnt);
 8029ce6:	2103      	movs	r1, #3
 8029ce8:	4628      	mov	r0, r5
 8029cea:	f7f6 fc03 	bl	80204f4 <get_buffer_address_by_chirp>
  
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_I1.dma_global->dma, DMA_CH_I1.ch_num, (uint32_t) pDMA_dst_I1);
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_Q1.dma_global->dma, DMA_CH_Q1.ch_num, (uint32_t) pDMA_dst_Q1);
 8029cee:	4d18      	ldr	r5, [pc, #96]	; (8029d50 <bsp_dma_set_destination_addr_from_acq_buf_obj+0xa0>)
  pDMA_dst_I1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 0, chirp_cnt);
  pDMA_dst_Q1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 1, chirp_cnt);
  pDMA_dst_I2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 2, chirp_cnt);
  pDMA_dst_Q2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 3, chirp_cnt);
  
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_I1.dma_global->dma, DMA_CH_I1.ch_num, (uint32_t) pDMA_dst_I1);
 8029cf0:	4b18      	ldr	r3, [pc, #96]	; (8029d54 <bsp_dma_set_destination_addr_from_acq_buf_obj+0xa4>)
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_Q1.dma_global->dma, DMA_CH_Q1.ch_num, (uint32_t) pDMA_dst_Q1);
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_I2.dma_global->dma, DMA_CH_I2.ch_num, (uint32_t) pDMA_dst_I2);
 8029cf2:	4c19      	ldr	r4, [pc, #100]	; (8029d58 <bsp_dma_set_destination_addr_from_acq_buf_obj+0xa8>)
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetSourceAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetDestinationAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].DAR = addr;
 8029cf4:	7b1a      	ldrb	r2, [r3, #12]
  pDMA_dst_I1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 0, chirp_cnt);
  pDMA_dst_Q1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 1, chirp_cnt);
  pDMA_dst_I2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 2, chirp_cnt);
  pDMA_dst_Q2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 3, chirp_cnt);
  
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_I1.dma_global->dma, DMA_CH_I1.ch_num, (uint32_t) pDMA_dst_I1);
 8029cf6:	6819      	ldr	r1, [r3, #0]
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_Q1.dma_global->dma, DMA_CH_Q1.ch_num, (uint32_t) pDMA_dst_Q1);
 8029cf8:	682b      	ldr	r3, [r5, #0]
  pDMA_dst_I1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 0, chirp_cnt);
  pDMA_dst_Q1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 1, chirp_cnt);
  pDMA_dst_I2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 2, chirp_cnt);
  pDMA_dst_Q2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 3, chirp_cnt);
  
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_I1.dma_global->dma, DMA_CH_I1.ch_num, (uint32_t) pDMA_dst_I1);
 8029cfa:	f8d1 c000 	ldr.w	ip, [r1]
 8029cfe:	f8d8 e000 	ldr.w	lr, [r8]
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_Q1.dma_global->dma, DMA_CH_Q1.ch_num, (uint32_t) pDMA_dst_Q1);
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_I2.dma_global->dma, DMA_CH_I2.ch_num, (uint32_t) pDMA_dst_I2);
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_Q2.dma_global->dma, DMA_CH_Q2.ch_num, (uint32_t) pDMA_dst_Q2);
 8029d02:	4916      	ldr	r1, [pc, #88]	; (8029d5c <bsp_dma_set_destination_addr_from_acq_buf_obj+0xac>)
  pDMA_dst_Q1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 1, chirp_cnt);
  pDMA_dst_I2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 2, chirp_cnt);
  pDMA_dst_Q2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 3, chirp_cnt);
  
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_I1.dma_global->dma, DMA_CH_I1.ch_num, (uint32_t) pDMA_dst_I1);
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_Q1.dma_global->dma, DMA_CH_Q1.ch_num, (uint32_t) pDMA_dst_Q1);
 8029d04:	f8d3 8000 	ldr.w	r8, [r3]
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_I2.dma_global->dma, DMA_CH_I2.ch_num, (uint32_t) pDMA_dst_I2);
 8029d08:	6823      	ldr	r3, [r4, #0]
 8029d0a:	f8d6 a000 	ldr.w	sl, [r6]
 8029d0e:	f8d3 9000 	ldr.w	r9, [r3]
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_Q2.dma_global->dma, DMA_CH_Q2.ch_num, (uint32_t) pDMA_dst_Q2);
 8029d12:	680e      	ldr	r6, [r1, #0]
void bsp_dma_set_destination_addr_from_acq_buf_obj(acq_buf_obj *acq_buf, uint32_t chirp_cnt)
{
  pDMA_dst_I1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 0, chirp_cnt);
  pDMA_dst_Q1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 1, chirp_cnt);
  pDMA_dst_I2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 2, chirp_cnt);
  pDMA_dst_Q2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 3, chirp_cnt);
 8029d14:	4b12      	ldr	r3, [pc, #72]	; (8029d60 <bsp_dma_set_destination_addr_from_acq_buf_obj+0xb0>)
  
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_I1.dma_global->dma, DMA_CH_I1.ch_num, (uint32_t) pDMA_dst_I1);
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_Q1.dma_global->dma, DMA_CH_Q1.ch_num, (uint32_t) pDMA_dst_Q1);
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_I2.dma_global->dma, DMA_CH_I2.ch_num, (uint32_t) pDMA_dst_I2);
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_Q2.dma_global->dma, DMA_CH_Q2.ch_num, (uint32_t) pDMA_dst_Q2);
 8029d16:	6836      	ldr	r6, [r6, #0]
void bsp_dma_set_destination_addr_from_acq_buf_obj(acq_buf_obj *acq_buf, uint32_t chirp_cnt)
{
  pDMA_dst_I1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 0, chirp_cnt);
  pDMA_dst_Q1 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 1, chirp_cnt);
  pDMA_dst_I2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 2, chirp_cnt);
  pDMA_dst_Q2 = (uint32_t*) get_buffer_address_by_chirp(acq_buf, 3, chirp_cnt);
 8029d18:	6018      	str	r0, [r3, #0]
 8029d1a:	2358      	movs	r3, #88	; 0x58
 8029d1c:	fb03 c202 	mla	r2, r3, r2, ip
  
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_I1.dma_global->dma, DMA_CH_I1.ch_num, (uint32_t) pDMA_dst_I1);
  XMC_DMA_CH_SetDestinationAddress(DMA_CH_Q1.dma_global->dma, DMA_CH_Q1.ch_num, (uint32_t) pDMA_dst_Q1);
 8029d20:	683f      	ldr	r7, [r7, #0]
 8029d22:	f8c2 e008 	str.w	lr, [r2, #8]
 8029d26:	7b2a      	ldrb	r2, [r5, #12]
 8029d28:	fb03 8802 	mla	r8, r3, r2, r8
 8029d2c:	f8c8 7008 	str.w	r7, [r8, #8]
 8029d30:	7b22      	ldrb	r2, [r4, #12]
 8029d32:	fb03 9902 	mla	r9, r3, r2, r9
 8029d36:	f8c9 a008 	str.w	sl, [r9, #8]
 8029d3a:	7b0a      	ldrb	r2, [r1, #12]
 8029d3c:	fb03 6302 	mla	r3, r3, r2, r6
 8029d40:	6098      	str	r0, [r3, #8]
 8029d42:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8029d46:	bf00      	nop
 8029d48:	1fff2ae0 	.word	0x1fff2ae0
 8029d4c:	1fff2ab4 	.word	0x1fff2ab4
 8029d50:	1ffe8a68 	.word	0x1ffe8a68
 8029d54:	1ffe8ae0 	.word	0x1ffe8ae0
 8029d58:	1ffe8b48 	.word	0x1ffe8b48
 8029d5c:	1ffe8a78 	.word	0x1ffe8a78
 8029d60:	1fff2adc 	.word	0x1fff2adc
 8029d64:	1fff2abc 	.word	0x1fff2abc

08029d68 <bsp_trigger_new_frame>:
}

//============================================================================

void bsp_trigger_new_frame(void)
{
 8029d68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  /* Stop ADC timer if ADC is still running */
  if (TIMER_GetTimerStatus(&TIMER_ADC_TRIG))
 8029d6c:	4866      	ldr	r0, [pc, #408]	; (8029f08 <bsp_trigger_new_frame+0x1a0>)
}

//============================================================================

void bsp_trigger_new_frame(void)
{
 8029d6e:	b083      	sub	sp, #12
  /* Stop ADC timer if ADC is still running */
  if (TIMER_GetTimerStatus(&TIMER_ADC_TRIG))
 8029d70:	f7fc fec0 	bl	8026af4 <TIMER_GetTimerStatus>
 8029d74:	2800      	cmp	r0, #0
 8029d76:	f040 80b5 	bne.w	8029ee4 <bsp_trigger_new_frame+0x17c>
 8029d7a:	4f64      	ldr	r7, [pc, #400]	; (8029f0c <bsp_trigger_new_frame+0x1a4>)
 8029d7c:	4e64      	ldr	r6, [pc, #400]	; (8029f10 <bsp_trigger_new_frame+0x1a8>)
 8029d7e:	683a      	ldr	r2, [r7, #0]
==============================================================================
 */

static void get_raw_data(void)
{
  watchdog_status = 0;
 8029d80:	4b64      	ldr	r3, [pc, #400]	; (8029f14 <bsp_trigger_new_frame+0x1ac>)
 8029d82:	6810      	ldr	r0, [r2, #0]
 8029d84:	7b39      	ldrb	r1, [r7, #12]
 8029d86:	4d64      	ldr	r5, [pc, #400]	; (8029f18 <bsp_trigger_new_frame+0x1b0>)
 8029d88:	4c64      	ldr	r4, [pc, #400]	; (8029f1c <bsp_trigger_new_frame+0x1b4>)
 8029d8a:	f04f 0800 	mov.w	r8, #0
 8029d8e:	f883 8000 	strb.w	r8, [r3]
 8029d92:	f7f8 f8c9 	bl	8021f28 <XMC_DMA_CH_Disable>
 8029d96:	6833      	ldr	r3, [r6, #0]
 8029d98:	7b31      	ldrb	r1, [r6, #12]
 8029d9a:	6818      	ldr	r0, [r3, #0]
 8029d9c:	f7f8 f8c4 	bl	8021f28 <XMC_DMA_CH_Disable>
 8029da0:	682b      	ldr	r3, [r5, #0]
 8029da2:	7b29      	ldrb	r1, [r5, #12]
 8029da4:	6818      	ldr	r0, [r3, #0]
 8029da6:	f7f8 f8bf 	bl	8021f28 <XMC_DMA_CH_Disable>
 8029daa:	6823      	ldr	r3, [r4, #0]
 8029dac:	7b21      	ldrb	r1, [r4, #12]
 8029dae:	6818      	ldr	r0, [r3, #0]
 8029db0:	f7f8 f8ba 	bl	8021f28 <XMC_DMA_CH_Disable>
 * }
 * @endcode<BR> </p>
 */
__STATIC_INLINE void DMA_CH_SetBlockSize(DMA_CH_t *const obj, uint32_t block_size)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, block_size);
 8029db4:	6823      	ldr	r3, [r4, #0]
  
  /* DMA Reconfiguration */
  dma_disable();
  dma_set_block_size(bsp_num_samples_per_dma_transfer);
 8029db6:	f8df c17c 	ldr.w	ip, [pc, #380]	; 8029f34 <bsp_trigger_new_frame+0x1cc>
 8029dba:	f8d3 b000 	ldr.w	fp, [r3]
 * see ::XMC_DMA_CH_Enable() for more information.
 *
 */
__STATIC_INLINE void XMC_DMA_CH_SetBlockSize(XMC_DMA_t *const dma, const uint8_t channel, uint32_t block_size)
{
  dma->CH[channel].CTLH = block_size;
 8029dbe:	7b23      	ldrb	r3, [r4, #12]
 8029dc0:	6838      	ldr	r0, [r7, #0]
 8029dc2:	9300      	str	r3, [sp, #0]
//============================================================================

static void dma_set_block_size(uint32_t block_size)
{
  /* The maximum block size defined by DMA is 4095 */
  block_size = (block_size > BSP_MAX_DMA_BLOCK_SIZE) ? BSP_MAX_DMA_BLOCK_SIZE : block_size;
 8029dc4:	f8dc 3000 	ldr.w	r3, [ip]
 8029dc8:	682a      	ldr	r2, [r5, #0]
 8029dca:	6831      	ldr	r1, [r6, #0]
 8029dcc:	9301      	str	r3, [sp, #4]
 8029dce:	9b00      	ldr	r3, [sp, #0]
 8029dd0:	6800      	ldr	r0, [r0, #0]
 8029dd2:	f897 e00c 	ldrb.w	lr, [r7, #12]
 8029dd6:	f8d2 a000 	ldr.w	sl, [r2]
 8029dda:	6809      	ldr	r1, [r1, #0]
 8029ddc:	f896 900c 	ldrb.w	r9, [r6, #12]
 8029de0:	7b2a      	ldrb	r2, [r5, #12]
 8029de2:	f04f 0c58 	mov.w	ip, #88	; 0x58
 8029de6:	fb0c bb03 	mla	fp, ip, r3, fp
 8029dea:	9b01      	ldr	r3, [sp, #4]
 8029dec:	fb0c 000e 	mla	r0, ip, lr, r0
 8029df0:	f640 7eff 	movw	lr, #4095	; 0xfff
 8029df4:	fb0c 1109 	mla	r1, ip, r9, r1
 8029df8:	4573      	cmp	r3, lr
 8029dfa:	fb0c a202 	mla	r2, ip, r2, sl
 8029dfe:	bf28      	it	cs
 8029e00:	4673      	movcs	r3, lr
 8029e02:	61c3      	str	r3, [r0, #28]
 8029e04:	61cb      	str	r3, [r1, #28]
 8029e06:	61d3      	str	r3, [r2, #28]
 8029e08:	f8cb 301c 	str.w	r3, [fp, #28]
  
  /* DMA Reconfiguration */
  dma_disable();
  dma_set_block_size(bsp_num_samples_per_dma_transfer);
  
  acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 8029e0c:	f7f6 f9fc 	bl	8020208 <ds_get_active_acq_buf>
  
  bsp_dma_set_destination_addr_from_acq_buf_obj(p_acq_buf, 0 );
 8029e10:	4641      	mov	r1, r8
 8029e12:	f7ff ff4d 	bl	8029cb0 <bsp_dma_set_destination_addr_from_acq_buf_obj>
 */
__STATIC_INLINE void DMA_CH_Enable(DMA_CH_t *const obj)
{
  XMC_ASSERT("DMA_CH_Enable: NULL DMA_CH_t object", (obj != NULL));

  XMC_DMA_CH_Enable(obj->dma_global->dma, obj->ch_num);
 8029e16:	6830      	ldr	r0, [r6, #0]
 8029e18:	6829      	ldr	r1, [r5, #0]
 8029e1a:	6822      	ldr	r2, [r4, #0]
  
  dma_enable();
  
  /* BGT and PLL Power-up */
  if(bsp_duty_cycle_enable == ENABLED)
 8029e1c:	4b40      	ldr	r3, [pc, #256]	; (8029f20 <bsp_trigger_new_frame+0x1b8>)
 8029e1e:	f8d7 9000 	ldr.w	r9, [r7]
 * ensure that the GPDMA module itself is enabled before calling this function.
 * See ::XMC_DMA_Enable() for details.
 */
__STATIC_INLINE void XMC_DMA_CH_Enable(XMC_DMA_t *const dma, const uint8_t channel)
{
  dma->CHENREG = (uint32_t)(0x101UL << channel);   
 8029e22:	f897 e00c 	ldrb.w	lr, [r7, #12]
 8029e26:	f895 800c 	ldrb.w	r8, [r5, #12]
 8029e2a:	f894 c00c 	ldrb.w	ip, [r4, #12]
 8029e2e:	6805      	ldr	r5, [r0, #0]
 8029e30:	7b36      	ldrb	r6, [r6, #12]
 8029e32:	6808      	ldr	r0, [r1, #0]
 8029e34:	6811      	ldr	r1, [r2, #0]
 8029e36:	781a      	ldrb	r2, [r3, #0]
 8029e38:	f8d9 7000 	ldr.w	r7, [r9]
 8029e3c:	f240 1301 	movw	r3, #257	; 0x101
 8029e40:	fa03 fe0e 	lsl.w	lr, r3, lr
 8029e44:	fa03 f606 	lsl.w	r6, r3, r6
 8029e48:	fa03 f408 	lsl.w	r4, r3, r8
 8029e4c:	2a01      	cmp	r2, #1
 8029e4e:	fa03 f30c 	lsl.w	r3, r3, ip
 8029e52:	f8c7 e3a0 	str.w	lr, [r7, #928]	; 0x3a0
 8029e56:	f8c5 63a0 	str.w	r6, [r5, #928]	; 0x3a0
 8029e5a:	f8c0 43a0 	str.w	r4, [r0, #928]	; 0x3a0
 8029e5e:	f8c1 33a0 	str.w	r3, [r1, #928]	; 0x3a0
 8029e62:	d04e      	beq.n	8029f02 <bsp_trigger_new_frame+0x19a>
  {
    bsp_components_power_up();
  }
  else
  {
    if (pll_get_update_config_flag() == ENABLED)
 8029e64:	f000 fbb2 	bl	802a5cc <pll_get_update_config_flag>
 8029e68:	2801      	cmp	r0, #1
    {
#if (FW_MODULATION_TYPE == 0U) /* Doppler modulation */
      pll_update_configuration(pll_handle, DOPPLER_MODULATION);
      
#elif (FW_MODULATION_TYPE == 1U) /* FMCW modulation */
      pll_update_configuration(pll_handle, FMCW_MODULATION);
 8029e6a:	4b2e      	ldr	r3, [pc, #184]	; (8029f24 <bsp_trigger_new_frame+0x1bc>)
  {
    bsp_components_power_up();
  }
  else
  {
    if (pll_get_update_config_flag() == ENABLED)
 8029e6c:	d041      	beq.n	8029ef2 <bsp_trigger_new_frame+0x18a>
    } /* Doppler modulation */
    
#if (FW_MODULATION_TYPE == 1U) /* FMCW modulation */
    else
    {
      pll_enable_ramps(pll_handle); /* Enable PLL's ramps */
 8029e6e:	6818      	ldr	r0, [r3, #0]
 8029e70:	f000 fb6e 	bl	802a550 <pll_enable_ramps>
    }
#endif /* FMCW modulation */
    
    bgt_start_tx();
 8029e74:	f7ff fc72 	bl	802975c <bgt_start_tx>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 8029e78:	482b      	ldr	r0, [pc, #172]	; (8029f28 <bsp_trigger_new_frame+0x1c0>)
 8029e7a:	f7fc ff0f 	bl	8026c9c <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 8029e7e:	482a      	ldr	r0, [pc, #168]	; (8029f28 <bsp_trigger_new_frame+0x1c0>)
 8029e80:	f241 3188 	movw	r1, #5000	; 0x1388
 8029e84:	f7fc fe48 	bl	8026b18 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8029e88:	4827      	ldr	r0, [pc, #156]	; (8029f28 <bsp_trigger_new_frame+0x1c0>)
 8029e8a:	f7fc fdfb 	bl	8026a84 <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 8029e8e:	4826      	ldr	r0, [pc, #152]	; (8029f28 <bsp_trigger_new_frame+0x1c0>)
 8029e90:	f7fc fef2 	bl	8026c78 <TIMER_GetInterruptStatus>
 8029e94:	2800      	cmp	r0, #0
 8029e96:	d0fa      	beq.n	8029e8e <bsp_trigger_new_frame+0x126>
  
  TIMER_Stop(&TIMER_DELAY);
 8029e98:	4823      	ldr	r0, [pc, #140]	; (8029f28 <bsp_trigger_new_frame+0x1c0>)
 8029e9a:	f7fc fe09 	bl	8026ab0 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 8029e9e:	4822      	ldr	r0, [pc, #136]	; (8029f28 <bsp_trigger_new_frame+0x1c0>)
 8029ea0:	f7fc ff12 	bl	8026cc8 <TIMER_Clear>
    bgt_start_tx();
    bsp_time_delay_usec(50);
  }
  
  /* Set WatchDog Timer Period */
  TIMER_SetTimeInterval(&TIMER_WATCHDOG, ds_device_get_settings()->pll_num_of_chirps_per_frame * (ds_device_get_settings()->pll_chirp_time_usec + PLL_RAMP_DOWM_TIME_USEC + PLL_STEADY_STATE_USEC) * 100U);
 8029ea4:	f7f6 f946 	bl	8020134 <ds_device_get_settings>
 8029ea8:	6944      	ldr	r4, [r0, #20]
 8029eaa:	f7f6 f943 	bl	8020134 <ds_device_get_settings>
 8029eae:	6801      	ldr	r1, [r0, #0]
 8029eb0:	481e      	ldr	r0, [pc, #120]	; (8029f2c <bsp_trigger_new_frame+0x1c4>)
 8029eb2:	2364      	movs	r3, #100	; 0x64
 8029eb4:	fb03 f301 	mul.w	r3, r3, r1
 8029eb8:	f503 419c 	add.w	r1, r3, #19968	; 0x4e00
 8029ebc:	3120      	adds	r1, #32
 8029ebe:	fb04 f101 	mul.w	r1, r4, r1
 8029ec2:	f7fc fe29 	bl	8026b18 <TIMER_SetTimeInterval>
  
  /* PLL Chirp Trigger */
#if (FW_MODULATION_TYPE == 1U) /* FMCW modulation */
  pll_trigger_ramp();
 8029ec6:	f000 fb4b 	bl	802a560 <pll_trigger_ramp>
  
#if (FW_MODULATION_TYPE == 0U) /* Doppler modulation */
  /* Start ADC Timer manually as no PLL output signals as no ramps */
  bsp_timer_start(&TIMER_ADC_TRIG);
#else
  pll_release_ramp_trigger();
 8029eca:	f000 fb4b 	bl	802a564 <pll_release_ramp_trigger>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 8029ece:	4817      	ldr	r0, [pc, #92]	; (8029f2c <bsp_trigger_new_frame+0x1c4>)
 8029ed0:	f7fc fdd8 	bl	8026a84 <TIMER_Start>
  
  /* Get the raw ADC data */
  get_raw_data();
  
  /* This callback is used to inform upper layers about the beginning of data acquisition process */
  if(bsp_cb.bsp_acq_started_cb != NULL)
 8029ed4:	4b16      	ldr	r3, [pc, #88]	; (8029f30 <bsp_trigger_new_frame+0x1c8>)
 8029ed6:	681b      	ldr	r3, [r3, #0]
 8029ed8:	b183      	cbz	r3, 8029efc <bsp_trigger_new_frame+0x194>
  {
    bsp_cb.bsp_acq_started_cb(NULL);
 8029eda:	2000      	movs	r0, #0
  }
}
 8029edc:	b003      	add	sp, #12
 8029ede:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  get_raw_data();
  
  /* This callback is used to inform upper layers about the beginning of data acquisition process */
  if(bsp_cb.bsp_acq_started_cb != NULL)
  {
    bsp_cb.bsp_acq_started_cb(NULL);
 8029ee2:	4718      	bx	r3

TIMER_STATUS_t bsp_timer_stop_clear(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Stop(handle_timer);
 8029ee4:	4808      	ldr	r0, [pc, #32]	; (8029f08 <bsp_trigger_new_frame+0x1a0>)
 8029ee6:	f7fc fde3 	bl	8026ab0 <TIMER_Stop>
  
  status |= TIMER_Clear(handle_timer);
 8029eea:	4807      	ldr	r0, [pc, #28]	; (8029f08 <bsp_trigger_new_frame+0x1a0>)
 8029eec:	f7fc feec 	bl	8026cc8 <TIMER_Clear>
 8029ef0:	e743      	b.n	8029d7a <bsp_trigger_new_frame+0x12>
    {
#if (FW_MODULATION_TYPE == 0U) /* Doppler modulation */
      pll_update_configuration(pll_handle, DOPPLER_MODULATION);
      
#elif (FW_MODULATION_TYPE == 1U) /* FMCW modulation */
      pll_update_configuration(pll_handle, FMCW_MODULATION);
 8029ef2:	4601      	mov	r1, r0
 8029ef4:	6818      	ldr	r0, [r3, #0]
 8029ef6:	f000 fb3b 	bl	802a570 <pll_update_configuration>
 8029efa:	e7bb      	b.n	8029e74 <bsp_trigger_new_frame+0x10c>
  /* This callback is used to inform upper layers about the beginning of data acquisition process */
  if(bsp_cb.bsp_acq_started_cb != NULL)
  {
    bsp_cb.bsp_acq_started_cb(NULL);
  }
}
 8029efc:	b003      	add	sp, #12
 8029efe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  dma_enable();
  
  /* BGT and PLL Power-up */
  if(bsp_duty_cycle_enable == ENABLED)
  {
    bsp_components_power_up();
 8029f02:	f7ff fde9 	bl	8029ad8 <bsp_components_power_up>
 8029f06:	e7cd      	b.n	8029ea4 <bsp_trigger_new_frame+0x13c>
 8029f08:	1ffe8fc4 	.word	0x1ffe8fc4
 8029f0c:	1ffe8ae0 	.word	0x1ffe8ae0
 8029f10:	1ffe8a68 	.word	0x1ffe8a68
 8029f14:	1fff2aac 	.word	0x1fff2aac
 8029f18:	1ffe8b48 	.word	0x1ffe8b48
 8029f1c:	1ffe8a78 	.word	0x1ffe8a78
 8029f20:	1ffe9000 	.word	0x1ffe9000
 8029f24:	1ffe9004 	.word	0x1ffe9004
 8029f28:	1ffe88f8 	.word	0x1ffe88f8
 8029f2c:	1ffe893c 	.word	0x1ffe893c
 8029f30:	1fff2ae4 	.word	0x1fff2ae4
 8029f34:	1fff2ac8 	.word	0x1fff2ac8

08029f38 <CCU43_0_IRQHandler>:

//============================================================================

void triggerFrameISR(void)
{
  bsp_trigger_new_frame();
 8029f38:	f7ff bf16 	b.w	8029d68 <bsp_trigger_new_frame>

08029f3c <DMA_Event_Handler>:

//============================================================================

void DMA_Event_Handler(XMC_DMA_CH_EVENT_t dma_event)
{
  if((dma_event & XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE) != 0)
 8029f3c:	0783      	lsls	r3, r0, #30
 8029f3e:	d400      	bmi.n	8029f42 <DMA_Event_Handler+0x6>
 8029f40:	4770      	bx	lr
}

//============================================================================

void DMA_Event_Handler(XMC_DMA_CH_EVENT_t dma_event)
{
 8029f42:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

TIMER_STATUS_t bsp_timer_stop_clear(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Stop(handle_timer);
 8029f46:	4879      	ldr	r0, [pc, #484]	; (802a12c <DMA_Event_Handler+0x1f0>)
 8029f48:	4f79      	ldr	r7, [pc, #484]	; (802a130 <DMA_Event_Handler+0x1f4>)
    * we don't need to care which interrupts are triggered by DMA.
    * this timer is source peripheral's trigger to request DMA transaction.
    * Even though DMA error interrupt, we'd better stop the this timer. */
    bsp_timer_stop_clear(&TIMER_ADC_TRIG);
    
    chirp_count++;
 8029f4a:	f8df 8240 	ldr.w	r8, [pc, #576]	; 802a18c <DMA_Event_Handler+0x250>
 8029f4e:	4e79      	ldr	r6, [pc, #484]	; (802a134 <DMA_Event_Handler+0x1f8>)
 8029f50:	4d79      	ldr	r5, [pc, #484]	; (802a138 <DMA_Event_Handler+0x1fc>)
 8029f52:	4c7a      	ldr	r4, [pc, #488]	; (802a13c <DMA_Event_Handler+0x200>)

TIMER_STATUS_t bsp_timer_stop_clear(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Stop(handle_timer);
 8029f54:	f7fc fdac 	bl	8026ab0 <TIMER_Stop>
  
  status |= TIMER_Clear(handle_timer);
 8029f58:	4874      	ldr	r0, [pc, #464]	; (802a12c <DMA_Event_Handler+0x1f0>)
 8029f5a:	f7fc feb5 	bl	8026cc8 <TIMER_Clear>
 */
__STATIC_INLINE void DMA_CH_Disable(DMA_CH_t *const obj)
{
  XMC_ASSERT("DMA_CH_Disable: NULL DMA_CH_t object", (obj != NULL));

  XMC_DMA_CH_Disable(obj->dma_global->dma, obj->ch_num);
 8029f5e:	683a      	ldr	r2, [r7, #0]
    * we don't need to care which interrupts are triggered by DMA.
    * this timer is source peripheral's trigger to request DMA transaction.
    * Even though DMA error interrupt, we'd better stop the this timer. */
    bsp_timer_stop_clear(&TIMER_ADC_TRIG);
    
    chirp_count++;
 8029f60:	f8d8 3000 	ldr.w	r3, [r8]
 8029f64:	6810      	ldr	r0, [r2, #0]
 8029f66:	7b39      	ldrb	r1, [r7, #12]
 8029f68:	3301      	adds	r3, #1
 8029f6a:	f8c8 3000 	str.w	r3, [r8]
 8029f6e:	f7f7 ffdb 	bl	8021f28 <XMC_DMA_CH_Disable>
 8029f72:	6833      	ldr	r3, [r6, #0]
 8029f74:	7b31      	ldrb	r1, [r6, #12]
 8029f76:	6818      	ldr	r0, [r3, #0]
 8029f78:	f7f7 ffd6 	bl	8021f28 <XMC_DMA_CH_Disable>
 8029f7c:	682b      	ldr	r3, [r5, #0]
 8029f7e:	7b29      	ldrb	r1, [r5, #12]
 8029f80:	6818      	ldr	r0, [r3, #0]
 8029f82:	f7f7 ffd1 	bl	8021f28 <XMC_DMA_CH_Disable>
 8029f86:	6823      	ldr	r3, [r4, #0]
 8029f88:	7b21      	ldrb	r1, [r4, #12]
 8029f8a:	6818      	ldr	r0, [r3, #0]
 8029f8c:	f7f7 ffcc 	bl	8021f28 <XMC_DMA_CH_Disable>

//============================================================================

static void dma_reset_dlr(void)
{
  XMC_DMA_CH_ClearSourcePeripheralRequest(DMA_CH_I1.dma_global->dma, DMA_CH_I1.ch_num);
 8029f90:	683b      	ldr	r3, [r7, #0]
 8029f92:	7b39      	ldrb	r1, [r7, #12]
 8029f94:	6818      	ldr	r0, [r3, #0]
 8029f96:	f7f8 f945 	bl	8022224 <XMC_DMA_CH_ClearSourcePeripheralRequest>
  XMC_DMA_CH_ClearSourcePeripheralRequest(DMA_CH_Q1.dma_global->dma, DMA_CH_Q1.ch_num);
 8029f9a:	6833      	ldr	r3, [r6, #0]
 8029f9c:	7b31      	ldrb	r1, [r6, #12]
 8029f9e:	6818      	ldr	r0, [r3, #0]
 8029fa0:	f7f8 f940 	bl	8022224 <XMC_DMA_CH_ClearSourcePeripheralRequest>
  XMC_DMA_CH_ClearSourcePeripheralRequest(DMA_CH_I2.dma_global->dma, DMA_CH_I2.ch_num);
 8029fa4:	682b      	ldr	r3, [r5, #0]
 8029fa6:	7b29      	ldrb	r1, [r5, #12]
 8029fa8:	6818      	ldr	r0, [r3, #0]
 8029faa:	f7f8 f93b 	bl	8022224 <XMC_DMA_CH_ClearSourcePeripheralRequest>
  XMC_DMA_CH_ClearSourcePeripheralRequest(DMA_CH_Q2.dma_global->dma, DMA_CH_Q2.ch_num);
 8029fae:	6823      	ldr	r3, [r4, #0]
 8029fb0:	7b21      	ldrb	r1, [r4, #12]
 8029fb2:	6818      	ldr	r0, [r3, #0]
 8029fb4:	f7f8 f936 	bl	8022224 <XMC_DMA_CH_ClearSourcePeripheralRequest>
    * We should consider the pending request from external peripheral. */
    dma_reset_dlr();
    
#if (FW_MODULATION_TYPE == 1U) /* FMCW modulation */
    
    acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 8029fb8:	f7f6 f926 	bl	8020208 <ds_get_active_acq_buf>
    
    if (chirp_count < p_acq_buf->params.num_of_chirps_per_frame)
 8029fbc:	f8d8 1000 	ldr.w	r1, [r8]
 8029fc0:	8883      	ldrh	r3, [r0, #4]
 8029fc2:	428b      	cmp	r3, r1
 8029fc4:	d867      	bhi.n	802a096 <DMA_Event_Handler+0x15a>
      dma_enable();
    }
    else
#endif
    {
      ADC_MEASUREMENT_ADV_SoftwareTrigger(&ADC_MEASUREMENT_SCAN);
 8029fc6:	485e      	ldr	r0, [pc, #376]	; (802a140 <DMA_Event_Handler+0x204>)
 8029fc8:	f7fe fd2a 	bl	8028a20 <ADC_MEASUREMENT_ADV_SoftwareTrigger>
      
      bsp_frame_counter++;
 8029fcc:	4a5d      	ldr	r2, [pc, #372]	; (802a144 <DMA_Event_Handler+0x208>)

static void done_sampling(void)
{
  uint16_t  lbgt_ana_command = 0;
  
  if(bsp_duty_cycle_enable == ENABLED)
 8029fce:	495e      	ldr	r1, [pc, #376]	; (802a148 <DMA_Event_Handler+0x20c>)
    else
#endif
    {
      ADC_MEASUREMENT_ADV_SoftwareTrigger(&ADC_MEASUREMENT_SCAN);
      
      bsp_frame_counter++;
 8029fd0:	8813      	ldrh	r3, [r2, #0]

static void done_sampling(void)
{
  uint16_t  lbgt_ana_command = 0;
  
  if(bsp_duty_cycle_enable == ENABLED)
 8029fd2:	7809      	ldrb	r1, [r1, #0]
    else
#endif
    {
      ADC_MEASUREMENT_ADV_SoftwareTrigger(&ADC_MEASUREMENT_SCAN);
      
      bsp_frame_counter++;
 8029fd4:	3301      	adds	r3, #1
 8029fd6:	b29b      	uxth	r3, r3
      
      chirp_count = 0;
 8029fd8:	2000      	movs	r0, #0

static void done_sampling(void)
{
  uint16_t  lbgt_ana_command = 0;
  
  if(bsp_duty_cycle_enable == ENABLED)
 8029fda:	2901      	cmp	r1, #1
    else
#endif
    {
      ADC_MEASUREMENT_ADV_SoftwareTrigger(&ADC_MEASUREMENT_SCAN);
      
      bsp_frame_counter++;
 8029fdc:	8013      	strh	r3, [r2, #0]
      
      chirp_count = 0;
 8029fde:	f8c8 0000 	str.w	r0, [r8]

static void done_sampling(void)
{
  uint16_t  lbgt_ana_command = 0;
  
  if(bsp_duty_cycle_enable == ENABLED)
 8029fe2:	f000 8081 	beq.w	802a0e8 <DMA_Event_Handler+0x1ac>
  {
    bsp_components_power_down();
  }
  
  lbgt_ana_command = bgt_get_ana_config();
 8029fe6:	f7ff fbf9 	bl	80297dc <bgt_get_ana_config>
 8029fea:	4b58      	ldr	r3, [pc, #352]	; (802a14c <DMA_Event_Handler+0x210>)
{
  uint16_t result;
  extern XMC_VADC_GROUP_t *const group_ptrs[XMC_VADC_MAXIMUM_NUM_GROUPS];
  XMC_ASSERT("ADC_MEASUREMENT_ADV_GetResult:Invalid handle_ptr", (handle_ptr != NULL))

  result = XMC_VADC_GROUP_GetResult(group_ptrs[handle_ptr->group_index],
 8029fec:	4a58      	ldr	r2, [pc, #352]	; (802a150 <DMA_Event_Handler+0x214>)
                                    (uint32_t) handle_ptr->ch_handle->result_reg_number);
 8029fee:	681c      	ldr	r4, [r3, #0]
{
  uint16_t result;
  extern XMC_VADC_GROUP_t *const group_ptrs[XMC_VADC_MAXIMUM_NUM_GROUPS];
  XMC_ASSERT("ADC_MEASUREMENT_ADV_GetResult:Invalid handle_ptr", (handle_ptr != NULL))

  result = XMC_VADC_GROUP_GetResult(group_ptrs[handle_ptr->group_index],
 8029ff0:	7a19      	ldrb	r1, [r3, #8]
                                    (uint32_t) handle_ptr->ch_handle->result_reg_number);
 8029ff2:	78a3      	ldrb	r3, [r4, #2]
{
  uint16_t result;
  extern XMC_VADC_GROUP_t *const group_ptrs[XMC_VADC_MAXIMUM_NUM_GROUPS];
  XMC_ASSERT("ADC_MEASUREMENT_ADV_GetResult:Invalid handle_ptr", (handle_ptr != NULL))

  result = XMC_VADC_GROUP_GetResult(group_ptrs[handle_ptr->group_index],
 8029ff4:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
  bsp_bgt_ana_out[lbgt_ana_command] = (ADC_MEASUREMENT_ADV_GetResult(&ADC_MEASUREMENT_SCAN_BGT24_ANA_handle));
 8029ff8:	4c56      	ldr	r4, [pc, #344]	; (802a154 <DMA_Event_Handler+0x218>)
 8029ffa:	f003 030f 	and.w	r3, r3, #15
                                                                const uint32_t res_reg)
{
  XMC_ASSERT("XMC_VADC_GROUP_GetResult:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_GetResult:Wrong Result Register", ((res_reg) < XMC_VADC_NUM_RESULT_REGISTERS))

  return ((XMC_VADC_RESULT_SIZE_t)group_ptr->RES[res_reg]);
 8029ffe:	33c0      	adds	r3, #192	; 0xc0
 802a000:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 802a004:	f824 3010 	strh.w	r3, [r4, r0, lsl #1]
  
  if (bsp_bgt_ana_out[2] == 0)
 802a008:	88a3      	ldrh	r3, [r4, #4]
 802a00a:	2b00      	cmp	r3, #0
 802a00c:	d03e      	beq.n	802a08c <DMA_Event_Handler+0x150>
  {
    bgt_ana_vref_tx();
  }
  else if (lbgt_ana_command == 2)
 802a00e:	2802      	cmp	r0, #2
 802a010:	d067      	beq.n	802a0e2 <DMA_Event_Handler+0x1a6>
  {
    bgt_ana_vout_tx();
  }
  else
  {
    bgt_ana_temp();
 802a012:	f7ff fbdd 	bl	80297d0 <bgt_ana_temp>
  }
  
  /* Calculate the BGT temperature and output power based on the BGT ANA MUX pin ADC sampled values */
  bsp_bgt_temperature_C = (0.2629f * (1000 * 3.3f * bsp_bgt_ana_out[0] / 4095.0f) - 364.32f);
 802a016:	8823      	ldrh	r3, [r4, #0]
 802a018:	ed9f 5a4f 	vldr	s10, [pc, #316]	; 802a158 <DMA_Event_Handler+0x21c>
 802a01c:	eddf 5a4f 	vldr	s11, [pc, #316]	; 802a15c <DMA_Event_Handler+0x220>
 802a020:	ed9f 6a4f 	vldr	s12, [pc, #316]	; 802a160 <DMA_Event_Handler+0x224>
 802a024:	eddf 6a4f 	vldr	s13, [pc, #316]	; 802a164 <DMA_Event_Handler+0x228>
  
  if((bsp_bgt_ana_out[1] - bsp_bgt_ana_out[2]) >= 0)
 802a028:	88a2      	ldrh	r2, [r4, #4]
  {
    bgt_ana_temp();
  }
  
  /* Calculate the BGT temperature and output power based on the BGT ANA MUX pin ADC sampled values */
  bsp_bgt_temperature_C = (0.2629f * (1000 * 3.3f * bsp_bgt_ana_out[0] / 4095.0f) - 364.32f);
 802a02a:	494f      	ldr	r1, [pc, #316]	; (802a168 <DMA_Event_Handler+0x22c>)
 802a02c:	ee07 3a90 	vmov	s15, r3
 802a030:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  
  if((bsp_bgt_ana_out[1] - bsp_bgt_ana_out[2]) >= 0)
 802a034:	8863      	ldrh	r3, [r4, #2]
  {
    bgt_ana_temp();
  }
  
  /* Calculate the BGT temperature and output power based on the BGT ANA MUX pin ADC sampled values */
  bsp_bgt_temperature_C = (0.2629f * (1000 * 3.3f * bsp_bgt_ana_out[0] / 4095.0f) - 364.32f);
 802a036:	ee67 7a05 	vmul.f32	s15, s14, s10
  
  if((bsp_bgt_ana_out[1] - bsp_bgt_ana_out[2]) >= 0)
 802a03a:	1a9b      	subs	r3, r3, r2
  {
    bgt_ana_temp();
  }
  
  /* Calculate the BGT temperature and output power based on the BGT ANA MUX pin ADC sampled values */
  bsp_bgt_temperature_C = (0.2629f * (1000 * 3.3f * bsp_bgt_ana_out[0] / 4095.0f) - 364.32f);
 802a03c:	eec7 7aa5 	vdiv.f32	s15, s15, s11
 802a040:	eee7 6a86 	vfma.f32	s13, s15, s12
 802a044:	edc1 6a00 	vstr	s13, [r1]
  
  if((bsp_bgt_ana_out[1] - bsp_bgt_ana_out[2]) >= 0)
 802a048:	d416      	bmi.n	802a078 <DMA_Event_Handler+0x13c>
  {
    bsp_bgt_vout_tx_power_dBm = 5.24f * logf(1000 * 3.3f / 4095.0f * (bsp_bgt_ana_out[1] - bsp_bgt_ana_out[2])) - 23.74f;
 802a04a:	ee07 3a90 	vmov	s15, r3
 802a04e:	ed9f 7a47 	vldr	s14, [pc, #284]	; 802a16c <DMA_Event_Handler+0x230>
 802a052:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802a056:	ee67 7a87 	vmul.f32	s15, s15, s14
 802a05a:	ee17 0a90 	vmov	r0, s15
 802a05e:	f002 ff87 	bl	802cf70 <logf>
 802a062:	ed9f 7a43 	vldr	s14, [pc, #268]	; 802a170 <DMA_Event_Handler+0x234>
 802a066:	eddf 7a43 	vldr	s15, [pc, #268]	; 802a174 <DMA_Event_Handler+0x238>
 802a06a:	4b43      	ldr	r3, [pc, #268]	; (802a178 <DMA_Event_Handler+0x23c>)
 802a06c:	ee06 0a90 	vmov	s13, r0
 802a070:	eee6 7a87 	vfma.f32	s15, s13, s14
 802a074:	edc3 7a00 	vstr	s15, [r3]
  }
  
  /* This callback is used to inform upper layers that a valid data is available and ADC sampling is completed */
  if((bsp_cb.bsp_acq_done_cb != NULL) & (watchdog_status == 0))
 802a078:	4a40      	ldr	r2, [pc, #256]	; (802a17c <DMA_Event_Handler+0x240>)
 802a07a:	4b41      	ldr	r3, [pc, #260]	; (802a180 <DMA_Event_Handler+0x244>)
 802a07c:	7812      	ldrb	r2, [r2, #0]
 802a07e:	685b      	ldr	r3, [r3, #4]
 802a080:	b93a      	cbnz	r2, 802a092 <DMA_Event_Handler+0x156>
 802a082:	b133      	cbz	r3, 802a092 <DMA_Event_Handler+0x156>
  {
    bsp_cb.bsp_acq_done_cb(NULL);
 802a084:	2000      	movs	r0, #0
      chirp_count = 0;
      
      done_sampling();
    }
  }
}
 802a086:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  }
  
  /* This callback is used to inform upper layers that a valid data is available and ADC sampling is completed */
  if((bsp_cb.bsp_acq_done_cb != NULL) & (watchdog_status == 0))
  {
    bsp_cb.bsp_acq_done_cb(NULL);
 802a08a:	4718      	bx	r3
  lbgt_ana_command = bgt_get_ana_config();
  bsp_bgt_ana_out[lbgt_ana_command] = (ADC_MEASUREMENT_ADV_GetResult(&ADC_MEASUREMENT_SCAN_BGT24_ANA_handle));
  
  if (bsp_bgt_ana_out[2] == 0)
  {
    bgt_ana_vref_tx();
 802a08c:	f7ff fba4 	bl	80297d8 <bgt_ana_vref_tx>
 802a090:	e7c1      	b.n	802a016 <DMA_Event_Handler+0xda>
 802a092:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
    
    if (chirp_count < p_acq_buf->params.num_of_chirps_per_frame)
    {
      /* Reconfiguration of DMA destination offset */
      bsp_dma_set_destination_addr_from_acq_buf_obj(p_acq_buf, chirp_count);
 802a096:	f7ff fe0b 	bl	8029cb0 <bsp_dma_set_destination_addr_from_acq_buf_obj>
 */
__STATIC_INLINE void DMA_CH_Enable(DMA_CH_t *const obj)
{
  XMC_ASSERT("DMA_CH_Enable: NULL DMA_CH_t object", (obj != NULL));

  XMC_DMA_CH_Enable(obj->dma_global->dma, obj->ch_num);
 802a09a:	6831      	ldr	r1, [r6, #0]
 802a09c:	682a      	ldr	r2, [r5, #0]
 802a09e:	6823      	ldr	r3, [r4, #0]
 802a0a0:	f8d7 8000 	ldr.w	r8, [r7]
 802a0a4:	f896 c00c 	ldrb.w	ip, [r6, #12]
 802a0a8:	7b28      	ldrb	r0, [r5, #12]
 802a0aa:	f894 e00c 	ldrb.w	lr, [r4, #12]
 802a0ae:	7b3f      	ldrb	r7, [r7, #12]
 802a0b0:	f8d8 6000 	ldr.w	r6, [r8]
 802a0b4:	680c      	ldr	r4, [r1, #0]
 802a0b6:	6811      	ldr	r1, [r2, #0]
 802a0b8:	681a      	ldr	r2, [r3, #0]
 802a0ba:	f240 1301 	movw	r3, #257	; 0x101
 802a0be:	fa03 f707 	lsl.w	r7, r3, r7
 802a0c2:	fa03 f50c 	lsl.w	r5, r3, ip
 802a0c6:	fa03 f000 	lsl.w	r0, r3, r0
 802a0ca:	fa03 f30e 	lsl.w	r3, r3, lr
 802a0ce:	f8c6 73a0 	str.w	r7, [r6, #928]	; 0x3a0
 802a0d2:	f8c4 53a0 	str.w	r5, [r4, #928]	; 0x3a0
 802a0d6:	f8c1 03a0 	str.w	r0, [r1, #928]	; 0x3a0
 802a0da:	f8c2 33a0 	str.w	r3, [r2, #928]	; 0x3a0
 802a0de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  {
    bgt_ana_vref_tx();
  }
  else if (lbgt_ana_command == 2)
  {
    bgt_ana_vout_tx();
 802a0e2:	f7ff fb77 	bl	80297d4 <bgt_ana_vout_tx>
 802a0e6:	e796      	b.n	802a016 <DMA_Event_Handler+0xda>

//============================================================================

void bsp_components_power_down(void)
{
  pll_disable_ramps(pll_handle);
 802a0e8:	4b26      	ldr	r3, [pc, #152]	; (802a184 <DMA_Event_Handler+0x248>)
 802a0ea:	6818      	ldr	r0, [r3, #0]
 802a0ec:	f000 fa34 	bl	802a558 <pll_disable_ramps>
  
  /* To avoid out of band spurs */
  bgt_lowest_power_with_q2_disable();
 802a0f0:	f7ff fb76 	bl	80297e0 <bgt_lowest_power_with_q2_disable>

void bsp_time_delay_usec(uint32_t delay_val_usec)
{
  uint32_t delay_cnt;
  
  TIMER_ClearEvent(&TIMER_DELAY);
 802a0f4:	4824      	ldr	r0, [pc, #144]	; (802a188 <DMA_Event_Handler+0x24c>)
 802a0f6:	f7fc fdd1 	bl	8026c9c <TIMER_ClearEvent>
  
  /* time in in units of microseconds */
  delay_cnt = delay_val_usec * 100U;
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
 802a0fa:	4823      	ldr	r0, [pc, #140]	; (802a188 <DMA_Event_Handler+0x24c>)
 802a0fc:	f241 3188 	movw	r1, #5000	; 0x1388
 802a100:	f7fc fd0a 	bl	8026b18 <TIMER_SetTimeInterval>

TIMER_STATUS_t bsp_timer_start(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Start(handle_timer);
 802a104:	4820      	ldr	r0, [pc, #128]	; (802a188 <DMA_Event_Handler+0x24c>)
 802a106:	f7fc fcbd 	bl	8026a84 <TIMER_Start>
  
  TIMER_SetTimeInterval(&TIMER_DELAY,delay_cnt);
  
  bsp_timer_start(&TIMER_DELAY);
  
  while(!TIMER_GetInterruptStatus(&TIMER_DELAY));
 802a10a:	481f      	ldr	r0, [pc, #124]	; (802a188 <DMA_Event_Handler+0x24c>)
 802a10c:	f7fc fdb4 	bl	8026c78 <TIMER_GetInterruptStatus>
 802a110:	2800      	cmp	r0, #0
 802a112:	d0fa      	beq.n	802a10a <DMA_Event_Handler+0x1ce>
  
  TIMER_Stop(&TIMER_DELAY);
 802a114:	481c      	ldr	r0, [pc, #112]	; (802a188 <DMA_Event_Handler+0x24c>)
 802a116:	f7fc fccb 	bl	8026ab0 <TIMER_Stop>
  
  TIMER_Clear(&TIMER_DELAY);
 802a11a:	481b      	ldr	r0, [pc, #108]	; (802a188 <DMA_Event_Handler+0x24c>)
 802a11c:	f7fc fdd4 	bl	8026cc8 <TIMER_Clear>
  /* To avoid out of band spurs */
  bgt_lowest_power_with_q2_disable();
  bsp_time_delay_usec(50U);           /* Delay for BGT Power down SPI settings */
  
  /* Power-down BGT */
  bgt_power_down();
 802a120:	f7ff fb34 	bl	802978c <bgt_power_down>
  
  /* Disable PLL */
  pll_power_down();
 802a124:	f000 fa22 	bl	802a56c <pll_power_down>
 802a128:	e75d      	b.n	8029fe6 <DMA_Event_Handler+0xaa>
 802a12a:	bf00      	nop
 802a12c:	1ffe8fc4 	.word	0x1ffe8fc4
 802a130:	1ffe8ae0 	.word	0x1ffe8ae0
 802a134:	1ffe8a68 	.word	0x1ffe8a68
 802a138:	1ffe8b48 	.word	0x1ffe8b48
 802a13c:	1ffe8a78 	.word	0x1ffe8a78
 802a140:	08031c4c 	.word	0x08031c4c
 802a144:	1fff2ab8 	.word	0x1fff2ab8
 802a148:	1ffe9000 	.word	0x1ffe9000
 802a14c:	08031cc4 	.word	0x08031cc4
 802a150:	08031bd0 	.word	0x08031bd0
 802a154:	1fff2ad0 	.word	0x1fff2ad0
 802a158:	454e4000 	.word	0x454e4000
 802a15c:	457ff000 	.word	0x457ff000
 802a160:	3e869ad4 	.word	0x3e869ad4
 802a164:	c3b628f6 	.word	0xc3b628f6
 802a168:	1fff2ad8 	.word	0x1fff2ad8
 802a16c:	3f4e4ce5 	.word	0x3f4e4ce5
 802a170:	40a7ae14 	.word	0x40a7ae14
 802a174:	c1bdeb85 	.word	0xc1bdeb85
 802a178:	1fff2acc 	.word	0x1fff2acc
 802a17c:	1fff2aac 	.word	0x1fff2aac
 802a180:	1fff2ae4 	.word	0x1fff2ae4
 802a184:	1ffe9004 	.word	0x1ffe9004
 802a188:	1ffe88f8 	.word	0x1ffe88f8
 802a18c:	1fff2ab0 	.word	0x1fff2ab0

0802a190 <bsp_usb_init>:
}

//============================================================================

uint8_t bsp_usb_init(uint32_t timeout_delay)
{
 802a190:	b538      	push	{r3, r4, r5, lr}
 802a192:	4605      	mov	r5, r0
  uint32_t time_out_cnt = 0;
  
  if (USBD_VCOM_Connect() != USBD_VCOM_STATUS_SUCCESS)
 802a194:	f7fb fd22 	bl	8025bdc <USBD_VCOM_Connect>
 802a198:	b958      	cbnz	r0, 802a1b2 <bsp_usb_init+0x22>
  {
    return (1); /* Fail */
  }
  
  while (time_out_cnt < timeout_delay)
 802a19a:	b155      	cbz	r5, 802a1b2 <bsp_usb_init+0x22>
 802a19c:	4604      	mov	r4, r0
 802a19e:	e001      	b.n	802a1a4 <bsp_usb_init+0x14>
 802a1a0:	42ac      	cmp	r4, r5
 802a1a2:	d006      	beq.n	802a1b2 <bsp_usb_init+0x22>
  {
    if (USBD_VCOM_IsEnumDone())
 802a1a4:	f7fb fcba 	bl	8025b1c <USBD_VCOM_IsEnumDone>
    {
      return (0); /* Success */
    }
    
    time_out_cnt++;
 802a1a8:	3401      	adds	r4, #1
    return (1); /* Fail */
  }
  
  while (time_out_cnt < timeout_delay)
  {
    if (USBD_VCOM_IsEnumDone())
 802a1aa:	2800      	cmp	r0, #0
 802a1ac:	d0f8      	beq.n	802a1a0 <bsp_usb_init+0x10>
    {
      return (0); /* Success */
 802a1ae:	2000      	movs	r0, #0
    
    time_out_cnt++;
  }
  
  return (1); /* Fail */
}
 802a1b0:	bd38      	pop	{r3, r4, r5, pc}
{
  uint32_t time_out_cnt = 0;
  
  if (USBD_VCOM_Connect() != USBD_VCOM_STATUS_SUCCESS)
  {
    return (1); /* Fail */
 802a1b2:	2001      	movs	r0, #1
 802a1b4:	bd38      	pop	{r3, r4, r5, pc}
 802a1b6:	bf00      	nop

0802a1b8 <bsp_bgt_get_temp_value>:

//============================================================================

float32_t bsp_bgt_get_temp_value(void)
{
  return (bsp_bgt_temperature_C);
 802a1b8:	4b01      	ldr	r3, [pc, #4]	; (802a1c0 <bsp_bgt_get_temp_value+0x8>)
}
 802a1ba:	6818      	ldr	r0, [r3, #0]
 802a1bc:	4770      	bx	lr
 802a1be:	bf00      	nop
 802a1c0:	1fff2ad8 	.word	0x1fff2ad8

0802a1c4 <bsp_bgt_get_txpower_value>:

//============================================================================

float32_t bsp_bgt_get_txpower_value(void)
{
  return (bsp_bgt_vout_tx_power_dBm);
 802a1c4:	4b01      	ldr	r3, [pc, #4]	; (802a1cc <bsp_bgt_get_txpower_value+0x8>)
}
 802a1c6:	6818      	ldr	r0, [r3, #0]
 802a1c8:	4770      	bx	lr
 802a1ca:	bf00      	nop
 802a1cc:	1fff2acc 	.word	0x1fff2acc

0802a1d0 <bsp_set_num_samples_per_dma_transfer>:

//============================================================================

void bsp_set_num_samples_per_dma_transfer(uint32_t num_samples_per_dma_transfer)
{
  bsp_num_samples_per_dma_transfer = num_samples_per_dma_transfer;
 802a1d0:	4b01      	ldr	r3, [pc, #4]	; (802a1d8 <bsp_set_num_samples_per_dma_transfer+0x8>)
 802a1d2:	6018      	str	r0, [r3, #0]
 802a1d4:	4770      	bx	lr
 802a1d6:	bf00      	nop
 802a1d8:	1fff2ac8 	.word	0x1fff2ac8

0802a1dc <bsp_set_num_chirps_per_frame>:

//============================================================================

void bsp_set_num_chirps_per_frame(uint32_t num_chirps_per_frame)
{
  pll_set_num_chirps_per_frame(num_chirps_per_frame);
 802a1dc:	f000 ba64 	b.w	802a6a8 <pll_set_num_chirps_per_frame>

0802a1e0 <bsp_get_frame_counter>:

//============================================================================

uint16_t bsp_get_frame_counter(void)
{
  return (bsp_frame_counter);
 802a1e0:	4b01      	ldr	r3, [pc, #4]	; (802a1e8 <bsp_get_frame_counter+0x8>)
 802a1e2:	8818      	ldrh	r0, [r3, #0]
}
 802a1e4:	b280      	uxth	r0, r0
 802a1e6:	4770      	bx	lr
 802a1e8:	1fff2ab8 	.word	0x1fff2ab8

0802a1ec <bsp_reset_frame_counter>:

//============================================================================

void bsp_reset_frame_counter(void)
{
  bsp_frame_counter = 0;
 802a1ec:	4b01      	ldr	r3, [pc, #4]	; (802a1f4 <bsp_reset_frame_counter+0x8>)
 802a1ee:	2200      	movs	r2, #0
 802a1f0:	801a      	strh	r2, [r3, #0]
 802a1f2:	4770      	bx	lr
 802a1f4:	1fff2ab8 	.word	0x1fff2ab8

0802a1f8 <bsp_set_duty_cycle_enable_flag>:

//============================================================================

void bsp_set_duty_cycle_enable_flag(const uint8_t flag)
{
  bsp_duty_cycle_enable = flag;
 802a1f8:	4b01      	ldr	r3, [pc, #4]	; (802a200 <bsp_set_duty_cycle_enable_flag+0x8>)
 802a1fa:	7018      	strb	r0, [r3, #0]
 802a1fc:	4770      	bx	lr
 802a1fe:	bf00      	nop
 802a200:	1ffe9000 	.word	0x1ffe9000

0802a204 <bsp_register_callback>:
uint8_t bsp_register_callback(Bsp_Callback_ID_t cb_id, void (*pcallback)(void *parameter))
{
  uint8_t status = 0;
  
  /* Check if he callback function is valid */
  if(pcallback == NULL)
 802a204:	b139      	cbz	r1, 802a216 <bsp_register_callback+0x12>
  {
    return(1);
  }
  
  /* Register user callback function based on callback ID */
  switch (cb_id)
 802a206:	2801      	cmp	r0, #1
 802a208:	d007      	beq.n	802a21a <bsp_register_callback+0x16>
 802a20a:	2802      	cmp	r0, #2
 802a20c:	d103      	bne.n	802a216 <bsp_register_callback+0x12>
  case BSP_ACQUISITION_STARTED_CB_ID:
    bsp_cb.bsp_acq_started_cb = pcallback;
    break;
    
  case BSP_ACQUISITION_DONE_CB_ID:
    bsp_cb.bsp_acq_done_cb = pcallback;
 802a20e:	4b05      	ldr	r3, [pc, #20]	; (802a224 <bsp_register_callback+0x20>)

//============================================================================

uint8_t bsp_register_callback(Bsp_Callback_ID_t cb_id, void (*pcallback)(void *parameter))
{
  uint8_t status = 0;
 802a210:	2000      	movs	r0, #0
  case BSP_ACQUISITION_STARTED_CB_ID:
    bsp_cb.bsp_acq_started_cb = pcallback;
    break;
    
  case BSP_ACQUISITION_DONE_CB_ID:
    bsp_cb.bsp_acq_done_cb = pcallback;
 802a212:	6059      	str	r1, [r3, #4]
    break;
 802a214:	4770      	bx	lr
    
  default:
    /* Return error status */
    status =  1;
 802a216:	2001      	movs	r0, #1
    break;
  }
  
  return (status);
}
 802a218:	4770      	bx	lr
  
  /* Register user callback function based on callback ID */
  switch (cb_id)
  {
  case BSP_ACQUISITION_STARTED_CB_ID:
    bsp_cb.bsp_acq_started_cb = pcallback;
 802a21a:	4b02      	ldr	r3, [pc, #8]	; (802a224 <bsp_register_callback+0x20>)

//============================================================================

uint8_t bsp_register_callback(Bsp_Callback_ID_t cb_id, void (*pcallback)(void *parameter))
{
  uint8_t status = 0;
 802a21c:	2000      	movs	r0, #0
  
  /* Register user callback function based on callback ID */
  switch (cb_id)
  {
  case BSP_ACQUISITION_STARTED_CB_ID:
    bsp_cb.bsp_acq_started_cb = pcallback;
 802a21e:	6019      	str	r1, [r3, #0]
    break;
 802a220:	4770      	bx	lr
 802a222:	bf00      	nop
 802a224:	1fff2ae4 	.word	0x1fff2ae4

0802a228 <bsp_led_on>:
}

//============================================================================

void bsp_led_on(void)
{
 802a228:	4b03      	ldr	r3, [pc, #12]	; (802a238 <bsp_led_on+0x10>)
 802a22a:	7c19      	ldrb	r1, [r3, #16]
 802a22c:	681a      	ldr	r2, [r3, #0]
 802a22e:	2301      	movs	r3, #1
 802a230:	408b      	lsls	r3, r1
 802a232:	6053      	str	r3, [r2, #4]
 802a234:	4770      	bx	lr
 802a236:	bf00      	nop
 802a238:	08030d48 	.word	0x08030d48

0802a23c <bsp_led_off>:
}

//============================================================================

void bsp_led_off(void)
{
 802a23c:	4b03      	ldr	r3, [pc, #12]	; (802a24c <bsp_led_off+0x10>)

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 802a23e:	7c19      	ldrb	r1, [r3, #16]
 802a240:	681a      	ldr	r2, [r3, #0]
 802a242:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 802a246:	408b      	lsls	r3, r1
 802a248:	6053      	str	r3, [r2, #4]
 802a24a:	4770      	bx	lr
 802a24c:	08030d48 	.word	0x08030d48

0802a250 <CCU43_1_IRQHandler>:
}

//============================================================================

void watchdog_isr(void)
{
 802a250:	b508      	push	{r3, lr}
  if(chirp_count < (ds_device_get_settings()->pll_num_of_chirps_per_frame-1))
 802a252:	f7f5 ff6f 	bl	8020134 <ds_device_get_settings>
 802a256:	4a08      	ldr	r2, [pc, #32]	; (802a278 <CCU43_1_IRQHandler+0x28>)
 802a258:	6943      	ldr	r3, [r0, #20]
 802a25a:	6812      	ldr	r2, [r2, #0]
 802a25c:	3b01      	subs	r3, #1
 802a25e:	4293      	cmp	r3, r2
 802a260:	d902      	bls.n	802a268 <CCU43_1_IRQHandler+0x18>
  {
    watchdog_status = 1;
 802a262:	4b06      	ldr	r3, [pc, #24]	; (802a27c <CCU43_1_IRQHandler+0x2c>)
 802a264:	2201      	movs	r2, #1
 802a266:	701a      	strb	r2, [r3, #0]

TIMER_STATUS_t timer_stop_clear(TIMER_t* const handle_timer)
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Stop(handle_timer);
 802a268:	4805      	ldr	r0, [pc, #20]	; (802a280 <CCU43_1_IRQHandler+0x30>)
 802a26a:	f7fc fc21 	bl	8026ab0 <TIMER_Stop>
  
  status |= TIMER_Clear(handle_timer);
 802a26e:	4804      	ldr	r0, [pc, #16]	; (802a280 <CCU43_1_IRQHandler+0x30>)
  {
    watchdog_status = 1;
  }
  
  timer_stop_clear(&TIMER_WATCHDOG);
}
 802a270:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
  TIMER_STATUS_t  status;
  
  status = TIMER_Stop(handle_timer);
  
  status |= TIMER_Clear(handle_timer);
 802a274:	f7fc bd28 	b.w	8026cc8 <TIMER_Clear>
 802a278:	1fff2ab0 	.word	0x1fff2ab0
 802a27c:	1fff2aac 	.word	0x1fff2aac
 802a280:	1ffe893c 	.word	0x1ffe893c

0802a284 <pga_init>:
 */

Pga_Status_t pga_init(uint16_t gain_level)
{
  /* Initialize the PGA112 device */
  return pga112_init(gain_level);
 802a284:	f000 ba92 	b.w	802a7ac <pga112_init>

0802a288 <pga_set_gain>:
//============================================================================

Pga_Status_t pga_set_gain(uint16_t gain_level)
{
  /* Updates the PGA112 gain */
  return pga112_set_gain(gain_level);
 802a288:	f000 baca 	b.w	802a820 <pga112_set_gain>

0802a28c <pga_ldo_enable>:
}

//============================================================================

void pga_ldo_enable(void)
{
 802a28c:	4a07      	ldr	r2, [pc, #28]	; (802a2ac <pga_ldo_enable+0x20>)
 802a28e:	4b08      	ldr	r3, [pc, #32]	; (802a2b0 <pga_ldo_enable+0x24>)

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 802a290:	7c10      	ldrb	r0, [r2, #16]
 802a292:	6811      	ldr	r1, [r2, #0]
 802a294:	681a      	ldr	r2, [r3, #0]
 802a296:	b410      	push	{r4}
 802a298:	7c1c      	ldrb	r4, [r3, #16]
 802a29a:	2301      	movs	r3, #1
 802a29c:	fa03 f000 	lsl.w	r0, r3, r0
 802a2a0:	40a3      	lsls	r3, r4
 802a2a2:	6048      	str	r0, [r1, #4]
  DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_SPI_M_CS_PGA);
  DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_PGA_LDO_ENABLE);
}
 802a2a4:	f85d 4b04 	ldr.w	r4, [sp], #4
 802a2a8:	6053      	str	r3, [r2, #4]
 802a2aa:	4770      	bx	lr
 802a2ac:	08030cbc 	.word	0x08030cbc
 802a2b0:	08030d5c 	.word	0x08030d5c
 802a2b4:	00000000 	.word	0x00000000

0802a2b8 <pll_init>:
   3. EXPORTED FUNCTIONS
==============================================================================
 */

void pll_init(void* pll_handle)
{
 802a2b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  Lmx249x_Object_t* lmx249x_pll = (Lmx249x_Object_t*)pll_handle;
  Lmx249x_Hardware_Setup_t s_sPLLHardwareSetup;
  
  /* Send general configuration to PLL */
  /* --------------------------------- */
  s_sPLLHardwareSetup.dReferenceFreq         = 40.0;
 802a2bc:	ed9f 7b30 	vldr	d7, [pc, #192]	; 802a380 <pll_init+0xc8>
   3. EXPORTED FUNCTIONS
==============================================================================
 */

void pll_init(void* pll_handle)
{
 802a2c0:	b08b      	sub	sp, #44	; 0x2c
  s_sPLLHardwareSetup.uLockDetectNumGoodEdge = 32;
  s_sPLLHardwareSetup.uLockDetectNumBadEdge  = 4;
  s_sPLLHardwareSetup.eLockDetectWindow      = LMX249x_DLD_TOL_10NS;
  
  /* Set the digital IOs used by SPI interface */
  lmx249x_spi_pins.spi_device = LMX_DEVICE;
 802a2c2:	f8df e0cc 	ldr.w	lr, [pc, #204]	; 802a390 <pll_init+0xd8>
  lmx249x_spi_pins.gpio_cs_pin 	 = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_PLL;
 802a2c6:	4b30      	ldr	r3, [pc, #192]	; (802a388 <pll_init+0xd0>)
  lmx249x_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_DATA;
 802a2c8:	f8df 80c8 	ldr.w	r8, [pc, #200]	; 802a394 <pll_init+0xdc>
  lmx249x_spi_pins.gpio_clk_pin  = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;
 802a2cc:	f8df c0c8 	ldr.w	ip, [pc, #200]	; 802a398 <pll_init+0xe0>
  
  lmx249x_init(lmx249x_pll, &s_sPLLHardwareSetup, spi_transmit_data, (void*)&lmx249x_spi_pins);
 802a2d0:	4a2e      	ldr	r2, [pc, #184]	; (802a38c <pll_init+0xd4>)
  s_sPLLHardwareSetup.uLockDetectNumBadEdge  = 4;
  s_sPLLHardwareSetup.eLockDetectWindow      = LMX249x_DLD_TOL_10NS;
  
  /* Set the digital IOs used by SPI interface */
  lmx249x_spi_pins.spi_device = LMX_DEVICE;
  lmx249x_spi_pins.gpio_cs_pin 	 = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_PLL;
 802a2d2:	f8ce 3004 	str.w	r3, [lr, #4]
  
  /* Send general configuration to PLL */
  /* --------------------------------- */
  s_sPLLHardwareSetup.dReferenceFreq         = 40.0;
  s_sPLLHardwareSetup.uReferenceDivider      = 1;
  s_sPLLHardwareSetup.eReferenceDoubler      = LMX249x_OSCIN_DOUBLER_OFF;
 802a2d6:	2700      	movs	r7, #0
  Lmx249x_Hardware_Setup_t s_sPLLHardwareSetup;
  
  /* Send general configuration to PLL */
  /* --------------------------------- */
  s_sPLLHardwareSetup.dReferenceFreq         = 40.0;
  s_sPLLHardwareSetup.uReferenceDivider      = 1;
 802a2d8:	2501      	movs	r5, #1
  s_sPLLHardwareSetup.eReferenceDoubler      = LMX249x_OSCIN_DOUBLER_OFF;
  s_sPLLHardwareSetup.eOscInMode             = LMX249x_OSCIN_SINGLE_ENDED;
  s_sPLLHardwareSetup.uExternalDivider       = 16;
 802a2da:	2110      	movs	r1, #16
  s_sPLLHardwareSetup.eTrig1PinFunction      = LMX249x_MUX_OUT_FLAG0_FROM_RAMP;
  s_sPLLHardwareSetup.eTrig1PinDriveMode     = LMX249x_PIN_FCN_PULLUPDN_OUT;
 802a2dc:	2402      	movs	r4, #2
  lmx249x_spi_pins.spi_device = LMX_DEVICE;
  lmx249x_spi_pins.gpio_cs_pin 	 = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_PLL;
  lmx249x_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_DATA;
  lmx249x_spi_pins.gpio_clk_pin  = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;
  
  lmx249x_init(lmx249x_pll, &s_sPLLHardwareSetup, spi_transmit_data, (void*)&lmx249x_spi_pins);
 802a2de:	4673      	mov	r3, lr
  s_sPLLHardwareSetup.eOscInMode             = LMX249x_OSCIN_SINGLE_ENDED;
  s_sPLLHardwareSetup.uExternalDivider       = 16;
  s_sPLLHardwareSetup.eTrig1PinFunction      = LMX249x_MUX_OUT_FLAG0_FROM_RAMP;
  s_sPLLHardwareSetup.eTrig1PinDriveMode     = LMX249x_PIN_FCN_PULLUPDN_OUT;
  s_sPLLHardwareSetup.eTrig2PinFunction      = LMX249x_MUX_IN_TRIG2;
  s_sPLLHardwareSetup.eTrig2PinDriveMode     = LMX249x_PIN_FCN_INPUT;
 802a2e0:	2607      	movs	r6, #7
  s_sPLLHardwareSetup.eLockDetectWindow      = LMX249x_DLD_TOL_10NS;
  
  /* Set the digital IOs used by SPI interface */
  lmx249x_spi_pins.spi_device = LMX_DEVICE;
  lmx249x_spi_pins.gpio_cs_pin 	 = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_PLL;
  lmx249x_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_DATA;
 802a2e2:	f8ce 8008 	str.w	r8, [lr, #8]
  lmx249x_spi_pins.gpio_clk_pin  = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;
 802a2e6:	f8ce c00c 	str.w	ip, [lr, #12]
  s_sPLLHardwareSetup.uLockDetectNumGoodEdge = 32;
  s_sPLLHardwareSetup.uLockDetectNumBadEdge  = 4;
  s_sPLLHardwareSetup.eLockDetectWindow      = LMX249x_DLD_TOL_10NS;
  
  /* Set the digital IOs used by SPI interface */
  lmx249x_spi_pins.spi_device = LMX_DEVICE;
 802a2ea:	f88e 5000 	strb.w	r5, [lr]
  s_sPLLHardwareSetup.eMUXoutPinDriveMode    = LMX249x_PIN_FCN_PULLUPDN_OUT;
  s_sPLLHardwareSetup.eChargePumpPolarity    = LMX249x_CPPOL_NEGATIVE;
  s_sPLLHardwareSetup.uChargePumpCurrent     = 20;
  s_sPLLHardwareSetup.uChargePumpCurrentFS   = 0;
  s_sPLLHardwareSetup.uChargePumpThresholdLo = 6;
  s_sPLLHardwareSetup.uChargePumpThresholdHi = 42;
 802a2ee:	f04f 0c2a 	mov.w	ip, #42	; 0x2a
  s_sPLLHardwareSetup.eChargePumpPulseWidth  = LMX249x_CP_PULSE_860PS;
  s_sPLLHardwareSetup.eCycleSlipReduction    = LMX249x_CSR_DISABLED;
  s_sPLLHardwareSetup.uFastLockTimer         = 0;
  s_sPLLHardwareSetup.uLockDetectNumGoodEdge = 32;
 802a2f2:	f04f 0e20 	mov.w	lr, #32
  Lmx249x_Hardware_Setup_t s_sPLLHardwareSetup;
  
  /* Send general configuration to PLL */
  /* --------------------------------- */
  s_sPLLHardwareSetup.dReferenceFreq         = 40.0;
  s_sPLLHardwareSetup.uReferenceDivider      = 1;
 802a2f6:	f8ad 5008 	strh.w	r5, [sp, #8]
  s_sPLLHardwareSetup.eChargePumpPolarity    = LMX249x_CPPOL_NEGATIVE;
  s_sPLLHardwareSetup.uChargePumpCurrent     = 20;
  s_sPLLHardwareSetup.uChargePumpCurrentFS   = 0;
  s_sPLLHardwareSetup.uChargePumpThresholdLo = 6;
  s_sPLLHardwareSetup.uChargePumpThresholdHi = 42;
  s_sPLLHardwareSetup.eChargePumpPulseWidth  = LMX249x_CP_PULSE_860PS;
 802a2fa:	f88d 501d 	strb.w	r5, [sp, #29]
  
  /* Send general configuration to PLL */
  /* --------------------------------- */
  s_sPLLHardwareSetup.dReferenceFreq         = 40.0;
  s_sPLLHardwareSetup.uReferenceDivider      = 1;
  s_sPLLHardwareSetup.eReferenceDoubler      = LMX249x_OSCIN_DOUBLER_OFF;
 802a2fe:	f88d 700a 	strb.w	r7, [sp, #10]
  s_sPLLHardwareSetup.uChargePumpThresholdHi = 42;
  s_sPLLHardwareSetup.eChargePumpPulseWidth  = LMX249x_CP_PULSE_860PS;
  s_sPLLHardwareSetup.eCycleSlipReduction    = LMX249x_CSR_DISABLED;
  s_sPLLHardwareSetup.uFastLockTimer         = 0;
  s_sPLLHardwareSetup.uLockDetectNumGoodEdge = 32;
  s_sPLLHardwareSetup.uLockDetectNumBadEdge  = 4;
 802a302:	2504      	movs	r5, #4
  /* Send general configuration to PLL */
  /* --------------------------------- */
  s_sPLLHardwareSetup.dReferenceFreq         = 40.0;
  s_sPLLHardwareSetup.uReferenceDivider      = 1;
  s_sPLLHardwareSetup.eReferenceDoubler      = LMX249x_OSCIN_DOUBLER_OFF;
  s_sPLLHardwareSetup.eOscInMode             = LMX249x_OSCIN_SINGLE_ENDED;
 802a304:	f88d 700b 	strb.w	r7, [sp, #11]
  s_sPLLHardwareSetup.eTrig2PinDriveMode     = LMX249x_PIN_FCN_INPUT;
  s_sPLLHardwareSetup.eModPinFunction        = LMX249x_MUX_OUT_FLAG1_FROM_RAMP;
  s_sPLLHardwareSetup.eModPinDriveMode       = LMX249x_PIN_FCN_PULLUPDN_OUT;
  s_sPLLHardwareSetup.eMUXoutPinFunction     = LMX249x_MUX_OUT_READ_BACK;
  s_sPLLHardwareSetup.eMUXoutPinDriveMode    = LMX249x_PIN_FCN_PULLUPDN_OUT;
  s_sPLLHardwareSetup.eChargePumpPolarity    = LMX249x_CPPOL_NEGATIVE;
 802a308:	f88d 7018 	strb.w	r7, [sp, #24]
  s_sPLLHardwareSetup.uChargePumpCurrent     = 20;
  s_sPLLHardwareSetup.uChargePumpCurrentFS   = 0;
 802a30c:	f88d 701a 	strb.w	r7, [sp, #26]
  s_sPLLHardwareSetup.uChargePumpThresholdLo = 6;
  s_sPLLHardwareSetup.uChargePumpThresholdHi = 42;
  s_sPLLHardwareSetup.eChargePumpPulseWidth  = LMX249x_CP_PULSE_860PS;
  s_sPLLHardwareSetup.eCycleSlipReduction    = LMX249x_CSR_DISABLED;
 802a310:	f88d 701e 	strb.w	r7, [sp, #30]
  s_sPLLHardwareSetup.uFastLockTimer         = 0;
 802a314:	f8ad 7020 	strh.w	r7, [sp, #32]
  /* --------------------------------- */
  s_sPLLHardwareSetup.dReferenceFreq         = 40.0;
  s_sPLLHardwareSetup.uReferenceDivider      = 1;
  s_sPLLHardwareSetup.eReferenceDoubler      = LMX249x_OSCIN_DOUBLER_OFF;
  s_sPLLHardwareSetup.eOscInMode             = LMX249x_OSCIN_SINGLE_ENDED;
  s_sPLLHardwareSetup.uExternalDivider       = 16;
 802a318:	9103      	str	r1, [sp, #12]
   3. EXPORTED FUNCTIONS
==============================================================================
 */

void pll_init(void* pll_handle)
{
 802a31a:	4607      	mov	r7, r0
  lmx249x_spi_pins.spi_device = LMX_DEVICE;
  lmx249x_spi_pins.gpio_cs_pin 	 = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_PLL;
  lmx249x_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_DATA;
  lmx249x_spi_pins.gpio_clk_pin  = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;
  
  lmx249x_init(lmx249x_pll, &s_sPLLHardwareSetup, spi_transmit_data, (void*)&lmx249x_spi_pins);
 802a31c:	4669      	mov	r1, sp
  s_sPLLHardwareSetup.dReferenceFreq         = 40.0;
  s_sPLLHardwareSetup.uReferenceDivider      = 1;
  s_sPLLHardwareSetup.eReferenceDoubler      = LMX249x_OSCIN_DOUBLER_OFF;
  s_sPLLHardwareSetup.eOscInMode             = LMX249x_OSCIN_SINGLE_ENDED;
  s_sPLLHardwareSetup.uExternalDivider       = 16;
  s_sPLLHardwareSetup.eTrig1PinFunction      = LMX249x_MUX_OUT_FLAG0_FROM_RAMP;
 802a31e:	f04f 0b1e 	mov.w	fp, #30
  s_sPLLHardwareSetup.eTrig1PinDriveMode     = LMX249x_PIN_FCN_PULLUPDN_OUT;
  s_sPLLHardwareSetup.eTrig2PinFunction      = LMX249x_MUX_IN_TRIG2;
  s_sPLLHardwareSetup.eTrig2PinDriveMode     = LMX249x_PIN_FCN_INPUT;
  s_sPLLHardwareSetup.eModPinFunction        = LMX249x_MUX_OUT_FLAG1_FROM_RAMP;
 802a322:	f04f 0a1f 	mov.w	sl, #31
  s_sPLLHardwareSetup.eModPinDriveMode       = LMX249x_PIN_FCN_PULLUPDN_OUT;
  s_sPLLHardwareSetup.eMUXoutPinFunction     = LMX249x_MUX_OUT_READ_BACK;
  s_sPLLHardwareSetup.eMUXoutPinDriveMode    = LMX249x_PIN_FCN_PULLUPDN_OUT;
  s_sPLLHardwareSetup.eChargePumpPolarity    = LMX249x_CPPOL_NEGATIVE;
  s_sPLLHardwareSetup.uChargePumpCurrent     = 20;
 802a326:	f04f 0914 	mov.w	r9, #20
  s_sPLLHardwareSetup.uChargePumpCurrentFS   = 0;
  s_sPLLHardwareSetup.uChargePumpThresholdLo = 6;
 802a32a:	f04f 0806 	mov.w	r8, #6
  Lmx249x_Object_t* lmx249x_pll = (Lmx249x_Object_t*)pll_handle;
  Lmx249x_Hardware_Setup_t s_sPLLHardwareSetup;
  
  /* Send general configuration to PLL */
  /* --------------------------------- */
  s_sPLLHardwareSetup.dReferenceFreq         = 40.0;
 802a32e:	ed8d 7b00 	vstr	d7, [sp]
  s_sPLLHardwareSetup.eMUXoutPinDriveMode    = LMX249x_PIN_FCN_PULLUPDN_OUT;
  s_sPLLHardwareSetup.eChargePumpPolarity    = LMX249x_CPPOL_NEGATIVE;
  s_sPLLHardwareSetup.uChargePumpCurrent     = 20;
  s_sPLLHardwareSetup.uChargePumpCurrentFS   = 0;
  s_sPLLHardwareSetup.uChargePumpThresholdLo = 6;
  s_sPLLHardwareSetup.uChargePumpThresholdHi = 42;
 802a332:	f88d c01c 	strb.w	ip, [sp, #28]
  s_sPLLHardwareSetup.eChargePumpPulseWidth  = LMX249x_CP_PULSE_860PS;
  s_sPLLHardwareSetup.eCycleSlipReduction    = LMX249x_CSR_DISABLED;
  s_sPLLHardwareSetup.uFastLockTimer         = 0;
  s_sPLLHardwareSetup.uLockDetectNumGoodEdge = 32;
 802a336:	f88d e022 	strb.w	lr, [sp, #34]	; 0x22
  s_sPLLHardwareSetup.dReferenceFreq         = 40.0;
  s_sPLLHardwareSetup.uReferenceDivider      = 1;
  s_sPLLHardwareSetup.eReferenceDoubler      = LMX249x_OSCIN_DOUBLER_OFF;
  s_sPLLHardwareSetup.eOscInMode             = LMX249x_OSCIN_SINGLE_ENDED;
  s_sPLLHardwareSetup.uExternalDivider       = 16;
  s_sPLLHardwareSetup.eTrig1PinFunction      = LMX249x_MUX_OUT_FLAG0_FROM_RAMP;
 802a33a:	f88d b010 	strb.w	fp, [sp, #16]
  s_sPLLHardwareSetup.eTrig1PinDriveMode     = LMX249x_PIN_FCN_PULLUPDN_OUT;
 802a33e:	f88d 4011 	strb.w	r4, [sp, #17]
  s_sPLLHardwareSetup.eTrig2PinFunction      = LMX249x_MUX_IN_TRIG2;
 802a342:	f88d 4012 	strb.w	r4, [sp, #18]
  s_sPLLHardwareSetup.eTrig2PinDriveMode     = LMX249x_PIN_FCN_INPUT;
  s_sPLLHardwareSetup.eModPinFunction        = LMX249x_MUX_OUT_FLAG1_FROM_RAMP;
  s_sPLLHardwareSetup.eModPinDriveMode       = LMX249x_PIN_FCN_PULLUPDN_OUT;
 802a346:	f88d 4015 	strb.w	r4, [sp, #21]
  s_sPLLHardwareSetup.eMUXoutPinFunction     = LMX249x_MUX_OUT_READ_BACK;
  s_sPLLHardwareSetup.eMUXoutPinDriveMode    = LMX249x_PIN_FCN_PULLUPDN_OUT;
 802a34a:	f88d 4017 	strb.w	r4, [sp, #23]
  s_sPLLHardwareSetup.eOscInMode             = LMX249x_OSCIN_SINGLE_ENDED;
  s_sPLLHardwareSetup.uExternalDivider       = 16;
  s_sPLLHardwareSetup.eTrig1PinFunction      = LMX249x_MUX_OUT_FLAG0_FROM_RAMP;
  s_sPLLHardwareSetup.eTrig1PinDriveMode     = LMX249x_PIN_FCN_PULLUPDN_OUT;
  s_sPLLHardwareSetup.eTrig2PinFunction      = LMX249x_MUX_IN_TRIG2;
  s_sPLLHardwareSetup.eTrig2PinDriveMode     = LMX249x_PIN_FCN_INPUT;
 802a34e:	f88d 6013 	strb.w	r6, [sp, #19]
  s_sPLLHardwareSetup.eModPinFunction        = LMX249x_MUX_OUT_FLAG1_FROM_RAMP;
  s_sPLLHardwareSetup.eModPinDriveMode       = LMX249x_PIN_FCN_PULLUPDN_OUT;
  s_sPLLHardwareSetup.eMUXoutPinFunction     = LMX249x_MUX_OUT_READ_BACK;
 802a352:	f88d 6016 	strb.w	r6, [sp, #22]
  s_sPLLHardwareSetup.uExternalDivider       = 16;
  s_sPLLHardwareSetup.eTrig1PinFunction      = LMX249x_MUX_OUT_FLAG0_FROM_RAMP;
  s_sPLLHardwareSetup.eTrig1PinDriveMode     = LMX249x_PIN_FCN_PULLUPDN_OUT;
  s_sPLLHardwareSetup.eTrig2PinFunction      = LMX249x_MUX_IN_TRIG2;
  s_sPLLHardwareSetup.eTrig2PinDriveMode     = LMX249x_PIN_FCN_INPUT;
  s_sPLLHardwareSetup.eModPinFunction        = LMX249x_MUX_OUT_FLAG1_FROM_RAMP;
 802a356:	f88d a014 	strb.w	sl, [sp, #20]
  s_sPLLHardwareSetup.eModPinDriveMode       = LMX249x_PIN_FCN_PULLUPDN_OUT;
  s_sPLLHardwareSetup.eMUXoutPinFunction     = LMX249x_MUX_OUT_READ_BACK;
  s_sPLLHardwareSetup.eMUXoutPinDriveMode    = LMX249x_PIN_FCN_PULLUPDN_OUT;
  s_sPLLHardwareSetup.eChargePumpPolarity    = LMX249x_CPPOL_NEGATIVE;
  s_sPLLHardwareSetup.uChargePumpCurrent     = 20;
 802a35a:	f88d 9019 	strb.w	r9, [sp, #25]
  s_sPLLHardwareSetup.uChargePumpCurrentFS   = 0;
  s_sPLLHardwareSetup.uChargePumpThresholdLo = 6;
 802a35e:	f88d 801b 	strb.w	r8, [sp, #27]
  s_sPLLHardwareSetup.uChargePumpThresholdHi = 42;
  s_sPLLHardwareSetup.eChargePumpPulseWidth  = LMX249x_CP_PULSE_860PS;
  s_sPLLHardwareSetup.eCycleSlipReduction    = LMX249x_CSR_DISABLED;
  s_sPLLHardwareSetup.uFastLockTimer         = 0;
  s_sPLLHardwareSetup.uLockDetectNumGoodEdge = 32;
  s_sPLLHardwareSetup.uLockDetectNumBadEdge  = 4;
 802a362:	f88d 5023 	strb.w	r5, [sp, #35]	; 0x23
  s_sPLLHardwareSetup.eLockDetectWindow      = LMX249x_DLD_TOL_10NS;
 802a366:	f88d 5024 	strb.w	r5, [sp, #36]	; 0x24
  lmx249x_spi_pins.spi_device = LMX_DEVICE;
  lmx249x_spi_pins.gpio_cs_pin 	 = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_PLL;
  lmx249x_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_DATA;
  lmx249x_spi_pins.gpio_clk_pin  = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;
  
  lmx249x_init(lmx249x_pll, &s_sPLLHardwareSetup, spi_transmit_data, (void*)&lmx249x_spi_pins);
 802a36a:	f000 fa87 	bl	802a87c <lmx249x_init>
  
  lmx249x_set_power_state(lmx249x_pll, LMX249x_POWER_CE);
 802a36e:	4638      	mov	r0, r7
 802a370:	4621      	mov	r1, r4
 802a372:	f000 fb51 	bl	802aa18 <lmx249x_set_power_state>
}
 802a376:	b00b      	add	sp, #44	; 0x2c
 802a378:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802a37c:	f3af 8000 	nop.w
 802a380:	00000000 	.word	0x00000000
 802a384:	40440000 	.word	0x40440000
 802a388:	08030d0c 	.word	0x08030d0c
 802a38c:	0802a6cd 	.word	0x0802a6cd
 802a390:	1fff2afc 	.word	0x1fff2afc
 802a394:	08030d70 	.word	0x08030d70
 802a398:	08030ca8 	.word	0x08030ca8
 802a39c:	f3af 8000 	nop.w

0802a3a0 <pll_configure_ramps>:

//============================================================================

void pll_configure_ramps(void* pll_handle)
{
 802a3a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802a3a4:	ed2d 8b04 	vpush	{d8-d9}
  
  Lmx249x_Ramp_Global_t pllGlobalRampSetup;
  
  Lmx249x_Ramp_Section_t pllRampSections[5];
  
  pllGlobalRampSetup.dBaseFrequency = (double)s_pll_base_freq_MHz; /*!< base frequency */
 802a3a8:	4b63      	ldr	r3, [pc, #396]	; (802a538 <pll_configure_ramps+0x198>)
  pllGlobalRampSetup.eDevTrigger = LMX249x_TRIGGER_A;				 /*!< Defines the deviation trigger for FSK operation */
  pllGlobalRampSetup.eDitherMode = LMX249x_FRAC_DITHER_DISABLED;                 /*!< Defines the fractional dithering */
  pllGlobalRampSetup.eFracOrder  = LMX249x_FRAC_ORD_SECOND;                      /*!< Defines the fractional order */
  
  /* Calculate real frequency shift based on PLL clock */
  double bandwidth_MHz = lmx249x_get_real_frequency_shift(lmx249x_pll, s_pll_bandwidth_MHz, s_pll_chirp_time_usec);
 802a3aa:	f8df 91a0 	ldr.w	r9, [pc, #416]	; 802a54c <pll_configure_ramps+0x1ac>
}

//============================================================================

void pll_configure_ramps(void* pll_handle)
{
 802a3ae:	b0bb      	sub	sp, #236	; 0xec
 802a3b0:	4680      	mov	r8, r0
  
  Lmx249x_Ramp_Global_t pllGlobalRampSetup;
  
  Lmx249x_Ramp_Section_t pllRampSections[5];
  
  pllGlobalRampSetup.dBaseFrequency = (double)s_pll_base_freq_MHz; /*!< base frequency */
 802a3b2:	6818      	ldr	r0, [r3, #0]
 802a3b4:	f003 fd54 	bl	802de60 <__aeabi_f2d>
  
  pllGlobalRampSetup.dMinFrequency  = (double)(s_pll_lower_freq_MHz - (float)PLL_RAMP_GUARD_FREQ_MHZ); /*!< Minimum frequency that can't be underrun by a ramp */
 802a3b8:	4b60      	ldr	r3, [pc, #384]	; (802a53c <pll_configure_ramps+0x19c>)
 802a3ba:	edd3 8a00 	vldr	s17, [r3]
 802a3be:	eeb6 9a00 	vmov.f32	s18, #96	; 0x60
 802a3c2:	ee78 7ac9 	vsub.f32	s15, s17, s18
  
  Lmx249x_Ramp_Global_t pllGlobalRampSetup;
  
  Lmx249x_Ramp_Section_t pllRampSections[5];
  
  pllGlobalRampSetup.dBaseFrequency = (double)s_pll_base_freq_MHz; /*!< base frequency */
 802a3c6:	e9cd 0102 	strd	r0, r1, [sp, #8]
  
  pllGlobalRampSetup.dMinFrequency  = (double)(s_pll_lower_freq_MHz - (float)PLL_RAMP_GUARD_FREQ_MHZ); /*!< Minimum frequency that can't be underrun by a ramp */
 802a3ca:	ee17 0a90 	vmov	r0, s15
 802a3ce:	f003 fd47 	bl	802de60 <__aeabi_f2d>
  pllGlobalRampSetup.dMaxFrequency  = (double)(s_pll_upper_freq_MHz + (float)PLL_RAMP_GUARD_FREQ_MHZ); /*!< Maximum frequency that can't be overrun by a ramp */
 802a3d2:	4b5b      	ldr	r3, [pc, #364]	; (802a540 <pll_configure_ramps+0x1a0>)
 802a3d4:	ed93 8a00 	vldr	s16, [r3]
 802a3d8:	ee78 7a09 	vadd.f32	s15, s16, s18
  
  Lmx249x_Ramp_Section_t pllRampSections[5];
  
  pllGlobalRampSetup.dBaseFrequency = (double)s_pll_base_freq_MHz; /*!< base frequency */
  
  pllGlobalRampSetup.dMinFrequency  = (double)(s_pll_lower_freq_MHz - (float)PLL_RAMP_GUARD_FREQ_MHZ); /*!< Minimum frequency that can't be underrun by a ramp */
 802a3dc:	e9cd 0106 	strd	r0, r1, [sp, #24]
  pllGlobalRampSetup.dMaxFrequency  = (double)(s_pll_upper_freq_MHz + (float)PLL_RAMP_GUARD_FREQ_MHZ); /*!< Maximum frequency that can't be overrun by a ramp */
 802a3e0:	ee17 0a90 	vmov	r0, s15
 802a3e4:	f003 fd3c 	bl	802de60 <__aeabi_f2d>
 802a3e8:	e9cd 0108 	strd	r0, r1, [sp, #32]
  pllGlobalRampSetup.dComp0Freq     = (double)s_pll_lower_freq_MHz; /*!< Frequency that is used by Comparator 0 to compare the ramp with. */
 802a3ec:	ee18 0a90 	vmov	r0, s17
 802a3f0:	f003 fd36 	bl	802de60 <__aeabi_f2d>
 802a3f4:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
  pllGlobalRampSetup.dComp1Freq     = (double)s_pll_upper_freq_MHz; /*!< Frequency that is used by Comparator 0 to compare the ramp with. */
 802a3f8:	ee18 0a10 	vmov	r0, s16
 802a3fc:	f003 fd30 	bl	802de60 <__aeabi_f2d>
  pllGlobalRampSetup.dDeviationFrequency = 0;  			    /*!< FSK deviation frequency */
  
  pllGlobalRampSetup.uNumRamps = s_pll_num_of_chirps * 4 + 1;	    /*!< Number of ramps to do before ramp is disabled (set to 0 for infinite number of ramps) */
 802a400:	4b50      	ldr	r3, [pc, #320]	; (802a544 <pll_configure_ramps+0x1a4>)
  pllGlobalRampSetup.eDevTrigger = LMX249x_TRIGGER_A;				 /*!< Defines the deviation trigger for FSK operation */
  pllGlobalRampSetup.eDitherMode = LMX249x_FRAC_DITHER_DISABLED;                 /*!< Defines the fractional dithering */
  pllGlobalRampSetup.eFracOrder  = LMX249x_FRAC_ORD_SECOND;                      /*!< Defines the fractional order */
  
  /* Calculate real frequency shift based on PLL clock */
  double bandwidth_MHz = lmx249x_get_real_frequency_shift(lmx249x_pll, s_pll_bandwidth_MHz, s_pll_chirp_time_usec);
 802a402:	4a51      	ldr	r2, [pc, #324]	; (802a548 <pll_configure_ramps+0x1a8>)
  pllGlobalRampSetup.dMaxFrequency  = (double)(s_pll_upper_freq_MHz + (float)PLL_RAMP_GUARD_FREQ_MHZ); /*!< Maximum frequency that can't be overrun by a ramp */
  pllGlobalRampSetup.dComp0Freq     = (double)s_pll_lower_freq_MHz; /*!< Frequency that is used by Comparator 0 to compare the ramp with. */
  pllGlobalRampSetup.dComp1Freq     = (double)s_pll_upper_freq_MHz; /*!< Frequency that is used by Comparator 0 to compare the ramp with. */
  pllGlobalRampSetup.dDeviationFrequency = 0;  			    /*!< FSK deviation frequency */
  
  pllGlobalRampSetup.uNumRamps = s_pll_num_of_chirps * 4 + 1;	    /*!< Number of ramps to do before ramp is disabled (set to 0 for infinite number of ramps) */
 802a404:	681b      	ldr	r3, [r3, #0]
 802a406:	009b      	lsls	r3, r3, #2
  
  pllGlobalRampSetup.eTriggerA   = LMX249x_RAMP_TRIG_NEVER_TRIGGERS;             /*!< Define the source for Trigger A */
 802a408:	2400      	movs	r4, #0
  
  pllGlobalRampSetup.dMinFrequency  = (double)(s_pll_lower_freq_MHz - (float)PLL_RAMP_GUARD_FREQ_MHZ); /*!< Minimum frequency that can't be underrun by a ramp */
  pllGlobalRampSetup.dMaxFrequency  = (double)(s_pll_upper_freq_MHz + (float)PLL_RAMP_GUARD_FREQ_MHZ); /*!< Maximum frequency that can't be overrun by a ramp */
  pllGlobalRampSetup.dComp0Freq     = (double)s_pll_lower_freq_MHz; /*!< Frequency that is used by Comparator 0 to compare the ramp with. */
  pllGlobalRampSetup.dComp1Freq     = (double)s_pll_upper_freq_MHz; /*!< Frequency that is used by Comparator 0 to compare the ramp with. */
  pllGlobalRampSetup.dDeviationFrequency = 0;  			    /*!< FSK deviation frequency */
 802a40a:	f04f 0a00 	mov.w	sl, #0
 802a40e:	f04f 0b00 	mov.w	fp, #0
  pllGlobalRampSetup.eTriggerA   = LMX249x_RAMP_TRIG_NEVER_TRIGGERS;             /*!< Define the source for Trigger A */
  pllGlobalRampSetup.eTriggerB   = LMX249x_RAMP_TRIG_TRIG2_TERMINAL_RISING_EDGE; /*!< Define the source for Trigger B */
  pllGlobalRampSetup.eTriggerC   = LMX249x_RAMP_TRIG_NEVER_TRIGGERS;             /*!< Define the source for Trigger C */
  pllGlobalRampSetup.eRampClock  = LMX249x_RAMP_CLOCK_INTERNAL;         	 /*!< determines if internal or external clock for ramp timing is used */
  pllGlobalRampSetup.eModulation = LMX249x_RAMP_MODULATION_FM;        		 /*!< Kind of modulation */
  pllGlobalRampSetup.eAutoOff    = LMX249x_RAMP_AUTO_OFF_ENABLE;           	 /*!< Defines, if the Ramp should be turned off after a certain amount of ramps */
 802a412:	2501      	movs	r5, #1
  pllGlobalRampSetup.dDeviationFrequency = 0;  			    /*!< FSK deviation frequency */
  
  pllGlobalRampSetup.uNumRamps = s_pll_num_of_chirps * 4 + 1;	    /*!< Number of ramps to do before ramp is disabled (set to 0 for infinite number of ramps) */
  
  pllGlobalRampSetup.eTriggerA   = LMX249x_RAMP_TRIG_NEVER_TRIGGERS;             /*!< Define the source for Trigger A */
  pllGlobalRampSetup.eTriggerB   = LMX249x_RAMP_TRIG_TRIG2_TERMINAL_RISING_EDGE; /*!< Define the source for Trigger B */
 802a414:	2602      	movs	r6, #2
  pllGlobalRampSetup.eRampClock  = LMX249x_RAMP_CLOCK_INTERNAL;         	 /*!< determines if internal or external clock for ramp timing is used */
  pllGlobalRampSetup.eModulation = LMX249x_RAMP_MODULATION_FM;        		 /*!< Kind of modulation */
  pllGlobalRampSetup.eAutoOff    = LMX249x_RAMP_AUTO_OFF_ENABLE;           	 /*!< Defines, if the Ramp should be turned off after a certain amount of ramps */
  pllGlobalRampSetup.eRampCountTrigger = LMX249x_RAMP_COUNT_INCREMENT_SEGMENT_TRANSITION; /*!< Defines the increment trigger for the ramp counter */
  pllGlobalRampSetup.eDevTrigger = LMX249x_TRIGGER_A;				 /*!< Defines the deviation trigger for FSK operation */
  pllGlobalRampSetup.eDitherMode = LMX249x_FRAC_DITHER_DISABLED;                 /*!< Defines the fractional dithering */
 802a416:	2703      	movs	r7, #3
  pllGlobalRampSetup.dBaseFrequency = (double)s_pll_base_freq_MHz; /*!< base frequency */
  
  pllGlobalRampSetup.dMinFrequency  = (double)(s_pll_lower_freq_MHz - (float)PLL_RAMP_GUARD_FREQ_MHZ); /*!< Minimum frequency that can't be underrun by a ramp */
  pllGlobalRampSetup.dMaxFrequency  = (double)(s_pll_upper_freq_MHz + (float)PLL_RAMP_GUARD_FREQ_MHZ); /*!< Maximum frequency that can't be overrun by a ramp */
  pllGlobalRampSetup.dComp0Freq     = (double)s_pll_lower_freq_MHz; /*!< Frequency that is used by Comparator 0 to compare the ramp with. */
  pllGlobalRampSetup.dComp1Freq     = (double)s_pll_upper_freq_MHz; /*!< Frequency that is used by Comparator 0 to compare the ramp with. */
 802a418:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
  pllGlobalRampSetup.dDeviationFrequency = 0;  			    /*!< FSK deviation frequency */
  
  pllGlobalRampSetup.uNumRamps = s_pll_num_of_chirps * 4 + 1;	    /*!< Number of ramps to do before ramp is disabled (set to 0 for infinite number of ramps) */
 802a41c:	3301      	adds	r3, #1
  pllGlobalRampSetup.eDevTrigger = LMX249x_TRIGGER_A;				 /*!< Defines the deviation trigger for FSK operation */
  pllGlobalRampSetup.eDitherMode = LMX249x_FRAC_DITHER_DISABLED;                 /*!< Defines the fractional dithering */
  pllGlobalRampSetup.eFracOrder  = LMX249x_FRAC_ORD_SECOND;                      /*!< Defines the fractional order */
  
  /* Calculate real frequency shift based on PLL clock */
  double bandwidth_MHz = lmx249x_get_real_frequency_shift(lmx249x_pll, s_pll_bandwidth_MHz, s_pll_chirp_time_usec);
 802a41e:	6810      	ldr	r0, [r2, #0]
  pllGlobalRampSetup.dMaxFrequency  = (double)(s_pll_upper_freq_MHz + (float)PLL_RAMP_GUARD_FREQ_MHZ); /*!< Maximum frequency that can't be overrun by a ramp */
  pllGlobalRampSetup.dComp0Freq     = (double)s_pll_lower_freq_MHz; /*!< Frequency that is used by Comparator 0 to compare the ramp with. */
  pllGlobalRampSetup.dComp1Freq     = (double)s_pll_upper_freq_MHz; /*!< Frequency that is used by Comparator 0 to compare the ramp with. */
  pllGlobalRampSetup.dDeviationFrequency = 0;  			    /*!< FSK deviation frequency */
  
  pllGlobalRampSetup.uNumRamps = s_pll_num_of_chirps * 4 + 1;	    /*!< Number of ramps to do before ramp is disabled (set to 0 for infinite number of ramps) */
 802a420:	f8ad 303e 	strh.w	r3, [sp, #62]	; 0x3e
  
  pllGlobalRampSetup.eTriggerA   = LMX249x_RAMP_TRIG_NEVER_TRIGGERS;             /*!< Define the source for Trigger A */
  pllGlobalRampSetup.eTriggerB   = LMX249x_RAMP_TRIG_TRIG2_TERMINAL_RISING_EDGE; /*!< Define the source for Trigger B */
 802a424:	f88d 6039 	strb.w	r6, [sp, #57]	; 0x39
  pllGlobalRampSetup.eModulation = LMX249x_RAMP_MODULATION_FM;        		 /*!< Kind of modulation */
  pllGlobalRampSetup.eAutoOff    = LMX249x_RAMP_AUTO_OFF_ENABLE;           	 /*!< Defines, if the Ramp should be turned off after a certain amount of ramps */
  pllGlobalRampSetup.eRampCountTrigger = LMX249x_RAMP_COUNT_INCREMENT_SEGMENT_TRANSITION; /*!< Defines the increment trigger for the ramp counter */
  pllGlobalRampSetup.eDevTrigger = LMX249x_TRIGGER_A;				 /*!< Defines the deviation trigger for FSK operation */
  pllGlobalRampSetup.eDitherMode = LMX249x_FRAC_DITHER_DISABLED;                 /*!< Defines the fractional dithering */
  pllGlobalRampSetup.eFracOrder  = LMX249x_FRAC_ORD_SECOND;                      /*!< Defines the fractional order */
 802a428:	f88d 6042 	strb.w	r6, [sp, #66]	; 0x42
  
  pllGlobalRampSetup.dMinFrequency  = (double)(s_pll_lower_freq_MHz - (float)PLL_RAMP_GUARD_FREQ_MHZ); /*!< Minimum frequency that can't be underrun by a ramp */
  pllGlobalRampSetup.dMaxFrequency  = (double)(s_pll_upper_freq_MHz + (float)PLL_RAMP_GUARD_FREQ_MHZ); /*!< Maximum frequency that can't be overrun by a ramp */
  pllGlobalRampSetup.dComp0Freq     = (double)s_pll_lower_freq_MHz; /*!< Frequency that is used by Comparator 0 to compare the ramp with. */
  pllGlobalRampSetup.dComp1Freq     = (double)s_pll_upper_freq_MHz; /*!< Frequency that is used by Comparator 0 to compare the ramp with. */
  pllGlobalRampSetup.dDeviationFrequency = 0;  			    /*!< FSK deviation frequency */
 802a42c:	e9cd ab04 	strd	sl, fp, [sp, #16]
  
  pllGlobalRampSetup.uNumRamps = s_pll_num_of_chirps * 4 + 1;	    /*!< Number of ramps to do before ramp is disabled (set to 0 for infinite number of ramps) */
  
  pllGlobalRampSetup.eTriggerA   = LMX249x_RAMP_TRIG_NEVER_TRIGGERS;             /*!< Define the source for Trigger A */
 802a430:	f88d 4038 	strb.w	r4, [sp, #56]	; 0x38
  pllGlobalRampSetup.eTriggerB   = LMX249x_RAMP_TRIG_TRIG2_TERMINAL_RISING_EDGE; /*!< Define the source for Trigger B */
  pllGlobalRampSetup.eTriggerC   = LMX249x_RAMP_TRIG_NEVER_TRIGGERS;             /*!< Define the source for Trigger C */
 802a434:	f88d 403a 	strb.w	r4, [sp, #58]	; 0x3a
  pllGlobalRampSetup.eRampClock  = LMX249x_RAMP_CLOCK_INTERNAL;         	 /*!< determines if internal or external clock for ramp timing is used */
 802a438:	f88d 403b 	strb.w	r4, [sp, #59]	; 0x3b
  pllGlobalRampSetup.eModulation = LMX249x_RAMP_MODULATION_FM;        		 /*!< Kind of modulation */
 802a43c:	f88d 403c 	strb.w	r4, [sp, #60]	; 0x3c
  pllGlobalRampSetup.eAutoOff    = LMX249x_RAMP_AUTO_OFF_ENABLE;           	 /*!< Defines, if the Ramp should be turned off after a certain amount of ramps */
  pllGlobalRampSetup.eRampCountTrigger = LMX249x_RAMP_COUNT_INCREMENT_SEGMENT_TRANSITION; /*!< Defines the increment trigger for the ramp counter */
 802a440:	f88d 4040 	strb.w	r4, [sp, #64]	; 0x40
  pllGlobalRampSetup.eTriggerA   = LMX249x_RAMP_TRIG_NEVER_TRIGGERS;             /*!< Define the source for Trigger A */
  pllGlobalRampSetup.eTriggerB   = LMX249x_RAMP_TRIG_TRIG2_TERMINAL_RISING_EDGE; /*!< Define the source for Trigger B */
  pllGlobalRampSetup.eTriggerC   = LMX249x_RAMP_TRIG_NEVER_TRIGGERS;             /*!< Define the source for Trigger C */
  pllGlobalRampSetup.eRampClock  = LMX249x_RAMP_CLOCK_INTERNAL;         	 /*!< determines if internal or external clock for ramp timing is used */
  pllGlobalRampSetup.eModulation = LMX249x_RAMP_MODULATION_FM;        		 /*!< Kind of modulation */
  pllGlobalRampSetup.eAutoOff    = LMX249x_RAMP_AUTO_OFF_ENABLE;           	 /*!< Defines, if the Ramp should be turned off after a certain amount of ramps */
 802a444:	f88d 503d 	strb.w	r5, [sp, #61]	; 0x3d
  pllGlobalRampSetup.eRampCountTrigger = LMX249x_RAMP_COUNT_INCREMENT_SEGMENT_TRANSITION; /*!< Defines the increment trigger for the ramp counter */
  pllGlobalRampSetup.eDevTrigger = LMX249x_TRIGGER_A;				 /*!< Defines the deviation trigger for FSK operation */
 802a448:	f88d 5041 	strb.w	r5, [sp, #65]	; 0x41
  pllGlobalRampSetup.eDitherMode = LMX249x_FRAC_DITHER_DISABLED;                 /*!< Defines the fractional dithering */
 802a44c:	f88d 7043 	strb.w	r7, [sp, #67]	; 0x43
  pllGlobalRampSetup.eFracOrder  = LMX249x_FRAC_ORD_SECOND;                      /*!< Defines the fractional order */
  
  /* Calculate real frequency shift based on PLL clock */
  double bandwidth_MHz = lmx249x_get_real_frequency_shift(lmx249x_pll, s_pll_bandwidth_MHz, s_pll_chirp_time_usec);
 802a450:	f003 fd06 	bl	802de60 <__aeabi_f2d>
 802a454:	460b      	mov	r3, r1
 802a456:	f8d9 1000 	ldr.w	r1, [r9]
 802a45a:	9100      	str	r1, [sp, #0]
 802a45c:	4602      	mov	r2, r0
 802a45e:	4640      	mov	r0, r8
 802a460:	f000 fd88 	bl	802af74 <lmx249x_get_real_frequency_shift>
  pllRampSections[0].eComparators = LMX249x_RAMP_NO_COMPARATOR;
  
  /* Ramp down to lower frequency */
  pllRampSections[1].dFreqShift   = -bandwidth_MHz;
  pllRampSections[1].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
  pllRampSections[1].dTramp       = (double)PLL_RAMP_DOWM_TIME_USEC;
 802a464:	ed9f 7b32 	vldr	d7, [pc, #200]	; 802a530 <pll_configure_ramps+0x190>
  pllGlobalRampSetup.eDevTrigger = LMX249x_TRIGGER_A;				 /*!< Defines the deviation trigger for FSK operation */
  pllGlobalRampSetup.eDitherMode = LMX249x_FRAC_DITHER_DISABLED;                 /*!< Defines the fractional dithering */
  pllGlobalRampSetup.eFracOrder  = LMX249x_FRAC_ORD_SECOND;                      /*!< Defines the fractional order */
  
  /* Calculate real frequency shift based on PLL clock */
  double bandwidth_MHz = lmx249x_get_real_frequency_shift(lmx249x_pll, s_pll_bandwidth_MHz, s_pll_chirp_time_usec);
 802a468:	4602      	mov	r2, r0
 802a46a:	460b      	mov	r3, r1
  pllRampSections[2].eComparators = LMX249x_RAMP_NO_COMPARATOR;
  
  /* Ramp up and trigger ADC sampling */
  pllRampSections[3].dFreqShift   = bandwidth_MHz;
  pllRampSections[3].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
  pllRampSections[3].dTramp       = (double)s_pll_chirp_time_usec;
 802a46c:	f8d9 0000 	ldr.w	r0, [r9]
  pllRampSections[0].dFreqShift   = 0.0;
  pllRampSections[0].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
  pllRampSections[0].dTramp       = 0;
  pllRampSections[0].eFlag        = LMX249x_RAMP_FLAG_CLR_BOTH;
  pllRampSections[0].eReset       = LMX249x_RAMP_RST_ENABLE;
  pllRampSections[0].eNextTrig    = LMX249x_RAMP_NEXT_TRIG_TRIGB;
 802a470:	f88d 6062 	strb.w	r6, [sp, #98]	; 0x62
  pllRampSections[0].uNext        = 1;
  pllRampSections[0].eComparators = LMX249x_RAMP_NO_COMPARATOR;
  
  /* Ramp down to lower frequency */
  pllRampSections[1].dFreqShift   = -bandwidth_MHz;
 802a474:	f101 4100 	add.w	r1, r1, #2147483648	; 0x80000000
  pllRampSections[2].eNextTrig    = LMX249x_RAMP_NEXT_TRIG_RAMPX_LEN;
  pllRampSections[2].uNext        = 3;
  pllRampSections[2].eComparators = LMX249x_RAMP_NO_COMPARATOR;
  
  /* Ramp up and trigger ADC sampling */
  pllRampSections[3].dFreqShift   = bandwidth_MHz;
 802a478:	e9cd 232a 	strd	r2, r3, [sp, #168]	; 0xa8
  pllRampSections[1].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
  pllRampSections[1].dTramp       = (double)PLL_RAMP_DOWM_TIME_USEC;
  pllRampSections[1].eFlag        = LMX249x_RAMP_FLAG_CLR_BOTH;
  pllRampSections[1].eReset       = LMX249x_RAMP_RST_DISABLE; /* first ramp resets counters */
  pllRampSections[1].eNextTrig    = LMX249x_RAMP_NEXT_TRIG_RAMPX_LEN;
  pllRampSections[1].uNext        = 2;
 802a47c:	f88d 6083 	strb.w	r6, [sp, #131]	; 0x83
  pllRampSections[0].eNextTrig    = LMX249x_RAMP_NEXT_TRIG_TRIGB;
  pllRampSections[0].uNext        = 1;
  pllRampSections[0].eComparators = LMX249x_RAMP_NO_COMPARATOR;
  
  /* Ramp down to lower frequency */
  pllRampSections[1].dFreqShift   = -bandwidth_MHz;
 802a480:	921a      	str	r2, [sp, #104]	; 0x68
  pllRampSections[1].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
  pllRampSections[1].dTramp       = (double)PLL_RAMP_DOWM_TIME_USEC;
 802a482:	ed8d 7b1e 	vstr	d7, [sp, #120]	; 0x78
  pllRampSections[1].eComparators = LMX249x_RAMP_NO_COMPARATOR;
  
  /* Wait time between ramps */
  pllRampSections[2].dFreqShift   = 0;
  pllRampSections[2].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
  pllRampSections[2].dTramp       = (double)PLL_STEADY_STATE_USEC;
 802a486:	ed8d 7b26 	vstr	d7, [sp, #152]	; 0x98
  /* Calculate real frequency shift based on PLL clock */
  double bandwidth_MHz = lmx249x_get_real_frequency_shift(lmx249x_pll, s_pll_bandwidth_MHz, s_pll_chirp_time_usec);
  
  /* reset ramp  */
  pllRampSections[0].dFreqShift   = 0.0;
  pllRampSections[0].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
 802a48a:	f88d 4050 	strb.w	r4, [sp, #80]	; 0x50
  
  /* Calculate real frequency shift based on PLL clock */
  double bandwidth_MHz = lmx249x_get_real_frequency_shift(lmx249x_pll, s_pll_bandwidth_MHz, s_pll_chirp_time_usec);
  
  /* reset ramp  */
  pllRampSections[0].dFreqShift   = 0.0;
 802a48e:	e9cd ab12 	strd	sl, fp, [sp, #72]	; 0x48
  pllRampSections[0].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
  pllRampSections[0].dTramp       = 0;
 802a492:	e9cd ab16 	strd	sl, fp, [sp, #88]	; 0x58
  pllRampSections[0].eFlag        = LMX249x_RAMP_FLAG_CLR_BOTH;
 802a496:	f88d 4060 	strb.w	r4, [sp, #96]	; 0x60
  pllRampSections[0].eReset       = LMX249x_RAMP_RST_ENABLE;
 802a49a:	f88d 5061 	strb.w	r5, [sp, #97]	; 0x61
  pllRampSections[0].eNextTrig    = LMX249x_RAMP_NEXT_TRIG_TRIGB;
  pllRampSections[0].uNext        = 1;
 802a49e:	f88d 5063 	strb.w	r5, [sp, #99]	; 0x63
  pllRampSections[0].eComparators = LMX249x_RAMP_NO_COMPARATOR;
 802a4a2:	f88d 4064 	strb.w	r4, [sp, #100]	; 0x64
  
  /* Ramp down to lower frequency */
  pllRampSections[1].dFreqShift   = -bandwidth_MHz;
  pllRampSections[1].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
 802a4a6:	f88d 4070 	strb.w	r4, [sp, #112]	; 0x70
  pllRampSections[1].dTramp       = (double)PLL_RAMP_DOWM_TIME_USEC;
  pllRampSections[1].eFlag        = LMX249x_RAMP_FLAG_CLR_BOTH;
 802a4aa:	f88d 4080 	strb.w	r4, [sp, #128]	; 0x80
  pllRampSections[1].eReset       = LMX249x_RAMP_RST_DISABLE; /* first ramp resets counters */
 802a4ae:	f88d 4081 	strb.w	r4, [sp, #129]	; 0x81
  pllRampSections[1].eNextTrig    = LMX249x_RAMP_NEXT_TRIG_RAMPX_LEN;
 802a4b2:	f88d 4082 	strb.w	r4, [sp, #130]	; 0x82
  pllRampSections[1].uNext        = 2;
  pllRampSections[1].eComparators = LMX249x_RAMP_NO_COMPARATOR;
 802a4b6:	f88d 4084 	strb.w	r4, [sp, #132]	; 0x84
  
  /* Wait time between ramps */
  pllRampSections[2].dFreqShift   = 0;
 802a4ba:	e9cd ab22 	strd	sl, fp, [sp, #136]	; 0x88
  pllRampSections[2].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
 802a4be:	f88d 4090 	strb.w	r4, [sp, #144]	; 0x90
  pllRampSections[2].dTramp       = (double)PLL_STEADY_STATE_USEC;
  pllRampSections[2].eFlag        = LMX249x_RAMP_FLAG_CLR_BOTH;
 802a4c2:	f88d 40a0 	strb.w	r4, [sp, #160]	; 0xa0
  pllRampSections[2].eReset       = LMX249x_RAMP_RST_DISABLE;
 802a4c6:	f88d 40a1 	strb.w	r4, [sp, #161]	; 0xa1
  pllRampSections[2].eNextTrig    = LMX249x_RAMP_NEXT_TRIG_RAMPX_LEN;
 802a4ca:	f88d 40a2 	strb.w	r4, [sp, #162]	; 0xa2
  pllRampSections[2].uNext        = 3;
 802a4ce:	f88d 70a3 	strb.w	r7, [sp, #163]	; 0xa3
  pllRampSections[2].eComparators = LMX249x_RAMP_NO_COMPARATOR;
 802a4d2:	f88d 40a4 	strb.w	r4, [sp, #164]	; 0xa4
  
  /* Ramp up and trigger ADC sampling */
  pllRampSections[3].dFreqShift   = bandwidth_MHz;
  pllRampSections[3].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
 802a4d6:	f88d 40b0 	strb.w	r4, [sp, #176]	; 0xb0
  pllRampSections[0].eNextTrig    = LMX249x_RAMP_NEXT_TRIG_TRIGB;
  pllRampSections[0].uNext        = 1;
  pllRampSections[0].eComparators = LMX249x_RAMP_NO_COMPARATOR;
  
  /* Ramp down to lower frequency */
  pllRampSections[1].dFreqShift   = -bandwidth_MHz;
 802a4da:	911b      	str	r1, [sp, #108]	; 0x6c
  pllRampSections[2].eComparators = LMX249x_RAMP_NO_COMPARATOR;
  
  /* Ramp up and trigger ADC sampling */
  pllRampSections[3].dFreqShift   = bandwidth_MHz;
  pllRampSections[3].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
  pllRampSections[3].dTramp       = (double)s_pll_chirp_time_usec;
 802a4dc:	f003 fc9e 	bl	802de1c <__aeabi_ui2d>
  pllRampSections[3].eFlag        = LMX249x_RAMP_FLAG_SET_BOTH;
  pllRampSections[3].eReset       = LMX249x_RAMP_RST_DISABLE;
  pllRampSections[3].eNextTrig    = LMX249x_RAMP_NEXT_TRIG_RAMPX_LEN;
  pllRampSections[3].uNext        = 4;
 802a4e0:	2604      	movs	r6, #4
  pllRampSections[2].eComparators = LMX249x_RAMP_NO_COMPARATOR;
  
  /* Ramp up and trigger ADC sampling */
  pllRampSections[3].dFreqShift   = bandwidth_MHz;
  pllRampSections[3].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
  pllRampSections[3].dTramp       = (double)s_pll_chirp_time_usec;
 802a4e2:	e9cd 012e 	strd	r0, r1, [sp, #184]	; 0xb8
  pllRampSections[4].eReset       = LMX249x_RAMP_RST_ENABLE;
  pllRampSections[4].eNextTrig    = LMX249x_RAMP_NEXT_TRIG_RAMPX_LEN;
  pllRampSections[4].uNext        = 1;
  pllRampSections[4].eComparators = LMX249x_RAMP_NO_COMPARATOR;
  
  lmx249x_configure_ramps(lmx249x_pll, &pllGlobalRampSetup, pllRampSections, 5);
 802a4e6:	aa12      	add	r2, sp, #72	; 0x48
 802a4e8:	4640      	mov	r0, r8
 802a4ea:	a902      	add	r1, sp, #8
 802a4ec:	2305      	movs	r3, #5
  
  /* Ramp up and trigger ADC sampling */
  pllRampSections[3].dFreqShift   = bandwidth_MHz;
  pllRampSections[3].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
  pllRampSections[3].dTramp       = (double)s_pll_chirp_time_usec;
  pllRampSections[3].eFlag        = LMX249x_RAMP_FLAG_SET_BOTH;
 802a4ee:	f88d 70c0 	strb.w	r7, [sp, #192]	; 0xc0
  pllRampSections[3].eReset       = LMX249x_RAMP_RST_DISABLE;
 802a4f2:	f88d 40c1 	strb.w	r4, [sp, #193]	; 0xc1
  pllRampSections[3].eNextTrig    = LMX249x_RAMP_NEXT_TRIG_RAMPX_LEN;
 802a4f6:	f88d 40c2 	strb.w	r4, [sp, #194]	; 0xc2
  pllRampSections[3].uNext        = 4;
  pllRampSections[3].eComparators = LMX249x_RAMP_NO_COMPARATOR;
 802a4fa:	f88d 40c4 	strb.w	r4, [sp, #196]	; 0xc4
  
  /* Clear ADC sampling flags */
  pllRampSections[4].dFreqShift   = 0;
 802a4fe:	e9cd ab32 	strd	sl, fp, [sp, #200]	; 0xc8
  pllRampSections[4].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
 802a502:	f88d 40d0 	strb.w	r4, [sp, #208]	; 0xd0
  pllRampSections[4].dTramp       = 0;
 802a506:	e9cd ab36 	strd	sl, fp, [sp, #216]	; 0xd8
  pllRampSections[4].eFlag        = LMX249x_RAMP_FLAG_CLR_BOTH;
 802a50a:	f88d 40e0 	strb.w	r4, [sp, #224]	; 0xe0
  pllRampSections[4].eReset       = LMX249x_RAMP_RST_ENABLE;
 802a50e:	f88d 50e1 	strb.w	r5, [sp, #225]	; 0xe1
  pllRampSections[4].eNextTrig    = LMX249x_RAMP_NEXT_TRIG_RAMPX_LEN;
 802a512:	f88d 40e2 	strb.w	r4, [sp, #226]	; 0xe2
  pllRampSections[4].uNext        = 1;
 802a516:	f88d 50e3 	strb.w	r5, [sp, #227]	; 0xe3
  pllRampSections[4].eComparators = LMX249x_RAMP_NO_COMPARATOR;
 802a51a:	f88d 40e4 	strb.w	r4, [sp, #228]	; 0xe4
  pllRampSections[3].eFastlock    = LMX249x_RAMP_FASTLOCK_DISABLED;
  pllRampSections[3].dTramp       = (double)s_pll_chirp_time_usec;
  pllRampSections[3].eFlag        = LMX249x_RAMP_FLAG_SET_BOTH;
  pllRampSections[3].eReset       = LMX249x_RAMP_RST_DISABLE;
  pllRampSections[3].eNextTrig    = LMX249x_RAMP_NEXT_TRIG_RAMPX_LEN;
  pllRampSections[3].uNext        = 4;
 802a51e:	f88d 60c3 	strb.w	r6, [sp, #195]	; 0xc3
  pllRampSections[4].eReset       = LMX249x_RAMP_RST_ENABLE;
  pllRampSections[4].eNextTrig    = LMX249x_RAMP_NEXT_TRIG_RAMPX_LEN;
  pllRampSections[4].uNext        = 1;
  pllRampSections[4].eComparators = LMX249x_RAMP_NO_COMPARATOR;
  
  lmx249x_configure_ramps(lmx249x_pll, &pllGlobalRampSetup, pllRampSections, 5);
 802a522:	f000 faf3 	bl	802ab0c <lmx249x_configure_ramps>
}
 802a526:	b03b      	add	sp, #236	; 0xec
 802a528:	ecbd 8b04 	vpop	{d8-d9}
 802a52c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802a530:	00000000 	.word	0x00000000
 802a534:	40590000 	.word	0x40590000
 802a538:	1fff2b0c 	.word	0x1fff2b0c
 802a53c:	1fff2af4 	.word	0x1fff2af4
 802a540:	1fff2af0 	.word	0x1fff2af0
 802a544:	1fff2af8 	.word	0x1fff2af8
 802a548:	1ffe900c 	.word	0x1ffe900c
 802a54c:	1ffe9008 	.word	0x1ffe9008

0802a550 <pll_enable_ramps>:
//============================================================================

void pll_enable_ramps(void* pll_handle)
{
  Lmx249x_Object_t* lmx249x_pll = (Lmx249x_Object_t*)pll_handle;
  lmx249x_enable_ramps(lmx249x_pll, true);
 802a550:	2101      	movs	r1, #1
 802a552:	f000 bcf7 	b.w	802af44 <lmx249x_enable_ramps>
 802a556:	bf00      	nop

0802a558 <pll_disable_ramps>:
//============================================================================

void pll_disable_ramps(void* pll_handle)
{
  Lmx249x_Object_t* lmx249x_pll = (Lmx249x_Object_t*)pll_handle;
  lmx249x_enable_ramps(lmx249x_pll, false);
 802a558:	2100      	movs	r1, #0
 802a55a:	f000 bcf3 	b.w	802af44 <lmx249x_enable_ramps>
 802a55e:	bf00      	nop

0802a560 <pll_trigger_ramp>:
//============================================================================

void pll_trigger_ramp(void)
{
  /* Start ramps generation */
  lmx249x_trigger_ramp();
 802a560:	f000 bd4e 	b.w	802b000 <lmx249x_trigger_ramp>

0802a564 <pll_release_ramp_trigger>:
//============================================================================

void pll_release_ramp_trigger(void)
{
  /* Bring PLL trigger to down state */
  lmx249x_release_ramp_trigger();
 802a564:	f000 bd60 	b.w	802b028 <lmx249x_release_ramp_trigger>

0802a568 <pll_power_up>:
//============================================================================

void pll_power_up(void)
{
  /* PLL power-up */
  lmx249x_power_up();
 802a568:	f000 bd68 	b.w	802b03c <lmx249x_power_up>

0802a56c <pll_power_down>:
//============================================================================

void pll_power_down(void)
{
  /* PLL power-down */
  lmx249x_power_down();
 802a56c:	f000 bd70 	b.w	802b050 <lmx249x_power_down>

0802a570 <pll_update_configuration>:
}

//============================================================================

void pll_update_configuration(void* pll_handle, uint8_t modulation_type)
{
 802a570:	b530      	push	{r4, r5, lr}
 802a572:	460c      	mov	r4, r1
 802a574:	b083      	sub	sp, #12
 802a576:	4605      	mov	r5, r0
  Lmx249x_Object_t* lmx249x_pll = (Lmx249x_Object_t*)pll_handle;
  
  pll_configure_ramps(lmx249x_pll);
 802a578:	f7ff ff12 	bl	802a3a0 <pll_configure_ramps>
  
  if (modulation_type == 1) /* FMCW modulation */
 802a57c:	2c01      	cmp	r4, #1
 802a57e:	d011      	beq.n	802a5a4 <pll_update_configuration+0x34>
  {
    lmx249x_enable_ramps(lmx249x_pll, true);
  }
  else
  {
    lmx249x_set_frequency(lmx249x_pll, s_pll_base_freq_MHz, LMX249x_FRAC_ORD_THIRD, LMX249x_FRAC_DITHER_WEAK);
 802a580:	4b0b      	ldr	r3, [pc, #44]	; (802a5b0 <pll_update_configuration+0x40>)
 802a582:	6818      	ldr	r0, [r3, #0]
 802a584:	f003 fc6c 	bl	802de60 <__aeabi_f2d>
 802a588:	2403      	movs	r4, #3
 802a58a:	460b      	mov	r3, r1
 802a58c:	2100      	movs	r1, #0
 802a58e:	4602      	mov	r2, r0
 802a590:	9400      	str	r4, [sp, #0]
 802a592:	4628      	mov	r0, r5
 802a594:	9101      	str	r1, [sp, #4]
 802a596:	f000 fa51 	bl	802aa3c <lmx249x_set_frequency>
  }
  
  s_update_pll_config_flag = false;
 802a59a:	4b06      	ldr	r3, [pc, #24]	; (802a5b4 <pll_update_configuration+0x44>)
 802a59c:	2200      	movs	r2, #0
 802a59e:	701a      	strb	r2, [r3, #0]
}
 802a5a0:	b003      	add	sp, #12
 802a5a2:	bd30      	pop	{r4, r5, pc}
  
  pll_configure_ramps(lmx249x_pll);
  
  if (modulation_type == 1) /* FMCW modulation */
  {
    lmx249x_enable_ramps(lmx249x_pll, true);
 802a5a4:	4628      	mov	r0, r5
 802a5a6:	4621      	mov	r1, r4
 802a5a8:	f000 fccc 	bl	802af44 <lmx249x_enable_ramps>
 802a5ac:	e7f5      	b.n	802a59a <pll_update_configuration+0x2a>
 802a5ae:	bf00      	nop
 802a5b0:	1fff2b0c 	.word	0x1fff2b0c
 802a5b4:	1fff2aec 	.word	0x1fff2aec

0802a5b8 <pll_set_update_config_flag>:

void pll_set_update_config_flag(uint8_t flag)
{
  if (flag == 0)
  {
    s_update_pll_config_flag = false;
 802a5b8:	4b03      	ldr	r3, [pc, #12]	; (802a5c8 <pll_set_update_config_flag+0x10>)

//============================================================================

void pll_set_update_config_flag(uint8_t flag)
{
  if (flag == 0)
 802a5ba:	b110      	cbz	r0, 802a5c2 <pll_set_update_config_flag+0xa>
  {
    s_update_pll_config_flag = false;
  }
  else
  {
    s_update_pll_config_flag = true;
 802a5bc:	2201      	movs	r2, #1
 802a5be:	701a      	strb	r2, [r3, #0]
 802a5c0:	4770      	bx	lr

void pll_set_update_config_flag(uint8_t flag)
{
  if (flag == 0)
  {
    s_update_pll_config_flag = false;
 802a5c2:	7018      	strb	r0, [r3, #0]
 802a5c4:	4770      	bx	lr
 802a5c6:	bf00      	nop
 802a5c8:	1fff2aec 	.word	0x1fff2aec

0802a5cc <pll_get_update_config_flag>:

//============================================================================

uint8_t pll_get_update_config_flag(void)
{
  return (s_update_pll_config_flag);
 802a5cc:	4b01      	ldr	r3, [pc, #4]	; (802a5d4 <pll_get_update_config_flag+0x8>)
 802a5ce:	7818      	ldrb	r0, [r3, #0]
}
 802a5d0:	4770      	bx	lr
 802a5d2:	bf00      	nop
 802a5d4:	1fff2aec 	.word	0x1fff2aec

0802a5d8 <pll_set_frequency>:

//============================================================================

void pll_set_frequency(double freq_MHz)
{
 802a5d8:	b538      	push	{r3, r4, r5, lr}
	/* This check ensures, that the RF Frequency is not set out-side of the 24GHz- ISM band,
	 * do not circumvent it would understanding the consequences. Emitting outside ISM band is forbidden.
	 */

	if( freq_MHz < (double) ISM_MIN_RF_FREQUENCY_KHZ / 1000.0 )
 802a5da:	a312      	add	r3, pc, #72	; (adr r3, 802a624 <pll_set_frequency+0x4c>)
 802a5dc:	e9d3 2300 	ldrd	r2, r3, [r3]
}

//============================================================================

void pll_set_frequency(double freq_MHz)
{
 802a5e0:	4604      	mov	r4, r0
 802a5e2:	460d      	mov	r5, r1
	/* This check ensures, that the RF Frequency is not set out-side of the 24GHz- ISM band,
	 * do not circumvent it would understanding the consequences. Emitting outside ISM band is forbidden.
	 */

	if( freq_MHz < (double) ISM_MIN_RF_FREQUENCY_KHZ / 1000.0 )
 802a5e4:	f003 ff02 	bl	802e3ec <__aeabi_dcmplt>
 802a5e8:	b990      	cbnz	r0, 802a610 <pll_set_frequency+0x38>
		freq_MHz = (double) ISM_MIN_RF_FREQUENCY_KHZ / 1000.0;

	else if( freq_MHz > (double) ISM_MAX_RF_FREQUENCY_KHZ / 1000.0 )
 802a5ea:	4620      	mov	r0, r4
 802a5ec:	4629      	mov	r1, r5
 802a5ee:	a30f      	add	r3, pc, #60	; (adr r3, 802a62c <pll_set_frequency+0x54>)
 802a5f0:	e9d3 2300 	ldrd	r2, r3, [r3]
 802a5f4:	f003 ff18 	bl	802e428 <__aeabi_dcmpgt>
 802a5f8:	b118      	cbz	r0, 802a602 <pll_set_frequency+0x2a>
		freq_MHz = (double) ISM_MAX_RF_FREQUENCY_KHZ / 1000.0;

	s_pll_base_freq_MHz = freq_MHz;
 802a5fa:	4b07      	ldr	r3, [pc, #28]	; (802a618 <pll_set_frequency+0x40>)
 802a5fc:	4807      	ldr	r0, [pc, #28]	; (802a61c <pll_set_frequency+0x44>)
 802a5fe:	6018      	str	r0, [r3, #0]
 802a600:	bd38      	pop	{r3, r4, r5, pc}
 802a602:	4620      	mov	r0, r4
 802a604:	4629      	mov	r1, r5
 802a606:	f003 ff61 	bl	802e4cc <__aeabi_d2f>
 802a60a:	4b03      	ldr	r3, [pc, #12]	; (802a618 <pll_set_frequency+0x40>)
 802a60c:	6018      	str	r0, [r3, #0]
 802a60e:	bd38      	pop	{r3, r4, r5, pc}
 802a610:	4b01      	ldr	r3, [pc, #4]	; (802a618 <pll_set_frequency+0x40>)
 802a612:	4803      	ldr	r0, [pc, #12]	; (802a620 <pll_set_frequency+0x48>)
 802a614:	6018      	str	r0, [r3, #0]
 802a616:	bd38      	pop	{r3, r4, r5, pc}
 802a618:	1fff2b0c 	.word	0x1fff2b0c
 802a61c:	46bd4200 	.word	0x46bd4200
 802a620:	46bbb200 	.word	0x46bbb200
 802a624:	00000000 	.word	0x00000000
 802a628:	40d77640 	.word	0x40d77640
 802a62c:	00000000 	.word	0x00000000
 802a630:	40d7a840 	.word	0x40d7a840
 802a634:	f3af 8000 	nop.w

0802a638 <pll_set_upper_lower_frequency>:
}

//============================================================================

void pll_set_upper_lower_frequency(double lower_freq_MHz, double upper_freq_MHz)
{
 802a638:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802a63a:	4614      	mov	r4, r2
 802a63c:	461d      	mov	r5, r3
	/* This check ensures, that the RF Frequency is not set out-side of the 24GHz- ISM band,
	 * do not circumvent it would understanding the consequences. Emitting outside ISM band is forbidden.
	 */
	if( lower_freq_MHz < (double) ISM_MIN_RF_FREQUENCY_KHZ / 1000.0 )
 802a63e:	a316      	add	r3, pc, #88	; (adr r3, 802a698 <pll_set_upper_lower_frequency+0x60>)
 802a640:	e9d3 2300 	ldrd	r2, r3, [r3]
}

//============================================================================

void pll_set_upper_lower_frequency(double lower_freq_MHz, double upper_freq_MHz)
{
 802a644:	4606      	mov	r6, r0
 802a646:	460f      	mov	r7, r1
	/* This check ensures, that the RF Frequency is not set out-side of the 24GHz- ISM band,
	 * do not circumvent it would understanding the consequences. Emitting outside ISM band is forbidden.
	 */
	if( lower_freq_MHz < (double) ISM_MIN_RF_FREQUENCY_KHZ / 1000.0 )
 802a648:	f003 fed0 	bl	802e3ec <__aeabi_dcmplt>
 802a64c:	b990      	cbnz	r0, 802a674 <pll_set_upper_lower_frequency+0x3c>
 802a64e:	4630      	mov	r0, r6
 802a650:	4639      	mov	r1, r7
 802a652:	f003 ff3b 	bl	802e4cc <__aeabi_d2f>
 802a656:	4606      	mov	r6, r0
		lower_freq_MHz = (double) ISM_MIN_RF_FREQUENCY_KHZ / 1000.0;

	if( upper_freq_MHz > (double) ISM_MAX_RF_FREQUENCY_KHZ / 1000.0 )
 802a658:	4620      	mov	r0, r4
 802a65a:	4629      	mov	r1, r5
 802a65c:	a310      	add	r3, pc, #64	; (adr r3, 802a6a0 <pll_set_upper_lower_frequency+0x68>)
 802a65e:	e9d3 2300 	ldrd	r2, r3, [r3]
 802a662:	f003 fee1 	bl	802e428 <__aeabi_dcmpgt>
 802a666:	b138      	cbz	r0, 802a678 <pll_set_upper_lower_frequency+0x40>
 802a668:	4807      	ldr	r0, [pc, #28]	; (802a688 <pll_set_upper_lower_frequency+0x50>)
		upper_freq_MHz = (double) ISM_MAX_RF_FREQUENCY_KHZ / 1000.0;

  s_pll_lower_freq_MHz = lower_freq_MHz;
 802a66a:	4a08      	ldr	r2, [pc, #32]	; (802a68c <pll_set_upper_lower_frequency+0x54>)
  s_pll_upper_freq_MHz = upper_freq_MHz;
 802a66c:	4b08      	ldr	r3, [pc, #32]	; (802a690 <pll_set_upper_lower_frequency+0x58>)
		lower_freq_MHz = (double) ISM_MIN_RF_FREQUENCY_KHZ / 1000.0;

	if( upper_freq_MHz > (double) ISM_MAX_RF_FREQUENCY_KHZ / 1000.0 )
		upper_freq_MHz = (double) ISM_MAX_RF_FREQUENCY_KHZ / 1000.0;

  s_pll_lower_freq_MHz = lower_freq_MHz;
 802a66e:	6016      	str	r6, [r2, #0]
  s_pll_upper_freq_MHz = upper_freq_MHz;
 802a670:	6018      	str	r0, [r3, #0]
 802a672:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802a674:	4e07      	ldr	r6, [pc, #28]	; (802a694 <pll_set_upper_lower_frequency+0x5c>)
 802a676:	e7ef      	b.n	802a658 <pll_set_upper_lower_frequency+0x20>
 802a678:	4620      	mov	r0, r4
 802a67a:	4629      	mov	r1, r5
 802a67c:	f003 ff26 	bl	802e4cc <__aeabi_d2f>
 802a680:	e7f3      	b.n	802a66a <pll_set_upper_lower_frequency+0x32>
 802a682:	bf00      	nop
 802a684:	f3af 8000 	nop.w
 802a688:	46bd4200 	.word	0x46bd4200
 802a68c:	1fff2af4 	.word	0x1fff2af4
 802a690:	1fff2af0 	.word	0x1fff2af0
 802a694:	46bbb200 	.word	0x46bbb200
 802a698:	00000000 	.word	0x00000000
 802a69c:	40d77640 	.word	0x40d77640
 802a6a0:	00000000 	.word	0x00000000
 802a6a4:	40d7a840 	.word	0x40d7a840

0802a6a8 <pll_set_num_chirps_per_frame>:

//============================================================================

void pll_set_num_chirps_per_frame(uint32_t num_chirps_per_frame)
{
  s_pll_num_of_chirps = num_chirps_per_frame;
 802a6a8:	4b01      	ldr	r3, [pc, #4]	; (802a6b0 <pll_set_num_chirps_per_frame+0x8>)
 802a6aa:	6018      	str	r0, [r3, #0]
 802a6ac:	4770      	bx	lr
 802a6ae:	bf00      	nop
 802a6b0:	1fff2af8 	.word	0x1fff2af8

0802a6b4 <pll_set_bandwidth>:

//============================================================================

void pll_set_bandwidth(float bandwidth_MHz)
{
  s_pll_bandwidth_MHz = bandwidth_MHz;
 802a6b4:	4b01      	ldr	r3, [pc, #4]	; (802a6bc <pll_set_bandwidth+0x8>)
 802a6b6:	6018      	str	r0, [r3, #0]
 802a6b8:	4770      	bx	lr
 802a6ba:	bf00      	nop
 802a6bc:	1ffe900c 	.word	0x1ffe900c

0802a6c0 <pll_set_chirp_time>:

//============================================================================

void pll_set_chirp_time(uint32_t chirp_time_usec)
{
  s_pll_chirp_time_usec = chirp_time_usec;
 802a6c0:	4b01      	ldr	r3, [pc, #4]	; (802a6c8 <pll_set_chirp_time+0x8>)
 802a6c2:	6018      	str	r0, [r3, #0]
 802a6c4:	4770      	bx	lr
 802a6c6:	bf00      	nop
 802a6c8:	1ffe9008 	.word	0x1ffe9008

0802a6cc <spi_transmit_data>:
   2. EXPORTED FUNCTIONS
==============================================================================
 */

void spi_transmit_data(uint8_t* data_ptr, uint8_t num_of_bytes, void* peripheral_ptr)
{
 802a6cc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  SPI_DIGITAL_IOs_t spi_pins = *(SPI_DIGITAL_IOs_t*)peripheral_ptr;
 802a6d0:	f8d2 e004 	ldr.w	lr, [r2, #4]
 802a6d4:	6896      	ldr	r6, [r2, #8]

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 802a6d6:	f89e 5010 	ldrb.w	r5, [lr, #16]
 802a6da:	f8de c000 	ldr.w	ip, [lr]
 802a6de:	68d4      	ldr	r4, [r2, #12]
 802a6e0:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 802a6e4:	fa03 f205 	lsl.w	r2, r3, r5
 802a6e8:	f8cc 2004 	str.w	r2, [ip, #4]
  uint8_t index, data;
  
  DIGITAL_IO_SetOutputLow((DIGITAL_IO_t*)spi_pins.gpio_cs_pin);
  __NOP(); __NOP(); __NOP(); __NOP();
 802a6ec:	bf00      	nop
 802a6ee:	bf00      	nop
 802a6f0:	bf00      	nop
 802a6f2:	bf00      	nop
  
  for (uint8_t count = 0U; count < num_of_bytes; count++)
 802a6f4:	b399      	cbz	r1, 802a75e <spi_transmit_data+0x92>
 802a6f6:	f101 39ff 	add.w	r9, r1, #4294967295
 802a6fa:	6837      	ldr	r7, [r6, #0]
 802a6fc:	6821      	ldr	r1, [r4, #0]
 802a6fe:	fa50 f989 	uxtab	r9, r0, r9
 802a702:	f100 38ff 	add.w	r8, r0, #4294967295

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 802a706:	2501      	movs	r5, #1

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 802a708:	4618      	mov	r0, r3
  {
    data = *data_ptr++;
 802a70a:	f818 2f01 	ldrb.w	r2, [r8, #1]!
 802a70e:	2308      	movs	r3, #8

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 802a710:	f896 a010 	ldrb.w	sl, [r6, #16]
    
    for (index =0 ; index < 8U; index++)
    {
      if (data & 0x80)
 802a714:	f012 0f80 	tst.w	r2, #128	; 0x80
 802a718:	bf14      	ite	ne
 802a71a:	fa05 fa0a 	lslne.w	sl, r5, sl

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 802a71e:	fa00 fa0a 	lsleq.w	sl, r0, sl
 802a722:	f8c7 a004 	str.w	sl, [r7, #4]
      }
      else
      {
        DIGITAL_IO_SetOutputLow((DIGITAL_IO_t*)spi_pins.gpio_data_pin);
      }
      __NOP(); __NOP();
 802a726:	bf00      	nop
 802a728:	bf00      	nop

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 802a72a:	f894 a010 	ldrb.w	sl, [r4, #16]
 802a72e:	fa05 fa0a 	lsl.w	sl, r5, sl
 802a732:	f8c1 a004 	str.w	sl, [r1, #4]
      
      DIGITAL_IO_SetOutputHigh((DIGITAL_IO_t*)spi_pins.gpio_clk_pin);
      __NOP(); __NOP(); __NOP(); __NOP();
 802a736:	bf00      	nop
 802a738:	bf00      	nop
 802a73a:	bf00      	nop
 802a73c:	bf00      	nop

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 802a73e:	f894 a010 	ldrb.w	sl, [r4, #16]
 802a742:	fa00 fa0a 	lsl.w	sl, r0, sl
 802a746:	f8c1 a004 	str.w	sl, [r1, #4]
      
      DIGITAL_IO_SetOutputLow((DIGITAL_IO_t*)spi_pins.gpio_clk_pin);
      __NOP(); __NOP();
 802a74a:	bf00      	nop
 802a74c:	bf00      	nop
 802a74e:	3b01      	subs	r3, #1
      
      data <<= 1;
 802a750:	0052      	lsls	r2, r2, #1
  
  for (uint8_t count = 0U; count < num_of_bytes; count++)
  {
    data = *data_ptr++;
    
    for (index =0 ; index < 8U; index++)
 802a752:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
      __NOP(); __NOP(); __NOP(); __NOP();
      
      DIGITAL_IO_SetOutputLow((DIGITAL_IO_t*)spi_pins.gpio_clk_pin);
      __NOP(); __NOP();
      
      data <<= 1;
 802a756:	b2d2      	uxtb	r2, r2
  
  for (uint8_t count = 0U; count < num_of_bytes; count++)
  {
    data = *data_ptr++;
    
    for (index =0 ; index < 8U; index++)
 802a758:	d1da      	bne.n	802a710 <spi_transmit_data+0x44>
  uint8_t index, data;
  
  DIGITAL_IO_SetOutputLow((DIGITAL_IO_t*)spi_pins.gpio_cs_pin);
  __NOP(); __NOP(); __NOP(); __NOP();
  
  for (uint8_t count = 0U; count < num_of_bytes; count++)
 802a75a:	45c8      	cmp	r8, r9
 802a75c:	d1d5      	bne.n	802a70a <spi_transmit_data+0x3e>

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 802a75e:	f89e 2010 	ldrb.w	r2, [lr, #16]
 802a762:	2301      	movs	r3, #1
 802a764:	4093      	lsls	r3, r2
 802a766:	f8cc 3004 	str.w	r3, [ip, #4]
      data <<= 1;
    }
  }
  
  DIGITAL_IO_SetOutputHigh((DIGITAL_IO_t*)spi_pins.gpio_cs_pin);
  __NOP(); __NOP(); __NOP(); __NOP();
 802a76a:	bf00      	nop
 802a76c:	bf00      	nop
 802a76e:	bf00      	nop
 802a770:	bf00      	nop
 802a772:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802a776:	bf00      	nop

0802a778 <com_init>:
   2. EXPORTED FUNCTIONS
==============================================================================
 */
   
void com_init(void)
{
 802a778:	4770      	bx	lr
 802a77a:	bf00      	nop

0802a77c <com_send_data>:

//============================================================================

void com_send_data(const void* pData, uint16_t uNumBytes)
{
  USBD_VCOM_SendData(pData,uNumBytes);
 802a77c:	f7fb b9dc 	b.w	8025b38 <USBD_VCOM_SendData>

0802a780 <com_get_data>:
}

//============================================================================

uint16_t com_get_data(void* pData, uint16_t uNumBytes)
{
 802a780:	b538      	push	{r3, r4, r5, lr}
 802a782:	460c      	mov	r4, r1
 802a784:	4605      	mov	r5, r0
  uint16_t bytes = 0;
  
  bytes = USBD_VCOM_BytesReceived();
 802a786:	f7fb fa15 	bl	8025bb4 <USBD_VCOM_BytesReceived>
  
  bytes = (bytes > uNumBytes) ? uNumBytes : bytes;
 802a78a:	42a0      	cmp	r0, r4
 802a78c:	bf28      	it	cs
 802a78e:	4620      	movcs	r0, r4
 802a790:	b284      	uxth	r4, r0
  
  if (bytes)
 802a792:	b11c      	cbz	r4, 802a79c <com_get_data+0x1c>
  {
    USBD_VCOM_ReceiveData((int8_t*)pData, bytes);
 802a794:	4628      	mov	r0, r5
 802a796:	4621      	mov	r1, r4
 802a798:	f7fb f9e8 	bl	8025b6c <USBD_VCOM_ReceiveData>
  }
  
  return (bytes);
}
 802a79c:	4620      	mov	r0, r4
 802a79e:	bd38      	pop	{r3, r4, r5, pc}

0802a7a0 <com_flush>:

//============================================================================

void com_flush(void)
{
  CDC_Device_USBTask(&USBD_VCOM_cdc_interface);	/* Do nothing as USBD VCOM already flushes the data that is sent */
 802a7a0:	4801      	ldr	r0, [pc, #4]	; (802a7a8 <com_flush+0x8>)
 802a7a2:	f7fb b811 	b.w	80257c8 <CDC_Device_USBTask>
 802a7a6:	bf00      	nop
 802a7a8:	2000d6c8 	.word	0x2000d6c8

0802a7ac <pga112_init>:
   4. EXPORTED FUNCTIONS
==============================================================================
 */

Pga_Status_t pga112_init(uint16_t gain_level)
{
 802a7ac:	b570      	push	{r4, r5, r6, lr}
  /* Set the digital IOs used by SPI interface */
  pga112_spi_pins.spi_device = PGA_DEVICE;
 802a7ae:	4a15      	ldr	r2, [pc, #84]	; (802a804 <pga112_init+0x58>)
  pga112_spi_pins.gpio_cs_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_PGA;
 802a7b0:	4915      	ldr	r1, [pc, #84]	; (802a808 <pga112_init+0x5c>)
  pga112_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_DATA_PGA;
 802a7b2:	4d16      	ldr	r5, [pc, #88]	; (802a80c <pga112_init+0x60>)
  pga112_spi_pins.gpio_clk_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;
 802a7b4:	4b16      	ldr	r3, [pc, #88]	; (802a810 <pga112_init+0x64>)

Pga_Status_t pga112_init(uint16_t gain_level)
{
  /* Set the digital IOs used by SPI interface */
  pga112_spi_pins.spi_device = PGA_DEVICE;
  pga112_spi_pins.gpio_cs_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_PGA;
 802a7b6:	6051      	str	r1, [r2, #4]
   4. EXPORTED FUNCTIONS
==============================================================================
 */

Pga_Status_t pga112_init(uint16_t gain_level)
{
 802a7b8:	b082      	sub	sp, #8
  /* Set the digital IOs used by SPI interface */
  pga112_spi_pins.spi_device = PGA_DEVICE;
 802a7ba:	2102      	movs	r1, #2
//============================================================================

Pga_Status_t pga112_set_gain(uint16_t gain_level)
{
  Pga112_Binary_Gain_t  gain_val;
  uint16_t shuffled_data = 0;
 802a7bc:	2400      	movs	r4, #0

  if(gain_level > PGA112_MAX_NUMBER_SUPPORTED_GAIN)
 802a7be:	2807      	cmp	r0, #7
Pga_Status_t pga112_init(uint16_t gain_level)
{
  /* Set the digital IOs used by SPI interface */
  pga112_spi_pins.spi_device = PGA_DEVICE;
  pga112_spi_pins.gpio_cs_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_PGA;
  pga112_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_DATA_PGA;
 802a7c0:	6095      	str	r5, [r2, #8]
  pga112_spi_pins.gpio_clk_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;
 802a7c2:	60d3      	str	r3, [r2, #12]
 */

Pga_Status_t pga112_init(uint16_t gain_level)
{
  /* Set the digital IOs used by SPI interface */
  pga112_spi_pins.spi_device = PGA_DEVICE;
 802a7c4:	7011      	strb	r1, [r2, #0]
//============================================================================

Pga_Status_t pga112_set_gain(uint16_t gain_level)
{
  Pga112_Binary_Gain_t  gain_val;
  uint16_t shuffled_data = 0;
 802a7c6:	f8ad 4006 	strh.w	r4, [sp, #6]

  if(gain_level > PGA112_MAX_NUMBER_SUPPORTED_GAIN)
 802a7ca:	d818      	bhi.n	802a7fe <pga112_init+0x52>
 802a7cc:	4b11      	ldr	r3, [pc, #68]	; (802a814 <pga112_init+0x68>)

  /* Get PGA112 gain value from the selected index */
  pga112_global_gain = gain_level;
  gain_val = pga112_get_binary_gain(gain_level);

  pga112_global_config = (PGA112_CMD_WRITE | gain_val | PGA112_CH1);
 802a7ce:	4e12      	ldr	r6, [pc, #72]	; (802a818 <pga112_init+0x6c>)
 802a7d0:	5c1b      	ldrb	r3, [r3, r0]
  {
    return (PGA_STATUS_FAIL);
  }

  /* Get PGA112 gain value from the selected index */
  pga112_global_gain = gain_level;
 802a7d2:	4d12      	ldr	r5, [pc, #72]	; (802a81c <pga112_init+0x70>)
  gain_val = pga112_get_binary_gain(gain_level);

  pga112_global_config = (PGA112_CMD_WRITE | gain_val | PGA112_CH1);
 802a7d4:	f443 5328 	orr.w	r3, r3, #10752	; 0x2a00
 802a7d8:	f043 0301 	orr.w	r3, r3, #1
  {
    return (PGA_STATUS_FAIL);
  }

  /* Get PGA112 gain value from the selected index */
  pga112_global_gain = gain_level;
 802a7dc:	8028      	strh	r0, [r5, #0]
  gain_val = pga112_get_binary_gain(gain_level);

  pga112_global_config = (PGA112_CMD_WRITE | gain_val | PGA112_CH1);
 802a7de:	8033      	strh	r3, [r6, #0]

  /* Lower byte goes to upper byte position */
  shuffled_data  = ((pga112_global_config & 0x00FF) << 8);
 802a7e0:	8835      	ldrh	r5, [r6, #0]

  /* Upper byte goes to lower byte position */
  shuffled_data |= ((pga112_global_config & 0xFF00) >> 8);
 802a7e2:	8833      	ldrh	r3, [r6, #0]
 802a7e4:	a802      	add	r0, sp, #8
  gain_val = pga112_get_binary_gain(gain_level);

  pga112_global_config = (PGA112_CMD_WRITE | gain_val | PGA112_CH1);

  /* Lower byte goes to upper byte position */
  shuffled_data  = ((pga112_global_config & 0x00FF) << 8);
 802a7e6:	b2ad      	uxth	r5, r5

  /* Upper byte goes to lower byte position */
  shuffled_data |= ((pga112_global_config & 0xFF00) >> 8);
 802a7e8:	f3c3 2307 	ubfx	r3, r3, #8, #8
 802a7ec:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
 802a7f0:	f820 3d02 	strh.w	r3, [r0, #-2]!

  /* Send command to PGA112 */
  spi_transmit_data((uint8_t *)&shuffled_data, 2, (void*) &pga112_spi_pins);
 802a7f4:	f7ff ff6a 	bl	802a6cc <spi_transmit_data>

  return (PGA_STATUS_SUCCESS);
 802a7f8:	4620      	mov	r0, r4
  pga112_spi_pins.gpio_cs_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_PGA;
  pga112_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_DATA_PGA;
  pga112_spi_pins.gpio_clk_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;

  return (pga112_set_gain(gain_level));
}
 802a7fa:	b002      	add	sp, #8
 802a7fc:	bd70      	pop	{r4, r5, r6, pc}
  Pga112_Binary_Gain_t  gain_val;
  uint16_t shuffled_data = 0;

  if(gain_level > PGA112_MAX_NUMBER_SUPPORTED_GAIN)
  {
    return (PGA_STATUS_FAIL);
 802a7fe:	2001      	movs	r0, #1
  pga112_spi_pins.gpio_cs_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_PGA;
  pga112_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_DATA_PGA;
  pga112_spi_pins.gpio_clk_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;

  return (pga112_set_gain(gain_level));
}
 802a800:	b002      	add	sp, #8
 802a802:	bd70      	pop	{r4, r5, r6, pc}
 802a804:	1fff2b10 	.word	0x1fff2b10
 802a808:	08030cbc 	.word	0x08030cbc
 802a80c:	08030c94 	.word	0x08030c94
 802a810:	08030ca8 	.word	0x08030ca8
 802a814:	08031dec 	.word	0x08031dec
 802a818:	1ffe9010 	.word	0x1ffe9010
 802a81c:	1fff2b20 	.word	0x1fff2b20

0802a820 <pga112_set_gain>:
}

//============================================================================

Pga_Status_t pga112_set_gain(uint16_t gain_level)
{
 802a820:	b510      	push	{r4, lr}
 802a822:	b082      	sub	sp, #8
  Pga112_Binary_Gain_t  gain_val;
  uint16_t shuffled_data = 0;
 802a824:	2400      	movs	r4, #0

  if(gain_level > PGA112_MAX_NUMBER_SUPPORTED_GAIN)
 802a826:	2807      	cmp	r0, #7
//============================================================================

Pga_Status_t pga112_set_gain(uint16_t gain_level)
{
  Pga112_Binary_Gain_t  gain_val;
  uint16_t shuffled_data = 0;
 802a828:	f8ad 4006 	strh.w	r4, [sp, #6]

  if(gain_level > PGA112_MAX_NUMBER_SUPPORTED_GAIN)
 802a82c:	d81a      	bhi.n	802a864 <pga112_set_gain+0x44>
 802a82e:	4b0f      	ldr	r3, [pc, #60]	; (802a86c <pga112_set_gain+0x4c>)

  /* Get PGA112 gain value from the selected index */
  pga112_global_gain = gain_level;
  gain_val = pga112_get_binary_gain(gain_level);

  pga112_global_config = (PGA112_CMD_WRITE | gain_val | PGA112_CH1);
 802a830:	4a0f      	ldr	r2, [pc, #60]	; (802a870 <pga112_set_gain+0x50>)
 802a832:	5c1b      	ldrb	r3, [r3, r0]
  {
    return (PGA_STATUS_FAIL);
  }

  /* Get PGA112 gain value from the selected index */
  pga112_global_gain = gain_level;
 802a834:	490f      	ldr	r1, [pc, #60]	; (802a874 <pga112_set_gain+0x54>)
  gain_val = pga112_get_binary_gain(gain_level);

  pga112_global_config = (PGA112_CMD_WRITE | gain_val | PGA112_CH1);
 802a836:	f443 5328 	orr.w	r3, r3, #10752	; 0x2a00
 802a83a:	f043 0301 	orr.w	r3, r3, #1
  {
    return (PGA_STATUS_FAIL);
  }

  /* Get PGA112 gain value from the selected index */
  pga112_global_gain = gain_level;
 802a83e:	8008      	strh	r0, [r1, #0]
  gain_val = pga112_get_binary_gain(gain_level);

  pga112_global_config = (PGA112_CMD_WRITE | gain_val | PGA112_CH1);
 802a840:	8013      	strh	r3, [r2, #0]

  /* Lower byte goes to upper byte position */
  shuffled_data  = ((pga112_global_config & 0x00FF) << 8);
 802a842:	8811      	ldrh	r1, [r2, #0]

  /* Upper byte goes to lower byte position */
  shuffled_data |= ((pga112_global_config & 0xFF00) >> 8);
 802a844:	8813      	ldrh	r3, [r2, #0]

  /* Send command to PGA112 */
  spi_transmit_data((uint8_t *)&shuffled_data, 2, (void*) &pga112_spi_pins);
 802a846:	4a0c      	ldr	r2, [pc, #48]	; (802a878 <pga112_set_gain+0x58>)

  /* Lower byte goes to upper byte position */
  shuffled_data  = ((pga112_global_config & 0x00FF) << 8);

  /* Upper byte goes to lower byte position */
  shuffled_data |= ((pga112_global_config & 0xFF00) >> 8);
 802a848:	a802      	add	r0, sp, #8
  gain_val = pga112_get_binary_gain(gain_level);

  pga112_global_config = (PGA112_CMD_WRITE | gain_val | PGA112_CH1);

  /* Lower byte goes to upper byte position */
  shuffled_data  = ((pga112_global_config & 0x00FF) << 8);
 802a84a:	b289      	uxth	r1, r1

  /* Upper byte goes to lower byte position */
  shuffled_data |= ((pga112_global_config & 0xFF00) >> 8);
 802a84c:	f3c3 2307 	ubfx	r3, r3, #8, #8
 802a850:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 802a854:	f820 3d02 	strh.w	r3, [r0, #-2]!

  /* Send command to PGA112 */
  spi_transmit_data((uint8_t *)&shuffled_data, 2, (void*) &pga112_spi_pins);
 802a858:	2102      	movs	r1, #2
 802a85a:	f7ff ff37 	bl	802a6cc <spi_transmit_data>

  return (PGA_STATUS_SUCCESS);
 802a85e:	4620      	mov	r0, r4
}
 802a860:	b002      	add	sp, #8
 802a862:	bd10      	pop	{r4, pc}
  Pga112_Binary_Gain_t  gain_val;
  uint16_t shuffled_data = 0;

  if(gain_level > PGA112_MAX_NUMBER_SUPPORTED_GAIN)
  {
    return (PGA_STATUS_FAIL);
 802a864:	2001      	movs	r0, #1

  /* Send command to PGA112 */
  spi_transmit_data((uint8_t *)&shuffled_data, 2, (void*) &pga112_spi_pins);

  return (PGA_STATUS_SUCCESS);
}
 802a866:	b002      	add	sp, #8
 802a868:	bd10      	pop	{r4, pc}
 802a86a:	bf00      	nop
 802a86c:	08031dec 	.word	0x08031dec
 802a870:	1ffe9010 	.word	0x1ffe9010
 802a874:	1fff2b20 	.word	0x1fff2b20
 802a878:	1fff2b10 	.word	0x1fff2b10

0802a87c <lmx249x_init>:
==============================================================================
 */

void lmx249x_init(Lmx249x_Object_t* pThis, const Lmx249x_Hardware_Setup_t* pSetup,
                  sendSPIFunction sendSPI, void* pDataForSendSPI)
{
 802a87c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802a880:	4605      	mov	r5, r0
 802a882:	b087      	sub	sp, #28
  uint8_t uSPIData[17];
  
  /* Set Internal Parameters */
  pThis->dExternalDivideFactor = (1.0 / pSetup->uExternalDivider); /* inverse RF-divider within the BGT chip */
 802a884:	68c8      	ldr	r0, [r1, #12]
==============================================================================
 */

void lmx249x_init(Lmx249x_Object_t* pThis, const Lmx249x_Hardware_Setup_t* pSetup,
                  sendSPIFunction sendSPI, void* pDataForSendSPI)
{
 802a886:	460c      	mov	r4, r1
 802a888:	4616      	mov	r6, r2
 802a88a:	461f      	mov	r7, r3
  uint8_t uSPIData[17];
  
  /* Set Internal Parameters */
  pThis->dExternalDivideFactor = (1.0 / pSetup->uExternalDivider); /* inverse RF-divider within the BGT chip */
 802a88c:	f003 fac6 	bl	802de1c <__aeabi_ui2d>
 802a890:	4602      	mov	r2, r0
 802a892:	460b      	mov	r3, r1
 802a894:	2000      	movs	r0, #0
 802a896:	495f      	ldr	r1, [pc, #380]	; (802aa14 <lmx249x_init+0x198>)
 802a898:	f003 fc60 	bl	802e15c <__aeabi_ddiv>
  pThis->dPFDCycleTime = 1.0f / (pSetup->dReferenceFreq * (pSetup->eReferenceDoubler ? 2.0 : 1.0) / pSetup->uReferenceDivider );
 802a89c:	7aa3      	ldrb	r3, [r4, #10]
 802a89e:	2200      	movs	r2, #0
                  sendSPIFunction sendSPI, void* pDataForSendSPI)
{
  uint8_t uSPIData[17];
  
  /* Set Internal Parameters */
  pThis->dExternalDivideFactor = (1.0 / pSetup->uExternalDivider); /* inverse RF-divider within the BGT chip */
 802a8a0:	e9c5 0100 	strd	r0, r1, [r5]
  pThis->dPFDCycleTime = 1.0f / (pSetup->dReferenceFreq * (pSetup->eReferenceDoubler ? 2.0 : 1.0) / pSetup->uReferenceDivider );
 802a8a4:	e9d4 0100 	ldrd	r0, r1, [r4]
 802a8a8:	2b00      	cmp	r3, #0
 802a8aa:	f040 80b0 	bne.w	802aa0e <lmx249x_init+0x192>
 802a8ae:	4b59      	ldr	r3, [pc, #356]	; (802aa14 <lmx249x_init+0x198>)
 802a8b0:	f003 fb2a 	bl	802df08 <__aeabi_dmul>
 802a8b4:	4680      	mov	r8, r0
 802a8b6:	8920      	ldrh	r0, [r4, #8]
 802a8b8:	4689      	mov	r9, r1
 802a8ba:	f003 fabf 	bl	802de3c <__aeabi_i2d>
 802a8be:	4602      	mov	r2, r0
 802a8c0:	460b      	mov	r3, r1
 802a8c2:	4640      	mov	r0, r8
 802a8c4:	4649      	mov	r1, r9
 802a8c6:	f003 fc49 	bl	802e15c <__aeabi_ddiv>
 802a8ca:	4602      	mov	r2, r0
 802a8cc:	460b      	mov	r3, r1
 802a8ce:	2000      	movs	r0, #0
 802a8d0:	4950      	ldr	r1, [pc, #320]	; (802aa14 <lmx249x_init+0x198>)
 802a8d2:	f003 fc43 	bl	802e15c <__aeabi_ddiv>
  pThis->uReg58 = 0;
 802a8d6:	f04f 0800 	mov.w	r8, #0
  pThis->sendSPI = sendSPI;
  pThis->pDataForSendSPI = pDataForSendSPI;
 802a8da:	61af      	str	r7, [r5, #24]
  
  /* Do a Power on Reset and set all PLL registers to the default value */
  uSPIData[0] = 0;
  uSPIData[1] = 2;
  uSPIData[2] = (1 << 2);
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
 802a8dc:	463a      	mov	r2, r7
  pThis->pDataForSendSPI = pDataForSendSPI;
  
  /* Do a Power on Reset and set all PLL registers to the default value */
  uSPIData[0] = 0;
  uSPIData[1] = 2;
  uSPIData[2] = (1 << 2);
 802a8de:	2304      	movs	r3, #4
  pThis->sendSPI = sendSPI;
  pThis->pDataForSendSPI = pDataForSendSPI;
  
  /* Do a Power on Reset and set all PLL registers to the default value */
  uSPIData[0] = 0;
  uSPIData[1] = 2;
 802a8e0:	2702      	movs	r7, #2
{
  uint8_t uSPIData[17];
  
  /* Set Internal Parameters */
  pThis->dExternalDivideFactor = (1.0 / pSetup->uExternalDivider); /* inverse RF-divider within the BGT chip */
  pThis->dPFDCycleTime = 1.0f / (pSetup->dReferenceFreq * (pSetup->eReferenceDoubler ? 2.0 : 1.0) / pSetup->uReferenceDivider );
 802a8e2:	e9c5 0102 	strd	r0, r1, [r5, #8]
  pThis->uReg58 = 0;
  pThis->sendSPI = sendSPI;
 802a8e6:	616e      	str	r6, [r5, #20]
  
  /* Do a Power on Reset and set all PLL registers to the default value */
  uSPIData[0] = 0;
  uSPIData[1] = 2;
  uSPIData[2] = (1 << 2);
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
 802a8e8:	a801      	add	r0, sp, #4
  pThis->sendSPI = sendSPI;
  pThis->pDataForSendSPI = pDataForSendSPI;
  
  /* Do a Power on Reset and set all PLL registers to the default value */
  uSPIData[0] = 0;
  uSPIData[1] = 2;
 802a8ea:	f88d 7005 	strb.w	r7, [sp, #5]
  uSPIData[2] = (1 << 2);
 802a8ee:	f88d 3006 	strb.w	r3, [sp, #6]
  uint8_t uSPIData[17];
  
  /* Set Internal Parameters */
  pThis->dExternalDivideFactor = (1.0 / pSetup->uExternalDivider); /* inverse RF-divider within the BGT chip */
  pThis->dPFDCycleTime = 1.0f / (pSetup->dReferenceFreq * (pSetup->eReferenceDoubler ? 2.0 : 1.0) / pSetup->uReferenceDivider );
  pThis->uReg58 = 0;
 802a8f2:	f885 8010 	strb.w	r8, [r5, #16]
  
  /* Do a Power on Reset and set all PLL registers to the default value */
  uSPIData[0] = 0;
  uSPIData[1] = 2;
  uSPIData[2] = (1 << 2);
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
 802a8f6:	2103      	movs	r1, #3
  pThis->uReg58 = 0;
  pThis->sendSPI = sendSPI;
  pThis->pDataForSendSPI = pDataForSendSPI;
  
  /* Do a Power on Reset and set all PLL registers to the default value */
  uSPIData[0] = 0;
 802a8f8:	f88d 8004 	strb.w	r8, [sp, #4]
  uSPIData[1] = 2;
  uSPIData[2] = (1 << 2);
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
 802a8fc:	47b0      	blx	r6
  
  /* Setup Routing and Drive for Pins TRIG1, TRIG2, MOD and MUXout */
  uSPIData[LMX249x_REG_IDX(25, 15, 35)] = 0x41 | /* these bits must be set */
    ((pSetup->eTrig1PinFunction   >> 2) & 0x08) | /* TRIG1_MUX[5] shifted to bit 3 */
 802a8fe:	f894 9010 	ldrb.w	r9, [r4, #16]
      ((pSetup->eTrig2PinFunction   >> 1) & 0x10) | /* TRIG2_MUX[5] shifted to bit 4 */
        ((pSetup->eMUXoutPinFunction  >> 0) & 0x20) | /* MUXout_MUX[5] stays at bit 5 */
 802a902:	7da7      	ldrb	r7, [r4, #22]
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
  
  /* Setup Routing and Drive for Pins TRIG1, TRIG2, MOD and MUXout */
  uSPIData[LMX249x_REG_IDX(25, 15, 35)] = 0x41 | /* these bits must be set */
    ((pSetup->eTrig1PinFunction   >> 2) & 0x08) | /* TRIG1_MUX[5] shifted to bit 3 */
      ((pSetup->eTrig2PinFunction   >> 1) & 0x10) | /* TRIG2_MUX[5] shifted to bit 4 */
 802a904:	f894 c012 	ldrb.w	ip, [r4, #18]
  uSPIData[LMX249x_REG_IDX(25, 15, 26)] = (pSetup->uReferenceDivider >> 8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] =  pSetup->eReferenceDoubler |
    (pSetup->eOscInMode << 2);
  
  /* Setup Charge Pump configuration */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eChargePumpPulseWidth << 3);
 802a908:	7f61      	ldrb	r1, [r4, #29]
  
  /* Setup Reference Scaling */
  uSPIData[LMX249x_REG_IDX(25, 15, 25)] = (pSetup->uReferenceDivider >> 0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(25, 15, 26)] = (pSetup->uReferenceDivider >> 8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] =  pSetup->eReferenceDoubler |
    (pSetup->eOscInMode << 2);
 802a90a:	7ae6      	ldrb	r6, [r4, #11]
  /* Setup Routing and Drive for Pins TRIG1, TRIG2, MOD and MUXout */
  uSPIData[LMX249x_REG_IDX(25, 15, 35)] = 0x41 | /* these bits must be set */
    ((pSetup->eTrig1PinFunction   >> 2) & 0x08) | /* TRIG1_MUX[5] shifted to bit 3 */
      ((pSetup->eTrig2PinFunction   >> 1) & 0x10) | /* TRIG2_MUX[5] shifted to bit 4 */
        ((pSetup->eMUXoutPinFunction  >> 0) & 0x20) | /* MUXout_MUX[5] stays at bit 5 */
          ((pSetup->eModPinFunction     << 2) & 0x80);  /* MOD_MUX[5] shifted to at bit 7 */
 802a90c:	f894 e014 	ldrb.w	lr, [r4, #20]
  uSPIData[LMX249x_REG_IDX(25, 15, 26)] = (pSetup->uReferenceDivider >> 8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] =  pSetup->eReferenceDoubler |
    (pSetup->eOscInMode << 2);
  
  /* Setup Charge Pump configuration */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eChargePumpPulseWidth << 3);
 802a910:	f894 b00a 	ldrb.w	fp, [r4, #10]
    (pSetup->uChargePumpCurrent & 0x1F);
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] =  (pSetup->uChargePumpCurrentFS & 0x1F);
  
  /* Setup speed up settings */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eCycleSlipReduction << 5);
  uSPIData[LMX249x_REG_IDX(25, 15, 32)]  = (pSetup->uFastLockTimer & 0xFF);
 802a914:	8c23      	ldrh	r3, [r4, #32]
 802a916:	f88d 300d 	strb.w	r3, [sp, #13]
  uSPIData[1] = 2;
  uSPIData[2] = (1 << 2);
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
  
  /* Setup Routing and Drive for Pins TRIG1, TRIG2, MOD and MUXout */
  uSPIData[LMX249x_REG_IDX(25, 15, 35)] = 0x41 | /* these bits must be set */
 802a91a:	ea4f 0099 	mov.w	r0, r9, lsr #2
 802a91e:	f007 0220 	and.w	r2, r7, #32
 802a922:	f000 0008 	and.w	r0, r0, #8
 802a926:	ea4f 0a5c 	mov.w	sl, ip, lsr #1
 802a92a:	f042 0241 	orr.w	r2, r2, #65	; 0x41
 802a92e:	4302      	orrs	r2, r0
 802a930:	f00a 0a10 	and.w	sl, sl, #16
  uSPIData[LMX249x_REG_IDX(25, 15, 26)] = (pSetup->uReferenceDivider >> 8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] =  pSetup->eReferenceDoubler |
    (pSetup->eOscInMode << 2);
  
  /* Setup Charge Pump configuration */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eChargePumpPulseWidth << 3);
 802a934:	00c9      	lsls	r1, r1, #3
 802a936:	ea41 0186 	orr.w	r1, r1, r6, lsl #2
  uSPIData[1] = 2;
  uSPIData[2] = (1 << 2);
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
  
  /* Setup Routing and Drive for Pins TRIG1, TRIG2, MOD and MUXout */
  uSPIData[LMX249x_REG_IDX(25, 15, 35)] = 0x41 | /* these bits must be set */
 802a93a:	ea42 020a 	orr.w	r2, r2, sl
    ((pSetup->eTrig1PinFunction   >> 2) & 0x08) | /* TRIG1_MUX[5] shifted to bit 3 */
      ((pSetup->eTrig2PinFunction   >> 1) & 0x10) | /* TRIG2_MUX[5] shifted to bit 4 */
        ((pSetup->eMUXoutPinFunction  >> 0) & 0x20) | /* MUXout_MUX[5] stays at bit 5 */
          ((pSetup->eModPinFunction     << 2) & 0x80);  /* MOD_MUX[5] shifted to at bit 7 */
 802a93e:	ea4f 0a8e 	mov.w	sl, lr, lsl #2
  uSPIData[LMX249x_REG_IDX(25, 15, 26)] = (pSetup->uReferenceDivider >> 8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] =  pSetup->eReferenceDoubler |
    (pSetup->eOscInMode << 2);
  
  /* Setup Charge Pump configuration */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eChargePumpPulseWidth << 3);
 802a942:	ea41 010b 	orr.w	r1, r1, fp
  uSPIData[1] = 2;
  uSPIData[2] = (1 << 2);
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
  
  /* Setup Routing and Drive for Pins TRIG1, TRIG2, MOD and MUXout */
  uSPIData[LMX249x_REG_IDX(25, 15, 35)] = 0x41 | /* these bits must be set */
 802a946:	f02a 0a7f 	bic.w	sl, sl, #127	; 0x7f
    ((pSetup->eTrig1PinFunction   >> 2) & 0x08) | /* TRIG1_MUX[5] shifted to bit 3 */
      ((pSetup->eTrig2PinFunction   >> 1) & 0x10) | /* TRIG2_MUX[5] shifted to bit 4 */
        ((pSetup->eMUXoutPinFunction  >> 0) & 0x20) | /* MUXout_MUX[5] stays at bit 5 */
          ((pSetup->eModPinFunction     << 2) & 0x80);  /* MOD_MUX[5] shifted to at bit 7 */
  
  uSPIData[LMX249x_REG_IDX(25, 15, 36)] = ((pSetup->eTrig1PinFunction & 0x1F) << 3) |
 802a94a:	f894 b011 	ldrb.w	fp, [r4, #17]
  
  /* Setup Charge Pump configuration */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eChargePumpPulseWidth << 3);
  uSPIData[LMX249x_REG_IDX(25, 15, 28)] = ((pSetup->eChargePumpPolarity) << 5) |
    (pSetup->uChargePumpCurrent & 0x1F);
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] =  (pSetup->uChargePumpCurrentFS & 0x1F);
 802a94e:	7ea6      	ldrb	r6, [r4, #26]
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] =  pSetup->eReferenceDoubler |
    (pSetup->eOscInMode << 2);
  
  /* Setup Charge Pump configuration */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eChargePumpPulseWidth << 3);
  uSPIData[LMX249x_REG_IDX(25, 15, 28)] = ((pSetup->eChargePumpPolarity) << 5) |
 802a950:	7e60      	ldrb	r0, [r4, #25]
  uSPIData[1] = 2;
  uSPIData[2] = (1 << 2);
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
  
  /* Setup Routing and Drive for Pins TRIG1, TRIG2, MOD and MUXout */
  uSPIData[LMX249x_REG_IDX(25, 15, 35)] = 0x41 | /* these bits must be set */
 802a952:	ea42 020a 	orr.w	r2, r2, sl
          ((pSetup->eModPinFunction     << 2) & 0x80);  /* MOD_MUX[5] shifted to at bit 7 */
  
  uSPIData[LMX249x_REG_IDX(25, 15, 36)] = ((pSetup->eTrig1PinFunction & 0x1F) << 3) |
    pSetup->eTrig1PinDriveMode;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 37)] = ((pSetup->eTrig2PinFunction & 0x1F) << 3) |
 802a956:	f894 a013 	ldrb.w	sl, [r4, #19]
  uSPIData[1] = 2;
  uSPIData[2] = (1 << 2);
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
  
  /* Setup Routing and Drive for Pins TRIG1, TRIG2, MOD and MUXout */
  uSPIData[LMX249x_REG_IDX(25, 15, 35)] = 0x41 | /* these bits must be set */
 802a95a:	f88d 200a 	strb.w	r2, [sp, #10]
    ((pSetup->eTrig1PinFunction   >> 2) & 0x08) | /* TRIG1_MUX[5] shifted to bit 3 */
      ((pSetup->eTrig2PinFunction   >> 1) & 0x10) | /* TRIG2_MUX[5] shifted to bit 4 */
        ((pSetup->eMUXoutPinFunction  >> 0) & 0x20) | /* MUXout_MUX[5] stays at bit 5 */
          ((pSetup->eModPinFunction     << 2) & 0x80);  /* MOD_MUX[5] shifted to at bit 7 */
  
  uSPIData[LMX249x_REG_IDX(25, 15, 36)] = ((pSetup->eTrig1PinFunction & 0x1F) << 3) |
 802a95e:	ea4b 09c9 	orr.w	r9, fp, r9, lsl #3
    pSetup->eTrig2PinDriveMode;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 38)] = ((pSetup->eModPinFunction & 0x1F) << 3) |
    pSetup->eModPinDriveMode;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 39)] = ((pSetup->eMUXoutPinFunction & 0x1F) << 3) |
 802a962:	7de2      	ldrb	r2, [r4, #23]
    pSetup->eTrig1PinDriveMode;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 37)] = ((pSetup->eTrig2PinFunction & 0x1F) << 3) |
    pSetup->eTrig2PinDriveMode;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 38)] = ((pSetup->eModPinFunction & 0x1F) << 3) |
 802a964:	f894 b015 	ldrb.w	fp, [r4, #21]
    ((pSetup->eTrig1PinFunction   >> 2) & 0x08) | /* TRIG1_MUX[5] shifted to bit 3 */
      ((pSetup->eTrig2PinFunction   >> 1) & 0x10) | /* TRIG2_MUX[5] shifted to bit 4 */
        ((pSetup->eMUXoutPinFunction  >> 0) & 0x20) | /* MUXout_MUX[5] stays at bit 5 */
          ((pSetup->eModPinFunction     << 2) & 0x80);  /* MOD_MUX[5] shifted to at bit 7 */
  
  uSPIData[LMX249x_REG_IDX(25, 15, 36)] = ((pSetup->eTrig1PinFunction & 0x1F) << 3) |
 802a968:	f88d 9009 	strb.w	r9, [sp, #9]
    pSetup->eTrig1PinDriveMode;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 37)] = ((pSetup->eTrig2PinFunction & 0x1F) << 3) |
 802a96c:	ea4a 0ccc 	orr.w	ip, sl, ip, lsl #3
  uSPIData[LMX249x_REG_IDX(25, 15, 28)] = ((pSetup->eChargePumpPolarity) << 5) |
    (pSetup->uChargePumpCurrent & 0x1F);
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] =  (pSetup->uChargePumpCurrentFS & 0x1F);
  
  /* Setup speed up settings */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eCycleSlipReduction << 5);
 802a970:	f894 901e 	ldrb.w	r9, [r4, #30]
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] =  pSetup->eReferenceDoubler |
    (pSetup->eOscInMode << 2);
  
  /* Setup Charge Pump configuration */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eChargePumpPulseWidth << 3);
  uSPIData[LMX249x_REG_IDX(25, 15, 28)] = ((pSetup->eChargePumpPolarity) << 5) |
 802a974:	f894 a018 	ldrb.w	sl, [r4, #24]
          ((pSetup->eModPinFunction     << 2) & 0x80);  /* MOD_MUX[5] shifted to at bit 7 */
  
  uSPIData[LMX249x_REG_IDX(25, 15, 36)] = ((pSetup->eTrig1PinFunction & 0x1F) << 3) |
    pSetup->eTrig1PinDriveMode;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 37)] = ((pSetup->eTrig2PinFunction & 0x1F) << 3) |
 802a978:	f88d c008 	strb.w	ip, [sp, #8]
    pSetup->eTrig2PinDriveMode;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 38)] = ((pSetup->eModPinFunction & 0x1F) << 3) |
 802a97c:	ea4b 0ece 	orr.w	lr, fp, lr, lsl #3
  
  uSPIData[LMX249x_REG_IDX(25, 15, 39)] = ((pSetup->eMUXoutPinFunction & 0x1F) << 3) |
    pSetup->eMUXoutPinDriveMode;
  
  /* Setup Reference Scaling */
  uSPIData[LMX249x_REG_IDX(25, 15, 25)] = (pSetup->uReferenceDivider >> 0) & 0xFF;
 802a980:	f8b4 c008 	ldrh.w	ip, [r4, #8]
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eCycleSlipReduction << 5);
  uSPIData[LMX249x_REG_IDX(25, 15, 32)]  = (pSetup->uFastLockTimer & 0xFF);
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] |= (pSetup->uFastLockTimer >> 3) & 0xE0;
  
  /* Setup lock detection */
  uSPIData[LMX249x_REG_IDX(25, 15, 30)] =  pSetup->uChargePumpThresholdLo & 0x3F;
 802a984:	f894 b01b 	ldrb.w	fp, [r4, #27]
    pSetup->eTrig1PinDriveMode;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 37)] = ((pSetup->eTrig2PinFunction & 0x1F) << 3) |
    pSetup->eTrig2PinDriveMode;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 38)] = ((pSetup->eModPinFunction & 0x1F) << 3) |
 802a988:	f88d e007 	strb.w	lr, [sp, #7]
    pSetup->eModPinDriveMode;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 39)] = ((pSetup->eMUXoutPinFunction & 0x1F) << 3) |
 802a98c:	ea42 07c7 	orr.w	r7, r2, r7, lsl #3
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] =  (pSetup->uChargePumpCurrentFS & 0x1F);
  
  /* Setup speed up settings */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eCycleSlipReduction << 5);
  uSPIData[LMX249x_REG_IDX(25, 15, 32)]  = (pSetup->uFastLockTimer & 0xFF);
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] |= (pSetup->uFastLockTimer >> 3) & 0xE0;
 802a990:	08db      	lsrs	r3, r3, #3
  
  /* Setup lock detection */
  uSPIData[LMX249x_REG_IDX(25, 15, 30)] =  pSetup->uChargePumpThresholdLo & 0x3F;
  uSPIData[LMX249x_REG_IDX(25, 15, 31)] =  pSetup->uChargePumpThresholdHi & 0x3F;
 802a992:	7f22      	ldrb	r2, [r4, #28]
    pSetup->eTrig2PinDriveMode;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 38)] = ((pSetup->eModPinFunction & 0x1F) << 3) |
    pSetup->eModPinDriveMode;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 39)] = ((pSetup->eMUXoutPinFunction & 0x1F) << 3) |
 802a994:	f88d 7006 	strb.w	r7, [sp, #6]
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] =  (pSetup->uChargePumpCurrentFS & 0x1F);
  
  /* Setup speed up settings */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eCycleSlipReduction << 5);
  uSPIData[LMX249x_REG_IDX(25, 15, 32)]  = (pSetup->uFastLockTimer & 0xFF);
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] |= (pSetup->uFastLockTimer >> 3) & 0xE0;
 802a998:	f023 031f 	bic.w	r3, r3, #31
  uSPIData[LMX249x_REG_IDX(25, 15, 26)] = (pSetup->uReferenceDivider >> 8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] =  pSetup->eReferenceDoubler |
    (pSetup->eOscInMode << 2);
  
  /* Setup Charge Pump configuration */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eChargePumpPulseWidth << 3);
 802a99c:	b2c9      	uxtb	r1, r1
  uSPIData[LMX249x_REG_IDX(25, 15, 28)] = ((pSetup->eChargePumpPolarity) << 5) |
    (pSetup->uChargePumpCurrent & 0x1F);
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] =  (pSetup->uChargePumpCurrentFS & 0x1F);
 802a99e:	f006 061f 	and.w	r6, r6, #31
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] =  pSetup->eReferenceDoubler |
    (pSetup->eOscInMode << 2);
  
  /* Setup Charge Pump configuration */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eChargePumpPulseWidth << 3);
  uSPIData[LMX249x_REG_IDX(25, 15, 28)] = ((pSetup->eChargePumpPolarity) << 5) |
 802a9a2:	f000 001f 	and.w	r0, r0, #31
    (pSetup->uChargePumpCurrent & 0x1F);
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] =  (pSetup->uChargePumpCurrentFS & 0x1F);
  
  /* Setup speed up settings */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eCycleSlipReduction << 5);
 802a9a6:	ea41 1149 	orr.w	r1, r1, r9, lsl #5
  uSPIData[LMX249x_REG_IDX(25, 15, 32)]  = (pSetup->uFastLockTimer & 0xFF);
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] |= (pSetup->uFastLockTimer >> 3) & 0xE0;
 802a9aa:	431e      	orrs	r6, r3
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] =  pSetup->eReferenceDoubler |
    (pSetup->eOscInMode << 2);
  
  /* Setup Charge Pump configuration */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eChargePumpPulseWidth << 3);
  uSPIData[LMX249x_REG_IDX(25, 15, 28)] = ((pSetup->eChargePumpPolarity) << 5) |
 802a9ac:	ea40 104a 	orr.w	r0, r0, sl, lsl #5
  uSPIData[LMX249x_REG_IDX(25, 15, 39)] = ((pSetup->eMUXoutPinFunction & 0x1F) << 3) |
    pSetup->eMUXoutPinDriveMode;
  
  /* Setup Reference Scaling */
  uSPIData[LMX249x_REG_IDX(25, 15, 25)] = (pSetup->uReferenceDivider >> 0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(25, 15, 26)] = (pSetup->uReferenceDivider >> 8) & 0xFF;
 802a9b0:	ea4f 231c 	mov.w	r3, ip, lsr #8
  
  /* Setup lock detection */
  uSPIData[LMX249x_REG_IDX(25, 15, 30)] =  pSetup->uChargePumpThresholdLo & 0x3F;
  uSPIData[LMX249x_REG_IDX(25, 15, 31)] =  pSetup->uChargePumpThresholdHi & 0x3F;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 33)] =  pSetup->uLockDetectNumGoodEdge;
 802a9b4:	f894 e022 	ldrb.w	lr, [r4, #34]	; 0x22
  uSPIData[LMX249x_REG_IDX(25, 15, 28)] = ((pSetup->eChargePumpPolarity) << 5) |
    (pSetup->uChargePumpCurrent & 0x1F);
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] =  (pSetup->uChargePumpCurrentFS & 0x1F);
  
  /* Setup speed up settings */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eCycleSlipReduction << 5);
 802a9b8:	f88d 1012 	strb.w	r1, [sp, #18]
  uSPIData[LMX249x_REG_IDX(25, 15, 32)]  = (pSetup->uFastLockTimer & 0xFF);
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] |= (pSetup->uFastLockTimer >> 3) & 0xE0;
  
  /* Setup lock detection */
  uSPIData[LMX249x_REG_IDX(25, 15, 30)] =  pSetup->uChargePumpThresholdLo & 0x3F;
 802a9bc:	f00b 073f 	and.w	r7, fp, #63	; 0x3f
  uSPIData[LMX249x_REG_IDX(25, 15, 31)] =  pSetup->uChargePumpThresholdHi & 0x3F;
 802a9c0:	f002 023f 	and.w	r2, r2, #63	; 0x3f
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] =  pSetup->eReferenceDoubler |
    (pSetup->eOscInMode << 2);
  
  /* Setup Charge Pump configuration */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eChargePumpPulseWidth << 3);
  uSPIData[LMX249x_REG_IDX(25, 15, 28)] = ((pSetup->eChargePumpPolarity) << 5) |
 802a9c4:	f88d 0011 	strb.w	r0, [sp, #17]
  
  uSPIData[LMX249x_REG_IDX(25, 15, 39)] = ((pSetup->eMUXoutPinFunction & 0x1F) << 3) |
    pSetup->eMUXoutPinDriveMode;
  
  /* Setup Reference Scaling */
  uSPIData[LMX249x_REG_IDX(25, 15, 25)] = (pSetup->uReferenceDivider >> 0) & 0xFF;
 802a9c8:	f88d c014 	strb.w	ip, [sp, #20]
  uSPIData[LMX249x_REG_IDX(25, 15, 26)] = (pSetup->uReferenceDivider >> 8) & 0xFF;
 802a9cc:	f88d 3013 	strb.w	r3, [sp, #19]
  uSPIData[LMX249x_REG_IDX(25, 15, 32)]  = (pSetup->uFastLockTimer & 0xFF);
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] |= (pSetup->uFastLockTimer >> 3) & 0xE0;
  
  /* Setup lock detection */
  uSPIData[LMX249x_REG_IDX(25, 15, 30)] =  pSetup->uChargePumpThresholdLo & 0x3F;
  uSPIData[LMX249x_REG_IDX(25, 15, 31)] =  pSetup->uChargePumpThresholdHi & 0x3F;
 802a9d0:	f88d 200e 	strb.w	r2, [sp, #14]
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] =  (pSetup->uChargePumpCurrentFS & 0x1F);
  
  /* Setup speed up settings */
  uSPIData[LMX249x_REG_IDX(25, 15, 27)] |= (pSetup->eCycleSlipReduction << 5);
  uSPIData[LMX249x_REG_IDX(25, 15, 32)]  = (pSetup->uFastLockTimer & 0xFF);
  uSPIData[LMX249x_REG_IDX(25, 15, 29)] |= (pSetup->uFastLockTimer >> 3) & 0xE0;
 802a9d4:	f88d 6010 	strb.w	r6, [sp, #16]
  
  /* Setup lock detection */
  uSPIData[LMX249x_REG_IDX(25, 15, 30)] =  pSetup->uChargePumpThresholdLo & 0x3F;
 802a9d8:	f88d 700f 	strb.w	r7, [sp, #15]
  uSPIData[LMX249x_REG_IDX(25, 15, 31)] =  pSetup->uChargePumpThresholdHi & 0x3F;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 33)] =  pSetup->uLockDetectNumGoodEdge;
 802a9dc:	f88d e00c 	strb.w	lr, [sp, #12]
  uSPIData[LMX249x_REG_IDX(25, 15, 34)] = (pSetup->uLockDetectNumBadEdge & 0x1F) |
 802a9e0:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
    (pSetup->eLockDetectWindow << 5);
 802a9e4:	f894 2024 	ldrb.w	r2, [r4, #36]	; 0x24
  
  uSPIData[0] = 0;
 802a9e8:	f88d 8004 	strb.w	r8, [sp, #4]
  /* Setup lock detection */
  uSPIData[LMX249x_REG_IDX(25, 15, 30)] =  pSetup->uChargePumpThresholdLo & 0x3F;
  uSPIData[LMX249x_REG_IDX(25, 15, 31)] =  pSetup->uChargePumpThresholdHi & 0x3F;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 33)] =  pSetup->uLockDetectNumGoodEdge;
  uSPIData[LMX249x_REG_IDX(25, 15, 34)] = (pSetup->uLockDetectNumBadEdge & 0x1F) |
 802a9ec:	f003 031f 	and.w	r3, r3, #31
 802a9f0:	ea43 1342 	orr.w	r3, r3, r2, lsl #5
    (pSetup->eLockDetectWindow << 5);
  
  uSPIData[0] = 0;
  uSPIData[1] = 25 + 15 - 1;
 802a9f4:	2227      	movs	r2, #39	; 0x27
  /* Setup lock detection */
  uSPIData[LMX249x_REG_IDX(25, 15, 30)] =  pSetup->uChargePumpThresholdLo & 0x3F;
  uSPIData[LMX249x_REG_IDX(25, 15, 31)] =  pSetup->uChargePumpThresholdHi & 0x3F;
  
  uSPIData[LMX249x_REG_IDX(25, 15, 33)] =  pSetup->uLockDetectNumGoodEdge;
  uSPIData[LMX249x_REG_IDX(25, 15, 34)] = (pSetup->uLockDetectNumBadEdge & 0x1F) |
 802a9f6:	f88d 300b 	strb.w	r3, [sp, #11]
    (pSetup->eLockDetectWindow << 5);
  
  uSPIData[0] = 0;
  uSPIData[1] = 25 + 15 - 1;
 802a9fa:	f88d 2005 	strb.w	r2, [sp, #5]
  pThis->sendSPI(uSPIData, 15 + 2, pThis->pDataForSendSPI);
 802a9fe:	a801      	add	r0, sp, #4
 802aa00:	696b      	ldr	r3, [r5, #20]
 802aa02:	69aa      	ldr	r2, [r5, #24]
 802aa04:	2111      	movs	r1, #17
 802aa06:	4798      	blx	r3
}
 802aa08:	b007      	add	sp, #28
 802aa0a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
{
  uint8_t uSPIData[17];
  
  /* Set Internal Parameters */
  pThis->dExternalDivideFactor = (1.0 / pSetup->uExternalDivider); /* inverse RF-divider within the BGT chip */
  pThis->dPFDCycleTime = 1.0f / (pSetup->dReferenceFreq * (pSetup->eReferenceDoubler ? 2.0 : 1.0) / pSetup->uReferenceDivider );
 802aa0e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 802aa12:	e74d      	b.n	802a8b0 <lmx249x_init+0x34>
 802aa14:	3ff00000 	.word	0x3ff00000

0802aa18 <lmx249x_set_power_state>:
}

//============================================================================

void lmx249x_set_power_state(Lmx249x_Object_t* pThis, Lmx249x_Power_State_t eState)
{
 802aa18:	b530      	push	{r4, r5, lr}
 802aa1a:	b083      	sub	sp, #12
  uint8_t uSPIData[3];
  uSPIData[0] = 0;
 802aa1c:	2500      	movs	r5, #0
  uSPIData[1] = 2;
 802aa1e:	2402      	movs	r4, #2
  uSPIData[2] = eState;
 802aa20:	f88d 1006 	strb.w	r1, [sp, #6]
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
 802aa24:	6943      	ldr	r3, [r0, #20]
 802aa26:	6982      	ldr	r2, [r0, #24]
//============================================================================

void lmx249x_set_power_state(Lmx249x_Object_t* pThis, Lmx249x_Power_State_t eState)
{
  uint8_t uSPIData[3];
  uSPIData[0] = 0;
 802aa28:	f88d 5004 	strb.w	r5, [sp, #4]
  uSPIData[1] = 2;
 802aa2c:	f88d 4005 	strb.w	r4, [sp, #5]
  uSPIData[2] = eState;
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
 802aa30:	a801      	add	r0, sp, #4
 802aa32:	2103      	movs	r1, #3
 802aa34:	4798      	blx	r3
}
 802aa36:	b003      	add	sp, #12
 802aa38:	bd30      	pop	{r4, r5, pc}
 802aa3a:	bf00      	nop

0802aa3c <lmx249x_set_frequency>:
//============================================================================

Lmx249x_Error_Code_t lmx249x_set_frequency(Lmx249x_Object_t* pThis, double dBaseFrequency,
                                           Lmx249x_Frac_Order_t eFracOrder,
                                           Lmx249x_Frac_Dither_t eDitherMode)
{
 802aa3c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802aa40:	b084      	sub	sp, #16
  uint32_t iFactorN;
  int32_t iFracDenominator;
  int32_t iFracNumarator;
  
  /* Disable ramp (just in case a ramp is currently in progress) */
  uSPIData[0] = 0;
 802aa42:	2600      	movs	r6, #0
  uSPIData[1] = 58;
 802aa44:	213a      	movs	r1, #58	; 0x3a
//============================================================================

Lmx249x_Error_Code_t lmx249x_set_frequency(Lmx249x_Object_t* pThis, double dBaseFrequency,
                                           Lmx249x_Frac_Order_t eFracOrder,
                                           Lmx249x_Frac_Dither_t eDitherMode)
{
 802aa46:	4604      	mov	r4, r0
 802aa48:	4690      	mov	r8, r2
 802aa4a:	4699      	mov	r9, r3
  
  /* Disable ramp (just in case a ramp is currently in progress) */
  uSPIData[0] = 0;
  uSPIData[1] = 58;
  uSPIData[2] = 0;
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
 802aa4c:	6982      	ldr	r2, [r0, #24]
 802aa4e:	6943      	ldr	r3, [r0, #20]
  int32_t iFracDenominator;
  int32_t iFracNumarator;
  
  /* Disable ramp (just in case a ramp is currently in progress) */
  uSPIData[0] = 0;
  uSPIData[1] = 58;
 802aa50:	f88d 1005 	strb.w	r1, [sp, #5]
  uSPIData[2] = 0;
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
 802aa54:	a801      	add	r0, sp, #4
  uint32_t iFactorN;
  int32_t iFracDenominator;
  int32_t iFracNumarator;
  
  /* Disable ramp (just in case a ramp is currently in progress) */
  uSPIData[0] = 0;
 802aa56:	f88d 6004 	strb.w	r6, [sp, #4]
  uSPIData[1] = 58;
  uSPIData[2] = 0;
 802aa5a:	f88d 6006 	strb.w	r6, [sp, #6]
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
 802aa5e:	2103      	movs	r1, #3
//============================================================================

Lmx249x_Error_Code_t lmx249x_set_frequency(Lmx249x_Object_t* pThis, double dBaseFrequency,
                                           Lmx249x_Frac_Order_t eFracOrder,
                                           Lmx249x_Frac_Dither_t eDitherMode)
{
 802aa60:	f89d 7030 	ldrb.w	r7, [sp, #48]	; 0x30
 802aa64:	f89d 5034 	ldrb.w	r5, [sp, #52]	; 0x34
  
  /* Disable ramp (just in case a ramp is currently in progress) */
  uSPIData[0] = 0;
  uSPIData[1] = 58;
  uSPIData[2] = 0;
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
 802aa68:	4798      	blx	r3
  
  /* Setup frequency */
  dRelFrequency = dBaseFrequency * pThis->dExternalDivideFactor * pThis->dPFDCycleTime;  /* divider ratio between PLL-RF-in and PFD-frequency */
 802aa6a:	e9d4 2300 	ldrd	r2, r3, [r4]
 802aa6e:	4640      	mov	r0, r8
 802aa70:	4649      	mov	r1, r9
 802aa72:	f003 fa49 	bl	802df08 <__aeabi_dmul>
 802aa76:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 802aa7a:	f003 fa45 	bl	802df08 <__aeabi_dmul>
 802aa7e:	4689      	mov	r9, r1
 802aa80:	4680      	mov	r8, r0
  
  iFactorN = (int32_t)dRelFrequency;
 802aa82:	f003 fcdb 	bl	802e43c <__aeabi_d2iz>
 802aa86:	4682      	mov	sl, r0
  dRelFrequency -= iFactorN;
 802aa88:	f003 f9c8 	bl	802de1c <__aeabi_ui2d>
 802aa8c:	4602      	mov	r2, r0
 802aa8e:	460b      	mov	r3, r1
 802aa90:	4640      	mov	r0, r8
 802aa92:	4649      	mov	r1, r9
 802aa94:	f003 f884 	bl	802dba0 <__aeabi_dsub>
  iFracDenominator = 1<<24;
  iFracNumarator = (uint32_t)(dRelFrequency * iFracDenominator + 0.5);
 802aa98:	2200      	movs	r2, #0
 802aa9a:	4b1a      	ldr	r3, [pc, #104]	; (802ab04 <lmx249x_set_frequency+0xc8>)
 802aa9c:	f003 fa34 	bl	802df08 <__aeabi_dmul>
 802aaa0:	2200      	movs	r2, #0
 802aaa2:	4b19      	ldr	r3, [pc, #100]	; (802ab08 <lmx249x_set_frequency+0xcc>)
 802aaa4:	f003 f87e 	bl	802dba4 <__adddf3>
 802aaa8:	f003 fcf0 	bl	802e48c <__aeabi_d2uiz>
  
  uSPIData[LMX249x_REG_IDX(16, 9, 16)] = (int8_t) ((iFactorN >>  0) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 17)] = (int8_t) ((iFactorN >>  8) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 18)] = (int8_t) ((iFactorN >> 16) & 0x03) |
    (eFracOrder << 4)        |
      (eDitherMode << 2);
 802aaac:	00ad      	lsls	r5, r5, #2
 802aaae:	ea45 1707 	orr.w	r7, r5, r7, lsl #4
  iFracDenominator = 1<<24;
  iFracNumarator = (uint32_t)(dRelFrequency * iFracDenominator + 0.5);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 16)] = (int8_t) ((iFactorN >>  0) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 17)] = (int8_t) ((iFactorN >>  8) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 18)] = (int8_t) ((iFactorN >> 16) & 0x03) |
 802aab2:	f3ca 4501 	ubfx	r5, sl, #16, #2
  uSPIData[LMX249x_REG_IDX(16, 9, 19)] = (iFracNumarator >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 20)] = (iFracNumarator >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 21)] = (iFracNumarator >> 16) & 0xFF;
  
  iFracDenominator -= 1;
  uSPIData[LMX249x_REG_IDX(16, 9, 22)] = (iFracDenominator >>  0) & 0xFF;
 802aab6:	23ff      	movs	r3, #255	; 0xff
  iFracDenominator = 1<<24;
  iFracNumarator = (uint32_t)(dRelFrequency * iFracDenominator + 0.5);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 16)] = (int8_t) ((iFactorN >>  0) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 17)] = (int8_t) ((iFactorN >>  8) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 18)] = (int8_t) ((iFactorN >> 16) & 0x03) |
 802aab8:	432f      	orrs	r7, r5
  dRelFrequency -= iFactorN;
  iFracDenominator = 1<<24;
  iFracNumarator = (uint32_t)(dRelFrequency * iFracDenominator + 0.5);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 16)] = (int8_t) ((iFactorN >>  0) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 17)] = (int8_t) ((iFactorN >>  8) & 0xFF);
 802aaba:	ea4f 2e1a 	mov.w	lr, sl, lsr #8
  uSPIData[LMX249x_REG_IDX(16, 9, 18)] = (int8_t) ((iFactorN >> 16) & 0x03) |
    (eFracOrder << 4)        |
      (eDitherMode << 2);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 19)] = (iFracNumarator >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 20)] = (iFracNumarator >>  8) & 0xFF;
 802aabe:	1205      	asrs	r5, r0, #8
  uSPIData[LMX249x_REG_IDX(16, 9, 21)] = (iFracNumarator >> 16) & 0xFF;
 802aac0:	1402      	asrs	r2, r0, #16
  uSPIData[LMX249x_REG_IDX(16, 9, 23)] = (iFracDenominator >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 24)] = (iFracDenominator >> 16) & 0xFF;
  
  /* Send register sequence to PLL */
  uSPIData[0] = 0;
  uSPIData[1] = 16 + 9 - 1;
 802aac2:	2118      	movs	r1, #24
  uSPIData[LMX249x_REG_IDX(16, 9, 17)] = (int8_t) ((iFactorN >>  8) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 18)] = (int8_t) ((iFactorN >> 16) & 0x03) |
    (eFracOrder << 4)        |
      (eDitherMode << 2);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 19)] = (iFracNumarator >>  0) & 0xFF;
 802aac4:	f88d 000b 	strb.w	r0, [sp, #11]
  uSPIData[LMX249x_REG_IDX(16, 9, 20)] = (iFracNumarator >>  8) & 0xFF;
 802aac8:	f88d 500a 	strb.w	r5, [sp, #10]
  uSPIData[LMX249x_REG_IDX(16, 9, 24)] = (iFracDenominator >> 16) & 0xFF;
  
  /* Send register sequence to PLL */
  uSPIData[0] = 0;
  uSPIData[1] = 16 + 9 - 1;
  pThis->sendSPI(uSPIData, 9 + 2, pThis->pDataForSendSPI);
 802aacc:	a801      	add	r0, sp, #4
    (eFracOrder << 4)        |
      (eDitherMode << 2);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 19)] = (iFracNumarator >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 20)] = (iFracNumarator >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 21)] = (iFracNumarator >> 16) & 0xFF;
 802aace:	f88d 2009 	strb.w	r2, [sp, #9]
  uSPIData[LMX249x_REG_IDX(16, 9, 23)] = (iFracDenominator >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 24)] = (iFracDenominator >> 16) & 0xFF;
  
  /* Send register sequence to PLL */
  uSPIData[0] = 0;
  uSPIData[1] = 16 + 9 - 1;
 802aad2:	f88d 1005 	strb.w	r1, [sp, #5]
  iFactorN = (int32_t)dRelFrequency;
  dRelFrequency -= iFactorN;
  iFracDenominator = 1<<24;
  iFracNumarator = (uint32_t)(dRelFrequency * iFracDenominator + 0.5);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 16)] = (int8_t) ((iFactorN >>  0) & 0xFF);
 802aad6:	f88d a00e 	strb.w	sl, [sp, #14]
  uSPIData[LMX249x_REG_IDX(16, 9, 22)] = (iFracDenominator >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 23)] = (iFracDenominator >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 24)] = (iFracDenominator >> 16) & 0xFF;
  
  /* Send register sequence to PLL */
  uSPIData[0] = 0;
 802aada:	f88d 6004 	strb.w	r6, [sp, #4]
  iFracDenominator = 1<<24;
  iFracNumarator = (uint32_t)(dRelFrequency * iFracDenominator + 0.5);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 16)] = (int8_t) ((iFactorN >>  0) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 17)] = (int8_t) ((iFactorN >>  8) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 18)] = (int8_t) ((iFactorN >> 16) & 0x03) |
 802aade:	f88d 700c 	strb.w	r7, [sp, #12]
  dRelFrequency -= iFactorN;
  iFracDenominator = 1<<24;
  iFracNumarator = (uint32_t)(dRelFrequency * iFracDenominator + 0.5);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 16)] = (int8_t) ((iFactorN >>  0) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 17)] = (int8_t) ((iFactorN >>  8) & 0xFF);
 802aae2:	f88d e00d 	strb.w	lr, [sp, #13]
  uSPIData[LMX249x_REG_IDX(16, 9, 24)] = (iFracDenominator >> 16) & 0xFF;
  
  /* Send register sequence to PLL */
  uSPIData[0] = 0;
  uSPIData[1] = 16 + 9 - 1;
  pThis->sendSPI(uSPIData, 9 + 2, pThis->pDataForSendSPI);
 802aae6:	6965      	ldr	r5, [r4, #20]
 802aae8:	69a2      	ldr	r2, [r4, #24]
  uSPIData[LMX249x_REG_IDX(16, 9, 19)] = (iFracNumarator >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 20)] = (iFracNumarator >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 21)] = (iFracNumarator >> 16) & 0xFF;
  
  iFracDenominator -= 1;
  uSPIData[LMX249x_REG_IDX(16, 9, 22)] = (iFracDenominator >>  0) & 0xFF;
 802aaea:	f88d 3008 	strb.w	r3, [sp, #8]
  uSPIData[LMX249x_REG_IDX(16, 9, 23)] = (iFracDenominator >>  8) & 0xFF;
 802aaee:	f88d 3007 	strb.w	r3, [sp, #7]
  uSPIData[LMX249x_REG_IDX(16, 9, 24)] = (iFracDenominator >> 16) & 0xFF;
 802aaf2:	f88d 3006 	strb.w	r3, [sp, #6]
  
  /* Send register sequence to PLL */
  uSPIData[0] = 0;
  uSPIData[1] = 16 + 9 - 1;
  pThis->sendSPI(uSPIData, 9 + 2, pThis->pDataForSendSPI);
 802aaf6:	210b      	movs	r1, #11
 802aaf8:	47a8      	blx	r5
  
  return (LMX249x_ERROR_CODE_OK);
}
 802aafa:	4630      	mov	r0, r6
 802aafc:	b004      	add	sp, #16
 802aafe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802ab02:	bf00      	nop
 802ab04:	41700000 	.word	0x41700000
 802ab08:	3fe00000 	.word	0x3fe00000

0802ab0c <lmx249x_configure_ramps>:

Lmx249x_Error_Code_t lmx249x_configure_ramps(Lmx249x_Object_t* pThis,
                                             const Lmx249x_Ramp_Global_t* pGlobalSettings,
                                             const Lmx249x_Ramp_Section_t* pRampSections,
                                             uint8_t uNumSections)
{
 802ab0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int64_t iRampLimitLow;
  int64_t iRampLimitHigh;
  int64_t iFSKDev;
  
  /* Check if the number of range is in a valid range */
  if ((uNumSections < 1) || (uNumSections > 8))
 802ab10:	f103 3eff 	add.w	lr, r3, #4294967295
 802ab14:	f1be 0f07 	cmp.w	lr, #7

Lmx249x_Error_Code_t lmx249x_configure_ramps(Lmx249x_Object_t* pThis,
                                             const Lmx249x_Ramp_Global_t* pGlobalSettings,
                                             const Lmx249x_Ramp_Section_t* pRampSections,
                                             uint8_t uNumSections)
{
 802ab18:	b095      	sub	sp, #84	; 0x54
  uint8_t uSPIData[29];  /* Data buffer that will be passed to the SPI interface */
  const double dFrequencyToNFactor = pThis->dExternalDivideFactor * pThis->dPFDCycleTime;
 802ab1a:	e9d0 6700 	ldrd	r6, r7, [r0]
 802ab1e:	e9d0 4502 	ldrd	r4, r5, [r0, #8]
  int64_t iRampLimitLow;
  int64_t iRampLimitHigh;
  int64_t iFSKDev;
  
  /* Check if the number of range is in a valid range */
  if ((uNumSections < 1) || (uNumSections > 8))
 802ab22:	d903      	bls.n	802ab2c <lmx249x_configure_ramps+0x20>
    return (LMX249x_ERROR_CODE_INVALID_NUMBER_OF_RAMPS);
 802ab24:	2001      	movs	r0, #1
  uSPIData[0] = 0;
  uSPIData[1] = 58 + 27 - 1;
  pThis->sendSPI(uSPIData, 27 + 2, pThis->pDataForSendSPI);
  
  return (LMX249x_ERROR_CODE_OK);
}
 802ab26:	b015      	add	sp, #84	; 0x54
 802ab28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802ab2c:	4683      	mov	fp, r0
 802ab2e:	920a      	str	r2, [sp, #40]	; 0x28
 802ab30:	910b      	str	r1, [sp, #44]	; 0x2c
 802ab32:	9309      	str	r3, [sp, #36]	; 0x24
                                             const Lmx249x_Ramp_Global_t* pGlobalSettings,
                                             const Lmx249x_Ramp_Section_t* pRampSections,
                                             uint8_t uNumSections)
{
  uint8_t uSPIData[29];  /* Data buffer that will be passed to the SPI interface */
  const double dFrequencyToNFactor = pThis->dExternalDivideFactor * pThis->dPFDCycleTime;
 802ab34:	4639      	mov	r1, r7
 802ab36:	462b      	mov	r3, r5
 802ab38:	4622      	mov	r2, r4
 802ab3a:	4630      	mov	r0, r6
 802ab3c:	f003 f9e4 	bl	802df08 <__aeabi_dmul>
  /* Check if the number of range is in a valid range */
  if ((uNumSections < 1) || (uNumSections > 8))
    return (LMX249x_ERROR_CODE_INVALID_NUMBER_OF_RAMPS);
  
  /* Disable ramp (just in case a ramp is currently in progress) */
  uSPIData[0] = 0;
 802ab40:	2700      	movs	r7, #0
  uSPIData[1] = 58;
 802ab42:	233a      	movs	r3, #58	; 0x3a
                                             const Lmx249x_Ramp_Global_t* pGlobalSettings,
                                             const Lmx249x_Ramp_Section_t* pRampSections,
                                             uint8_t uNumSections)
{
  uint8_t uSPIData[29];  /* Data buffer that will be passed to the SPI interface */
  const double dFrequencyToNFactor = pThis->dExternalDivideFactor * pThis->dPFDCycleTime;
 802ab44:	e9cd 0104 	strd	r0, r1, [sp, #16]
  if ((uNumSections < 1) || (uNumSections > 8))
    return (LMX249x_ERROR_CODE_INVALID_NUMBER_OF_RAMPS);
  
  /* Disable ramp (just in case a ramp is currently in progress) */
  uSPIData[0] = 0;
  uSPIData[1] = 58;
 802ab48:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
  /* Check if the number of range is in a valid range */
  if ((uNumSections < 1) || (uNumSections > 8))
    return (LMX249x_ERROR_CODE_INVALID_NUMBER_OF_RAMPS);
  
  /* Disable ramp (just in case a ramp is currently in progress) */
  uSPIData[0] = 0;
 802ab4c:	f88d 7030 	strb.w	r7, [sp, #48]	; 0x30
  uSPIData[1] = 58;
  uSPIData[2] = 0;
 802ab50:	f88d 7032 	strb.w	r7, [sp, #50]	; 0x32
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
 802ab54:	a80c      	add	r0, sp, #48	; 0x30
 802ab56:	f8db 3014 	ldr.w	r3, [fp, #20]
 802ab5a:	f8db 2018 	ldr.w	r2, [fp, #24]
 802ab5e:	2103      	movs	r1, #3
  
  /* Setup up the ramp sections */
  for (uIdx = 0; uIdx < uNumSections; ++uIdx)
 802ab60:	46b8      	mov	r8, r7
  
  /* Disable ramp (just in case a ramp is currently in progress) */
  uSPIData[0] = 0;
  uSPIData[1] = 58;
  uSPIData[2] = 0;
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
 802ab62:	4798      	blx	r3
 802ab64:	463d      	mov	r5, r7
  
  /* Setup up the ramp sections */
  for (uIdx = 0; uIdx < uNumSections; ++uIdx)
 802ab66:	9707      	str	r7, [sp, #28]
 802ab68:	9708      	str	r7, [sp, #32]
 802ab6a:	9700      	str	r7, [sp, #0]
 802ab6c:	46c2      	mov	sl, r8
 802ab6e:	e066      	b.n	802ac3e <lmx249x_configure_ramps+0x132>
    uRampLength =  (int32_t) ((pThisSection->dTramp) / pThis->dPFDCycleTime);
    if (uRampLength > 0xFFFF)
    {
      /* If the ramp is too long, divide ramp length by two and set the delay flag which doubles the ramp time */
      uRampLength >>= 1;
      uDelayFlag = 0x80;
 802ab70:	2380      	movs	r3, #128	; 0x80
 802ab72:	f894 901a 	ldrb.w	r9, [r4, #26]
 802ab76:	9307      	str	r3, [sp, #28]
    /* Convert given ramp parameters to counter values */
    uRampLength =  (int32_t) ((pThisSection->dTramp) / pThis->dPFDCycleTime);
    if (uRampLength > 0xFFFF)
    {
      /* If the ramp is too long, divide ramp length by two and set the delay flag which doubles the ramp time */
      uRampLength >>= 1;
 802ab78:	0845      	lsrs	r5, r0, #1
    * at least 1, otherwise the counter seems to wrap around and the section will be longer than expected.
    */
    if ((uRampLength == 0) && (pThisSection->eNextTrig == LMX249x_RAMP_NEXT_TRIG_RAMPX_LEN))
      uRampLength = 1;
    
    uCounterInc =  (int32_t) (pThisSection->dFreqShift * dFrequencyToNFactor * dFracDenominator / (double)uRampLength);
 802ab7a:	e9d4 2300 	ldrd	r2, r3, [r4]
 802ab7e:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 802ab82:	f003 f9c1 	bl	802df08 <__aeabi_dmul>
 802ab86:	2200      	movs	r2, #0
 802ab88:	4b3b      	ldr	r3, [pc, #236]	; (802ac78 <lmx249x_configure_ramps+0x16c>)
 802ab8a:	f003 f9bd 	bl	802df08 <__aeabi_dmul>
 802ab8e:	4606      	mov	r6, r0
 802ab90:	4628      	mov	r0, r5
 802ab92:	460f      	mov	r7, r1
 802ab94:	f003 f942 	bl	802de1c <__aeabi_ui2d>
 802ab98:	4602      	mov	r2, r0
 802ab9a:	460b      	mov	r3, r1
 802ab9c:	4630      	mov	r0, r6
 802ab9e:	4639      	mov	r1, r7
 802aba0:	f003 fadc 	bl	802e15c <__aeabi_ddiv>
 802aba4:	f003 fc4a 	bl	802e43c <__aeabi_d2iz>
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 5)] = ((uRampLength >> 8) & 0xFF);
    
    /* Set flags */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 6)] = ((int8_t) ((pThisSection->uNext &0x07)  << 5)) |
      ((int8_t)  (pThisSection->eNextTrig << 3)) |
        ((int8_t)  (pThisSection->eReset    << 2)) |
 802aba8:	7e63      	ldrb	r3, [r4, #25]
    /* Set ramp_length */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 4)] = ((uRampLength >> 0) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 5)] = ((uRampLength >> 8) & 0xFF);
    
    /* Set flags */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 6)] = ((int8_t) ((pThisSection->uNext &0x07)  << 5)) |
 802abaa:	7ee6      	ldrb	r6, [r4, #27]
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 1)] = (uint8_t) ((uCounterInc >>  8) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 2)] = (uint8_t) ((uCounterInc >> 16) & 0xFF);
    
    /* Set flags and increment */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 3)] = uDelayFlag |
      (uint8_t) ((pThisSection->eFastlock) << 6) |
 802abac:	7a22      	ldrb	r2, [r4, #8]
 802abae:	7e21      	ldrb	r1, [r4, #24]
        ((int8_t)  (pThisSection->eReset    << 2)) |
          ((int8_t)  (pThisSection->eFlag   << 0));
    
    /* Set comparator enable bit */
    uCompEnMask = 1 << uIdx;
    uComparator0Enable |= (pThisSection->eComparators & LMX249x_RAMP_USE_COMPARATOR_1) ? uCompEnMask : 0;
 802abb0:	7f24      	ldrb	r4, [r4, #28]
      uRampLength = 1;
    
    uCounterInc =  (int32_t) (pThisSection->dFreqShift * dFrequencyToNFactor * dFracDenominator / (double)uRampLength);
    
    /* Set ramp_increment */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 0)] = (uint8_t) ((uCounterInc >>  0) & 0xFF);
 802abb2:	f88d 0038 	strb.w	r0, [sp, #56]	; 0x38
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 5)] = ((uRampLength >> 8) & 0xFF);
    
    /* Set flags */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 6)] = ((int8_t) ((pThisSection->uNext &0x07)  << 5)) |
      ((int8_t)  (pThisSection->eNextTrig << 3)) |
        ((int8_t)  (pThisSection->eReset    << 2)) |
 802abb6:	009b      	lsls	r3, r3, #2
 802abb8:	ea43 1646 	orr.w	r6, r3, r6, lsl #5
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 0)] = (uint8_t) ((uCounterInc >>  0) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 1)] = (uint8_t) ((uCounterInc >>  8) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 2)] = (uint8_t) ((uCounterInc >> 16) & 0xFF);
    
    /* Set flags and increment */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 3)] = uDelayFlag |
 802abbc:	9b07      	ldr	r3, [sp, #28]
      (uint8_t) ((pThisSection->eFastlock) << 6) |
        (uint8_t) ((uCounterInc >> 24) & 0x3F);
    
    /* Set ramp_length */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 4)] = ((uRampLength >> 0) & 0xFF);
 802abbe:	f88d 5034 	strb.w	r5, [sp, #52]	; 0x34
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 0)] = (uint8_t) ((uCounterInc >>  0) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 1)] = (uint8_t) ((uCounterInc >>  8) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 2)] = (uint8_t) ((uCounterInc >> 16) & 0xFF);
    
    /* Set flags and increment */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 3)] = uDelayFlag |
 802abc2:	ea43 1282 	orr.w	r2, r3, r2, lsl #6
      ((int8_t)  (pThisSection->eNextTrig << 3)) |
        ((int8_t)  (pThisSection->eReset    << 2)) |
          ((int8_t)  (pThisSection->eFlag   << 0));
    
    /* Set comparator enable bit */
    uCompEnMask = 1 << uIdx;
 802abc6:	9b00      	ldr	r3, [sp, #0]
 802abc8:	4331      	orrs	r1, r6
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 0)] = (uint8_t) ((uCounterInc >>  0) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 1)] = (uint8_t) ((uCounterInc >>  8) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 2)] = (uint8_t) ((uCounterInc >> 16) & 0xFF);
    
    /* Set flags and increment */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 3)] = uDelayFlag |
 802abca:	f3c0 6e05 	ubfx	lr, r0, #24, #6
      ((int8_t)  (pThisSection->eNextTrig << 3)) |
        ((int8_t)  (pThisSection->eReset    << 2)) |
          ((int8_t)  (pThisSection->eFlag   << 0));
    
    /* Set comparator enable bit */
    uCompEnMask = 1 << uIdx;
 802abce:	2701      	movs	r7, #1
 802abd0:	409f      	lsls	r7, r3
    
    uCounterInc =  (int32_t) (pThisSection->dFreqShift * dFrequencyToNFactor * dFracDenominator / (double)uRampLength);
    
    /* Set ramp_increment */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 0)] = (uint8_t) ((uCounterInc >>  0) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 1)] = (uint8_t) ((uCounterInc >>  8) & 0xFF);
 802abd2:	1206      	asrs	r6, r0, #8
      (uint8_t) ((pThisSection->eFastlock) << 6) |
        (uint8_t) ((uCounterInc >> 24) & 0x3F);
    
    /* Set ramp_length */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 4)] = ((uRampLength >> 0) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 5)] = ((uRampLength >> 8) & 0xFF);
 802abd4:	0a2b      	lsrs	r3, r5, #8
    
    /* Set flags */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 6)] = ((int8_t) ((pThisSection->uNext &0x07)  << 5)) |
 802abd6:	ea41 01c9 	orr.w	r1, r1, r9, lsl #3
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 0)] = (uint8_t) ((uCounterInc >>  0) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 1)] = (uint8_t) ((uCounterInc >>  8) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 2)] = (uint8_t) ((uCounterInc >> 16) & 0xFF);
    
    /* Set flags and increment */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 3)] = uDelayFlag |
 802abda:	ea4e 0202 	orr.w	r2, lr, r2
        ((int8_t)  (pThisSection->eReset    << 2)) |
          ((int8_t)  (pThisSection->eFlag   << 0));
    
    /* Set comparator enable bit */
    uCompEnMask = 1 << uIdx;
    uComparator0Enable |= (pThisSection->eComparators & LMX249x_RAMP_USE_COMPARATOR_1) ? uCompEnMask : 0;
 802abde:	f004 0402 	and.w	r4, r4, #2
    uCounterInc =  (int32_t) (pThisSection->dFreqShift * dFrequencyToNFactor * dFracDenominator / (double)uRampLength);
    
    /* Set ramp_increment */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 0)] = (uint8_t) ((uCounterInc >>  0) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 1)] = (uint8_t) ((uCounterInc >>  8) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 2)] = (uint8_t) ((uCounterInc >> 16) & 0xFF);
 802abe2:	1400      	asrs	r0, r0, #16
      (uint8_t) ((pThisSection->eFastlock) << 6) |
        (uint8_t) ((uCounterInc >> 24) & 0x3F);
    
    /* Set ramp_length */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 4)] = ((uRampLength >> 0) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 5)] = ((uRampLength >> 8) & 0xFF);
 802abe4:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
        ((int8_t)  (pThisSection->eReset    << 2)) |
          ((int8_t)  (pThisSection->eFlag   << 0));
    
    /* Set comparator enable bit */
    uCompEnMask = 1 << uIdx;
    uComparator0Enable |= (pThisSection->eComparators & LMX249x_RAMP_USE_COMPARATOR_1) ? uCompEnMask : 0;
 802abe8:	b2ff      	uxtb	r7, r7
    /* Set ramp_length */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 4)] = ((uRampLength >> 0) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 5)] = ((uRampLength >> 8) & 0xFF);
    
    /* Set flags */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 6)] = ((int8_t) ((pThisSection->uNext &0x07)  << 5)) |
 802abea:	f88d 1032 	strb.w	r1, [sp, #50]	; 0x32
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 0)] = (uint8_t) ((uCounterInc >>  0) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 1)] = (uint8_t) ((uCounterInc >>  8) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 2)] = (uint8_t) ((uCounterInc >> 16) & 0xFF);
    
    /* Set flags and increment */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 3)] = uDelayFlag |
 802abee:	f88d 2035 	strb.w	r2, [sp, #53]	; 0x35
        ((int8_t)  (pThisSection->eReset    << 2)) |
          ((int8_t)  (pThisSection->eFlag   << 0));
    
    /* Set comparator enable bit */
    uCompEnMask = 1 << uIdx;
    uComparator0Enable |= (pThisSection->eComparators & LMX249x_RAMP_USE_COMPARATOR_1) ? uCompEnMask : 0;
 802abf2:	f004 03ff 	and.w	r3, r4, #255	; 0xff
    
    uCounterInc =  (int32_t) (pThisSection->dFreqShift * dFrequencyToNFactor * dFracDenominator / (double)uRampLength);
    
    /* Set ramp_increment */
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 0)] = (uint8_t) ((uCounterInc >>  0) & 0xFF);
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 1)] = (uint8_t) ((uCounterInc >>  8) & 0xFF);
 802abf6:	f88d 6037 	strb.w	r6, [sp, #55]	; 0x37
    uSPIData[LMX249x_REG_IDX(0, uNumRegs, 2)] = (uint8_t) ((uCounterInc >> 16) & 0xFF);
 802abfa:	f88d 0036 	strb.w	r0, [sp, #54]	; 0x36
        ((int8_t)  (pThisSection->eReset    << 2)) |
          ((int8_t)  (pThisSection->eFlag   << 0));
    
    /* Set comparator enable bit */
    uCompEnMask = 1 << uIdx;
    uComparator0Enable |= (pThisSection->eComparators & LMX249x_RAMP_USE_COMPARATOR_1) ? uCompEnMask : 0;
 802abfe:	2c00      	cmp	r4, #0
 802ac00:	d038      	beq.n	802ac74 <lmx249x_configure_ramps+0x168>
 802ac02:	9b08      	ldr	r3, [sp, #32]
 802ac04:	433b      	orrs	r3, r7
 802ac06:	9308      	str	r3, [sp, #32]
    uComparator1Enable |= (pThisSection->eComparators & LMX249x_RAMP_USE_COMPARATOR_1) ? uCompEnMask : 0;
    
    /* Write the register data to the chip, write highest address (the one of the register written first) at the
    * beginning of the data buffer.
    */
    uBaseRegister += uNumRegs - 1;
 802ac08:	9b02      	ldr	r3, [sp, #8]
 802ac0a:	335c      	adds	r3, #92	; 0x5c
 802ac0c:	b29b      	uxth	r3, r3
    uSPIData[0] = (uint8_t)((uBaseRegister >> 8) & 0xFF);
 802ac0e:	0a1a      	lsrs	r2, r3, #8
    uSPIData[1] = (uint8_t)((uBaseRegister >> 0) & 0xFF);
 802ac10:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    
    /* Write the register data to the chip, write highest address (the one of the register written first) at the
    * beginning of the data buffer.
    */
    uBaseRegister += uNumRegs - 1;
    uSPIData[0] = (uint8_t)((uBaseRegister >> 8) & 0xFF);
 802ac14:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
    uSPIData[1] = (uint8_t)((uBaseRegister >> 0) & 0xFF);
    pThis->sendSPI(uSPIData, uNumRegs + 2, pThis->pDataForSendSPI);
 802ac18:	f8db 3014 	ldr.w	r3, [fp, #20]
 802ac1c:	f8db 2018 	ldr.w	r2, [fp, #24]
 802ac20:	2109      	movs	r1, #9
 802ac22:	a80c      	add	r0, sp, #48	; 0x30
 802ac24:	f108 0801 	add.w	r8, r8, #1
 802ac28:	4798      	blx	r3
 802ac2a:	fa5f f888 	uxtb.w	r8, r8
  uSPIData[1] = 58;
  uSPIData[2] = 0;
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
  
  /* Setup up the ramp sections */
  for (uIdx = 0; uIdx < uNumSections; ++uIdx)
 802ac2e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802ac30:	fa4f f588 	sxtb.w	r5, r8
 802ac34:	429d      	cmp	r5, r3
          ((int8_t)  (pThisSection->eFlag   << 0));
    
    /* Set comparator enable bit */
    uCompEnMask = 1 << uIdx;
    uComparator0Enable |= (pThisSection->eComparators & LMX249x_RAMP_USE_COMPARATOR_1) ? uCompEnMask : 0;
    uComparator1Enable |= (pThisSection->eComparators & LMX249x_RAMP_USE_COMPARATOR_1) ? uCompEnMask : 0;
 802ac36:	ea47 0a0a 	orr.w	sl, r7, sl
  uSPIData[1] = 58;
  uSPIData[2] = 0;
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
  
  /* Setup up the ramp sections */
  for (uIdx = 0; uIdx < uNumSections; ++uIdx)
 802ac3a:	9500      	str	r5, [sp, #0]
 802ac3c:	da1e      	bge.n	802ac7c <lmx249x_configure_ramps+0x170>
  {
    /* Setup register buffer */
    uBaseRegister = (86 + uIdx * 7);
    pThisSection = &pRampSections[uIdx];
 802ac3e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802ac40:	eb03 1445 	add.w	r4, r3, r5, lsl #5
  
  /* Setup up the ramp sections */
  for (uIdx = 0; uIdx < uNumSections; ++uIdx)
  {
    /* Setup register buffer */
    uBaseRegister = (86 + uIdx * 7);
 802ac44:	ebc5 05c5 	rsb	r5, r5, r5, lsl #3
    pThisSection = &pRampSections[uIdx];
    
    /* Convert given ramp parameters to counter values */
    uRampLength =  (int32_t) ((pThisSection->dTramp) / pThis->dPFDCycleTime);
 802ac48:	e9db 2302 	ldrd	r2, r3, [fp, #8]
  
  /* Setup up the ramp sections */
  for (uIdx = 0; uIdx < uNumSections; ++uIdx)
  {
    /* Setup register buffer */
    uBaseRegister = (86 + uIdx * 7);
 802ac4c:	b2ad      	uxth	r5, r5
    pThisSection = &pRampSections[uIdx];
    
    /* Convert given ramp parameters to counter values */
    uRampLength =  (int32_t) ((pThisSection->dTramp) / pThis->dPFDCycleTime);
 802ac4e:	e9d4 0104 	ldrd	r0, r1, [r4, #16]
  
  /* Setup up the ramp sections */
  for (uIdx = 0; uIdx < uNumSections; ++uIdx)
  {
    /* Setup register buffer */
    uBaseRegister = (86 + uIdx * 7);
 802ac52:	9502      	str	r5, [sp, #8]
    pThisSection = &pRampSections[uIdx];
    
    /* Convert given ramp parameters to counter values */
    uRampLength =  (int32_t) ((pThisSection->dTramp) / pThis->dPFDCycleTime);
 802ac54:	f003 fa82 	bl	802e15c <__aeabi_ddiv>
 802ac58:	f003 fbf0 	bl	802e43c <__aeabi_d2iz>
    if (uRampLength > 0xFFFF)
 802ac5c:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
    /* Setup register buffer */
    uBaseRegister = (86 + uIdx * 7);
    pThisSection = &pRampSections[uIdx];
    
    /* Convert given ramp parameters to counter values */
    uRampLength =  (int32_t) ((pThisSection->dTramp) / pThis->dPFDCycleTime);
 802ac60:	4605      	mov	r5, r0
    if (uRampLength > 0xFFFF)
 802ac62:	d285      	bcs.n	802ab70 <lmx249x_configure_ramps+0x64>
    }
    
    /* If the transition to the next sections is triggered by the length of this section, the length must be
    * at least 1, otherwise the counter seems to wrap around and the section will be longer than expected.
    */
    if ((uRampLength == 0) && (pThisSection->eNextTrig == LMX249x_RAMP_NEXT_TRIG_RAMPX_LEN))
 802ac64:	f894 901a 	ldrb.w	r9, [r4, #26]
 802ac68:	2800      	cmp	r0, #0
 802ac6a:	d186      	bne.n	802ab7a <lmx249x_configure_ramps+0x6e>
 802ac6c:	fab9 f589 	clz	r5, r9
 802ac70:	096d      	lsrs	r5, r5, #5
 802ac72:	e782      	b.n	802ab7a <lmx249x_configure_ramps+0x6e>
          ((int8_t)  (pThisSection->eFlag   << 0));
    
    /* Set comparator enable bit */
    uCompEnMask = 1 << uIdx;
    uComparator0Enable |= (pThisSection->eComparators & LMX249x_RAMP_USE_COMPARATOR_1) ? uCompEnMask : 0;
    uComparator1Enable |= (pThisSection->eComparators & LMX249x_RAMP_USE_COMPARATOR_1) ? uCompEnMask : 0;
 802ac74:	461f      	mov	r7, r3
 802ac76:	e7c7      	b.n	802ac08 <lmx249x_configure_ramps+0xfc>
 802ac78:	41700000 	.word	0x41700000
  /* Wet comparator enable bits */
  uSPIData[LMX249x_REG_IDX(58, 27, 64)] = uComparator0Enable;
  uSPIData[LMX249x_REG_IDX(58, 27, 69)] = uComparator1Enable;
  
  /* Setup base frequency */
  dRelFrequency = pGlobalSettings->dBaseFrequency * dFrequencyToNFactor;  /* divider ratio between PLL-RF-in and PFD-frequency */
 802ac7c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    uSPIData[1] = (uint8_t)((uBaseRegister >> 0) & 0xFF);
    pThis->sendSPI(uSPIData, uNumRegs + 2, pThis->pDataForSendSPI);
  }
  
  /* Wet comparator enable bits */
  uSPIData[LMX249x_REG_IDX(58, 27, 64)] = uComparator0Enable;
 802ac7e:	f89d 4020 	ldrb.w	r4, [sp, #32]
 802ac82:	f88d 4046 	strb.w	r4, [sp, #70]	; 0x46
  uSPIData[LMX249x_REG_IDX(58, 27, 69)] = uComparator1Enable;
  
  /* Setup base frequency */
  dRelFrequency = pGlobalSettings->dBaseFrequency * dFrequencyToNFactor;  /* divider ratio between PLL-RF-in and PFD-frequency */
 802ac86:	e9d3 2300 	ldrd	r2, r3, [r3]
 802ac8a:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    pThis->sendSPI(uSPIData, uNumRegs + 2, pThis->pDataForSendSPI);
  }
  
  /* Wet comparator enable bits */
  uSPIData[LMX249x_REG_IDX(58, 27, 64)] = uComparator0Enable;
  uSPIData[LMX249x_REG_IDX(58, 27, 69)] = uComparator1Enable;
 802ac8e:	f88d a041 	strb.w	sl, [sp, #65]	; 0x41
  
  /* Setup base frequency */
  dRelFrequency = pGlobalSettings->dBaseFrequency * dFrequencyToNFactor;  /* divider ratio between PLL-RF-in and PFD-frequency */
 802ac92:	f003 f939 	bl	802df08 <__aeabi_dmul>
 802ac96:	460f      	mov	r7, r1
 802ac98:	4606      	mov	r6, r0
  
  iFactorN = (int32_t)dRelFrequency;
 802ac9a:	f003 fbcf 	bl	802e43c <__aeabi_d2iz>
 802ac9e:	4680      	mov	r8, r0
  dRelFrequency -= iFactorN;
 802aca0:	f003 f8bc 	bl	802de1c <__aeabi_ui2d>
 802aca4:	4604      	mov	r4, r0
 802aca6:	460d      	mov	r5, r1
 802aca8:	4622      	mov	r2, r4
 802acaa:	462b      	mov	r3, r5
 802acac:	4630      	mov	r0, r6
 802acae:	4639      	mov	r1, r7
 802acb0:	f002 ff76 	bl	802dba0 <__aeabi_dsub>
  iFracNumarator = (uint32_t) (dRelFrequency * dFracDenominator);
 802acb4:	2200      	movs	r2, #0
 802acb6:	4ba2      	ldr	r3, [pc, #648]	; (802af40 <lmx249x_configure_ramps+0x434>)
 802acb8:	f003 f926 	bl	802df08 <__aeabi_dmul>
 802acbc:	f003 fbe6 	bl	802e48c <__aeabi_d2uiz>
  
  uSPIData[LMX249x_REG_IDX(16, 9, 16)] = (int8_t) ((iFactorN >>  0) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 17)] = (int8_t) ((iFactorN >>  8) & 0xFF);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 18)] = (int8_t) (((iFactorN >> 16) & 0x03) | (pGlobalSettings->eFracOrder << 4) | (pGlobalSettings->eDitherMode << 2));
 802acc0:	990b      	ldr	r1, [sp, #44]	; 0x2c
  
  iFactorN = (int32_t)dRelFrequency;
  dRelFrequency -= iFactorN;
  iFracNumarator = (uint32_t) (dRelFrequency * dFracDenominator);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 16)] = (int8_t) ((iFactorN >>  0) & 0xFF);
 802acc2:	f88d 803a 	strb.w	r8, [sp, #58]	; 0x3a
  uSPIData[LMX249x_REG_IDX(16, 9, 17)] = (int8_t) ((iFactorN >>  8) & 0xFF);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 18)] = (int8_t) (((iFactorN >> 16) & 0x03) | (pGlobalSettings->eFracOrder << 4) | (pGlobalSettings->eDitherMode << 2));
 802acc6:	f891 303a 	ldrb.w	r3, [r1, #58]	; 0x3a
 802acca:	f891 203b 	ldrb.w	r2, [r1, #59]	; 0x3b
  
  uSPIData[LMX249x_REG_IDX(16, 9, 19)] = (iFracNumarator >>  0) & 0xFF;
 802acce:	f88d 0037 	strb.w	r0, [sp, #55]	; 0x37
  iFracNumarator = (uint32_t) (dRelFrequency * dFracDenominator);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 16)] = (int8_t) ((iFactorN >>  0) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 17)] = (int8_t) ((iFactorN >>  8) & 0xFF);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 18)] = (int8_t) (((iFactorN >> 16) & 0x03) | (pGlobalSettings->eFracOrder << 4) | (pGlobalSettings->eDitherMode << 2));
 802acd2:	011b      	lsls	r3, r3, #4
 802acd4:	ea43 0382 	orr.w	r3, r3, r2, lsl #2
 802acd8:	f3c8 4101 	ubfx	r1, r8, #16, #2
  
  uSPIData[LMX249x_REG_IDX(16, 9, 19)] = (iFracNumarator >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 20)] = (iFracNumarator >>  8) & 0xFF;
 802acdc:	ea4f 2e20 	mov.w	lr, r0, asr #8
  uSPIData[LMX249x_REG_IDX(16, 9, 21)] = (iFracNumarator >> 16) & 0xFF;
  
  /* Fractional denominator is always 0xFFFFFF when ramp generator is active */
  uSPIData[LMX249x_REG_IDX(16, 9, 22)] = 0xFF;
 802ace0:	22ff      	movs	r2, #255	; 0xff
  iFracNumarator = (uint32_t) (dRelFrequency * dFracDenominator);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 16)] = (int8_t) ((iFactorN >>  0) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 17)] = (int8_t) ((iFactorN >>  8) & 0xFF);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 18)] = (int8_t) (((iFactorN >> 16) & 0x03) | (pGlobalSettings->eFracOrder << 4) | (pGlobalSettings->eDitherMode << 2));
 802ace2:	4319      	orrs	r1, r3
  
  uSPIData[LMX249x_REG_IDX(16, 9, 19)] = (iFracNumarator >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 20)] = (iFracNumarator >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 21)] = (iFracNumarator >> 16) & 0xFF;
 802ace4:	1407      	asrs	r7, r0, #16
  iFactorN = (int32_t)dRelFrequency;
  dRelFrequency -= iFactorN;
  iFracNumarator = (uint32_t) (dRelFrequency * dFracDenominator);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 16)] = (int8_t) ((iFactorN >>  0) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 17)] = (int8_t) ((iFactorN >>  8) & 0xFF);
 802ace6:	ea4f 2318 	mov.w	r3, r8, lsr #8
  uSPIData[LMX249x_REG_IDX(16, 9, 23)] = 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 24)] = 0xFF;
  
  /*Send register sequence to PLL */
  uSPIData[0] = 0;
  uSPIData[1] = 16 + 9 - 1;
 802acea:	2618      	movs	r6, #24
  uSPIData[LMX249x_REG_IDX(16, 9, 22)] = 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 23)] = 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 24)] = 0xFF;
  
  /*Send register sequence to PLL */
  uSPIData[0] = 0;
 802acec:	f04f 0800 	mov.w	r8, #0
  uSPIData[LMX249x_REG_IDX(16, 9, 17)] = (int8_t) ((iFactorN >>  8) & 0xFF);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 18)] = (int8_t) (((iFactorN >> 16) & 0x03) | (pGlobalSettings->eFracOrder << 4) | (pGlobalSettings->eDitherMode << 2));
  
  uSPIData[LMX249x_REG_IDX(16, 9, 19)] = (iFracNumarator >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 20)] = (iFracNumarator >>  8) & 0xFF;
 802acf0:	f88d e036 	strb.w	lr, [sp, #54]	; 0x36
  iFracNumarator = (uint32_t) (dRelFrequency * dFracDenominator);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 16)] = (int8_t) ((iFactorN >>  0) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 17)] = (int8_t) ((iFactorN >>  8) & 0xFF);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 18)] = (int8_t) (((iFactorN >> 16) & 0x03) | (pGlobalSettings->eFracOrder << 4) | (pGlobalSettings->eDitherMode << 2));
 802acf4:	f88d 1038 	strb.w	r1, [sp, #56]	; 0x38
  iFactorN = (int32_t)dRelFrequency;
  dRelFrequency -= iFactorN;
  iFracNumarator = (uint32_t) (dRelFrequency * dFracDenominator);
  
  uSPIData[LMX249x_REG_IDX(16, 9, 16)] = (int8_t) ((iFactorN >>  0) & 0xFF);
  uSPIData[LMX249x_REG_IDX(16, 9, 17)] = (int8_t) ((iFactorN >>  8) & 0xFF);
 802acf8:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
  
  uSPIData[LMX249x_REG_IDX(16, 9, 18)] = (int8_t) (((iFactorN >> 16) & 0x03) | (pGlobalSettings->eFracOrder << 4) | (pGlobalSettings->eDitherMode << 2));
  
  uSPIData[LMX249x_REG_IDX(16, 9, 19)] = (iFracNumarator >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 20)] = (iFracNumarator >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 21)] = (iFracNumarator >> 16) & 0xFF;
 802acfc:	f88d 7035 	strb.w	r7, [sp, #53]	; 0x35
  
  /* Fractional denominator is always 0xFFFFFF when ramp generator is active */
  uSPIData[LMX249x_REG_IDX(16, 9, 22)] = 0xFF;
 802ad00:	f88d 2034 	strb.w	r2, [sp, #52]	; 0x34
  uSPIData[LMX249x_REG_IDX(16, 9, 23)] = 0xFF;
 802ad04:	f88d 2033 	strb.w	r2, [sp, #51]	; 0x33
  uSPIData[LMX249x_REG_IDX(16, 9, 24)] = 0xFF;
 802ad08:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
  
  /*Send register sequence to PLL */
  uSPIData[0] = 0;
  uSPIData[1] = 16 + 9 - 1;
 802ad0c:	f88d 6031 	strb.w	r6, [sp, #49]	; 0x31
  pThis->sendSPI(uSPIData, 9 + 2, pThis->pDataForSendSPI);
 802ad10:	f8db 3014 	ldr.w	r3, [fp, #20]
 802ad14:	f8db 2018 	ldr.w	r2, [fp, #24]
  uSPIData[LMX249x_REG_IDX(16, 9, 22)] = 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 23)] = 0xFF;
  uSPIData[LMX249x_REG_IDX(16, 9, 24)] = 0xFF;
  
  /*Send register sequence to PLL */
  uSPIData[0] = 0;
 802ad18:	f88d 8030 	strb.w	r8, [sp, #48]	; 0x30
  uSPIData[1] = 16 + 9 - 1;
  pThis->sendSPI(uSPIData, 9 + 2, pThis->pDataForSendSPI);
 802ad1c:	a80c      	add	r0, sp, #48	; 0x30
 802ad1e:	210b      	movs	r1, #11
 802ad20:	4798      	blx	r3
  /* Setup ramp range and comparator values */
  /* The formula in the LMX249x data sheet for the following settings is very misleading. The used formular was
  * found by debugging. The essence here is to specify the limits as the difference (limFreq - baseFreq), while
  * limFreq is the N factor with fractional part, but baseFreq must be the integer N factor (no rounding, just truncating).
  */
  iRampComp0     = (int64_t) ((pGlobalSettings->dComp0Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
 802ad22:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 802ad24:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 802ad28:	e9d6 2308 	ldrd	r2, r3, [r6, #32]
 802ad2c:	f003 f8ec 	bl	802df08 <__aeabi_dmul>
 802ad30:	4622      	mov	r2, r4
 802ad32:	462b      	mov	r3, r5
 802ad34:	f002 ff34 	bl	802dba0 <__aeabi_dsub>
 802ad38:	2200      	movs	r2, #0
 802ad3a:	4b81      	ldr	r3, [pc, #516]	; (802af40 <lmx249x_configure_ramps+0x434>)
 802ad3c:	f003 f8e4 	bl	802df08 <__aeabi_dmul>
 802ad40:	f003 fc2a 	bl	802e598 <__aeabi_d2lz>
  iRampComp1     = (int64_t) ((pGlobalSettings->dComp1Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
 802ad44:	e9d6 230a 	ldrd	r2, r3, [r6, #40]	; 0x28
  /* Setup ramp range and comparator values */
  /* The formula in the LMX249x data sheet for the following settings is very misleading. The used formular was
  * found by debugging. The essence here is to specify the limits as the difference (limFreq - baseFreq), while
  * limFreq is the N factor with fractional part, but baseFreq must be the integer N factor (no rounding, just truncating).
  */
  iRampComp0     = (int64_t) ((pGlobalSettings->dComp0Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
 802ad48:	4681      	mov	r9, r0
 802ad4a:	468a      	mov	sl, r1
  iRampComp1     = (int64_t) ((pGlobalSettings->dComp1Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
 802ad4c:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 802ad50:	f003 f8da 	bl	802df08 <__aeabi_dmul>
 802ad54:	4622      	mov	r2, r4
 802ad56:	462b      	mov	r3, r5
 802ad58:	f002 ff22 	bl	802dba0 <__aeabi_dsub>
 802ad5c:	2200      	movs	r2, #0
 802ad5e:	4b78      	ldr	r3, [pc, #480]	; (802af40 <lmx249x_configure_ramps+0x434>)
 802ad60:	f003 f8d2 	bl	802df08 <__aeabi_dmul>
 802ad64:	f003 fc18 	bl	802e598 <__aeabi_d2lz>
  iRampLimitLow  = (int64_t) ((pGlobalSettings->dMinFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
 802ad68:	e9d6 2304 	ldrd	r2, r3, [r6, #16]
  /* The formula in the LMX249x data sheet for the following settings is very misleading. The used formular was
  * found by debugging. The essence here is to specify the limits as the difference (limFreq - baseFreq), while
  * limFreq is the N factor with fractional part, but baseFreq must be the integer N factor (no rounding, just truncating).
  */
  iRampComp0     = (int64_t) ((pGlobalSettings->dComp0Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampComp1     = (int64_t) ((pGlobalSettings->dComp1Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
 802ad6c:	e9cd 0102 	strd	r0, r1, [sp, #8]
  iRampLimitLow  = (int64_t) ((pGlobalSettings->dMinFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
 802ad70:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 802ad74:	960b      	str	r6, [sp, #44]	; 0x2c
 802ad76:	f003 f8c7 	bl	802df08 <__aeabi_dmul>
 802ad7a:	4622      	mov	r2, r4
 802ad7c:	462b      	mov	r3, r5
 802ad7e:	f002 ff0f 	bl	802dba0 <__aeabi_dsub>
 802ad82:	2200      	movs	r2, #0
 802ad84:	4b6e      	ldr	r3, [pc, #440]	; (802af40 <lmx249x_configure_ramps+0x434>)
 802ad86:	f003 f8bf 	bl	802df08 <__aeabi_dmul>
 802ad8a:	f003 fc05 	bl	802e598 <__aeabi_d2lz>
  iRampLimitHigh = (int64_t) ((pGlobalSettings->dMaxFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
 802ad8e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  * found by debugging. The essence here is to specify the limits as the difference (limFreq - baseFreq), while
  * limFreq is the N factor with fractional part, but baseFreq must be the integer N factor (no rounding, just truncating).
  */
  iRampComp0     = (int64_t) ((pGlobalSettings->dComp0Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampComp1     = (int64_t) ((pGlobalSettings->dComp1Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampLimitLow  = (int64_t) ((pGlobalSettings->dMinFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
 802ad90:	4606      	mov	r6, r0
  iRampLimitHigh = (int64_t) ((pGlobalSettings->dMaxFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
 802ad92:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
  * found by debugging. The essence here is to specify the limits as the difference (limFreq - baseFreq), while
  * limFreq is the N factor with fractional part, but baseFreq must be the integer N factor (no rounding, just truncating).
  */
  iRampComp0     = (int64_t) ((pGlobalSettings->dComp0Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampComp1     = (int64_t) ((pGlobalSettings->dComp1Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampLimitLow  = (int64_t) ((pGlobalSettings->dMinFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
 802ad96:	460f      	mov	r7, r1
  iRampLimitHigh = (int64_t) ((pGlobalSettings->dMaxFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
 802ad98:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 802ad9c:	f003 f8b4 	bl	802df08 <__aeabi_dmul>
 802ada0:	4622      	mov	r2, r4
 802ada2:	462b      	mov	r3, r5
 802ada4:	f002 fefc 	bl	802dba0 <__aeabi_dsub>
 802ada8:	2200      	movs	r2, #0
 802adaa:	4b65      	ldr	r3, [pc, #404]	; (802af40 <lmx249x_configure_ramps+0x434>)
 802adac:	f003 f8ac 	bl	802df08 <__aeabi_dmul>
 802adb0:	f003 fbf2 	bl	802e598 <__aeabi_d2lz>
  uSPIData[LMX249x_REG_IDX(58, 27, 80)] = (iRampLimitHigh >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 81)] = (iRampLimitHigh >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 82)] = (iRampLimitHigh >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] = ((iRampComp0    & 0x100000000) ? 1 << 0 : 0) |
    ((iRampComp1    & 0x100000000) ? 1 << 1 : 0) |
 802adb4:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
  * limFreq is the N factor with fractional part, but baseFreq must be the integer N factor (no rounding, just truncating).
  */
  iRampComp0     = (int64_t) ((pGlobalSettings->dComp0Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampComp1     = (int64_t) ((pGlobalSettings->dComp1Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampLimitLow  = (int64_t) ((pGlobalSettings->dMinFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampLimitHigh = (int64_t) ((pGlobalSettings->dMaxFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
 802adb8:	e9cd 0100 	strd	r0, r1, [sp]
  uSPIData[LMX249x_REG_IDX(58, 27, 80)] = (iRampLimitHigh >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 81)] = (iRampLimitHigh >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 82)] = (iRampLimitHigh >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] = ((iRampComp0    & 0x100000000) ? 1 << 0 : 0) |
    ((iRampComp1    & 0x100000000) ? 1 << 1 : 0) |
 802adbc:	f005 0301 	and.w	r3, r5, #1
 802adc0:	2200      	movs	r2, #0
  uSPIData[LMX249x_REG_IDX(58, 27, 79)] = (iRampLimitHigh >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 80)] = (iRampLimitHigh >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 81)] = (iRampLimitHigh >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 82)] = (iRampLimitHigh >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] = ((iRampComp0    & 0x100000000) ? 1 << 0 : 0) |
 802adc2:	ea52 0103 	orrs.w	r1, r2, r3
    ((iRampComp1    & 0x100000000) ? 1 << 1 : 0) |
      ((iRampLimitLow   & 0x100000000) ? 1 << 3 : 0) |
 802adc6:	f007 0301 	and.w	r3, r7, #1
 802adca:	f04f 0200 	mov.w	r2, #0
  uSPIData[LMX249x_REG_IDX(58, 27, 75)] = (iRampLimitLow >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 76)] = (iRampLimitLow >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 77)] = (iRampLimitLow >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 78)] = (iRampLimitLow >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 79)] = (iRampLimitHigh >>  0) & 0xFF;
 802adce:	f89d 5000 	ldrb.w	r5, [sp]
  iRampComp0     = (int64_t) ((pGlobalSettings->dComp0Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampComp1     = (int64_t) ((pGlobalSettings->dComp1Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampLimitLow  = (int64_t) ((pGlobalSettings->dMinFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampLimitHigh = (int64_t) ((pGlobalSettings->dMaxFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  
  uSPIData[LMX249x_REG_IDX(58, 27, 60)] = (iRampComp0 >>  0) & 0xFF;
 802add2:	f88d 904a 	strb.w	r9, [sp, #74]	; 0x4a
  uSPIData[LMX249x_REG_IDX(58, 27, 79)] = (iRampLimitHigh >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 80)] = (iRampLimitHigh >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 81)] = (iRampLimitHigh >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 82)] = (iRampLimitHigh >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] = ((iRampComp0    & 0x100000000) ? 1 << 0 : 0) |
 802add6:	bf0c      	ite	eq
 802add8:	4641      	moveq	r1, r8
 802adda:	2102      	movne	r1, #2
 802addc:	ea52 0e03 	orrs.w	lr, r2, r3
 802ade0:	9107      	str	r1, [sp, #28]
  uSPIData[LMX249x_REG_IDX(58, 27, 60)] = (iRampComp0 >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 61)] = (iRampComp0 >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 62)] = (iRampComp0 >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 63)] = (iRampComp0 >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 65)] = (iRampComp1 >>  0) & 0xFF;
 802ade2:	f88d 4045 	strb.w	r4, [sp, #69]	; 0x45
  uSPIData[LMX249x_REG_IDX(58, 27, 66)] = (iRampComp1 >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 67)] = (iRampComp1 >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 68)] = (iRampComp1 >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 75)] = (iRampLimitLow >>  0) & 0xFF;
 802ade6:	f88d 603b 	strb.w	r6, [sp, #59]	; 0x3b
  uSPIData[LMX249x_REG_IDX(58, 27, 76)] = (iRampLimitLow >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 77)] = (iRampLimitLow >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 78)] = (iRampLimitLow >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 79)] = (iRampLimitHigh >>  0) & 0xFF;
 802adea:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
  uSPIData[LMX249x_REG_IDX(58, 27, 80)] = (iRampLimitHigh >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 81)] = (iRampLimitHigh >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 82)] = (iRampLimitHigh >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] = ((iRampComp0    & 0x100000000) ? 1 << 0 : 0) |
 802adee:	bf0c      	ite	eq
 802adf0:	4645      	moveq	r5, r8
 802adf2:	2508      	movne	r5, #8
  uSPIData[LMX249x_REG_IDX(58, 27, 61)] = (iRampComp0 >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 62)] = (iRampComp0 >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 63)] = (iRampComp0 >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 65)] = (iRampComp1 >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 66)] = (iRampComp1 >>  8) & 0xFF;
 802adf4:	0a23      	lsrs	r3, r4, #8
  uSPIData[LMX249x_REG_IDX(58, 27, 79)] = (iRampLimitHigh >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 80)] = (iRampLimitHigh >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 81)] = (iRampLimitHigh >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 82)] = (iRampLimitHigh >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] = ((iRampComp0    & 0x100000000) ? 1 << 0 : 0) |
 802adf6:	9508      	str	r5, [sp, #32]
  uSPIData[LMX249x_REG_IDX(58, 27, 62)] = (iRampComp0 >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 63)] = (iRampComp0 >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 65)] = (iRampComp1 >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 66)] = (iRampComp1 >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 67)] = (iRampComp1 >> 16) & 0xFF;
 802adf8:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
 802adfc:	ea4f 4c14 	mov.w	ip, r4, lsr #16
  uSPIData[LMX249x_REG_IDX(58, 27, 68)] = (iRampComp1 >> 24) & 0xFF;
 802ae00:	ea4f 6e14 	mov.w	lr, r4, lsr #24
  uSPIData[LMX249x_REG_IDX(58, 27, 76)] = (iRampLimitLow >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 77)] = (iRampLimitLow >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 78)] = (iRampLimitLow >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 79)] = (iRampLimitHigh >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 80)] = (iRampLimitHigh >>  8) & 0xFF;
 802ae04:	9c00      	ldr	r4, [sp, #0]
  uSPIData[LMX249x_REG_IDX(58, 27, 61)] = (iRampComp0 >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 62)] = (iRampComp0 >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 63)] = (iRampComp0 >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 65)] = (iRampComp1 >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 66)] = (iRampComp1 >>  8) & 0xFF;
 802ae06:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
  uSPIData[LMX249x_REG_IDX(58, 27, 76)] = (iRampLimitLow >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 77)] = (iRampLimitLow >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 78)] = (iRampLimitLow >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 79)] = (iRampLimitHigh >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 80)] = (iRampLimitHigh >>  8) & 0xFF;
 802ae0a:	0a27      	lsrs	r7, r4, #8
  uSPIData[LMX249x_REG_IDX(58, 27, 82)] = (iRampLimitHigh >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] = ((iRampComp0    & 0x100000000) ? 1 << 0 : 0) |
    ((iRampComp1    & 0x100000000) ? 1 << 1 : 0) |
      ((iRampLimitLow   & 0x100000000) ? 1 << 3 : 0) |
        ((iRampLimitHigh  & 0x100000000) ? 1 << 4 : 0);
 802ae0c:	e9dd 4500 	ldrd	r4, r5, [sp]
  iRampComp1     = (int64_t) ((pGlobalSettings->dComp1Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampLimitLow  = (int64_t) ((pGlobalSettings->dMinFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampLimitHigh = (int64_t) ((pGlobalSettings->dMaxFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  
  uSPIData[LMX249x_REG_IDX(58, 27, 60)] = (iRampComp0 >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 61)] = (iRampComp0 >>  8) & 0xFF;
 802ae10:	ea4f 2019 	mov.w	r0, r9, lsr #8
  uSPIData[LMX249x_REG_IDX(58, 27, 62)] = (iRampComp0 >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 63)] = (iRampComp0 >> 24) & 0xFF;
 802ae14:	ea4f 6219 	mov.w	r2, r9, lsr #24
  iRampLimitLow  = (int64_t) ((pGlobalSettings->dMinFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampLimitHigh = (int64_t) ((pGlobalSettings->dMaxFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  
  uSPIData[LMX249x_REG_IDX(58, 27, 60)] = (iRampComp0 >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 61)] = (iRampComp0 >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 62)] = (iRampComp0 >> 16) & 0xFF;
 802ae18:	ea4f 4119 	mov.w	r1, r9, lsr #16
  iRampComp1     = (int64_t) ((pGlobalSettings->dComp1Freq    * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampLimitLow  = (int64_t) ((pGlobalSettings->dMinFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampLimitHigh = (int64_t) ((pGlobalSettings->dMaxFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  
  uSPIData[LMX249x_REG_IDX(58, 27, 60)] = (iRampComp0 >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 61)] = (iRampComp0 >>  8) & 0xFF;
 802ae1c:	f88d 0049 	strb.w	r0, [sp, #73]	; 0x49
  uSPIData[LMX249x_REG_IDX(58, 27, 62)] = (iRampComp0 >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 63)] = (iRampComp0 >> 24) & 0xFF;
 802ae20:	f88d 2047 	strb.w	r2, [sp, #71]	; 0x47
  uSPIData[LMX249x_REG_IDX(58, 27, 66)] = (iRampComp1 >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 67)] = (iRampComp1 >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 68)] = (iRampComp1 >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 75)] = (iRampLimitLow >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 76)] = (iRampLimitLow >>  8) & 0xFF;
 802ae24:	0a30      	lsrs	r0, r6, #8
  uSPIData[LMX249x_REG_IDX(58, 27, 82)] = (iRampLimitHigh >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] = ((iRampComp0    & 0x100000000) ? 1 << 0 : 0) |
    ((iRampComp1    & 0x100000000) ? 1 << 1 : 0) |
      ((iRampLimitLow   & 0x100000000) ? 1 << 3 : 0) |
        ((iRampLimitHigh  & 0x100000000) ? 1 << 4 : 0);
 802ae26:	f005 0301 	and.w	r3, r5, #1
  uSPIData[LMX249x_REG_IDX(58, 27, 76)] = (iRampLimitLow >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 77)] = (iRampLimitLow >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 78)] = (iRampLimitLow >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 79)] = (iRampLimitHigh >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 80)] = (iRampLimitHigh >>  8) & 0xFF;
 802ae2a:	f88d 7036 	strb.w	r7, [sp, #54]	; 0x36
  uSPIData[LMX249x_REG_IDX(58, 27, 82)] = (iRampLimitHigh >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] = ((iRampComp0    & 0x100000000) ? 1 << 0 : 0) |
    ((iRampComp1    & 0x100000000) ? 1 << 1 : 0) |
      ((iRampLimitLow   & 0x100000000) ? 1 << 3 : 0) |
        ((iRampLimitHigh  & 0x100000000) ? 1 << 4 : 0);
 802ae2e:	2200      	movs	r2, #0
  
  /* Define FSK deviation */
  iFSKDev = (int64_t) ((pGlobalSettings->dDeviationFrequency - pGlobalSettings->dBaseFrequency)
 802ae30:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
  uSPIData[LMX249x_REG_IDX(58, 27, 66)] = (iRampComp1 >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 67)] = (iRampComp1 >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 68)] = (iRampComp1 >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 75)] = (iRampLimitLow >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 76)] = (iRampLimitLow >>  8) & 0xFF;
 802ae32:	f88d 003a 	strb.w	r0, [sp, #58]	; 0x3a
  iRampLimitLow  = (int64_t) ((pGlobalSettings->dMinFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  iRampLimitHigh = (int64_t) ((pGlobalSettings->dMaxFrequency * dFrequencyToNFactor - iFactorN) * dFracDenominator);
  
  uSPIData[LMX249x_REG_IDX(58, 27, 60)] = (iRampComp0 >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 61)] = (iRampComp0 >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 62)] = (iRampComp0 >> 16) & 0xFF;
 802ae36:	f88d 1048 	strb.w	r1, [sp, #72]	; 0x48
  uSPIData[LMX249x_REG_IDX(58, 27, 79)] = (iRampLimitHigh >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 80)] = (iRampLimitHigh >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 81)] = (iRampLimitHigh >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 82)] = (iRampLimitHigh >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] = ((iRampComp0    & 0x100000000) ? 1 << 0 : 0) |
 802ae3a:	ea52 0003 	orrs.w	r0, r2, r3
  uSPIData[LMX249x_REG_IDX(58, 27, 67)] = (iRampComp1 >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 68)] = (iRampComp1 >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 75)] = (iRampLimitLow >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 76)] = (iRampLimitLow >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 77)] = (iRampLimitLow >> 16) & 0xFF;
 802ae3e:	ea4f 4116 	mov.w	r1, r6, lsr #16
  uSPIData[LMX249x_REG_IDX(58, 27, 78)] = (iRampLimitLow >> 24) & 0xFF;
 802ae42:	ea4f 6616 	mov.w	r6, r6, lsr #24
    ((iRampComp1    & 0x100000000) ? 1 << 1 : 0) |
      ((iRampLimitLow   & 0x100000000) ? 1 << 3 : 0) |
        ((iRampLimitHigh  & 0x100000000) ? 1 << 4 : 0);
  
  /* Define FSK deviation */
  iFSKDev = (int64_t) ((pGlobalSettings->dDeviationFrequency - pGlobalSettings->dBaseFrequency)
 802ae46:	e9d7 2300 	ldrd	r2, r3, [r7]
  uSPIData[LMX249x_REG_IDX(58, 27, 67)] = (iRampComp1 >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 68)] = (iRampComp1 >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 75)] = (iRampLimitLow >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 76)] = (iRampLimitLow >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 77)] = (iRampLimitLow >> 16) & 0xFF;
 802ae4a:	f88d 1039 	strb.w	r1, [sp, #57]	; 0x39
  uSPIData[LMX249x_REG_IDX(58, 27, 78)] = (iRampLimitLow >> 24) & 0xFF;
 802ae4e:	f88d 6038 	strb.w	r6, [sp, #56]	; 0x38
    ((iRampComp1    & 0x100000000) ? 1 << 1 : 0) |
      ((iRampLimitLow   & 0x100000000) ? 1 << 3 : 0) |
        ((iRampLimitHigh  & 0x100000000) ? 1 << 4 : 0);
  
  /* Define FSK deviation */
  iFSKDev = (int64_t) ((pGlobalSettings->dDeviationFrequency - pGlobalSettings->dBaseFrequency)
 802ae52:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
  uSPIData[LMX249x_REG_IDX(58, 27, 77)] = (iRampLimitLow >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 78)] = (iRampLimitLow >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 79)] = (iRampLimitHigh >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 80)] = (iRampLimitHigh >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 81)] = (iRampLimitHigh >> 16) & 0xFF;
 802ae56:	ea4f 4614 	mov.w	r6, r4, lsr #16
  uSPIData[LMX249x_REG_IDX(58, 27, 82)] = (iRampLimitHigh >> 24) & 0xFF;
 802ae5a:	ea4f 6514 	mov.w	r5, r4, lsr #24
    ((iRampComp1    & 0x100000000) ? 1 << 1 : 0) |
      ((iRampLimitLow   & 0x100000000) ? 1 << 3 : 0) |
        ((iRampLimitHigh  & 0x100000000) ? 1 << 4 : 0);
  
  /* Define FSK deviation */
  iFSKDev = (int64_t) ((pGlobalSettings->dDeviationFrequency - pGlobalSettings->dBaseFrequency)
 802ae5e:	463c      	mov	r4, r7
  uSPIData[LMX249x_REG_IDX(58, 27, 79)] = (iRampLimitHigh >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 80)] = (iRampLimitHigh >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 81)] = (iRampLimitHigh >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 82)] = (iRampLimitHigh >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] = ((iRampComp0    & 0x100000000) ? 1 << 0 : 0) |
 802ae60:	bf0c      	ite	eq
 802ae62:	4644      	moveq	r4, r8
 802ae64:	2410      	movne	r4, #16
  uSPIData[LMX249x_REG_IDX(58, 27, 62)] = (iRampComp0 >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 63)] = (iRampComp0 >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 65)] = (iRampComp1 >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 66)] = (iRampComp1 >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 67)] = (iRampComp1 >> 16) & 0xFF;
 802ae66:	f88d c043 	strb.w	ip, [sp, #67]	; 0x43
  uSPIData[LMX249x_REG_IDX(58, 27, 68)] = (iRampComp1 >> 24) & 0xFF;
 802ae6a:	f88d e042 	strb.w	lr, [sp, #66]	; 0x42
  uSPIData[LMX249x_REG_IDX(58, 27, 79)] = (iRampLimitHigh >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 80)] = (iRampLimitHigh >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 81)] = (iRampLimitHigh >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 82)] = (iRampLimitHigh >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] = ((iRampComp0    & 0x100000000) ? 1 << 0 : 0) |
 802ae6e:	9400      	str	r4, [sp, #0]
  uSPIData[LMX249x_REG_IDX(58, 27, 77)] = (iRampLimitLow >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 78)] = (iRampLimitLow >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 79)] = (iRampLimitHigh >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 80)] = (iRampLimitHigh >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 81)] = (iRampLimitHigh >> 16) & 0xFF;
 802ae70:	f88d 6035 	strb.w	r6, [sp, #53]	; 0x35
  uSPIData[LMX249x_REG_IDX(58, 27, 82)] = (iRampLimitHigh >> 24) & 0xFF;
 802ae74:	f88d 5034 	strb.w	r5, [sp, #52]	; 0x34
    ((iRampComp1    & 0x100000000) ? 1 << 1 : 0) |
      ((iRampLimitLow   & 0x100000000) ? 1 << 3 : 0) |
        ((iRampLimitHigh  & 0x100000000) ? 1 << 4 : 0);
  
  /* Define FSK deviation */
  iFSKDev = (int64_t) ((pGlobalSettings->dDeviationFrequency - pGlobalSettings->dBaseFrequency)
 802ae78:	f002 fe92 	bl	802dba0 <__aeabi_dsub>
                       * dFrequencyToNFactor * (1 << 24));
 802ae7c:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 802ae80:	f003 f842 	bl	802df08 <__aeabi_dmul>
 802ae84:	2200      	movs	r2, #0
 802ae86:	4b2e      	ldr	r3, [pc, #184]	; (802af40 <lmx249x_configure_ramps+0x434>)
 802ae88:	f003 f83e 	bl	802df08 <__aeabi_dmul>
    ((iRampComp1    & 0x100000000) ? 1 << 1 : 0) |
      ((iRampLimitLow   & 0x100000000) ? 1 << 3 : 0) |
        ((iRampLimitHigh  & 0x100000000) ? 1 << 4 : 0);
  
  /* Define FSK deviation */
  iFSKDev = (int64_t) ((pGlobalSettings->dDeviationFrequency - pGlobalSettings->dBaseFrequency)
 802ae8c:	f003 fb84 	bl	802e598 <__aeabi_d2lz>
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] |= ((iFSKDev    & 0x100000000) ? 1 << 2 : 0)
    | (pGlobalSettings->eDevTrigger << 5);
  
  /* Define Ramp Trigger Sources and Modulation type */
  pThis->uReg58 = (pGlobalSettings->eRampClock) /* 0 << 1) */  | /* internal or external clock */
 802ae90:	f897 5033 	ldrb.w	r5, [r7, #51]	; 0x33
 802ae94:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
    (pGlobalSettings->eModulation) /* 0 << 2) */ | /* phase or frequency modulation */
      (pGlobalSettings->eTriggerA << 4);          /* Trigger A source */
 802ae98:	f897 2030 	ldrb.w	r2, [r7, #48]	; 0x30
  uSPIData[LMX249x_REG_IDX(58, 27, 72)] = (iFSKDev >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 73)] = (iFSKDev >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 74)] = (iFSKDev >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] |= ((iFSKDev    & 0x100000000) ? 1 << 2 : 0)
    | (pGlobalSettings->eDevTrigger << 5);
 802ae9c:	f897 6039 	ldrb.w	r6, [r7, #57]	; 0x39
 802aea0:	9c08      	ldr	r4, [sp, #32]
  
  /* Define FSK deviation */
  iFSKDev = (int64_t) ((pGlobalSettings->dDeviationFrequency - pGlobalSettings->dBaseFrequency)
                       * dFrequencyToNFactor * (1 << 24));
  
  uSPIData[LMX249x_REG_IDX(58, 27, 71)] = (iFSKDev >>  0) & 0xFF;
 802aea2:	f88d 003f 	strb.w	r0, [sp, #63]	; 0x3f
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] |= ((iFSKDev    & 0x100000000) ? 1 << 2 : 0)
    | (pGlobalSettings->eDevTrigger << 5);
  
  /* Define Ramp Trigger Sources and Modulation type */
  pThis->uReg58 = (pGlobalSettings->eRampClock) /* 0 << 1) */  | /* internal or external clock */
 802aea6:	432b      	orrs	r3, r5
 802aea8:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
  uSPIData[LMX249x_REG_IDX(58, 27, 79)] = (iRampLimitHigh >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 80)] = (iRampLimitHigh >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 81)] = (iRampLimitHigh >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 82)] = (iRampLimitHigh >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] = ((iRampComp0    & 0x100000000) ? 1 << 0 : 0) |
 802aeac:	f00a 0201 	and.w	r2, sl, #1
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] |= ((iFSKDev    & 0x100000000) ? 1 << 2 : 0)
    | (pGlobalSettings->eDevTrigger << 5);
  
  /* Define Ramp Trigger Sources and Modulation type */
  pThis->uReg58 = (pGlobalSettings->eRampClock) /* 0 << 1) */  | /* internal or external clock */
 802aeb0:	b2db      	uxtb	r3, r3
 802aeb2:	ea42 1246 	orr.w	r2, r2, r6, lsl #5
 802aeb6:	9e07      	ldr	r6, [sp, #28]
 802aeb8:	f88b 3010 	strb.w	r3, [fp, #16]
  
  uSPIData[LMX249x_REG_IDX(58, 27, 59)] = (pGlobalSettings->eTriggerB)   | /* Trigger B source */
    (pGlobalSettings->eTriggerC << 4);   /* Trigger C source */
  
  /* Setup ramp counter */
  uSPIData[LMX249x_REG_IDX(58, 27, 83)] = (pGlobalSettings->uNumRamps & 0xFF);
 802aebc:	8efd      	ldrh	r5, [r7, #54]	; 0x36
  pThis->uReg58 = (pGlobalSettings->eRampClock) /* 0 << 1) */  | /* internal or external clock */
    (pGlobalSettings->eModulation) /* 0 << 2) */ | /* phase or frequency modulation */
      (pGlobalSettings->eTriggerA << 4);          /* Trigger A source */
  uSPIData[LMX249x_REG_IDX(58, 27, 58)] = pThis->uReg58;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 59)] = (pGlobalSettings->eTriggerB)   | /* Trigger B source */
 802aebe:	f897 a031 	ldrb.w	sl, [r7, #49]	; 0x31
    (pGlobalSettings->eTriggerC << 4);   /* Trigger C source */
  
  /* Setup ramp counter */
  uSPIData[LMX249x_REG_IDX(58, 27, 83)] = (pGlobalSettings->uNumRamps & 0xFF);
  uSPIData[LMX249x_REG_IDX(58, 27, 84)] = ((pGlobalSettings->uNumRamps >> 8)& 0x1F)  |
    (pGlobalSettings->eAutoOff << 5)     |
 802aec2:	f897 9035 	ldrb.w	r9, [r7, #53]	; 0x35
      (pGlobalSettings->eRampCountTrigger << 6);
 802aec6:	f897 c038 	ldrb.w	ip, [r7, #56]	; 0x38
    (pGlobalSettings->eModulation) /* 0 << 2) */ | /* phase or frequency modulation */
      (pGlobalSettings->eTriggerA << 4);          /* Trigger A source */
  uSPIData[LMX249x_REG_IDX(58, 27, 58)] = pThis->uReg58;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 59)] = (pGlobalSettings->eTriggerB)   | /* Trigger B source */
    (pGlobalSettings->eTriggerC << 4);   /* Trigger C source */
 802aeca:	f897 e032 	ldrb.w	lr, [r7, #50]	; 0x32
  
  /* Define Ramp Trigger Sources and Modulation type */
  pThis->uReg58 = (pGlobalSettings->eRampClock) /* 0 << 1) */  | /* internal or external clock */
    (pGlobalSettings->eModulation) /* 0 << 2) */ | /* phase or frequency modulation */
      (pGlobalSettings->eTriggerA << 4);          /* Trigger A source */
  uSPIData[LMX249x_REG_IDX(58, 27, 58)] = pThis->uReg58;
 802aece:	f88d 304c 	strb.w	r3, [sp, #76]	; 0x4c
  uSPIData[LMX249x_REG_IDX(58, 27, 71)] = (iFSKDev >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 72)] = (iFSKDev >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 73)] = (iFSKDev >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 74)] = (iFSKDev >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] |= ((iFSKDev    & 0x100000000) ? 1 << 2 : 0)
 802aed2:	f001 0701 	and.w	r7, r1, #1
 802aed6:	4332      	orrs	r2, r6
 802aed8:	2600      	movs	r6, #0
 802aeda:	4322      	orrs	r2, r4
 802aedc:	ea56 0407 	orrs.w	r4, r6, r7
 802aee0:	9c00      	ldr	r4, [sp, #0]
  uSPIData[LMX249x_REG_IDX(58, 27, 84)] = ((pGlobalSettings->uNumRamps >> 8)& 0x1F)  |
    (pGlobalSettings->eAutoOff << 5)     |
      (pGlobalSettings->eRampCountTrigger << 6);
  
  /* Send register sequence to PLL */
  uSPIData[0] = 0;
 802aee2:	f88d 8030 	strb.w	r8, [sp, #48]	; 0x30
  uSPIData[LMX249x_REG_IDX(58, 27, 59)] = (pGlobalSettings->eTriggerB)   | /* Trigger B source */
    (pGlobalSettings->eTriggerC << 4);   /* Trigger C source */
  
  /* Setup ramp counter */
  uSPIData[LMX249x_REG_IDX(58, 27, 83)] = (pGlobalSettings->uNumRamps & 0xFF);
  uSPIData[LMX249x_REG_IDX(58, 27, 84)] = ((pGlobalSettings->uNumRamps >> 8)& 0x1F)  |
 802aee6:	f3c5 2104 	ubfx	r1, r5, #8, #5
 802aeea:	ea44 0402 	orr.w	r4, r4, r2
 802aeee:	ea41 1949 	orr.w	r9, r1, r9, lsl #5
  uSPIData[LMX249x_REG_IDX(58, 27, 71)] = (iFSKDev >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 72)] = (iFSKDev >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 73)] = (iFSKDev >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 74)] = (iFSKDev >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] |= ((iFSKDev    & 0x100000000) ? 1 << 2 : 0)
 802aef2:	bf14      	ite	ne
 802aef4:	2204      	movne	r2, #4
 802aef6:	4642      	moveq	r2, r8
 802aef8:	4314      	orrs	r4, r2
  uSPIData[LMX249x_REG_IDX(58, 27, 59)] = (pGlobalSettings->eTriggerB)   | /* Trigger B source */
    (pGlobalSettings->eTriggerC << 4);   /* Trigger C source */
  
  /* Setup ramp counter */
  uSPIData[LMX249x_REG_IDX(58, 27, 83)] = (pGlobalSettings->uNumRamps & 0xFF);
  uSPIData[LMX249x_REG_IDX(58, 27, 84)] = ((pGlobalSettings->uNumRamps >> 8)& 0x1F)  |
 802aefa:	ea49 1c8c 	orr.w	ip, r9, ip, lsl #6
  pThis->uReg58 = (pGlobalSettings->eRampClock) /* 0 << 1) */  | /* internal or external clock */
    (pGlobalSettings->eModulation) /* 0 << 2) */ | /* phase or frequency modulation */
      (pGlobalSettings->eTriggerA << 4);          /* Trigger A source */
  uSPIData[LMX249x_REG_IDX(58, 27, 58)] = pThis->uReg58;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 59)] = (pGlobalSettings->eTriggerB)   | /* Trigger B source */
 802aefe:	ea4a 1e0e 	orr.w	lr, sl, lr, lsl #4
  /* Define FSK deviation */
  iFSKDev = (int64_t) ((pGlobalSettings->dDeviationFrequency - pGlobalSettings->dBaseFrequency)
                       * dFrequencyToNFactor * (1 << 24));
  
  uSPIData[LMX249x_REG_IDX(58, 27, 71)] = (iFSKDev >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 72)] = (iFSKDev >>  8) & 0xFF;
 802af02:	0a07      	lsrs	r7, r0, #8
  uSPIData[LMX249x_REG_IDX(58, 27, 73)] = (iFSKDev >> 16) & 0xFF;
 802af04:	0c06      	lsrs	r6, r0, #16
  uSPIData[LMX249x_REG_IDX(58, 27, 74)] = (iFSKDev >> 24) & 0xFF;
 802af06:	0e01      	lsrs	r1, r0, #24
    (pGlobalSettings->eAutoOff << 5)     |
      (pGlobalSettings->eRampCountTrigger << 6);
  
  /* Send register sequence to PLL */
  uSPIData[0] = 0;
  uSPIData[1] = 58 + 27 - 1;
 802af08:	2254      	movs	r2, #84	; 0x54
  pThis->sendSPI(uSPIData, 27 + 2, pThis->pDataForSendSPI);
 802af0a:	a80c      	add	r0, sp, #48	; 0x30
  uSPIData[LMX249x_REG_IDX(58, 27, 59)] = (pGlobalSettings->eTriggerB)   | /* Trigger B source */
    (pGlobalSettings->eTriggerC << 4);   /* Trigger C source */
  
  /* Setup ramp counter */
  uSPIData[LMX249x_REG_IDX(58, 27, 83)] = (pGlobalSettings->uNumRamps & 0xFF);
  uSPIData[LMX249x_REG_IDX(58, 27, 84)] = ((pGlobalSettings->uNumRamps >> 8)& 0x1F)  |
 802af0c:	f88d c032 	strb.w	ip, [sp, #50]	; 0x32
  pThis->uReg58 = (pGlobalSettings->eRampClock) /* 0 << 1) */  | /* internal or external clock */
    (pGlobalSettings->eModulation) /* 0 << 2) */ | /* phase or frequency modulation */
      (pGlobalSettings->eTriggerA << 4);          /* Trigger A source */
  uSPIData[LMX249x_REG_IDX(58, 27, 58)] = pThis->uReg58;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 59)] = (pGlobalSettings->eTriggerB)   | /* Trigger B source */
 802af10:	f88d e04b 	strb.w	lr, [sp, #75]	; 0x4b
  uSPIData[LMX249x_REG_IDX(58, 27, 71)] = (iFSKDev >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 72)] = (iFSKDev >>  8) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 73)] = (iFSKDev >> 16) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 74)] = (iFSKDev >> 24) & 0xFF;
  
  uSPIData[LMX249x_REG_IDX(58, 27, 70)] |= ((iFSKDev    & 0x100000000) ? 1 << 2 : 0)
 802af14:	f88d 4040 	strb.w	r4, [sp, #64]	; 0x40
  
  uSPIData[LMX249x_REG_IDX(58, 27, 59)] = (pGlobalSettings->eTriggerB)   | /* Trigger B source */
    (pGlobalSettings->eTriggerC << 4);   /* Trigger C source */
  
  /* Setup ramp counter */
  uSPIData[LMX249x_REG_IDX(58, 27, 83)] = (pGlobalSettings->uNumRamps & 0xFF);
 802af18:	f88d 5033 	strb.w	r5, [sp, #51]	; 0x33
  /* Define FSK deviation */
  iFSKDev = (int64_t) ((pGlobalSettings->dDeviationFrequency - pGlobalSettings->dBaseFrequency)
                       * dFrequencyToNFactor * (1 << 24));
  
  uSPIData[LMX249x_REG_IDX(58, 27, 71)] = (iFSKDev >>  0) & 0xFF;
  uSPIData[LMX249x_REG_IDX(58, 27, 72)] = (iFSKDev >>  8) & 0xFF;
 802af1c:	f88d 703e 	strb.w	r7, [sp, #62]	; 0x3e
  uSPIData[LMX249x_REG_IDX(58, 27, 73)] = (iFSKDev >> 16) & 0xFF;
 802af20:	f88d 603d 	strb.w	r6, [sp, #61]	; 0x3d
  uSPIData[LMX249x_REG_IDX(58, 27, 74)] = (iFSKDev >> 24) & 0xFF;
 802af24:	f88d 103c 	strb.w	r1, [sp, #60]	; 0x3c
    (pGlobalSettings->eAutoOff << 5)     |
      (pGlobalSettings->eRampCountTrigger << 6);
  
  /* Send register sequence to PLL */
  uSPIData[0] = 0;
  uSPIData[1] = 58 + 27 - 1;
 802af28:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
  pThis->sendSPI(uSPIData, 27 + 2, pThis->pDataForSendSPI);
 802af2c:	f8db 3014 	ldr.w	r3, [fp, #20]
 802af30:	f8db 2018 	ldr.w	r2, [fp, #24]
 802af34:	211d      	movs	r1, #29
 802af36:	4798      	blx	r3
  
  return (LMX249x_ERROR_CODE_OK);
 802af38:	4640      	mov	r0, r8
}
 802af3a:	b015      	add	sp, #84	; 0x54
 802af3c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802af40:	41700000 	.word	0x41700000

0802af44 <lmx249x_enable_ramps>:

//============================================================================

void lmx249x_enable_ramps(Lmx249x_Object_t* pThis, uint8_t bEnable)
{
 802af44:	b510      	push	{r4, lr}
 802af46:	b082      	sub	sp, #8
  uint8_t uSPIData[4];
  uSPIData[0] = 0;              /* High address byte */
 802af48:	2400      	movs	r4, #0
  uSPIData[1] = 58;             /* Low address byte */
 802af4a:	223a      	movs	r2, #58	; 0x3a
  uSPIData[2] = pThis->uReg58;  /* Configuration of register 58 */
 802af4c:	7c03      	ldrb	r3, [r0, #16]
//============================================================================

void lmx249x_enable_ramps(Lmx249x_Object_t* pThis, uint8_t bEnable)
{
  uint8_t uSPIData[4];
  uSPIData[0] = 0;              /* High address byte */
 802af4e:	f88d 4004 	strb.w	r4, [sp, #4]
  uSPIData[1] = 58;             /* Low address byte */
 802af52:	f88d 2005 	strb.w	r2, [sp, #5]
  uSPIData[2] = pThis->uReg58;  /* Configuration of register 58 */
  
  /* enable ramps */
  if (bEnable != 0)
 802af56:	b951      	cbnz	r1, 802af6e <lmx249x_enable_ramps+0x2a>
    uSPIData[2] |= 1;
  else
    uSPIData[2] &= 0xFE;
 802af58:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 802af5c:	f88d 3006 	strb.w	r3, [sp, #6]
  
  pThis->sendSPI(uSPIData, 3, pThis->pDataForSendSPI);
 802af60:	6982      	ldr	r2, [r0, #24]
 802af62:	6943      	ldr	r3, [r0, #20]
 802af64:	2103      	movs	r1, #3
 802af66:	a801      	add	r0, sp, #4
 802af68:	4798      	blx	r3
}
 802af6a:	b002      	add	sp, #8
 802af6c:	bd10      	pop	{r4, pc}
  uSPIData[1] = 58;             /* Low address byte */
  uSPIData[2] = pThis->uReg58;  /* Configuration of register 58 */
  
  /* enable ramps */
  if (bEnable != 0)
    uSPIData[2] |= 1;
 802af6e:	f043 0301 	orr.w	r3, r3, #1
 802af72:	e7f3      	b.n	802af5c <lmx249x_enable_ramps+0x18>

0802af74 <lmx249x_get_real_frequency_shift>:
}

//============================================================================

double lmx249x_get_real_frequency_shift(Lmx249x_Object_t* pThis, double FreqShift_MHz, uint32_t FreqShift_time_usec)
{
 802af74:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  double RealFreqShift;
  const double FracDenominator = (double)(1<<24);
  uint32_t FreqShiftSteps;
  double FreqShiftPerStep;
  
  FreqShiftSteps =  (uint32_t) (FreqShift_time_usec / pThis->dPFDCycleTime);
 802af78:	e9d0 4502 	ldrd	r4, r5, [r0, #8]
}

//============================================================================

double lmx249x_get_real_frequency_shift(Lmx249x_Object_t* pThis, double FreqShift_MHz, uint32_t FreqShift_time_usec)
{
 802af7c:	4601      	mov	r1, r0
  double RealFreqShift;
  const double FracDenominator = (double)(1<<24);
  uint32_t FreqShiftSteps;
  double FreqShiftPerStep;
  
  FreqShiftSteps =  (uint32_t) (FreqShift_time_usec / pThis->dPFDCycleTime);
 802af7e:	980a      	ldr	r0, [sp, #40]	; 0x28
  
  FreqShiftPerStep = (FreqShift_MHz * pThis->dExternalDivideFactor) / FreqShiftSteps;
 802af80:	e9d1 6700 	ldrd	r6, r7, [r1]
}

//============================================================================

double lmx249x_get_real_frequency_shift(Lmx249x_Object_t* pThis, double FreqShift_MHz, uint32_t FreqShift_time_usec)
{
 802af84:	4692      	mov	sl, r2
 802af86:	469b      	mov	fp, r3
  double RealFreqShift;
  const double FracDenominator = (double)(1<<24);
  uint32_t FreqShiftSteps;
  double FreqShiftPerStep;
  
  FreqShiftSteps =  (uint32_t) (FreqShift_time_usec / pThis->dPFDCycleTime);
 802af88:	f002 ff48 	bl	802de1c <__aeabi_ui2d>
 802af8c:	4622      	mov	r2, r4
 802af8e:	462b      	mov	r3, r5
 802af90:	f003 f8e4 	bl	802e15c <__aeabi_ddiv>
 802af94:	f003 fa7a 	bl	802e48c <__aeabi_d2uiz>
  
  FreqShiftPerStep = (FreqShift_MHz * pThis->dExternalDivideFactor) / FreqShiftSteps;
 802af98:	f002 ff40 	bl	802de1c <__aeabi_ui2d>
 802af9c:	4652      	mov	r2, sl
 802af9e:	4680      	mov	r8, r0
 802afa0:	4689      	mov	r9, r1
 802afa2:	465b      	mov	r3, fp
 802afa4:	4630      	mov	r0, r6
 802afa6:	4639      	mov	r1, r7
 802afa8:	f002 ffae 	bl	802df08 <__aeabi_dmul>
 802afac:	4642      	mov	r2, r8
 802afae:	464b      	mov	r3, r9
 802afb0:	f003 f8d4 	bl	802e15c <__aeabi_ddiv>
  
  FreqShiftPerStep = ((uint32_t)((FreqShiftPerStep * FracDenominator) * pThis->dPFDCycleTime) ) / FracDenominator / pThis->dPFDCycleTime;
 802afb4:	2200      	movs	r2, #0
 802afb6:	4b10      	ldr	r3, [pc, #64]	; (802aff8 <lmx249x_get_real_frequency_shift+0x84>)
 802afb8:	f002 ffa6 	bl	802df08 <__aeabi_dmul>
 802afbc:	4602      	mov	r2, r0
 802afbe:	460b      	mov	r3, r1
 802afc0:	4620      	mov	r0, r4
 802afc2:	4629      	mov	r1, r5
 802afc4:	f002 ffa0 	bl	802df08 <__aeabi_dmul>
 802afc8:	f003 fa60 	bl	802e48c <__aeabi_d2uiz>
 802afcc:	f002 ff26 	bl	802de1c <__aeabi_ui2d>
 802afd0:	2200      	movs	r2, #0
 802afd2:	4b0a      	ldr	r3, [pc, #40]	; (802affc <lmx249x_get_real_frequency_shift+0x88>)
 802afd4:	f002 ff98 	bl	802df08 <__aeabi_dmul>
 802afd8:	4622      	mov	r2, r4
 802afda:	462b      	mov	r3, r5
 802afdc:	f003 f8be 	bl	802e15c <__aeabi_ddiv>
 802afe0:	4602      	mov	r2, r0
 802afe2:	460b      	mov	r3, r1
  
  RealFreqShift = FreqShiftPerStep * FreqShiftSteps /  pThis->dExternalDivideFactor;
 802afe4:	4640      	mov	r0, r8
 802afe6:	4649      	mov	r1, r9
 802afe8:	f002 ff8e 	bl	802df08 <__aeabi_dmul>
 802afec:	4632      	mov	r2, r6
 802afee:	463b      	mov	r3, r7
 802aff0:	f003 f8b4 	bl	802e15c <__aeabi_ddiv>
  
  return (RealFreqShift);
}
 802aff4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802aff8:	41700000 	.word	0x41700000
 802affc:	3e700000 	.word	0x3e700000

0802b000 <lmx249x_trigger_ramp>:

//============================================================================

void lmx249x_trigger_ramp(void)
{
 802b000:	4b07      	ldr	r3, [pc, #28]	; (802b020 <lmx249x_trigger_ramp+0x20>)
 802b002:	7c18      	ldrb	r0, [r3, #16]
 802b004:	6819      	ldr	r1, [r3, #0]
 802b006:	2201      	movs	r2, #1
 802b008:	4082      	lsls	r2, r0

__STATIC_INLINE uint32_t XMC_GPIO_GetInput(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_GetInput: Invalid port", XMC_GPIO_CHECK_PORT(port));

  return (((port->IN) >> pin) & 0x1U);
 802b00a:	6a4b      	ldr	r3, [r1, #36]	; 0x24
  /* Wait until PLL is ready to generate the next chirp */
  while (DIGITAL_IO_GetInput(&DIGITAL_IO_PLL_MOD) != 0);
 802b00c:	421a      	tst	r2, r3
 802b00e:	d1fc      	bne.n	802b00a <lmx249x_trigger_ramp+0xa>
 802b010:	4b04      	ldr	r3, [pc, #16]	; (802b024 <lmx249x_trigger_ramp+0x24>)

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 802b012:	7c19      	ldrb	r1, [r3, #16]
 802b014:	681a      	ldr	r2, [r3, #0]
 802b016:	2301      	movs	r3, #1
 802b018:	408b      	lsls	r3, r1
 802b01a:	6053      	str	r3, [r2, #4]
 802b01c:	4770      	bx	lr
 802b01e:	bf00      	nop
 802b020:	08030cf8 	.word	0x08030cf8
 802b024:	08030ce4 	.word	0x08030ce4

0802b028 <lmx249x_release_ramp_trigger>:
}

//============================================================================

void lmx249x_release_ramp_trigger(void)
{
 802b028:	4b03      	ldr	r3, [pc, #12]	; (802b038 <lmx249x_release_ramp_trigger+0x10>)

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 802b02a:	7c19      	ldrb	r1, [r3, #16]
 802b02c:	681a      	ldr	r2, [r3, #0]
 802b02e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 802b032:	408b      	lsls	r3, r1
 802b034:	6053      	str	r3, [r2, #4]
 802b036:	4770      	bx	lr
 802b038:	08030ce4 	.word	0x08030ce4

0802b03c <lmx249x_power_up>:
}

//============================================================================

void lmx249x_power_up(void)
{
 802b03c:	4b03      	ldr	r3, [pc, #12]	; (802b04c <lmx249x_power_up+0x10>)

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 802b03e:	7c19      	ldrb	r1, [r3, #16]
 802b040:	681a      	ldr	r2, [r3, #0]
 802b042:	2301      	movs	r3, #1
 802b044:	408b      	lsls	r3, r1
 802b046:	6053      	str	r3, [r2, #4]
 802b048:	4770      	bx	lr
 802b04a:	bf00      	nop
 802b04c:	08030c80 	.word	0x08030c80

0802b050 <lmx249x_power_down>:
}

//============================================================================

void lmx249x_power_down(void)
{
 802b050:	4b03      	ldr	r3, [pc, #12]	; (802b060 <lmx249x_power_down+0x10>)

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 802b052:	7c19      	ldrb	r1, [r3, #16]
 802b054:	681a      	ldr	r2, [r3, #0]
 802b056:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 802b05a:	408b      	lsls	r3, r1
 802b05c:	6053      	str	r3, [r2, #4]
 802b05e:	4770      	bx	lr
 802b060:	08030c80 	.word	0x08030c80

0802b064 <bgt24mtr1x_init>:
void bgt24mtr1x_init(Bgt24mtr1x_LNAgain_t lna_gain, Bgt24mtr1x_Power_t power_level)
{
  bgt24mtr1x_global_config = BGT24MTR1X_BASE_CONF;
  
  /* Set the digital IOs used by SPI interface */
  bgt24mtr1x_spi_pins.spi_device    = BGT_DEVICE;
 802b064:	4a36      	ldr	r2, [pc, #216]	; (802b140 <bgt24mtr1x_init+0xdc>)
==============================================================================
 */

void bgt24mtr1x_init(Bgt24mtr1x_LNAgain_t lna_gain, Bgt24mtr1x_Power_t power_level)
{
  bgt24mtr1x_global_config = BGT24MTR1X_BASE_CONF;
 802b066:	4b37      	ldr	r3, [pc, #220]	; (802b144 <bgt24mtr1x_init+0xe0>)
   3. EXPORTED FUNCTIONS
==============================================================================
 */

void bgt24mtr1x_init(Bgt24mtr1x_LNAgain_t lna_gain, Bgt24mtr1x_Power_t power_level)
{
 802b068:	b4f0      	push	{r4, r5, r6, r7}
  bgt24mtr1x_global_config = BGT24MTR1X_BASE_CONF;
  
  /* Set the digital IOs used by SPI interface */
  bgt24mtr1x_spi_pins.spi_device    = BGT_DEVICE;
  bgt24mtr1x_spi_pins.gpio_cs_pin 	= (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_BGT24;
 802b06a:	4e37      	ldr	r6, [pc, #220]	; (802b148 <bgt24mtr1x_init+0xe4>)
 802b06c:	6056      	str	r6, [r2, #4]
==============================================================================
 */

void bgt24mtr1x_init(Bgt24mtr1x_LNAgain_t lna_gain, Bgt24mtr1x_Power_t power_level)
{
  bgt24mtr1x_global_config = BGT24MTR1X_BASE_CONF;
 802b06e:	f241 0748 	movw	r7, #4168	; 0x1048
  
  /* Set the digital IOs used by SPI interface */
  bgt24mtr1x_spi_pins.spi_device    = BGT_DEVICE;
  bgt24mtr1x_spi_pins.gpio_cs_pin 	= (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_BGT24;
  bgt24mtr1x_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_DATA;
 802b072:	4d36      	ldr	r5, [pc, #216]	; (802b14c <bgt24mtr1x_init+0xe8>)
  bgt24mtr1x_spi_pins.gpio_clk_pin 	= (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;
 802b074:	4c36      	ldr	r4, [pc, #216]	; (802b150 <bgt24mtr1x_init+0xec>)
==============================================================================
 */

void bgt24mtr1x_init(Bgt24mtr1x_LNAgain_t lna_gain, Bgt24mtr1x_Power_t power_level)
{
  bgt24mtr1x_global_config = BGT24MTR1X_BASE_CONF;
 802b076:	801f      	strh	r7, [r3, #0]
  
  /* Set the digital IOs used by SPI interface */
  bgt24mtr1x_spi_pins.spi_device    = BGT_DEVICE;
 802b078:	2600      	movs	r6, #0
 802b07a:	7016      	strb	r6, [r2, #0]
  bgt24mtr1x_spi_pins.gpio_cs_pin 	= (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_BGT24;
  bgt24mtr1x_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_DATA;
 802b07c:	6095      	str	r5, [r2, #8]
  bgt24mtr1x_spi_pins.gpio_clk_pin 	= (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;
 802b07e:	60d4      	str	r4, [r2, #12]
  
  if (lna_gain)
  {
    bgt24mtr1x_global_config &= BGT24MTR1X_ENA_LNA_MASK;
 802b080:	881a      	ldrh	r2, [r3, #0]
  bgt24mtr1x_spi_pins.spi_device    = BGT_DEVICE;
  bgt24mtr1x_spi_pins.gpio_cs_pin 	= (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CS_BGT24;
  bgt24mtr1x_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_DATA;
  bgt24mtr1x_spi_pins.gpio_clk_pin 	= (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;
  
  if (lna_gain)
 802b082:	b998      	cbnz	r0, 802b0ac <bgt24mtr1x_init+0x48>
  {
    bgt24mtr1x_global_config &= BGT24MTR1X_ENA_LNA_MASK;
  }
  else
  {
    bgt24mtr1x_global_config |= BGT24MTR1X_DIS_LNA_MASK;
 802b084:	ea6f 4242 	mvn.w	r2, r2, lsl #17
 802b088:	ea6f 4252 	mvn.w	r2, r2, lsr #17
 802b08c:	b292      	uxth	r2, r2
 802b08e:	801a      	strh	r2, [r3, #0]
//============================================================================

void bgt24mtr1x_set_tx_power(Bgt24mtr1x_Power_t power_level)
{
  /* Clear the last 3-bits */
  bgt24mtr1x_global_config &= 0xFFF8;
 802b090:	881a      	ldrh	r2, [r3, #0]
 802b092:	f022 0207 	bic.w	r2, r2, #7
 802b096:	0412      	lsls	r2, r2, #16
 802b098:	0c12      	lsrs	r2, r2, #16
 802b09a:	801a      	strh	r2, [r3, #0]
  
  switch (power_level)
 802b09c:	2906      	cmp	r1, #6
 802b09e:	d84a      	bhi.n	802b136 <bgt24mtr1x_init+0xd2>
 802b0a0:	e8df f001 	tbb	[pc, r1]
 802b0a4:	37312b25 	.word	0x37312b25
 802b0a8:	433d      	.short	0x433d
 802b0aa:	08          	.byte	0x08
 802b0ab:	00          	.byte	0x00
  bgt24mtr1x_spi_pins.gpio_data_pin = (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_DATA;
  bgt24mtr1x_spi_pins.gpio_clk_pin 	= (DIGITAL_IO_t*)&DIGITAL_IO_SPI_M_CLK;
  
  if (lna_gain)
  {
    bgt24mtr1x_global_config &= BGT24MTR1X_ENA_LNA_MASK;
 802b0ac:	f3c2 020e 	ubfx	r2, r2, #0, #15
 802b0b0:	801a      	strh	r2, [r3, #0]
 802b0b2:	e7ed      	b.n	802b090 <bgt24mtr1x_init+0x2c>
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_2;
    break;
    
  case BGT24MTR1X_TX_LEVEL_6:
    /* Reduction by 0.4dBm */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_1;
 802b0b4:	881a      	ldrh	r2, [r3, #0]
 802b0b6:	b292      	uxth	r2, r2
 802b0b8:	f042 0201 	orr.w	r2, r2, #1
 802b0bc:	801a      	strh	r2, [r3, #0]

//============================================================================

void bgt24mtr1x_ana_vout_tx(void)
{
  bgt24mtr1x_ana_command = BGT24MTR1X_ANA_CMD_TX_POWER;
 802b0be:	4925      	ldr	r1, [pc, #148]	; (802b154 <bgt24mtr1x_init+0xf0>)
 802b0c0:	2201      	movs	r2, #1
 802b0c2:	800a      	strh	r2, [r1, #0]
  
  bgt24mtr1x_global_config &= BGT24MTR1X_AMUX_VOUT_TX;
 802b0c4:	881a      	ldrh	r2, [r3, #0]
 802b0c6:	f422 5206 	bic.w	r2, r2, #8576	; 0x2180
 802b0ca:	0412      	lsls	r2, r2, #16
 802b0cc:	0c12      	lsrs	r2, r2, #16

//============================================================================

void bgt24mtr1x_ana_vref_tx(void)
{
  bgt24mtr1x_ana_command = BGT24MTR1X_ANA_CMD_TX_POWER_REF;
 802b0ce:	2002      	movs	r0, #2

void bgt24mtr1x_ana_vout_tx(void)
{
  bgt24mtr1x_ana_command = BGT24MTR1X_ANA_CMD_TX_POWER;
  
  bgt24mtr1x_global_config &= BGT24MTR1X_AMUX_VOUT_TX;
 802b0d0:	801a      	strh	r2, [r3, #0]

//============================================================================

void bgt24mtr1x_ana_vref_tx(void)
{
  bgt24mtr1x_ana_command = BGT24MTR1X_ANA_CMD_TX_POWER_REF;
 802b0d2:	8008      	strh	r0, [r1, #0]
  
  bgt24mtr1x_global_config &= BGT24MTR1X_AMUX_VOUT_TX;
 802b0d4:	881a      	ldrh	r2, [r3, #0]
 802b0d6:	f422 5206 	bic.w	r2, r2, #8576	; 0x2180
 802b0da:	0412      	lsls	r2, r2, #16
 802b0dc:	0c12      	lsrs	r2, r2, #16
 802b0de:	801a      	strh	r2, [r3, #0]
  
  bgt24mtr1x_global_config |= BGT24MTR1X_AMUX_0;
 802b0e0:	881a      	ldrh	r2, [r3, #0]
 802b0e2:	b292      	uxth	r2, r2
 802b0e4:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 802b0e8:	801a      	strh	r2, [r3, #0]
  
  /* Configure BGT24MTR1x */
  bgt24mtr1x_set_tx_power(power_level);
  
  bgt24mtr1x_ana_vref_tx();
}
 802b0ea:	bcf0      	pop	{r4, r5, r6, r7}
 802b0ec:	4770      	bx	lr
  
  switch (power_level)
  {
  case BGT24MTR1X_TX_MIN:
    /* Reduction by 9dBm */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_7;
 802b0ee:	881a      	ldrh	r2, [r3, #0]
 802b0f0:	b292      	uxth	r2, r2
 802b0f2:	f042 0207 	orr.w	r2, r2, #7
 802b0f6:	801a      	strh	r2, [r3, #0]
 802b0f8:	e7e1      	b.n	802b0be <bgt24mtr1x_init+0x5a>
    break;
    
  case BGT24MTR1X_TX_LEVEL_1:
    /* Reduction by 6dBm */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_6;
 802b0fa:	881a      	ldrh	r2, [r3, #0]
 802b0fc:	b292      	uxth	r2, r2
 802b0fe:	f042 0206 	orr.w	r2, r2, #6
 802b102:	801a      	strh	r2, [r3, #0]
 802b104:	e7db      	b.n	802b0be <bgt24mtr1x_init+0x5a>
    break;
    
  case BGT24MTR1X_TX_LEVEL_2:
    /* Reduction by 4dBm */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_5;
 802b106:	881a      	ldrh	r2, [r3, #0]
 802b108:	b292      	uxth	r2, r2
 802b10a:	f042 0205 	orr.w	r2, r2, #5
 802b10e:	801a      	strh	r2, [r3, #0]
 802b110:	e7d5      	b.n	802b0be <bgt24mtr1x_init+0x5a>
    break;
    
  case BGT24MTR1X_TX_MID:
    /* Reduction by 2.5dBm */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_4;
 802b112:	881a      	ldrh	r2, [r3, #0]
 802b114:	b292      	uxth	r2, r2
 802b116:	f042 0204 	orr.w	r2, r2, #4
 802b11a:	801a      	strh	r2, [r3, #0]
 802b11c:	e7cf      	b.n	802b0be <bgt24mtr1x_init+0x5a>
    break;
    
  case BGT24MTR1X_TX_LEVEL_4:
    /* Reduction by 1.4dBm */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_3;
 802b11e:	881a      	ldrh	r2, [r3, #0]
 802b120:	b292      	uxth	r2, r2
 802b122:	f042 0203 	orr.w	r2, r2, #3
 802b126:	801a      	strh	r2, [r3, #0]
 802b128:	e7c9      	b.n	802b0be <bgt24mtr1x_init+0x5a>
    break;
    
  case BGT24MTR1X_TX_LEVEL_5:
    /* Reduction by 0.8dBm */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_2;
 802b12a:	881a      	ldrh	r2, [r3, #0]
 802b12c:	b292      	uxth	r2, r2
 802b12e:	f042 0202 	orr.w	r2, r2, #2
 802b132:	801a      	strh	r2, [r3, #0]
 802b134:	e7c3      	b.n	802b0be <bgt24mtr1x_init+0x5a>
    break;
    
  case BGT24MTR1X_TX_MAX:
  default:
    /* TX on with maximum power */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_0;
 802b136:	881a      	ldrh	r2, [r3, #0]
 802b138:	b292      	uxth	r2, r2
 802b13a:	801a      	strh	r2, [r3, #0]
 802b13c:	e7bf      	b.n	802b0be <bgt24mtr1x_init+0x5a>
 802b13e:	bf00      	nop
 802b140:	1fff2b24 	.word	0x1fff2b24
 802b144:	1ffe9012 	.word	0x1ffe9012
 802b148:	08030d34 	.word	0x08030d34
 802b14c:	08030d70 	.word	0x08030d70
 802b150:	08030ca8 	.word	0x08030ca8
 802b154:	1ffe9014 	.word	0x1ffe9014

0802b158 <bgt24mtr1x_start_tx>:

//============================================================================

void bgt24mtr1x_start_tx(void)
{
  bgt24mtr1x_global_config &= BGT24MTR1X_ENA_PA_MASK;
 802b158:	490b      	ldr	r1, [pc, #44]	; (802b188 <bgt24mtr1x_start_tx+0x30>)
  
  /* Upper byte goes to lower byte position */
  shuffled_data |= (config_val >> 8);
  
  /* Transmit configuration data to BGT24MTR1x through SPI protocol */
  spi_transmit_data((uint8_t *)&shuffled_data , 2U, (void*) &bgt24mtr1x_spi_pins);
 802b15a:	4a0c      	ldr	r2, [pc, #48]	; (802b18c <bgt24mtr1x_start_tx+0x34>)

//============================================================================

void bgt24mtr1x_start_tx(void)
{
  bgt24mtr1x_global_config &= BGT24MTR1X_ENA_PA_MASK;
 802b15c:	880b      	ldrh	r3, [r1, #0]
 802b15e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
}

//============================================================================

void bgt24mtr1x_start_tx(void)
{
 802b162:	b500      	push	{lr}
  bgt24mtr1x_global_config &= BGT24MTR1X_ENA_PA_MASK;
 802b164:	041b      	lsls	r3, r3, #16
 802b166:	0c1b      	lsrs	r3, r3, #16
 802b168:	800b      	strh	r3, [r1, #0]
  bgt24mtr1x_set_config(bgt24mtr1x_global_config);
 802b16a:	880b      	ldrh	r3, [r1, #0]
}

//============================================================================

void bgt24mtr1x_start_tx(void)
{
 802b16c:	b083      	sub	sp, #12
  bgt24mtr1x_global_config &= BGT24MTR1X_ENA_PA_MASK;
  bgt24mtr1x_set_config(bgt24mtr1x_global_config);
 802b16e:	b29b      	uxth	r3, r3
  
  /* Lower byte goes to upper byte position */
  shuffled_data  = (config_val << 8);
  
  /* Upper byte goes to lower byte position */
  shuffled_data |= (config_val >> 8);
 802b170:	a802      	add	r0, sp, #8
 802b172:	0a19      	lsrs	r1, r3, #8
 802b174:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
 802b178:	f820 3d02 	strh.w	r3, [r0, #-2]!
  
  /* Transmit configuration data to BGT24MTR1x through SPI protocol */
  spi_transmit_data((uint8_t *)&shuffled_data , 2U, (void*) &bgt24mtr1x_spi_pins);
 802b17c:	2102      	movs	r1, #2
 802b17e:	f7ff faa5 	bl	802a6cc <spi_transmit_data>

void bgt24mtr1x_start_tx(void)
{
  bgt24mtr1x_global_config &= BGT24MTR1X_ENA_PA_MASK;
  bgt24mtr1x_set_config(bgt24mtr1x_global_config);
}
 802b182:	b003      	add	sp, #12
 802b184:	f85d fb04 	ldr.w	pc, [sp], #4
 802b188:	1ffe9012 	.word	0x1ffe9012
 802b18c:	1fff2b24 	.word	0x1fff2b24

0802b190 <bgt24mtr1x_stop_tx>:

//============================================================================

void bgt24mtr1x_stop_tx(void)
{
  bgt24mtr1x_global_config |= BGT24MTR1X_DIS_PA_MASK;
 802b190:	490b      	ldr	r1, [pc, #44]	; (802b1c0 <bgt24mtr1x_stop_tx+0x30>)
  
  /* Upper byte goes to lower byte position */
  shuffled_data |= (config_val >> 8);
  
  /* Transmit configuration data to BGT24MTR1x through SPI protocol */
  spi_transmit_data((uint8_t *)&shuffled_data , 2U, (void*) &bgt24mtr1x_spi_pins);
 802b192:	4a0c      	ldr	r2, [pc, #48]	; (802b1c4 <bgt24mtr1x_stop_tx+0x34>)

//============================================================================

void bgt24mtr1x_stop_tx(void)
{
  bgt24mtr1x_global_config |= BGT24MTR1X_DIS_PA_MASK;
 802b194:	880b      	ldrh	r3, [r1, #0]
}

//============================================================================

void bgt24mtr1x_stop_tx(void)
{
 802b196:	b500      	push	{lr}
  bgt24mtr1x_global_config |= BGT24MTR1X_DIS_PA_MASK;
 802b198:	b29b      	uxth	r3, r3
 802b19a:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 802b19e:	800b      	strh	r3, [r1, #0]
  bgt24mtr1x_set_config(bgt24mtr1x_global_config);
 802b1a0:	880b      	ldrh	r3, [r1, #0]
}

//============================================================================

void bgt24mtr1x_stop_tx(void)
{
 802b1a2:	b083      	sub	sp, #12
  bgt24mtr1x_global_config |= BGT24MTR1X_DIS_PA_MASK;
  bgt24mtr1x_set_config(bgt24mtr1x_global_config);
 802b1a4:	b29b      	uxth	r3, r3
  
  /* Lower byte goes to upper byte position */
  shuffled_data  = (config_val << 8);
  
  /* Upper byte goes to lower byte position */
  shuffled_data |= (config_val >> 8);
 802b1a6:	a802      	add	r0, sp, #8
 802b1a8:	0a19      	lsrs	r1, r3, #8
 802b1aa:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
 802b1ae:	f820 3d02 	strh.w	r3, [r0, #-2]!
  
  /* Transmit configuration data to BGT24MTR1x through SPI protocol */
  spi_transmit_data((uint8_t *)&shuffled_data , 2U, (void*) &bgt24mtr1x_spi_pins);
 802b1b2:	2102      	movs	r1, #2
 802b1b4:	f7ff fa8a 	bl	802a6cc <spi_transmit_data>

void bgt24mtr1x_stop_tx(void)
{
  bgt24mtr1x_global_config |= BGT24MTR1X_DIS_PA_MASK;
  bgt24mtr1x_set_config(bgt24mtr1x_global_config);
}
 802b1b8:	b003      	add	sp, #12
 802b1ba:	f85d fb04 	ldr.w	pc, [sp], #4
 802b1be:	bf00      	nop
 802b1c0:	1ffe9012 	.word	0x1ffe9012
 802b1c4:	1fff2b24 	.word	0x1fff2b24

0802b1c8 <bgt24mtr1x_set_tx_power>:
//============================================================================

void bgt24mtr1x_set_tx_power(Bgt24mtr1x_Power_t power_level)
{
  /* Clear the last 3-bits */
  bgt24mtr1x_global_config &= 0xFFF8;
 802b1c8:	4a22      	ldr	r2, [pc, #136]	; (802b254 <bgt24mtr1x_set_tx_power+0x8c>)
 802b1ca:	8813      	ldrh	r3, [r2, #0]
 802b1cc:	f023 0307 	bic.w	r3, r3, #7
 802b1d0:	041b      	lsls	r3, r3, #16
 802b1d2:	0c1b      	lsrs	r3, r3, #16
 802b1d4:	8013      	strh	r3, [r2, #0]
  
  switch (power_level)
 802b1d6:	2806      	cmp	r0, #6
 802b1d8:	d838      	bhi.n	802b24c <bgt24mtr1x_set_tx_power+0x84>
 802b1da:	e8df f000 	tbb	[pc, r0]
 802b1de:	1913      	.short	0x1913
 802b1e0:	312b251f 	.word	0x312b251f
 802b1e4:	04          	.byte	0x04
 802b1e5:	00          	.byte	0x00
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_2;
    break;
    
  case BGT24MTR1X_TX_LEVEL_6:
    /* Reduction by 0.4dBm */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_1;
 802b1e6:	8813      	ldrh	r3, [r2, #0]
 802b1e8:	b29b      	uxth	r3, r3
 802b1ea:	f043 0301 	orr.w	r3, r3, #1
 802b1ee:	8013      	strh	r3, [r2, #0]

//============================================================================

void bgt24mtr1x_ana_vout_tx(void)
{
  bgt24mtr1x_ana_command = BGT24MTR1X_ANA_CMD_TX_POWER;
 802b1f0:	4b19      	ldr	r3, [pc, #100]	; (802b258 <bgt24mtr1x_set_tx_power+0x90>)
 802b1f2:	2101      	movs	r1, #1
 802b1f4:	8019      	strh	r1, [r3, #0]
  
  bgt24mtr1x_global_config &= BGT24MTR1X_AMUX_VOUT_TX;
 802b1f6:	8813      	ldrh	r3, [r2, #0]
 802b1f8:	f423 5306 	bic.w	r3, r3, #8576	; 0x2180
 802b1fc:	041b      	lsls	r3, r3, #16
 802b1fe:	0c1b      	lsrs	r3, r3, #16
 802b200:	8013      	strh	r3, [r2, #0]
 802b202:	4770      	bx	lr
  
  switch (power_level)
  {
  case BGT24MTR1X_TX_MIN:
    /* Reduction by 9dBm */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_7;
 802b204:	8813      	ldrh	r3, [r2, #0]
 802b206:	b29b      	uxth	r3, r3
 802b208:	f043 0307 	orr.w	r3, r3, #7
 802b20c:	8013      	strh	r3, [r2, #0]
    break;
 802b20e:	e7ef      	b.n	802b1f0 <bgt24mtr1x_set_tx_power+0x28>
    
  case BGT24MTR1X_TX_LEVEL_1:
    /* Reduction by 6dBm */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_6;
 802b210:	8813      	ldrh	r3, [r2, #0]
 802b212:	b29b      	uxth	r3, r3
 802b214:	f043 0306 	orr.w	r3, r3, #6
 802b218:	8013      	strh	r3, [r2, #0]
    break;
 802b21a:	e7e9      	b.n	802b1f0 <bgt24mtr1x_set_tx_power+0x28>
    
  case BGT24MTR1X_TX_LEVEL_2:
    /* Reduction by 4dBm */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_5;
 802b21c:	8813      	ldrh	r3, [r2, #0]
 802b21e:	b29b      	uxth	r3, r3
 802b220:	f043 0305 	orr.w	r3, r3, #5
 802b224:	8013      	strh	r3, [r2, #0]
    break;
 802b226:	e7e3      	b.n	802b1f0 <bgt24mtr1x_set_tx_power+0x28>
    
  case BGT24MTR1X_TX_MID:
    /* Reduction by 2.5dBm */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_4;
 802b228:	8813      	ldrh	r3, [r2, #0]
 802b22a:	b29b      	uxth	r3, r3
 802b22c:	f043 0304 	orr.w	r3, r3, #4
 802b230:	8013      	strh	r3, [r2, #0]
    break;
 802b232:	e7dd      	b.n	802b1f0 <bgt24mtr1x_set_tx_power+0x28>
    
  case BGT24MTR1X_TX_LEVEL_4:
    /* Reduction by 1.4dBm */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_3;
 802b234:	8813      	ldrh	r3, [r2, #0]
 802b236:	b29b      	uxth	r3, r3
 802b238:	f043 0303 	orr.w	r3, r3, #3
 802b23c:	8013      	strh	r3, [r2, #0]
    break;
 802b23e:	e7d7      	b.n	802b1f0 <bgt24mtr1x_set_tx_power+0x28>
    
  case BGT24MTR1X_TX_LEVEL_5:
    /* Reduction by 0.8dBm */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_2;
 802b240:	8813      	ldrh	r3, [r2, #0]
 802b242:	b29b      	uxth	r3, r3
 802b244:	f043 0302 	orr.w	r3, r3, #2
 802b248:	8013      	strh	r3, [r2, #0]
    break;
 802b24a:	e7d1      	b.n	802b1f0 <bgt24mtr1x_set_tx_power+0x28>
    break;
    
  case BGT24MTR1X_TX_MAX:
  default:
    /* TX on with maximum power */
    bgt24mtr1x_global_config |= BGT24MTR1X_PC_PA_0;
 802b24c:	8813      	ldrh	r3, [r2, #0]
 802b24e:	b29b      	uxth	r3, r3
 802b250:	8013      	strh	r3, [r2, #0]
 802b252:	e7cd      	b.n	802b1f0 <bgt24mtr1x_set_tx_power+0x28>
 802b254:	1ffe9012 	.word	0x1ffe9012
 802b258:	1ffe9014 	.word	0x1ffe9014

0802b25c <bgt24mtr1x_lna_gain_enable>:

//============================================================================

void bgt24mtr1x_lna_gain_enable(void)
{
  bgt24mtr1x_global_config &= BGT24MTR1X_ENA_LNA_MASK;
 802b25c:	4a02      	ldr	r2, [pc, #8]	; (802b268 <bgt24mtr1x_lna_gain_enable+0xc>)
 802b25e:	8813      	ldrh	r3, [r2, #0]
 802b260:	f3c3 030e 	ubfx	r3, r3, #0, #15
 802b264:	8013      	strh	r3, [r2, #0]
 802b266:	4770      	bx	lr
 802b268:	1ffe9012 	.word	0x1ffe9012

0802b26c <bgt24mtr1x_lna_gain_disable>:

//============================================================================

void bgt24mtr1x_lna_gain_disable(void)
{
  bgt24mtr1x_global_config |= BGT24MTR1X_DIS_LNA_MASK;
 802b26c:	4a04      	ldr	r2, [pc, #16]	; (802b280 <bgt24mtr1x_lna_gain_disable+0x14>)
 802b26e:	8813      	ldrh	r3, [r2, #0]
 802b270:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 802b274:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 802b278:	b29b      	uxth	r3, r3
 802b27a:	8013      	strh	r3, [r2, #0]
 802b27c:	4770      	bx	lr
 802b27e:	bf00      	nop
 802b280:	1ffe9012 	.word	0x1ffe9012

0802b284 <bgt24mtr1x_set_config>:
}

//============================================================================

void bgt24mtr1x_set_config(uint16_t config_val)
{
 802b284:	b500      	push	{lr}
 802b286:	b083      	sub	sp, #12
  
  /* Lower byte goes to upper byte position */
  shuffled_data  = (config_val << 8);
  
  /* Upper byte goes to lower byte position */
  shuffled_data |= (config_val >> 8);
 802b288:	ab02      	add	r3, sp, #8
 802b28a:	0a02      	lsrs	r2, r0, #8
 802b28c:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
 802b290:	f823 0d02 	strh.w	r0, [r3, #-2]!
  
  /* Transmit configuration data to BGT24MTR1x through SPI protocol */
  spi_transmit_data((uint8_t *)&shuffled_data , 2U, (void*) &bgt24mtr1x_spi_pins);
 802b294:	2102      	movs	r1, #2
 802b296:	4618      	mov	r0, r3
 802b298:	4a02      	ldr	r2, [pc, #8]	; (802b2a4 <bgt24mtr1x_set_config+0x20>)
 802b29a:	f7ff fa17 	bl	802a6cc <spi_transmit_data>
}
 802b29e:	b003      	add	sp, #12
 802b2a0:	f85d fb04 	ldr.w	pc, [sp], #4
 802b2a4:	1fff2b24 	.word	0x1fff2b24

0802b2a8 <bgt24mtr1x_ana_temp>:

//============================================================================

void bgt24mtr1x_ana_temp(void)
{
  bgt24mtr1x_ana_command = BGT24MTR1X_ANA_CMD_TEMPERATURE;
 802b2a8:	4b07      	ldr	r3, [pc, #28]	; (802b2c8 <bgt24mtr1x_ana_temp+0x20>)
  
  bgt24mtr1x_global_config &= BGT24MTR1X_AMUX_VOUT_TX;
 802b2aa:	4a08      	ldr	r2, [pc, #32]	; (802b2cc <bgt24mtr1x_ana_temp+0x24>)

//============================================================================

void bgt24mtr1x_ana_temp(void)
{
  bgt24mtr1x_ana_command = BGT24MTR1X_ANA_CMD_TEMPERATURE;
 802b2ac:	2100      	movs	r1, #0
 802b2ae:	8019      	strh	r1, [r3, #0]
  
  bgt24mtr1x_global_config &= BGT24MTR1X_AMUX_VOUT_TX;
 802b2b0:	8813      	ldrh	r3, [r2, #0]
 802b2b2:	f423 5306 	bic.w	r3, r3, #8576	; 0x2180
 802b2b6:	041b      	lsls	r3, r3, #16
 802b2b8:	0c1b      	lsrs	r3, r3, #16
 802b2ba:	8013      	strh	r3, [r2, #0]
  
  bgt24mtr1x_global_config |= BGT24MTR1X_AMUX_2;
 802b2bc:	8813      	ldrh	r3, [r2, #0]
 802b2be:	b29b      	uxth	r3, r3
 802b2c0:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 802b2c4:	8013      	strh	r3, [r2, #0]
 802b2c6:	4770      	bx	lr
 802b2c8:	1ffe9014 	.word	0x1ffe9014
 802b2cc:	1ffe9012 	.word	0x1ffe9012

0802b2d0 <bgt24mtr1x_ana_vout_tx>:

//============================================================================

void bgt24mtr1x_ana_vout_tx(void)
{
  bgt24mtr1x_ana_command = BGT24MTR1X_ANA_CMD_TX_POWER;
 802b2d0:	4b05      	ldr	r3, [pc, #20]	; (802b2e8 <bgt24mtr1x_ana_vout_tx+0x18>)
  
  bgt24mtr1x_global_config &= BGT24MTR1X_AMUX_VOUT_TX;
 802b2d2:	4a06      	ldr	r2, [pc, #24]	; (802b2ec <bgt24mtr1x_ana_vout_tx+0x1c>)

//============================================================================

void bgt24mtr1x_ana_vout_tx(void)
{
  bgt24mtr1x_ana_command = BGT24MTR1X_ANA_CMD_TX_POWER;
 802b2d4:	2101      	movs	r1, #1
 802b2d6:	8019      	strh	r1, [r3, #0]
  
  bgt24mtr1x_global_config &= BGT24MTR1X_AMUX_VOUT_TX;
 802b2d8:	8813      	ldrh	r3, [r2, #0]
 802b2da:	f423 5306 	bic.w	r3, r3, #8576	; 0x2180
 802b2de:	041b      	lsls	r3, r3, #16
 802b2e0:	0c1b      	lsrs	r3, r3, #16
 802b2e2:	8013      	strh	r3, [r2, #0]
 802b2e4:	4770      	bx	lr
 802b2e6:	bf00      	nop
 802b2e8:	1ffe9014 	.word	0x1ffe9014
 802b2ec:	1ffe9012 	.word	0x1ffe9012

0802b2f0 <bgt24mtr1x_ana_vref_tx>:

//============================================================================

void bgt24mtr1x_ana_vref_tx(void)
{
  bgt24mtr1x_ana_command = BGT24MTR1X_ANA_CMD_TX_POWER_REF;
 802b2f0:	4b07      	ldr	r3, [pc, #28]	; (802b310 <bgt24mtr1x_ana_vref_tx+0x20>)
  
  bgt24mtr1x_global_config &= BGT24MTR1X_AMUX_VOUT_TX;
 802b2f2:	4a08      	ldr	r2, [pc, #32]	; (802b314 <bgt24mtr1x_ana_vref_tx+0x24>)

//============================================================================

void bgt24mtr1x_ana_vref_tx(void)
{
  bgt24mtr1x_ana_command = BGT24MTR1X_ANA_CMD_TX_POWER_REF;
 802b2f4:	2102      	movs	r1, #2
 802b2f6:	8019      	strh	r1, [r3, #0]
  
  bgt24mtr1x_global_config &= BGT24MTR1X_AMUX_VOUT_TX;
 802b2f8:	8813      	ldrh	r3, [r2, #0]
 802b2fa:	f423 5306 	bic.w	r3, r3, #8576	; 0x2180
 802b2fe:	041b      	lsls	r3, r3, #16
 802b300:	0c1b      	lsrs	r3, r3, #16
 802b302:	8013      	strh	r3, [r2, #0]
  
  bgt24mtr1x_global_config |= BGT24MTR1X_AMUX_0;
 802b304:	8813      	ldrh	r3, [r2, #0]
 802b306:	b29b      	uxth	r3, r3
 802b308:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 802b30c:	8013      	strh	r3, [r2, #0]
 802b30e:	4770      	bx	lr
 802b310:	1ffe9014 	.word	0x1ffe9014
 802b314:	1ffe9012 	.word	0x1ffe9012

0802b318 <bgt24mtr1x_get_ana_config>:

//============================================================================

uint16_t bgt24mtr1x_get_ana_config(void)
{
  return (bgt24mtr1x_ana_command);
 802b318:	4b01      	ldr	r3, [pc, #4]	; (802b320 <bgt24mtr1x_get_ana_config+0x8>)
 802b31a:	8818      	ldrh	r0, [r3, #0]
}
 802b31c:	b280      	uxth	r0, r0
 802b31e:	4770      	bx	lr
 802b320:	1ffe9014 	.word	0x1ffe9014

0802b324 <system_reset>:

//===========================================================================

/* This function yet to be filled in case of software reset */
void system_reset(void)
{
 802b324:	4770      	bx	lr
 802b326:	bf00      	nop

0802b328 <app_data_acq_started_cb>:
 *  it can be used to get information about the beginning of data acquisition
 */
void app_data_acq_started_cb(void *parameter)
{
  /* Turn On LED at the beginning of data acquisition */
  bsp_led_on();
 802b328:	f7fe bf7e 	b.w	802a228 <bsp_led_on>

0802b32c <app_data_acq_done_cb>:

/* This callback function will be executed by radar control at the end of data acquisition,
 * it is used to inform upper layers that data sampling is done and data is ready in user buffer
 */
void app_data_acq_done_cb(void *parameter)
{
 802b32c:	b508      	push	{r3, lr}
  /* Turn Off LED at the end of data acquisition */
  bsp_led_off();
 802b32e:	f7fe ff85 	bl	802a23c <bsp_led_off>

  /* Set the main application state at the end of data acquisition */
  g_adc_sampling_completed = true;
  radar_app_state = APP_RADAR_DATA_ACQUISITION_COMPLETED;
 802b332:	4b05      	ldr	r3, [pc, #20]	; (802b348 <app_data_acq_done_cb+0x1c>)
{
  /* Turn Off LED at the end of data acquisition */
  bsp_led_off();

  /* Set the main application state at the end of data acquisition */
  g_adc_sampling_completed = true;
 802b334:	4905      	ldr	r1, [pc, #20]	; (802b34c <app_data_acq_done_cb+0x20>)
  radar_app_state = APP_RADAR_DATA_ACQUISITION_COMPLETED;
 802b336:	2203      	movs	r2, #3
{
  /* Turn Off LED at the end of data acquisition */
  bsp_led_off();

  /* Set the main application state at the end of data acquisition */
  g_adc_sampling_completed = true;
 802b338:	2001      	movs	r0, #1
  radar_app_state = APP_RADAR_DATA_ACQUISITION_COMPLETED;
 802b33a:	701a      	strb	r2, [r3, #0]
  acq_completed_cb();
}
 802b33c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
  /* Turn Off LED at the end of data acquisition */
  bsp_led_off();

  /* Set the main application state at the end of data acquisition */
  g_adc_sampling_completed = true;
 802b340:	6008      	str	r0, [r1, #0]
  radar_app_state = APP_RADAR_DATA_ACQUISITION_COMPLETED;
  acq_completed_cb();
 802b342:	f001 bbbb 	b.w	802cabc <acq_completed_cb>
 802b346:	bf00      	nop
 802b348:	1ffe9094 	.word	0x1ffe9094
 802b34c:	1ffe97c4 	.word	0x1ffe97c4

0802b350 <app_init>:
   5. EXPORTED FUNCTIONS
==============================================================================
 */

void app_init(void)
{
 802b350:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  /* Initialize USB */
  if(bsp_usb_init(BSP_USB_TIMEOUT) == 0)
 802b354:	f640 70ff 	movw	r0, #4095	; 0xfff
   5. EXPORTED FUNCTIONS
==============================================================================
 */

void app_init(void)
{
 802b358:	b083      	sub	sp, #12
  /* Initialize USB */
  if(bsp_usb_init(BSP_USB_TIMEOUT) == 0)
 802b35a:	f7fe ff19 	bl	802a190 <bsp_usb_init>
 802b35e:	b910      	cbnz	r0, 802b366 <app_init+0x16>
  {
    g_usb_init = true;
 802b360:	4b48      	ldr	r3, [pc, #288]	; (802b484 <app_init+0x134>)
 802b362:	2201      	movs	r2, #1
 802b364:	701a      	strb	r2, [r3, #0]
  }

  /* Open the available radar device */
  if(radar_open_device(0, &h_radar_device) != RADAR_ERR_OK)
 802b366:	4f48      	ldr	r7, [pc, #288]	; (802b488 <app_init+0x138>)
 802b368:	2000      	movs	r0, #0
 802b36a:	4639      	mov	r1, r7
 802b36c:	f7f5 f9b0 	bl	80206d0 <radar_open_device>
 802b370:	b100      	cbz	r0, 802b374 <app_init+0x24>
  {
    XMC_DEBUG("Opening Radar device failed\n");
    while(1U);
 802b372:	e7fe      	b.n	802b372 <app_init+0x22>
  }

  /* Register user callback functions */
  radar_register_callback(RADAR_ACQUISITION_STARTED_CB_ID, app_data_acq_started_cb);
 802b374:	4945      	ldr	r1, [pc, #276]	; (802b48c <app_init+0x13c>)
    EP_RADAR_P2G_ENDPOINT_LIST_ENTRY(h_radar_device),
    EP_CALIBRATION_ENDPOINT_LIST_ENTRY(h_radar_device),
    EP_TARGET_DETECTION_ENDPOINT_LIST_ENTRY(h_radar_device)
  };

  memcpy(endpoint_list, ep_list, NUMBER_SUPPORTED_ENDPOINTS * sizeof(Endpoint_t));
 802b376:	4c46      	ldr	r4, [pc, #280]	; (802b490 <app_init+0x140>)
 802b378:	f8df a148 	ldr.w	sl, [pc, #328]	; 802b4c4 <app_init+0x174>
 802b37c:	f8df 9148 	ldr.w	r9, [pc, #328]	; 802b4c8 <app_init+0x178>
 802b380:	f8df 8148 	ldr.w	r8, [pc, #328]	; 802b4cc <app_init+0x17c>
 802b384:	4e43      	ldr	r6, [pc, #268]	; (802b494 <app_init+0x144>)
 802b386:	4d44      	ldr	r5, [pc, #272]	; (802b498 <app_init+0x148>)
 802b388:	f8df b144 	ldr.w	fp, [pc, #324]	; 802b4d0 <app_init+0x180>
    XMC_DEBUG("Opening Radar device failed\n");
    while(1U);
  }

  /* Register user callback functions */
  radar_register_callback(RADAR_ACQUISITION_STARTED_CB_ID, app_data_acq_started_cb);
 802b38c:	2001      	movs	r0, #1
 802b38e:	f7f5 ff53 	bl	8021238 <radar_register_callback>
  radar_register_callback(RADAR_ACQUISITION_DONE_CB_ID, app_data_acq_done_cb);
 802b392:	4942      	ldr	r1, [pc, #264]	; (802b49c <app_init+0x14c>)
 802b394:	2002      	movs	r0, #2
 802b396:	f7f5 ff4f 	bl	8021238 <radar_register_callback>
    EP_RADAR_P2G_ENDPOINT_LIST_ENTRY(h_radar_device),
    EP_CALIBRATION_ENDPOINT_LIST_ENTRY(h_radar_device),
    EP_TARGET_DETECTION_ENDPOINT_LIST_ENTRY(h_radar_device)
  };

  memcpy(endpoint_list, ep_list, NUMBER_SUPPORTED_ENDPOINTS * sizeof(Endpoint_t));
 802b39a:	f8df c138 	ldr.w	ip, [pc, #312]	; 802b4d4 <app_init+0x184>
 802b39e:	4940      	ldr	r1, [pc, #256]	; (802b4a0 <app_init+0x150>)
 802b3a0:	f8df e134 	ldr.w	lr, [pc, #308]	; 802b4d8 <app_init+0x188>
 802b3a4:	483f      	ldr	r0, [pc, #252]	; (802b4a4 <app_init+0x154>)
 802b3a6:	4a40      	ldr	r2, [pc, #256]	; (802b4a8 <app_init+0x158>)
 802b3a8:	4b40      	ldr	r3, [pc, #256]	; (802b4ac <app_init+0x15c>)
 802b3aa:	f8c4 a000 	str.w	sl, [r4]
 802b3ae:	f8c4 c014 	str.w	ip, [r4, #20]
 802b3b2:	62a1      	str	r1, [r4, #40]	; 0x28
 802b3b4:	f50a 2ae1 	add.w	sl, sl, #460800	; 0x70800
 802b3b8:	f50c 2c6e 	add.w	ip, ip, #974848	; 0xee000
 802b3bc:	f5a1 3142 	sub.w	r1, r1, #198656	; 0x30800
 802b3c0:	f8c4 9008 	str.w	r9, [r4, #8]
 802b3c4:	f8c4 8010 	str.w	r8, [r4, #16]
 802b3c8:	f8df 9110 	ldr.w	r9, [pc, #272]	; 802b4dc <app_init+0x18c>
 802b3cc:	f8df 8110 	ldr.w	r8, [pc, #272]	; 802b4e0 <app_init+0x190>
 802b3d0:	f8c4 e01c 	str.w	lr, [r4, #28]
 802b3d4:	f60c 5cef 	addw	ip, ip, #3567	; 0xdef
 802b3d8:	f8df e108 	ldr.w	lr, [pc, #264]	; 802b4e4 <app_init+0x194>
 802b3dc:	6260      	str	r0, [r4, #36]	; 0x24
 802b3de:	f2a1 31f7 	subw	r1, r1, #1015	; 0x3f7
 802b3e2:	4833      	ldr	r0, [pc, #204]	; (802b4b0 <app_init+0x160>)
 802b3e4:	6326      	str	r6, [r4, #48]	; 0x30
 802b3e6:	63a5      	str	r5, [r4, #56]	; 0x38
 802b3e8:	2601      	movs	r6, #1
  /* Register user callback functions */
  radar_register_callback(RADAR_ACQUISITION_STARTED_CB_ID, app_data_acq_started_cb);
  radar_register_callback(RADAR_ACQUISITION_DONE_CB_ID, app_data_acq_done_cb);

  /* Register all endpoints to the communication protocol */
  Endpoint_t ep_list[NUMBER_SUPPORTED_ENDPOINTS] =
 802b3ea:	683d      	ldr	r5, [r7, #0]
    EP_RADAR_P2G_ENDPOINT_LIST_ENTRY(h_radar_device),
    EP_CALIBRATION_ENDPOINT_LIST_ENTRY(h_radar_device),
    EP_TARGET_DETECTION_ENDPOINT_LIST_ENTRY(h_radar_device)
  };

  memcpy(endpoint_list, ep_list, NUMBER_SUPPORTED_ENDPOINTS * sizeof(Endpoint_t));
 802b3ec:	63e2      	str	r2, [r4, #60]	; 0x3c
 802b3ee:	6463      	str	r3, [r4, #68]	; 0x44
 802b3f0:	4a30      	ldr	r2, [pc, #192]	; (802b4b4 <app_init+0x164>)

  /* Initialize the internal protocol state and the communication interface */
  protocol_init(endpoint_list, sizeof(endpoint_list)/sizeof(endpoint_list[0]), SYSTIMER_GetTime, BSP_HOST_TIMEOUT_USEC, system_reset);
 802b3f2:	4b31      	ldr	r3, [pc, #196]	; (802b4b8 <app_init+0x168>)
    EP_RADAR_P2G_ENDPOINT_LIST_ENTRY(h_radar_device),
    EP_CALIBRATION_ENDPOINT_LIST_ENTRY(h_radar_device),
    EP_TARGET_DETECTION_ENDPOINT_LIST_ENTRY(h_radar_device)
  };

  memcpy(endpoint_list, ep_list, NUMBER_SUPPORTED_ENDPOINTS * sizeof(Endpoint_t));
 802b3f4:	f8c4 9058 	str.w	r9, [r4, #88]	; 0x58
 802b3f8:	f20a 4af1 	addw	sl, sl, #1265	; 0x4f1
 802b3fc:	f8c4 8060 	str.w	r8, [r4, #96]	; 0x60
 802b400:	f8c4 c064 	str.w	ip, [r4, #100]	; 0x64
 802b404:	f8c4 e06c 	str.w	lr, [r4, #108]	; 0x6c
 802b408:	6760      	str	r0, [r4, #116]	; 0x74
 802b40a:	67a1      	str	r1, [r4, #120]	; 0x78
 802b40c:	f8df c0d8 	ldr.w	ip, [pc, #216]	; 802b4e8 <app_init+0x198>
 802b410:	f8df e0d8 	ldr.w	lr, [pc, #216]	; 802b4ec <app_init+0x19c>
 802b414:	f8c4 b04c 	str.w	fp, [r4, #76]	; 0x4c

  /* Initialize the internal protocol state and the communication interface */
  protocol_init(endpoint_list, sizeof(endpoint_list)/sizeof(endpoint_list[0]), SYSTIMER_GetTime, BSP_HOST_TIMEOUT_USEC, system_reset);
 802b418:	4620      	mov	r0, r4
    EP_RADAR_P2G_ENDPOINT_LIST_ENTRY(h_radar_device),
    EP_CALIBRATION_ENDPOINT_LIST_ENTRY(h_radar_device),
    EP_TARGET_DETECTION_ENDPOINT_LIST_ENTRY(h_radar_device)
  };

  memcpy(endpoint_list, ep_list, NUMBER_SUPPORTED_ENDPOINTS * sizeof(Endpoint_t));
 802b41a:	f8c4 a050 	str.w	sl, [r4, #80]	; 0x50
 802b41e:	80a6      	strh	r6, [r4, #4]
 802b420:	8326      	strh	r6, [r4, #24]
 802b422:	85a6      	strh	r6, [r4, #44]	; 0x2c
 802b424:	f8a4 6040 	strh.w	r6, [r4, #64]	; 0x40
 802b428:	f8a4 6054 	strh.w	r6, [r4, #84]	; 0x54
 802b42c:	f8a4 6068 	strh.w	r6, [r4, #104]	; 0x68
 802b430:	f8a4 607c 	strh.w	r6, [r4, #124]	; 0x7c
 802b434:	60e5      	str	r5, [r4, #12]
 802b436:	6225      	str	r5, [r4, #32]
 802b438:	6365      	str	r5, [r4, #52]	; 0x34
 802b43a:	64a5      	str	r5, [r4, #72]	; 0x48
 802b43c:	65e5      	str	r5, [r4, #92]	; 0x5c
 802b43e:	6725      	str	r5, [r4, #112]	; 0x70
 802b440:	f8df 90ac 	ldr.w	r9, [pc, #172]	; 802b4f0 <app_init+0x1a0>
 802b444:	f8c4 2080 	str.w	r2, [r4, #128]	; 0x80
 802b448:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 802b4f4 <app_init+0x1a4>

  /* Initialize the internal protocol state and the communication interface */
  protocol_init(endpoint_list, sizeof(endpoint_list)/sizeof(endpoint_list[0]), SYSTIMER_GetTime, BSP_HOST_TIMEOUT_USEC, system_reset);
 802b44c:	9300      	str	r3, [sp, #0]
 802b44e:	2108      	movs	r1, #8
 802b450:	4a1a      	ldr	r2, [pc, #104]	; (802b4bc <app_init+0x16c>)
 802b452:	4b1b      	ldr	r3, [pc, #108]	; (802b4c0 <app_init+0x170>)
    EP_RADAR_P2G_ENDPOINT_LIST_ENTRY(h_radar_device),
    EP_CALIBRATION_ENDPOINT_LIST_ENTRY(h_radar_device),
    EP_TARGET_DETECTION_ENDPOINT_LIST_ENTRY(h_radar_device)
  };

  memcpy(endpoint_list, ep_list, NUMBER_SUPPORTED_ENDPOINTS * sizeof(Endpoint_t));
 802b454:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
 802b458:	f8a4 6090 	strh.w	r6, [r4, #144]	; 0x90
 802b45c:	f8c4 5098 	str.w	r5, [r4, #152]	; 0x98
 802b460:	f8c4 9088 	str.w	r9, [r4, #136]	; 0x88
 802b464:	f8c4 808c 	str.w	r8, [r4, #140]	; 0x8c
 802b468:	f8c4 c094 	str.w	ip, [r4, #148]	; 0x94
 802b46c:	f8c4 e09c 	str.w	lr, [r4, #156]	; 0x9c

  /* Initialize the internal protocol state and the communication interface */
  protocol_init(endpoint_list, sizeof(endpoint_list)/sizeof(endpoint_list[0]), SYSTIMER_GetTime, BSP_HOST_TIMEOUT_USEC, system_reset);
 802b470:	f7f9 fe98 	bl	80251a4 <protocol_init>

  /* Start data acquisition at the defined frame interval */
  if (radar_start_acquisition(h_radar_device) != RADAR_ERR_OK)
 802b474:	6838      	ldr	r0, [r7, #0]
 802b476:	f7f5 fe2b 	bl	80210d0 <radar_start_acquisition>
 802b47a:	b100      	cbz	r0, 802b47e <app_init+0x12e>
  {
    XMC_DEBUG("Starting Radar data acquisition failed\n");
    while(1U);
 802b47c:	e7fe      	b.n	802b47c <app_init+0x12c>
  }
}
 802b47e:	b003      	add	sp, #12
 802b480:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802b484:	1fff2b34 	.word	0x1fff2b34
 802b488:	1fff2b3c 	.word	0x1fff2b3c
 802b48c:	0802b329 	.word	0x0802b329
 802b490:	2000da88 	.word	0x2000da88
 802b494:	08024abd 	.word	0x08024abd
 802b498:	08024bb1 	.word	0x08024bb1
 802b49c:	0802b32d 	.word	0x0802b32d
 802b4a0:	52464d43 	.word	0x52464d43
 802b4a4:	08023f31 	.word	0x08023f31
 802b4a8:	5244504c 	.word	0x5244504c
 802b4ac:	080248e5 	.word	0x080248e5
 802b4b0:	08024d6d 	.word	0x08024d6d
 802b4b4:	08023c25 	.word	0x08023c25
 802b4b8:	0802b325 	.word	0x0802b325
 802b4bc:	08026fdd 	.word	0x08026fdd
 802b4c0:	00989680 	.word	0x00989680
 802b4c4:	52424153 	.word	0x52424153
 802b4c8:	08023f95 	.word	0x08023f95
 802b4cc:	080246dd 	.word	0x080246dd
 802b4d0:	08024985 	.word	0x08024985
 802b4d4:	52414458 	.word	0x52414458
 802b4d8:	08023e79 	.word	0x08023e79
 802b4dc:	08024c41 	.word	0x08024c41
 802b4e0:	08024cf9 	.word	0x08024cf9
 802b4e4:	08024cfd 	.word	0x08024cfd
 802b4e8:	08024d71 	.word	0x08024d71
 802b4ec:	08025059 	.word	0x08025059
 802b4f0:	08023e11 	.word	0x08023e11
 802b4f4:	52544443 	.word	0x52544443

0802b4f8 <app_register_algo_process>:
//===========================================================================

void app_register_algo_process(algorithm algo_processor)
{
  /* Register algorithm processing function */
  algo_processing_function = algo_processor;
 802b4f8:	4b01      	ldr	r3, [pc, #4]	; (802b500 <app_register_algo_process+0x8>)
 802b4fa:	6018      	str	r0, [r3, #0]
 802b4fc:	4770      	bx	lr
 802b4fe:	bf00      	nop
 802b500:	1fff2b38 	.word	0x1fff2b38

0802b504 <app_process>:
}

//===========================================================================

void app_process(void)
{
 802b504:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (g_usb_init == true)
 802b508:	4c33      	ldr	r4, [pc, #204]	; (802b5d8 <app_process+0xd4>)
 802b50a:	7823      	ldrb	r3, [r4, #0]
 802b50c:	2b01      	cmp	r3, #1
}

//===========================================================================

void app_process(void)
{
 802b50e:	b082      	sub	sp, #8
  if (g_usb_init == true)
 802b510:	d05e      	beq.n	802b5d0 <app_process+0xcc>
    protocol_run();
  }
  else
  {
    /* Initialize the USB low layer driver and start USB data communication */
    if(bsp_usb_init(BSP_USB_TIMEOUT) == 0)
 802b512:	f640 70ff 	movw	r0, #4095	; 0xfff
 802b516:	f7fe fe3b 	bl	802a190 <bsp_usb_init>
 802b51a:	b908      	cbnz	r0, 802b520 <app_process+0x1c>
    {
      g_usb_init = true;
 802b51c:	2301      	movs	r3, #1
 802b51e:	7023      	strb	r3, [r4, #0]

//===========================================================================

void radar_app_process(void)
{
  switch(radar_app_state)
 802b520:	4c2e      	ldr	r4, [pc, #184]	; (802b5dc <app_process+0xd8>)
 802b522:	7823      	ldrb	r3, [r4, #0]
 802b524:	2b03      	cmp	r3, #3
 802b526:	d018      	beq.n	802b55a <app_process+0x56>
 802b528:	2b04      	cmp	r3, #4
 802b52a:	d00d      	beq.n	802b548 <app_process+0x44>
 802b52c:	2b02      	cmp	r3, #2
 802b52e:	d002      	beq.n	802b536 <app_process+0x32>
    }
  }

  /* Main radar application process */
  radar_app_process();
}
 802b530:	b002      	add	sp, #8
 802b532:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	{
	  radar_app_state = APP_IDLE;
	}
	break;
  case APP_APPLY_DEVICE_SETTINGS:
    if(ds_is_device_settings_updated())
 802b536:	f7f4 fe05 	bl	8020144 <ds_is_device_settings_updated>
 802b53a:	2800      	cmp	r0, #0
 802b53c:	d13b      	bne.n	802b5b6 <app_process+0xb2>
	{
	  radar_app_state = APP_APPLY_DEVICE_SETTINGS;
	}
	else
	{
	  radar_app_state = APP_IDLE;
 802b53e:	2301      	movs	r3, #1
 802b540:	7023      	strb	r3, [r4, #0]
    }
  }

  /* Main radar application process */
  radar_app_process();
}
 802b542:	b002      	add	sp, #8
 802b544:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    radar_app_state = APP_CHECK_FOR_SETTINGS_UPDATE;
    break;

   case APP_CHECK_FOR_SETTINGS_UPDATE:
	/* Check if a new hardware settings are required */
    if(ds_is_device_settings_updated())
 802b548:	f7f4 fdfc 	bl	8020144 <ds_is_device_settings_updated>
 802b54c:	2800      	cmp	r0, #0
 802b54e:	d0f6      	beq.n	802b53e <app_process+0x3a>
	{
	  radar_app_state = APP_APPLY_DEVICE_SETTINGS;
 802b550:	2302      	movs	r3, #2
 802b552:	7023      	strb	r3, [r4, #0]
    }
  }

  /* Main radar application process */
  radar_app_process();
}
 802b554:	b002      	add	sp, #8
 802b556:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  case APP_IDLE:
    break;

  case APP_RADAR_DATA_ACQUISITION_COMPLETED:
    #if defined(FMCW_SUPPORTED) || defined(DOPPLER_SUPPORTED)
      if (g_do_processing)
 802b55a:	4b21      	ldr	r3, [pc, #132]	; (802b5e0 <app_process+0xdc>)
 802b55c:	681b      	ldr	r3, [r3, #0]
 802b55e:	b32b      	cbz	r3, 802b5ac <app_process+0xa8>
      {
        /* Start the processing of the algorithm assigned in the function pointer 'algo_processor' */
    	if (algo_processing_function != NULL)
 802b560:	4d20      	ldr	r5, [pc, #128]	; (802b5e4 <app_process+0xe0>)
 802b562:	682b      	ldr	r3, [r5, #0]
 802b564:	b313      	cbz	r3, 802b5ac <app_process+0xa8>

void do_algo_helper(void)
{
  static uint32_t median_filter_len = 0;

  acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 802b566:	f7f4 fe4f 	bl	8020208 <ds_get_active_acq_buf>
 802b56a:	4607      	mov	r7, r0

  algo_settings_t *p_algo_settings;
  device_settings_t *p_dev_settings;

  p_algo_settings = ds_algo_get_settings();
 802b56c:	f7f4 fd86 	bl	802007c <ds_algo_get_settings>
 802b570:	4606      	mov	r6, r0

  /* the shadow remains unchanged during algorithm execution, so we do not need to copy into a extra copy! */
  p_dev_settings = ds_device_get_shadow_settings();
 802b572:	f7f4 fde3 	bl	802013c <ds_device_get_shadow_settings>

  // tests for updated values
  if(median_filter_len != p_algo_settings->median_filter_len)
 802b576:	491c      	ldr	r1, [pc, #112]	; (802b5e8 <app_process+0xe4>)
 802b578:	69b3      	ldr	r3, [r6, #24]
 802b57a:	680a      	ldr	r2, [r1, #0]
 802b57c:	4293      	cmp	r3, r2
  device_settings_t *p_dev_settings;

  p_algo_settings = ds_algo_get_settings();

  /* the shadow remains unchanged during algorithm execution, so we do not need to copy into a extra copy! */
  p_dev_settings = ds_device_get_shadow_settings();
 802b57e:	4680      	mov	r8, r0

  // tests for updated values
  if(median_filter_len != p_algo_settings->median_filter_len)
 802b580:	d003      	beq.n	802b58a <app_process+0x86>
  {
	  /* To re-init the median filter, if the setting is changed, is a duty of the algorithm module, not of the interface! */
	  median_filter_len = p_algo_settings->median_filter_len;
	  median_filter_init(median_filter_len);
 802b582:	4618      	mov	r0, r3

  // tests for updated values
  if(median_filter_len != p_algo_settings->median_filter_len)
  {
	  /* To re-init the median filter, if the setting is changed, is a duty of the algorithm module, not of the interface! */
	  median_filter_len = p_algo_settings->median_filter_len;
 802b584:	600b      	str	r3, [r1, #0]
	  median_filter_init(median_filter_len);
 802b586:	f001 fa5f 	bl	802ca48 <median_filter_init>

  static algo_target_list_t target_list = { .max_num_of_targets = MAX_NUM_OF_TARGETS, .num_of_targets = 0 };

  algo_result_t algo_result;

  target_list.num_of_targets = 0;
 802b58a:	4b18      	ldr	r3, [pc, #96]	; (802b5ec <app_process+0xe8>)
  algo_result.p_target_list  = &target_list;
 802b58c:	9301      	str	r3, [sp, #4]

  static algo_target_list_t target_list = { .max_num_of_targets = MAX_NUM_OF_TARGETS, .num_of_targets = 0 };

  algo_result_t algo_result;

  target_list.num_of_targets = 0;
 802b58e:	f04f 0e00 	mov.w	lr, #0
 802b592:	f8c3 e000 	str.w	lr, [r3]
  algo_result.p_target_list  = &target_list;

  algo_processing_function(p_acq_buf, p_algo_settings, p_dev_settings, &algo_result);
 802b596:	4638      	mov	r0, r7
 802b598:	4631      	mov	r1, r6
 802b59a:	4642      	mov	r2, r8
 802b59c:	466b      	mov	r3, sp
 802b59e:	682d      	ldr	r5, [r5, #0]
 802b5a0:	47a8      	blx	r5

  store_algo_result(&algo_result);
 802b5a2:	4668      	mov	r0, sp
 802b5a4:	f7f4 fd2c 	bl	8020000 <store_algo_result>
  algo_completed_cb();
 802b5a8:	f001 fa8a 	bl	802cac0 <algo_completed_cb>
    	}
      }
    #endif

    /* Check if a new hardware settings are required */
    radar_app_state = APP_CHECK_FOR_SETTINGS_UPDATE;
 802b5ac:	2304      	movs	r3, #4
 802b5ae:	7023      	strb	r3, [r4, #0]
    }
  }

  /* Main radar application process */
  radar_app_process();
}
 802b5b0:	b002      	add	sp, #8
 802b5b2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	}
	break;
  case APP_APPLY_DEVICE_SETTINGS:
    if(ds_is_device_settings_updated())
	{
	  device_settings_t *p_dev_settings = ds_device_get_settings();
 802b5b6:	f7f4 fdbd 	bl	8020134 <ds_device_get_settings>

	  if(radar_apply_hw_settings(h_radar_device, UPDATE, p_dev_settings) == RADAR_ERR_OK)
 802b5ba:	4b0d      	ldr	r3, [pc, #52]	; (802b5f0 <app_process+0xec>)
	}
	break;
  case APP_APPLY_DEVICE_SETTINGS:
    if(ds_is_device_settings_updated())
	{
	  device_settings_t *p_dev_settings = ds_device_get_settings();
 802b5bc:	4602      	mov	r2, r0

	  if(radar_apply_hw_settings(h_radar_device, UPDATE, p_dev_settings) == RADAR_ERR_OK)
 802b5be:	2104      	movs	r1, #4
 802b5c0:	6818      	ldr	r0, [r3, #0]
 802b5c2:	f7f5 fe47 	bl	8021254 <radar_apply_hw_settings>
 802b5c6:	2800      	cmp	r0, #0
 802b5c8:	d1b9      	bne.n	802b53e <app_process+0x3a>
	  {
	    ds_device_settings_copy_to_shadow();
 802b5ca:	f7f4 fdc9 	bl	8020160 <ds_device_settings_copy_to_shadow>
 802b5ce:	e7b6      	b.n	802b53e <app_process+0x3a>
void app_process(void)
{
  if (g_usb_init == true)
  {
    /* Run communication protocol */
    protocol_run();
 802b5d0:	f7f9 fe36 	bl	8025240 <protocol_run>
 802b5d4:	e7a4      	b.n	802b520 <app_process+0x1c>
 802b5d6:	bf00      	nop
 802b5d8:	1fff2b34 	.word	0x1fff2b34
 802b5dc:	1ffe9094 	.word	0x1ffe9094
 802b5e0:	1ffe88a8 	.word	0x1ffe88a8
 802b5e4:	1fff2b38 	.word	0x1fff2b38
 802b5e8:	1fff2b40 	.word	0x1fff2b40
 802b5ec:	1ffe9018 	.word	0x1ffe9018
 802b5f0:	1fff2b3c 	.word	0x1fff2b3c
 802b5f4:	00000000 	.word	0x00000000

0802b5f8 <range_doppler_do>:
    4. EXPORTED FUNCTIONS
==============================================================================
 */

void range_doppler_do(acq_buf_obj *p_acq_buf, const algo_settings_t *cp_algo_settings, const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
 802b5f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802b5fc:	ed2d 8b08 	vpush	{d8-d11}
 802b600:	b0ad      	sub	sp, #180	; 0xb4
 802b602:	460c      	mov	r4, r1
 802b604:	9116      	str	r1, [sp, #88]	; 0x58
  
  float Fd_per_bin = 1.0f/(float)(PulseRepTime_sec * DOPPLER_FFT_SIZE);  // Doppler Per bin
  
  //--------------------------------------------------------------------------
  
  alpha_mti = 1.0f / cp_algo_settings->mti_filter_len;
 802b606:	69c9      	ldr	r1, [r1, #28]
 802b608:	9108      	str	r1, [sp, #32]
 802b60a:	eddd 7a08 	vldr	s15, [sp, #32]
  
  float max_value;
  
  float PulseRepTime_sec = (float)(cp_dev_settings->pll_chirp_time_usec + PLL_RAMP_DOWM_TIME_USEC + PLL_STEADY_STATE_USEC) * 1e-6;  // Chirp repetition time in seconds
  
  float range_detection_threshold = cp_algo_settings->range_detection_threshold;
 802b60e:	6b61      	ldr	r1, [r4, #52]	; 0x34
    4. EXPORTED FUNCTIONS
==============================================================================
 */

void range_doppler_do(acq_buf_obj *p_acq_buf, const algo_settings_t *cp_algo_settings, const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
 802b610:	9015      	str	r0, [sp, #84]	; 0x54
  
  float Fd_per_bin = 1.0f/(float)(PulseRepTime_sec * DOPPLER_FFT_SIZE);  // Doppler Per bin
  
  //--------------------------------------------------------------------------
  
  alpha_mti = 1.0f / cp_algo_settings->mti_filter_len;
 802b612:	eef8 7a67 	vcvt.f32.u32	s15, s15
 802b616:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 802b61a:	eec7 7a27 	vdiv.f32	s15, s14, s15
    4. EXPORTED FUNCTIONS
==============================================================================
 */

void range_doppler_do(acq_buf_obj *p_acq_buf, const algo_settings_t *cp_algo_settings, const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
 802b61e:	461e      	mov	r6, r3
 802b620:	4604      	mov	r4, r0
  algo_target_list_t *p_targets = p_algo_result->p_target_list;
  
  uint32_t Nc = p_acq_buf->params.num_of_chirps_per_frame;
  uint32_t Ns = p_acq_buf->params.num_of_samples_per_chirp;
 802b622:	8840      	ldrh	r0, [r0, #2]
  
  alpha_mti = 1.0f / cp_algo_settings->mti_filter_len;
  
  beta_mti = (1.0f - alpha_mti);
  
  if (samples_per_channel != Ns)
 802b624:	4dc1      	ldr	r5, [pc, #772]	; (802b92c <range_doppler_do+0x334>)
    4. EXPORTED FUNCTIONS
==============================================================================
 */

void range_doppler_do(acq_buf_obj *p_acq_buf, const algo_settings_t *cp_algo_settings, const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
 802b626:	9318      	str	r3, [sp, #96]	; 0x60
  algo_target_list_t *p_targets = p_algo_result->p_target_list;
  
  uint32_t Nc = p_acq_buf->params.num_of_chirps_per_frame;
  uint32_t Ns = p_acq_buf->params.num_of_samples_per_chirp;
 802b628:	900e      	str	r0, [sp, #56]	; 0x38
 802b62a:	4603      	mov	r3, r0
==============================================================================
 */

void range_doppler_do(acq_buf_obj *p_acq_buf, const algo_settings_t *cp_algo_settings, const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
  algo_target_list_t *p_targets = p_algo_result->p_target_list;
 802b62c:	6870      	ldr	r0, [r6, #4]
 802b62e:	9017      	str	r0, [sp, #92]	; 0x5c
  
  uint32_t i, j;
  uint32_t max_idx;
  uint32_t max_idx_arr;
  uint32_t cal_idx;
  uint32_t interp_factor = MAX_CALIB_SAMPLES_PER_CHANNEL / Ns;
 802b630:	f44f 7680 	mov.w	r6, #256	; 0x100
 802b634:	4618      	mov	r0, r3
 802b636:	fbb6 f3f3 	udiv	r3, r6, r3
 802b63a:	930a      	str	r3, [sp, #40]	; 0x28
  
  float Fd_per_bin = 1.0f/(float)(PulseRepTime_sec * DOPPLER_FFT_SIZE);  // Doppler Per bin
  
  //--------------------------------------------------------------------------
  
  alpha_mti = 1.0f / cp_algo_settings->mti_filter_len;
 802b63c:	4bbc      	ldr	r3, [pc, #752]	; (802b930 <range_doppler_do+0x338>)
  
  float max_value;
  
  float PulseRepTime_sec = (float)(cp_dev_settings->pll_chirp_time_usec + PLL_RAMP_DOWM_TIME_USEC + PLL_STEADY_STATE_USEC) * 1e-6;  // Chirp repetition time in seconds
  
  float range_detection_threshold = cp_algo_settings->range_detection_threshold;
 802b63e:	9107      	str	r1, [sp, #28]
  
  alpha_mti = 1.0f / cp_algo_settings->mti_filter_len;
  
  beta_mti = (1.0f - alpha_mti);
  
  if (samples_per_channel != Ns)
 802b640:	6829      	ldr	r1, [r5, #0]
  
  float Fd_per_bin = 1.0f/(float)(PulseRepTime_sec * DOPPLER_FFT_SIZE);  // Doppler Per bin
  
  //--------------------------------------------------------------------------
  
  alpha_mti = 1.0f / cp_algo_settings->mti_filter_len;
 802b642:	edc3 7a00 	vstr	s15, [r3]
  
  float max_value;
  
  float PulseRepTime_sec = (float)(cp_dev_settings->pll_chirp_time_usec + PLL_RAMP_DOWM_TIME_USEC + PLL_STEADY_STATE_USEC) * 1e-6;  // Chirp repetition time in seconds
  
  float range_detection_threshold = cp_algo_settings->range_detection_threshold;
 802b646:	eddd 6a07 	vldr	s13, [sp, #28]
  
  //--------------------------------------------------------------------------
  
  alpha_mti = 1.0f / cp_algo_settings->mti_filter_len;
  
  beta_mti = (1.0f - alpha_mti);
 802b64a:	4bba      	ldr	r3, [pc, #744]	; (802b934 <range_doppler_do+0x33c>)
    4. EXPORTED FUNCTIONS
==============================================================================
 */

void range_doppler_do(acq_buf_obj *p_acq_buf, const algo_settings_t *cp_algo_settings, const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
 802b64c:	921a      	str	r2, [sp, #104]	; 0x68
  
  //--------------------------------------------------------------------------
  
  alpha_mti = 1.0f / cp_algo_settings->mti_filter_len;
  
  beta_mti = (1.0f - alpha_mti);
 802b64e:	ee37 7a67 	vsub.f32	s14, s14, s15
  float if1_real, if2_real;
  float if1_imag, if2_imag;
  
  float max_value;
  
  float PulseRepTime_sec = (float)(cp_dev_settings->pll_chirp_time_usec + PLL_RAMP_DOWM_TIME_USEC + PLL_STEADY_STATE_USEC) * 1e-6;  // Chirp repetition time in seconds
 802b652:	6812      	ldr	r2, [r2, #0]

void range_doppler_do(acq_buf_obj *p_acq_buf, const algo_settings_t *cp_algo_settings, const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
  algo_target_list_t *p_targets = p_algo_result->p_target_list;
  
  uint32_t Nc = p_acq_buf->params.num_of_chirps_per_frame;
 802b654:	88a7      	ldrh	r7, [r4, #4]
  float if1_real, if2_real;
  float if1_imag, if2_imag;
  
  float max_value;
  
  float PulseRepTime_sec = (float)(cp_dev_settings->pll_chirp_time_usec + PLL_RAMP_DOWM_TIME_USEC + PLL_STEADY_STATE_USEC) * 1e-6;  // Chirp repetition time in seconds
 802b656:	921b      	str	r2, [sp, #108]	; 0x6c
  
  alpha_mti = 1.0f / cp_algo_settings->mti_filter_len;
  
  beta_mti = (1.0f - alpha_mti);
  
  if (samples_per_channel != Ns)
 802b658:	4281      	cmp	r1, r0
  
  float max_value;
  
  float PulseRepTime_sec = (float)(cp_dev_settings->pll_chirp_time_usec + PLL_RAMP_DOWM_TIME_USEC + PLL_STEADY_STATE_USEC) * 1e-6;  // Chirp repetition time in seconds
  
  float range_detection_threshold = cp_algo_settings->range_detection_threshold;
 802b65a:	eeb8 8a66 	vcvt.f32.u32	s16, s13
  
  //--------------------------------------------------------------------------
  
  alpha_mti = 1.0f / cp_algo_settings->mti_filter_len;
  
  beta_mti = (1.0f - alpha_mti);
 802b65e:	ed83 7a00 	vstr	s14, [r3]
  
  if (samples_per_channel != Ns)
 802b662:	d034      	beq.n	802b6ce <range_doppler_do+0xd6>
 */

static void range_doppler_init(const algo_settings_t *cp_algo_settings)
{
  /* Clear FFT arrays */
  memset(range_fft_signal_rx1, 0, RANGE_FFT_SIGNAL_ARRAY_LEN * sizeof(float));
 802b664:	2100      	movs	r1, #0
 802b666:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 802b66a:	48b3      	ldr	r0, [pc, #716]	; (802b938 <range_doppler_do+0x340>)

  memset(doppler_fft_spectrum, 0, DOPPLER_FFT_SPECT_ARRAY_LEN * sizeof(float));

  memset(&target_measurements[0], 0, sizeof(target_measurements));

  memset(&s_tracking_list, 0, sizeof(s_tracking_list));
 802b66c:	4cb3      	ldr	r4, [pc, #716]	; (802b93c <range_doppler_do+0x344>)
 */

static void range_doppler_init(const algo_settings_t *cp_algo_settings)
{
  /* Clear FFT arrays */
  memset(range_fft_signal_rx1, 0, RANGE_FFT_SIGNAL_ARRAY_LEN * sizeof(float));
 802b66e:	f003 faa6 	bl	802ebbe <memset>
  memset(range_fft_signal_rx2, 0, RANGE_FFT_SIGNAL_ARRAY_LEN * sizeof(float));
 802b672:	2100      	movs	r1, #0
 802b674:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 802b678:	48b1      	ldr	r0, [pc, #708]	; (802b940 <range_doppler_do+0x348>)
 802b67a:	f003 faa0 	bl	802ebbe <memset>

  memset(doppler_fft_signal_rx1, 0, DOPPLER_FFT_SIGNAL_ARRAY_LEN * sizeof(float));
 802b67e:	2100      	movs	r1, #0
 802b680:	f44f 7200 	mov.w	r2, #512	; 0x200
 802b684:	48af      	ldr	r0, [pc, #700]	; (802b944 <range_doppler_do+0x34c>)
 802b686:	f003 fa9a 	bl	802ebbe <memset>
  memset(doppler_fft_signal_rx2, 0, DOPPLER_FFT_SIGNAL_ARRAY_LEN * sizeof(float));
 802b68a:	2100      	movs	r1, #0
 802b68c:	f44f 7200 	mov.w	r2, #512	; 0x200
 802b690:	48ad      	ldr	r0, [pc, #692]	; (802b948 <range_doppler_do+0x350>)
 802b692:	f003 fa94 	bl	802ebbe <memset>

  memset(range_fft_spectrum_hist, 0, RANGE_FFT_SIZE/2 * sizeof(float));
 802b696:	2100      	movs	r1, #0
 802b698:	f44f 7200 	mov.w	r2, #512	; 0x200
 802b69c:	48ab      	ldr	r0, [pc, #684]	; (802b94c <range_doppler_do+0x354>)
 802b69e:	f003 fa8e 	bl	802ebbe <memset>

  memset(doppler_fft_spectrum, 0, DOPPLER_FFT_SPECT_ARRAY_LEN * sizeof(float));
 802b6a2:	4632      	mov	r2, r6
 802b6a4:	2100      	movs	r1, #0
 802b6a6:	48aa      	ldr	r0, [pc, #680]	; (802b950 <range_doppler_do+0x358>)
 802b6a8:	f003 fa89 	bl	802ebbe <memset>

  memset(&target_measurements[0], 0, sizeof(target_measurements));
 802b6ac:	2100      	movs	r1, #0
 802b6ae:	22a0      	movs	r2, #160	; 0xa0
 802b6b0:	48a8      	ldr	r0, [pc, #672]	; (802b954 <range_doppler_do+0x35c>)
 802b6b2:	f003 fa84 	bl	802ebbe <memset>

  memset(&s_tracking_list, 0, sizeof(s_tracking_list));
 802b6b6:	2100      	movs	r1, #0
 802b6b8:	f44f 62b5 	mov.w	r2, #1448	; 0x5a8
 802b6bc:	4620      	mov	r0, r4
 802b6be:	f003 fa7e 	bl	802ebbe <memset>
  s_tracking_list.max_num_of_tracks = CURRENT_NUM_OF_TRACKS;
 802b6c2:	2305      	movs	r3, #5
 802b6c4:	6063      	str	r3, [r4, #4]

  fft_init();  // To init the internal FFT functions
 802b6c6:	f7fd fd45 	bl	8029154 <fft_init>
  
  if (samples_per_channel != Ns)
  {
    range_doppler_init(cp_algo_settings);
    
    samples_per_channel = Ns;
 802b6ca:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802b6cc:	602b      	str	r3, [r5, #0]
  }
  
  distance_per_bin = (float)(300.0f / (cp_dev_settings->pll_bandwidth_MHz * 2 * (RANGE_FFT_SIZE / Ns)));  // distance/bin (meters) = c /(2B * Nfft/Ns)
 802b6ce:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 802b6d0:	eddd 6a0a 	vldr	s13, [sp, #40]	; 0x28
 802b6d4:	edd3 7a04 	vldr	s15, [r3, #16]
 802b6d8:	ed9f 6a9f 	vldr	s12, [pc, #636]	; 802b958 <range_doppler_do+0x360>
  
  peak_search_max_idx = (uint32_t)(cp_algo_settings->max_distance_cm / (100.0f * distance_per_bin) + 2);
 802b6dc:	9b16      	ldr	r3, [sp, #88]	; 0x58
 802b6de:	eddf 5a9f 	vldr	s11, [pc, #636]	; 802b95c <range_doppler_do+0x364>
 802b6e2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802b6e4:	9307      	str	r3, [sp, #28]
    range_doppler_init(cp_algo_settings);
    
    samples_per_channel = Ns;
  }
  
  distance_per_bin = (float)(300.0f / (cp_dev_settings->pll_bandwidth_MHz * 2 * (RANGE_FFT_SIZE / Ns)));  // distance/bin (meters) = c /(2B * Nfft/Ns)
 802b6e6:	ee77 7aa7 	vadd.f32	s15, s15, s15
 802b6ea:	eef8 6ae6 	vcvt.f32.s32	s13, s13
  
  peak_search_max_idx = (uint32_t)(cp_algo_settings->max_distance_cm / (100.0f * distance_per_bin) + 2);
 802b6ee:	ee07 3a10 	vmov	s14, r3
    range_doppler_init(cp_algo_settings);
    
    samples_per_channel = Ns;
  }
  
  distance_per_bin = (float)(300.0f / (cp_dev_settings->pll_bandwidth_MHz * 2 * (RANGE_FFT_SIZE / Ns)));  // distance/bin (meters) = c /(2B * Nfft/Ns)
 802b6f2:	ee67 6aa6 	vmul.f32	s13, s15, s13
  
  peak_search_max_idx = (uint32_t)(cp_algo_settings->max_distance_cm / (100.0f * distance_per_bin) + 2);
 802b6f6:	eeb8 7a47 	vcvt.f32.u32	s14, s14
    range_doppler_init(cp_algo_settings);
    
    samples_per_channel = Ns;
  }
  
  distance_per_bin = (float)(300.0f / (cp_dev_settings->pll_bandwidth_MHz * 2 * (RANGE_FFT_SIZE / Ns)));  // distance/bin (meters) = c /(2B * Nfft/Ns)
 802b6fa:	eec6 6a26 	vdiv.f32	s13, s12, s13
  peak_search_max_idx = (uint32_t)(cp_algo_settings->max_distance_cm / (100.0f * distance_per_bin) + 2);
  
  peak_search_max_idx = (peak_search_max_idx > RANGE_FFT_SIZE/2-1) ? RANGE_FFT_SIZE/2-1 : peak_search_max_idx;
  
  // Nc is set via "p_acq_buf->params.num_of_chirps_per_frame" and comes from the buffer, so the following statement is obsolete, to some extent. If violated, it should raise an fatal error!
  Nc = (Nc > NUM_OF_CHIRPS) ? NUM_OF_CHIRPS : Nc; // to avoid out of memory flow in case more number of chirps selected
 802b6fe:	2f10      	cmp	r7, #16
 802b700:	bf28      	it	cs
 802b702:	2710      	movcs	r7, #16
 802b704:	463b      	mov	r3, r7
 802b706:	9710      	str	r7, [sp, #64]	; 0x40
    range_doppler_init(cp_algo_settings);
    
    samples_per_channel = Ns;
  }
  
  distance_per_bin = (float)(300.0f / (cp_dev_settings->pll_bandwidth_MHz * 2 * (RANGE_FFT_SIZE / Ns)));  // distance/bin (meters) = c /(2B * Nfft/Ns)
 802b708:	4a95      	ldr	r2, [pc, #596]	; (802b960 <range_doppler_do+0x368>)
  
  peak_search_max_idx = (uint32_t)(cp_algo_settings->max_distance_cm / (100.0f * distance_per_bin) + 2);
 802b70a:	eeb0 5a00 	vmov.f32	s10, #0
 802b70e:	ee66 7aa5 	vmul.f32	s15, s13, s11
    range_doppler_init(cp_algo_settings);
    
    samples_per_channel = Ns;
  }
  
  distance_per_bin = (float)(300.0f / (cp_dev_settings->pll_bandwidth_MHz * 2 * (RANGE_FFT_SIZE / Ns)));  // distance/bin (meters) = c /(2B * Nfft/Ns)
 802b712:	edc2 6a00 	vstr	s13, [r2]
  
  peak_search_max_idx = (uint32_t)(cp_algo_settings->max_distance_cm / (100.0f * distance_per_bin) + 2);
 802b716:	eec7 7a27 	vdiv.f32	s15, s14, s15
 802b71a:	ee77 7a85 	vadd.f32	s15, s15, s10
 802b71e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 802b722:	ee17 7a90 	vmov	r7, s15
  
  peak_search_max_idx = (peak_search_max_idx > RANGE_FFT_SIZE/2-1) ? RANGE_FFT_SIZE/2-1 : peak_search_max_idx;
 802b726:	2f7f      	cmp	r7, #127	; 0x7f
 802b728:	bf28      	it	cs
 802b72a:	277f      	movcs	r7, #127	; 0x7f
 802b72c:	971c      	str	r7, [sp, #112]	; 0x70
  // Nc is set via "p_acq_buf->params.num_of_chirps_per_frame" and comes from the buffer, so the following statement is obsolete, to some extent. If violated, it should raise an fatal error!
  Nc = (Nc > NUM_OF_CHIRPS) ? NUM_OF_CHIRPS : Nc; // to avoid out of memory flow in case more number of chirps selected
  
  //==================== (1) Fast FFT on Rx1 & Rx2 ===========================
  
  for (j = 0; j < Nc; j++)		// Loop over number of chirps
 802b72e:	2b00      	cmp	r3, #0
 802b730:	f000 8404 	beq.w	802bf3c <range_doppler_do+0x944>
 802b734:	4b80      	ldr	r3, [pc, #512]	; (802b938 <range_doppler_do+0x340>)
 802b736:	931d      	str	r3, [sp, #116]	; 0x74
 802b738:	9319      	str	r3, [sp, #100]	; 0x64
 802b73a:	930f      	str	r3, [sp, #60]	; 0x3c
 802b73c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802b73e:	4a80      	ldr	r2, [pc, #512]	; (802b940 <range_doppler_do+0x348>)
      fft_input_q2[i]  = (float)((p_temp[3])[i] - adc_q2_calibration[cal_idx]);
      cal_idx += interp_factor;
    }
    
    //---------------------------------------- Rx1 ---------------------------
    compute_fft_signal(fft_input_i1, fft_input_q1, Ns, RANGE_FFT_SIZE, if_scale,
 802b740:	eddf 8a88 	vldr	s17, [pc, #544]	; 802b964 <range_doppler_do+0x36c>
 802b744:	920c      	str	r2, [sp, #48]	; 0x30
 802b746:	009b      	lsls	r3, r3, #2
 802b748:	930b      	str	r3, [sp, #44]	; 0x2c
  // Nc is set via "p_acq_buf->params.num_of_chirps_per_frame" and comes from the buffer, so the following statement is obsolete, to some extent. If violated, it should raise an fatal error!
  Nc = (Nc > NUM_OF_CHIRPS) ? NUM_OF_CHIRPS : Nc; // to avoid out of memory flow in case more number of chirps selected
  
  //==================== (1) Fast FFT on Rx1 & Rx2 ===========================
  
  for (j = 0; j < Nc; j++)		// Loop over number of chirps
 802b74a:	2300      	movs	r3, #0
 802b74c:	930d      	str	r3, [sp, #52]	; 0x34
 802b74e:	ab20      	add	r3, sp, #128	; 0x80
 802b750:	9311      	str	r3, [sp, #68]	; 0x44
 802b752:	ab22      	add	r3, sp, #136	; 0x88
 802b754:	9313      	str	r3, [sp, #76]	; 0x4c
 802b756:	ab21      	add	r3, sp, #132	; 0x84
 802b758:	9312      	str	r3, [sp, #72]	; 0x48
 802b75a:	ab23      	add	r3, sp, #140	; 0x8c
 802b75c:	9314      	str	r3, [sp, #80]	; 0x50
  {
    uint16_t *p_temp[4];
    p_temp[0] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 0, j );
 802b75e:	9f15      	ldr	r7, [sp, #84]	; 0x54
 802b760:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 802b762:	2100      	movs	r1, #0
 802b764:	4632      	mov	r2, r6
 802b766:	4638      	mov	r0, r7
 802b768:	f7f4 fec4 	bl	80204f4 <get_buffer_address_by_chirp>
    p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 1, j );
 802b76c:	2101      	movs	r1, #1
 802b76e:	4632      	mov	r2, r6
  //==================== (1) Fast FFT on Rx1 & Rx2 ===========================
  
  for (j = 0; j < Nc; j++)		// Loop over number of chirps
  {
    uint16_t *p_temp[4];
    p_temp[0] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 0, j );
 802b770:	4680      	mov	r8, r0
    p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 1, j );
 802b772:	4638      	mov	r0, r7
 802b774:	f7f4 febe 	bl	80204f4 <get_buffer_address_by_chirp>
    p_temp[2] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 2, j );
 802b778:	2102      	movs	r1, #2
 802b77a:	4632      	mov	r2, r6
  
  for (j = 0; j < Nc; j++)		// Loop over number of chirps
  {
    uint16_t *p_temp[4];
    p_temp[0] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 0, j );
    p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 1, j );
 802b77c:	4605      	mov	r5, r0
    p_temp[2] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 2, j );
 802b77e:	4638      	mov	r0, r7
 802b780:	f7f4 feb8 	bl	80204f4 <get_buffer_address_by_chirp>
    p_temp[3] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, j );
 802b784:	2103      	movs	r1, #3
  for (j = 0; j < Nc; j++)		// Loop over number of chirps
  {
    uint16_t *p_temp[4];
    p_temp[0] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 0, j );
    p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 1, j );
    p_temp[2] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 2, j );
 802b786:	4604      	mov	r4, r0
    p_temp[3] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, j );
 802b788:	4632      	mov	r2, r6
 802b78a:	4638      	mov	r0, r7
 802b78c:	f7f4 feb2 	bl	80204f4 <get_buffer_address_by_chirp>
    cal_idx = 0;
    
    for (i = 0; i < Ns; i++)	// Loop over number of samples per chirp
 802b790:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802b792:	2b00      	cmp	r3, #0
 802b794:	d053      	beq.n	802b83e <range_doppler_do+0x246>
 802b796:	4b74      	ldr	r3, [pc, #464]	; (802b968 <range_doppler_do+0x370>)
 802b798:	4a74      	ldr	r2, [pc, #464]	; (802b96c <range_doppler_do+0x374>)
 802b79a:	681b      	ldr	r3, [r3, #0]
 802b79c:	9309      	str	r3, [sp, #36]	; 0x24
 802b79e:	4b74      	ldr	r3, [pc, #464]	; (802b970 <range_doppler_do+0x378>)
 802b7a0:	6812      	ldr	r2, [r2, #0]
 802b7a2:	681b      	ldr	r3, [r3, #0]
 802b7a4:	9308      	str	r3, [sp, #32]
 802b7a6:	f8df 91d4 	ldr.w	r9, [pc, #468]	; 802b97c <range_doppler_do+0x384>
 802b7aa:	f8df b1d4 	ldr.w	fp, [pc, #468]	; 802b980 <range_doppler_do+0x388>
 802b7ae:	f8df a1d4 	ldr.w	sl, [pc, #468]	; 802b984 <range_doppler_do+0x38c>
 802b7b2:	9207      	str	r2, [sp, #28]
 802b7b4:	2300      	movs	r3, #0
 802b7b6:	f1a8 0802 	sub.w	r8, r8, #2
 802b7ba:	f1a5 0c02 	sub.w	ip, r5, #2
 802b7be:	f1a4 0e02 	sub.w	lr, r4, #2
 802b7c2:	1e87      	subs	r7, r0, #2
 802b7c4:	461a      	mov	r2, r3
    {
      fft_input_i1[i]  = (float)((p_temp[0])[i] - adc_i1_calibration[cal_idx]);
 802b7c6:	496b      	ldr	r1, [pc, #428]	; (802b974 <range_doppler_do+0x37c>)
 802b7c8:	f838 4f02 	ldrh.w	r4, [r8, #2]!
 802b7cc:	f831 6012 	ldrh.w	r6, [r1, r2, lsl #1]
      fft_input_q1[i]  = (float)((p_temp[1])[i] - adc_q1_calibration[cal_idx]);
 802b7d0:	9907      	ldr	r1, [sp, #28]
 802b7d2:	f83c 0f02 	ldrh.w	r0, [ip, #2]!
 802b7d6:	f831 5012 	ldrh.w	r5, [r1, r2, lsl #1]
      
      fft_input_i2[i]  = (float)((p_temp[2])[i] - adc_i2_calibration[cal_idx]);
 802b7da:	f83e 1f02 	ldrh.w	r1, [lr, #2]!
    p_temp[3] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, j );
    cal_idx = 0;
    
    for (i = 0; i < Ns; i++)	// Loop over number of samples per chirp
    {
      fft_input_i1[i]  = (float)((p_temp[0])[i] - adc_i1_calibration[cal_idx]);
 802b7de:	1ba4      	subs	r4, r4, r6
 802b7e0:	ee07 4a90 	vmov	s15, r4
      fft_input_q1[i]  = (float)((p_temp[1])[i] - adc_q1_calibration[cal_idx]);
 802b7e4:	1b40      	subs	r0, r0, r5
      
      fft_input_i2[i]  = (float)((p_temp[2])[i] - adc_i2_calibration[cal_idx]);
 802b7e6:	9d08      	ldr	r5, [sp, #32]
      fft_input_q2[i]  = (float)((p_temp[3])[i] - adc_q2_calibration[cal_idx]);
 802b7e8:	9c09      	ldr	r4, [sp, #36]	; 0x24
    for (i = 0; i < Ns; i++)	// Loop over number of samples per chirp
    {
      fft_input_i1[i]  = (float)((p_temp[0])[i] - adc_i1_calibration[cal_idx]);
      fft_input_q1[i]  = (float)((p_temp[1])[i] - adc_q1_calibration[cal_idx]);
      
      fft_input_i2[i]  = (float)((p_temp[2])[i] - adc_i2_calibration[cal_idx]);
 802b7ea:	f835 6012 	ldrh.w	r6, [r5, r2, lsl #1]
      fft_input_q2[i]  = (float)((p_temp[3])[i] - adc_q2_calibration[cal_idx]);
 802b7ee:	f834 4012 	ldrh.w	r4, [r4, r2, lsl #1]
 802b7f2:	f837 5f02 	ldrh.w	r5, [r7, #2]!
    p_temp[3] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, j );
    cal_idx = 0;
    
    for (i = 0; i < Ns; i++)	// Loop over number of samples per chirp
    {
      fft_input_i1[i]  = (float)((p_temp[0])[i] - adc_i1_calibration[cal_idx]);
 802b7f6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
      fft_input_q1[i]  = (float)((p_temp[1])[i] - adc_q1_calibration[cal_idx]);
      
      fft_input_i2[i]  = (float)((p_temp[2])[i] - adc_i2_calibration[cal_idx]);
 802b7fa:	1b89      	subs	r1, r1, r6
    p_temp[3] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, j );
    cal_idx = 0;
    
    for (i = 0; i < Ns; i++)	// Loop over number of samples per chirp
    {
      fft_input_i1[i]  = (float)((p_temp[0])[i] - adc_i1_calibration[cal_idx]);
 802b7fc:	ece9 7a01 	vstmia	r9!, {s15}
      fft_input_q1[i]  = (float)((p_temp[1])[i] - adc_q1_calibration[cal_idx]);
 802b800:	ee07 0a90 	vmov	s15, r0
 802b804:	eef8 6ae7 	vcvt.f32.s32	s13, s15
      
      fft_input_i2[i]  = (float)((p_temp[2])[i] - adc_i2_calibration[cal_idx]);
 802b808:	ee07 1a90 	vmov	s15, r1
      fft_input_q2[i]  = (float)((p_temp[3])[i] - adc_q2_calibration[cal_idx]);
 802b80c:	1b2c      	subs	r4, r5, r4
    for (i = 0; i < Ns; i++)	// Loop over number of samples per chirp
    {
      fft_input_i1[i]  = (float)((p_temp[0])[i] - adc_i1_calibration[cal_idx]);
      fft_input_q1[i]  = (float)((p_temp[1])[i] - adc_q1_calibration[cal_idx]);
      
      fft_input_i2[i]  = (float)((p_temp[2])[i] - adc_i2_calibration[cal_idx]);
 802b80e:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
      fft_input_q2[i]  = (float)((p_temp[3])[i] - adc_q2_calibration[cal_idx]);
 802b812:	ee07 4a90 	vmov	s15, r4
 802b816:	4958      	ldr	r1, [pc, #352]	; (802b978 <range_doppler_do+0x380>)
 802b818:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802b81c:	18cc      	adds	r4, r1, r3
 802b81e:	eb0a 0103 	add.w	r1, sl, r3
 802b822:	eb0b 0003 	add.w	r0, fp, r3
 802b826:	edc1 7a00 	vstr	s15, [r1]
    p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 1, j );
    p_temp[2] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 2, j );
    p_temp[3] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, j );
    cal_idx = 0;
    
    for (i = 0; i < Ns; i++)	// Loop over number of samples per chirp
 802b82a:	990b      	ldr	r1, [sp, #44]	; 0x2c
    {
      fft_input_i1[i]  = (float)((p_temp[0])[i] - adc_i1_calibration[cal_idx]);
      fft_input_q1[i]  = (float)((p_temp[1])[i] - adc_q1_calibration[cal_idx]);
      
      fft_input_i2[i]  = (float)((p_temp[2])[i] - adc_i2_calibration[cal_idx]);
 802b82c:	ed80 7a00 	vstr	s14, [r0]
 802b830:	3304      	adds	r3, #4
      fft_input_q2[i]  = (float)((p_temp[3])[i] - adc_q2_calibration[cal_idx]);
      cal_idx += interp_factor;
 802b832:	980a      	ldr	r0, [sp, #40]	; 0x28
    cal_idx = 0;
    
    for (i = 0; i < Ns; i++)	// Loop over number of samples per chirp
    {
      fft_input_i1[i]  = (float)((p_temp[0])[i] - adc_i1_calibration[cal_idx]);
      fft_input_q1[i]  = (float)((p_temp[1])[i] - adc_q1_calibration[cal_idx]);
 802b834:	edc4 6a00 	vstr	s13, [r4]
    p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 1, j );
    p_temp[2] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 2, j );
    p_temp[3] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, j );
    cal_idx = 0;
    
    for (i = 0; i < Ns; i++)	// Loop over number of samples per chirp
 802b838:	428b      	cmp	r3, r1
      fft_input_i1[i]  = (float)((p_temp[0])[i] - adc_i1_calibration[cal_idx]);
      fft_input_q1[i]  = (float)((p_temp[1])[i] - adc_q1_calibration[cal_idx]);
      
      fft_input_i2[i]  = (float)((p_temp[2])[i] - adc_i2_calibration[cal_idx]);
      fft_input_q2[i]  = (float)((p_temp[3])[i] - adc_q2_calibration[cal_idx]);
      cal_idx += interp_factor;
 802b83a:	4402      	add	r2, r0
    p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 1, j );
    p_temp[2] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 2, j );
    p_temp[3] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, j );
    cal_idx = 0;
    
    for (i = 0; i < Ns; i++)	// Loop over number of samples per chirp
 802b83c:	d1c3      	bne.n	802b7c6 <range_doppler_do+0x1ce>
      fft_input_q2[i]  = (float)((p_temp[3])[i] - adc_q2_calibration[cal_idx]);
      cal_idx += interp_factor;
    }
    
    //---------------------------------------- Rx1 ---------------------------
    compute_fft_signal(fft_input_i1, fft_input_q1, Ns, RANGE_FFT_SIZE, if_scale,
 802b83e:	9b11      	ldr	r3, [sp, #68]	; 0x44
 802b840:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
  // Nc is set via "p_acq_buf->params.num_of_chirps_per_frame" and comes from the buffer, so the following statement is obsolete, to some extent. If violated, it should raise an fatal error!
  Nc = (Nc > NUM_OF_CHIRPS) ? NUM_OF_CHIRPS : Nc; // to avoid out of memory flow in case more number of chirps selected
  
  //==================== (1) Fast FFT on Rx1 & Rx2 ===========================
  
  for (j = 0; j < Nc; j++)		// Loop over number of chirps
 802b844:	9e0d      	ldr	r6, [sp, #52]	; 0x34
      fft_input_q2[i]  = (float)((p_temp[3])[i] - adc_q2_calibration[cal_idx]);
      cal_idx += interp_factor;
    }
    
    //---------------------------------------- Rx1 ---------------------------
    compute_fft_signal(fft_input_i1, fft_input_q1, Ns, RANGE_FFT_SIZE, if_scale,
 802b846:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
 802b848:	9303      	str	r3, [sp, #12]
 802b84a:	2502      	movs	r5, #2
 802b84c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 802b84e:	9304      	str	r3, [sp, #16]
 802b850:	2400      	movs	r4, #0
 802b852:	9705      	str	r7, [sp, #20]
 802b854:	9501      	str	r5, [sp, #4]
 802b856:	4849      	ldr	r0, [pc, #292]	; (802b97c <range_doppler_do+0x384>)
 802b858:	4947      	ldr	r1, [pc, #284]	; (802b978 <range_doppler_do+0x380>)
 802b85a:	edcd 8a00 	vstr	s17, [sp]
 802b85e:	4642      	mov	r2, r8
 802b860:	f44f 7380 	mov.w	r3, #256	; 0x100
  // Nc is set via "p_acq_buf->params.num_of_chirps_per_frame" and comes from the buffer, so the following statement is obsolete, to some extent. If violated, it should raise an fatal error!
  Nc = (Nc > NUM_OF_CHIRPS) ? NUM_OF_CHIRPS : Nc; // to avoid out of memory flow in case more number of chirps selected
  
  //==================== (1) Fast FFT on Rx1 & Rx2 ===========================
  
  for (j = 0; j < Nc; j++)		// Loop over number of chirps
 802b864:	3601      	adds	r6, #1
      fft_input_q2[i]  = (float)((p_temp[3])[i] - adc_q2_calibration[cal_idx]);
      cal_idx += interp_factor;
    }
    
    //---------------------------------------- Rx1 ---------------------------
    compute_fft_signal(fft_input_i1, fft_input_q1, Ns, RANGE_FFT_SIZE, if_scale,
 802b866:	9402      	str	r4, [sp, #8]
  // Nc is set via "p_acq_buf->params.num_of_chirps_per_frame" and comes from the buffer, so the following statement is obsolete, to some extent. If violated, it should raise an fatal error!
  Nc = (Nc > NUM_OF_CHIRPS) ? NUM_OF_CHIRPS : Nc; // to avoid out of memory flow in case more number of chirps selected
  
  //==================== (1) Fast FFT on Rx1 & Rx2 ===========================
  
  for (j = 0; j < Nc; j++)		// Loop over number of chirps
 802b868:	960d      	str	r6, [sp, #52]	; 0x34
      fft_input_q2[i]  = (float)((p_temp[3])[i] - adc_q2_calibration[cal_idx]);
      cal_idx += interp_factor;
    }
    
    //---------------------------------------- Rx1 ---------------------------
    compute_fft_signal(fft_input_i1, fft_input_q1, Ns, RANGE_FFT_SIZE, if_scale,
 802b86a:	f7fd fc83 	bl	8029174 <compute_fft_signal>
                       fft_type, FFT_FAST_TIME, &if1_real, &if1_imag, &range_fft_signal_rx1[(j * RANGE_FFT_SIZE * 2)]);
    
    //---------------------------------------- Rx2 ---------------------------
    compute_fft_signal(fft_input_i2, fft_input_q2, Ns, RANGE_FFT_SIZE, if_scale,
 802b86e:	9b12      	ldr	r3, [sp, #72]	; 0x48
 802b870:	9501      	str	r5, [sp, #4]
 802b872:	9303      	str	r3, [sp, #12]
 802b874:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 802b876:	9b14      	ldr	r3, [sp, #80]	; 0x50
 802b878:	9304      	str	r3, [sp, #16]
 802b87a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802b87c:	9305      	str	r3, [sp, #20]
 802b87e:	9402      	str	r4, [sp, #8]
 802b880:	f44f 7380 	mov.w	r3, #256	; 0x100
 802b884:	edcd 8a00 	vstr	s17, [sp]
 802b888:	483d      	ldr	r0, [pc, #244]	; (802b980 <range_doppler_do+0x388>)
 802b88a:	493e      	ldr	r1, [pc, #248]	; (802b984 <range_doppler_do+0x38c>)
 802b88c:	4642      	mov	r2, r8
 802b88e:	f507 6700 	add.w	r7, r7, #2048	; 0x800
 802b892:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 802b896:	970f      	str	r7, [sp, #60]	; 0x3c
 802b898:	950c      	str	r5, [sp, #48]	; 0x30
 802b89a:	f7fd fc6b 	bl	8029174 <compute_fft_signal>
  // Nc is set via "p_acq_buf->params.num_of_chirps_per_frame" and comes from the buffer, so the following statement is obsolete, to some extent. If violated, it should raise an fatal error!
  Nc = (Nc > NUM_OF_CHIRPS) ? NUM_OF_CHIRPS : Nc; // to avoid out of memory flow in case more number of chirps selected
  
  //==================== (1) Fast FFT on Rx1 & Rx2 ===========================
  
  for (j = 0; j < Nc; j++)		// Loop over number of chirps
 802b89e:	9b10      	ldr	r3, [sp, #64]	; 0x40
 802b8a0:	429e      	cmp	r6, r3
 802b8a2:	f47f af5c 	bne.w	802b75e <range_doppler_do+0x166>
 802b8a6:	eddf 8a38 	vldr	s17, [pc, #224]	; 802b988 <range_doppler_do+0x390>
 802b8aa:	9f1d      	ldr	r7, [sp, #116]	; 0x74
 802b8ac:	4626      	mov	r6, r4
 802b8ae:	ad24      	add	r5, sp, #144	; 0x90
 802b8b0:	4698      	mov	r8, r3
  for (j = 0; j < Nc; j++)  // Loop over number of chirps
  {
    uint32_t idx = (2 * RANGE_FFT_SIZE) * j;
    
#if (RX_ANTENNA_SELECTION == 1U)
    compute_fft_spectrum(&range_fft_signal_rx1[idx], RANGE_FFT_SIZE/2, range_fft_spectrum);
 802b8b2:	4638      	mov	r0, r7
 802b8b4:	2180      	movs	r1, #128	; 0x80
 802b8b6:	4a35      	ldr	r2, [pc, #212]	; (802b98c <range_doppler_do+0x394>)
 802b8b8:	f7fd fd64 	bl	8029384 <compute_fft_spectrum>
#else
    compute_fft_spectrum(&range_fft_signal_rx2[idx], RANGE_FFT_SIZE/2, range_fft_spectrum);
#endif
    
    arm_max_f32(range_fft_spectrum, (uint32_t)RANGE_FFT_SIZE/2, &max_value, &max_idx);
 802b8bc:	4833      	ldr	r0, [pc, #204]	; (802b98c <range_doppler_do+0x394>)
 802b8be:	2180      	movs	r1, #128	; 0x80
 802b8c0:	462a      	mov	r2, r5
 802b8c2:	ab1f      	add	r3, sp, #124	; 0x7c
 802b8c4:	f7fc fea8 	bl	8028618 <arm_max_f32>
    
    if(last_max_value < max_value)
 802b8c8:	eddd 7a24 	vldr	s15, [sp, #144]	; 0x90
 802b8cc:	eef4 7ae8 	vcmpe.f32	s15, s17
 802b8d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b8d4:	bfc8      	it	gt
 802b8d6:	4634      	movgt	r4, r6
  
  float last_max_value = 0;
  
  max_idx_arr = 0;
  
  for (j = 0; j < Nc; j++)  // Loop over number of chirps
 802b8d8:	f106 0601 	add.w	r6, r6, #1
    
    arm_max_f32(range_fft_spectrum, (uint32_t)RANGE_FFT_SIZE/2, &max_value, &max_idx);
    
    if(last_max_value < max_value)
    {
      last_max_value = max_value;
 802b8dc:	bfc8      	it	gt
 802b8de:	eef0 8a67 	vmovgt.f32	s17, s15
  
  float last_max_value = 0;
  
  max_idx_arr = 0;
  
  for (j = 0; j < Nc; j++)  // Loop over number of chirps
 802b8e2:	4546      	cmp	r6, r8
 802b8e4:	f507 6700 	add.w	r7, r7, #2048	; 0x800
 802b8e8:	d1e3      	bne.n	802b8b2 <range_doppler_do+0x2ba>
 802b8ea:	9b19      	ldr	r3, [sp, #100]	; 0x64
 802b8ec:	0264      	lsls	r4, r4, #9
  }
  
  max_idx = (2 * RANGE_FFT_SIZE) * max_idx_arr;
  
#if (RX_ANTENNA_SELECTION == 1U)
  compute_fft_spectrum(&range_fft_signal_rx1[max_idx], RANGE_FFT_SIZE/2, range_fft_spectrum);
 802b8ee:	eb03 0084 	add.w	r0, r3, r4, lsl #2
 802b8f2:	2180      	movs	r1, #128	; 0x80
 802b8f4:	4a25      	ldr	r2, [pc, #148]	; (802b98c <range_doppler_do+0x394>)
      
      max_idx_arr = j;
    }
  }
  
  max_idx = (2 * RANGE_FFT_SIZE) * max_idx_arr;
 802b8f6:	941f      	str	r4, [sp, #124]	; 0x7c
  
#if (RX_ANTENNA_SELECTION == 1U)
  compute_fft_spectrum(&range_fft_signal_rx1[max_idx], RANGE_FFT_SIZE/2, range_fft_spectrum);
 802b8f8:	f7fd fd44 	bl	8029384 <compute_fft_spectrum>
  compute_fft_spectrum(&range_fft_signal_rx2[max_idx], RANGE_FFT_SIZE/2, range_fft_spectrum);
#endif
  
  //==================== (3) MTI Filter update =======================
  
  if (cp_algo_settings->mti_filter_enable == 1U)
 802b8fc:	9b16      	ldr	r3, [sp, #88]	; 0x58
 802b8fe:	6a1b      	ldr	r3, [r3, #32]
 802b900:	2b01      	cmp	r3, #1
 802b902:	f040 8296 	bne.w	802be32 <range_doppler_do+0x83a>
  {
    memcpy(range_fft_spectrum_temp, range_fft_spectrum, (RANGE_FFT_SIZE/2) * sizeof(float));
 802b906:	4921      	ldr	r1, [pc, #132]	; (802b98c <range_doppler_do+0x394>)
 802b908:	4821      	ldr	r0, [pc, #132]	; (802b990 <range_doppler_do+0x398>)
 802b90a:	f44f 7200 	mov.w	r2, #512	; 0x200
 802b90e:	f003 f94b 	bl	802eba8 <memcpy>
 802b912:	4a07      	ldr	r2, [pc, #28]	; (802b930 <range_doppler_do+0x338>)
 802b914:	4b1d      	ldr	r3, [pc, #116]	; (802b98c <range_doppler_do+0x394>)
 802b916:	ed92 5a00 	vldr	s10, [r2]
 802b91a:	4a06      	ldr	r2, [pc, #24]	; (802b934 <range_doppler_do+0x33c>)
 802b91c:	491c      	ldr	r1, [pc, #112]	; (802b990 <range_doppler_do+0x398>)
 802b91e:	edd2 5a00 	vldr	s11, [r2]
 802b922:	4a0a      	ldr	r2, [pc, #40]	; (802b94c <range_doppler_do+0x354>)
 802b924:	f503 7000 	add.w	r0, r3, #512	; 0x200
 802b928:	e034      	b.n	802b994 <range_doppler_do+0x39c>
 802b92a:	bf00      	nop
 802b92c:	200042ec 	.word	0x200042ec
 802b930:	200046f0 	.word	0x200046f0
 802b934:	200039e8 	.word	0x200039e8
 802b938:	1fff2b44 	.word	0x1fff2b44
 802b93c:	1ffe9098 	.word	0x1ffe9098
 802b940:	1fffab44 	.word	0x1fffab44
 802b944:	20003344 	.word	0x20003344
 802b948:	20003544 	.word	0x20003544
 802b94c:	20003aec 	.word	0x20003aec
 802b950:	200039ec 	.word	0x200039ec
 802b954:	20003948 	.word	0x20003948
 802b958:	43960000 	.word	0x43960000
 802b95c:	42c80000 	.word	0x42c80000
 802b960:	20003944 	.word	0x20003944
 802b964:	3c534067 	.word	0x3c534067
 802b968:	1ffe88a4 	.word	0x1ffe88a4
 802b96c:	1ffe889c 	.word	0x1ffe889c
 802b970:	1ffe88a0 	.word	0x1ffe88a0
 802b974:	2000cb28 	.word	0x2000cb28
 802b978:	20002b44 	.word	0x20002b44
 802b97c:	20003eec 	.word	0x20003eec
 802b980:	200042f0 	.word	0x200042f0
 802b984:	20002f44 	.word	0x20002f44
 802b988:	00000000 	.word	0x00000000
 802b98c:	20003744 	.word	0x20003744
 802b990:	20003cec 	.word	0x20003cec
    
    for (i = 0; i < (RANGE_FFT_SIZE/2); i++)
    {
      range_fft_spectrum[i] = fabsf(range_fft_spectrum[i] - range_fft_spectrum_hist[i]);
 802b994:	edd2 7a00 	vldr	s15, [r2]
 802b998:	ed93 7a00 	vldr	s14, [r3]
      
      range_fft_spectrum_hist[i] = alpha_mti * range_fft_spectrum_temp[i] + beta_mti * range_fft_spectrum_hist[i];
 802b99c:	ecb1 6a01 	vldmia	r1!, {s12}
 802b9a0:	ee67 6aa5 	vmul.f32	s13, s15, s11
  {
    memcpy(range_fft_spectrum_temp, range_fft_spectrum, (RANGE_FFT_SIZE/2) * sizeof(float));
    
    for (i = 0; i < (RANGE_FFT_SIZE/2); i++)
    {
      range_fft_spectrum[i] = fabsf(range_fft_spectrum[i] - range_fft_spectrum_hist[i]);
 802b9a4:	ee77 7a67 	vsub.f32	s15, s14, s15
      
      range_fft_spectrum_hist[i] = alpha_mti * range_fft_spectrum_temp[i] + beta_mti * range_fft_spectrum_hist[i];
 802b9a8:	eeb0 7a66 	vmov.f32	s14, s13
 802b9ac:	eea6 7a05 	vfma.f32	s14, s12, s10
  {
    memcpy(range_fft_spectrum_temp, range_fft_spectrum, (RANGE_FFT_SIZE/2) * sizeof(float));
    
    for (i = 0; i < (RANGE_FFT_SIZE/2); i++)
    {
      range_fft_spectrum[i] = fabsf(range_fft_spectrum[i] - range_fft_spectrum_hist[i]);
 802b9b0:	eef0 7ae7 	vabs.f32	s15, s15
 802b9b4:	ece3 7a01 	vstmia	r3!, {s15}
  
  if (cp_algo_settings->mti_filter_enable == 1U)
  {
    memcpy(range_fft_spectrum_temp, range_fft_spectrum, (RANGE_FFT_SIZE/2) * sizeof(float));
    
    for (i = 0; i < (RANGE_FFT_SIZE/2); i++)
 802b9b8:	4283      	cmp	r3, r0
    {
      range_fft_spectrum[i] = fabsf(range_fft_spectrum[i] - range_fft_spectrum_hist[i]);
      
      range_fft_spectrum_hist[i] = alpha_mti * range_fft_spectrum_temp[i] + beta_mti * range_fft_spectrum_hist[i];
 802b9ba:	eca2 7a01 	vstmia	r2!, {s14}
  
  if (cp_algo_settings->mti_filter_enable == 1U)
  {
    memcpy(range_fft_spectrum_temp, range_fft_spectrum, (RANGE_FFT_SIZE/2) * sizeof(float));
    
    for (i = 0; i < (RANGE_FFT_SIZE/2); i++)
 802b9be:	d1e9      	bne.n	802b994 <range_doppler_do+0x39c>
    memset(range_fft_spectrum_hist, 0, RANGE_FFT_SIZE/2 * sizeof(float));
  }

  //=========== (4) Target detection on Rx1 ==================================
  
  memset(&p_targets->elems[0], 0, sizeof(p_targets->elems)); // clear target data
 802b9c0:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 802b9c2:	4dcf      	ldr	r5, [pc, #828]	; (802bd00 <range_doppler_do+0x708>)
    
    if((fp >= threshold) && (fp >= fl2) && (fp >= fl) && (fp > fr) && (fp > fr2))
    {
      peak_idx = (fl2_bin * fl2 + fl_bin * fl + fp_bin * fp + fr_bin * fr + fr2_bin * fr2) / (fl2 + fl + fp + fr + fr2);
      
      target_range = (uint32_t)(peak_idx * 100.0f * distance_per_bin);
 802b9c4:	ed9f 9acf 	vldr	s18, [pc, #828]	; 802bd04 <range_doppler_do+0x70c>
    memset(range_fft_spectrum_hist, 0, RANGE_FFT_SIZE/2 * sizeof(float));
  }

  //=========== (4) Target detection on Rx1 ==================================
  
  memset(&p_targets->elems[0], 0, sizeof(p_targets->elems)); // clear target data
 802b9c8:	f103 0a0c 	add.w	sl, r3, #12
 802b9cc:	2100      	movs	r1, #0
 802b9ce:	2264      	movs	r2, #100	; 0x64
 802b9d0:	4650      	mov	r0, sl
 802b9d2:	f003 f8f4 	bl	802ebbe <memset>
 802b9d6:	9b1c      	ldr	r3, [sp, #112]	; 0x70
  
  memset(&target_measurements[0], 0, sizeof(target_measurements));
 802b9d8:	48cb      	ldr	r0, [pc, #812]	; (802bd08 <range_doppler_do+0x710>)
 802b9da:	2100      	movs	r1, #0
 802b9dc:	22a0      	movs	r2, #160	; 0xa0
 802b9de:	1e9f      	subs	r7, r3, #2
 802b9e0:	f003 f8ed 	bl	802ebbe <memset>
    
    if((fp >= threshold) && (fp >= fl2) && (fp >= fl) && (fp > fr) && (fp > fr2))
    {
      peak_idx = (fl2_bin * fl2 + fl_bin * fl + fp_bin * fp + fr_bin * fr + fr2_bin * fr2) / (fl2 + fl + fp + fr + fr2);
      
      target_range = (uint32_t)(peak_idx * 100.0f * distance_per_bin);
 802b9e4:	4bc9      	ldr	r3, [pc, #804]	; (802bd0c <range_doppler_do+0x714>)
 802b9e6:	f8dd 9058 	ldr.w	r9, [sp, #88]	; 0x58
 802b9ea:	edd3 8a00 	vldr	s17, [r3]
//==========================================================================

static uint8_t target_detection(const algo_settings_t *p_algo_settings, float* fft_spectrum, target_data_t* target_info, uint32_t search_length, float threshold)
{
  uint32_t target_range;
  uint32_t n = 2;
 802b9ee:	2302      	movs	r3, #2
  uint32_t  fl2_bin, fl_bin, fp_bin, fr_bin, fr2_bin;
  float fl2,fl, fp, fr,fr2;
  float peak_idx = 0;
  uint8_t num_of_targets = 0;
  
  while (n <= (search_length - 2))
 802b9f0:	42bb      	cmp	r3, r7
 802b9f2:	f1a5 0408 	sub.w	r4, r5, #8
  uint32_t target_range;
  uint32_t n = 2;
  uint32_t  fl2_bin, fl_bin, fp_bin, fr_bin, fr2_bin;
  float fl2,fl, fp, fr,fr2;
  float peak_idx = 0;
  uint8_t num_of_targets = 0;
 802b9f6:	f04f 0800 	mov.w	r8, #0
  
  while (n <= (search_length - 2))
 802b9fa:	f200 809e 	bhi.w	802bb3a <range_doppler_do+0x542>
    fl_bin  = fp_bin - 1;
    fl2_bin = fp_bin - 2;
    fr_bin  = fp_bin + 1;
    fr2_bin = fp_bin + 2;
    
    fp  = fft_spectrum[fp_bin];
 802b9fe:	ed95 5a00 	vldr	s10, [r5]
    fl  = fft_spectrum[fl_bin];
 802ba02:	edd4 4a01 	vldr	s9, [r4, #4]
    fl2 = fft_spectrum[fl2_bin];
 802ba06:	ecb4 7a01 	vldmia	r4!, {s14}
    fr  = fft_spectrum[fr_bin];
 802ba0a:	ed95 4a01 	vldr	s8, [r5, #4]
    fr2 = fft_spectrum[fr2_bin];
 802ba0e:	edd4 6a03 	vldr	s13, [r4, #12]
    
    if((fp >= threshold) && (fp >= fl2) && (fp >= fl) && (fp > fr) && (fp > fr2))
 802ba12:	eeb4 8ac5 	vcmpe.f32	s16, s10
    fr2_bin = fp_bin + 2;
    
    fp  = fft_spectrum[fp_bin];
    fl  = fft_spectrum[fl_bin];
    fl2 = fft_spectrum[fl2_bin];
    fr  = fft_spectrum[fr_bin];
 802ba16:	3504      	adds	r5, #4
    fr2 = fft_spectrum[fr2_bin];
    
    if((fp >= threshold) && (fp >= fl2) && (fp >= fl) && (fp > fr) && (fp > fr2))
 802ba18:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  uint8_t num_of_targets = 0;
  
  while (n <= (search_length - 2))
  {
    fp_bin  = n;
    fl_bin  = fp_bin - 1;
 802ba1c:	f103 30ff 	add.w	r0, r3, #4294967295
    fl2_bin = fp_bin - 2;
 802ba20:	f1a3 0102 	sub.w	r1, r3, #2
    fr_bin  = fp_bin + 1;
 802ba24:	f103 0601 	add.w	r6, r3, #1
    fr2_bin = fp_bin + 2;
 802ba28:	f103 0202 	add.w	r2, r3, #2
    fl  = fft_spectrum[fl_bin];
    fl2 = fft_spectrum[fl2_bin];
    fr  = fft_spectrum[fr_bin];
    fr2 = fft_spectrum[fr2_bin];
    
    if((fp >= threshold) && (fp >= fl2) && (fp >= fl) && (fp > fr) && (fp > fr2))
 802ba2c:	f200 8081 	bhi.w	802bb32 <range_doppler_do+0x53a>
 802ba30:	eeb4 5ac7 	vcmpe.f32	s10, s14
 802ba34:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802ba38:	db7b      	blt.n	802bb32 <range_doppler_do+0x53a>
 802ba3a:	eeb4 5ae4 	vcmpe.f32	s10, s9
 802ba3e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802ba42:	db76      	blt.n	802bb32 <range_doppler_do+0x53a>
 802ba44:	eeb4 5ac4 	vcmpe.f32	s10, s8
 802ba48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802ba4c:	dd71      	ble.n	802bb32 <range_doppler_do+0x53a>
 802ba4e:	eeb4 5ae6 	vcmpe.f32	s10, s13
 802ba52:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802ba56:	dd6c      	ble.n	802bb32 <range_doppler_do+0x53a>
    {
      peak_idx = (fl2_bin * fl2 + fl_bin * fl + fp_bin * fp + fr_bin * fr + fr2_bin * fr2) / (fl2 + fl + fp + fr + fr2);
 802ba58:	ee07 0a90 	vmov	s15, r0
 802ba5c:	eef8 5a67 	vcvt.f32.u32	s11, s15
 802ba60:	ee07 1a90 	vmov	s15, r1
 802ba64:	ee64 5aa5 	vmul.f32	s11, s9, s11
 802ba68:	eeb8 6a67 	vcvt.f32.u32	s12, s15
 802ba6c:	ee07 3a90 	vmov	s15, r3
 802ba70:	eee7 5a06 	vfma.f32	s11, s14, s12
      
      target_range = (uint32_t)(peak_idx * 100.0f * distance_per_bin);
      
      if ((target_range - p_algo_settings->range_offset_cm) > 0)
 802ba74:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
    fr  = fft_spectrum[fr_bin];
    fr2 = fft_spectrum[fr2_bin];
    
    if((fp >= threshold) && (fp >= fl2) && (fp >= fl) && (fp > fr) && (fp > fr2))
    {
      peak_idx = (fl2_bin * fl2 + fl_bin * fl + fp_bin * fp + fr_bin * fr + fr2_bin * fr2) / (fl2 + fl + fp + fr + fr2);
 802ba78:	eef8 7a67 	vcvt.f32.u32	s15, s15
 802ba7c:	ee34 6a87 	vadd.f32	s12, s9, s14
 802ba80:	eee5 5a27 	vfma.f32	s11, s10, s15
 802ba84:	ee07 6a10 	vmov	s14, r6
 802ba88:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 802ba8c:	ee35 6a06 	vadd.f32	s12, s10, s12
 802ba90:	eee4 5a07 	vfma.f32	s11, s8, s14
 802ba94:	ee34 6a06 	vadd.f32	s12, s8, s12
 802ba98:	eeb0 7a65 	vmov.f32	s14, s11
 802ba9c:	ee05 2a90 	vmov	s11, r2
 802baa0:	eef8 5a65 	vcvt.f32.u32	s11, s11
 802baa4:	eea6 7aa5 	vfma.f32	s14, s13, s11
 802baa8:	ee76 6a86 	vadd.f32	s13, s13, s12
 802baac:	ee87 7a26 	vdiv.f32	s14, s14, s13
      
      target_range = (uint32_t)(peak_idx * 100.0f * distance_per_bin);
 802bab0:	ee67 6a09 	vmul.f32	s13, s14, s18
 802bab4:	ee66 6aa8 	vmul.f32	s13, s13, s17
 802bab8:	eefc 6ae6 	vcvt.u32.f32	s13, s13
 802babc:	ee16 2a90 	vmov	r2, s13
      
      if ((target_range - p_algo_settings->range_offset_cm) > 0)
 802bac0:	429a      	cmp	r2, r3
      {
        target_range = target_range - p_algo_settings->range_offset_cm;
 802bac2:	bf18      	it	ne
 802bac4:	1ad3      	subne	r3, r2, r3
      }
      
      if ((target_range >= p_algo_settings->min_distance_cm) && (target_range <= p_algo_settings->max_distance_cm))
 802bac6:	f8d9 202c 	ldr.w	r2, [r9, #44]	; 0x2c
 802baca:	429a      	cmp	r2, r3
 802bacc:	d82d      	bhi.n	802bb2a <range_doppler_do+0x532>
 802bace:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
 802bad2:	4293      	cmp	r3, r2
 802bad4:	d829      	bhi.n	802bb2a <range_doppler_do+0x532>
      {
        float fp_new;
        
        if(peak_idx > fp_bin)
 802bad6:	eef4 7ac7 	vcmpe.f32	s15, s14
 802bada:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802bade:	f100 8226 	bmi.w	802bf2e <range_doppler_do+0x936>
          fp_new = fp +(fr - fp) * (peak_idx - fp_bin) / (fr_bin - fp_bin);
        else
          fp_new= fl + (fp - fl) * (fp_bin - peak_idx) / (fp_bin - fl_bin);
 802bae2:	ee35 5a64 	vsub.f32	s10, s10, s9
 802bae6:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802baea:	eee5 4a27 	vfma.f32	s9, s10, s15
 802baee:	eeb0 5a64 	vmov.f32	s10, s9
        
        target_info[num_of_targets].strength = fp_new;  // FFT magnitude level
        
        target_info[num_of_targets].range = target_range; // Range in centimeters (cm)
 802baf2:	ee07 3a90 	vmov	s15, r3
        if(peak_idx > fp_bin)
          fp_new = fp +(fr - fp) * (peak_idx - fp_bin) / (fr_bin - fp_bin);
        else
          fp_new= fl + (fp - fl) * (fp_bin - peak_idx) / (fp_bin - fl_bin);
        
        target_info[num_of_targets].strength = fp_new;  // FFT magnitude level
 802baf6:	eb08 0b88 	add.w	fp, r8, r8, lsl #2
        
        target_info[num_of_targets].range = target_range; // Range in centimeters (cm)
 802bafa:	eef8 7a67 	vcvt.f32.u32	s15, s15
        if(peak_idx > fp_bin)
          fp_new = fp +(fr - fp) * (peak_idx - fp_bin) / (fr_bin - fp_bin);
        else
          fp_new= fl + (fp - fl) * (fp_bin - peak_idx) / (fp_bin - fl_bin);
        
        target_info[num_of_targets].strength = fp_new;  // FFT magnitude level
 802bafe:	eb0a 028b 	add.w	r2, sl, fp, lsl #2
 802bb02:	ed82 5a01 	vstr	s10, [r2, #4]
        
        target_info[num_of_targets].range = target_range; // Range in centimeters (cm)
 802bb06:	edc2 7a02 	vstr	s15, [r2, #8]
        
        target_info[num_of_targets].idx = (uint32_t)(peak_idx + 0.5);  // index of FFT where target is detected (rounded)
 802bb0a:	ee17 0a10 	vmov	r0, s14
 802bb0e:	f002 f9a7 	bl	802de60 <__aeabi_f2d>
 802bb12:	2200      	movs	r2, #0
 802bb14:	4b7e      	ldr	r3, [pc, #504]	; (802bd10 <range_doppler_do+0x718>)
 802bb16:	f002 f845 	bl	802dba4 <__adddf3>
 802bb1a:	f002 fcb7 	bl	802e48c <__aeabi_d2uiz>
        
        num_of_targets++;
 802bb1e:	f108 0801 	add.w	r8, r8, #1
        
        target_info[num_of_targets].strength = fp_new;  // FFT magnitude level
        
        target_info[num_of_targets].range = target_range; // Range in centimeters (cm)
        
        target_info[num_of_targets].idx = (uint32_t)(peak_idx + 0.5);  // index of FFT where target is detected (rounded)
 802bb22:	f84a 002b 	str.w	r0, [sl, fp, lsl #2]
        
        num_of_targets++;
 802bb26:	fa5f f888 	uxtb.w	r8, r8
      }
      
      if (num_of_targets >= MAX_NUM_OF_TARGETS)
 802bb2a:	f1b8 0f04 	cmp.w	r8, #4
 802bb2e:	f200 8209 	bhi.w	802bf44 <range_doppler_do+0x94c>
  // Nc is set via "p_acq_buf->params.num_of_chirps_per_frame" and comes from the buffer, so the following statement is obsolete, to some extent. If violated, it should raise an fatal error!
  Nc = (Nc > NUM_OF_CHIRPS) ? NUM_OF_CHIRPS : Nc; // to avoid out of memory flow in case more number of chirps selected
  
  //==================== (1) Fast FFT on Rx1 & Rx2 ===========================
  
  for (j = 0; j < Nc; j++)		// Loop over number of chirps
 802bb32:	4633      	mov	r3, r6
  uint32_t  fl2_bin, fl_bin, fp_bin, fr_bin, fr2_bin;
  float fl2,fl, fp, fr,fr2;
  float peak_idx = 0;
  uint8_t num_of_targets = 0;
  
  while (n <= (search_length - 2))
 802bb34:	42bb      	cmp	r3, r7
 802bb36:	f67f af62 	bls.w	802b9fe <range_doppler_do+0x406>
  
  memset(&p_targets->elems[0], 0, sizeof(p_targets->elems)); // clear target data
  
  memset(&target_measurements[0], 0, sizeof(target_measurements));
  
  p_targets->num_of_targets = target_detection(cp_algo_settings, range_fft_spectrum, &p_targets->elems[0], peak_search_max_idx, range_detection_threshold);
 802bb3a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 802bb3c:	f8c3 8000 	str.w	r8, [r3]
  
  //=========== (5) Slow FFT on Rx1 & Rx2 ====================================
  
  if ((p_targets->num_of_targets > 0) && (Nc > 1))
 802bb40:	9b10      	ldr	r3, [sp, #64]	; 0x40
 802bb42:	2b01      	cmp	r3, #1
  
  memset(&p_targets->elems[0], 0, sizeof(p_targets->elems)); // clear target data
  
  memset(&target_measurements[0], 0, sizeof(target_measurements));
  
  p_targets->num_of_targets = target_detection(cp_algo_settings, range_fft_spectrum, &p_targets->elems[0], peak_search_max_idx, range_detection_threshold);
 802bb44:	4642      	mov	r2, r8
  
  //=========== (5) Slow FFT on Rx1 & Rx2 ====================================
  
  if ((p_targets->num_of_targets > 0) && (Nc > 1))
 802bb46:	f240 811a 	bls.w	802bd7e <range_doppler_do+0x786>
  {
    for (j = 0; j < p_targets->num_of_targets; j++)
 802bb4a:	2a00      	cmp	r2, #0
 802bb4c:	f000 8117 	beq.w	802bd7e <range_doppler_do+0x786>
  float if1_real, if2_real;
  float if1_imag, if2_imag;
  
  float max_value;
  
  float PulseRepTime_sec = (float)(cp_dev_settings->pll_chirp_time_usec + PLL_RAMP_DOWM_TIME_USEC + PLL_STEADY_STATE_USEC) * 1e-6;  // Chirp repetition time in seconds
 802bb50:	981b      	ldr	r0, [sp, #108]	; 0x6c
 802bb52:	4c70      	ldr	r4, [pc, #448]	; (802bd14 <range_doppler_do+0x71c>)
 802bb54:	f8df 91b0 	ldr.w	r9, [pc, #432]	; 802bd08 <range_doppler_do+0x710>
 802bb58:	f8df b1e4 	ldr.w	fp, [pc, #484]	; 802bd40 <range_doppler_do+0x748>
        if2_real = doppler_fft_signal_rx2[2*idx_max];
        if2_imag = doppler_fft_signal_rx2[2*idx_max + 1];
      }
      else
      {
        p_targets->elems[j].speed = 0;
 802bb5c:	ed9f ba6e 	vldr	s22, [pc, #440]	; 802bd18 <range_doppler_do+0x720>
        {
          p_targets->elems[j].speed = (float) ((int32_t)idx_max * -Fd_per_bin) * (float)Hz_2_MPS;
        }
        else // target approching
        {
          p_targets->elems[j].speed = (float)((DOPPLER_FFT_SIZE - 1 - idx_max) * Fd_per_bin) * (float)Hz_2_MPS;
 802bb60:	ed9f aa6e 	vldr	s20, [pc, #440]	; 802bd1c <range_doppler_do+0x724>
      {
        target_angle_data T;
        
        float wave_length_ant_spacing_ratio = (BSP_TGT_WAVE_LENGTH_MM / BSP_TGT_ANTENNA_SPACING_MM);
        
        T= compute_angle(if1_real, if1_imag, if2_real, if2_imag, IGNORE_NAN, cp_algo_settings->angle_offset_deg, wave_length_ant_spacing_ratio);
 802bb64:	eddf aa6e 	vldr	s21, [pc, #440]	; 802bd20 <range_doppler_do+0x728>
  float if1_real, if2_real;
  float if1_imag, if2_imag;
  
  float max_value;
  
  float PulseRepTime_sec = (float)(cp_dev_settings->pll_chirp_time_usec + PLL_RAMP_DOWM_TIME_USEC + PLL_STEADY_STATE_USEC) * 1e-6;  // Chirp repetition time in seconds
 802bb68:	30c8      	adds	r0, #200	; 0xc8
 802bb6a:	ee07 0a90 	vmov	s15, r0
 802bb6e:	eef8 7a67 	vcvt.f32.u32	s15, s15
  
  float range_detection_threshold = cp_algo_settings->range_detection_threshold;
  
  uint32_t peak_search_max_idx;
  
  float Fd_per_bin = 1.0f/(float)(PulseRepTime_sec * DOPPLER_FFT_SIZE);  // Doppler Per bin
 802bb72:	eef7 8a00 	vmov.f32	s17, #112	; 0x70
  float if1_real, if2_real;
  float if1_imag, if2_imag;
  
  float max_value;
  
  float PulseRepTime_sec = (float)(cp_dev_settings->pll_chirp_time_usec + PLL_RAMP_DOWM_TIME_USEC + PLL_STEADY_STATE_USEC) * 1e-6;  // Chirp repetition time in seconds
 802bb76:	ee17 0a90 	vmov	r0, s15
 802bb7a:	f002 f971 	bl	802de60 <__aeabi_f2d>
 802bb7e:	a35c      	add	r3, pc, #368	; (adr r3, 802bcf0 <range_doppler_do+0x6f8>)
 802bb80:	e9d3 2300 	ldrd	r2, r3, [r3]
 802bb84:	f002 f9c0 	bl	802df08 <__aeabi_dmul>
 802bb88:	f002 fca0 	bl	802e4cc <__aeabi_d2f>
  
  float range_detection_threshold = cp_algo_settings->range_detection_threshold;
  
  uint32_t peak_search_max_idx;
  
  float Fd_per_bin = 1.0f/(float)(PulseRepTime_sec * DOPPLER_FFT_SIZE);  // Doppler Per bin
 802bb8c:	eddf 7a65 	vldr	s15, [pc, #404]	; 802bd24 <range_doppler_do+0x72c>
 802bb90:	9a10      	ldr	r2, [sp, #64]	; 0x40
 802bb92:	f8dd 805c 	ldr.w	r8, [sp, #92]	; 0x5c
      {
        target_angle_data T;
        
        float wave_length_ant_spacing_ratio = (BSP_TGT_WAVE_LENGTH_MM / BSP_TGT_ANTENNA_SPACING_MM);
        
        T= compute_angle(if1_real, if1_imag, if2_real, if2_imag, IGNORE_NAN, cp_algo_settings->angle_offset_deg, wave_length_ant_spacing_ratio);
 802bb96:	9e16      	ldr	r6, [sp, #88]	; 0x58
  
  float range_detection_threshold = cp_algo_settings->range_detection_threshold;
  
  uint32_t peak_search_max_idx;
  
  float Fd_per_bin = 1.0f/(float)(PulseRepTime_sec * DOPPLER_FFT_SIZE);  // Doppler Per bin
 802bb98:	ee07 0a10 	vmov	s14, r0
 802bb9c:	ee67 7a27 	vmul.f32	s15, s14, s15
 802bba0:	b293      	uxth	r3, r2
 802bba2:	eec8 8aa7 	vdiv.f32	s17, s17, s15
 802bba6:	9308      	str	r3, [sp, #32]
 802bba8:	ab20      	add	r3, sp, #128	; 0x80
 802bbaa:	9311      	str	r3, [sp, #68]	; 0x44
 802bbac:	ab22      	add	r3, sp, #136	; 0x88
 802bbae:	9313      	str	r3, [sp, #76]	; 0x4c
 802bbb0:	ab21      	add	r3, sp, #132	; 0x84
 802bbb2:	eb04 0482 	add.w	r4, r4, r2, lsl #2
 802bbb6:	9312      	str	r3, [sp, #72]	; 0x48
 802bbb8:	ab23      	add	r3, sp, #140	; 0x8c
 802bbba:	f04f 0a00 	mov.w	sl, #0
 802bbbe:	9314      	str	r3, [sp, #80]	; 0x50
 802bbc0:	ad24      	add	r5, sp, #144	; 0x90
      {
        target_angle_data T;
        
        float wave_length_ant_spacing_ratio = (BSP_TGT_WAVE_LENGTH_MM / BSP_TGT_ANTENNA_SPACING_MM);
        
        T= compute_angle(if1_real, if1_imag, if2_real, if2_imag, IGNORE_NAN, cp_algo_settings->angle_offset_deg, wave_length_ant_spacing_ratio);
 802bbc2:	9407      	str	r4, [sp, #28]
 802bbc4:	ed9f 9b4c 	vldr	d9, [pc, #304]	; 802bcf8 <range_doppler_do+0x700>
  
  if ((p_targets->num_of_targets > 0) && (Nc > 1))
  {
    for (j = 0; j < p_targets->num_of_targets; j++)
    {
      uint32_t idx_max = 0;
 802bbc8:	2300      	movs	r3, #0
 802bbca:	9325      	str	r3, [sp, #148]	; 0x94
      target_idx = 2 * p_targets->elems[j].idx; // Get the index of Fast FFT spectrum where target is detected
 802bbcc:	f8d8 300c 	ldr.w	r3, [r8, #12]
 802bbd0:	9c19      	ldr	r4, [sp, #100]	; 0x64
 802bbd2:	4a50      	ldr	r2, [pc, #320]	; (802bd14 <range_doppler_do+0x71c>)
 802bbd4:	4f54      	ldr	r7, [pc, #336]	; (802bd28 <range_doppler_do+0x730>)
 802bbd6:	4855      	ldr	r0, [pc, #340]	; (802bd2c <range_doppler_do+0x734>)
 802bbd8:	4955      	ldr	r1, [pc, #340]	; (802bd30 <range_doppler_do+0x738>)
 802bbda:	00db      	lsls	r3, r3, #3
 802bbdc:	eb04 0e03 	add.w	lr, r4, r3
 802bbe0:	4c54      	ldr	r4, [pc, #336]	; (802bd34 <range_doppler_do+0x73c>)
 802bbe2:	4423      	add	r3, r4
 802bbe4:	9c07      	ldr	r4, [sp, #28]
      
      for (i = 0; i < Nc; i++)	// Loop over number of chirps
      {
        uint32_t idx = target_idx + (2 * RANGE_FFT_SIZE) * i;
        
        fft_input_i1[i]  = range_fft_signal_rx1[idx];
 802bbe6:	edde 7a00 	vldr	s15, [lr]
        fft_input_q1[i]  = range_fft_signal_rx1[idx + 1];
 802bbea:	f8de c004 	ldr.w	ip, [lr, #4]
      
      for (i = 0; i < Nc; i++)	// Loop over number of chirps
      {
        uint32_t idx = target_idx + (2 * RANGE_FFT_SIZE) * i;
        
        fft_input_i1[i]  = range_fft_signal_rx1[idx];
 802bbee:	ece2 7a01 	vstmia	r2!, {s15}
        fft_input_q1[i]  = range_fft_signal_rx1[idx + 1];
        
        fft_input_i2[i]  = range_fft_signal_rx2[idx];
 802bbf2:	edd3 7a00 	vldr	s15, [r3]
      for (i = 0; i < Nc; i++)	// Loop over number of chirps
      {
        uint32_t idx = target_idx + (2 * RANGE_FFT_SIZE) * i;
        
        fft_input_i1[i]  = range_fft_signal_rx1[idx];
        fft_input_q1[i]  = range_fft_signal_rx1[idx + 1];
 802bbf6:	f847 cb04 	str.w	ip, [r7], #4
    for (j = 0; j < p_targets->num_of_targets; j++)
    {
      uint32_t idx_max = 0;
      target_idx = 2 * p_targets->elems[j].idx; // Get the index of Fast FFT spectrum where target is detected
      
      for (i = 0; i < Nc; i++)	// Loop over number of chirps
 802bbfa:	42a2      	cmp	r2, r4
        
        fft_input_i1[i]  = range_fft_signal_rx1[idx];
        fft_input_q1[i]  = range_fft_signal_rx1[idx + 1];
        
        fft_input_i2[i]  = range_fft_signal_rx2[idx];
        fft_input_q2[i]  = range_fft_signal_rx2[idx + 1];
 802bbfc:	f8d3 c004 	ldr.w	ip, [r3, #4]
        uint32_t idx = target_idx + (2 * RANGE_FFT_SIZE) * i;
        
        fft_input_i1[i]  = range_fft_signal_rx1[idx];
        fft_input_q1[i]  = range_fft_signal_rx1[idx + 1];
        
        fft_input_i2[i]  = range_fft_signal_rx2[idx];
 802bc00:	ece0 7a01 	vstmia	r0!, {s15}
 802bc04:	f50e 6e00 	add.w	lr, lr, #2048	; 0x800
        fft_input_q2[i]  = range_fft_signal_rx2[idx + 1];
 802bc08:	f841 cb04 	str.w	ip, [r1], #4
 802bc0c:	f503 6300 	add.w	r3, r3, #2048	; 0x800
    for (j = 0; j < p_targets->num_of_targets; j++)
    {
      uint32_t idx_max = 0;
      target_idx = 2 * p_targets->elems[j].idx; // Get the index of Fast FFT spectrum where target is detected
      
      for (i = 0; i < Nc; i++)	// Loop over number of chirps
 802bc10:	d1e9      	bne.n	802bbe6 <range_doppler_do+0x5ee>
        fft_input_i2[i]  = range_fft_signal_rx2[idx];
        fft_input_q2[i]  = range_fft_signal_rx2[idx + 1];
      }
      
      //-------------------------------- Rx1 ---------------------------------
      compute_fft_signal(fft_input_i1, fft_input_q1, Nc, DOPPLER_FFT_SIZE, 1.0,
 802bc12:	9b11      	ldr	r3, [sp, #68]	; 0x44
 802bc14:	9407      	str	r4, [sp, #28]
 802bc16:	9303      	str	r3, [sp, #12]
 802bc18:	9c08      	ldr	r4, [sp, #32]
 802bc1a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 802bc1c:	9304      	str	r3, [sp, #16]
 802bc1e:	f04f 0c02 	mov.w	ip, #2
 802bc22:	eef7 ba00 	vmov.f32	s23, #112	; 0x70
 802bc26:	2701      	movs	r7, #1
 802bc28:	4b43      	ldr	r3, [pc, #268]	; (802bd38 <range_doppler_do+0x740>)
 802bc2a:	9305      	str	r3, [sp, #20]
 802bc2c:	f8cd c004 	str.w	ip, [sp, #4]
 802bc30:	4838      	ldr	r0, [pc, #224]	; (802bd14 <range_doppler_do+0x71c>)
 802bc32:	493d      	ldr	r1, [pc, #244]	; (802bd28 <range_doppler_do+0x730>)
 802bc34:	edcd ba00 	vstr	s23, [sp]
 802bc38:	4622      	mov	r2, r4
 802bc3a:	2340      	movs	r3, #64	; 0x40
 802bc3c:	9702      	str	r7, [sp, #8]
 802bc3e:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
 802bc42:	f7fd fa97 	bl	8029174 <compute_fft_signal>
                         FFT_INPUT_COMPLEX, FFT_SLOW_TIME, &if1_real, &if1_imag, doppler_fft_signal_rx1);
      
      //-------------------------------- Rx2 ---------------------------------

      compute_fft_signal(fft_input_i2, fft_input_q2, Nc, DOPPLER_FFT_SIZE, 1.0,
 802bc46:	9b12      	ldr	r3, [sp, #72]	; 0x48
 802bc48:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 802bc4c:	9303      	str	r3, [sp, #12]
 802bc4e:	9b14      	ldr	r3, [sp, #80]	; 0x50
 802bc50:	f8cd c004 	str.w	ip, [sp, #4]
 802bc54:	9304      	str	r3, [sp, #16]
 802bc56:	4835      	ldr	r0, [pc, #212]	; (802bd2c <range_doppler_do+0x734>)
 802bc58:	4935      	ldr	r1, [pc, #212]	; (802bd30 <range_doppler_do+0x738>)
 802bc5a:	edcd ba00 	vstr	s23, [sp]
 802bc5e:	2340      	movs	r3, #64	; 0x40
 802bc60:	4622      	mov	r2, r4
 802bc62:	9702      	str	r7, [sp, #8]
 802bc64:	f8cd b014 	str.w	fp, [sp, #20]
 802bc68:	f7fd fa84 	bl	8029174 <compute_fft_signal>
                         FFT_INPUT_COMPLEX, FFT_SLOW_TIME, &if2_real, &if2_imag, doppler_fft_signal_rx2);
      
#if (RX_ANTENNA_SELECTION == 1U)
      compute_fft_spectrum(doppler_fft_signal_rx1, DOPPLER_FFT_SIZE, doppler_fft_spectrum);
 802bc6c:	4832      	ldr	r0, [pc, #200]	; (802bd38 <range_doppler_do+0x740>)
 802bc6e:	4a33      	ldr	r2, [pc, #204]	; (802bd3c <range_doppler_do+0x744>)
 802bc70:	2140      	movs	r1, #64	; 0x40
 802bc72:	f7fd fb87 	bl	8029384 <compute_fft_spectrum>
#else
      compute_fft_spectrum(doppler_fft_signal_rx2, DOPPLER_FFT_SIZE, doppler_fft_spectrum);
#endif
      
      arm_max_f32(doppler_fft_spectrum, (uint32_t)DOPPLER_FFT_SIZE, &max_value, &idx_max);
 802bc76:	4831      	ldr	r0, [pc, #196]	; (802bd3c <range_doppler_do+0x744>)
 802bc78:	2140      	movs	r1, #64	; 0x40
 802bc7a:	462a      	mov	r2, r5
 802bc7c:	ab25      	add	r3, sp, #148	; 0x94
 802bc7e:	f7fc fccb 	bl	8028618 <arm_max_f32>
      
      if (max_value >= cp_algo_settings->speed_detection_threshold && idx_max != 0)
 802bc82:	edd6 7a0e 	vldr	s15, [r6, #56]	; 0x38
 802bc86:	ed9d 7a24 	vldr	s14, [sp, #144]	; 0x90
 802bc8a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 802bc8e:	eef4 7ac7 	vcmpe.f32	s15, s14
 802bc92:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802bc96:	f200 80d3 	bhi.w	802be40 <range_doppler_do+0x848>
 802bc9a:	9b25      	ldr	r3, [sp, #148]	; 0x94
 802bc9c:	2b00      	cmp	r3, #0
 802bc9e:	f000 80cf 	beq.w	802be40 <range_doppler_do+0x848>
      {
        if (idx_max < DOPPLER_FFT_SIZE/2) // target departing
 802bca2:	2b1f      	cmp	r3, #31
 802bca4:	f200 80e7 	bhi.w	802be76 <range_doppler_do+0x87e>
        {
          p_targets->elems[j].speed = (float) ((int32_t)idx_max * -Fd_per_bin) * (float)Hz_2_MPS;
 802bca8:	ee07 3a90 	vmov	s15, r3
 802bcac:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802bcb0:	ee68 7ae7 	vnmul.f32	s15, s17, s15
 802bcb4:	ee67 7a8a 	vmul.f32	s15, s15, s20
        }
        
        //=========== (6) Angle Calculation on Rx1 & Rx2 =====================
        
        if1_real = doppler_fft_signal_rx1[2*idx_max];
        if1_imag = doppler_fft_signal_rx1[2*idx_max + 1];
 802bcb8:	00da      	lsls	r2, r3, #3
 802bcba:	491f      	ldr	r1, [pc, #124]	; (802bd38 <range_doppler_do+0x740>)
 802bcbc:	edc8 7a06 	vstr	s15, [r8, #24]
 802bcc0:	3204      	adds	r2, #4
 802bcc2:	188f      	adds	r7, r1, r2
        
        if2_real = doppler_fft_signal_rx2[2*idx_max];
        if2_imag = doppler_fft_signal_rx2[2*idx_max + 1];
 802bcc4:	eb0b 0102 	add.w	r1, fp, r2
          p_targets->elems[j].speed = (float)((DOPPLER_FFT_SIZE - 1 - idx_max) * Fd_per_bin) * (float)Hz_2_MPS;
        }
        
        //=========== (6) Angle Calculation on Rx1 & Rx2 =====================
        
        if1_real = doppler_fft_signal_rx1[2*idx_max];
 802bcc8:	4a1b      	ldr	r2, [pc, #108]	; (802bd38 <range_doppler_do+0x740>)
 802bcca:	00db      	lsls	r3, r3, #3
 802bccc:	18d0      	adds	r0, r2, r3
        if1_imag = doppler_fft_signal_rx1[2*idx_max + 1];
 802bcce:	683a      	ldr	r2, [r7, #0]
        
        if2_real = doppler_fft_signal_rx2[2*idx_max];
        if2_imag = doppler_fft_signal_rx2[2*idx_max + 1];
 802bcd0:	680f      	ldr	r7, [r1, #0]
          p_targets->elems[j].speed = (float)((DOPPLER_FFT_SIZE - 1 - idx_max) * Fd_per_bin) * (float)Hz_2_MPS;
        }
        
        //=========== (6) Angle Calculation on Rx1 & Rx2 =====================
        
        if1_real = doppler_fft_signal_rx1[2*idx_max];
 802bcd2:	6801      	ldr	r1, [r0, #0]
      else
      {
        p_targets->elems[j].speed = 0;
      }
      
      if (cp_algo_settings->tracking_enable == 1U)
 802bcd4:	68f0      	ldr	r0, [r6, #12]
        }
        
        //=========== (6) Angle Calculation on Rx1 & Rx2 =====================
        
        if1_real = doppler_fft_signal_rx1[2*idx_max];
        if1_imag = doppler_fft_signal_rx1[2*idx_max + 1];
 802bcd6:	9222      	str	r2, [sp, #136]	; 0x88
        
        if2_real = doppler_fft_signal_rx2[2*idx_max];
 802bcd8:	445b      	add	r3, fp
      else
      {
        p_targets->elems[j].speed = 0;
      }
      
      if (cp_algo_settings->tracking_enable == 1U)
 802bcda:	2801      	cmp	r0, #1
        //=========== (6) Angle Calculation on Rx1 & Rx2 =====================
        
        if1_real = doppler_fft_signal_rx1[2*idx_max];
        if1_imag = doppler_fft_signal_rx1[2*idx_max + 1];
        
        if2_real = doppler_fft_signal_rx2[2*idx_max];
 802bcdc:	681b      	ldr	r3, [r3, #0]
        if2_imag = doppler_fft_signal_rx2[2*idx_max + 1];
 802bcde:	9723      	str	r7, [sp, #140]	; 0x8c
          p_targets->elems[j].speed = (float)((DOPPLER_FFT_SIZE - 1 - idx_max) * Fd_per_bin) * (float)Hz_2_MPS;
        }
        
        //=========== (6) Angle Calculation on Rx1 & Rx2 =====================
        
        if1_real = doppler_fft_signal_rx1[2*idx_max];
 802bce0:	9120      	str	r1, [sp, #128]	; 0x80
        if1_imag = doppler_fft_signal_rx1[2*idx_max + 1];
        
        if2_real = doppler_fft_signal_rx2[2*idx_max];
 802bce2:	9321      	str	r3, [sp, #132]	; 0x84
      else
      {
        p_targets->elems[j].speed = 0;
      }
      
      if (cp_algo_settings->tracking_enable == 1U)
 802bce4:	f040 80b8 	bne.w	802be58 <range_doppler_do+0x860>
 802bce8:	e02c      	b.n	802bd44 <range_doppler_do+0x74c>
 802bcea:	bf00      	nop
 802bcec:	f3af 8000 	nop.w
 802bcf0:	a0b5ed8d 	.word	0xa0b5ed8d
 802bcf4:	3eb0c6f7 	.word	0x3eb0c6f7
 802bcf8:	00000000 	.word	0x00000000
 802bcfc:	40815800 	.word	0x40815800
 802bd00:	2000374c 	.word	0x2000374c
 802bd04:	42c80000 	.word	0x42c80000
 802bd08:	20003948 	.word	0x20003948
 802bd0c:	20003944 	.word	0x20003944
 802bd10:	3fe00000 	.word	0x3fe00000
 802bd14:	20003eec 	.word	0x20003eec
 802bd18:	00000000 	.word	0x00000000
 802bd1c:	3bcb295f 	.word	0x3bcb295f
 802bd20:	3fff2d46 	.word	0x3fff2d46
 802bd24:	42800000 	.word	0x42800000
 802bd28:	20002b44 	.word	0x20002b44
 802bd2c:	200042f0 	.word	0x200042f0
 802bd30:	20002f44 	.word	0x20002f44
 802bd34:	1fffab44 	.word	0x1fffab44
 802bd38:	20003344 	.word	0x20003344
 802bd3c:	200039ec 	.word	0x200039ec
 802bd40:	20003544 	.word	0x20003544
      {
        target_measurements[j].strength = p_targets->elems[j].strength;
 802bd44:	f8d8 0010 	ldr.w	r0, [r8, #16]
 802bd48:	f8c9 0004 	str.w	r0, [r9, #4]
        target_measurements[j].range    = p_targets->elems[j].range;
 802bd4c:	f8d8 0014 	ldr.w	r0, [r8, #20]
 802bd50:	f8c9 0008 	str.w	r0, [r9, #8]
        target_measurements[j].speed    = p_targets->elems[j].speed;
 802bd54:	edc9 7a03 	vstr	s15, [r9, #12]
        
        target_measurements[j].rx1_angle_arg_re = if1_real;
 802bd58:	f8c9 1010 	str.w	r1, [r9, #16]
        target_measurements[j].rx1_angle_arg_im = if1_imag;
 802bd5c:	f8c9 2014 	str.w	r2, [r9, #20]
        target_measurements[j].rx2_angle_arg_re = if2_real;
 802bd60:	f8c9 3018 	str.w	r3, [r9, #24]
        target_measurements[j].rx2_angle_arg_im = if2_imag;
 802bd64:	f8c9 701c 	str.w	r7, [r9, #28]
  
  //=========== (5) Slow FFT on Rx1 & Rx2 ====================================
  
  if ((p_targets->num_of_targets > 0) && (Nc > 1))
  {
    for (j = 0; j < p_targets->num_of_targets; j++)
 802bd68:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 802bd6a:	681a      	ldr	r2, [r3, #0]
 802bd6c:	f10a 0a01 	add.w	sl, sl, #1
 802bd70:	4552      	cmp	r2, sl
 802bd72:	f108 0814 	add.w	r8, r8, #20
 802bd76:	f109 0920 	add.w	r9, r9, #32
 802bd7a:	f63f af25 	bhi.w	802bbc8 <range_doppler_do+0x5d0>
  }
  
  //=========== (7) Measurement update =======================================
  
  p_algo_result->p_target_list->mode = target_mode;
  if (cp_algo_settings->tracking_enable == 1U)
 802bd7e:	9916      	ldr	r1, [sp, #88]	; 0x58
    }
  }
  
  //=========== (7) Measurement update =======================================
  
  p_algo_result->p_target_list->mode = target_mode;
 802bd80:	9b18      	ldr	r3, [sp, #96]	; 0x60
  if (cp_algo_settings->tracking_enable == 1U)
 802bd82:	68c9      	ldr	r1, [r1, #12]
    }
  }
  
  //=========== (7) Measurement update =======================================
  
  p_algo_result->p_target_list->mode = target_mode;
 802bd84:	685b      	ldr	r3, [r3, #4]
 802bd86:	2001      	movs	r0, #1
  if (cp_algo_settings->tracking_enable == 1U)
 802bd88:	4281      	cmp	r1, r0
    }
  }
  
  //=========== (7) Measurement update =======================================
  
  p_algo_result->p_target_list->mode = target_mode;
 802bd8a:	7218      	strb	r0, [r3, #8]
  if (cp_algo_settings->tracking_enable == 1U)
 802bd8c:	d07e      	beq.n	802be8c <range_doppler_do+0x894>
static void target_sorting(algo_result_t *algo_result)
{
  target_data_t *p_target = algo_result->p_target_list->elems;
  target_data_t tmp;
  
  if(algo_result->p_target_list->num_of_targets < 2)
 802bd8e:	681a      	ldr	r2, [r3, #0]
 802bd90:	2a01      	cmp	r2, #1
 802bd92:	d946      	bls.n	802be22 <range_doppler_do+0x82a>

//===========================================================================

static void target_sorting(algo_result_t *algo_result)
{
  target_data_t *p_target = algo_result->p_target_list->elems;
 802bd94:	2100      	movs	r1, #0
  
  if(algo_result->p_target_list->num_of_targets < 2)
    return; // nothing to sort
  
  /* Sorting of the targets header */
  for (uint8_t m = 0; m < (algo_result->p_target_list->num_of_targets - 1); m++)
 802bd96:	3a01      	subs	r2, #1

//===========================================================================

static void target_sorting(algo_result_t *algo_result)
{
  target_data_t *p_target = algo_result->p_target_list->elems;
 802bd98:	9108      	str	r1, [sp, #32]
  
  if(algo_result->p_target_list->num_of_targets < 2)
    return; // nothing to sort
  
  /* Sorting of the targets header */
  for (uint8_t m = 0; m < (algo_result->p_target_list->num_of_targets - 1); m++)
 802bd9a:	9209      	str	r2, [sp, #36]	; 0x24

//===========================================================================

static void target_sorting(algo_result_t *algo_result)
{
  target_data_t *p_target = algo_result->p_target_list->elems;
 802bd9c:	f103 0a0c 	add.w	sl, r3, #12
 802bda0:	468b      	mov	fp, r1
    return; // nothing to sort
  
  /* Sorting of the targets header */
  for (uint8_t m = 0; m < (algo_result->p_target_list->num_of_targets - 1); m++)
  {
    for (uint8_t n = 0; n < (algo_result->p_target_list->num_of_targets - m - 1); n++)
 802bda2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802bda4:	ebb3 030b 	subs.w	r3, r3, fp
 802bda8:	9307      	str	r3, [sp, #28]
 802bdaa:	d032      	beq.n	802be12 <range_doppler_do+0x81a>
 802bdac:	2600      	movs	r6, #0
 802bdae:	4634      	mov	r4, r6
    {
      if (p_target[n].strength < p_target[n+1].strength) // Compare FFT amplitude levels
 802bdb0:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 802bdb4:	009b      	lsls	r3, r3, #2
 802bdb6:	f103 0514 	add.w	r5, r3, #20
 802bdba:	4455      	add	r5, sl
 802bdbc:	4453      	add	r3, sl
 802bdbe:	edd5 7a01 	vldr	s15, [r5, #4]
 802bdc2:	ed93 7a01 	vldr	s14, [r3, #4]
    return; // nothing to sort
  
  /* Sorting of the targets header */
  for (uint8_t m = 0; m < (algo_result->p_target_list->num_of_targets - 1); m++)
  {
    for (uint8_t n = 0; n < (algo_result->p_target_list->num_of_targets - m - 1); n++)
 802bdc6:	3601      	adds	r6, #1
    {
      if (p_target[n].strength < p_target[n+1].strength) // Compare FFT amplitude levels
 802bdc8:	eeb4 7ae7 	vcmpe.f32	s14, s15
      {
        tmp = p_target[n];
 802bdcc:	f10d 0c98 	add.w	ip, sp, #152	; 0x98
    return; // nothing to sort
  
  /* Sorting of the targets header */
  for (uint8_t m = 0; m < (algo_result->p_target_list->num_of_targets - 1); m++)
  {
    for (uint8_t n = 0; n < (algo_result->p_target_list->num_of_targets - m - 1); n++)
 802bdd0:	b2f6      	uxtb	r6, r6
    {
      if (p_target[n].strength < p_target[n+1].strength) // Compare FFT amplitude levels
 802bdd2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
      {
        tmp = p_target[n];
        p_target[n] = p_target[n+1];
 802bdd6:	46ae      	mov	lr, r5
  {
    for (uint8_t n = 0; n < (algo_result->p_target_list->num_of_targets - m - 1); n++)
    {
      if (p_target[n].strength < p_target[n+1].strength) // Compare FFT amplitude levels
      {
        tmp = p_target[n];
 802bdd8:	461f      	mov	r7, r3
        p_target[n] = p_target[n+1];
 802bdda:	4699      	mov	r9, r3
        p_target[n+1] = tmp;
 802bddc:	46e0      	mov	r8, ip
    return; // nothing to sort
  
  /* Sorting of the targets header */
  for (uint8_t m = 0; m < (algo_result->p_target_list->num_of_targets - 1); m++)
  {
    for (uint8_t n = 0; n < (algo_result->p_target_list->num_of_targets - m - 1); n++)
 802bdde:	4634      	mov	r4, r6
    {
      if (p_target[n].strength < p_target[n+1].strength) // Compare FFT amplitude levels
 802bde0:	d514      	bpl.n	802be0c <range_doppler_do+0x814>
      {
        tmp = p_target[n];
 802bde2:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 802bde4:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
        p_target[n] = p_target[n+1];
 802bde8:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
  {
    for (uint8_t n = 0; n < (algo_result->p_target_list->num_of_targets - m - 1); n++)
    {
      if (p_target[n].strength < p_target[n+1].strength) // Compare FFT amplitude levels
      {
        tmp = p_target[n];
 802bdec:	f8d7 b000 	ldr.w	fp, [r7]
 802bdf0:	f8cc b000 	str.w	fp, [ip]
        p_target[n] = p_target[n+1];
 802bdf4:	e8a9 000f 	stmia.w	r9!, {r0, r1, r2, r3}
        p_target[n+1] = tmp;
 802bdf8:	e8b8 000f 	ldmia.w	r8!, {r0, r1, r2, r3}
 802bdfc:	46ac      	mov	ip, r5
    for (uint8_t n = 0; n < (algo_result->p_target_list->num_of_targets - m - 1); n++)
    {
      if (p_target[n].strength < p_target[n+1].strength) // Compare FFT amplitude levels
      {
        tmp = p_target[n];
        p_target[n] = p_target[n+1];
 802bdfe:	f8de 5000 	ldr.w	r5, [lr]
 802be02:	603d      	str	r5, [r7, #0]
        p_target[n+1] = tmp;
 802be04:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 802be08:	f8ce b000 	str.w	fp, [lr]
    return; // nothing to sort
  
  /* Sorting of the targets header */
  for (uint8_t m = 0; m < (algo_result->p_target_list->num_of_targets - 1); m++)
  {
    for (uint8_t n = 0; n < (algo_result->p_target_list->num_of_targets - m - 1); n++)
 802be0c:	9b07      	ldr	r3, [sp, #28]
 802be0e:	429e      	cmp	r6, r3
 802be10:	d3ce      	bcc.n	802bdb0 <range_doppler_do+0x7b8>
  
  if(algo_result->p_target_list->num_of_targets < 2)
    return; // nothing to sort
  
  /* Sorting of the targets header */
  for (uint8_t m = 0; m < (algo_result->p_target_list->num_of_targets - 1); m++)
 802be12:	9b08      	ldr	r3, [sp, #32]
 802be14:	9a09      	ldr	r2, [sp, #36]	; 0x24
 802be16:	3301      	adds	r3, #1
 802be18:	b2db      	uxtb	r3, r3
 802be1a:	4293      	cmp	r3, r2
 802be1c:	9308      	str	r3, [sp, #32]
 802be1e:	469b      	mov	fp, r3
 802be20:	d3bf      	bcc.n	802bda2 <range_doppler_do+0x7aa>
  }
  else
  {
    target_sorting(p_algo_result);
  }
  p_algo_result->range_detection_threshold = range_detection_threshold;
 802be22:	9b18      	ldr	r3, [sp, #96]	; 0x60
 802be24:	ed83 8a00 	vstr	s16, [r3]
  
}
 802be28:	b02d      	add	sp, #180	; 0xb4
 802be2a:	ecbd 8b08 	vpop	{d8-d11}
 802be2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      range_fft_spectrum_hist[i] = alpha_mti * range_fft_spectrum_temp[i] + beta_mti * range_fft_spectrum_hist[i];
    }
  }
  else
  {
    memset(range_fft_spectrum_hist, 0, RANGE_FFT_SIZE/2 * sizeof(float));
 802be32:	2100      	movs	r1, #0
 802be34:	f44f 7200 	mov.w	r2, #512	; 0x200
 802be38:	4847      	ldr	r0, [pc, #284]	; (802bf58 <range_doppler_do+0x960>)
 802be3a:	f002 fec0 	bl	802ebbe <memset>
 802be3e:	e5bf      	b.n	802b9c0 <range_doppler_do+0x3c8>
      else
      {
        p_targets->elems[j].speed = 0;
      }
      
      if (cp_algo_settings->tracking_enable == 1U)
 802be40:	68f0      	ldr	r0, [r6, #12]
        if2_real = doppler_fft_signal_rx2[2*idx_max];
        if2_imag = doppler_fft_signal_rx2[2*idx_max + 1];
      }
      else
      {
        p_targets->elems[j].speed = 0;
 802be42:	ed88 ba06 	vstr	s22, [r8, #24]
      }
      
      if (cp_algo_settings->tracking_enable == 1U)
 802be46:	2801      	cmp	r0, #1
 802be48:	9920      	ldr	r1, [sp, #128]	; 0x80
 802be4a:	9a22      	ldr	r2, [sp, #136]	; 0x88
 802be4c:	9b21      	ldr	r3, [sp, #132]	; 0x84
 802be4e:	9f23      	ldr	r7, [sp, #140]	; 0x8c
        if2_real = doppler_fft_signal_rx2[2*idx_max];
        if2_imag = doppler_fft_signal_rx2[2*idx_max + 1];
      }
      else
      {
        p_targets->elems[j].speed = 0;
 802be50:	eddf 7a42 	vldr	s15, [pc, #264]	; 802bf5c <range_doppler_do+0x964>
      }
      
      if (cp_algo_settings->tracking_enable == 1U)
 802be54:	f43f af76 	beq.w	802bd44 <range_doppler_do+0x74c>
      {
        target_angle_data T;
        
        float wave_length_ant_spacing_ratio = (BSP_TGT_WAVE_LENGTH_MM / BSP_TGT_ANTENNA_SPACING_MM);
        
        T= compute_angle(if1_real, if1_imag, if2_real, if2_imag, IGNORE_NAN, cp_algo_settings->angle_offset_deg, wave_length_ant_spacing_ratio);
 802be58:	f9b6 0028 	ldrsh.w	r0, [r6, #40]	; 0x28
 802be5c:	9004      	str	r0, [sp, #16]
 802be5e:	9700      	str	r7, [sp, #0]
 802be60:	ed8d 9b02 	vstr	d9, [sp, #8]
 802be64:	edcd aa05 	vstr	s21, [sp, #20]
 802be68:	a826      	add	r0, sp, #152	; 0x98
 802be6a:	f7fd fa91 	bl	8029390 <compute_angle>
        
        p_targets->elems[j].angle = T.target_angle;
 802be6e:	9b28      	ldr	r3, [sp, #160]	; 0xa0
 802be70:	f8c8 301c 	str.w	r3, [r8, #28]
 802be74:	e778      	b.n	802bd68 <range_doppler_do+0x770>
        {
          p_targets->elems[j].speed = (float) ((int32_t)idx_max * -Fd_per_bin) * (float)Hz_2_MPS;
        }
        else // target approching
        {
          p_targets->elems[j].speed = (float)((DOPPLER_FFT_SIZE - 1 - idx_max) * Fd_per_bin) * (float)Hz_2_MPS;
 802be76:	f1c3 023f 	rsb	r2, r3, #63	; 0x3f
 802be7a:	ee07 2a90 	vmov	s15, r2
 802be7e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 802be82:	ee67 7aa8 	vmul.f32	s15, s15, s17
 802be86:	ee67 7a8a 	vmul.f32	s15, s15, s20
 802be8a:	e715      	b.n	802bcb8 <range_doppler_do+0x6c0>

//==========================================================================

static void update_tracking_list(tracking_list_t* p_tracking_list, Measurement_elem_t* measurement_ptr, const algo_settings_t *cp_algo_Settings, uint32_t num_of_targets, uint32_t frame_period_usec, uint32_t num_of_chirps)
{
  data_association(p_tracking_list, measurement_ptr, num_of_targets, cp_algo_Settings, frame_period_usec, num_of_chirps);
 802be8c:	981a      	ldr	r0, [sp, #104]	; 0x68
 802be8e:	4c34      	ldr	r4, [pc, #208]	; (802bf60 <range_doppler_do+0x968>)
 802be90:	9d16      	ldr	r5, [sp, #88]	; 0x58
 802be92:	6a81      	ldr	r1, [r0, #40]	; 0x28
 802be94:	6943      	ldr	r3, [r0, #20]
 802be96:	9301      	str	r3, [sp, #4]
 802be98:	9100      	str	r1, [sp, #0]
 802be9a:	b292      	uxth	r2, r2
 802be9c:	462b      	mov	r3, r5
 802be9e:	4620      	mov	r0, r4
 802bea0:	4930      	ldr	r1, [pc, #192]	; (802bf64 <range_doppler_do+0x96c>)
 802bea2:	f000 f911 	bl	802c0c8 <data_association>

//==========================================================================

static void update_target_list_from_tracks(algo_target_list_t *p_targets, tracking_list_t *p_tracks, uint32_t reduced_num_of_tracks)
{
  if (p_tracks->num_of_tracks > CURRENT_NUM_OF_TRACKS )
 802bea6:	6823      	ldr	r3, [r4, #0]
  
  p_algo_result->p_target_list->mode = target_mode;
  if (cp_algo_settings->tracking_enable == 1U)
  {
    update_tracking_list(&s_tracking_list, target_measurements, cp_algo_settings, p_targets->num_of_targets, cp_dev_settings->frame_period_usec, cp_dev_settings->pll_num_of_chirps_per_frame );
    update_target_list_from_tracks(p_algo_result->p_target_list, &s_tracking_list, cp_algo_settings->num_of_tracks);
 802bea8:	9a18      	ldr	r2, [sp, #96]	; 0x60
    p_tracks->num_of_tracks = CURRENT_NUM_OF_TRACKS;
  }
  
  p_targets->num_of_targets = 0;
  
  for (uint8_t i = 0; i < p_tracks->max_num_of_tracks; i++)
 802beaa:	f8d4 e004 	ldr.w	lr, [r4, #4]
  
  p_algo_result->p_target_list->mode = target_mode;
  if (cp_algo_settings->tracking_enable == 1U)
  {
    update_tracking_list(&s_tracking_list, target_measurements, cp_algo_settings, p_targets->num_of_targets, cp_dev_settings->frame_period_usec, cp_dev_settings->pll_num_of_chirps_per_frame );
    update_target_list_from_tracks(p_algo_result->p_target_list, &s_tracking_list, cp_algo_settings->num_of_tracks);
 802beae:	6856      	ldr	r6, [r2, #4]
 802beb0:	f8d5 8010 	ldr.w	r8, [r5, #16]

//==========================================================================

static void update_target_list_from_tracks(algo_target_list_t *p_targets, tracking_list_t *p_tracks, uint32_t reduced_num_of_tracks)
{
  if (p_tracks->num_of_tracks > CURRENT_NUM_OF_TRACKS )
 802beb4:	2b05      	cmp	r3, #5
  {
    p_tracks->num_of_tracks = CURRENT_NUM_OF_TRACKS;
 802beb6:	bf84      	itt	hi
 802beb8:	2305      	movhi	r3, #5
 802beba:	6023      	strhi	r3, [r4, #0]
  }
  
  p_targets->num_of_targets = 0;
 802bebc:	2300      	movs	r3, #0
 802bebe:	6033      	str	r3, [r6, #0]
  
  for (uint8_t i = 0; i < p_tracks->max_num_of_tracks; i++)
  {
    p_targets->elems[i].idx = 0;
 802bec0:	469c      	mov	ip, r3
    p_tracks->num_of_tracks = CURRENT_NUM_OF_TRACKS;
  }
  
  p_targets->num_of_targets = 0;
  
  for (uint8_t i = 0; i < p_tracks->max_num_of_tracks; i++)
 802bec2:	f1be 0f00 	cmp.w	lr, #0
 802bec6:	d102      	bne.n	802bece <range_doppler_do+0x8d6>
 802bec8:	e02e      	b.n	802bf28 <range_doppler_do+0x930>
 802beca:	459e      	cmp	lr, r3
 802becc:	d92c      	bls.n	802bf28 <range_doppler_do+0x930>
  {
    p_targets->elems[i].idx = 0;
 802bece:	eb03 0583 	add.w	r5, r3, r3, lsl #2
 802bed2:	eb06 0585 	add.w	r5, r6, r5, lsl #2
    
    if (p_tracks->elems[i].is_alived == 1 && p_tracks->elems[i].measurement_counter > 2 &&
 802bed6:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
 802beda:	eb04 1242 	add.w	r2, r4, r2, lsl #5
  
  p_targets->num_of_targets = 0;
  
  for (uint8_t i = 0; i < p_tracks->max_num_of_tracks; i++)
  {
    p_targets->elems[i].idx = 0;
 802bede:	f105 0708 	add.w	r7, r5, #8
    
    if (p_tracks->elems[i].is_alived == 1 && p_tracks->elems[i].measurement_counter > 2 &&
 802bee2:	f102 0108 	add.w	r1, r2, #8
  
  p_targets->num_of_targets = 0;
  
  for (uint8_t i = 0; i < p_tracks->max_num_of_tracks; i++)
  {
    p_targets->elems[i].idx = 0;
 802bee6:	f8c7 c004 	str.w	ip, [r7, #4]
    
    if (p_tracks->elems[i].is_alived == 1 && p_tracks->elems[i].measurement_counter > 2 &&
 802beea:	7848      	ldrb	r0, [r1, #1]
    p_tracks->num_of_tracks = CURRENT_NUM_OF_TRACKS;
  }
  
  p_targets->num_of_targets = 0;
  
  for (uint8_t i = 0; i < p_tracks->max_num_of_tracks; i++)
 802beec:	3301      	adds	r3, #1
  {
    p_targets->elems[i].idx = 0;
    
    if (p_tracks->elems[i].is_alived == 1 && p_tracks->elems[i].measurement_counter > 2 &&
 802beee:	2801      	cmp	r0, #1
    p_tracks->num_of_tracks = CURRENT_NUM_OF_TRACKS;
  }
  
  p_targets->num_of_targets = 0;
  
  for (uint8_t i = 0; i < p_tracks->max_num_of_tracks; i++)
 802bef0:	b2db      	uxtb	r3, r3
  {
    p_targets->elems[i].idx = 0;
    
    if (p_tracks->elems[i].is_alived == 1 && p_tracks->elems[i].measurement_counter > 2 &&
 802bef2:	d1ea      	bne.n	802beca <range_doppler_do+0x8d2>
 802bef4:	6910      	ldr	r0, [r2, #16]
 802bef6:	2802      	cmp	r0, #2
 802bef8:	d9e7      	bls.n	802beca <range_doppler_do+0x8d2>
 802befa:	8889      	ldrh	r1, [r1, #4]
 802befc:	2900      	cmp	r1, #0
 802befe:	d0e4      	beq.n	802beca <range_doppler_do+0x8d2>
        p_tracks->elems[i].range_change_flag > 0)
    {
      p_targets->elems[i].idx           = (uint32_t)(p_tracks->elems[i].track_id + 1);
 802bf00:	7a11      	ldrb	r1, [r2, #8]
      p_targets->elems[i].strength      = p_tracks->elems[i].strength;
      p_targets->elems[i].range         = p_tracks->elems[i].range;
      p_targets->elems[i].speed         = p_tracks->elems[i].speed;
      p_targets->elems[i].angle         = p_tracks->elems[i].angle;
      
      p_targets->num_of_targets         += 1;
 802bf02:	6830      	ldr	r0, [r6, #0]
    
    if (p_tracks->elems[i].is_alived == 1 && p_tracks->elems[i].measurement_counter > 2 &&
        p_tracks->elems[i].range_change_flag > 0)
    {
      p_targets->elems[i].idx           = (uint32_t)(p_tracks->elems[i].track_id + 1);
      p_targets->elems[i].strength      = p_tracks->elems[i].strength;
 802bf04:	f8d2 b014 	ldr.w	fp, [r2, #20]
      p_targets->elems[i].range         = p_tracks->elems[i].range;
 802bf08:	f8d2 a018 	ldr.w	sl, [r2, #24]
    
    if (p_tracks->elems[i].is_alived == 1 && p_tracks->elems[i].measurement_counter > 2 &&
        p_tracks->elems[i].range_change_flag > 0)
    {
      p_targets->elems[i].idx           = (uint32_t)(p_tracks->elems[i].track_id + 1);
      p_targets->elems[i].strength      = p_tracks->elems[i].strength;
 802bf0c:	f8c7 b008 	str.w	fp, [r7, #8]
    p_targets->elems[i].idx = 0;
    
    if (p_tracks->elems[i].is_alived == 1 && p_tracks->elems[i].measurement_counter > 2 &&
        p_tracks->elems[i].range_change_flag > 0)
    {
      p_targets->elems[i].idx           = (uint32_t)(p_tracks->elems[i].track_id + 1);
 802bf10:	3101      	adds	r1, #1
      p_targets->elems[i].strength      = p_tracks->elems[i].strength;
      p_targets->elems[i].range         = p_tracks->elems[i].range;
      p_targets->elems[i].speed         = p_tracks->elems[i].speed;
      p_targets->elems[i].angle         = p_tracks->elems[i].angle;
      
      p_targets->num_of_targets         += 1;
 802bf12:	3001      	adds	r0, #1
    p_targets->elems[i].idx = 0;
    
    if (p_tracks->elems[i].is_alived == 1 && p_tracks->elems[i].measurement_counter > 2 &&
        p_tracks->elems[i].range_change_flag > 0)
    {
      p_targets->elems[i].idx           = (uint32_t)(p_tracks->elems[i].track_id + 1);
 802bf14:	6079      	str	r1, [r7, #4]
      p_targets->elems[i].speed         = p_tracks->elems[i].speed;
      p_targets->elems[i].angle         = p_tracks->elems[i].angle;
      
      p_targets->num_of_targets         += 1;
      
      if (p_targets->num_of_targets >= reduced_num_of_tracks)
 802bf16:	4580      	cmp	r8, r0
        p_tracks->elems[i].range_change_flag > 0)
    {
      p_targets->elems[i].idx           = (uint32_t)(p_tracks->elems[i].track_id + 1);
      p_targets->elems[i].strength      = p_tracks->elems[i].strength;
      p_targets->elems[i].range         = p_tracks->elems[i].range;
      p_targets->elems[i].speed         = p_tracks->elems[i].speed;
 802bf18:	69d1      	ldr	r1, [r2, #28]
      p_targets->elems[i].angle         = p_tracks->elems[i].angle;
 802bf1a:	6a12      	ldr	r2, [r2, #32]
 802bf1c:	61ea      	str	r2, [r5, #28]
    if (p_tracks->elems[i].is_alived == 1 && p_tracks->elems[i].measurement_counter > 2 &&
        p_tracks->elems[i].range_change_flag > 0)
    {
      p_targets->elems[i].idx           = (uint32_t)(p_tracks->elems[i].track_id + 1);
      p_targets->elems[i].strength      = p_tracks->elems[i].strength;
      p_targets->elems[i].range         = p_tracks->elems[i].range;
 802bf1e:	f8c5 a014 	str.w	sl, [r5, #20]
      p_targets->elems[i].speed         = p_tracks->elems[i].speed;
 802bf22:	61a9      	str	r1, [r5, #24]
      p_targets->elems[i].angle         = p_tracks->elems[i].angle;
      
      p_targets->num_of_targets         += 1;
 802bf24:	6030      	str	r0, [r6, #0]
      
      if (p_targets->num_of_targets >= reduced_num_of_tracks)
 802bf26:	d8d0      	bhi.n	802beca <range_doppler_do+0x8d2>
  if (cp_algo_settings->tracking_enable == 1U)
  {
    update_tracking_list(&s_tracking_list, target_measurements, cp_algo_settings, p_targets->num_of_targets, cp_dev_settings->frame_period_usec, cp_dev_settings->pll_num_of_chirps_per_frame );
    update_target_list_from_tracks(p_algo_result->p_target_list, &s_tracking_list, cp_algo_settings->num_of_tracks);
    
    p_algo_result->p_target_list->mode = tracking_mode;
 802bf28:	2302      	movs	r3, #2
 802bf2a:	7233      	strb	r3, [r6, #8]
 802bf2c:	e779      	b.n	802be22 <range_doppler_do+0x82a>
      if ((target_range >= p_algo_settings->min_distance_cm) && (target_range <= p_algo_settings->max_distance_cm))
      {
        float fp_new;
        
        if(peak_idx > fp_bin)
          fp_new = fp +(fr - fp) * (peak_idx - fp_bin) / (fr_bin - fp_bin);
 802bf2e:	ee34 4a45 	vsub.f32	s8, s8, s10
 802bf32:	ee77 7a67 	vsub.f32	s15, s14, s15
 802bf36:	eea4 5a27 	vfma.f32	s10, s8, s15
 802bf3a:	e5da      	b.n	802baf2 <range_doppler_do+0x4fa>
 802bf3c:	461c      	mov	r4, r3
 802bf3e:	4b0a      	ldr	r3, [pc, #40]	; (802bf68 <range_doppler_do+0x970>)
 802bf40:	9319      	str	r3, [sp, #100]	; 0x64
 802bf42:	e4d4      	b.n	802b8ee <range_doppler_do+0x2f6>
  
  memset(&p_targets->elems[0], 0, sizeof(p_targets->elems)); // clear target data
  
  memset(&target_measurements[0], 0, sizeof(target_measurements));
  
  p_targets->num_of_targets = target_detection(cp_algo_settings, range_fft_spectrum, &p_targets->elems[0], peak_search_max_idx, range_detection_threshold);
 802bf44:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 802bf46:	f8c3 8000 	str.w	r8, [r3]
  
  //=========== (5) Slow FFT on Rx1 & Rx2 ====================================
  
  if ((p_targets->num_of_targets > 0) && (Nc > 1))
 802bf4a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 802bf4c:	2b01      	cmp	r3, #1
  
  memset(&p_targets->elems[0], 0, sizeof(p_targets->elems)); // clear target data
  
  memset(&target_measurements[0], 0, sizeof(target_measurements));
  
  p_targets->num_of_targets = target_detection(cp_algo_settings, range_fft_spectrum, &p_targets->elems[0], peak_search_max_idx, range_detection_threshold);
 802bf4e:	4642      	mov	r2, r8
  
  //=========== (5) Slow FFT on Rx1 & Rx2 ====================================
  
  if ((p_targets->num_of_targets > 0) && (Nc > 1))
 802bf50:	f63f adfe 	bhi.w	802bb50 <range_doppler_do+0x558>
 802bf54:	e713      	b.n	802bd7e <range_doppler_do+0x786>
 802bf56:	bf00      	nop
 802bf58:	20003aec 	.word	0x20003aec
 802bf5c:	00000000 	.word	0x00000000
 802bf60:	1ffe9098 	.word	0x1ffe9098
 802bf64:	20003948 	.word	0x20003948
 802bf68:	1fff2b44 	.word	0x1fff2b44
 802bf6c:	f3af 8000 	nop.w

0802bf70 <compare_float>:

static int compare_float(const void *a, const void *b)
{
	int retval = 0;

	float a_f = *(float*)a;
 802bf70:	ed90 7a00 	vldr	s14, [r0]
	float b_f = *(float*)b;
 802bf74:	edd1 7a00 	vldr	s15, [r1]

	if (a_f > b_f)
 802bf78:	eeb4 7ae7 	vcmpe.f32	s14, s15
 802bf7c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802bf80:	dc04      	bgt.n	802bf8c <compare_float+0x1c>
	{
		retval = 1;
	}
	else if (a_f < b_f)
 802bf82:	bf4c      	ite	mi
 802bf84:	f04f 30ff 	movmi.w	r0, #4294967295
 802bf88:	2000      	movpl	r0, #0
 802bf8a:	4770      	bx	lr
	float a_f = *(float*)a;
	float b_f = *(float*)b;

	if (a_f > b_f)
	{
		retval = 1;
 802bf8c:	2001      	movs	r0, #1
	{
		retval = -1;
	}

	return retval;
}
 802bf8e:	4770      	bx	lr

0802bf90 <assign_track>:
}

//===========================================================================

static uint32_t assign_track(tracking_list_t *p_tracks, Measurement_elem_t* target_measurement, uint8_t id, uint16_t angle_offset_deg, float wave_length_ant_spacing_ratio, float min_angle)
{
 802bf90:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 802bf94:	ed2d 8b02 	vpush	{d8}
 802bf98:	460d      	mov	r5, r1
 802bf9a:	b08b      	sub	sp, #44	; 0x2c

	uint32_t retValue = 0;

	target_angle_data T;
	T = compute_angle(target_measurement->rx1_angle_arg_re, target_measurement->rx1_angle_arg_im,
 802bf9c:	f8d5 c014 	ldr.w	ip, [r5, #20]
 802bfa0:	f8d5 e018 	ldr.w	lr, [r5, #24]
 802bfa4:	f8df 9118 	ldr.w	r9, [pc, #280]	; 802c0c0 <assign_track+0x130>
 802bfa8:	69ef      	ldr	r7, [r5, #28]
 802bfaa:	6909      	ldr	r1, [r1, #16]
 802bfac:	ed8d 0a05 	vstr	s0, [sp, #20]
 802bfb0:	b21b      	sxth	r3, r3
 802bfb2:	f04f 0800 	mov.w	r8, #0
 802bfb6:	9304      	str	r3, [sp, #16]
}

//===========================================================================

static uint32_t assign_track(tracking_list_t *p_tracks, Measurement_elem_t* target_measurement, uint8_t id, uint16_t angle_offset_deg, float wave_length_ant_spacing_ratio, float min_angle)
{
 802bfb8:	4606      	mov	r6, r0
 802bfba:	4614      	mov	r4, r2

	uint32_t retValue = 0;

	target_angle_data T;
	T = compute_angle(target_measurement->rx1_angle_arg_re, target_measurement->rx1_angle_arg_im,
 802bfbc:	4673      	mov	r3, lr
 802bfbe:	4662      	mov	r2, ip
 802bfc0:	9700      	str	r7, [sp, #0]
 802bfc2:	e9cd 8902 	strd	r8, r9, [sp, #8]
 802bfc6:	a806      	add	r0, sp, #24
}

//===========================================================================

static uint32_t assign_track(tracking_list_t *p_tracks, Measurement_elem_t* target_measurement, uint8_t id, uint16_t angle_offset_deg, float wave_length_ant_spacing_ratio, float min_angle)
{
 802bfc8:	eeb0 8a60 	vmov.f32	s16, s1

	uint32_t retValue = 0;

	target_angle_data T;
	T = compute_angle(target_measurement->rx1_angle_arg_re, target_measurement->rx1_angle_arg_im,
 802bfcc:	f7fd f9e0 	bl	8029390 <compute_angle>
 802bfd0:	eddd 7a08 	vldr	s15, [sp, #32]
			target_measurement->rx2_angle_arg_re, target_measurement->rx2_angle_arg_im, IGNORE_NAN, angle_offset_deg, wave_length_ant_spacing_ratio);

	if( fabs(T.target_angle) < min_angle)
 802bfd4:	eeb0 7ae7 	vabs.f32	s14, s15
 802bfd8:	eeb4 7ac8 	vcmpe.f32	s14, s16
 802bfdc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802bfe0:	d416      	bmi.n	802c010 <assign_track+0x80>

//===========================================================================

static void clear_track_elem(Tracking_Params_t* track_ptr)
{
	memset(track_ptr, 0, sizeof(Tracking_Params_t));
 802bfe2:	eb04 00c4 	add.w	r0, r4, r4, lsl #3
 802bfe6:	eb06 1040 	add.w	r0, r6, r0, lsl #5
 802bfea:	2100      	movs	r1, #0
 802bfec:	f44f 7290 	mov.w	r2, #288	; 0x120
 802bff0:	3008      	adds	r0, #8
	track_ptr->d_phi = IGNORE_NAN;
 802bff2:	3401      	adds	r4, #1

//===========================================================================

static void clear_track_elem(Tracking_Params_t* track_ptr)
{
	memset(track_ptr, 0, sizeof(Tracking_Params_t));
 802bff4:	f002 fde3 	bl	802ebbe <memset>
	track_ptr->d_phi = IGNORE_NAN;
 802bff8:	eb04 04c4 	add.w	r4, r4, r4, lsl #3
 802bffc:	4b2f      	ldr	r3, [pc, #188]	; (802c0bc <assign_track+0x12c>)
 802bffe:	eb06 1444 	add.w	r4, r6, r4, lsl #5
		retValue = 1;
	}
	else
	{
		clear_track_elem(&p_tracks->elems[id]);
		retValue = 0;
 802c002:	2000      	movs	r0, #0
//===========================================================================

static void clear_track_elem(Tracking_Params_t* track_ptr)
{
	memset(track_ptr, 0, sizeof(Tracking_Params_t));
	track_ptr->d_phi = IGNORE_NAN;
 802c004:	6063      	str	r3, [r4, #4]
		clear_track_elem(&p_tracks->elems[id]);
		retValue = 0;
	}

	return retValue;
}
 802c006:	b00b      	add	sp, #44	; 0x2c
 802c008:	ecbd 8b02 	vpop	{d8}
 802c00c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if( fabs(T.target_angle) < min_angle)
	{

		Tracking_Params_t *p_track = &p_tracks->elems[id];

		p_track->track_id = id;
 802c010:	eb04 07c4 	add.w	r7, r4, r4, lsl #3
 802c014:	eb06 1747 	add.w	r7, r6, r7, lsl #5
		p_track->is_alived = 1;
 802c018:	2301      	movs	r3, #1
	if( fabs(T.target_angle) < min_angle)
	{

		Tracking_Params_t *p_track = &p_tracks->elems[id];

		p_track->track_id = id;
 802c01a:	723c      	strb	r4, [r7, #8]
		p_track->is_alived = 1;
 802c01c:	727b      	strb	r3, [r7, #9]

		p_track->measurement_counter = 1;
 802c01e:	613b      	str	r3, [r7, #16]

		p_track->range_change_flag = 1;
 802c020:	81bb      	strh	r3, [r7, #12]
		p_track->speed_count = 1;
 802c022:	817b      	strh	r3, [r7, #10]

		p_track->strength = target_measurement->strength;
 802c024:	686b      	ldr	r3, [r5, #4]
 802c026:	617b      	str	r3, [r7, #20]
		p_track->range    = target_measurement->range;
 802c028:	68ab      	ldr	r3, [r5, #8]
 802c02a:	61bb      	str	r3, [r7, #24]
		p_track->speed    = target_measurement->speed;
 802c02c:	68eb      	ldr	r3, [r5, #12]
 802c02e:	61fb      	str	r3, [r7, #28]

		p_track->rx1_angle_arg_re[0] = target_measurement->rx1_angle_arg_re;
 802c030:	692b      	ldr	r3, [r5, #16]
 802c032:	627b      	str	r3, [r7, #36]	; 0x24
		p_track->rx1_angle_arg_im[0] = target_measurement->rx1_angle_arg_im;
 802c034:	696b      	ldr	r3, [r5, #20]
 802c036:	667b      	str	r3, [r7, #100]	; 0x64
		p_track->rx2_angle_arg_re[0] = target_measurement->rx2_angle_arg_re;
 802c038:	69ab      	ldr	r3, [r5, #24]
 802c03a:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
		p_track->rx2_angle_arg_im[0] = target_measurement->rx2_angle_arg_im;
 802c03e:	69ea      	ldr	r2, [r5, #28]
 802c040:	f8c7 20e4 	str.w	r2, [r7, #228]	; 0xe4

		p_track->angle  = T.target_angle;
		p_track->d_phi  = T.d_phi;
 802c044:	1c63      	adds	r3, r4, #1
 802c046:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 802c04a:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
		p_track->rx1_angle_arg_re[0] = target_measurement->rx1_angle_arg_re;
		p_track->rx1_angle_arg_im[0] = target_measurement->rx1_angle_arg_im;
		p_track->rx2_angle_arg_re[0] = target_measurement->rx2_angle_arg_re;
		p_track->rx2_angle_arg_im[0] = target_measurement->rx2_angle_arg_im;

		p_track->angle  = T.target_angle;
 802c04e:	edc7 7a08 	vstr	s15, [r7, #32]
		p_track->d_phi  = T.d_phi;
 802c052:	eb06 1843 	add.w	r8, r6, r3, lsl #5
 802c056:	f002 fa39 	bl	802e4cc <__aeabi_d2f>

		// calculate the medium filter for the track angle
		median_angle_arr[id].is_full = 0;
 802c05a:	ea4f 1c04 	mov.w	ip, r4, lsl #4
 802c05e:	f8df e064 	ldr.w	lr, [pc, #100]	; 802c0c4 <assign_track+0x134>
		p_track->rx1_angle_arg_im[0] = target_measurement->rx1_angle_arg_im;
		p_track->rx2_angle_arg_re[0] = target_measurement->rx2_angle_arg_re;
		p_track->rx2_angle_arg_im[0] = target_measurement->rx2_angle_arg_im;

		p_track->angle  = T.target_angle;
		p_track->d_phi  = T.d_phi;
 802c062:	f8c8 0004 	str.w	r0, [r8, #4]

		// calculate the medium filter for the track angle
		median_angle_arr[id].is_full = 0;
 802c066:	ebc4 030c 	rsb	r3, r4, ip
 802c06a:	009b      	lsls	r3, r3, #2
 802c06c:	eb0e 0203 	add.w	r2, lr, r3
 802c070:	2000      	movs	r0, #0
//===========================================================================

float median_filtering(Median_Filtering_t *track_median_arr, float new_input)
{

	if( track_median_arr->median_filter_len > MAX_MEDIAN_FILTER_LEN)
 802c072:	6851      	ldr	r1, [r2, #4]

		p_track->angle  = T.target_angle;
		p_track->d_phi  = T.d_phi;

		// calculate the medium filter for the track angle
		median_angle_arr[id].is_full = 0;
 802c074:	f80e 0003 	strb.w	r0, [lr, r3]
//===========================================================================

float median_filtering(Median_Filtering_t *track_median_arr, float new_input)
{

	if( track_median_arr->median_filter_len > MAX_MEDIAN_FILTER_LEN)
 802c078:	290d      	cmp	r1, #13
		p_track->angle  = T.target_angle;
		p_track->d_phi  = T.d_phi;

		// calculate the medium filter for the track angle
		median_angle_arr[id].is_full = 0;
		median_filtering(&median_angle_arr[id], p_track->angle);
 802c07a:	6a38      	ldr	r0, [r7, #32]
//===========================================================================

float median_filtering(Median_Filtering_t *track_median_arr, float new_input)
{

	if( track_median_arr->median_filter_len > MAX_MEDIAN_FILTER_LEN)
 802c07c:	d91a      	bls.n	802c0b4 <assign_track+0x124>
		track_median_arr->median_filter_len = MAX_MEDIAN_FILTER_LEN;
 802c07e:	210d      	movs	r1, #13
 802c080:	6051      	str	r1, [r2, #4]
 802c082:	223c      	movs	r2, #60	; 0x3c
 802c084:	fb02 e204 	mla	r2, r2, r4, lr
 802c088:	3208      	adds	r2, #8
 802c08a:	2300      	movs	r3, #0

	if (track_median_arr->is_full == 0)
	{
		for (uint32_t j = 0; j < track_median_arr->median_filter_len; j++)
 802c08c:	3301      	adds	r3, #1
 802c08e:	428b      	cmp	r3, r1
		{
			track_median_arr->buffer[j] = new_input;
 802c090:	f842 0b04 	str.w	r0, [r2], #4
	if( track_median_arr->median_filter_len > MAX_MEDIAN_FILTER_LEN)
		track_median_arr->median_filter_len = MAX_MEDIAN_FILTER_LEN;

	if (track_median_arr->is_full == 0)
	{
		for (uint32_t j = 0; j < track_median_arr->median_filter_len; j++)
 802c094:	d3fa      	bcc.n	802c08c <assign_track+0xfc>
		median_filtering(&median_angle_arr[id], p_track->angle);

		target_measurement->is_associated = 1;

		// Inc the number of valid tracks:
		p_tracks->num_of_tracks += 1;
 802c096:	6833      	ldr	r3, [r6, #0]
		for (uint32_t j = 0; j < track_median_arr->median_filter_len; j++)
		{
			track_median_arr->buffer[j] = new_input;
		}

		track_median_arr->is_full = 1;
 802c098:	2201      	movs	r2, #1
 802c09a:	ebc4 040c 	rsb	r4, r4, ip
		median_filtering(&median_angle_arr[id], p_track->angle);

		target_measurement->is_associated = 1;

		// Inc the number of valid tracks:
		p_tracks->num_of_tracks += 1;
 802c09e:	4413      	add	r3, r2
		retValue = 1;
 802c0a0:	4610      	mov	r0, r2
		for (uint32_t j = 0; j < track_median_arr->median_filter_len; j++)
		{
			track_median_arr->buffer[j] = new_input;
		}

		track_median_arr->is_full = 1;
 802c0a2:	f80e 2024 	strb.w	r2, [lr, r4, lsl #2]

		// calculate the medium filter for the track angle
		median_angle_arr[id].is_full = 0;
		median_filtering(&median_angle_arr[id], p_track->angle);

		target_measurement->is_associated = 1;
 802c0a6:	802a      	strh	r2, [r5, #0]

		// Inc the number of valid tracks:
		p_tracks->num_of_tracks += 1;
 802c0a8:	6033      	str	r3, [r6, #0]
		clear_track_elem(&p_tracks->elems[id]);
		retValue = 0;
	}

	return retValue;
}
 802c0aa:	b00b      	add	sp, #44	; 0x2c
 802c0ac:	ecbd 8b02 	vpop	{d8}
 802c0b0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if( track_median_arr->median_filter_len > MAX_MEDIAN_FILTER_LEN)
		track_median_arr->median_filter_len = MAX_MEDIAN_FILTER_LEN;

	if (track_median_arr->is_full == 0)
	{
		for (uint32_t j = 0; j < track_median_arr->median_filter_len; j++)
 802c0b4:	2900      	cmp	r1, #0
 802c0b6:	d0ee      	beq.n	802c096 <assign_track+0x106>
 802c0b8:	e7e3      	b.n	802c082 <assign_track+0xf2>
 802c0ba:	bf00      	nop
 802c0bc:	440ac000 	.word	0x440ac000
 802c0c0:	40815800 	.word	0x40815800
 802c0c4:	200049f4 	.word	0x200049f4

0802c0c8 <data_association>:

//===========================================================================

void data_association(tracking_list_t *p_tracks, Measurement_elem_t* target_measurements, uint16_t num_of_targets,
		const algo_settings_t *cp_algo_settings, uint32_t frame_period_usec, uint32_t num_of_chirps )
{
 802c0c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802c0cc:	ed2d 8b0c 	vpush	{d8-d13}
	float px_measured = 0;
	float px_min, px_max;
	float curr_neighbor, last_neighbor;

	//========= CASE 1: all tracks are empty ===========
	if(p_tracks->num_of_tracks == 0 && num_of_targets != 0)
 802c0d0:	6805      	ldr	r5, [r0, #0]

//===========================================================================

void data_association(tracking_list_t *p_tracks, Measurement_elem_t* target_measurements, uint16_t num_of_targets,
		const algo_settings_t *cp_algo_settings, uint32_t frame_period_usec, uint32_t num_of_chirps )
{
 802c0d2:	b0a7      	sub	sp, #156	; 0x9c
 802c0d4:	4604      	mov	r4, r0
 802c0d6:	468b      	mov	fp, r1
 802c0d8:	4692      	mov	sl, r2
 802c0da:	9307      	str	r3, [sp, #28]
	float px_measured = 0;
	float px_min, px_max;
	float curr_neighbor, last_neighbor;

	//========= CASE 1: all tracks are empty ===========
	if(p_tracks->num_of_tracks == 0 && num_of_targets != 0)
 802c0dc:	b915      	cbnz	r5, 802c0e4 <data_association+0x1c>
 802c0de:	2a00      	cmp	r2, #0
 802c0e0:	f040 82f2 	bne.w	802c6c8 <data_association+0x600>
	//========= CASE 2: update tracks already assigned ===========
	else
	{
		int8_t tgt_idx;

		for (uint8_t i = 0; i < p_tracks->max_num_of_tracks; i++)
 802c0e4:	6867      	ldr	r7, [r4, #4]
 802c0e6:	2f00      	cmp	r7, #0
 802c0e8:	f000 82a3 	beq.w	802c632 <data_association+0x56a>
			if (p_tracks->elems[i].is_alived == 0)
			{
				continue;
			}

			px_track_predict = p_tracks->elems[i].range - (p_tracks->elems[i].speed * ((frame_period_usec/1000) * 0.1f) );	// range is in cm, thus speed is cm/sec
 802c0ec:	4b54      	ldr	r3, [pc, #336]	; (802c240 <data_association+0x178>)
 802c0ee:	9a3c      	ldr	r2, [sp, #240]	; 0xf0
 802c0f0:	ed9f aa54 	vldr	s20, [pc, #336]	; 802c244 <data_association+0x17c>

			px_max = px_track_predict + DELTA_PX_CM;
 802c0f4:	eddf 8a54 	vldr	s17, [pc, #336]	; 802c248 <data_association+0x180>

			px_min = px_track_predict - DELTA_PX_CM;

			if (px_min < 0)
			{
				px_min = 0;
 802c0f8:	eddf 9a54 	vldr	s19, [pc, #336]	; 802c24c <data_association+0x184>
	track_ptr->range = (1.0f - alpha_range) * track_ptr->range +
			alpha_range * (target_measurement->range * 0.5f + px_track_predict);

	if (track_ptr->range_change_flag == 0)
	{
		if ((track_ptr->range < last_range - 40) || (track_ptr->range > last_range + 40))
 802c0fc:	eddf aa54 	vldr	s21, [pc, #336]	; 802c250 <data_association+0x188>
			if (p_tracks->elems[i].is_alived == 0)
			{
				continue;
			}

			px_track_predict = p_tracks->elems[i].range - (p_tracks->elems[i].speed * ((frame_period_usec/1000) * 0.1f) );	// range is in cm, thus speed is cm/sec
 802c100:	fba3 2302 	umull	r2, r3, r3, r2
 802c104:	099b      	lsrs	r3, r3, #6
 802c106:	ee09 3a10 	vmov	s18, r3
 802c10a:	46a0      	mov	r8, r4
 802c10c:	f04f 0900 	mov.w	r9, #0
 802c110:	4654      	mov	r4, sl
	{
		int8_t tgt_idx;

		for (uint8_t i = 0; i < p_tracks->max_num_of_tracks; i++)
		{
			if (p_tracks->elems[i].is_alived == 0)
 802c112:	ea4f 05c9 	mov.w	r5, r9, lsl #3
 802c116:	eb05 0309 	add.w	r3, r5, r9
 802c11a:	eb08 1343 	add.w	r3, r8, r3, lsl #5
 802c11e:	7a5a      	ldrb	r2, [r3, #9]
 802c120:	2a00      	cmp	r2, #0
 802c122:	f000 820f 	beq.w	802c544 <data_association+0x47c>
			{
				continue;
			}

			px_track_predict = p_tracks->elems[i].range - (p_tracks->elems[i].speed * ((frame_period_usec/1000) * 0.1f) );	// range is in cm, thus speed is cm/sec
 802c126:	eef8 7ac9 	vcvt.f32.s32	s15, s18
 802c12a:	edd3 6a06 	vldr	s13, [r3, #24]
 802c12e:	ed93 7a07 	vldr	s14, [r3, #28]
 802c132:	ee67 7a8a 	vmul.f32	s15, s15, s20
 802c136:	eeb0 6a66 	vmov.f32	s12, s13
 802c13a:	eea7 6a67 	vfms.f32	s12, s14, s15
 802c13e:	eeb0 7a46 	vmov.f32	s14, s12

			px_max = px_track_predict + DELTA_PX_CM;

			px_min = px_track_predict - DELTA_PX_CM;
 802c142:	ee36 6a68 	vsub.f32	s12, s12, s17
				continue;
			}

			px_track_predict = p_tracks->elems[i].range - (p_tracks->elems[i].speed * ((frame_period_usec/1000) * 0.1f) );	// range is in cm, thus speed is cm/sec

			px_max = px_track_predict + DELTA_PX_CM;
 802c146:	ee37 5a28 	vadd.f32	s10, s14, s17

			px_min = px_track_predict - DELTA_PX_CM;

			if (px_min < 0)
			{
				px_min = 0;
 802c14a:	eeb5 6a40 	vcmp.f32	s12, #0.0
 802c14e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c152:	bf48      	it	mi
 802c154:	eeb0 6a69 	vmovmi.f32	s12, s19

			curr_neighbor = 0;

			last_neighbor = 10000;

			for (uint8_t j = 0; j < num_of_targets; j++)
 802c158:	2c00      	cmp	r4, #0
 802c15a:	f000 827d 	beq.w	802c658 <data_association+0x590>
 802c15e:	eddf 4a3d 	vldr	s9, [pc, #244]	; 802c254 <data_association+0x18c>
 802c162:	2200      	movs	r2, #0
 802c164:	20ff      	movs	r0, #255	; 0xff
			{
				if(target_measurements[j].is_associated == 0)
 802c166:	0153      	lsls	r3, r2, #5

			curr_neighbor = 0;

			last_neighbor = 10000;

			for (uint8_t j = 0; j < num_of_targets; j++)
 802c168:	1c51      	adds	r1, r2, #1
			{
				if(target_measurements[j].is_associated == 0)
 802c16a:	f83b 6003 	ldrh.w	r6, [fp, r3]
 802c16e:	445b      	add	r3, fp
 802c170:	b9be      	cbnz	r6, 802c1a2 <data_association+0xda>
				{
					px_measured = target_measurements[j].range;
 802c172:	edd3 7a02 	vldr	s15, [r3, #8]

					if((px_min <= px_measured) && (px_measured <= px_max))
 802c176:	eeb4 6ae7 	vcmpe.f32	s12, s15
 802c17a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c17e:	d810      	bhi.n	802c1a2 <data_association+0xda>
 802c180:	eeb4 5ae7 	vcmpe.f32	s10, s15
 802c184:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c188:	db0b      	blt.n	802c1a2 <data_association+0xda>
					{
						curr_neighbor = fabsf(px_measured - px_track_predict);
 802c18a:	ee77 5ac7 	vsub.f32	s11, s15, s14
 802c18e:	eef0 5ae5 	vabs.f32	s11, s11

						if (curr_neighbor < last_neighbor)
 802c192:	eef4 5ae4 	vcmpe.f32	s11, s9
 802c196:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
						{
							last_neighbor = px_measured;
 802c19a:	bf44      	itt	mi
 802c19c:	eef0 4a67 	vmovmi.f32	s9, s15

							tgt_idx = j;
 802c1a0:	b2d0      	uxtbmi	r0, r2

			curr_neighbor = 0;

			last_neighbor = 10000;

			for (uint8_t j = 0; j < num_of_targets; j++)
 802c1a2:	b2ca      	uxtb	r2, r1
 802c1a4:	4294      	cmp	r4, r2
 802c1a6:	d8de      	bhi.n	802c166 <data_association+0x9e>
						}
					}
				}
			}

			if (tgt_idx == -1)
 802c1a8:	b240      	sxtb	r0, r0
 802c1aa:	1c43      	adds	r3, r0, #1
 802c1ac:	f000 8254 	beq.w	802c658 <data_association+0x590>

				p_tracks->elems[i].range = 0.5 * (p_tracks->elems[i].range + px_track_predict);
			}
			else
			{
				p_tracks->elems[i].lifetime_counter /= 2;
 802c1b0:	eb05 0309 	add.w	r3, r5, r9
 802c1b4:	eb08 1343 	add.w	r3, r8, r3, lsl #5

				p_tracks->elems[i].measurement_counter += 1;

				update_track(&p_tracks->elems[i], &target_measurements[tgt_idx], i, px_track_predict * 0.5,
 802c1b8:	0142      	lsls	r2, r0, #5
 802c1ba:	9e07      	ldr	r6, [sp, #28]

				p_tracks->elems[i].range = 0.5 * (p_tracks->elems[i].range + px_track_predict);
			}
			else
			{
				p_tracks->elems[i].lifetime_counter /= 2;
 802c1bc:	89d9      	ldrh	r1, [r3, #14]

				p_tracks->elems[i].measurement_counter += 1;

				update_track(&p_tracks->elems[i], &target_measurements[tgt_idx], i, px_track_predict * 0.5,
 802c1be:	9208      	str	r2, [sp, #32]
 802c1c0:	eb0b 0a02 	add.w	sl, fp, r2

	uint32_t idx;

	float alpha_range ;

	if (fabs(target_measurement->speed) <= 0.3)
 802c1c4:	edda ba03 	vldr	s23, [sl, #12]
			}
			else
			{
				p_tracks->elems[i].lifetime_counter /= 2;

				p_tracks->elems[i].measurement_counter += 1;
 802c1c8:	691a      	ldr	r2, [r3, #16]

				update_track(&p_tracks->elems[i], &target_measurements[tgt_idx], i, px_track_predict * 0.5,
 802c1ca:	f8b6 e028 	ldrh.w	lr, [r6, #40]	; 0x28
 802c1ce:	ed96 ba0d 	vldr	s22, [r6, #52]	; 0x34
 802c1d2:	9e07      	ldr	r6, [sp, #28]
static void update_track(Tracking_Params_t* track_ptr, Measurement_elem_t* target_measurement, uint8_t track_id,
		float px_track_predict, float range_detection_threshold, int16_t angle_offset_deg, uint32_t num_of_chirps,
		float wave_length_ant_spacing_ratio)
{

	float last_range = track_ptr->range;
 802c1d4:	ed93 ca06 	vldr	s24, [r3, #24]
			{
				p_tracks->elems[i].lifetime_counter /= 2;

				p_tracks->elems[i].measurement_counter += 1;

				update_track(&p_tracks->elems[i], &target_measurements[tgt_idx], i, px_track_predict * 0.5,
 802c1d8:	edd6 ca11 	vldr	s25, [r6, #68]	; 0x44
 802c1dc:	f8cd e024 	str.w	lr, [sp, #36]	; 0x24
			}
			else
			{
				p_tracks->elems[i].lifetime_counter /= 2;

				p_tracks->elems[i].measurement_counter += 1;
 802c1e0:	3201      	adds	r2, #1

				p_tracks->elems[i].range = 0.5 * (p_tracks->elems[i].range + px_track_predict);
			}
			else
			{
				p_tracks->elems[i].lifetime_counter /= 2;
 802c1e2:	0849      	lsrs	r1, r1, #1

	uint32_t idx;

	float alpha_range ;

	if (fabs(target_measurement->speed) <= 0.3)
 802c1e4:	eef0 daeb 	vabs.f32	s27, s23

				p_tracks->elems[i].range = 0.5 * (p_tracks->elems[i].range + px_track_predict);
			}
			else
			{
				p_tracks->elems[i].lifetime_counter /= 2;
 802c1e8:	81d9      	strh	r1, [r3, #14]

				p_tracks->elems[i].measurement_counter += 1;
 802c1ea:	611a      	str	r2, [r3, #16]

	uint32_t idx;

	float alpha_range ;

	if (fabs(target_measurement->speed) <= 0.3)
 802c1ec:	ee1d 0a90 	vmov	r0, s27
			{
				p_tracks->elems[i].lifetime_counter /= 2;

				p_tracks->elems[i].measurement_counter += 1;

				update_track(&p_tracks->elems[i], &target_measurements[tgt_idx], i, px_track_predict * 0.5,
 802c1f0:	eeb6 da00 	vmov.f32	s26, #96	; 0x60
 802c1f4:	ee27 8a0d 	vmul.f32	s16, s14, s26

	uint32_t idx;

	float alpha_range ;

	if (fabs(target_measurement->speed) <= 0.3)
 802c1f8:	f001 fe32 	bl	802de60 <__aeabi_f2d>
 802c1fc:	a30e      	add	r3, pc, #56	; (adr r3, 802c238 <data_association+0x170>)
 802c1fe:	e9d3 2300 	ldrd	r2, r3, [r3]
			{
				p_tracks->elems[i].lifetime_counter /= 2;

				p_tracks->elems[i].measurement_counter += 1;

				update_track(&p_tracks->elems[i], &target_measurements[tgt_idx], i, px_track_predict * 0.5,
 802c202:	eeb8 ba4b 	vcvt.f32.u32	s22, s22

	uint32_t idx;

	float alpha_range ;

	if (fabs(target_measurement->speed) <= 0.3)
 802c206:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
 802c20a:	f002 f8f9 	bl	802e400 <__aeabi_dcmple>
 802c20e:	2800      	cmp	r0, #0
 802c210:	f040 8238 	bne.w	802c684 <data_association+0x5bc>
	{
		alpha_range = 0.25;
	}
	else if (fabs(target_measurement->speed) > 0.3 && fabs(target_measurement->speed) < 0.5)
 802c214:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 802c218:	a307      	add	r3, pc, #28	; (adr r3, 802c238 <data_association+0x170>)
 802c21a:	e9d3 2300 	ldrd	r2, r3, [r3]
 802c21e:	f002 f903 	bl	802e428 <__aeabi_dcmpgt>
 802c222:	b1f8      	cbz	r0, 802c264 <data_association+0x19c>
 802c224:	eef4 dacd 	vcmpe.f32	s27, s26
 802c228:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c22c:	d51a      	bpl.n	802c264 <data_association+0x19c>
	{
		alpha_range = 0.50;
 802c22e:	eef0 7a4d 	vmov.f32	s15, s26
 802c232:	e033      	b.n	802c29c <data_association+0x1d4>
 802c234:	f3af 8000 	nop.w
 802c238:	33333333 	.word	0x33333333
 802c23c:	3fd33333 	.word	0x3fd33333
 802c240:	10624dd3 	.word	0x10624dd3
 802c244:	3dcccccd 	.word	0x3dcccccd
 802c248:	42f00000 	.word	0x42f00000
 802c24c:	00000000 	.word	0x00000000
 802c250:	42200000 	.word	0x42200000
 802c254:	461c4000 	.word	0x461c4000
 802c258:	3c23d700 	.word	0x3c23d700
 802c25c:	3f7d70a4 	.word	0x3f7d70a4
 802c260:	3d800000 	.word	0x3d800000
	}
	else if (fabs(target_measurement->speed) >= 0.5 && fabs(target_measurement->speed) < 1.0)
 802c264:	eef6 7a00 	vmov.f32	s15, #96	; 0x60
 802c268:	eef4 dae7 	vcmpe.f32	s27, s15
 802c26c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c270:	f280 8216 	bge.w	802c6a0 <data_association+0x5d8>
	{
		alpha_range = 0.8;
	}
	else if (fabs(target_measurement->speed) >= 1.0)
 802c274:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
 802c278:	eef4 dae7 	vcmpe.f32	s27, s15
 802c27c:	ed1f da0a 	vldr	s26, [pc, #-40]	; 802c258 <data_association+0x190>
 802c280:	ed1f 7a0a 	vldr	s14, [pc, #-40]	; 802c25c <data_association+0x194>
 802c284:	ed5f 7a0a 	vldr	s15, [pc, #-40]	; 802c260 <data_association+0x198>
 802c288:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c28c:	eef6 6a0e 	vmov.f32	s13, #110	; 0x6e
 802c290:	bfb8      	it	lt
 802c292:	eeb0 da66 	vmovlt.f32	s26, s13
 802c296:	bfa8      	it	ge
 802c298:	eef0 7a47 	vmovge.f32	s15, s14
	}

	//------------------------- update range -----------------------------------

	track_ptr->range = (1.0f - alpha_range) * track_ptr->range +
			alpha_range * (target_measurement->range * 0.5f + px_track_predict);
 802c29c:	edda 6a02 	vldr	s13, [sl, #8]
 802c2a0:	eeb6 7a00 	vmov.f32	s14, #96	; 0x60
 802c2a4:	eea6 8a87 	vfma.f32	s16, s13, s14
		alpha_range = 1.0/16.0;
	}

	//------------------------- update range -----------------------------------

	track_ptr->range = (1.0f - alpha_range) * track_ptr->range +
 802c2a8:	eb05 0309 	add.w	r3, r5, r9
 802c2ac:	eb08 1343 	add.w	r3, r8, r3, lsl #5
			alpha_range * (target_measurement->range * 0.5f + px_track_predict);
 802c2b0:	ee67 7a88 	vmul.f32	s15, s15, s16

	if (track_ptr->range_change_flag == 0)
 802c2b4:	899a      	ldrh	r2, [r3, #12]
		alpha_range = 1.0/16.0;
	}

	//------------------------- update range -----------------------------------

	track_ptr->range = (1.0f - alpha_range) * track_ptr->range +
 802c2b6:	eeec 7a0d 	vfma.f32	s15, s24, s26
 802c2ba:	edc3 7a06 	vstr	s15, [r3, #24]
			alpha_range * (target_measurement->range * 0.5f + px_track_predict);

	if (track_ptr->range_change_flag == 0)
 802c2be:	b96a      	cbnz	r2, 802c2dc <data_association+0x214>
	{
		if ((track_ptr->range < last_range - 40) || (track_ptr->range > last_range + 40))
 802c2c0:	ee3c 7a6a 	vsub.f32	s14, s24, s21
 802c2c4:	eef4 7ac7 	vcmpe.f32	s15, s14
 802c2c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c2cc:	f140 81df 	bpl.w	802c68e <data_association+0x5c6>
		{
			track_ptr->range_change_flag = 1;
 802c2d0:	eb05 0309 	add.w	r3, r5, r9
 802c2d4:	eb08 1343 	add.w	r3, r8, r3, lsl #5
 802c2d8:	2201      	movs	r2, #1
 802c2da:	819a      	strh	r2, [r3, #12]
		}
	}

	//------------------------- update speed -----------------------------------

	track_ptr->speed = target_measurement->speed;
 802c2dc:	eb05 0309 	add.w	r3, r5, r9
 802c2e0:	eb08 1343 	add.w	r3, r8, r3, lsl #5

	if (track_ptr->speed == 0)
 802c2e4:	eef5 ba40 	vcmp.f32	s23, #0.0
 802c2e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		}
	}

	//------------------------- update speed -----------------------------------

	track_ptr->speed = target_measurement->speed;
 802c2ec:	edc3 ba07 	vstr	s23, [r3, #28]
 802c2f0:	eb05 0109 	add.w	r1, r5, r9

	if (track_ptr->speed == 0)
	{
		track_ptr->speed_count += 1;
 802c2f4:	bf08      	it	eq
 802c2f6:	895b      	ldrheq	r3, [r3, #10]
 802c2f8:	ea4f 1141 	mov.w	r1, r1, lsl #5
 802c2fc:	bf08      	it	eq
 802c2fe:	3301      	addeq	r3, #1
 802c300:	eb08 0601 	add.w	r6, r8, r1
 802c304:	bf0c      	ite	eq
 802c306:	b29b      	uxtheq	r3, r3
	}
	else
	{
		track_ptr->speed_count = 0;
 802c308:	2300      	movne	r3, #0
 802c30a:	8173      	strh	r3, [r6, #10]
	}

	//------------------------- update angle -----------------------------------

	track_ptr->strength = target_measurement->strength;
 802c30c:	edda 7a01 	vldr	s15, [sl, #4]

	if (track_ptr->strength > 1.0 * range_detection_threshold)
 802c310:	eeb4 bae7 	vcmpe.f32	s22, s15
 802c314:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		track_ptr->speed_count = 0;
	}

	//------------------------- update angle -----------------------------------

	track_ptr->strength = target_measurement->strength;
 802c318:	edc6 7a05 	vstr	s15, [r6, #20]

	if (track_ptr->strength > 1.0 * range_detection_threshold)
 802c31c:	f140 810e 	bpl.w	802c53c <data_association+0x474>
	{
		if (track_ptr->speed_count == 0)
 802c320:	b29b      	uxth	r3, r3
 802c322:	2b00      	cmp	r3, #0
 802c324:	f000 8307 	beq.w	802c936 <data_association+0x86e>
			track_ptr->angle = T.target_angle;
			track_ptr->d_phi = T.d_phi;

			track_ptr->angle = median_filtering(&median_angle_arr[track_id], track_ptr->angle);
		}
		else if ((track_ptr->speed_count % (num_of_chirps + 1)) != 0)
 802c328:	9a3d      	ldr	r2, [sp, #244]	; 0xf4
 802c32a:	3201      	adds	r2, #1
 802c32c:	fbb3 f0f2 	udiv	r0, r3, r2
 802c330:	fb02 3310 	mls	r3, r2, r0, r3
 802c334:	930a      	str	r3, [sp, #40]	; 0x28
 802c336:	2b00      	cmp	r3, #0
 802c338:	f040 8243 	bne.w	802c7c2 <data_association+0x6fa>
		}
		else
		{
			//---------------------------------------- Rx1 ------------------------------------------

			compute_fft_signal(track_ptr->rx1_angle_arg_re, track_ptr->rx1_angle_arg_im, num_of_chirps, DOPPLER_FFT_SIZE, 1.0,
 802c33c:	f8bd 70f4 	ldrh.w	r7, [sp, #244]	; 0xf4
 802c340:	eb08 0001 	add.w	r0, r8, r1
 802c344:	f04f 567e 	mov.w	r6, #1065353216	; 0x3f800000
 802c348:	f04f 0c01 	mov.w	ip, #1
 802c34c:	f10d 0e38 	add.w	lr, sp, #56	; 0x38
 802c350:	4601      	mov	r1, r0
 802c352:	ab0f      	add	r3, sp, #60	; 0x3c
 802c354:	9600      	str	r6, [sp, #0]
 802c356:	f04f 0a02 	mov.w	sl, #2
 802c35a:	4eb8      	ldr	r6, [pc, #736]	; (802c63c <data_association+0x574>)
 802c35c:	f8cd c008 	str.w	ip, [sp, #8]
 802c360:	f8cd e00c 	str.w	lr, [sp, #12]
 802c364:	463a      	mov	r2, r7
 802c366:	3024      	adds	r0, #36	; 0x24
 802c368:	3164      	adds	r1, #100	; 0x64
 802c36a:	9304      	str	r3, [sp, #16]
 802c36c:	f8cd a004 	str.w	sl, [sp, #4]
 802c370:	2340      	movs	r3, #64	; 0x40
 802c372:	9605      	str	r6, [sp, #20]
 802c374:	f7fc fefe 	bl	8029174 <compute_fft_signal>
					FFT_INPUT_COMPLEX, FFT_SLOW_TIME, &i1_mean, &q1_mean, rx_angle_fft);

			compute_fft_spectrum(rx_angle_fft, DOPPLER_FFT_SIZE, rx_angle_fft_spectrum);
 802c378:	4630      	mov	r0, r6
 802c37a:	2140      	movs	r1, #64	; 0x40
 802c37c:	4ab0      	ldr	r2, [pc, #704]	; (802c640 <data_association+0x578>)
 802c37e:	f7fd f801 	bl	8029384 <compute_fft_spectrum>

			arm_max_f32(rx_angle_fft_spectrum, (uint32_t)DOPPLER_FFT_SIZE, &max_value, &idx);
 802c382:	ab13      	add	r3, sp, #76	; 0x4c
 802c384:	aa12      	add	r2, sp, #72	; 0x48
 802c386:	48ae      	ldr	r0, [pc, #696]	; (802c640 <data_association+0x578>)
 802c388:	2140      	movs	r1, #64	; 0x40
 802c38a:	f7fc f945 	bl	8028618 <arm_max_f32>

			if (idx != 0)
 802c38e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 802c390:	b133      	cbz	r3, 802c3a0 <data_association+0x2d8>
			{
				i1_mean = rx_angle_fft[2*idx + 0];
 802c392:	eb06 02c3 	add.w	r2, r6, r3, lsl #3
				q1_mean = rx_angle_fft[2*idx + 1];
 802c396:	4613      	mov	r3, r2

			arm_max_f32(rx_angle_fft_spectrum, (uint32_t)DOPPLER_FFT_SIZE, &max_value, &idx);

			if (idx != 0)
			{
				i1_mean = rx_angle_fft[2*idx + 0];
 802c398:	6812      	ldr	r2, [r2, #0]
				q1_mean = rx_angle_fft[2*idx + 1];
 802c39a:	685b      	ldr	r3, [r3, #4]

			arm_max_f32(rx_angle_fft_spectrum, (uint32_t)DOPPLER_FFT_SIZE, &max_value, &idx);

			if (idx != 0)
			{
				i1_mean = rx_angle_fft[2*idx + 0];
 802c39c:	920e      	str	r2, [sp, #56]	; 0x38
				q1_mean = rx_angle_fft[2*idx + 1];
 802c39e:	930f      	str	r3, [sp, #60]	; 0x3c
			}

			//---------------------------------------- Rx2 ------------------------------------------

			compute_fft_signal(track_ptr->rx2_angle_arg_re, track_ptr->rx2_angle_arg_im, num_of_chirps, DOPPLER_FFT_SIZE, 1.0,
 802c3a0:	eb05 0109 	add.w	r1, r5, r9
 802c3a4:	0149      	lsls	r1, r1, #5
 802c3a6:	eb08 0001 	add.w	r0, r8, r1
 802c3aa:	9605      	str	r6, [sp, #20]
 802c3ac:	ae10      	add	r6, sp, #64	; 0x40
 802c3ae:	f04f 5c7e 	mov.w	ip, #1065353216	; 0x3f800000
 802c3b2:	f04f 0e02 	mov.w	lr, #2
 802c3b6:	463a      	mov	r2, r7
 802c3b8:	4601      	mov	r1, r0
 802c3ba:	2301      	movs	r3, #1
 802c3bc:	9603      	str	r6, [sp, #12]
 802c3be:	af11      	add	r7, sp, #68	; 0x44
 802c3c0:	4e9e      	ldr	r6, [pc, #632]	; (802c63c <data_association+0x574>)
 802c3c2:	f8cd c000 	str.w	ip, [sp]
 802c3c6:	f8cd e004 	str.w	lr, [sp, #4]
 802c3ca:	30a4      	adds	r0, #164	; 0xa4
 802c3cc:	31e4      	adds	r1, #228	; 0xe4
 802c3ce:	9302      	str	r3, [sp, #8]
 802c3d0:	9704      	str	r7, [sp, #16]
 802c3d2:	2340      	movs	r3, #64	; 0x40
 802c3d4:	f7fc fece 	bl	8029174 <compute_fft_signal>
					FFT_INPUT_COMPLEX, FFT_SLOW_TIME, &i2_mean, &q2_mean, rx_angle_fft);

			compute_fft_spectrum(rx_angle_fft, DOPPLER_FFT_SIZE, rx_angle_fft_spectrum);
 802c3d8:	4630      	mov	r0, r6
 802c3da:	2140      	movs	r1, #64	; 0x40
 802c3dc:	4a98      	ldr	r2, [pc, #608]	; (802c640 <data_association+0x578>)
 802c3de:	f7fc ffd1 	bl	8029384 <compute_fft_spectrum>

			arm_max_f32(rx_angle_fft_spectrum, (uint32_t)DOPPLER_FFT_SIZE, &max_value, &idx);
 802c3e2:	ab13      	add	r3, sp, #76	; 0x4c
 802c3e4:	aa12      	add	r2, sp, #72	; 0x48
 802c3e6:	4896      	ldr	r0, [pc, #600]	; (802c640 <data_association+0x578>)
 802c3e8:	2140      	movs	r1, #64	; 0x40
 802c3ea:	f7fc f915 	bl	8028618 <arm_max_f32>

			if (idx != 0)
 802c3ee:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 802c3f0:	2b00      	cmp	r3, #0
 802c3f2:	f040 8162 	bne.w	802c6ba <data_association+0x5f2>
 802c3f6:	9f10      	ldr	r7, [sp, #64]	; 0x40
 802c3f8:	9b11      	ldr	r3, [sp, #68]	; 0x44
				q2_mean = rx_angle_fft[2*idx + 1];
			}

			target_angle_data T;

			T = compute_angle(i1_mean, q1_mean, i2_mean, q2_mean,track_ptr->d_phi, angle_offset_deg, wave_length_ant_spacing_ratio);
 802c3fa:	9300      	str	r3, [sp, #0]
 802c3fc:	444d      	add	r5, r9
 802c3fe:	eb08 1545 	add.w	r5, r8, r5, lsl #5
 802c402:	f8dd a038 	ldr.w	sl, [sp, #56]	; 0x38
 802c406:	f8d5 0124 	ldr.w	r0, [r5, #292]	; 0x124
 802c40a:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
 802c40c:	f001 fd28 	bl	802de60 <__aeabi_f2d>
 802c410:	f9bd 3024 	ldrsh.w	r3, [sp, #36]	; 0x24
 802c414:	9304      	str	r3, [sp, #16]
 802c416:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802c41a:	463b      	mov	r3, r7
 802c41c:	4651      	mov	r1, sl
 802c41e:	4632      	mov	r2, r6
 802c420:	a814      	add	r0, sp, #80	; 0x50
 802c422:	edcd ca05 	vstr	s25, [sp, #20]
 802c426:	f7fc ffb3 	bl	8029390 <compute_angle>

			track_ptr->angle = T.target_angle;
 802c42a:	f8dd a058 	ldr.w	sl, [sp, #88]	; 0x58
//===========================================================================

float median_filtering(Median_Filtering_t *track_median_arr, float new_input)
{

	if( track_median_arr->median_filter_len > MAX_MEDIAN_FILTER_LEN)
 802c42e:	f8df c21c 	ldr.w	ip, [pc, #540]	; 802c64c <data_association+0x584>

			target_angle_data T;

			T = compute_angle(i1_mean, q1_mean, i2_mean, q2_mean,track_ptr->d_phi, angle_offset_deg, wave_length_ant_spacing_ratio);

			track_ptr->angle = T.target_angle;
 802c432:	f8c5 a020 	str.w	sl, [r5, #32]
			track_ptr->d_phi = T.d_phi;
 802c436:	e9dd 0114 	ldrd	r0, r1, [sp, #80]	; 0x50
//===========================================================================

float median_filtering(Median_Filtering_t *track_median_arr, float new_input)
{

	if( track_median_arr->median_filter_len > MAX_MEDIAN_FILTER_LEN)
 802c43a:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
 802c43e:	ea4f 1709 	mov.w	r7, r9, lsl #4
			target_angle_data T;

			T = compute_angle(i1_mean, q1_mean, i2_mean, q2_mean,track_ptr->d_phi, angle_offset_deg, wave_length_ant_spacing_ratio);

			track_ptr->angle = T.target_angle;
			track_ptr->d_phi = T.d_phi;
 802c442:	f002 f843 	bl	802e4cc <__aeabi_d2f>
//===========================================================================

float median_filtering(Median_Filtering_t *track_median_arr, float new_input)
{

	if( track_median_arr->median_filter_len > MAX_MEDIAN_FILTER_LEN)
 802c446:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
			target_angle_data T;

			T = compute_angle(i1_mean, q1_mean, i2_mean, q2_mean,track_ptr->d_phi, angle_offset_deg, wave_length_ant_spacing_ratio);

			track_ptr->angle = T.target_angle;
			track_ptr->d_phi = T.d_phi;
 802c44a:	f8c5 0124 	str.w	r0, [r5, #292]	; 0x124
//===========================================================================

float median_filtering(Median_Filtering_t *track_median_arr, float new_input)
{

	if( track_median_arr->median_filter_len > MAX_MEDIAN_FILTER_LEN)
 802c44e:	ebc9 0307 	rsb	r3, r9, r7
 802c452:	eb0c 0283 	add.w	r2, ip, r3, lsl #2

			target_angle_data T;

			T = compute_angle(i1_mean, q1_mean, i2_mean, q2_mean,track_ptr->d_phi, angle_offset_deg, wave_length_ant_spacing_ratio);

			track_ptr->angle = T.target_angle;
 802c456:	ea4f 05c9 	mov.w	r5, r9, lsl #3
//===========================================================================

float median_filtering(Median_Filtering_t *track_median_arr, float new_input)
{

	if( track_median_arr->median_filter_len > MAX_MEDIAN_FILTER_LEN)
 802c45a:	6851      	ldr	r1, [r2, #4]
		track_median_arr->median_filter_len = MAX_MEDIAN_FILTER_LEN;

	if (track_median_arr->is_full == 0)
 802c45c:	f81c 3023 	ldrb.w	r3, [ip, r3, lsl #2]
//===========================================================================

float median_filtering(Median_Filtering_t *track_median_arr, float new_input)
{

	if( track_median_arr->median_filter_len > MAX_MEDIAN_FILTER_LEN)
 802c460:	290d      	cmp	r1, #13
 802c462:	f240 8191 	bls.w	802c788 <data_association+0x6c0>
		track_median_arr->median_filter_len = MAX_MEDIAN_FILTER_LEN;
 802c466:	210d      	movs	r1, #13
 802c468:	6051      	str	r1, [r2, #4]

	if (track_median_arr->is_full == 0)
 802c46a:	2b00      	cmp	r3, #0
 802c46c:	f000 8170 	beq.w	802c750 <data_association+0x688>
 802c470:	230c      	movs	r3, #12
 802c472:	930a      	str	r3, [sp, #40]	; 0x28
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c474:	ebc9 0307 	rsb	r3, r9, r7
 802c478:	eb0c 0383 	add.w	r3, ip, r3, lsl #2
 802c47c:	68de      	ldr	r6, [r3, #12]
 802c47e:	6918      	ldr	r0, [r3, #16]
 802c480:	695a      	ldr	r2, [r3, #20]

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802c482:	609e      	str	r6, [r3, #8]
 802c484:	60d8      	str	r0, [r3, #12]
 802c486:	611a      	str	r2, [r3, #16]
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c488:	9619      	str	r6, [sp, #100]	; 0x64
 802c48a:	901a      	str	r0, [sp, #104]	; 0x68
 802c48c:	921b      	str	r2, [sp, #108]	; 0x6c
	}
	else
	{
		float sorting_arr[MAX_MEDIAN_FILTER_LEN];

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
 802c48e:	230c      	movs	r3, #12
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c490:	ebc9 0207 	rsb	r2, r9, r7
 802c494:	eb0c 0282 	add.w	r2, ip, r2, lsl #2

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c498:	2b04      	cmp	r3, #4
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c49a:	6990      	ldr	r0, [r2, #24]
 802c49c:	901c      	str	r0, [sp, #112]	; 0x70

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802c49e:	6150      	str	r0, [r2, #20]

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c4a0:	d025      	beq.n	802c4ee <data_association+0x426>
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c4a2:	69d0      	ldr	r0, [r2, #28]
 802c4a4:	901d      	str	r0, [sp, #116]	; 0x74

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c4a6:	2b05      	cmp	r3, #5
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802c4a8:	6190      	str	r0, [r2, #24]

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c4aa:	d020      	beq.n	802c4ee <data_association+0x426>
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c4ac:	6a10      	ldr	r0, [r2, #32]
 802c4ae:	901e      	str	r0, [sp, #120]	; 0x78

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c4b0:	2b06      	cmp	r3, #6
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802c4b2:	61d0      	str	r0, [r2, #28]

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c4b4:	d01b      	beq.n	802c4ee <data_association+0x426>
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c4b6:	6a50      	ldr	r0, [r2, #36]	; 0x24
 802c4b8:	901f      	str	r0, [sp, #124]	; 0x7c

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c4ba:	2b07      	cmp	r3, #7
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802c4bc:	6210      	str	r0, [r2, #32]

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c4be:	d016      	beq.n	802c4ee <data_association+0x426>
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c4c0:	6a90      	ldr	r0, [r2, #40]	; 0x28
 802c4c2:	9020      	str	r0, [sp, #128]	; 0x80

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c4c4:	2b08      	cmp	r3, #8
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802c4c6:	6250      	str	r0, [r2, #36]	; 0x24

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c4c8:	d011      	beq.n	802c4ee <data_association+0x426>
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c4ca:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 802c4cc:	9021      	str	r0, [sp, #132]	; 0x84

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c4ce:	2b09      	cmp	r3, #9
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802c4d0:	6290      	str	r0, [r2, #40]	; 0x28

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c4d2:	d00c      	beq.n	802c4ee <data_association+0x426>
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c4d4:	6b10      	ldr	r0, [r2, #48]	; 0x30
 802c4d6:	9022      	str	r0, [sp, #136]	; 0x88

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c4d8:	2b0a      	cmp	r3, #10
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802c4da:	62d0      	str	r0, [r2, #44]	; 0x2c

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c4dc:	d007      	beq.n	802c4ee <data_association+0x426>
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c4de:	6b50      	ldr	r0, [r2, #52]	; 0x34
 802c4e0:	9023      	str	r0, [sp, #140]	; 0x8c

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c4e2:	2b0c      	cmp	r3, #12
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802c4e4:	6310      	str	r0, [r2, #48]	; 0x30

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c4e6:	d102      	bne.n	802c4ee <data_association+0x426>
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c4e8:	6b93      	ldr	r3, [r2, #56]	; 0x38
 802c4ea:	9324      	str	r3, [sp, #144]	; 0x90

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802c4ec:	6353      	str	r3, [r2, #52]	; 0x34

		}

		track_median_arr->buffer[track_median_arr->median_filter_len-1] = new_input;
 802c4ee:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802c4f0:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
 802c4f4:	ebc9 0607 	rsb	r6, r9, r7
 802c4f8:	18f2      	adds	r2, r6, r3

		sorting_arr[track_median_arr->median_filter_len-1] = new_input;
 802c4fa:	a826      	add	r0, sp, #152	; 0x98

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];

		}

		track_median_arr->buffer[track_median_arr->median_filter_len-1] = new_input;
 802c4fc:	eb0c 0282 	add.w	r2, ip, r2, lsl #2

		sorting_arr[track_median_arr->median_filter_len-1] = new_input;
 802c500:	eb00 0383 	add.w	r3, r0, r3, lsl #2

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];

		}

		track_median_arr->buffer[track_median_arr->median_filter_len-1] = new_input;
 802c504:	f8c2 a008 	str.w	sl, [r2, #8]

		sorting_arr[track_median_arr->median_filter_len-1] = new_input;

		qsort(sorting_arr, track_median_arr->median_filter_len, sizeof(float), compare_float);
 802c508:	a819      	add	r0, sp, #100	; 0x64
 802c50a:	2204      	movs	r2, #4

		}

		track_median_arr->buffer[track_median_arr->median_filter_len-1] = new_input;

		sorting_arr[track_median_arr->median_filter_len-1] = new_input;
 802c50c:	f843 ac34 	str.w	sl, [r3, #-52]

		qsort(sorting_arr, track_median_arr->median_filter_len, sizeof(float), compare_float);
 802c510:	4b4c      	ldr	r3, [pc, #304]	; (802c644 <data_association+0x57c>)
 802c512:	f002 fee2 	bl	802f2da <qsort>

		return sorting_arr[track_median_arr->median_filter_len / 2];
 802c516:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 802c51a:	eb0c 0686 	add.w	r6, ip, r6, lsl #2
 802c51e:	aa26      	add	r2, sp, #152	; 0x98
 802c520:	6873      	ldr	r3, [r6, #4]
 802c522:	085b      	lsrs	r3, r3, #1
 802c524:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 802c528:	f853 ac34 	ldr.w	sl, [r3, #-52]
			T = compute_angle(i1_mean, q1_mean, i2_mean, q2_mean,track_ptr->d_phi, angle_offset_deg, wave_length_ant_spacing_ratio);

			track_ptr->angle = T.target_angle;
			track_ptr->d_phi = T.d_phi;

			track_ptr->angle = median_filtering(&median_angle_arr[track_id], track_ptr->angle);
 802c52c:	eb05 0309 	add.w	r3, r5, r9
 802c530:	eb08 1343 	add.w	r3, r8, r3, lsl #5
 802c534:	f8c3 a020 	str.w	sl, [r3, #32]
 802c538:	f8d8 7004 	ldr.w	r7, [r8, #4]

				update_track(&p_tracks->elems[i], &target_measurements[tgt_idx], i, px_track_predict * 0.5,
								cp_algo_settings->range_detection_threshold , cp_algo_settings->angle_offset_deg, num_of_chirps,
								cp_algo_settings->wave_length_ant_spacing_ratio);

				target_measurements[tgt_idx].is_associated = 1;
 802c53c:	9a08      	ldr	r2, [sp, #32]
 802c53e:	2301      	movs	r3, #1
 802c540:	f82b 3002 	strh.w	r3, [fp, r2]
	//========= CASE 2: update tracks already assigned ===========
	else
	{
		int8_t tgt_idx;

		for (uint8_t i = 0; i < p_tracks->max_num_of_tracks; i++)
 802c544:	f109 0901 	add.w	r9, r9, #1
 802c548:	fa5f f989 	uxtb.w	r9, r9
 802c54c:	45b9      	cmp	r9, r7
 802c54e:	f4ff ade0 	bcc.w	802c112 <data_association+0x4a>
 802c552:	46a2      	mov	sl, r4
 802c554:	4644      	mov	r4, r8

		//========= CASE 3: Kill expired tracks ===========

		int32_t ghost_target_diff = 0;

		for (uint32_t j = 0; j < p_tracks->max_num_of_tracks; j++)
 802c556:	2f00      	cmp	r7, #0
 802c558:	d06b      	beq.n	802c632 <data_association+0x56a>
 802c55a:	f04f 0900 	mov.w	r9, #0
//===========================================================================

static void clear_track_elem(Tracking_Params_t* track_ptr)
{
	memset(track_ptr, 0, sizeof(Tracking_Params_t));
	track_ptr->d_phi = IGNORE_NAN;
 802c55e:	ed9f 8a3a 	vldr	s16, [pc, #232]	; 802c648 <data_association+0x580>
					p_tracks->elems[j].speed_count > 2*LIFE_TIME_COUNT )
			{
				clear_track_elem(&p_tracks->elems[j]);  // init track data
				p_tracks->num_of_tracks -= 1;

				median_angle_arr[j].is_full = 0;
 802c562:	f8df 80e8 	ldr.w	r8, [pc, #232]	; 802c64c <data_association+0x584>

//===========================================================================

static void clear_track_elem(Tracking_Params_t* track_ptr)
{
	memset(track_ptr, 0, sizeof(Tracking_Params_t));
 802c566:	464e      	mov	r6, r9
 802c568:	f104 0508 	add.w	r5, r4, #8
 802c56c:	e011      	b.n	802c592 <data_association+0x4ca>
 802c56e:	f002 fb26 	bl	802ebbe <memset>
	track_ptr->d_phi = IGNORE_NAN;
 802c572:	ed85 8a47 	vstr	s16, [r5, #284]	; 0x11c

			if (p_tracks->elems[j].lifetime_counter > LIFE_TIME_COUNT || ghost_target_diff > 0  ||
					p_tracks->elems[j].speed_count > 2*LIFE_TIME_COUNT )
			{
				clear_track_elem(&p_tracks->elems[j]);  // init track data
				p_tracks->num_of_tracks -= 1;
 802c576:	6822      	ldr	r2, [r4, #0]
 802c578:	ebc9 1309 	rsb	r3, r9, r9, lsl #4
 802c57c:	3a01      	subs	r2, #1
 802c57e:	6022      	str	r2, [r4, #0]

				median_angle_arr[j].is_full = 0;
 802c580:	f808 6023 	strb.w	r6, [r8, r3, lsl #2]
 802c584:	6867      	ldr	r7, [r4, #4]

		//========= CASE 3: Kill expired tracks ===========

		int32_t ghost_target_diff = 0;

		for (uint32_t j = 0; j < p_tracks->max_num_of_tracks; j++)
 802c586:	f109 0901 	add.w	r9, r9, #1
 802c58a:	45b9      	cmp	r9, r7
 802c58c:	f505 7590 	add.w	r5, r5, #288	; 0x120
 802c590:	d219      	bcs.n	802c5c6 <data_association+0x4fe>
		{
			ghost_target_diff = p_tracks->elems[j].lifetime_counter - p_tracks->elems[j].measurement_counter - GHOST_LIFE_TIME;
 802c592:	f8b5 e006 	ldrh.w	lr, [r5, #6]
 802c596:	68ab      	ldr	r3, [r5, #8]

			if (p_tracks->elems[j].lifetime_counter > LIFE_TIME_COUNT || ghost_target_diff > 0  ||
 802c598:	f1be 0f14 	cmp.w	lr, #20

		int32_t ghost_target_diff = 0;

		for (uint32_t j = 0; j < p_tracks->max_num_of_tracks; j++)
		{
			ghost_target_diff = p_tracks->elems[j].lifetime_counter - p_tracks->elems[j].measurement_counter - GHOST_LIFE_TIME;
 802c59c:	ebc3 030e 	rsb	r3, r3, lr

//===========================================================================

static void clear_track_elem(Tracking_Params_t* track_ptr)
{
	memset(track_ptr, 0, sizeof(Tracking_Params_t));
 802c5a0:	4628      	mov	r0, r5
 802c5a2:	f04f 0100 	mov.w	r1, #0
 802c5a6:	f44f 7290 	mov.w	r2, #288	; 0x120

		int32_t ghost_target_diff = 0;

		for (uint32_t j = 0; j < p_tracks->max_num_of_tracks; j++)
		{
			ghost_target_diff = p_tracks->elems[j].lifetime_counter - p_tracks->elems[j].measurement_counter - GHOST_LIFE_TIME;
 802c5aa:	f1a3 0305 	sub.w	r3, r3, #5

			if (p_tracks->elems[j].lifetime_counter > LIFE_TIME_COUNT || ghost_target_diff > 0  ||
 802c5ae:	d8de      	bhi.n	802c56e <data_association+0x4a6>
 802c5b0:	428b      	cmp	r3, r1
 802c5b2:	dcdc      	bgt.n	802c56e <data_association+0x4a6>
 802c5b4:	886b      	ldrh	r3, [r5, #2]
 802c5b6:	2b28      	cmp	r3, #40	; 0x28
 802c5b8:	d8d9      	bhi.n	802c56e <data_association+0x4a6>

		//========= CASE 3: Kill expired tracks ===========

		int32_t ghost_target_diff = 0;

		for (uint32_t j = 0; j < p_tracks->max_num_of_tracks; j++)
 802c5ba:	f109 0901 	add.w	r9, r9, #1
 802c5be:	45b9      	cmp	r9, r7
 802c5c0:	f505 7590 	add.w	r5, r5, #288	; 0x120
 802c5c4:	d3e5      	bcc.n	802c592 <data_association+0x4ca>
			}
		}

		//========= CASE 4: assign new tracks  ===========

		if (p_tracks->num_of_tracks < p_tracks->max_num_of_tracks)
 802c5c6:	6823      	ldr	r3, [r4, #0]
 802c5c8:	429f      	cmp	r7, r3
 802c5ca:	d932      	bls.n	802c632 <data_association+0x56a>
		{
			for (uint8_t j = 0; j < num_of_targets; j++)
 802c5cc:	f1ba 0f00 	cmp.w	sl, #0
 802c5d0:	d02f      	beq.n	802c632 <data_association+0x56a>
 802c5d2:	9e07      	ldr	r6, [sp, #28]
 802c5d4:	2500      	movs	r5, #0
			{
				if(target_measurements[j].is_associated == 0 && target_measurements[j].speed != 0)
 802c5d6:	016b      	lsls	r3, r5, #5
 802c5d8:	eb0b 0103 	add.w	r1, fp, r3
 802c5dc:	f83b 2003 	ldrh.w	r2, [fp, r3]
 802c5e0:	bb1a      	cbnz	r2, 802c62a <data_association+0x562>
 802c5e2:	edd1 7a03 	vldr	s15, [r1, #12]
 802c5e6:	eef5 7a40 	vcmp.f32	s15, #0.0
 802c5ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c5ee:	d01c      	beq.n	802c62a <data_association+0x562>

static uint8_t get_next_free_trackID(tracking_list_t *p_tracks )
{
	uint8_t i = 0;

	while(i < p_tracks->max_num_of_tracks)
 802c5f0:	6860      	ldr	r0, [r4, #4]
 802c5f2:	2800      	cmp	r0, #0
 802c5f4:	f000 8216 	beq.w	802ca24 <data_association+0x95c>
	{
		if(p_tracks->elems[i].is_alived == 0)
 802c5f8:	7a63      	ldrb	r3, [r4, #9]
 802c5fa:	b913      	cbnz	r3, 802c602 <data_association+0x53a>
 802c5fc:	e214      	b.n	802ca28 <data_association+0x960>
 802c5fe:	7a5b      	ldrb	r3, [r3, #9]
 802c600:	b13b      	cbz	r3, 802c612 <data_association+0x54a>
		{
			break;
		}
		i++;
 802c602:	3201      	adds	r2, #1
 802c604:	b2d2      	uxtb	r2, r2
{
	uint8_t i = 0;

	while(i < p_tracks->max_num_of_tracks)
	{
		if(p_tracks->elems[i].is_alived == 0)
 802c606:	eb02 03c2 	add.w	r3, r2, r2, lsl #3

static uint8_t get_next_free_trackID(tracking_list_t *p_tracks )
{
	uint8_t i = 0;

	while(i < p_tracks->max_num_of_tracks)
 802c60a:	4282      	cmp	r2, r0
	{
		if(p_tracks->elems[i].is_alived == 0)
 802c60c:	eb04 1343 	add.w	r3, r4, r3, lsl #5

static uint8_t get_next_free_trackID(tracking_list_t *p_tracks )
{
	uint8_t i = 0;

	while(i < p_tracks->max_num_of_tracks)
 802c610:	d3f5      	bcc.n	802c5fe <data_association+0x536>
			{
				if(target_measurements[j].is_associated == 0 && target_measurements[j].speed != 0)
				{
					uint8_t next_free_id = get_next_free_trackID( p_tracks );

					(void) assign_track(p_tracks, &target_measurements[j], next_free_id, cp_algo_settings->angle_offset_deg,
 802c612:	8d33      	ldrh	r3, [r6, #40]	; 0x28
 802c614:	ed96 0a11 	vldr	s0, [r6, #68]	; 0x44
 802c618:	edd6 0a12 	vldr	s1, [r6, #72]	; 0x48
 802c61c:	4620      	mov	r0, r4
 802c61e:	f7ff fcb7 	bl	802bf90 <assign_track>
							cp_algo_settings->wave_length_ant_spacing_ratio, cp_algo_settings->min_angle_for_track_assignment );

					if (p_tracks->num_of_tracks >= p_tracks->max_num_of_tracks)
 802c622:	e894 000c 	ldmia.w	r4, {r2, r3}
 802c626:	429a      	cmp	r2, r3
 802c628:	d203      	bcs.n	802c632 <data_association+0x56a>

		//========= CASE 4: assign new tracks  ===========

		if (p_tracks->num_of_tracks < p_tracks->max_num_of_tracks)
		{
			for (uint8_t j = 0; j < num_of_targets; j++)
 802c62a:	3501      	adds	r5, #1
 802c62c:	b2ed      	uxtb	r5, r5
 802c62e:	45aa      	cmp	sl, r5
 802c630:	d8d1      	bhi.n	802c5d6 <data_association+0x50e>
				}
			}
		}
	}

}
 802c632:	b027      	add	sp, #156	; 0x9c
 802c634:	ecbd 8b0c 	vpop	{d8-d13}
 802c638:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802c63c:	200047f4 	.word	0x200047f4
 802c640:	200046f4 	.word	0x200046f4
 802c644:	0802bf71 	.word	0x0802bf71
 802c648:	440ac000 	.word	0x440ac000
 802c64c:	200049f4 	.word	0x200049f4
 802c650:	3e4ccccc 	.word	0x3e4ccccc
 802c654:	3f4ccccd 	.word	0x3f4ccccd
				}
			}

			if (tgt_idx == -1)
			{
				p_tracks->elems[i].lifetime_counter += 1;
 802c658:	444d      	add	r5, r9
 802c65a:	eb08 1545 	add.w	r5, r8, r5, lsl #5

				p_tracks->elems[i].range = 0.5 * (p_tracks->elems[i].range + px_track_predict);
 802c65e:	ee36 7a87 	vadd.f32	s14, s13, s14
				}
			}

			if (tgt_idx == -1)
			{
				p_tracks->elems[i].lifetime_counter += 1;
 802c662:	89eb      	ldrh	r3, [r5, #14]

				p_tracks->elems[i].range = 0.5 * (p_tracks->elems[i].range + px_track_predict);
 802c664:	eef6 7a00 	vmov.f32	s15, #96	; 0x60
	//========= CASE 2: update tracks already assigned ===========
	else
	{
		int8_t tgt_idx;

		for (uint8_t i = 0; i < p_tracks->max_num_of_tracks; i++)
 802c668:	f109 0901 	add.w	r9, r9, #1

			if (tgt_idx == -1)
			{
				p_tracks->elems[i].lifetime_counter += 1;

				p_tracks->elems[i].range = 0.5 * (p_tracks->elems[i].range + px_track_predict);
 802c66c:	ee27 7a27 	vmul.f32	s14, s14, s15
	//========= CASE 2: update tracks already assigned ===========
	else
	{
		int8_t tgt_idx;

		for (uint8_t i = 0; i < p_tracks->max_num_of_tracks; i++)
 802c670:	fa5f f989 	uxtb.w	r9, r9
				}
			}

			if (tgt_idx == -1)
			{
				p_tracks->elems[i].lifetime_counter += 1;
 802c674:	3301      	adds	r3, #1
	//========= CASE 2: update tracks already assigned ===========
	else
	{
		int8_t tgt_idx;

		for (uint8_t i = 0; i < p_tracks->max_num_of_tracks; i++)
 802c676:	45b9      	cmp	r9, r7
				}
			}

			if (tgt_idx == -1)
			{
				p_tracks->elems[i].lifetime_counter += 1;
 802c678:	81eb      	strh	r3, [r5, #14]

				p_tracks->elems[i].range = 0.5 * (p_tracks->elems[i].range + px_track_predict);
 802c67a:	ed85 7a06 	vstr	s14, [r5, #24]
	//========= CASE 2: update tracks already assigned ===========
	else
	{
		int8_t tgt_idx;

		for (uint8_t i = 0; i < p_tracks->max_num_of_tracks; i++)
 802c67e:	f4ff ad48 	bcc.w	802c112 <data_association+0x4a>
 802c682:	e766      	b.n	802c552 <data_association+0x48a>

	uint32_t idx;

	float alpha_range ;

	if (fabs(target_measurement->speed) <= 0.3)
 802c684:	eeb6 da08 	vmov.f32	s26, #104	; 0x68
	{
		alpha_range = 0.25;
 802c688:	eef5 7a00 	vmov.f32	s15, #80	; 0x50
 802c68c:	e606      	b.n	802c29c <data_association+0x1d4>
	track_ptr->range = (1.0f - alpha_range) * track_ptr->range +
			alpha_range * (target_measurement->range * 0.5f + px_track_predict);

	if (track_ptr->range_change_flag == 0)
	{
		if ((track_ptr->range < last_range - 40) || (track_ptr->range > last_range + 40))
 802c68e:	ee3c ca2a 	vadd.f32	s24, s24, s21
 802c692:	eef4 7acc 	vcmpe.f32	s15, s24
 802c696:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c69a:	f77f ae1f 	ble.w	802c2dc <data_association+0x214>
 802c69e:	e617      	b.n	802c2d0 <data_association+0x208>
	}
	else if (fabs(target_measurement->speed) > 0.3 && fabs(target_measurement->speed) < 0.5)
	{
		alpha_range = 0.50;
	}
	else if (fabs(target_measurement->speed) >= 0.5 && fabs(target_measurement->speed) < 1.0)
 802c6a0:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
 802c6a4:	eef4 dae7 	vcmpe.f32	s27, s15
 802c6a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c6ac:	f57f ade2 	bpl.w	802c274 <data_association+0x1ac>
 802c6b0:	ed1f da19 	vldr	s26, [pc, #-100]	; 802c650 <data_association+0x588>
	{
		alpha_range = 0.8;
 802c6b4:	ed5f 7a19 	vldr	s15, [pc, #-100]	; 802c654 <data_association+0x58c>
 802c6b8:	e5f0      	b.n	802c29c <data_association+0x1d4>

			arm_max_f32(rx_angle_fft_spectrum, (uint32_t)DOPPLER_FFT_SIZE, &max_value, &idx);

			if (idx != 0)
			{
				i2_mean = rx_angle_fft[2*idx + 0];
 802c6ba:	eb06 02c3 	add.w	r2, r6, r3, lsl #3
 802c6be:	6817      	ldr	r7, [r2, #0]
				q2_mean = rx_angle_fft[2*idx + 1];
 802c6c0:	6853      	ldr	r3, [r2, #4]

			arm_max_f32(rx_angle_fft_spectrum, (uint32_t)DOPPLER_FFT_SIZE, &max_value, &idx);

			if (idx != 0)
			{
				i2_mean = rx_angle_fft[2*idx + 0];
 802c6c2:	9710      	str	r7, [sp, #64]	; 0x40
				q2_mean = rx_angle_fft[2*idx + 1];
 802c6c4:	9311      	str	r3, [sp, #68]	; 0x44
 802c6c6:	e698      	b.n	802c3fa <data_association+0x332>

	//========= CASE 1: all tracks are empty ===========
	if(p_tracks->num_of_tracks == 0 && num_of_targets != 0)
	{
		// clear all tracks:
		for (uint8_t i = 0; i < p_tracks->max_num_of_tracks; i++)
 802c6c8:	6840      	ldr	r0, [r0, #4]
 802c6ca:	b170      	cbz	r0, 802c6ea <data_association+0x622>
		{
			memset(&p_tracks->elems[i], 0 ,sizeof(p_tracks->elems[i]) );
 802c6cc:	eb05 00c5 	add.w	r0, r5, r5, lsl #3
 802c6d0:	eb04 1040 	add.w	r0, r4, r0, lsl #5
 802c6d4:	3008      	adds	r0, #8
 802c6d6:	2100      	movs	r1, #0
 802c6d8:	f44f 7290 	mov.w	r2, #288	; 0x120
 802c6dc:	f002 fa6f 	bl	802ebbe <memset>

	//========= CASE 1: all tracks are empty ===========
	if(p_tracks->num_of_tracks == 0 && num_of_targets != 0)
	{
		// clear all tracks:
		for (uint8_t i = 0; i < p_tracks->max_num_of_tracks; i++)
 802c6e0:	3501      	adds	r5, #1
 802c6e2:	6860      	ldr	r0, [r4, #4]
 802c6e4:	b2ed      	uxtb	r5, r5
 802c6e6:	4285      	cmp	r5, r0
 802c6e8:	d3f0      	bcc.n	802c6cc <data_association+0x604>
 802c6ea:	9e07      	ldr	r6, [sp, #28]
 802c6ec:	2500      	movs	r5, #0
			memset(&p_tracks->elems[i], 0 ,sizeof(p_tracks->elems[i]) );
		}

		for (uint8_t j = 0; j < num_of_targets; j++)
		{
			if(target_measurements[j].speed != 0)		// only moving targets
 802c6ee:	eb0b 1145 	add.w	r1, fp, r5, lsl #5
 802c6f2:	edd1 7a03 	vldr	s15, [r1, #12]
 802c6f6:	eef5 7a40 	vcmp.f32	s15, #0.0
 802c6fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c6fe:	d01d      	beq.n	802c73c <data_association+0x674>

static uint8_t get_next_free_trackID(tracking_list_t *p_tracks )
{
	uint8_t i = 0;

	while(i < p_tracks->max_num_of_tracks)
 802c700:	2800      	cmp	r0, #0
 802c702:	f000 8193 	beq.w	802ca2c <data_association+0x964>
	{
		if(p_tracks->elems[i].is_alived == 0)
 802c706:	7a62      	ldrb	r2, [r4, #9]
 802c708:	b15a      	cbz	r2, 802c722 <data_association+0x65a>
 802c70a:	2200      	movs	r2, #0
 802c70c:	e001      	b.n	802c712 <data_association+0x64a>
 802c70e:	7a5b      	ldrb	r3, [r3, #9]
 802c710:	b13b      	cbz	r3, 802c722 <data_association+0x65a>
		{
			break;
		}
		i++;
 802c712:	3201      	adds	r2, #1
 802c714:	b2d2      	uxtb	r2, r2
{
	uint8_t i = 0;

	while(i < p_tracks->max_num_of_tracks)
	{
		if(p_tracks->elems[i].is_alived == 0)
 802c716:	eb02 03c2 	add.w	r3, r2, r2, lsl #3

static uint8_t get_next_free_trackID(tracking_list_t *p_tracks )
{
	uint8_t i = 0;

	while(i < p_tracks->max_num_of_tracks)
 802c71a:	4282      	cmp	r2, r0
	{
		if(p_tracks->elems[i].is_alived == 0)
 802c71c:	eb04 1343 	add.w	r3, r4, r3, lsl #5

static uint8_t get_next_free_trackID(tracking_list_t *p_tracks )
{
	uint8_t i = 0;

	while(i < p_tracks->max_num_of_tracks)
 802c720:	d3f5      	bcc.n	802c70e <data_association+0x646>
		{
			if(target_measurements[j].speed != 0)		// only moving targets
			{
				uint8_t next_free_id = get_next_free_trackID( p_tracks );

				(void) assign_track(p_tracks, &target_measurements[j], next_free_id, cp_algo_settings->angle_offset_deg,
 802c722:	8d33      	ldrh	r3, [r6, #40]	; 0x28
 802c724:	ed96 0a11 	vldr	s0, [r6, #68]	; 0x44
 802c728:	edd6 0a12 	vldr	s1, [r6, #72]	; 0x48
 802c72c:	4620      	mov	r0, r4
 802c72e:	f7ff fc2f 	bl	802bf90 <assign_track>
						cp_algo_settings->wave_length_ant_spacing_ratio, cp_algo_settings->min_angle_for_track_assignment);

				if (p_tracks->num_of_tracks >= p_tracks->max_num_of_tracks)
 802c732:	6823      	ldr	r3, [r4, #0]
 802c734:	6860      	ldr	r0, [r4, #4]
 802c736:	4283      	cmp	r3, r0
 802c738:	f4bf af7b 	bcs.w	802c632 <data_association+0x56a>
		for (uint8_t i = 0; i < p_tracks->max_num_of_tracks; i++)
		{
			memset(&p_tracks->elems[i], 0 ,sizeof(p_tracks->elems[i]) );
		}

		for (uint8_t j = 0; j < num_of_targets; j++)
 802c73c:	3501      	adds	r5, #1
 802c73e:	b2ed      	uxtb	r5, r5
 802c740:	45aa      	cmp	sl, r5
 802c742:	d8d4      	bhi.n	802c6ee <data_association+0x626>
				}
			}
		}
	}

}
 802c744:	b027      	add	sp, #156	; 0x9c
 802c746:	ecbd 8b0c 	vpop	{d8-d13}
 802c74a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if( track_median_arr->median_filter_len > MAX_MEDIAN_FILTER_LEN)
		track_median_arr->median_filter_len = MAX_MEDIAN_FILTER_LEN;

	if (track_median_arr->is_full == 0)
	{
		for (uint32_t j = 0; j < track_median_arr->median_filter_len; j++)
 802c74e:	b149      	cbz	r1, 802c764 <data_association+0x69c>
 802c750:	223c      	movs	r2, #60	; 0x3c
 802c752:	fb02 c209 	mla	r2, r2, r9, ip
 802c756:	3208      	adds	r2, #8
{

	if( track_median_arr->median_filter_len > MAX_MEDIAN_FILTER_LEN)
		track_median_arr->median_filter_len = MAX_MEDIAN_FILTER_LEN;

	if (track_median_arr->is_full == 0)
 802c758:	2300      	movs	r3, #0
	{
		for (uint32_t j = 0; j < track_median_arr->median_filter_len; j++)
 802c75a:	3301      	adds	r3, #1
 802c75c:	4299      	cmp	r1, r3
		{
			track_median_arr->buffer[j] = new_input;
 802c75e:	f842 ab04 	str.w	sl, [r2], #4
	if( track_median_arr->median_filter_len > MAX_MEDIAN_FILTER_LEN)
		track_median_arr->median_filter_len = MAX_MEDIAN_FILTER_LEN;

	if (track_median_arr->is_full == 0)
	{
		for (uint32_t j = 0; j < track_median_arr->median_filter_len; j++)
 802c762:	d8fa      	bhi.n	802c75a <data_association+0x692>
		{
			track_median_arr->buffer[j] = new_input;
		}

		track_median_arr->is_full = 1;
 802c764:	ebc9 0607 	rsb	r6, r9, r7
 802c768:	2301      	movs	r3, #1
 802c76a:	f80c 3026 	strb.w	r3, [ip, r6, lsl #2]
			T = compute_angle(i1_mean, q1_mean, i2_mean, q2_mean,track_ptr->d_phi, angle_offset_deg, wave_length_ant_spacing_ratio);

			track_ptr->angle = T.target_angle;
			track_ptr->d_phi = T.d_phi;

			track_ptr->angle = median_filtering(&median_angle_arr[track_id], track_ptr->angle);
 802c76e:	eb05 0309 	add.w	r3, r5, r9
 802c772:	eb08 1343 	add.w	r3, r8, r3, lsl #5

				update_track(&p_tracks->elems[i], &target_measurements[tgt_idx], i, px_track_predict * 0.5,
								cp_algo_settings->range_detection_threshold , cp_algo_settings->angle_offset_deg, num_of_chirps,
								cp_algo_settings->wave_length_ant_spacing_ratio);

				target_measurements[tgt_idx].is_associated = 1;
 802c776:	9a08      	ldr	r2, [sp, #32]
			T = compute_angle(i1_mean, q1_mean, i2_mean, q2_mean,track_ptr->d_phi, angle_offset_deg, wave_length_ant_spacing_ratio);

			track_ptr->angle = T.target_angle;
			track_ptr->d_phi = T.d_phi;

			track_ptr->angle = median_filtering(&median_angle_arr[track_id], track_ptr->angle);
 802c778:	f8c3 a020 	str.w	sl, [r3, #32]

				update_track(&p_tracks->elems[i], &target_measurements[tgt_idx], i, px_track_predict * 0.5,
								cp_algo_settings->range_detection_threshold , cp_algo_settings->angle_offset_deg, num_of_chirps,
								cp_algo_settings->wave_length_ant_spacing_ratio);

				target_measurements[tgt_idx].is_associated = 1;
 802c77c:	2301      	movs	r3, #1
 802c77e:	f8d8 7004 	ldr.w	r7, [r8, #4]
 802c782:	f82b 3002 	strh.w	r3, [fp, r2]
 802c786:	e6dd      	b.n	802c544 <data_association+0x47c>
{

	if( track_median_arr->median_filter_len > MAX_MEDIAN_FILTER_LEN)
		track_median_arr->median_filter_len = MAX_MEDIAN_FILTER_LEN;

	if (track_median_arr->is_full == 0)
 802c788:	2b00      	cmp	r3, #0
 802c78a:	d0e0      	beq.n	802c74e <data_association+0x686>
 802c78c:	1e4b      	subs	r3, r1, #1
	else
	{
		float sorting_arr[MAX_MEDIAN_FILTER_LEN];

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
 802c78e:	2b0b      	cmp	r3, #11
 802c790:	f200 8154 	bhi.w	802ca3c <data_association+0x974>
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c794:	2b00      	cmp	r3, #0
 802c796:	f43f aeaa 	beq.w	802c4ee <data_association+0x426>
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c79a:	68d0      	ldr	r0, [r2, #12]
 802c79c:	9019      	str	r0, [sp, #100]	; 0x64

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c79e:	2b01      	cmp	r3, #1
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802c7a0:	6090      	str	r0, [r2, #8]

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c7a2:	f000 8145 	beq.w	802ca30 <data_association+0x968>
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c7a6:	6910      	ldr	r0, [r2, #16]
 802c7a8:	901a      	str	r0, [sp, #104]	; 0x68

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c7aa:	2b02      	cmp	r3, #2
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802c7ac:	60d0      	str	r0, [r2, #12]

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c7ae:	f000 813f 	beq.w	802ca30 <data_association+0x968>
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c7b2:	6950      	ldr	r0, [r2, #20]
 802c7b4:	901b      	str	r0, [sp, #108]	; 0x6c

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c7b6:	2b03      	cmp	r3, #3
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802c7b8:	6110      	str	r0, [r2, #16]

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c7ba:	930a      	str	r3, [sp, #40]	; 0x28
 802c7bc:	f47f ae68 	bne.w	802c490 <data_association+0x3c8>
 802c7c0:	e695      	b.n	802c4ee <data_association+0x426>
			track_ptr->angle = median_filtering(&median_angle_arr[track_id], track_ptr->angle);
		}
		else if ((track_ptr->speed_count % (num_of_chirps + 1)) != 0)
		{

			idx = (track_ptr->speed_count % (num_of_chirps + 1)) - 1;
 802c7c2:	3b01      	subs	r3, #1
 802c7c4:	2148      	movs	r1, #72	; 0x48
 802c7c6:	fb11 3109 	smlabb	r1, r1, r9, r3
 802c7ca:	eb08 0181 	add.w	r1, r8, r1, lsl #2

			track_ptr->rx1_angle_arg_re[idx] = target_measurement->rx1_angle_arg_re;
 802c7ce:	f8da 7010 	ldr.w	r7, [sl, #16]
 802c7d2:	624f      	str	r7, [r1, #36]	; 0x24

			track_ptr->rx1_angle_arg_im[idx] = target_measurement->rx1_angle_arg_im;
 802c7d4:	f8da 2014 	ldr.w	r2, [sl, #20]
 802c7d8:	664a      	str	r2, [r1, #100]	; 0x64
			track_ptr->angle = median_filtering(&median_angle_arr[track_id], track_ptr->angle);
		}
		else if ((track_ptr->speed_count % (num_of_chirps + 1)) != 0)
		{

			idx = (track_ptr->speed_count % (num_of_chirps + 1)) - 1;
 802c7da:	9313      	str	r3, [sp, #76]	; 0x4c

			track_ptr->rx1_angle_arg_re[idx] = target_measurement->rx1_angle_arg_re;

			track_ptr->rx1_angle_arg_im[idx] = target_measurement->rx1_angle_arg_im;

			track_ptr->rx2_angle_arg_re[idx] = target_measurement->rx2_angle_arg_re;
 802c7dc:	f8da 3018 	ldr.w	r3, [sl, #24]
 802c7e0:	f8c1 30a4 	str.w	r3, [r1, #164]	; 0xa4

			track_ptr->rx2_angle_arg_im[idx] = target_measurement->rx2_angle_arg_im;
 802c7e4:	f8da 001c 	ldr.w	r0, [sl, #28]
 802c7e8:	f8c1 00e4 	str.w	r0, [r1, #228]	; 0xe4

			target_angle_data T;

			T = compute_angle(track_ptr->rx1_angle_arg_re[idx], track_ptr->rx1_angle_arg_im[idx],
 802c7ec:	9000      	str	r0, [sp, #0]
//===========================================================================

float median_filtering(Median_Filtering_t *track_median_arr, float new_input)
{

	if( track_median_arr->median_filter_len > MAX_MEDIAN_FILTER_LEN)
 802c7ee:	f8df c250 	ldr.w	ip, [pc, #592]	; 802ca40 <data_association+0x978>

			track_ptr->rx2_angle_arg_im[idx] = target_measurement->rx2_angle_arg_im;

			target_angle_data T;

			T = compute_angle(track_ptr->rx1_angle_arg_re[idx], track_ptr->rx1_angle_arg_im[idx],
 802c7f2:	f8d6 0124 	ldr.w	r0, [r6, #292]	; 0x124
//===========================================================================

float median_filtering(Median_Filtering_t *track_median_arr, float new_input)
{

	if( track_median_arr->median_filter_len > MAX_MEDIAN_FILTER_LEN)
 802c7f6:	f8cd c034 	str.w	ip, [sp, #52]	; 0x34

			idx = (track_ptr->speed_count % (num_of_chirps + 1)) - 1;

			track_ptr->rx1_angle_arg_re[idx] = target_measurement->rx1_angle_arg_re;

			track_ptr->rx1_angle_arg_im[idx] = target_measurement->rx1_angle_arg_im;
 802c7fa:	920c      	str	r2, [sp, #48]	; 0x30

			track_ptr->rx2_angle_arg_re[idx] = target_measurement->rx2_angle_arg_re;
 802c7fc:	930a      	str	r3, [sp, #40]	; 0x28

			track_ptr->rx2_angle_arg_im[idx] = target_measurement->rx2_angle_arg_im;

			target_angle_data T;

			T = compute_angle(track_ptr->rx1_angle_arg_re[idx], track_ptr->rx1_angle_arg_im[idx],
 802c7fe:	f001 fb2f 	bl	802de60 <__aeabi_f2d>
 802c802:	f9bd e024 	ldrsh.w	lr, [sp, #36]	; 0x24
 802c806:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802c808:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 802c80a:	f8cd e010 	str.w	lr, [sp, #16]
 802c80e:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802c812:	edcd ca05 	vstr	s25, [sp, #20]
 802c816:	4639      	mov	r1, r7
 802c818:	a814      	add	r0, sp, #80	; 0x50
 802c81a:	f7fc fdb9 	bl	8029390 <compute_angle>
					track_ptr->rx2_angle_arg_re[idx], track_ptr->rx2_angle_arg_im[idx],track_ptr->d_phi, angle_offset_deg, wave_length_ant_spacing_ratio);

			track_ptr->angle = T.target_angle;
 802c81e:	f8dd a058 	ldr.w	sl, [sp, #88]	; 0x58
 802c822:	f8c6 a020 	str.w	sl, [r6, #32]
			track_ptr->d_phi = T.d_phi;
 802c826:	e9dd 0114 	ldrd	r0, r1, [sp, #80]	; 0x50
 802c82a:	f001 fe4f 	bl	802e4cc <__aeabi_d2f>
//===========================================================================

float median_filtering(Median_Filtering_t *track_median_arr, float new_input)
{

	if( track_median_arr->median_filter_len > MAX_MEDIAN_FILTER_LEN)
 802c82e:	ea4f 1709 	mov.w	r7, r9, lsl #4
 802c832:	f8dd c034 	ldr.w	ip, [sp, #52]	; 0x34

			T = compute_angle(track_ptr->rx1_angle_arg_re[idx], track_ptr->rx1_angle_arg_im[idx],
					track_ptr->rx2_angle_arg_re[idx], track_ptr->rx2_angle_arg_im[idx],track_ptr->d_phi, angle_offset_deg, wave_length_ant_spacing_ratio);

			track_ptr->angle = T.target_angle;
			track_ptr->d_phi = T.d_phi;
 802c836:	f8c6 0124 	str.w	r0, [r6, #292]	; 0x124
//===========================================================================

float median_filtering(Median_Filtering_t *track_median_arr, float new_input)
{

	if( track_median_arr->median_filter_len > MAX_MEDIAN_FILTER_LEN)
 802c83a:	ebc9 0207 	rsb	r2, r9, r7
 802c83e:	eb0c 0382 	add.w	r3, ip, r2, lsl #2
		track_median_arr->median_filter_len = MAX_MEDIAN_FILTER_LEN;

	if (track_median_arr->is_full == 0)
 802c842:	f81c 2022 	ldrb.w	r2, [ip, r2, lsl #2]
//===========================================================================

float median_filtering(Median_Filtering_t *track_median_arr, float new_input)
{

	if( track_median_arr->median_filter_len > MAX_MEDIAN_FILTER_LEN)
 802c846:	6859      	ldr	r1, [r3, #4]
 802c848:	290d      	cmp	r1, #13
 802c84a:	d917      	bls.n	802c87c <data_association+0x7b4>
		track_median_arr->median_filter_len = MAX_MEDIAN_FILTER_LEN;
 802c84c:	210d      	movs	r1, #13
 802c84e:	6059      	str	r1, [r3, #4]

	if (track_median_arr->is_full == 0)
 802c850:	2a00      	cmp	r2, #0
 802c852:	f000 80c4 	beq.w	802c9de <data_association+0x916>
 802c856:	220c      	movs	r2, #12
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c858:	ebc9 0307 	rsb	r3, r9, r7
 802c85c:	eb0c 0383 	add.w	r3, ip, r3, lsl #2
 802c860:	f8d3 e00c 	ldr.w	lr, [r3, #12]
 802c864:	691e      	ldr	r6, [r3, #16]
 802c866:	6958      	ldr	r0, [r3, #20]
 802c868:	f8cd e064 	str.w	lr, [sp, #100]	; 0x64

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802c86c:	f8c3 e008 	str.w	lr, [r3, #8]
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c870:	961a      	str	r6, [sp, #104]	; 0x68

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802c872:	60de      	str	r6, [r3, #12]
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c874:	901b      	str	r0, [sp, #108]	; 0x6c

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802c876:	6118      	str	r0, [r3, #16]
	}
	else
	{
		float sorting_arr[MAX_MEDIAN_FILTER_LEN];

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
 802c878:	200c      	movs	r0, #12
 802c87a:	e01c      	b.n	802c8b6 <data_association+0x7ee>
{

	if( track_median_arr->median_filter_len > MAX_MEDIAN_FILTER_LEN)
		track_median_arr->median_filter_len = MAX_MEDIAN_FILTER_LEN;

	if (track_median_arr->is_full == 0)
 802c87c:	2a00      	cmp	r2, #0
 802c87e:	f000 80ab 	beq.w	802c9d8 <data_association+0x910>
 802c882:	1e48      	subs	r0, r1, #1
	else
	{
		float sorting_arr[MAX_MEDIAN_FILTER_LEN];

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
 802c884:	280b      	cmp	r0, #11
 802c886:	f200 80d7 	bhi.w	802ca38 <data_association+0x970>
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c88a:	2800      	cmp	r0, #0
 802c88c:	f000 80c8 	beq.w	802ca20 <data_association+0x958>
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c890:	68da      	ldr	r2, [r3, #12]
 802c892:	9219      	str	r2, [sp, #100]	; 0x64

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c894:	2801      	cmp	r0, #1
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802c896:	609a      	str	r2, [r3, #8]

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c898:	f000 80c2 	beq.w	802ca20 <data_association+0x958>
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c89c:	691a      	ldr	r2, [r3, #16]
 802c89e:	921a      	str	r2, [sp, #104]	; 0x68

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c8a0:	2802      	cmp	r0, #2
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802c8a2:	60da      	str	r2, [r3, #12]

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c8a4:	f000 80bc 	beq.w	802ca20 <data_association+0x958>
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c8a8:	695a      	ldr	r2, [r3, #20]
 802c8aa:	921b      	str	r2, [sp, #108]	; 0x6c

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c8ac:	2803      	cmp	r0, #3
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802c8ae:	611a      	str	r2, [r3, #16]

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c8b0:	f000 80c0 	beq.w	802ca34 <data_association+0x96c>
 802c8b4:	4602      	mov	r2, r0
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c8b6:	ebc9 0307 	rsb	r3, r9, r7
 802c8ba:	eb0c 0383 	add.w	r3, ip, r3, lsl #2

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c8be:	2804      	cmp	r0, #4
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c8c0:	699e      	ldr	r6, [r3, #24]
 802c8c2:	961c      	str	r6, [sp, #112]	; 0x70

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802c8c4:	615e      	str	r6, [r3, #20]

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c8c6:	d025      	beq.n	802c914 <data_association+0x84c>
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c8c8:	69de      	ldr	r6, [r3, #28]
 802c8ca:	961d      	str	r6, [sp, #116]	; 0x74

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c8cc:	2805      	cmp	r0, #5
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802c8ce:	619e      	str	r6, [r3, #24]

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c8d0:	d020      	beq.n	802c914 <data_association+0x84c>
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c8d2:	6a1e      	ldr	r6, [r3, #32]
 802c8d4:	961e      	str	r6, [sp, #120]	; 0x78

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c8d6:	2806      	cmp	r0, #6
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802c8d8:	61de      	str	r6, [r3, #28]

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c8da:	d01b      	beq.n	802c914 <data_association+0x84c>
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c8dc:	6a5e      	ldr	r6, [r3, #36]	; 0x24
 802c8de:	961f      	str	r6, [sp, #124]	; 0x7c

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c8e0:	2807      	cmp	r0, #7
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802c8e2:	621e      	str	r6, [r3, #32]

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c8e4:	d016      	beq.n	802c914 <data_association+0x84c>
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c8e6:	6a9e      	ldr	r6, [r3, #40]	; 0x28
 802c8e8:	9620      	str	r6, [sp, #128]	; 0x80

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c8ea:	2808      	cmp	r0, #8
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802c8ec:	625e      	str	r6, [r3, #36]	; 0x24

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c8ee:	d011      	beq.n	802c914 <data_association+0x84c>
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c8f0:	6ade      	ldr	r6, [r3, #44]	; 0x2c
 802c8f2:	9621      	str	r6, [sp, #132]	; 0x84

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c8f4:	2809      	cmp	r0, #9
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802c8f6:	629e      	str	r6, [r3, #40]	; 0x28

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c8f8:	d00c      	beq.n	802c914 <data_association+0x84c>
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c8fa:	6b1e      	ldr	r6, [r3, #48]	; 0x30
 802c8fc:	9622      	str	r6, [sp, #136]	; 0x88

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c8fe:	280a      	cmp	r0, #10
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802c900:	62de      	str	r6, [r3, #44]	; 0x2c

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c902:	d007      	beq.n	802c914 <data_association+0x84c>
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c904:	6b5e      	ldr	r6, [r3, #52]	; 0x34
 802c906:	9623      	str	r6, [sp, #140]	; 0x8c

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c908:	280c      	cmp	r0, #12
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802c90a:	631e      	str	r6, [r3, #48]	; 0x30

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c90c:	d102      	bne.n	802c914 <data_association+0x84c>
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c90e:	6b98      	ldr	r0, [r3, #56]	; 0x38
 802c910:	9024      	str	r0, [sp, #144]	; 0x90

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802c912:	6358      	str	r0, [r3, #52]	; 0x34

		}

		track_median_arr->buffer[track_median_arr->median_filter_len-1] = new_input;
 802c914:	ebc9 0607 	rsb	r6, r9, r7
 802c918:	18b3      	adds	r3, r6, r2

		sorting_arr[track_median_arr->median_filter_len-1] = new_input;
 802c91a:	a826      	add	r0, sp, #152	; 0x98
 802c91c:	eb00 0782 	add.w	r7, r0, r2, lsl #2

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];

		}

		track_median_arr->buffer[track_median_arr->median_filter_len-1] = new_input;
 802c920:	eb0c 0383 	add.w	r3, ip, r3, lsl #2
 802c924:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
 802c928:	f8c3 a008 	str.w	sl, [r3, #8]

		sorting_arr[track_median_arr->median_filter_len-1] = new_input;

		qsort(sorting_arr, track_median_arr->median_filter_len, sizeof(float), compare_float);
 802c92c:	a819      	add	r0, sp, #100	; 0x64
 802c92e:	2204      	movs	r2, #4

		}

		track_median_arr->buffer[track_median_arr->median_filter_len-1] = new_input;

		sorting_arr[track_median_arr->median_filter_len-1] = new_input;
 802c930:	f847 ac34 	str.w	sl, [r7, #-52]
 802c934:	e5ec      	b.n	802c510 <data_association+0x448>

	if (track_ptr->strength > 1.0 * range_detection_threshold)
	{
		if (track_ptr->speed_count == 0)
		{
			track_ptr->rx1_angle_arg_re[0] = target_measurement->rx1_angle_arg_re;
 802c936:	f8da 7010 	ldr.w	r7, [sl, #16]
 802c93a:	6277      	str	r7, [r6, #36]	; 0x24

			track_ptr->rx1_angle_arg_im[0] = target_measurement->rx1_angle_arg_im;
 802c93c:	f8da 2014 	ldr.w	r2, [sl, #20]
 802c940:	6672      	str	r2, [r6, #100]	; 0x64

			track_ptr->rx2_angle_arg_re[0] = target_measurement->rx2_angle_arg_re;
 802c942:	f8da 3018 	ldr.w	r3, [sl, #24]
 802c946:	f8c6 30a4 	str.w	r3, [r6, #164]	; 0xa4

			track_ptr->rx2_angle_arg_im[0] = target_measurement->rx2_angle_arg_im;
 802c94a:	f8da 101c 	ldr.w	r1, [sl, #28]
 802c94e:	f8c6 10e4 	str.w	r1, [r6, #228]	; 0xe4

			target_angle_data T;

			T = compute_angle(track_ptr->rx1_angle_arg_re[0], track_ptr->rx1_angle_arg_im[0],
 802c952:	9100      	str	r1, [sp, #0]
//===========================================================================

float median_filtering(Median_Filtering_t *track_median_arr, float new_input)
{

	if( track_median_arr->median_filter_len > MAX_MEDIAN_FILTER_LEN)
 802c954:	f8df c0e8 	ldr.w	ip, [pc, #232]	; 802ca40 <data_association+0x978>

			track_ptr->rx2_angle_arg_im[0] = target_measurement->rx2_angle_arg_im;

			target_angle_data T;

			T = compute_angle(track_ptr->rx1_angle_arg_re[0], track_ptr->rx1_angle_arg_im[0],
 802c958:	f8d6 0124 	ldr.w	r0, [r6, #292]	; 0x124
//===========================================================================

float median_filtering(Median_Filtering_t *track_median_arr, float new_input)
{

	if( track_median_arr->median_filter_len > MAX_MEDIAN_FILTER_LEN)
 802c95c:	f8cd c034 	str.w	ip, [sp, #52]	; 0x34
	{
		if (track_ptr->speed_count == 0)
		{
			track_ptr->rx1_angle_arg_re[0] = target_measurement->rx1_angle_arg_re;

			track_ptr->rx1_angle_arg_im[0] = target_measurement->rx1_angle_arg_im;
 802c960:	920c      	str	r2, [sp, #48]	; 0x30

			track_ptr->rx2_angle_arg_re[0] = target_measurement->rx2_angle_arg_re;
 802c962:	930a      	str	r3, [sp, #40]	; 0x28

			track_ptr->rx2_angle_arg_im[0] = target_measurement->rx2_angle_arg_im;

			target_angle_data T;

			T = compute_angle(track_ptr->rx1_angle_arg_re[0], track_ptr->rx1_angle_arg_im[0],
 802c964:	f001 fa7c 	bl	802de60 <__aeabi_f2d>
 802c968:	f9bd e024 	ldrsh.w	lr, [sp, #36]	; 0x24
 802c96c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802c96e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 802c970:	f8cd e010 	str.w	lr, [sp, #16]
 802c974:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802c978:	edcd ca05 	vstr	s25, [sp, #20]
 802c97c:	4639      	mov	r1, r7
 802c97e:	a814      	add	r0, sp, #80	; 0x50
 802c980:	f7fc fd06 	bl	8029390 <compute_angle>
					track_ptr->rx2_angle_arg_re[0], track_ptr->rx2_angle_arg_im[0],track_ptr->d_phi, angle_offset_deg, wave_length_ant_spacing_ratio);

			track_ptr->angle = T.target_angle;
 802c984:	f8dd a058 	ldr.w	sl, [sp, #88]	; 0x58
 802c988:	f8c6 a020 	str.w	sl, [r6, #32]
			track_ptr->d_phi = T.d_phi;
 802c98c:	e9dd 0114 	ldrd	r0, r1, [sp, #80]	; 0x50
 802c990:	f001 fd9c 	bl	802e4cc <__aeabi_d2f>
//===========================================================================

float median_filtering(Median_Filtering_t *track_median_arr, float new_input)
{

	if( track_median_arr->median_filter_len > MAX_MEDIAN_FILTER_LEN)
 802c994:	ea4f 1709 	mov.w	r7, r9, lsl #4
 802c998:	f8dd c034 	ldr.w	ip, [sp, #52]	; 0x34

			T = compute_angle(track_ptr->rx1_angle_arg_re[0], track_ptr->rx1_angle_arg_im[0],
					track_ptr->rx2_angle_arg_re[0], track_ptr->rx2_angle_arg_im[0],track_ptr->d_phi, angle_offset_deg, wave_length_ant_spacing_ratio);

			track_ptr->angle = T.target_angle;
			track_ptr->d_phi = T.d_phi;
 802c99c:	f8c6 0124 	str.w	r0, [r6, #292]	; 0x124
//===========================================================================

float median_filtering(Median_Filtering_t *track_median_arr, float new_input)
{

	if( track_median_arr->median_filter_len > MAX_MEDIAN_FILTER_LEN)
 802c9a0:	ebc9 0207 	rsb	r2, r9, r7
 802c9a4:	eb0c 0382 	add.w	r3, ip, r2, lsl #2
		track_median_arr->median_filter_len = MAX_MEDIAN_FILTER_LEN;

	if (track_median_arr->is_full == 0)
 802c9a8:	f81c 2022 	ldrb.w	r2, [ip, r2, lsl #2]
//===========================================================================

float median_filtering(Median_Filtering_t *track_median_arr, float new_input)
{

	if( track_median_arr->median_filter_len > MAX_MEDIAN_FILTER_LEN)
 802c9ac:	6859      	ldr	r1, [r3, #4]
 802c9ae:	290d      	cmp	r1, #13
 802c9b0:	d903      	bls.n	802c9ba <data_association+0x8f2>
		track_median_arr->median_filter_len = MAX_MEDIAN_FILTER_LEN;
 802c9b2:	210d      	movs	r1, #13
 802c9b4:	6059      	str	r1, [r3, #4]

	if (track_median_arr->is_full == 0)
 802c9b6:	b122      	cbz	r2, 802c9c2 <data_association+0x8fa>
 802c9b8:	e74d      	b.n	802c856 <data_association+0x78e>
 802c9ba:	b9da      	cbnz	r2, 802c9f4 <data_association+0x92c>
	{
		for (uint32_t j = 0; j < track_median_arr->median_filter_len; j++)
 802c9bc:	2900      	cmp	r1, #0
 802c9be:	f43f aed1 	beq.w	802c764 <data_association+0x69c>
 802c9c2:	223c      	movs	r2, #60	; 0x3c
 802c9c4:	fb02 c209 	mla	r2, r2, r9, ip
 802c9c8:	3208      	adds	r2, #8
{

	if( track_median_arr->median_filter_len > MAX_MEDIAN_FILTER_LEN)
		track_median_arr->median_filter_len = MAX_MEDIAN_FILTER_LEN;

	if (track_median_arr->is_full == 0)
 802c9ca:	2300      	movs	r3, #0
	{
		for (uint32_t j = 0; j < track_median_arr->median_filter_len; j++)
 802c9cc:	3301      	adds	r3, #1
 802c9ce:	428b      	cmp	r3, r1
		{
			track_median_arr->buffer[j] = new_input;
 802c9d0:	f842 ab04 	str.w	sl, [r2], #4
	if( track_median_arr->median_filter_len > MAX_MEDIAN_FILTER_LEN)
		track_median_arr->median_filter_len = MAX_MEDIAN_FILTER_LEN;

	if (track_median_arr->is_full == 0)
	{
		for (uint32_t j = 0; j < track_median_arr->median_filter_len; j++)
 802c9d4:	d3fa      	bcc.n	802c9cc <data_association+0x904>
 802c9d6:	e6c5      	b.n	802c764 <data_association+0x69c>
 802c9d8:	2900      	cmp	r1, #0
 802c9da:	f43f aec3 	beq.w	802c764 <data_association+0x69c>
 802c9de:	223c      	movs	r2, #60	; 0x3c
 802c9e0:	fb02 c209 	mla	r2, r2, r9, ip
 802c9e4:	3208      	adds	r2, #8
{

	if( track_median_arr->median_filter_len > MAX_MEDIAN_FILTER_LEN)
		track_median_arr->median_filter_len = MAX_MEDIAN_FILTER_LEN;

	if (track_median_arr->is_full == 0)
 802c9e6:	2300      	movs	r3, #0
	{
		for (uint32_t j = 0; j < track_median_arr->median_filter_len; j++)
 802c9e8:	3301      	adds	r3, #1
 802c9ea:	428b      	cmp	r3, r1
		{
			track_median_arr->buffer[j] = new_input;
 802c9ec:	f842 ab04 	str.w	sl, [r2], #4
	if( track_median_arr->median_filter_len > MAX_MEDIAN_FILTER_LEN)
		track_median_arr->median_filter_len = MAX_MEDIAN_FILTER_LEN;

	if (track_median_arr->is_full == 0)
	{
		for (uint32_t j = 0; j < track_median_arr->median_filter_len; j++)
 802c9f0:	d3fa      	bcc.n	802c9e8 <data_association+0x920>
 802c9f2:	e6b7      	b.n	802c764 <data_association+0x69c>
 802c9f4:	1e48      	subs	r0, r1, #1
	else
	{
		float sorting_arr[MAX_MEDIAN_FILTER_LEN];

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
 802c9f6:	280b      	cmp	r0, #11
 802c9f8:	d81e      	bhi.n	802ca38 <data_association+0x970>
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802c9fa:	b188      	cbz	r0, 802ca20 <data_association+0x958>
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802c9fc:	68da      	ldr	r2, [r3, #12]
 802c9fe:	9219      	str	r2, [sp, #100]	; 0x64

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802ca00:	2801      	cmp	r0, #1
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802ca02:	609a      	str	r2, [r3, #8]

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802ca04:	d00c      	beq.n	802ca20 <data_association+0x958>
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802ca06:	691a      	ldr	r2, [r3, #16]
 802ca08:	921a      	str	r2, [sp, #104]	; 0x68

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802ca0a:	2802      	cmp	r0, #2
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802ca0c:	60da      	str	r2, [r3, #12]

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802ca0e:	d007      	beq.n	802ca20 <data_association+0x958>
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value
 802ca10:	695a      	ldr	r2, [r3, #20]
 802ca12:	921b      	str	r2, [sp, #108]	; 0x6c

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802ca14:	2803      	cmp	r0, #3
		{

			sorting_arr[j] = track_median_arr->buffer[j+1];		// shift the array left in order to add new value

			track_median_arr->buffer[j] = track_median_arr->buffer[j+1];
 802ca16:	611a      	str	r2, [r3, #16]

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802ca18:	4602      	mov	r2, r0
 802ca1a:	f47f af4c 	bne.w	802c8b6 <data_association+0x7ee>
 802ca1e:	e779      	b.n	802c914 <data_association+0x84c>
 802ca20:	4602      	mov	r2, r0
 802ca22:	e777      	b.n	802c914 <data_association+0x84c>

static uint8_t get_next_free_trackID(tracking_list_t *p_tracks )
{
	uint8_t i = 0;

	while(i < p_tracks->max_num_of_tracks)
 802ca24:	4602      	mov	r2, r0
 802ca26:	e5f4      	b.n	802c612 <data_association+0x54a>
	{
		if(p_tracks->elems[i].is_alived == 0)
 802ca28:	461a      	mov	r2, r3
 802ca2a:	e5f2      	b.n	802c612 <data_association+0x54a>

static uint8_t get_next_free_trackID(tracking_list_t *p_tracks )
{
	uint8_t i = 0;

	while(i < p_tracks->max_num_of_tracks)
 802ca2c:	4602      	mov	r2, r0
 802ca2e:	e678      	b.n	802c722 <data_association+0x65a>

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
			len = track_median_arr->median_filter_len-1;

		for (uint32_t j = 0; j < len; j++)
 802ca30:	930a      	str	r3, [sp, #40]	; 0x28
 802ca32:	e55c      	b.n	802c4ee <data_association+0x426>
 802ca34:	2203      	movs	r2, #3
 802ca36:	e76d      	b.n	802c914 <data_association+0x84c>
	else
	{
		float sorting_arr[MAX_MEDIAN_FILTER_LEN];

		uint32_t len = MAX_MEDIAN_FILTER_LEN-1;
		if( len > track_median_arr->median_filter_len-1)
 802ca38:	4602      	mov	r2, r0
 802ca3a:	e70d      	b.n	802c858 <data_association+0x790>
 802ca3c:	930a      	str	r3, [sp, #40]	; 0x28
 802ca3e:	e519      	b.n	802c474 <data_association+0x3ac>
 802ca40:	200049f4 	.word	0x200049f4
 802ca44:	f3af 8000 	nop.w

0802ca48 <median_filter_init>:
}

//===========================================================================

void median_filter_init( uint32_t median_filter_len )
{
 802ca48:	280c      	cmp	r0, #12
	for (uint32_t j = 0; j < sizeof(median_angle_arr)/sizeof(median_angle_arr[0]); j++)
	{
		median_angle_arr[j].is_full = 0;
 802ca4a:	4b13      	ldr	r3, [pc, #76]	; (802ca98 <median_filter_init+0x50>)
 802ca4c:	d912      	bls.n	802ca74 <median_filter_init+0x2c>
 802ca4e:	2100      	movs	r1, #0
		median_angle_arr[j].median_filter_len = MAX_MEDIAN_FILTER_LEN;
 802ca50:	220d      	movs	r2, #13

void median_filter_init( uint32_t median_filter_len )
{
	for (uint32_t j = 0; j < sizeof(median_angle_arr)/sizeof(median_angle_arr[0]); j++)
	{
		median_angle_arr[j].is_full = 0;
 802ca52:	7019      	strb	r1, [r3, #0]
 802ca54:	f883 103c 	strb.w	r1, [r3, #60]	; 0x3c
 802ca58:	f883 1078 	strb.w	r1, [r3, #120]	; 0x78
 802ca5c:	f883 10b4 	strb.w	r1, [r3, #180]	; 0xb4
 802ca60:	f883 10f0 	strb.w	r1, [r3, #240]	; 0xf0
		median_angle_arr[j].median_filter_len = MAX_MEDIAN_FILTER_LEN;
 802ca64:	605a      	str	r2, [r3, #4]
 802ca66:	641a      	str	r2, [r3, #64]	; 0x40
 802ca68:	67da      	str	r2, [r3, #124]	; 0x7c
 802ca6a:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
 802ca6e:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
 802ca72:	4770      	bx	lr

void median_filter_init( uint32_t median_filter_len )
{
	for (uint32_t j = 0; j < sizeof(median_angle_arr)/sizeof(median_angle_arr[0]); j++)
	{
		median_angle_arr[j].is_full = 0;
 802ca74:	2200      	movs	r2, #0
		median_angle_arr[j].median_filter_len = MAX_MEDIAN_FILTER_LEN;
		if( median_filter_len < MAX_MEDIAN_FILTER_LEN)
			median_angle_arr[j].median_filter_len = median_filter_len;
 802ca76:	6058      	str	r0, [r3, #4]
 802ca78:	6418      	str	r0, [r3, #64]	; 0x40
 802ca7a:	67d8      	str	r0, [r3, #124]	; 0x7c
 802ca7c:	f8c3 00b8 	str.w	r0, [r3, #184]	; 0xb8
 802ca80:	f8c3 00f4 	str.w	r0, [r3, #244]	; 0xf4

void median_filter_init( uint32_t median_filter_len )
{
	for (uint32_t j = 0; j < sizeof(median_angle_arr)/sizeof(median_angle_arr[0]); j++)
	{
		median_angle_arr[j].is_full = 0;
 802ca84:	701a      	strb	r2, [r3, #0]
 802ca86:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
 802ca8a:	f883 2078 	strb.w	r2, [r3, #120]	; 0x78
 802ca8e:	f883 20b4 	strb.w	r2, [r3, #180]	; 0xb4
 802ca92:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
 802ca96:	4770      	bx	lr
 802ca98:	200049f4 	.word	0x200049f4

0802ca9c <main>:
   2. MAIN METHOD
==============================================================================
 */

int main(void)
{
 802ca9c:	b508      	push	{r3, lr}
  DAVE_STATUS_t status;
  
  /* Initialize DAVE APPs */
  status = DAVE_Init();
 802ca9e:	f7fc fa53 	bl	8028f48 <DAVE_Init>
  
  if(status != DAVE_STATUS_SUCCESS)
 802caa2:	b100      	cbz	r0, 802caa6 <main+0xa>
  {
    /* Placeholder for error handler code.
     * The while loop below can be replaced with an user error handler. */
    XMC_DEBUG("DAVE APPs initialization failed\n");
    while(1U);
 802caa4:	e7fe      	b.n	802caa4 <main+0x8>
  }
  
  /* Register algorithm processing function:
   * Set the algorithm processing function pointer, it will
   * be used by the application for algorithm data processing */
  app_register_algo_process(range_doppler_do);
 802caa6:	4804      	ldr	r0, [pc, #16]	; (802cab8 <main+0x1c>)
 802caa8:	f7fe fd26 	bl	802b4f8 <app_register_algo_process>
  
  /* Initialize the application */
  app_init();
 802caac:	f7fe fc50 	bl	802b350 <app_init>
  
  /* Infinite loop */
  while(1U)
  {
    /* Main application process */
    app_process();
 802cab0:	f7fe fd28 	bl	802b504 <app_process>
  }
 802cab4:	e7fc      	b.n	802cab0 <main+0x14>
 802cab6:	bf00      	nop
 802cab8:	0802b5f9 	.word	0x0802b5f9

0802cabc <acq_completed_cb>:
   3. USER CALLBACK FUNCTIONS
==============================================================================
 */

void acq_completed_cb(void)
{
 802cabc:	4770      	bx	lr
 802cabe:	bf00      	nop

0802cac0 <algo_completed_cb>:
  
  */
}

void algo_completed_cb(void)
{
 802cac0:	4770      	bx	lr
 802cac2:	bf00      	nop
 802cac4:	0000      	movs	r0, r0
	...

0802cac8 <atan>:
 802cac8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802cacc:	4bc4      	ldr	r3, [pc, #784]	; (802cde0 <atan+0x318>)
 802cace:	f021 4600 	bic.w	r6, r1, #2147483648	; 0x80000000
 802cad2:	429e      	cmp	r6, r3
 802cad4:	4604      	mov	r4, r0
 802cad6:	460d      	mov	r5, r1
 802cad8:	468b      	mov	fp, r1
 802cada:	dd0e      	ble.n	802cafa <atan+0x32>
 802cadc:	4bc1      	ldr	r3, [pc, #772]	; (802cde4 <atan+0x31c>)
 802cade:	429e      	cmp	r6, r3
 802cae0:	f300 80ac 	bgt.w	802cc3c <atan+0x174>
 802cae4:	f000 80a7 	beq.w	802cc36 <atan+0x16e>
 802cae8:	f1bb 0f00 	cmp.w	fp, #0
 802caec:	f340 80e5 	ble.w	802ccba <atan+0x1f2>
 802caf0:	a19f      	add	r1, pc, #636	; (adr r1, 802cd70 <atan+0x2a8>)
 802caf2:	e9d1 0100 	ldrd	r0, r1, [r1]
 802caf6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802cafa:	4bbb      	ldr	r3, [pc, #748]	; (802cde8 <atan+0x320>)
 802cafc:	429e      	cmp	r6, r3
 802cafe:	f300 80b5 	bgt.w	802cc6c <atan+0x1a4>
 802cb02:	f1a3 73de 	sub.w	r3, r3, #29097984	; 0x1bc0000
 802cb06:	429e      	cmp	r6, r3
 802cb08:	f340 80a0 	ble.w	802cc4c <atan+0x184>
 802cb0c:	f04f 3aff 	mov.w	sl, #4294967295
 802cb10:	4622      	mov	r2, r4
 802cb12:	462b      	mov	r3, r5
 802cb14:	4620      	mov	r0, r4
 802cb16:	4629      	mov	r1, r5
 802cb18:	f001 f9f6 	bl	802df08 <__aeabi_dmul>
 802cb1c:	4602      	mov	r2, r0
 802cb1e:	460b      	mov	r3, r1
 802cb20:	4680      	mov	r8, r0
 802cb22:	4689      	mov	r9, r1
 802cb24:	f001 f9f0 	bl	802df08 <__aeabi_dmul>
 802cb28:	a393      	add	r3, pc, #588	; (adr r3, 802cd78 <atan+0x2b0>)
 802cb2a:	e9d3 2300 	ldrd	r2, r3, [r3]
 802cb2e:	4606      	mov	r6, r0
 802cb30:	460f      	mov	r7, r1
 802cb32:	f001 f9e9 	bl	802df08 <__aeabi_dmul>
 802cb36:	a392      	add	r3, pc, #584	; (adr r3, 802cd80 <atan+0x2b8>)
 802cb38:	e9d3 2300 	ldrd	r2, r3, [r3]
 802cb3c:	f001 f832 	bl	802dba4 <__adddf3>
 802cb40:	4632      	mov	r2, r6
 802cb42:	463b      	mov	r3, r7
 802cb44:	f001 f9e0 	bl	802df08 <__aeabi_dmul>
 802cb48:	a38f      	add	r3, pc, #572	; (adr r3, 802cd88 <atan+0x2c0>)
 802cb4a:	e9d3 2300 	ldrd	r2, r3, [r3]
 802cb4e:	f001 f829 	bl	802dba4 <__adddf3>
 802cb52:	4632      	mov	r2, r6
 802cb54:	463b      	mov	r3, r7
 802cb56:	f001 f9d7 	bl	802df08 <__aeabi_dmul>
 802cb5a:	a38d      	add	r3, pc, #564	; (adr r3, 802cd90 <atan+0x2c8>)
 802cb5c:	e9d3 2300 	ldrd	r2, r3, [r3]
 802cb60:	f001 f820 	bl	802dba4 <__adddf3>
 802cb64:	4632      	mov	r2, r6
 802cb66:	463b      	mov	r3, r7
 802cb68:	f001 f9ce 	bl	802df08 <__aeabi_dmul>
 802cb6c:	a38a      	add	r3, pc, #552	; (adr r3, 802cd98 <atan+0x2d0>)
 802cb6e:	e9d3 2300 	ldrd	r2, r3, [r3]
 802cb72:	f001 f817 	bl	802dba4 <__adddf3>
 802cb76:	4632      	mov	r2, r6
 802cb78:	463b      	mov	r3, r7
 802cb7a:	f001 f9c5 	bl	802df08 <__aeabi_dmul>
 802cb7e:	a388      	add	r3, pc, #544	; (adr r3, 802cda0 <atan+0x2d8>)
 802cb80:	e9d3 2300 	ldrd	r2, r3, [r3]
 802cb84:	f001 f80e 	bl	802dba4 <__adddf3>
 802cb88:	4642      	mov	r2, r8
 802cb8a:	464b      	mov	r3, r9
 802cb8c:	f001 f9bc 	bl	802df08 <__aeabi_dmul>
 802cb90:	a385      	add	r3, pc, #532	; (adr r3, 802cda8 <atan+0x2e0>)
 802cb92:	e9d3 2300 	ldrd	r2, r3, [r3]
 802cb96:	4680      	mov	r8, r0
 802cb98:	4689      	mov	r9, r1
 802cb9a:	4630      	mov	r0, r6
 802cb9c:	4639      	mov	r1, r7
 802cb9e:	f001 f9b3 	bl	802df08 <__aeabi_dmul>
 802cba2:	a383      	add	r3, pc, #524	; (adr r3, 802cdb0 <atan+0x2e8>)
 802cba4:	e9d3 2300 	ldrd	r2, r3, [r3]
 802cba8:	f000 fffa 	bl	802dba0 <__aeabi_dsub>
 802cbac:	4632      	mov	r2, r6
 802cbae:	463b      	mov	r3, r7
 802cbb0:	f001 f9aa 	bl	802df08 <__aeabi_dmul>
 802cbb4:	a380      	add	r3, pc, #512	; (adr r3, 802cdb8 <atan+0x2f0>)
 802cbb6:	e9d3 2300 	ldrd	r2, r3, [r3]
 802cbba:	f000 fff1 	bl	802dba0 <__aeabi_dsub>
 802cbbe:	4632      	mov	r2, r6
 802cbc0:	463b      	mov	r3, r7
 802cbc2:	f001 f9a1 	bl	802df08 <__aeabi_dmul>
 802cbc6:	a37e      	add	r3, pc, #504	; (adr r3, 802cdc0 <atan+0x2f8>)
 802cbc8:	e9d3 2300 	ldrd	r2, r3, [r3]
 802cbcc:	f000 ffe8 	bl	802dba0 <__aeabi_dsub>
 802cbd0:	4632      	mov	r2, r6
 802cbd2:	463b      	mov	r3, r7
 802cbd4:	f001 f998 	bl	802df08 <__aeabi_dmul>
 802cbd8:	a37b      	add	r3, pc, #492	; (adr r3, 802cdc8 <atan+0x300>)
 802cbda:	e9d3 2300 	ldrd	r2, r3, [r3]
 802cbde:	f000 ffdf 	bl	802dba0 <__aeabi_dsub>
 802cbe2:	4632      	mov	r2, r6
 802cbe4:	463b      	mov	r3, r7
 802cbe6:	f001 f98f 	bl	802df08 <__aeabi_dmul>
 802cbea:	f1ba 3fff 	cmp.w	sl, #4294967295
 802cbee:	4602      	mov	r2, r0
 802cbf0:	460b      	mov	r3, r1
 802cbf2:	d06b      	beq.n	802cccc <atan+0x204>
 802cbf4:	4640      	mov	r0, r8
 802cbf6:	4649      	mov	r1, r9
 802cbf8:	f000 ffd4 	bl	802dba4 <__adddf3>
 802cbfc:	4622      	mov	r2, r4
 802cbfe:	462b      	mov	r3, r5
 802cc00:	f001 f982 	bl	802df08 <__aeabi_dmul>
 802cc04:	4e79      	ldr	r6, [pc, #484]	; (802cdec <atan+0x324>)
 802cc06:	4b7a      	ldr	r3, [pc, #488]	; (802cdf0 <atan+0x328>)
 802cc08:	ea4f 0aca 	mov.w	sl, sl, lsl #3
 802cc0c:	4456      	add	r6, sl
 802cc0e:	449a      	add	sl, r3
 802cc10:	e9da 2300 	ldrd	r2, r3, [sl]
 802cc14:	f000 ffc4 	bl	802dba0 <__aeabi_dsub>
 802cc18:	4622      	mov	r2, r4
 802cc1a:	462b      	mov	r3, r5
 802cc1c:	f000 ffc0 	bl	802dba0 <__aeabi_dsub>
 802cc20:	4602      	mov	r2, r0
 802cc22:	460b      	mov	r3, r1
 802cc24:	e9d6 0100 	ldrd	r0, r1, [r6]
 802cc28:	f000 ffba 	bl	802dba0 <__aeabi_dsub>
 802cc2c:	f1bb 0f00 	cmp.w	fp, #0
 802cc30:	db48      	blt.n	802ccc4 <atan+0x1fc>
 802cc32:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802cc36:	2800      	cmp	r0, #0
 802cc38:	f43f af56 	beq.w	802cae8 <atan+0x20>
 802cc3c:	4620      	mov	r0, r4
 802cc3e:	4629      	mov	r1, r5
 802cc40:	4622      	mov	r2, r4
 802cc42:	462b      	mov	r3, r5
 802cc44:	f000 ffae 	bl	802dba4 <__adddf3>
 802cc48:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802cc4c:	a360      	add	r3, pc, #384	; (adr r3, 802cdd0 <atan+0x308>)
 802cc4e:	e9d3 2300 	ldrd	r2, r3, [r3]
 802cc52:	f000 ffa7 	bl	802dba4 <__adddf3>
 802cc56:	2200      	movs	r2, #0
 802cc58:	4b66      	ldr	r3, [pc, #408]	; (802cdf4 <atan+0x32c>)
 802cc5a:	f001 fbe5 	bl	802e428 <__aeabi_dcmpgt>
 802cc5e:	2800      	cmp	r0, #0
 802cc60:	f43f af54 	beq.w	802cb0c <atan+0x44>
 802cc64:	4620      	mov	r0, r4
 802cc66:	4629      	mov	r1, r5
 802cc68:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802cc6c:	f000 f8cc 	bl	802ce08 <fabs>
 802cc70:	4b61      	ldr	r3, [pc, #388]	; (802cdf8 <atan+0x330>)
 802cc72:	429e      	cmp	r6, r3
 802cc74:	4604      	mov	r4, r0
 802cc76:	460d      	mov	r5, r1
 802cc78:	dc38      	bgt.n	802ccec <atan+0x224>
 802cc7a:	f5a3 2350 	sub.w	r3, r3, #851968	; 0xd0000
 802cc7e:	429e      	cmp	r6, r3
 802cc80:	dc5d      	bgt.n	802cd3e <atan+0x276>
 802cc82:	4602      	mov	r2, r0
 802cc84:	460b      	mov	r3, r1
 802cc86:	f000 ff8d 	bl	802dba4 <__adddf3>
 802cc8a:	2200      	movs	r2, #0
 802cc8c:	4b59      	ldr	r3, [pc, #356]	; (802cdf4 <atan+0x32c>)
 802cc8e:	f000 ff87 	bl	802dba0 <__aeabi_dsub>
 802cc92:	2200      	movs	r2, #0
 802cc94:	4606      	mov	r6, r0
 802cc96:	460f      	mov	r7, r1
 802cc98:	4620      	mov	r0, r4
 802cc9a:	4629      	mov	r1, r5
 802cc9c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 802cca0:	f000 ff80 	bl	802dba4 <__adddf3>
 802cca4:	4602      	mov	r2, r0
 802cca6:	460b      	mov	r3, r1
 802cca8:	4630      	mov	r0, r6
 802ccaa:	4639      	mov	r1, r7
 802ccac:	f001 fa56 	bl	802e15c <__aeabi_ddiv>
 802ccb0:	f04f 0a00 	mov.w	sl, #0
 802ccb4:	4604      	mov	r4, r0
 802ccb6:	460d      	mov	r5, r1
 802ccb8:	e72a      	b.n	802cb10 <atan+0x48>
 802ccba:	a147      	add	r1, pc, #284	; (adr r1, 802cdd8 <atan+0x310>)
 802ccbc:	e9d1 0100 	ldrd	r0, r1, [r1]
 802ccc0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802ccc4:	f101 4100 	add.w	r1, r1, #2147483648	; 0x80000000
 802ccc8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802cccc:	4640      	mov	r0, r8
 802ccce:	4649      	mov	r1, r9
 802ccd0:	f000 ff68 	bl	802dba4 <__adddf3>
 802ccd4:	4622      	mov	r2, r4
 802ccd6:	462b      	mov	r3, r5
 802ccd8:	f001 f916 	bl	802df08 <__aeabi_dmul>
 802ccdc:	4602      	mov	r2, r0
 802ccde:	460b      	mov	r3, r1
 802cce0:	4620      	mov	r0, r4
 802cce2:	4629      	mov	r1, r5
 802cce4:	f000 ff5c 	bl	802dba0 <__aeabi_dsub>
 802cce8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802ccec:	4b43      	ldr	r3, [pc, #268]	; (802cdfc <atan+0x334>)
 802ccee:	429e      	cmp	r6, r3
 802ccf0:	dc1a      	bgt.n	802cd28 <atan+0x260>
 802ccf2:	2200      	movs	r2, #0
 802ccf4:	4b42      	ldr	r3, [pc, #264]	; (802ce00 <atan+0x338>)
 802ccf6:	f000 ff53 	bl	802dba0 <__aeabi_dsub>
 802ccfa:	2200      	movs	r2, #0
 802ccfc:	4606      	mov	r6, r0
 802ccfe:	460f      	mov	r7, r1
 802cd00:	4620      	mov	r0, r4
 802cd02:	4629      	mov	r1, r5
 802cd04:	4b3e      	ldr	r3, [pc, #248]	; (802ce00 <atan+0x338>)
 802cd06:	f001 f8ff 	bl	802df08 <__aeabi_dmul>
 802cd0a:	2200      	movs	r2, #0
 802cd0c:	4b39      	ldr	r3, [pc, #228]	; (802cdf4 <atan+0x32c>)
 802cd0e:	f000 ff49 	bl	802dba4 <__adddf3>
 802cd12:	4602      	mov	r2, r0
 802cd14:	460b      	mov	r3, r1
 802cd16:	4630      	mov	r0, r6
 802cd18:	4639      	mov	r1, r7
 802cd1a:	f001 fa1f 	bl	802e15c <__aeabi_ddiv>
 802cd1e:	f04f 0a02 	mov.w	sl, #2
 802cd22:	4604      	mov	r4, r0
 802cd24:	460d      	mov	r5, r1
 802cd26:	e6f3      	b.n	802cb10 <atan+0x48>
 802cd28:	4602      	mov	r2, r0
 802cd2a:	460b      	mov	r3, r1
 802cd2c:	2000      	movs	r0, #0
 802cd2e:	4935      	ldr	r1, [pc, #212]	; (802ce04 <atan+0x33c>)
 802cd30:	f001 fa14 	bl	802e15c <__aeabi_ddiv>
 802cd34:	f04f 0a03 	mov.w	sl, #3
 802cd38:	4604      	mov	r4, r0
 802cd3a:	460d      	mov	r5, r1
 802cd3c:	e6e8      	b.n	802cb10 <atan+0x48>
 802cd3e:	2200      	movs	r2, #0
 802cd40:	4b2c      	ldr	r3, [pc, #176]	; (802cdf4 <atan+0x32c>)
 802cd42:	f000 ff2d 	bl	802dba0 <__aeabi_dsub>
 802cd46:	2200      	movs	r2, #0
 802cd48:	4606      	mov	r6, r0
 802cd4a:	460f      	mov	r7, r1
 802cd4c:	4620      	mov	r0, r4
 802cd4e:	4629      	mov	r1, r5
 802cd50:	4b28      	ldr	r3, [pc, #160]	; (802cdf4 <atan+0x32c>)
 802cd52:	f000 ff27 	bl	802dba4 <__adddf3>
 802cd56:	4602      	mov	r2, r0
 802cd58:	460b      	mov	r3, r1
 802cd5a:	4630      	mov	r0, r6
 802cd5c:	4639      	mov	r1, r7
 802cd5e:	f001 f9fd 	bl	802e15c <__aeabi_ddiv>
 802cd62:	f04f 0a01 	mov.w	sl, #1
 802cd66:	4604      	mov	r4, r0
 802cd68:	460d      	mov	r5, r1
 802cd6a:	e6d1      	b.n	802cb10 <atan+0x48>
 802cd6c:	f3af 8000 	nop.w
 802cd70:	54442d18 	.word	0x54442d18
 802cd74:	3ff921fb 	.word	0x3ff921fb
 802cd78:	e322da11 	.word	0xe322da11
 802cd7c:	3f90ad3a 	.word	0x3f90ad3a
 802cd80:	24760deb 	.word	0x24760deb
 802cd84:	3fa97b4b 	.word	0x3fa97b4b
 802cd88:	a0d03d51 	.word	0xa0d03d51
 802cd8c:	3fb10d66 	.word	0x3fb10d66
 802cd90:	c54c206e 	.word	0xc54c206e
 802cd94:	3fb745cd 	.word	0x3fb745cd
 802cd98:	920083ff 	.word	0x920083ff
 802cd9c:	3fc24924 	.word	0x3fc24924
 802cda0:	5555550d 	.word	0x5555550d
 802cda4:	3fd55555 	.word	0x3fd55555
 802cda8:	2c6a6c2f 	.word	0x2c6a6c2f
 802cdac:	bfa2b444 	.word	0xbfa2b444
 802cdb0:	52defd9a 	.word	0x52defd9a
 802cdb4:	3fadde2d 	.word	0x3fadde2d
 802cdb8:	af749a6d 	.word	0xaf749a6d
 802cdbc:	3fb3b0f2 	.word	0x3fb3b0f2
 802cdc0:	fe231671 	.word	0xfe231671
 802cdc4:	3fbc71c6 	.word	0x3fbc71c6
 802cdc8:	9998ebc4 	.word	0x9998ebc4
 802cdcc:	3fc99999 	.word	0x3fc99999
 802cdd0:	8800759c 	.word	0x8800759c
 802cdd4:	7e37e43c 	.word	0x7e37e43c
 802cdd8:	54442d18 	.word	0x54442d18
 802cddc:	bff921fb 	.word	0xbff921fb
 802cde0:	440fffff 	.word	0x440fffff
 802cde4:	7ff00000 	.word	0x7ff00000
 802cde8:	3fdbffff 	.word	0x3fdbffff
 802cdec:	08031e18 	.word	0x08031e18
 802cdf0:	08031df8 	.word	0x08031df8
 802cdf4:	3ff00000 	.word	0x3ff00000
 802cdf8:	3ff2ffff 	.word	0x3ff2ffff
 802cdfc:	40037fff 	.word	0x40037fff
 802ce00:	3ff80000 	.word	0x3ff80000
 802ce04:	bff00000 	.word	0xbff00000

0802ce08 <fabs>:
 802ce08:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 802ce0c:	4770      	bx	lr
 802ce0e:	bf00      	nop

0802ce10 <asin>:
 802ce10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802ce14:	f8df 809c 	ldr.w	r8, [pc, #156]	; 802ceb4 <asin+0xa4>
 802ce18:	b08a      	sub	sp, #40	; 0x28
 802ce1a:	4606      	mov	r6, r0
 802ce1c:	460f      	mov	r7, r1
 802ce1e:	f000 f97b 	bl	802d118 <__ieee754_asin>
 802ce22:	f998 3000 	ldrsb.w	r3, [r8]
 802ce26:	3301      	adds	r3, #1
 802ce28:	4604      	mov	r4, r0
 802ce2a:	460d      	mov	r5, r1
 802ce2c:	d004      	beq.n	802ce38 <asin+0x28>
 802ce2e:	4630      	mov	r0, r6
 802ce30:	4639      	mov	r1, r7
 802ce32:	f000 fe63 	bl	802dafc <__fpclassifyd>
 802ce36:	b920      	cbnz	r0, 802ce42 <asin+0x32>
 802ce38:	4620      	mov	r0, r4
 802ce3a:	4629      	mov	r1, r5
 802ce3c:	b00a      	add	sp, #40	; 0x28
 802ce3e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802ce42:	4630      	mov	r0, r6
 802ce44:	4639      	mov	r1, r7
 802ce46:	f7ff ffdf 	bl	802ce08 <fabs>
 802ce4a:	2200      	movs	r2, #0
 802ce4c:	4b16      	ldr	r3, [pc, #88]	; (802cea8 <asin+0x98>)
 802ce4e:	f001 faeb 	bl	802e428 <__aeabi_dcmpgt>
 802ce52:	2800      	cmp	r0, #0
 802ce54:	d0f0      	beq.n	802ce38 <asin+0x28>
 802ce56:	2301      	movs	r3, #1
 802ce58:	4a14      	ldr	r2, [pc, #80]	; (802ceac <asin+0x9c>)
 802ce5a:	9300      	str	r3, [sp, #0]
 802ce5c:	4814      	ldr	r0, [pc, #80]	; (802ceb0 <asin+0xa0>)
 802ce5e:	9201      	str	r2, [sp, #4]
 802ce60:	2300      	movs	r3, #0
 802ce62:	9308      	str	r3, [sp, #32]
 802ce64:	e9cd 6704 	strd	r6, r7, [sp, #16]
 802ce68:	e9cd 6702 	strd	r6, r7, [sp, #8]
 802ce6c:	f000 fe74 	bl	802db58 <nan>
 802ce70:	f998 3000 	ldrsb.w	r3, [r8]
 802ce74:	2b02      	cmp	r3, #2
 802ce76:	e9cd 0106 	strd	r0, r1, [sp, #24]
 802ce7a:	d00a      	beq.n	802ce92 <asin+0x82>
 802ce7c:	4668      	mov	r0, sp
 802ce7e:	f000 fe69 	bl	802db54 <matherr>
 802ce82:	b130      	cbz	r0, 802ce92 <asin+0x82>
 802ce84:	9b08      	ldr	r3, [sp, #32]
 802ce86:	b94b      	cbnz	r3, 802ce9c <asin+0x8c>
 802ce88:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 802ce8c:	b00a      	add	sp, #40	; 0x28
 802ce8e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802ce92:	f001 fe73 	bl	802eb7c <__errno>
 802ce96:	2321      	movs	r3, #33	; 0x21
 802ce98:	6003      	str	r3, [r0, #0]
 802ce9a:	e7f3      	b.n	802ce84 <asin+0x74>
 802ce9c:	f001 fe6e 	bl	802eb7c <__errno>
 802cea0:	9b08      	ldr	r3, [sp, #32]
 802cea2:	6003      	str	r3, [r0, #0]
 802cea4:	e7f0      	b.n	802ce88 <asin+0x78>
 802cea6:	bf00      	nop
 802cea8:	3ff00000 	.word	0x3ff00000
 802ceac:	08031e38 	.word	0x08031e38
 802ceb0:	08031e4c 	.word	0x08031e4c
 802ceb4:	1ffe9640 	.word	0x1ffe9640

0802ceb8 <fmodf>:
 802ceb8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 802cebc:	4d2a      	ldr	r5, [pc, #168]	; (802cf68 <fmodf+0xb0>)
 802cebe:	b08b      	sub	sp, #44	; 0x2c
 802cec0:	4607      	mov	r7, r0
 802cec2:	460e      	mov	r6, r1
 802cec4:	f000 fc20 	bl	802d708 <__ieee754_fmodf>
 802cec8:	f995 3000 	ldrsb.w	r3, [r5]
 802cecc:	3301      	adds	r3, #1
 802cece:	4604      	mov	r4, r0
 802ced0:	d003      	beq.n	802ceda <fmodf+0x22>
 802ced2:	4630      	mov	r0, r6
 802ced4:	f000 fe46 	bl	802db64 <__fpclassifyf>
 802ced8:	b918      	cbnz	r0, 802cee2 <fmodf+0x2a>
 802ceda:	4620      	mov	r0, r4
 802cedc:	b00b      	add	sp, #44	; 0x2c
 802cede:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 802cee2:	4638      	mov	r0, r7
 802cee4:	f000 fe3e 	bl	802db64 <__fpclassifyf>
 802cee8:	2800      	cmp	r0, #0
 802ceea:	d0f6      	beq.n	802ceda <fmodf+0x22>
 802ceec:	ee07 6a90 	vmov	s15, r6
 802cef0:	eef5 7a40 	vcmp.f32	s15, #0.0
 802cef4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802cef8:	d1ef      	bne.n	802ceda <fmodf+0x22>
 802cefa:	2301      	movs	r3, #1
 802cefc:	4a1b      	ldr	r2, [pc, #108]	; (802cf6c <fmodf+0xb4>)
 802cefe:	9300      	str	r3, [sp, #0]
 802cf00:	4638      	mov	r0, r7
 802cf02:	2300      	movs	r3, #0
 802cf04:	9201      	str	r2, [sp, #4]
 802cf06:	9308      	str	r3, [sp, #32]
 802cf08:	f000 ffaa 	bl	802de60 <__aeabi_f2d>
 802cf0c:	4680      	mov	r8, r0
 802cf0e:	4689      	mov	r9, r1
 802cf10:	4630      	mov	r0, r6
 802cf12:	e9cd 8902 	strd	r8, r9, [sp, #8]
 802cf16:	f000 ffa3 	bl	802de60 <__aeabi_f2d>
 802cf1a:	782c      	ldrb	r4, [r5, #0]
 802cf1c:	e9cd 0104 	strd	r0, r1, [sp, #16]
 802cf20:	b1a4      	cbz	r4, 802cf4c <fmodf+0x94>
 802cf22:	2000      	movs	r0, #0
 802cf24:	2100      	movs	r1, #0
 802cf26:	4602      	mov	r2, r0
 802cf28:	460b      	mov	r3, r1
 802cf2a:	f001 f917 	bl	802e15c <__aeabi_ddiv>
 802cf2e:	2c02      	cmp	r4, #2
 802cf30:	e9cd 0106 	strd	r0, r1, [sp, #24]
 802cf34:	d10c      	bne.n	802cf50 <fmodf+0x98>
 802cf36:	f001 fe21 	bl	802eb7c <__errno>
 802cf3a:	2321      	movs	r3, #33	; 0x21
 802cf3c:	6003      	str	r3, [r0, #0]
 802cf3e:	9b08      	ldr	r3, [sp, #32]
 802cf40:	b963      	cbnz	r3, 802cf5c <fmodf+0xa4>
 802cf42:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 802cf46:	f001 fac1 	bl	802e4cc <__aeabi_d2f>
 802cf4a:	e7c7      	b.n	802cedc <fmodf+0x24>
 802cf4c:	e9cd 8906 	strd	r8, r9, [sp, #24]
 802cf50:	4668      	mov	r0, sp
 802cf52:	f000 fdff 	bl	802db54 <matherr>
 802cf56:	2800      	cmp	r0, #0
 802cf58:	d1f1      	bne.n	802cf3e <fmodf+0x86>
 802cf5a:	e7ec      	b.n	802cf36 <fmodf+0x7e>
 802cf5c:	f001 fe0e 	bl	802eb7c <__errno>
 802cf60:	9b08      	ldr	r3, [sp, #32]
 802cf62:	6003      	str	r3, [r0, #0]
 802cf64:	e7ed      	b.n	802cf42 <fmodf+0x8a>
 802cf66:	bf00      	nop
 802cf68:	1ffe9640 	.word	0x1ffe9640
 802cf6c:	08031e40 	.word	0x08031e40

0802cf70 <logf>:
 802cf70:	b530      	push	{r4, r5, lr}
 802cf72:	ed2d 8b02 	vpush	{d8}
 802cf76:	4d37      	ldr	r5, [pc, #220]	; (802d054 <logf+0xe4>)
 802cf78:	b08b      	sub	sp, #44	; 0x2c
 802cf7a:	ee08 0a10 	vmov	s16, r0
 802cf7e:	f000 fc53 	bl	802d828 <__ieee754_logf>
 802cf82:	f995 3000 	ldrsb.w	r3, [r5]
 802cf86:	3301      	adds	r3, #1
 802cf88:	4604      	mov	r4, r0
 802cf8a:	d009      	beq.n	802cfa0 <logf+0x30>
 802cf8c:	ee18 0a10 	vmov	r0, s16
 802cf90:	f000 fde8 	bl	802db64 <__fpclassifyf>
 802cf94:	b120      	cbz	r0, 802cfa0 <logf+0x30>
 802cf96:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 802cf9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802cf9e:	dd04      	ble.n	802cfaa <logf+0x3a>
 802cfa0:	4620      	mov	r0, r4
 802cfa2:	b00b      	add	sp, #44	; 0x2c
 802cfa4:	ecbd 8b02 	vpop	{d8}
 802cfa8:	bd30      	pop	{r4, r5, pc}
 802cfaa:	4b2b      	ldr	r3, [pc, #172]	; (802d058 <logf+0xe8>)
 802cfac:	9301      	str	r3, [sp, #4]
 802cfae:	ee18 0a10 	vmov	r0, s16
 802cfb2:	2300      	movs	r3, #0
 802cfb4:	9308      	str	r3, [sp, #32]
 802cfb6:	f000 ff53 	bl	802de60 <__aeabi_f2d>
 802cfba:	782b      	ldrb	r3, [r5, #0]
 802cfbc:	e9cd 0104 	strd	r0, r1, [sp, #16]
 802cfc0:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802cfc4:	b983      	cbnz	r3, 802cfe8 <logf+0x78>
 802cfc6:	4b25      	ldr	r3, [pc, #148]	; (802d05c <logf+0xec>)
 802cfc8:	eeb5 8a40 	vcmp.f32	s16, #0.0
 802cfcc:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 802cfd0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802cfd4:	e9cd 2306 	strd	r2, r3, [sp, #24]
 802cfd8:	d034      	beq.n	802d044 <logf+0xd4>
 802cfda:	2301      	movs	r3, #1
 802cfdc:	9300      	str	r3, [sp, #0]
 802cfde:	4668      	mov	r0, sp
 802cfe0:	f000 fdb8 	bl	802db54 <matherr>
 802cfe4:	b988      	cbnz	r0, 802d00a <logf+0x9a>
 802cfe6:	e00c      	b.n	802d002 <logf+0x92>
 802cfe8:	491d      	ldr	r1, [pc, #116]	; (802d060 <logf+0xf0>)
 802cfea:	eeb5 8a40 	vcmp.f32	s16, #0.0
 802cfee:	2000      	movs	r0, #0
 802cff0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802cff4:	e9cd 0106 	strd	r0, r1, [sp, #24]
 802cff8:	d016      	beq.n	802d028 <logf+0xb8>
 802cffa:	2201      	movs	r2, #1
 802cffc:	2b02      	cmp	r3, #2
 802cffe:	9200      	str	r2, [sp, #0]
 802d000:	d1ed      	bne.n	802cfde <logf+0x6e>
 802d002:	f001 fdbb 	bl	802eb7c <__errno>
 802d006:	2321      	movs	r3, #33	; 0x21
 802d008:	6003      	str	r3, [r0, #0]
 802d00a:	4816      	ldr	r0, [pc, #88]	; (802d064 <logf+0xf4>)
 802d00c:	f000 fda4 	bl	802db58 <nan>
 802d010:	e9cd 0106 	strd	r0, r1, [sp, #24]
 802d014:	9b08      	ldr	r3, [sp, #32]
 802d016:	b9c3      	cbnz	r3, 802d04a <logf+0xda>
 802d018:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 802d01c:	f001 fa56 	bl	802e4cc <__aeabi_d2f>
 802d020:	b00b      	add	sp, #44	; 0x2c
 802d022:	ecbd 8b02 	vpop	{d8}
 802d026:	bd30      	pop	{r4, r5, pc}
 802d028:	2202      	movs	r2, #2
 802d02a:	4293      	cmp	r3, r2
 802d02c:	9200      	str	r2, [sp, #0]
 802d02e:	d004      	beq.n	802d03a <logf+0xca>
 802d030:	4668      	mov	r0, sp
 802d032:	f000 fd8f 	bl	802db54 <matherr>
 802d036:	2800      	cmp	r0, #0
 802d038:	d1ec      	bne.n	802d014 <logf+0xa4>
 802d03a:	f001 fd9f 	bl	802eb7c <__errno>
 802d03e:	2322      	movs	r3, #34	; 0x22
 802d040:	6003      	str	r3, [r0, #0]
 802d042:	e7e7      	b.n	802d014 <logf+0xa4>
 802d044:	2302      	movs	r3, #2
 802d046:	9300      	str	r3, [sp, #0]
 802d048:	e7f2      	b.n	802d030 <logf+0xc0>
 802d04a:	f001 fd97 	bl	802eb7c <__errno>
 802d04e:	9b08      	ldr	r3, [sp, #32]
 802d050:	6003      	str	r3, [r0, #0]
 802d052:	e7e1      	b.n	802d018 <logf+0xa8>
 802d054:	1ffe9640 	.word	0x1ffe9640
 802d058:	08031e48 	.word	0x08031e48
 802d05c:	c7efffff 	.word	0xc7efffff
 802d060:	fff00000 	.word	0xfff00000
 802d064:	08031e4c 	.word	0x08031e4c

0802d068 <sqrtf>:
 802d068:	b530      	push	{r4, r5, lr}
 802d06a:	ed2d 8b02 	vpush	{d8}
 802d06e:	4d28      	ldr	r5, [pc, #160]	; (802d110 <sqrtf+0xa8>)
 802d070:	b08b      	sub	sp, #44	; 0x2c
 802d072:	ee08 0a10 	vmov	s16, r0
 802d076:	f000 fceb 	bl	802da50 <__ieee754_sqrtf>
 802d07a:	f995 3000 	ldrsb.w	r3, [r5]
 802d07e:	3301      	adds	r3, #1
 802d080:	4604      	mov	r4, r0
 802d082:	d009      	beq.n	802d098 <sqrtf+0x30>
 802d084:	ee18 0a10 	vmov	r0, s16
 802d088:	f000 fd6c 	bl	802db64 <__fpclassifyf>
 802d08c:	b120      	cbz	r0, 802d098 <sqrtf+0x30>
 802d08e:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 802d092:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802d096:	d404      	bmi.n	802d0a2 <sqrtf+0x3a>
 802d098:	4620      	mov	r0, r4
 802d09a:	b00b      	add	sp, #44	; 0x2c
 802d09c:	ecbd 8b02 	vpop	{d8}
 802d0a0:	bd30      	pop	{r4, r5, pc}
 802d0a2:	2301      	movs	r3, #1
 802d0a4:	4a1b      	ldr	r2, [pc, #108]	; (802d114 <sqrtf+0xac>)
 802d0a6:	9300      	str	r3, [sp, #0]
 802d0a8:	ee18 0a10 	vmov	r0, s16
 802d0ac:	2300      	movs	r3, #0
 802d0ae:	9201      	str	r2, [sp, #4]
 802d0b0:	9308      	str	r3, [sp, #32]
 802d0b2:	f000 fed5 	bl	802de60 <__aeabi_f2d>
 802d0b6:	782c      	ldrb	r4, [r5, #0]
 802d0b8:	e9cd 0104 	strd	r0, r1, [sp, #16]
 802d0bc:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802d0c0:	b98c      	cbnz	r4, 802d0e6 <sqrtf+0x7e>
 802d0c2:	2200      	movs	r2, #0
 802d0c4:	2300      	movs	r3, #0
 802d0c6:	e9cd 2306 	strd	r2, r3, [sp, #24]
 802d0ca:	4668      	mov	r0, sp
 802d0cc:	f000 fd42 	bl	802db54 <matherr>
 802d0d0:	b198      	cbz	r0, 802d0fa <sqrtf+0x92>
 802d0d2:	9b08      	ldr	r3, [sp, #32]
 802d0d4:	b9b3      	cbnz	r3, 802d104 <sqrtf+0x9c>
 802d0d6:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 802d0da:	f001 f9f7 	bl	802e4cc <__aeabi_d2f>
 802d0de:	b00b      	add	sp, #44	; 0x2c
 802d0e0:	ecbd 8b02 	vpop	{d8}
 802d0e4:	bd30      	pop	{r4, r5, pc}
 802d0e6:	2000      	movs	r0, #0
 802d0e8:	2100      	movs	r1, #0
 802d0ea:	4602      	mov	r2, r0
 802d0ec:	460b      	mov	r3, r1
 802d0ee:	f001 f835 	bl	802e15c <__aeabi_ddiv>
 802d0f2:	2c02      	cmp	r4, #2
 802d0f4:	e9cd 0106 	strd	r0, r1, [sp, #24]
 802d0f8:	d1e7      	bne.n	802d0ca <sqrtf+0x62>
 802d0fa:	f001 fd3f 	bl	802eb7c <__errno>
 802d0fe:	2321      	movs	r3, #33	; 0x21
 802d100:	6003      	str	r3, [r0, #0]
 802d102:	e7e6      	b.n	802d0d2 <sqrtf+0x6a>
 802d104:	f001 fd3a 	bl	802eb7c <__errno>
 802d108:	9b08      	ldr	r3, [sp, #32]
 802d10a:	6003      	str	r3, [r0, #0]
 802d10c:	e7e3      	b.n	802d0d6 <sqrtf+0x6e>
 802d10e:	bf00      	nop
 802d110:	1ffe9640 	.word	0x1ffe9640
 802d114:	08031e50 	.word	0x08031e50

0802d118 <__ieee754_asin>:
 802d118:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802d11c:	4bc0      	ldr	r3, [pc, #768]	; (802d420 <__ieee754_asin+0x308>)
 802d11e:	f021 4600 	bic.w	r6, r1, #2147483648	; 0x80000000
 802d122:	429e      	cmp	r6, r3
 802d124:	b086      	sub	sp, #24
 802d126:	4604      	mov	r4, r0
 802d128:	460d      	mov	r5, r1
 802d12a:	468a      	mov	sl, r1
 802d12c:	dd11      	ble.n	802d152 <__ieee754_asin+0x3a>
 802d12e:	f106 4640 	add.w	r6, r6, #3221225472	; 0xc0000000
 802d132:	f506 1680 	add.w	r6, r6, #1048576	; 0x100000
 802d136:	4603      	mov	r3, r0
 802d138:	4333      	orrs	r3, r6
 802d13a:	d020      	beq.n	802d17e <__ieee754_asin+0x66>
 802d13c:	4602      	mov	r2, r0
 802d13e:	460b      	mov	r3, r1
 802d140:	f000 fd2e 	bl	802dba0 <__aeabi_dsub>
 802d144:	4602      	mov	r2, r0
 802d146:	460b      	mov	r3, r1
 802d148:	f001 f808 	bl	802e15c <__aeabi_ddiv>
 802d14c:	b006      	add	sp, #24
 802d14e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802d152:	4bb4      	ldr	r3, [pc, #720]	; (802d424 <__ieee754_asin+0x30c>)
 802d154:	429e      	cmp	r6, r3
 802d156:	dc29      	bgt.n	802d1ac <__ieee754_asin+0x94>
 802d158:	f1b6 5f79 	cmp.w	r6, #1044381696	; 0x3e400000
 802d15c:	f280 816a 	bge.w	802d434 <__ieee754_asin+0x31c>
 802d160:	a393      	add	r3, pc, #588	; (adr r3, 802d3b0 <__ieee754_asin+0x298>)
 802d162:	e9d3 2300 	ldrd	r2, r3, [r3]
 802d166:	f000 fd1d 	bl	802dba4 <__adddf3>
 802d16a:	2200      	movs	r2, #0
 802d16c:	4bae      	ldr	r3, [pc, #696]	; (802d428 <__ieee754_asin+0x310>)
 802d16e:	f001 f95b 	bl	802e428 <__aeabi_dcmpgt>
 802d172:	b1d8      	cbz	r0, 802d1ac <__ieee754_asin+0x94>
 802d174:	4620      	mov	r0, r4
 802d176:	4629      	mov	r1, r5
 802d178:	b006      	add	sp, #24
 802d17a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802d17e:	a38e      	add	r3, pc, #568	; (adr r3, 802d3b8 <__ieee754_asin+0x2a0>)
 802d180:	e9d3 2300 	ldrd	r2, r3, [r3]
 802d184:	f000 fec0 	bl	802df08 <__aeabi_dmul>
 802d188:	a38d      	add	r3, pc, #564	; (adr r3, 802d3c0 <__ieee754_asin+0x2a8>)
 802d18a:	e9d3 2300 	ldrd	r2, r3, [r3]
 802d18e:	4606      	mov	r6, r0
 802d190:	460f      	mov	r7, r1
 802d192:	4620      	mov	r0, r4
 802d194:	4629      	mov	r1, r5
 802d196:	f000 feb7 	bl	802df08 <__aeabi_dmul>
 802d19a:	4602      	mov	r2, r0
 802d19c:	460b      	mov	r3, r1
 802d19e:	4630      	mov	r0, r6
 802d1a0:	4639      	mov	r1, r7
 802d1a2:	f000 fcff 	bl	802dba4 <__adddf3>
 802d1a6:	b006      	add	sp, #24
 802d1a8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802d1ac:	4620      	mov	r0, r4
 802d1ae:	4629      	mov	r1, r5
 802d1b0:	f7ff fe2a 	bl	802ce08 <fabs>
 802d1b4:	4602      	mov	r2, r0
 802d1b6:	460b      	mov	r3, r1
 802d1b8:	2000      	movs	r0, #0
 802d1ba:	499b      	ldr	r1, [pc, #620]	; (802d428 <__ieee754_asin+0x310>)
 802d1bc:	f000 fcf0 	bl	802dba0 <__aeabi_dsub>
 802d1c0:	2200      	movs	r2, #0
 802d1c2:	4b9a      	ldr	r3, [pc, #616]	; (802d42c <__ieee754_asin+0x314>)
 802d1c4:	f000 fea0 	bl	802df08 <__aeabi_dmul>
 802d1c8:	a37f      	add	r3, pc, #508	; (adr r3, 802d3c8 <__ieee754_asin+0x2b0>)
 802d1ca:	e9d3 2300 	ldrd	r2, r3, [r3]
 802d1ce:	4604      	mov	r4, r0
 802d1d0:	460d      	mov	r5, r1
 802d1d2:	f000 fe99 	bl	802df08 <__aeabi_dmul>
 802d1d6:	a37e      	add	r3, pc, #504	; (adr r3, 802d3d0 <__ieee754_asin+0x2b8>)
 802d1d8:	e9d3 2300 	ldrd	r2, r3, [r3]
 802d1dc:	f000 fce2 	bl	802dba4 <__adddf3>
 802d1e0:	4622      	mov	r2, r4
 802d1e2:	462b      	mov	r3, r5
 802d1e4:	f000 fe90 	bl	802df08 <__aeabi_dmul>
 802d1e8:	a37b      	add	r3, pc, #492	; (adr r3, 802d3d8 <__ieee754_asin+0x2c0>)
 802d1ea:	e9d3 2300 	ldrd	r2, r3, [r3]
 802d1ee:	f000 fcd7 	bl	802dba0 <__aeabi_dsub>
 802d1f2:	4622      	mov	r2, r4
 802d1f4:	462b      	mov	r3, r5
 802d1f6:	f000 fe87 	bl	802df08 <__aeabi_dmul>
 802d1fa:	a379      	add	r3, pc, #484	; (adr r3, 802d3e0 <__ieee754_asin+0x2c8>)
 802d1fc:	e9d3 2300 	ldrd	r2, r3, [r3]
 802d200:	f000 fcd0 	bl	802dba4 <__adddf3>
 802d204:	4622      	mov	r2, r4
 802d206:	462b      	mov	r3, r5
 802d208:	f000 fe7e 	bl	802df08 <__aeabi_dmul>
 802d20c:	a376      	add	r3, pc, #472	; (adr r3, 802d3e8 <__ieee754_asin+0x2d0>)
 802d20e:	e9d3 2300 	ldrd	r2, r3, [r3]
 802d212:	f000 fcc5 	bl	802dba0 <__aeabi_dsub>
 802d216:	4622      	mov	r2, r4
 802d218:	462b      	mov	r3, r5
 802d21a:	f000 fe75 	bl	802df08 <__aeabi_dmul>
 802d21e:	a374      	add	r3, pc, #464	; (adr r3, 802d3f0 <__ieee754_asin+0x2d8>)
 802d220:	e9d3 2300 	ldrd	r2, r3, [r3]
 802d224:	f000 fcbe 	bl	802dba4 <__adddf3>
 802d228:	4622      	mov	r2, r4
 802d22a:	462b      	mov	r3, r5
 802d22c:	f000 fe6c 	bl	802df08 <__aeabi_dmul>
 802d230:	a371      	add	r3, pc, #452	; (adr r3, 802d3f8 <__ieee754_asin+0x2e0>)
 802d232:	e9d3 2300 	ldrd	r2, r3, [r3]
 802d236:	e9cd 0100 	strd	r0, r1, [sp]
 802d23a:	4620      	mov	r0, r4
 802d23c:	4629      	mov	r1, r5
 802d23e:	f000 fe63 	bl	802df08 <__aeabi_dmul>
 802d242:	a36f      	add	r3, pc, #444	; (adr r3, 802d400 <__ieee754_asin+0x2e8>)
 802d244:	e9d3 2300 	ldrd	r2, r3, [r3]
 802d248:	f000 fcaa 	bl	802dba0 <__aeabi_dsub>
 802d24c:	4622      	mov	r2, r4
 802d24e:	462b      	mov	r3, r5
 802d250:	f000 fe5a 	bl	802df08 <__aeabi_dmul>
 802d254:	a36c      	add	r3, pc, #432	; (adr r3, 802d408 <__ieee754_asin+0x2f0>)
 802d256:	e9d3 2300 	ldrd	r2, r3, [r3]
 802d25a:	f000 fca3 	bl	802dba4 <__adddf3>
 802d25e:	4622      	mov	r2, r4
 802d260:	462b      	mov	r3, r5
 802d262:	f000 fe51 	bl	802df08 <__aeabi_dmul>
 802d266:	a36a      	add	r3, pc, #424	; (adr r3, 802d410 <__ieee754_asin+0x2f8>)
 802d268:	e9d3 2300 	ldrd	r2, r3, [r3]
 802d26c:	f000 fc98 	bl	802dba0 <__aeabi_dsub>
 802d270:	4622      	mov	r2, r4
 802d272:	462b      	mov	r3, r5
 802d274:	f000 fe48 	bl	802df08 <__aeabi_dmul>
 802d278:	4b6b      	ldr	r3, [pc, #428]	; (802d428 <__ieee754_asin+0x310>)
 802d27a:	2200      	movs	r2, #0
 802d27c:	f000 fc92 	bl	802dba4 <__adddf3>
 802d280:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802d284:	4620      	mov	r0, r4
 802d286:	4629      	mov	r1, r5
 802d288:	f000 f97a 	bl	802d580 <__ieee754_sqrt>
 802d28c:	4b68      	ldr	r3, [pc, #416]	; (802d430 <__ieee754_asin+0x318>)
 802d28e:	429e      	cmp	r6, r3
 802d290:	4680      	mov	r8, r0
 802d292:	4689      	mov	r9, r1
 802d294:	dc67      	bgt.n	802d366 <__ieee754_asin+0x24e>
 802d296:	4602      	mov	r2, r0
 802d298:	460b      	mov	r3, r1
 802d29a:	460f      	mov	r7, r1
 802d29c:	f000 fc82 	bl	802dba4 <__adddf3>
 802d2a0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 802d2a4:	e9cd 0104 	strd	r0, r1, [sp, #16]
 802d2a8:	e9dd 0100 	ldrd	r0, r1, [sp]
 802d2ac:	f000 ff56 	bl	802e15c <__aeabi_ddiv>
 802d2b0:	4602      	mov	r2, r0
 802d2b2:	460b      	mov	r3, r1
 802d2b4:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 802d2b8:	f000 fe26 	bl	802df08 <__aeabi_dmul>
 802d2bc:	2600      	movs	r6, #0
 802d2be:	e9cd 0100 	strd	r0, r1, [sp]
 802d2c2:	4632      	mov	r2, r6
 802d2c4:	464b      	mov	r3, r9
 802d2c6:	4630      	mov	r0, r6
 802d2c8:	4649      	mov	r1, r9
 802d2ca:	f000 fe1d 	bl	802df08 <__aeabi_dmul>
 802d2ce:	4602      	mov	r2, r0
 802d2d0:	460b      	mov	r3, r1
 802d2d2:	4620      	mov	r0, r4
 802d2d4:	4629      	mov	r1, r5
 802d2d6:	f000 fc63 	bl	802dba0 <__aeabi_dsub>
 802d2da:	4632      	mov	r2, r6
 802d2dc:	4604      	mov	r4, r0
 802d2de:	460d      	mov	r5, r1
 802d2e0:	464b      	mov	r3, r9
 802d2e2:	4640      	mov	r0, r8
 802d2e4:	4649      	mov	r1, r9
 802d2e6:	f000 fc5d 	bl	802dba4 <__adddf3>
 802d2ea:	4602      	mov	r2, r0
 802d2ec:	460b      	mov	r3, r1
 802d2ee:	4620      	mov	r0, r4
 802d2f0:	4629      	mov	r1, r5
 802d2f2:	f000 ff33 	bl	802e15c <__aeabi_ddiv>
 802d2f6:	4602      	mov	r2, r0
 802d2f8:	460b      	mov	r3, r1
 802d2fa:	f000 fc53 	bl	802dba4 <__adddf3>
 802d2fe:	4602      	mov	r2, r0
 802d300:	460b      	mov	r3, r1
 802d302:	a12f      	add	r1, pc, #188	; (adr r1, 802d3c0 <__ieee754_asin+0x2a8>)
 802d304:	e9d1 0100 	ldrd	r0, r1, [r1]
 802d308:	f000 fc4a 	bl	802dba0 <__aeabi_dsub>
 802d30c:	4602      	mov	r2, r0
 802d30e:	460b      	mov	r3, r1
 802d310:	e9dd 0100 	ldrd	r0, r1, [sp]
 802d314:	f000 fc44 	bl	802dba0 <__aeabi_dsub>
 802d318:	4632      	mov	r2, r6
 802d31a:	4604      	mov	r4, r0
 802d31c:	460d      	mov	r5, r1
 802d31e:	463b      	mov	r3, r7
 802d320:	4630      	mov	r0, r6
 802d322:	4649      	mov	r1, r9
 802d324:	f000 fc3e 	bl	802dba4 <__adddf3>
 802d328:	4602      	mov	r2, r0
 802d32a:	460b      	mov	r3, r1
 802d32c:	a13a      	add	r1, pc, #232	; (adr r1, 802d418 <__ieee754_asin+0x300>)
 802d32e:	e9d1 0100 	ldrd	r0, r1, [r1]
 802d332:	f000 fc35 	bl	802dba0 <__aeabi_dsub>
 802d336:	4602      	mov	r2, r0
 802d338:	460b      	mov	r3, r1
 802d33a:	4620      	mov	r0, r4
 802d33c:	4629      	mov	r1, r5
 802d33e:	f000 fc2f 	bl	802dba0 <__aeabi_dsub>
 802d342:	4602      	mov	r2, r0
 802d344:	460b      	mov	r3, r1
 802d346:	a134      	add	r1, pc, #208	; (adr r1, 802d418 <__ieee754_asin+0x300>)
 802d348:	e9d1 0100 	ldrd	r0, r1, [r1]
 802d34c:	f000 fc28 	bl	802dba0 <__aeabi_dsub>
 802d350:	4602      	mov	r2, r0
 802d352:	460b      	mov	r3, r1
 802d354:	f1ba 0f00 	cmp.w	sl, #0
 802d358:	f340 80df 	ble.w	802d51a <__ieee754_asin+0x402>
 802d35c:	4610      	mov	r0, r2
 802d35e:	4619      	mov	r1, r3
 802d360:	b006      	add	sp, #24
 802d362:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802d366:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 802d36a:	e9dd 0100 	ldrd	r0, r1, [sp]
 802d36e:	f000 fef5 	bl	802e15c <__aeabi_ddiv>
 802d372:	4602      	mov	r2, r0
 802d374:	460b      	mov	r3, r1
 802d376:	4640      	mov	r0, r8
 802d378:	4649      	mov	r1, r9
 802d37a:	f000 fdc5 	bl	802df08 <__aeabi_dmul>
 802d37e:	4642      	mov	r2, r8
 802d380:	464b      	mov	r3, r9
 802d382:	f000 fc0f 	bl	802dba4 <__adddf3>
 802d386:	4602      	mov	r2, r0
 802d388:	460b      	mov	r3, r1
 802d38a:	f000 fc0b 	bl	802dba4 <__adddf3>
 802d38e:	a30c      	add	r3, pc, #48	; (adr r3, 802d3c0 <__ieee754_asin+0x2a8>)
 802d390:	e9d3 2300 	ldrd	r2, r3, [r3]
 802d394:	f000 fc04 	bl	802dba0 <__aeabi_dsub>
 802d398:	4602      	mov	r2, r0
 802d39a:	460b      	mov	r3, r1
 802d39c:	a106      	add	r1, pc, #24	; (adr r1, 802d3b8 <__ieee754_asin+0x2a0>)
 802d39e:	e9d1 0100 	ldrd	r0, r1, [r1]
 802d3a2:	f000 fbfd 	bl	802dba0 <__aeabi_dsub>
 802d3a6:	4602      	mov	r2, r0
 802d3a8:	460b      	mov	r3, r1
 802d3aa:	e7d3      	b.n	802d354 <__ieee754_asin+0x23c>
 802d3ac:	f3af 8000 	nop.w
 802d3b0:	8800759c 	.word	0x8800759c
 802d3b4:	7e37e43c 	.word	0x7e37e43c
 802d3b8:	54442d18 	.word	0x54442d18
 802d3bc:	3ff921fb 	.word	0x3ff921fb
 802d3c0:	33145c07 	.word	0x33145c07
 802d3c4:	3c91a626 	.word	0x3c91a626
 802d3c8:	0dfdf709 	.word	0x0dfdf709
 802d3cc:	3f023de1 	.word	0x3f023de1
 802d3d0:	7501b288 	.word	0x7501b288
 802d3d4:	3f49efe0 	.word	0x3f49efe0
 802d3d8:	b5688f3b 	.word	0xb5688f3b
 802d3dc:	3fa48228 	.word	0x3fa48228
 802d3e0:	0e884455 	.word	0x0e884455
 802d3e4:	3fc9c155 	.word	0x3fc9c155
 802d3e8:	03eb6f7d 	.word	0x03eb6f7d
 802d3ec:	3fd4d612 	.word	0x3fd4d612
 802d3f0:	55555555 	.word	0x55555555
 802d3f4:	3fc55555 	.word	0x3fc55555
 802d3f8:	b12e9282 	.word	0xb12e9282
 802d3fc:	3fb3b8c5 	.word	0x3fb3b8c5
 802d400:	1b8d0159 	.word	0x1b8d0159
 802d404:	3fe6066c 	.word	0x3fe6066c
 802d408:	9c598ac8 	.word	0x9c598ac8
 802d40c:	40002ae5 	.word	0x40002ae5
 802d410:	1c8a2d4b 	.word	0x1c8a2d4b
 802d414:	40033a27 	.word	0x40033a27
 802d418:	54442d18 	.word	0x54442d18
 802d41c:	3fe921fb 	.word	0x3fe921fb
 802d420:	3fefffff 	.word	0x3fefffff
 802d424:	3fdfffff 	.word	0x3fdfffff
 802d428:	3ff00000 	.word	0x3ff00000
 802d42c:	3fe00000 	.word	0x3fe00000
 802d430:	3fef3332 	.word	0x3fef3332
 802d434:	4602      	mov	r2, r0
 802d436:	460b      	mov	r3, r1
 802d438:	f000 fd66 	bl	802df08 <__aeabi_dmul>
 802d43c:	a33b      	add	r3, pc, #236	; (adr r3, 802d52c <__ieee754_asin+0x414>)
 802d43e:	e9d3 2300 	ldrd	r2, r3, [r3]
 802d442:	4606      	mov	r6, r0
 802d444:	460f      	mov	r7, r1
 802d446:	f000 fd5f 	bl	802df08 <__aeabi_dmul>
 802d44a:	a33a      	add	r3, pc, #232	; (adr r3, 802d534 <__ieee754_asin+0x41c>)
 802d44c:	e9d3 2300 	ldrd	r2, r3, [r3]
 802d450:	f000 fba8 	bl	802dba4 <__adddf3>
 802d454:	4632      	mov	r2, r6
 802d456:	463b      	mov	r3, r7
 802d458:	f000 fd56 	bl	802df08 <__aeabi_dmul>
 802d45c:	a337      	add	r3, pc, #220	; (adr r3, 802d53c <__ieee754_asin+0x424>)
 802d45e:	e9d3 2300 	ldrd	r2, r3, [r3]
 802d462:	f000 fb9d 	bl	802dba0 <__aeabi_dsub>
 802d466:	4632      	mov	r2, r6
 802d468:	463b      	mov	r3, r7
 802d46a:	f000 fd4d 	bl	802df08 <__aeabi_dmul>
 802d46e:	a335      	add	r3, pc, #212	; (adr r3, 802d544 <__ieee754_asin+0x42c>)
 802d470:	e9d3 2300 	ldrd	r2, r3, [r3]
 802d474:	f000 fb96 	bl	802dba4 <__adddf3>
 802d478:	4632      	mov	r2, r6
 802d47a:	463b      	mov	r3, r7
 802d47c:	f000 fd44 	bl	802df08 <__aeabi_dmul>
 802d480:	a332      	add	r3, pc, #200	; (adr r3, 802d54c <__ieee754_asin+0x434>)
 802d482:	e9d3 2300 	ldrd	r2, r3, [r3]
 802d486:	f000 fb8b 	bl	802dba0 <__aeabi_dsub>
 802d48a:	4632      	mov	r2, r6
 802d48c:	463b      	mov	r3, r7
 802d48e:	f000 fd3b 	bl	802df08 <__aeabi_dmul>
 802d492:	a330      	add	r3, pc, #192	; (adr r3, 802d554 <__ieee754_asin+0x43c>)
 802d494:	e9d3 2300 	ldrd	r2, r3, [r3]
 802d498:	f000 fb84 	bl	802dba4 <__adddf3>
 802d49c:	4632      	mov	r2, r6
 802d49e:	463b      	mov	r3, r7
 802d4a0:	f000 fd32 	bl	802df08 <__aeabi_dmul>
 802d4a4:	a32d      	add	r3, pc, #180	; (adr r3, 802d55c <__ieee754_asin+0x444>)
 802d4a6:	e9d3 2300 	ldrd	r2, r3, [r3]
 802d4aa:	4680      	mov	r8, r0
 802d4ac:	4689      	mov	r9, r1
 802d4ae:	4630      	mov	r0, r6
 802d4b0:	4639      	mov	r1, r7
 802d4b2:	f000 fd29 	bl	802df08 <__aeabi_dmul>
 802d4b6:	a32b      	add	r3, pc, #172	; (adr r3, 802d564 <__ieee754_asin+0x44c>)
 802d4b8:	e9d3 2300 	ldrd	r2, r3, [r3]
 802d4bc:	f000 fb70 	bl	802dba0 <__aeabi_dsub>
 802d4c0:	4632      	mov	r2, r6
 802d4c2:	463b      	mov	r3, r7
 802d4c4:	f000 fd20 	bl	802df08 <__aeabi_dmul>
 802d4c8:	a328      	add	r3, pc, #160	; (adr r3, 802d56c <__ieee754_asin+0x454>)
 802d4ca:	e9d3 2300 	ldrd	r2, r3, [r3]
 802d4ce:	f000 fb69 	bl	802dba4 <__adddf3>
 802d4d2:	4632      	mov	r2, r6
 802d4d4:	463b      	mov	r3, r7
 802d4d6:	f000 fd17 	bl	802df08 <__aeabi_dmul>
 802d4da:	a326      	add	r3, pc, #152	; (adr r3, 802d574 <__ieee754_asin+0x45c>)
 802d4dc:	e9d3 2300 	ldrd	r2, r3, [r3]
 802d4e0:	f000 fb5e 	bl	802dba0 <__aeabi_dsub>
 802d4e4:	4632      	mov	r2, r6
 802d4e6:	463b      	mov	r3, r7
 802d4e8:	f000 fd0e 	bl	802df08 <__aeabi_dmul>
 802d4ec:	2200      	movs	r2, #0
 802d4ee:	4b0e      	ldr	r3, [pc, #56]	; (802d528 <__ieee754_asin+0x410>)
 802d4f0:	f000 fb58 	bl	802dba4 <__adddf3>
 802d4f4:	4602      	mov	r2, r0
 802d4f6:	460b      	mov	r3, r1
 802d4f8:	4640      	mov	r0, r8
 802d4fa:	4649      	mov	r1, r9
 802d4fc:	f000 fe2e 	bl	802e15c <__aeabi_ddiv>
 802d500:	4602      	mov	r2, r0
 802d502:	460b      	mov	r3, r1
 802d504:	4620      	mov	r0, r4
 802d506:	4629      	mov	r1, r5
 802d508:	f000 fcfe 	bl	802df08 <__aeabi_dmul>
 802d50c:	4622      	mov	r2, r4
 802d50e:	462b      	mov	r3, r5
 802d510:	f000 fb48 	bl	802dba4 <__adddf3>
 802d514:	b006      	add	sp, #24
 802d516:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802d51a:	4610      	mov	r0, r2
 802d51c:	f103 4100 	add.w	r1, r3, #2147483648	; 0x80000000
 802d520:	e614      	b.n	802d14c <__ieee754_asin+0x34>
 802d522:	bf00      	nop
 802d524:	f3af 8000 	nop.w
 802d528:	3ff00000 	.word	0x3ff00000
 802d52c:	0dfdf709 	.word	0x0dfdf709
 802d530:	3f023de1 	.word	0x3f023de1
 802d534:	7501b288 	.word	0x7501b288
 802d538:	3f49efe0 	.word	0x3f49efe0
 802d53c:	b5688f3b 	.word	0xb5688f3b
 802d540:	3fa48228 	.word	0x3fa48228
 802d544:	0e884455 	.word	0x0e884455
 802d548:	3fc9c155 	.word	0x3fc9c155
 802d54c:	03eb6f7d 	.word	0x03eb6f7d
 802d550:	3fd4d612 	.word	0x3fd4d612
 802d554:	55555555 	.word	0x55555555
 802d558:	3fc55555 	.word	0x3fc55555
 802d55c:	b12e9282 	.word	0xb12e9282
 802d560:	3fb3b8c5 	.word	0x3fb3b8c5
 802d564:	1b8d0159 	.word	0x1b8d0159
 802d568:	3fe6066c 	.word	0x3fe6066c
 802d56c:	9c598ac8 	.word	0x9c598ac8
 802d570:	40002ae5 	.word	0x40002ae5
 802d574:	1c8a2d4b 	.word	0x1c8a2d4b
 802d578:	40033a27 	.word	0x40033a27
 802d57c:	f3af 8000 	nop.w

0802d580 <__ieee754_sqrt>:
 802d580:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802d584:	4e5f      	ldr	r6, [pc, #380]	; (802d704 <__ieee754_sqrt+0x184>)
 802d586:	46b6      	mov	lr, r6
 802d588:	400e      	ands	r6, r1
 802d58a:	4576      	cmp	r6, lr
 802d58c:	4604      	mov	r4, r0
 802d58e:	460d      	mov	r5, r1
 802d590:	460b      	mov	r3, r1
 802d592:	f000 8095 	beq.w	802d6c0 <__ieee754_sqrt+0x140>
 802d596:	2900      	cmp	r1, #0
 802d598:	4602      	mov	r2, r0
 802d59a:	dd74      	ble.n	802d686 <__ieee754_sqrt+0x106>
 802d59c:	150f      	asrs	r7, r1, #20
 802d59e:	d07f      	beq.n	802d6a0 <__ieee754_sqrt+0x120>
 802d5a0:	f2a7 37ff 	subw	r7, r7, #1023	; 0x3ff
 802d5a4:	f3c3 0313 	ubfx	r3, r3, #0, #20
 802d5a8:	07f8      	lsls	r0, r7, #31
 802d5aa:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 802d5ae:	d465      	bmi.n	802d67c <__ieee754_sqrt+0xfc>
 802d5b0:	0fd1      	lsrs	r1, r2, #31
 802d5b2:	2600      	movs	r6, #0
 802d5b4:	eb01 0343 	add.w	r3, r1, r3, lsl #1
 802d5b8:	107f      	asrs	r7, r7, #1
 802d5ba:	0052      	lsls	r2, r2, #1
 802d5bc:	46b6      	mov	lr, r6
 802d5be:	2016      	movs	r0, #22
 802d5c0:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 802d5c4:	eb0e 0401 	add.w	r4, lr, r1
 802d5c8:	429c      	cmp	r4, r3
 802d5ca:	ea4f 75d2 	mov.w	r5, r2, lsr #31
 802d5ce:	ea4f 0242 	mov.w	r2, r2, lsl #1
 802d5d2:	dc03      	bgt.n	802d5dc <__ieee754_sqrt+0x5c>
 802d5d4:	1b1b      	subs	r3, r3, r4
 802d5d6:	eb04 0e01 	add.w	lr, r4, r1
 802d5da:	440e      	add	r6, r1
 802d5dc:	3801      	subs	r0, #1
 802d5de:	eb05 0343 	add.w	r3, r5, r3, lsl #1
 802d5e2:	ea4f 0151 	mov.w	r1, r1, lsr #1
 802d5e6:	d1ed      	bne.n	802d5c4 <__ieee754_sqrt+0x44>
 802d5e8:	4684      	mov	ip, r0
 802d5ea:	2520      	movs	r5, #32
 802d5ec:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
 802d5f0:	e00a      	b.n	802d608 <__ieee754_sqrt+0x88>
 802d5f2:	4573      	cmp	r3, lr
 802d5f4:	d021      	beq.n	802d63a <__ieee754_sqrt+0xba>
 802d5f6:	0fd4      	lsrs	r4, r2, #31
 802d5f8:	3d01      	subs	r5, #1
 802d5fa:	ea4f 0151 	mov.w	r1, r1, lsr #1
 802d5fe:	eb04 0343 	add.w	r3, r4, r3, lsl #1
 802d602:	ea4f 0242 	mov.w	r2, r2, lsl #1
 802d606:	d021      	beq.n	802d64c <__ieee754_sqrt+0xcc>
 802d608:	459e      	cmp	lr, r3
 802d60a:	eb0c 0401 	add.w	r4, ip, r1
 802d60e:	daf0      	bge.n	802d5f2 <__ieee754_sqrt+0x72>
 802d610:	2c00      	cmp	r4, #0
 802d612:	eb04 0c01 	add.w	ip, r4, r1
 802d616:	db0a      	blt.n	802d62e <__ieee754_sqrt+0xae>
 802d618:	46f0      	mov	r8, lr
 802d61a:	ebce 0303 	rsb	r3, lr, r3
 802d61e:	4294      	cmp	r4, r2
 802d620:	bf88      	it	hi
 802d622:	f103 33ff 	addhi.w	r3, r3, #4294967295
 802d626:	1b12      	subs	r2, r2, r4
 802d628:	4408      	add	r0, r1
 802d62a:	46c6      	mov	lr, r8
 802d62c:	e7e3      	b.n	802d5f6 <__ieee754_sqrt+0x76>
 802d62e:	f1bc 0f00 	cmp.w	ip, #0
 802d632:	dbf1      	blt.n	802d618 <__ieee754_sqrt+0x98>
 802d634:	f10e 0801 	add.w	r8, lr, #1
 802d638:	e7ef      	b.n	802d61a <__ieee754_sqrt+0x9a>
 802d63a:	4294      	cmp	r4, r2
 802d63c:	d81c      	bhi.n	802d678 <__ieee754_sqrt+0xf8>
 802d63e:	2c00      	cmp	r4, #0
 802d640:	eb04 0c01 	add.w	ip, r4, r1
 802d644:	db48      	blt.n	802d6d8 <__ieee754_sqrt+0x158>
 802d646:	4698      	mov	r8, r3
 802d648:	2300      	movs	r3, #0
 802d64a:	e7ec      	b.n	802d626 <__ieee754_sqrt+0xa6>
 802d64c:	4313      	orrs	r3, r2
 802d64e:	d004      	beq.n	802d65a <__ieee754_sqrt+0xda>
 802d650:	1c41      	adds	r1, r0, #1
 802d652:	d047      	beq.n	802d6e4 <__ieee754_sqrt+0x164>
 802d654:	f000 0301 	and.w	r3, r0, #1
 802d658:	4418      	add	r0, r3
 802d65a:	0845      	lsrs	r5, r0, #1
 802d65c:	1073      	asrs	r3, r6, #1
 802d65e:	07f2      	lsls	r2, r6, #31
 802d660:	f103 537f 	add.w	r3, r3, #1069547520	; 0x3fc00000
 802d664:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
 802d668:	bf48      	it	mi
 802d66a:	f045 4500 	orrmi.w	r5, r5, #2147483648	; 0x80000000
 802d66e:	eb03 5107 	add.w	r1, r3, r7, lsl #20
 802d672:	4628      	mov	r0, r5
 802d674:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802d678:	469e      	mov	lr, r3
 802d67a:	e7bc      	b.n	802d5f6 <__ieee754_sqrt+0x76>
 802d67c:	0fd1      	lsrs	r1, r2, #31
 802d67e:	eb01 0343 	add.w	r3, r1, r3, lsl #1
 802d682:	0052      	lsls	r2, r2, #1
 802d684:	e794      	b.n	802d5b0 <__ieee754_sqrt+0x30>
 802d686:	f021 4600 	bic.w	r6, r1, #2147483648	; 0x80000000
 802d68a:	4306      	orrs	r6, r0
 802d68c:	d022      	beq.n	802d6d4 <__ieee754_sqrt+0x154>
 802d68e:	bb79      	cbnz	r1, 802d6f0 <__ieee754_sqrt+0x170>
 802d690:	460f      	mov	r7, r1
 802d692:	0ad3      	lsrs	r3, r2, #11
 802d694:	3f15      	subs	r7, #21
 802d696:	0552      	lsls	r2, r2, #21
 802d698:	2b00      	cmp	r3, #0
 802d69a:	d0fa      	beq.n	802d692 <__ieee754_sqrt+0x112>
 802d69c:	02dd      	lsls	r5, r3, #11
 802d69e:	d423      	bmi.n	802d6e8 <__ieee754_sqrt+0x168>
 802d6a0:	2100      	movs	r1, #0
 802d6a2:	005b      	lsls	r3, r3, #1
 802d6a4:	02dc      	lsls	r4, r3, #11
 802d6a6:	f101 0101 	add.w	r1, r1, #1
 802d6aa:	d5fa      	bpl.n	802d6a2 <__ieee754_sqrt+0x122>
 802d6ac:	f1c1 0001 	rsb	r0, r1, #1
 802d6b0:	f1c1 0420 	rsb	r4, r1, #32
 802d6b4:	fa22 f404 	lsr.w	r4, r2, r4
 802d6b8:	4323      	orrs	r3, r4
 802d6ba:	4407      	add	r7, r0
 802d6bc:	408a      	lsls	r2, r1
 802d6be:	e76f      	b.n	802d5a0 <__ieee754_sqrt+0x20>
 802d6c0:	4602      	mov	r2, r0
 802d6c2:	460b      	mov	r3, r1
 802d6c4:	f000 fc20 	bl	802df08 <__aeabi_dmul>
 802d6c8:	4622      	mov	r2, r4
 802d6ca:	462b      	mov	r3, r5
 802d6cc:	f000 fa6a 	bl	802dba4 <__adddf3>
 802d6d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802d6d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802d6d8:	f1bc 0f00 	cmp.w	ip, #0
 802d6dc:	daaa      	bge.n	802d634 <__ieee754_sqrt+0xb4>
 802d6de:	46f0      	mov	r8, lr
 802d6e0:	2300      	movs	r3, #0
 802d6e2:	e7a0      	b.n	802d626 <__ieee754_sqrt+0xa6>
 802d6e4:	3601      	adds	r6, #1
 802d6e6:	e7b9      	b.n	802d65c <__ieee754_sqrt+0xdc>
 802d6e8:	2420      	movs	r4, #32
 802d6ea:	2001      	movs	r0, #1
 802d6ec:	2100      	movs	r1, #0
 802d6ee:	e7e1      	b.n	802d6b4 <__ieee754_sqrt+0x134>
 802d6f0:	4602      	mov	r2, r0
 802d6f2:	460b      	mov	r3, r1
 802d6f4:	f000 fa54 	bl	802dba0 <__aeabi_dsub>
 802d6f8:	4602      	mov	r2, r0
 802d6fa:	460b      	mov	r3, r1
 802d6fc:	f000 fd2e 	bl	802e15c <__aeabi_ddiv>
 802d700:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802d704:	7ff00000 	.word	0x7ff00000

0802d708 <__ieee754_fmodf>:
 802d708:	b470      	push	{r4, r5, r6}
 802d70a:	b083      	sub	sp, #12
 802d70c:	ee07 0a90 	vmov	s15, r0
 802d710:	9101      	str	r1, [sp, #4]
 802d712:	9c01      	ldr	r4, [sp, #4]
 802d714:	f034 4000 	bics.w	r0, r4, #2147483648	; 0x80000000
 802d718:	d03e      	beq.n	802d798 <__ieee754_fmodf+0x90>
 802d71a:	ee17 3a90 	vmov	r3, s15
 802d71e:	f003 4500 	and.w	r5, r3, #2147483648	; 0x80000000
 802d722:	406b      	eors	r3, r5
 802d724:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 802d728:	da36      	bge.n	802d798 <__ieee754_fmodf+0x90>
 802d72a:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
 802d72e:	dc33      	bgt.n	802d798 <__ieee754_fmodf+0x90>
 802d730:	4283      	cmp	r3, r0
 802d732:	db37      	blt.n	802d7a4 <__ieee754_fmodf+0x9c>
 802d734:	d03f      	beq.n	802d7b6 <__ieee754_fmodf+0xae>
 802d736:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 802d73a:	da43      	bge.n	802d7c4 <__ieee754_fmodf+0xbc>
 802d73c:	021a      	lsls	r2, r3, #8
 802d73e:	2a00      	cmp	r2, #0
 802d740:	f06f 017d 	mvn.w	r1, #125	; 0x7d
 802d744:	dd04      	ble.n	802d750 <__ieee754_fmodf+0x48>
 802d746:	0052      	lsls	r2, r2, #1
 802d748:	2a00      	cmp	r2, #0
 802d74a:	f101 31ff 	add.w	r1, r1, #4294967295
 802d74e:	dcfa      	bgt.n	802d746 <__ieee754_fmodf+0x3e>
 802d750:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 802d754:	da43      	bge.n	802d7de <__ieee754_fmodf+0xd6>
 802d756:	0206      	lsls	r6, r0, #8
 802d758:	f06f 027d 	mvn.w	r2, #125	; 0x7d
 802d75c:	d403      	bmi.n	802d766 <__ieee754_fmodf+0x5e>
 802d75e:	0076      	lsls	r6, r6, #1
 802d760:	f102 32ff 	add.w	r2, r2, #4294967295
 802d764:	d5fb      	bpl.n	802d75e <__ieee754_fmodf+0x56>
 802d766:	f111 0f7e 	cmn.w	r1, #126	; 0x7e
 802d76a:	db33      	blt.n	802d7d4 <__ieee754_fmodf+0xcc>
 802d76c:	f3c3 0316 	ubfx	r3, r3, #0, #23
 802d770:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 802d774:	f112 0f7e 	cmn.w	r2, #126	; 0x7e
 802d778:	db27      	blt.n	802d7ca <__ieee754_fmodf+0xc2>
 802d77a:	f3c4 0016 	ubfx	r0, r4, #0, #23
 802d77e:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 802d782:	1a89      	subs	r1, r1, r2
 802d784:	e002      	b.n	802d78c <__ieee754_fmodf+0x84>
 802d786:	d016      	beq.n	802d7b6 <__ieee754_fmodf+0xae>
 802d788:	0063      	lsls	r3, r4, #1
 802d78a:	3901      	subs	r1, #1
 802d78c:	1a1c      	subs	r4, r3, r0
 802d78e:	b171      	cbz	r1, 802d7ae <__ieee754_fmodf+0xa6>
 802d790:	2c00      	cmp	r4, #0
 802d792:	daf8      	bge.n	802d786 <__ieee754_fmodf+0x7e>
 802d794:	005b      	lsls	r3, r3, #1
 802d796:	e7f8      	b.n	802d78a <__ieee754_fmodf+0x82>
 802d798:	ed9d 7a01 	vldr	s14, [sp, #4]
 802d79c:	ee67 7a87 	vmul.f32	s15, s15, s14
 802d7a0:	eec7 7aa7 	vdiv.f32	s15, s15, s15
 802d7a4:	ee17 0a90 	vmov	r0, s15
 802d7a8:	b003      	add	sp, #12
 802d7aa:	bc70      	pop	{r4, r5, r6}
 802d7ac:	4770      	bx	lr
 802d7ae:	1a18      	subs	r0, r3, r0
 802d7b0:	bf48      	it	mi
 802d7b2:	4618      	movmi	r0, r3
 802d7b4:	b9b0      	cbnz	r0, 802d7e4 <__ieee754_fmodf+0xdc>
 802d7b6:	4a1a      	ldr	r2, [pc, #104]	; (802d820 <__ieee754_fmodf+0x118>)
 802d7b8:	0feb      	lsrs	r3, r5, #31
 802d7ba:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 802d7be:	edd3 7a00 	vldr	s15, [r3]
 802d7c2:	e7ef      	b.n	802d7a4 <__ieee754_fmodf+0x9c>
 802d7c4:	15d9      	asrs	r1, r3, #23
 802d7c6:	397f      	subs	r1, #127	; 0x7f
 802d7c8:	e7c2      	b.n	802d750 <__ieee754_fmodf+0x48>
 802d7ca:	f06f 047d 	mvn.w	r4, #125	; 0x7d
 802d7ce:	1aa4      	subs	r4, r4, r2
 802d7d0:	40a0      	lsls	r0, r4
 802d7d2:	e7d6      	b.n	802d782 <__ieee754_fmodf+0x7a>
 802d7d4:	f06f 067d 	mvn.w	r6, #125	; 0x7d
 802d7d8:	1a76      	subs	r6, r6, r1
 802d7da:	40b3      	lsls	r3, r6
 802d7dc:	e7ca      	b.n	802d774 <__ieee754_fmodf+0x6c>
 802d7de:	15c2      	asrs	r2, r0, #23
 802d7e0:	3a7f      	subs	r2, #127	; 0x7f
 802d7e2:	e7c0      	b.n	802d766 <__ieee754_fmodf+0x5e>
 802d7e4:	4b0f      	ldr	r3, [pc, #60]	; (802d824 <__ieee754_fmodf+0x11c>)
 802d7e6:	4298      	cmp	r0, r3
 802d7e8:	dc04      	bgt.n	802d7f4 <__ieee754_fmodf+0xec>
 802d7ea:	0040      	lsls	r0, r0, #1
 802d7ec:	4298      	cmp	r0, r3
 802d7ee:	f102 32ff 	add.w	r2, r2, #4294967295
 802d7f2:	ddfa      	ble.n	802d7ea <__ieee754_fmodf+0xe2>
 802d7f4:	f112 0f7e 	cmn.w	r2, #126	; 0x7e
 802d7f8:	db09      	blt.n	802d80e <__ieee754_fmodf+0x106>
 802d7fa:	f5a0 0000 	sub.w	r0, r0, #8388608	; 0x800000
 802d7fe:	ea40 0305 	orr.w	r3, r0, r5
 802d802:	327f      	adds	r2, #127	; 0x7f
 802d804:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
 802d808:	ee07 3a90 	vmov	s15, r3
 802d80c:	e7ca      	b.n	802d7a4 <__ieee754_fmodf+0x9c>
 802d80e:	f06f 037d 	mvn.w	r3, #125	; 0x7d
 802d812:	1a9b      	subs	r3, r3, r2
 802d814:	4118      	asrs	r0, r3
 802d816:	ea40 0305 	orr.w	r3, r0, r5
 802d81a:	ee07 3a90 	vmov	s15, r3
 802d81e:	e7c1      	b.n	802d7a4 <__ieee754_fmodf+0x9c>
 802d820:	08031e58 	.word	0x08031e58
 802d824:	007fffff 	.word	0x007fffff

0802d828 <__ieee754_logf>:
 802d828:	b430      	push	{r4, r5}
 802d82a:	b082      	sub	sp, #8
 802d82c:	9001      	str	r0, [sp, #4]
 802d82e:	9b01      	ldr	r3, [sp, #4]
 802d830:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 802d834:	b372      	cbz	r2, 802d894 <__ieee754_logf+0x6c>
 802d836:	2b00      	cmp	r3, #0
 802d838:	db42      	blt.n	802d8c0 <__ieee754_logf+0x98>
 802d83a:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 802d83e:	da4c      	bge.n	802d8da <__ieee754_logf+0xb2>
 802d840:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 802d844:	db31      	blt.n	802d8aa <__ieee754_logf+0x82>
 802d846:	2200      	movs	r2, #0
 802d848:	4972      	ldr	r1, [pc, #456]	; (802da14 <__ieee754_logf+0x1ec>)
 802d84a:	f3c3 0516 	ubfx	r5, r3, #0, #23
 802d84e:	4429      	add	r1, r5
 802d850:	f401 0100 	and.w	r1, r1, #8388608	; 0x800000
 802d854:	15db      	asrs	r3, r3, #23
 802d856:	3b7f      	subs	r3, #127	; 0x7f
 802d858:	f081 547e 	eor.w	r4, r1, #1065353216	; 0x3f800000
 802d85c:	4413      	add	r3, r2
 802d85e:	f105 000f 	add.w	r0, r5, #15
 802d862:	ea44 0205 	orr.w	r2, r4, r5
 802d866:	ee07 2a90 	vmov	s15, r2
 802d86a:	f3c0 0216 	ubfx	r2, r0, #0, #23
 802d86e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 802d872:	2a0f      	cmp	r2, #15
 802d874:	eb03 53d1 	add.w	r3, r3, r1, lsr #23
 802d878:	ee37 7ac7 	vsub.f32	s14, s15, s14
 802d87c:	dc36      	bgt.n	802d8ec <__ieee754_logf+0xc4>
 802d87e:	eeb5 7a40 	vcmp.f32	s14, #0.0
 802d882:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802d886:	d172      	bne.n	802d96e <__ieee754_logf+0x146>
 802d888:	2b00      	cmp	r3, #0
 802d88a:	f040 809e 	bne.w	802d9ca <__ieee754_logf+0x1a2>
 802d88e:	eddf 7a62 	vldr	s15, [pc, #392]	; 802da18 <__ieee754_logf+0x1f0>
 802d892:	e005      	b.n	802d8a0 <__ieee754_logf+0x78>
 802d894:	eddf 7a61 	vldr	s15, [pc, #388]	; 802da1c <__ieee754_logf+0x1f4>
 802d898:	ed9f 7a5f 	vldr	s14, [pc, #380]	; 802da18 <__ieee754_logf+0x1f0>
 802d89c:	eec7 7a87 	vdiv.f32	s15, s15, s14
 802d8a0:	ee17 0a90 	vmov	r0, s15
 802d8a4:	b002      	add	sp, #8
 802d8a6:	bc30      	pop	{r4, r5}
 802d8a8:	4770      	bx	lr
 802d8aa:	eddf 7a5d 	vldr	s15, [pc, #372]	; 802da20 <__ieee754_logf+0x1f8>
 802d8ae:	ed9d 7a01 	vldr	s14, [sp, #4]
 802d8b2:	ee67 7a27 	vmul.f32	s15, s14, s15
 802d8b6:	f06f 0218 	mvn.w	r2, #24
 802d8ba:	ee17 3a90 	vmov	r3, s15
 802d8be:	e7c3      	b.n	802d848 <__ieee754_logf+0x20>
 802d8c0:	eddd 7a01 	vldr	s15, [sp, #4]
 802d8c4:	ed9f 7a54 	vldr	s14, [pc, #336]	; 802da18 <__ieee754_logf+0x1f0>
 802d8c8:	ee77 7ae7 	vsub.f32	s15, s15, s15
 802d8cc:	eec7 7a87 	vdiv.f32	s15, s15, s14
 802d8d0:	ee17 0a90 	vmov	r0, s15
 802d8d4:	b002      	add	sp, #8
 802d8d6:	bc30      	pop	{r4, r5}
 802d8d8:	4770      	bx	lr
 802d8da:	eddd 7a01 	vldr	s15, [sp, #4]
 802d8de:	ee77 7aa7 	vadd.f32	s15, s15, s15
 802d8e2:	ee17 0a90 	vmov	r0, s15
 802d8e6:	b002      	add	sp, #8
 802d8e8:	bc30      	pop	{r4, r5}
 802d8ea:	4770      	bx	lr
 802d8ec:	eeb0 6a00 	vmov.f32	s12, #0
 802d8f0:	ee37 6a06 	vadd.f32	s12, s14, s12
 802d8f4:	ee06 3a90 	vmov	s13, r3
 802d8f8:	ee87 6a06 	vdiv.f32	s12, s14, s12
 802d8fc:	4a49      	ldr	r2, [pc, #292]	; (802da24 <__ieee754_logf+0x1fc>)
 802d8fe:	f5c5 1157 	rsb	r1, r5, #3522560	; 0x35c000
 802d902:	442a      	add	r2, r5
 802d904:	f501 7122 	add.w	r1, r1, #648	; 0x288
 802d908:	430a      	orrs	r2, r1
 802d90a:	2a00      	cmp	r2, #0
 802d90c:	ed9f 2a46 	vldr	s4, [pc, #280]	; 802da28 <__ieee754_logf+0x200>
 802d910:	eddf 3a46 	vldr	s7, [pc, #280]	; 802da2c <__ieee754_logf+0x204>
 802d914:	eddf 4a46 	vldr	s9, [pc, #280]	; 802da30 <__ieee754_logf+0x208>
 802d918:	eddf 2a46 	vldr	s5, [pc, #280]	; 802da34 <__ieee754_logf+0x20c>
 802d91c:	ed9f 4a46 	vldr	s8, [pc, #280]	; 802da38 <__ieee754_logf+0x210>
 802d920:	eddf 7a46 	vldr	s15, [pc, #280]	; 802da3c <__ieee754_logf+0x214>
 802d924:	eddf 5a46 	vldr	s11, [pc, #280]	; 802da40 <__ieee754_logf+0x218>
 802d928:	ee26 5a06 	vmul.f32	s10, s12, s12
 802d92c:	eeb8 3ae6 	vcvt.f32.s32	s6, s13
 802d930:	ee65 6a05 	vmul.f32	s13, s10, s10
 802d934:	eee6 3a82 	vfma.f32	s7, s13, s4
 802d938:	eea6 4aa2 	vfma.f32	s8, s13, s5
 802d93c:	eee3 4aa6 	vfma.f32	s9, s7, s13
 802d940:	eee4 5a26 	vfma.f32	s11, s8, s13
 802d944:	eee4 7aa6 	vfma.f32	s15, s9, s13
 802d948:	ee67 7a85 	vmul.f32	s15, s15, s10
 802d94c:	eee5 7aa6 	vfma.f32	s15, s11, s13
 802d950:	dd48      	ble.n	802d9e4 <__ieee754_logf+0x1bc>
 802d952:	eef6 5a00 	vmov.f32	s11, #96	; 0x60
 802d956:	ee67 5a25 	vmul.f32	s11, s14, s11
 802d95a:	ee65 5a87 	vmul.f32	s11, s11, s14
 802d95e:	b9a3      	cbnz	r3, 802d98a <__ieee754_logf+0x162>
 802d960:	ee75 6aa7 	vadd.f32	s13, s11, s15
 802d964:	eee6 5ac6 	vfms.f32	s11, s13, s12
 802d968:	ee77 7a65 	vsub.f32	s15, s14, s11
 802d96c:	e798      	b.n	802d8a0 <__ieee754_logf+0x78>
 802d96e:	eddf 6a35 	vldr	s13, [pc, #212]	; 802da44 <__ieee754_logf+0x21c>
 802d972:	eef6 7a00 	vmov.f32	s15, #96	; 0x60
 802d976:	eee7 7a66 	vfms.f32	s15, s14, s13
 802d97a:	ee67 6a07 	vmul.f32	s13, s14, s14
 802d97e:	ee66 7aa7 	vmul.f32	s15, s13, s15
 802d982:	b99b      	cbnz	r3, 802d9ac <__ieee754_logf+0x184>
 802d984:	ee77 7a67 	vsub.f32	s15, s14, s15
 802d988:	e78a      	b.n	802d8a0 <__ieee754_logf+0x78>
 802d98a:	ed9f 5a2f 	vldr	s10, [pc, #188]	; 802da48 <__ieee754_logf+0x220>
 802d98e:	eddf 4a2f 	vldr	s9, [pc, #188]	; 802da4c <__ieee754_logf+0x224>
 802d992:	ee75 6aa7 	vadd.f32	s13, s11, s15
 802d996:	ee63 7a05 	vmul.f32	s15, s6, s10
 802d99a:	eee6 7a86 	vfma.f32	s15, s13, s12
 802d99e:	ee75 7ae7 	vsub.f32	s15, s11, s15
 802d9a2:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802d9a6:	eed3 7a24 	vfnms.f32	s15, s6, s9
 802d9aa:	e779      	b.n	802d8a0 <__ieee754_logf+0x78>
 802d9ac:	ee06 3a90 	vmov	s13, r3
 802d9b0:	eddf 5a25 	vldr	s11, [pc, #148]	; 802da48 <__ieee754_logf+0x220>
 802d9b4:	ed9f 6a25 	vldr	s12, [pc, #148]	; 802da4c <__ieee754_logf+0x224>
 802d9b8:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 802d9bc:	eee6 7ae5 	vfms.f32	s15, s13, s11
 802d9c0:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802d9c4:	eed6 7a86 	vfnms.f32	s15, s13, s12
 802d9c8:	e76a      	b.n	802d8a0 <__ieee754_logf+0x78>
 802d9ca:	ee07 3a90 	vmov	s15, r3
 802d9ce:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 802d9d2:	eddf 7a1d 	vldr	s15, [pc, #116]	; 802da48 <__ieee754_logf+0x220>
 802d9d6:	eddf 6a1d 	vldr	s13, [pc, #116]	; 802da4c <__ieee754_logf+0x224>
 802d9da:	ee67 7a27 	vmul.f32	s15, s14, s15
 802d9de:	eee7 7a26 	vfma.f32	s15, s14, s13
 802d9e2:	e75d      	b.n	802d8a0 <__ieee754_logf+0x78>
 802d9e4:	b173      	cbz	r3, 802da04 <__ieee754_logf+0x1dc>
 802d9e6:	eddf 5a18 	vldr	s11, [pc, #96]	; 802da48 <__ieee754_logf+0x220>
 802d9ea:	ed9f 5a18 	vldr	s10, [pc, #96]	; 802da4c <__ieee754_logf+0x224>
 802d9ee:	ee77 6a67 	vsub.f32	s13, s14, s15
 802d9f2:	ee65 7ac3 	vnmul.f32	s15, s11, s6
 802d9f6:	eee6 7a86 	vfma.f32	s15, s13, s12
 802d9fa:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802d9fe:	eed3 7a05 	vfnms.f32	s15, s6, s10
 802da02:	e74d      	b.n	802d8a0 <__ieee754_logf+0x78>
 802da04:	ee77 7a67 	vsub.f32	s15, s14, s15
 802da08:	eea7 7ac6 	vfms.f32	s14, s15, s12
 802da0c:	eef0 7a47 	vmov.f32	s15, s14
 802da10:	e746      	b.n	802d8a0 <__ieee754_logf+0x78>
 802da12:	bf00      	nop
 802da14:	004afb20 	.word	0x004afb20
 802da18:	00000000 	.word	0x00000000
 802da1c:	cc000000 	.word	0xcc000000
 802da20:	4c000000 	.word	0x4c000000
 802da24:	ffcf5c30 	.word	0xffcf5c30
 802da28:	3e178897 	.word	0x3e178897
 802da2c:	3e3a3325 	.word	0x3e3a3325
 802da30:	3e924925 	.word	0x3e924925
 802da34:	3e1cd04f 	.word	0x3e1cd04f
 802da38:	3e638e29 	.word	0x3e638e29
 802da3c:	3f2aaaab 	.word	0x3f2aaaab
 802da40:	3ecccccd 	.word	0x3ecccccd
 802da44:	3eaaaaab 	.word	0x3eaaaaab
 802da48:	3717f7d1 	.word	0x3717f7d1
 802da4c:	3f317180 	.word	0x3f317180

0802da50 <__ieee754_sqrtf>:
 802da50:	f020 4200 	bic.w	r2, r0, #2147483648	; 0x80000000
 802da54:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 802da58:	b470      	push	{r4, r5, r6}
 802da5a:	ee07 0a90 	vmov	s15, r0
 802da5e:	4603      	mov	r3, r0
 802da60:	d232      	bcs.n	802dac8 <__ieee754_sqrtf+0x78>
 802da62:	b36a      	cbz	r2, 802dac0 <__ieee754_sqrtf+0x70>
 802da64:	2800      	cmp	r0, #0
 802da66:	db41      	blt.n	802daec <__ieee754_sqrtf+0x9c>
 802da68:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
 802da6c:	ea4f 51e0 	mov.w	r1, r0, asr #23
 802da70:	d330      	bcc.n	802dad4 <__ieee754_sqrtf+0x84>
 802da72:	f1a1 027f 	sub.w	r2, r1, #127	; 0x7f
 802da76:	f3c3 0316 	ubfx	r3, r3, #0, #23
 802da7a:	07d1      	lsls	r1, r2, #31
 802da7c:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 802da80:	bf48      	it	mi
 802da82:	005b      	lslmi	r3, r3, #1
 802da84:	2400      	movs	r4, #0
 802da86:	1056      	asrs	r6, r2, #1
 802da88:	005b      	lsls	r3, r3, #1
 802da8a:	4625      	mov	r5, r4
 802da8c:	2119      	movs	r1, #25
 802da8e:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 802da92:	18a8      	adds	r0, r5, r2
 802da94:	4298      	cmp	r0, r3
 802da96:	dc02      	bgt.n	802da9e <__ieee754_sqrtf+0x4e>
 802da98:	1a1b      	subs	r3, r3, r0
 802da9a:	1885      	adds	r5, r0, r2
 802da9c:	4414      	add	r4, r2
 802da9e:	3901      	subs	r1, #1
 802daa0:	ea4f 0343 	mov.w	r3, r3, lsl #1
 802daa4:	ea4f 0252 	mov.w	r2, r2, lsr #1
 802daa8:	d1f3      	bne.n	802da92 <__ieee754_sqrtf+0x42>
 802daaa:	b113      	cbz	r3, 802dab2 <__ieee754_sqrtf+0x62>
 802daac:	f004 0301 	and.w	r3, r4, #1
 802dab0:	441c      	add	r4, r3
 802dab2:	1064      	asrs	r4, r4, #1
 802dab4:	f104 547c 	add.w	r4, r4, #1056964608	; 0x3f000000
 802dab8:	eb04 53c6 	add.w	r3, r4, r6, lsl #23
 802dabc:	ee07 3a90 	vmov	s15, r3
 802dac0:	ee17 0a90 	vmov	r0, s15
 802dac4:	bc70      	pop	{r4, r5, r6}
 802dac6:	4770      	bx	lr
 802dac8:	eee7 7aa7 	vfma.f32	s15, s15, s15
 802dacc:	bc70      	pop	{r4, r5, r6}
 802dace:	ee17 0a90 	vmov	r0, s15
 802dad2:	4770      	bx	lr
 802dad4:	f410 0200 	ands.w	r2, r0, #8388608	; 0x800000
 802dad8:	d10d      	bne.n	802daf6 <__ieee754_sqrtf+0xa6>
 802dada:	005b      	lsls	r3, r3, #1
 802dadc:	0218      	lsls	r0, r3, #8
 802dade:	f102 0201 	add.w	r2, r2, #1
 802dae2:	d5fa      	bpl.n	802dada <__ieee754_sqrtf+0x8a>
 802dae4:	f1c2 0201 	rsb	r2, r2, #1
 802dae8:	4411      	add	r1, r2
 802daea:	e7c2      	b.n	802da72 <__ieee754_sqrtf+0x22>
 802daec:	ee77 7ae7 	vsub.f32	s15, s15, s15
 802daf0:	eec7 7aa7 	vdiv.f32	s15, s15, s15
 802daf4:	e7e4      	b.n	802dac0 <__ieee754_sqrtf+0x70>
 802daf6:	2201      	movs	r2, #1
 802daf8:	4411      	add	r1, r2
 802dafa:	e7ba      	b.n	802da72 <__ieee754_sqrtf+0x22>

0802dafc <__fpclassifyd>:
 802dafc:	b410      	push	{r4}
 802dafe:	f031 4400 	bics.w	r4, r1, #2147483648	; 0x80000000
 802db02:	460b      	mov	r3, r1
 802db04:	d008      	beq.n	802db18 <__fpclassifyd+0x1c>
 802db06:	4a11      	ldr	r2, [pc, #68]	; (802db4c <__fpclassifyd+0x50>)
 802db08:	f5a1 1180 	sub.w	r1, r1, #1048576	; 0x100000
 802db0c:	4291      	cmp	r1, r2
 802db0e:	d808      	bhi.n	802db22 <__fpclassifyd+0x26>
 802db10:	2004      	movs	r0, #4
 802db12:	f85d 4b04 	ldr.w	r4, [sp], #4
 802db16:	4770      	bx	lr
 802db18:	b918      	cbnz	r0, 802db22 <__fpclassifyd+0x26>
 802db1a:	2002      	movs	r0, #2
 802db1c:	f85d 4b04 	ldr.w	r4, [sp], #4
 802db20:	4770      	bx	lr
 802db22:	f103 43ff 	add.w	r3, r3, #2139095040	; 0x7f800000
 802db26:	4a09      	ldr	r2, [pc, #36]	; (802db4c <__fpclassifyd+0x50>)
 802db28:	f503 03e0 	add.w	r3, r3, #7340032	; 0x700000
 802db2c:	4293      	cmp	r3, r2
 802db2e:	d9ef      	bls.n	802db10 <__fpclassifyd+0x14>
 802db30:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
 802db34:	d201      	bcs.n	802db3a <__fpclassifyd+0x3e>
 802db36:	2003      	movs	r0, #3
 802db38:	e7eb      	b.n	802db12 <__fpclassifyd+0x16>
 802db3a:	4b05      	ldr	r3, [pc, #20]	; (802db50 <__fpclassifyd+0x54>)
 802db3c:	429c      	cmp	r4, r3
 802db3e:	d001      	beq.n	802db44 <__fpclassifyd+0x48>
 802db40:	2000      	movs	r0, #0
 802db42:	e7e6      	b.n	802db12 <__fpclassifyd+0x16>
 802db44:	fab0 f080 	clz	r0, r0
 802db48:	0940      	lsrs	r0, r0, #5
 802db4a:	e7e2      	b.n	802db12 <__fpclassifyd+0x16>
 802db4c:	7fdfffff 	.word	0x7fdfffff
 802db50:	7ff00000 	.word	0x7ff00000

0802db54 <matherr>:
 802db54:	2000      	movs	r0, #0
 802db56:	4770      	bx	lr

0802db58 <nan>:
 802db58:	2000      	movs	r0, #0
 802db5a:	4901      	ldr	r1, [pc, #4]	; (802db60 <nan+0x8>)
 802db5c:	4770      	bx	lr
 802db5e:	bf00      	nop
 802db60:	7ff80000 	.word	0x7ff80000

0802db64 <__fpclassifyf>:
 802db64:	f030 4000 	bics.w	r0, r0, #2147483648	; 0x80000000
 802db68:	d101      	bne.n	802db6e <__fpclassifyf+0xa>
 802db6a:	2002      	movs	r0, #2
 802db6c:	4770      	bx	lr
 802db6e:	f5a0 0300 	sub.w	r3, r0, #8388608	; 0x800000
 802db72:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
 802db76:	d201      	bcs.n	802db7c <__fpclassifyf+0x18>
 802db78:	2004      	movs	r0, #4
 802db7a:	4770      	bx	lr
 802db7c:	4b05      	ldr	r3, [pc, #20]	; (802db94 <__fpclassifyf+0x30>)
 802db7e:	1e42      	subs	r2, r0, #1
 802db80:	429a      	cmp	r2, r3
 802db82:	d801      	bhi.n	802db88 <__fpclassifyf+0x24>
 802db84:	2003      	movs	r0, #3
 802db86:	4770      	bx	lr
 802db88:	f1a0 40ff 	sub.w	r0, r0, #2139095040	; 0x7f800000
 802db8c:	fab0 f080 	clz	r0, r0
 802db90:	0940      	lsrs	r0, r0, #5
 802db92:	4770      	bx	lr
 802db94:	007ffffe 	.word	0x007ffffe

0802db98 <__aeabi_drsub>:
 802db98:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 802db9c:	e002      	b.n	802dba4 <__adddf3>
 802db9e:	bf00      	nop

0802dba0 <__aeabi_dsub>:
 802dba0:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0802dba4 <__adddf3>:
 802dba4:	b530      	push	{r4, r5, lr}
 802dba6:	ea4f 0441 	mov.w	r4, r1, lsl #1
 802dbaa:	ea4f 0543 	mov.w	r5, r3, lsl #1
 802dbae:	ea94 0f05 	teq	r4, r5
 802dbb2:	bf08      	it	eq
 802dbb4:	ea90 0f02 	teqeq	r0, r2
 802dbb8:	bf1f      	itttt	ne
 802dbba:	ea54 0c00 	orrsne.w	ip, r4, r0
 802dbbe:	ea55 0c02 	orrsne.w	ip, r5, r2
 802dbc2:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 802dbc6:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 802dbca:	f000 80e2 	beq.w	802dd92 <__adddf3+0x1ee>
 802dbce:	ea4f 5454 	mov.w	r4, r4, lsr #21
 802dbd2:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 802dbd6:	bfb8      	it	lt
 802dbd8:	426d      	neglt	r5, r5
 802dbda:	dd0c      	ble.n	802dbf6 <__adddf3+0x52>
 802dbdc:	442c      	add	r4, r5
 802dbde:	ea80 0202 	eor.w	r2, r0, r2
 802dbe2:	ea81 0303 	eor.w	r3, r1, r3
 802dbe6:	ea82 0000 	eor.w	r0, r2, r0
 802dbea:	ea83 0101 	eor.w	r1, r3, r1
 802dbee:	ea80 0202 	eor.w	r2, r0, r2
 802dbf2:	ea81 0303 	eor.w	r3, r1, r3
 802dbf6:	2d36      	cmp	r5, #54	; 0x36
 802dbf8:	bf88      	it	hi
 802dbfa:	bd30      	pophi	{r4, r5, pc}
 802dbfc:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 802dc00:	ea4f 3101 	mov.w	r1, r1, lsl #12
 802dc04:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 802dc08:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 802dc0c:	d002      	beq.n	802dc14 <__adddf3+0x70>
 802dc0e:	4240      	negs	r0, r0
 802dc10:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 802dc14:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 802dc18:	ea4f 3303 	mov.w	r3, r3, lsl #12
 802dc1c:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 802dc20:	d002      	beq.n	802dc28 <__adddf3+0x84>
 802dc22:	4252      	negs	r2, r2
 802dc24:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 802dc28:	ea94 0f05 	teq	r4, r5
 802dc2c:	f000 80a7 	beq.w	802dd7e <__adddf3+0x1da>
 802dc30:	f1a4 0401 	sub.w	r4, r4, #1
 802dc34:	f1d5 0e20 	rsbs	lr, r5, #32
 802dc38:	db0d      	blt.n	802dc56 <__adddf3+0xb2>
 802dc3a:	fa02 fc0e 	lsl.w	ip, r2, lr
 802dc3e:	fa22 f205 	lsr.w	r2, r2, r5
 802dc42:	1880      	adds	r0, r0, r2
 802dc44:	f141 0100 	adc.w	r1, r1, #0
 802dc48:	fa03 f20e 	lsl.w	r2, r3, lr
 802dc4c:	1880      	adds	r0, r0, r2
 802dc4e:	fa43 f305 	asr.w	r3, r3, r5
 802dc52:	4159      	adcs	r1, r3
 802dc54:	e00e      	b.n	802dc74 <__adddf3+0xd0>
 802dc56:	f1a5 0520 	sub.w	r5, r5, #32
 802dc5a:	f10e 0e20 	add.w	lr, lr, #32
 802dc5e:	2a01      	cmp	r2, #1
 802dc60:	fa03 fc0e 	lsl.w	ip, r3, lr
 802dc64:	bf28      	it	cs
 802dc66:	f04c 0c02 	orrcs.w	ip, ip, #2
 802dc6a:	fa43 f305 	asr.w	r3, r3, r5
 802dc6e:	18c0      	adds	r0, r0, r3
 802dc70:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 802dc74:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 802dc78:	d507      	bpl.n	802dc8a <__adddf3+0xe6>
 802dc7a:	f04f 0e00 	mov.w	lr, #0
 802dc7e:	f1dc 0c00 	rsbs	ip, ip, #0
 802dc82:	eb7e 0000 	sbcs.w	r0, lr, r0
 802dc86:	eb6e 0101 	sbc.w	r1, lr, r1
 802dc8a:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 802dc8e:	d31b      	bcc.n	802dcc8 <__adddf3+0x124>
 802dc90:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 802dc94:	d30c      	bcc.n	802dcb0 <__adddf3+0x10c>
 802dc96:	0849      	lsrs	r1, r1, #1
 802dc98:	ea5f 0030 	movs.w	r0, r0, rrx
 802dc9c:	ea4f 0c3c 	mov.w	ip, ip, rrx
 802dca0:	f104 0401 	add.w	r4, r4, #1
 802dca4:	ea4f 5244 	mov.w	r2, r4, lsl #21
 802dca8:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 802dcac:	f080 809a 	bcs.w	802dde4 <__adddf3+0x240>
 802dcb0:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 802dcb4:	bf08      	it	eq
 802dcb6:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 802dcba:	f150 0000 	adcs.w	r0, r0, #0
 802dcbe:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 802dcc2:	ea41 0105 	orr.w	r1, r1, r5
 802dcc6:	bd30      	pop	{r4, r5, pc}
 802dcc8:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 802dccc:	4140      	adcs	r0, r0
 802dcce:	eb41 0101 	adc.w	r1, r1, r1
 802dcd2:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 802dcd6:	f1a4 0401 	sub.w	r4, r4, #1
 802dcda:	d1e9      	bne.n	802dcb0 <__adddf3+0x10c>
 802dcdc:	f091 0f00 	teq	r1, #0
 802dce0:	bf04      	itt	eq
 802dce2:	4601      	moveq	r1, r0
 802dce4:	2000      	moveq	r0, #0
 802dce6:	fab1 f381 	clz	r3, r1
 802dcea:	bf08      	it	eq
 802dcec:	3320      	addeq	r3, #32
 802dcee:	f1a3 030b 	sub.w	r3, r3, #11
 802dcf2:	f1b3 0220 	subs.w	r2, r3, #32
 802dcf6:	da0c      	bge.n	802dd12 <__adddf3+0x16e>
 802dcf8:	320c      	adds	r2, #12
 802dcfa:	dd08      	ble.n	802dd0e <__adddf3+0x16a>
 802dcfc:	f102 0c14 	add.w	ip, r2, #20
 802dd00:	f1c2 020c 	rsb	r2, r2, #12
 802dd04:	fa01 f00c 	lsl.w	r0, r1, ip
 802dd08:	fa21 f102 	lsr.w	r1, r1, r2
 802dd0c:	e00c      	b.n	802dd28 <__adddf3+0x184>
 802dd0e:	f102 0214 	add.w	r2, r2, #20
 802dd12:	bfd8      	it	le
 802dd14:	f1c2 0c20 	rsble	ip, r2, #32
 802dd18:	fa01 f102 	lsl.w	r1, r1, r2
 802dd1c:	fa20 fc0c 	lsr.w	ip, r0, ip
 802dd20:	bfdc      	itt	le
 802dd22:	ea41 010c 	orrle.w	r1, r1, ip
 802dd26:	4090      	lslle	r0, r2
 802dd28:	1ae4      	subs	r4, r4, r3
 802dd2a:	bfa2      	ittt	ge
 802dd2c:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 802dd30:	4329      	orrge	r1, r5
 802dd32:	bd30      	popge	{r4, r5, pc}
 802dd34:	ea6f 0404 	mvn.w	r4, r4
 802dd38:	3c1f      	subs	r4, #31
 802dd3a:	da1c      	bge.n	802dd76 <__adddf3+0x1d2>
 802dd3c:	340c      	adds	r4, #12
 802dd3e:	dc0e      	bgt.n	802dd5e <__adddf3+0x1ba>
 802dd40:	f104 0414 	add.w	r4, r4, #20
 802dd44:	f1c4 0220 	rsb	r2, r4, #32
 802dd48:	fa20 f004 	lsr.w	r0, r0, r4
 802dd4c:	fa01 f302 	lsl.w	r3, r1, r2
 802dd50:	ea40 0003 	orr.w	r0, r0, r3
 802dd54:	fa21 f304 	lsr.w	r3, r1, r4
 802dd58:	ea45 0103 	orr.w	r1, r5, r3
 802dd5c:	bd30      	pop	{r4, r5, pc}
 802dd5e:	f1c4 040c 	rsb	r4, r4, #12
 802dd62:	f1c4 0220 	rsb	r2, r4, #32
 802dd66:	fa20 f002 	lsr.w	r0, r0, r2
 802dd6a:	fa01 f304 	lsl.w	r3, r1, r4
 802dd6e:	ea40 0003 	orr.w	r0, r0, r3
 802dd72:	4629      	mov	r1, r5
 802dd74:	bd30      	pop	{r4, r5, pc}
 802dd76:	fa21 f004 	lsr.w	r0, r1, r4
 802dd7a:	4629      	mov	r1, r5
 802dd7c:	bd30      	pop	{r4, r5, pc}
 802dd7e:	f094 0f00 	teq	r4, #0
 802dd82:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 802dd86:	bf06      	itte	eq
 802dd88:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 802dd8c:	3401      	addeq	r4, #1
 802dd8e:	3d01      	subne	r5, #1
 802dd90:	e74e      	b.n	802dc30 <__adddf3+0x8c>
 802dd92:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 802dd96:	bf18      	it	ne
 802dd98:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 802dd9c:	d029      	beq.n	802ddf2 <__adddf3+0x24e>
 802dd9e:	ea94 0f05 	teq	r4, r5
 802dda2:	bf08      	it	eq
 802dda4:	ea90 0f02 	teqeq	r0, r2
 802dda8:	d005      	beq.n	802ddb6 <__adddf3+0x212>
 802ddaa:	ea54 0c00 	orrs.w	ip, r4, r0
 802ddae:	bf04      	itt	eq
 802ddb0:	4619      	moveq	r1, r3
 802ddb2:	4610      	moveq	r0, r2
 802ddb4:	bd30      	pop	{r4, r5, pc}
 802ddb6:	ea91 0f03 	teq	r1, r3
 802ddba:	bf1e      	ittt	ne
 802ddbc:	2100      	movne	r1, #0
 802ddbe:	2000      	movne	r0, #0
 802ddc0:	bd30      	popne	{r4, r5, pc}
 802ddc2:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 802ddc6:	d105      	bne.n	802ddd4 <__adddf3+0x230>
 802ddc8:	0040      	lsls	r0, r0, #1
 802ddca:	4149      	adcs	r1, r1
 802ddcc:	bf28      	it	cs
 802ddce:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 802ddd2:	bd30      	pop	{r4, r5, pc}
 802ddd4:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 802ddd8:	bf3c      	itt	cc
 802ddda:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 802ddde:	bd30      	popcc	{r4, r5, pc}
 802dde0:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 802dde4:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 802dde8:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 802ddec:	f04f 0000 	mov.w	r0, #0
 802ddf0:	bd30      	pop	{r4, r5, pc}
 802ddf2:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 802ddf6:	bf1a      	itte	ne
 802ddf8:	4619      	movne	r1, r3
 802ddfa:	4610      	movne	r0, r2
 802ddfc:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 802de00:	bf1c      	itt	ne
 802de02:	460b      	movne	r3, r1
 802de04:	4602      	movne	r2, r0
 802de06:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 802de0a:	bf06      	itte	eq
 802de0c:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 802de10:	ea91 0f03 	teqeq	r1, r3
 802de14:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 802de18:	bd30      	pop	{r4, r5, pc}
 802de1a:	bf00      	nop

0802de1c <__aeabi_ui2d>:
 802de1c:	f090 0f00 	teq	r0, #0
 802de20:	bf04      	itt	eq
 802de22:	2100      	moveq	r1, #0
 802de24:	4770      	bxeq	lr
 802de26:	b530      	push	{r4, r5, lr}
 802de28:	f44f 6480 	mov.w	r4, #1024	; 0x400
 802de2c:	f104 0432 	add.w	r4, r4, #50	; 0x32
 802de30:	f04f 0500 	mov.w	r5, #0
 802de34:	f04f 0100 	mov.w	r1, #0
 802de38:	e750      	b.n	802dcdc <__adddf3+0x138>
 802de3a:	bf00      	nop

0802de3c <__aeabi_i2d>:
 802de3c:	f090 0f00 	teq	r0, #0
 802de40:	bf04      	itt	eq
 802de42:	2100      	moveq	r1, #0
 802de44:	4770      	bxeq	lr
 802de46:	b530      	push	{r4, r5, lr}
 802de48:	f44f 6480 	mov.w	r4, #1024	; 0x400
 802de4c:	f104 0432 	add.w	r4, r4, #50	; 0x32
 802de50:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 802de54:	bf48      	it	mi
 802de56:	4240      	negmi	r0, r0
 802de58:	f04f 0100 	mov.w	r1, #0
 802de5c:	e73e      	b.n	802dcdc <__adddf3+0x138>
 802de5e:	bf00      	nop

0802de60 <__aeabi_f2d>:
 802de60:	0042      	lsls	r2, r0, #1
 802de62:	ea4f 01e2 	mov.w	r1, r2, asr #3
 802de66:	ea4f 0131 	mov.w	r1, r1, rrx
 802de6a:	ea4f 7002 	mov.w	r0, r2, lsl #28
 802de6e:	bf1f      	itttt	ne
 802de70:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 802de74:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 802de78:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 802de7c:	4770      	bxne	lr
 802de7e:	f092 0f00 	teq	r2, #0
 802de82:	bf14      	ite	ne
 802de84:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 802de88:	4770      	bxeq	lr
 802de8a:	b530      	push	{r4, r5, lr}
 802de8c:	f44f 7460 	mov.w	r4, #896	; 0x380
 802de90:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 802de94:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 802de98:	e720      	b.n	802dcdc <__adddf3+0x138>
 802de9a:	bf00      	nop

0802de9c <__aeabi_ul2d>:
 802de9c:	ea50 0201 	orrs.w	r2, r0, r1
 802dea0:	bf08      	it	eq
 802dea2:	4770      	bxeq	lr
 802dea4:	b530      	push	{r4, r5, lr}
 802dea6:	f04f 0500 	mov.w	r5, #0
 802deaa:	e00a      	b.n	802dec2 <__aeabi_l2d+0x16>

0802deac <__aeabi_l2d>:
 802deac:	ea50 0201 	orrs.w	r2, r0, r1
 802deb0:	bf08      	it	eq
 802deb2:	4770      	bxeq	lr
 802deb4:	b530      	push	{r4, r5, lr}
 802deb6:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 802deba:	d502      	bpl.n	802dec2 <__aeabi_l2d+0x16>
 802debc:	4240      	negs	r0, r0
 802debe:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 802dec2:	f44f 6480 	mov.w	r4, #1024	; 0x400
 802dec6:	f104 0432 	add.w	r4, r4, #50	; 0x32
 802deca:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 802dece:	f43f aedc 	beq.w	802dc8a <__adddf3+0xe6>
 802ded2:	f04f 0203 	mov.w	r2, #3
 802ded6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 802deda:	bf18      	it	ne
 802dedc:	3203      	addne	r2, #3
 802dede:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 802dee2:	bf18      	it	ne
 802dee4:	3203      	addne	r2, #3
 802dee6:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 802deea:	f1c2 0320 	rsb	r3, r2, #32
 802deee:	fa00 fc03 	lsl.w	ip, r0, r3
 802def2:	fa20 f002 	lsr.w	r0, r0, r2
 802def6:	fa01 fe03 	lsl.w	lr, r1, r3
 802defa:	ea40 000e 	orr.w	r0, r0, lr
 802defe:	fa21 f102 	lsr.w	r1, r1, r2
 802df02:	4414      	add	r4, r2
 802df04:	e6c1      	b.n	802dc8a <__adddf3+0xe6>
 802df06:	bf00      	nop

0802df08 <__aeabi_dmul>:
 802df08:	b570      	push	{r4, r5, r6, lr}
 802df0a:	f04f 0cff 	mov.w	ip, #255	; 0xff
 802df0e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 802df12:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 802df16:	bf1d      	ittte	ne
 802df18:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 802df1c:	ea94 0f0c 	teqne	r4, ip
 802df20:	ea95 0f0c 	teqne	r5, ip
 802df24:	f000 f8de 	bleq	802e0e4 <__aeabi_dmul+0x1dc>
 802df28:	442c      	add	r4, r5
 802df2a:	ea81 0603 	eor.w	r6, r1, r3
 802df2e:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 802df32:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 802df36:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 802df3a:	bf18      	it	ne
 802df3c:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 802df40:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 802df44:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 802df48:	d038      	beq.n	802dfbc <__aeabi_dmul+0xb4>
 802df4a:	fba0 ce02 	umull	ip, lr, r0, r2
 802df4e:	f04f 0500 	mov.w	r5, #0
 802df52:	fbe1 e502 	umlal	lr, r5, r1, r2
 802df56:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 802df5a:	fbe0 e503 	umlal	lr, r5, r0, r3
 802df5e:	f04f 0600 	mov.w	r6, #0
 802df62:	fbe1 5603 	umlal	r5, r6, r1, r3
 802df66:	f09c 0f00 	teq	ip, #0
 802df6a:	bf18      	it	ne
 802df6c:	f04e 0e01 	orrne.w	lr, lr, #1
 802df70:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 802df74:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 802df78:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 802df7c:	d204      	bcs.n	802df88 <__aeabi_dmul+0x80>
 802df7e:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 802df82:	416d      	adcs	r5, r5
 802df84:	eb46 0606 	adc.w	r6, r6, r6
 802df88:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 802df8c:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 802df90:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 802df94:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 802df98:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 802df9c:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 802dfa0:	bf88      	it	hi
 802dfa2:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 802dfa6:	d81e      	bhi.n	802dfe6 <__aeabi_dmul+0xde>
 802dfa8:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 802dfac:	bf08      	it	eq
 802dfae:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 802dfb2:	f150 0000 	adcs.w	r0, r0, #0
 802dfb6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 802dfba:	bd70      	pop	{r4, r5, r6, pc}
 802dfbc:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 802dfc0:	ea46 0101 	orr.w	r1, r6, r1
 802dfc4:	ea40 0002 	orr.w	r0, r0, r2
 802dfc8:	ea81 0103 	eor.w	r1, r1, r3
 802dfcc:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 802dfd0:	bfc2      	ittt	gt
 802dfd2:	ebd4 050c 	rsbsgt	r5, r4, ip
 802dfd6:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 802dfda:	bd70      	popgt	{r4, r5, r6, pc}
 802dfdc:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 802dfe0:	f04f 0e00 	mov.w	lr, #0
 802dfe4:	3c01      	subs	r4, #1
 802dfe6:	f300 80ab 	bgt.w	802e140 <__aeabi_dmul+0x238>
 802dfea:	f114 0f36 	cmn.w	r4, #54	; 0x36
 802dfee:	bfde      	ittt	le
 802dff0:	2000      	movle	r0, #0
 802dff2:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 802dff6:	bd70      	pople	{r4, r5, r6, pc}
 802dff8:	f1c4 0400 	rsb	r4, r4, #0
 802dffc:	3c20      	subs	r4, #32
 802dffe:	da35      	bge.n	802e06c <__aeabi_dmul+0x164>
 802e000:	340c      	adds	r4, #12
 802e002:	dc1b      	bgt.n	802e03c <__aeabi_dmul+0x134>
 802e004:	f104 0414 	add.w	r4, r4, #20
 802e008:	f1c4 0520 	rsb	r5, r4, #32
 802e00c:	fa00 f305 	lsl.w	r3, r0, r5
 802e010:	fa20 f004 	lsr.w	r0, r0, r4
 802e014:	fa01 f205 	lsl.w	r2, r1, r5
 802e018:	ea40 0002 	orr.w	r0, r0, r2
 802e01c:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 802e020:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 802e024:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 802e028:	fa21 f604 	lsr.w	r6, r1, r4
 802e02c:	eb42 0106 	adc.w	r1, r2, r6
 802e030:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 802e034:	bf08      	it	eq
 802e036:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 802e03a:	bd70      	pop	{r4, r5, r6, pc}
 802e03c:	f1c4 040c 	rsb	r4, r4, #12
 802e040:	f1c4 0520 	rsb	r5, r4, #32
 802e044:	fa00 f304 	lsl.w	r3, r0, r4
 802e048:	fa20 f005 	lsr.w	r0, r0, r5
 802e04c:	fa01 f204 	lsl.w	r2, r1, r4
 802e050:	ea40 0002 	orr.w	r0, r0, r2
 802e054:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 802e058:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 802e05c:	f141 0100 	adc.w	r1, r1, #0
 802e060:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 802e064:	bf08      	it	eq
 802e066:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 802e06a:	bd70      	pop	{r4, r5, r6, pc}
 802e06c:	f1c4 0520 	rsb	r5, r4, #32
 802e070:	fa00 f205 	lsl.w	r2, r0, r5
 802e074:	ea4e 0e02 	orr.w	lr, lr, r2
 802e078:	fa20 f304 	lsr.w	r3, r0, r4
 802e07c:	fa01 f205 	lsl.w	r2, r1, r5
 802e080:	ea43 0302 	orr.w	r3, r3, r2
 802e084:	fa21 f004 	lsr.w	r0, r1, r4
 802e088:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 802e08c:	fa21 f204 	lsr.w	r2, r1, r4
 802e090:	ea20 0002 	bic.w	r0, r0, r2
 802e094:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 802e098:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 802e09c:	bf08      	it	eq
 802e09e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 802e0a2:	bd70      	pop	{r4, r5, r6, pc}
 802e0a4:	f094 0f00 	teq	r4, #0
 802e0a8:	d10f      	bne.n	802e0ca <__aeabi_dmul+0x1c2>
 802e0aa:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 802e0ae:	0040      	lsls	r0, r0, #1
 802e0b0:	eb41 0101 	adc.w	r1, r1, r1
 802e0b4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 802e0b8:	bf08      	it	eq
 802e0ba:	3c01      	subeq	r4, #1
 802e0bc:	d0f7      	beq.n	802e0ae <__aeabi_dmul+0x1a6>
 802e0be:	ea41 0106 	orr.w	r1, r1, r6
 802e0c2:	f095 0f00 	teq	r5, #0
 802e0c6:	bf18      	it	ne
 802e0c8:	4770      	bxne	lr
 802e0ca:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 802e0ce:	0052      	lsls	r2, r2, #1
 802e0d0:	eb43 0303 	adc.w	r3, r3, r3
 802e0d4:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 802e0d8:	bf08      	it	eq
 802e0da:	3d01      	subeq	r5, #1
 802e0dc:	d0f7      	beq.n	802e0ce <__aeabi_dmul+0x1c6>
 802e0de:	ea43 0306 	orr.w	r3, r3, r6
 802e0e2:	4770      	bx	lr
 802e0e4:	ea94 0f0c 	teq	r4, ip
 802e0e8:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 802e0ec:	bf18      	it	ne
 802e0ee:	ea95 0f0c 	teqne	r5, ip
 802e0f2:	d00c      	beq.n	802e10e <__aeabi_dmul+0x206>
 802e0f4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 802e0f8:	bf18      	it	ne
 802e0fa:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 802e0fe:	d1d1      	bne.n	802e0a4 <__aeabi_dmul+0x19c>
 802e100:	ea81 0103 	eor.w	r1, r1, r3
 802e104:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 802e108:	f04f 0000 	mov.w	r0, #0
 802e10c:	bd70      	pop	{r4, r5, r6, pc}
 802e10e:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 802e112:	bf06      	itte	eq
 802e114:	4610      	moveq	r0, r2
 802e116:	4619      	moveq	r1, r3
 802e118:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 802e11c:	d019      	beq.n	802e152 <__aeabi_dmul+0x24a>
 802e11e:	ea94 0f0c 	teq	r4, ip
 802e122:	d102      	bne.n	802e12a <__aeabi_dmul+0x222>
 802e124:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 802e128:	d113      	bne.n	802e152 <__aeabi_dmul+0x24a>
 802e12a:	ea95 0f0c 	teq	r5, ip
 802e12e:	d105      	bne.n	802e13c <__aeabi_dmul+0x234>
 802e130:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 802e134:	bf1c      	itt	ne
 802e136:	4610      	movne	r0, r2
 802e138:	4619      	movne	r1, r3
 802e13a:	d10a      	bne.n	802e152 <__aeabi_dmul+0x24a>
 802e13c:	ea81 0103 	eor.w	r1, r1, r3
 802e140:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 802e144:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 802e148:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 802e14c:	f04f 0000 	mov.w	r0, #0
 802e150:	bd70      	pop	{r4, r5, r6, pc}
 802e152:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 802e156:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 802e15a:	bd70      	pop	{r4, r5, r6, pc}

0802e15c <__aeabi_ddiv>:
 802e15c:	b570      	push	{r4, r5, r6, lr}
 802e15e:	f04f 0cff 	mov.w	ip, #255	; 0xff
 802e162:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 802e166:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 802e16a:	bf1d      	ittte	ne
 802e16c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 802e170:	ea94 0f0c 	teqne	r4, ip
 802e174:	ea95 0f0c 	teqne	r5, ip
 802e178:	f000 f8a7 	bleq	802e2ca <__aeabi_ddiv+0x16e>
 802e17c:	eba4 0405 	sub.w	r4, r4, r5
 802e180:	ea81 0e03 	eor.w	lr, r1, r3
 802e184:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 802e188:	ea4f 3101 	mov.w	r1, r1, lsl #12
 802e18c:	f000 8088 	beq.w	802e2a0 <__aeabi_ddiv+0x144>
 802e190:	ea4f 3303 	mov.w	r3, r3, lsl #12
 802e194:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 802e198:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 802e19c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 802e1a0:	ea4f 2202 	mov.w	r2, r2, lsl #8
 802e1a4:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 802e1a8:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 802e1ac:	ea4f 2600 	mov.w	r6, r0, lsl #8
 802e1b0:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 802e1b4:	429d      	cmp	r5, r3
 802e1b6:	bf08      	it	eq
 802e1b8:	4296      	cmpeq	r6, r2
 802e1ba:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 802e1be:	f504 7440 	add.w	r4, r4, #768	; 0x300
 802e1c2:	d202      	bcs.n	802e1ca <__aeabi_ddiv+0x6e>
 802e1c4:	085b      	lsrs	r3, r3, #1
 802e1c6:	ea4f 0232 	mov.w	r2, r2, rrx
 802e1ca:	1ab6      	subs	r6, r6, r2
 802e1cc:	eb65 0503 	sbc.w	r5, r5, r3
 802e1d0:	085b      	lsrs	r3, r3, #1
 802e1d2:	ea4f 0232 	mov.w	r2, r2, rrx
 802e1d6:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 802e1da:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 802e1de:	ebb6 0e02 	subs.w	lr, r6, r2
 802e1e2:	eb75 0e03 	sbcs.w	lr, r5, r3
 802e1e6:	bf22      	ittt	cs
 802e1e8:	1ab6      	subcs	r6, r6, r2
 802e1ea:	4675      	movcs	r5, lr
 802e1ec:	ea40 000c 	orrcs.w	r0, r0, ip
 802e1f0:	085b      	lsrs	r3, r3, #1
 802e1f2:	ea4f 0232 	mov.w	r2, r2, rrx
 802e1f6:	ebb6 0e02 	subs.w	lr, r6, r2
 802e1fa:	eb75 0e03 	sbcs.w	lr, r5, r3
 802e1fe:	bf22      	ittt	cs
 802e200:	1ab6      	subcs	r6, r6, r2
 802e202:	4675      	movcs	r5, lr
 802e204:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 802e208:	085b      	lsrs	r3, r3, #1
 802e20a:	ea4f 0232 	mov.w	r2, r2, rrx
 802e20e:	ebb6 0e02 	subs.w	lr, r6, r2
 802e212:	eb75 0e03 	sbcs.w	lr, r5, r3
 802e216:	bf22      	ittt	cs
 802e218:	1ab6      	subcs	r6, r6, r2
 802e21a:	4675      	movcs	r5, lr
 802e21c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 802e220:	085b      	lsrs	r3, r3, #1
 802e222:	ea4f 0232 	mov.w	r2, r2, rrx
 802e226:	ebb6 0e02 	subs.w	lr, r6, r2
 802e22a:	eb75 0e03 	sbcs.w	lr, r5, r3
 802e22e:	bf22      	ittt	cs
 802e230:	1ab6      	subcs	r6, r6, r2
 802e232:	4675      	movcs	r5, lr
 802e234:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 802e238:	ea55 0e06 	orrs.w	lr, r5, r6
 802e23c:	d018      	beq.n	802e270 <__aeabi_ddiv+0x114>
 802e23e:	ea4f 1505 	mov.w	r5, r5, lsl #4
 802e242:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 802e246:	ea4f 1606 	mov.w	r6, r6, lsl #4
 802e24a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 802e24e:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 802e252:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 802e256:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 802e25a:	d1c0      	bne.n	802e1de <__aeabi_ddiv+0x82>
 802e25c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 802e260:	d10b      	bne.n	802e27a <__aeabi_ddiv+0x11e>
 802e262:	ea41 0100 	orr.w	r1, r1, r0
 802e266:	f04f 0000 	mov.w	r0, #0
 802e26a:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 802e26e:	e7b6      	b.n	802e1de <__aeabi_ddiv+0x82>
 802e270:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 802e274:	bf04      	itt	eq
 802e276:	4301      	orreq	r1, r0
 802e278:	2000      	moveq	r0, #0
 802e27a:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 802e27e:	bf88      	it	hi
 802e280:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 802e284:	f63f aeaf 	bhi.w	802dfe6 <__aeabi_dmul+0xde>
 802e288:	ebb5 0c03 	subs.w	ip, r5, r3
 802e28c:	bf04      	itt	eq
 802e28e:	ebb6 0c02 	subseq.w	ip, r6, r2
 802e292:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 802e296:	f150 0000 	adcs.w	r0, r0, #0
 802e29a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 802e29e:	bd70      	pop	{r4, r5, r6, pc}
 802e2a0:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 802e2a4:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 802e2a8:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 802e2ac:	bfc2      	ittt	gt
 802e2ae:	ebd4 050c 	rsbsgt	r5, r4, ip
 802e2b2:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 802e2b6:	bd70      	popgt	{r4, r5, r6, pc}
 802e2b8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 802e2bc:	f04f 0e00 	mov.w	lr, #0
 802e2c0:	3c01      	subs	r4, #1
 802e2c2:	e690      	b.n	802dfe6 <__aeabi_dmul+0xde>
 802e2c4:	ea45 0e06 	orr.w	lr, r5, r6
 802e2c8:	e68d      	b.n	802dfe6 <__aeabi_dmul+0xde>
 802e2ca:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 802e2ce:	ea94 0f0c 	teq	r4, ip
 802e2d2:	bf08      	it	eq
 802e2d4:	ea95 0f0c 	teqeq	r5, ip
 802e2d8:	f43f af3b 	beq.w	802e152 <__aeabi_dmul+0x24a>
 802e2dc:	ea94 0f0c 	teq	r4, ip
 802e2e0:	d10a      	bne.n	802e2f8 <__aeabi_ddiv+0x19c>
 802e2e2:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 802e2e6:	f47f af34 	bne.w	802e152 <__aeabi_dmul+0x24a>
 802e2ea:	ea95 0f0c 	teq	r5, ip
 802e2ee:	f47f af25 	bne.w	802e13c <__aeabi_dmul+0x234>
 802e2f2:	4610      	mov	r0, r2
 802e2f4:	4619      	mov	r1, r3
 802e2f6:	e72c      	b.n	802e152 <__aeabi_dmul+0x24a>
 802e2f8:	ea95 0f0c 	teq	r5, ip
 802e2fc:	d106      	bne.n	802e30c <__aeabi_ddiv+0x1b0>
 802e2fe:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 802e302:	f43f aefd 	beq.w	802e100 <__aeabi_dmul+0x1f8>
 802e306:	4610      	mov	r0, r2
 802e308:	4619      	mov	r1, r3
 802e30a:	e722      	b.n	802e152 <__aeabi_dmul+0x24a>
 802e30c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 802e310:	bf18      	it	ne
 802e312:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 802e316:	f47f aec5 	bne.w	802e0a4 <__aeabi_dmul+0x19c>
 802e31a:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 802e31e:	f47f af0d 	bne.w	802e13c <__aeabi_dmul+0x234>
 802e322:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 802e326:	f47f aeeb 	bne.w	802e100 <__aeabi_dmul+0x1f8>
 802e32a:	e712      	b.n	802e152 <__aeabi_dmul+0x24a>

0802e32c <__gedf2>:
 802e32c:	f04f 3cff 	mov.w	ip, #4294967295
 802e330:	e006      	b.n	802e340 <__cmpdf2+0x4>
 802e332:	bf00      	nop

0802e334 <__ledf2>:
 802e334:	f04f 0c01 	mov.w	ip, #1
 802e338:	e002      	b.n	802e340 <__cmpdf2+0x4>
 802e33a:	bf00      	nop

0802e33c <__cmpdf2>:
 802e33c:	f04f 0c01 	mov.w	ip, #1
 802e340:	f84d cd04 	str.w	ip, [sp, #-4]!
 802e344:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 802e348:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 802e34c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 802e350:	bf18      	it	ne
 802e352:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 802e356:	d01b      	beq.n	802e390 <__cmpdf2+0x54>
 802e358:	b001      	add	sp, #4
 802e35a:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 802e35e:	bf0c      	ite	eq
 802e360:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 802e364:	ea91 0f03 	teqne	r1, r3
 802e368:	bf02      	ittt	eq
 802e36a:	ea90 0f02 	teqeq	r0, r2
 802e36e:	2000      	moveq	r0, #0
 802e370:	4770      	bxeq	lr
 802e372:	f110 0f00 	cmn.w	r0, #0
 802e376:	ea91 0f03 	teq	r1, r3
 802e37a:	bf58      	it	pl
 802e37c:	4299      	cmppl	r1, r3
 802e37e:	bf08      	it	eq
 802e380:	4290      	cmpeq	r0, r2
 802e382:	bf2c      	ite	cs
 802e384:	17d8      	asrcs	r0, r3, #31
 802e386:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 802e38a:	f040 0001 	orr.w	r0, r0, #1
 802e38e:	4770      	bx	lr
 802e390:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 802e394:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 802e398:	d102      	bne.n	802e3a0 <__cmpdf2+0x64>
 802e39a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 802e39e:	d107      	bne.n	802e3b0 <__cmpdf2+0x74>
 802e3a0:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 802e3a4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 802e3a8:	d1d6      	bne.n	802e358 <__cmpdf2+0x1c>
 802e3aa:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 802e3ae:	d0d3      	beq.n	802e358 <__cmpdf2+0x1c>
 802e3b0:	f85d 0b04 	ldr.w	r0, [sp], #4
 802e3b4:	4770      	bx	lr
 802e3b6:	bf00      	nop

0802e3b8 <__aeabi_cdrcmple>:
 802e3b8:	4684      	mov	ip, r0
 802e3ba:	4610      	mov	r0, r2
 802e3bc:	4662      	mov	r2, ip
 802e3be:	468c      	mov	ip, r1
 802e3c0:	4619      	mov	r1, r3
 802e3c2:	4663      	mov	r3, ip
 802e3c4:	e000      	b.n	802e3c8 <__aeabi_cdcmpeq>
 802e3c6:	bf00      	nop

0802e3c8 <__aeabi_cdcmpeq>:
 802e3c8:	b501      	push	{r0, lr}
 802e3ca:	f7ff ffb7 	bl	802e33c <__cmpdf2>
 802e3ce:	2800      	cmp	r0, #0
 802e3d0:	bf48      	it	mi
 802e3d2:	f110 0f00 	cmnmi.w	r0, #0
 802e3d6:	bd01      	pop	{r0, pc}

0802e3d8 <__aeabi_dcmpeq>:
 802e3d8:	f84d ed08 	str.w	lr, [sp, #-8]!
 802e3dc:	f7ff fff4 	bl	802e3c8 <__aeabi_cdcmpeq>
 802e3e0:	bf0c      	ite	eq
 802e3e2:	2001      	moveq	r0, #1
 802e3e4:	2000      	movne	r0, #0
 802e3e6:	f85d fb08 	ldr.w	pc, [sp], #8
 802e3ea:	bf00      	nop

0802e3ec <__aeabi_dcmplt>:
 802e3ec:	f84d ed08 	str.w	lr, [sp, #-8]!
 802e3f0:	f7ff ffea 	bl	802e3c8 <__aeabi_cdcmpeq>
 802e3f4:	bf34      	ite	cc
 802e3f6:	2001      	movcc	r0, #1
 802e3f8:	2000      	movcs	r0, #0
 802e3fa:	f85d fb08 	ldr.w	pc, [sp], #8
 802e3fe:	bf00      	nop

0802e400 <__aeabi_dcmple>:
 802e400:	f84d ed08 	str.w	lr, [sp, #-8]!
 802e404:	f7ff ffe0 	bl	802e3c8 <__aeabi_cdcmpeq>
 802e408:	bf94      	ite	ls
 802e40a:	2001      	movls	r0, #1
 802e40c:	2000      	movhi	r0, #0
 802e40e:	f85d fb08 	ldr.w	pc, [sp], #8
 802e412:	bf00      	nop

0802e414 <__aeabi_dcmpge>:
 802e414:	f84d ed08 	str.w	lr, [sp, #-8]!
 802e418:	f7ff ffce 	bl	802e3b8 <__aeabi_cdrcmple>
 802e41c:	bf94      	ite	ls
 802e41e:	2001      	movls	r0, #1
 802e420:	2000      	movhi	r0, #0
 802e422:	f85d fb08 	ldr.w	pc, [sp], #8
 802e426:	bf00      	nop

0802e428 <__aeabi_dcmpgt>:
 802e428:	f84d ed08 	str.w	lr, [sp, #-8]!
 802e42c:	f7ff ffc4 	bl	802e3b8 <__aeabi_cdrcmple>
 802e430:	bf34      	ite	cc
 802e432:	2001      	movcc	r0, #1
 802e434:	2000      	movcs	r0, #0
 802e436:	f85d fb08 	ldr.w	pc, [sp], #8
 802e43a:	bf00      	nop

0802e43c <__aeabi_d2iz>:
 802e43c:	ea4f 0241 	mov.w	r2, r1, lsl #1
 802e440:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 802e444:	d215      	bcs.n	802e472 <__aeabi_d2iz+0x36>
 802e446:	d511      	bpl.n	802e46c <__aeabi_d2iz+0x30>
 802e448:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 802e44c:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 802e450:	d912      	bls.n	802e478 <__aeabi_d2iz+0x3c>
 802e452:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 802e456:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 802e45a:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 802e45e:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 802e462:	fa23 f002 	lsr.w	r0, r3, r2
 802e466:	bf18      	it	ne
 802e468:	4240      	negne	r0, r0
 802e46a:	4770      	bx	lr
 802e46c:	f04f 0000 	mov.w	r0, #0
 802e470:	4770      	bx	lr
 802e472:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 802e476:	d105      	bne.n	802e484 <__aeabi_d2iz+0x48>
 802e478:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 802e47c:	bf08      	it	eq
 802e47e:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 802e482:	4770      	bx	lr
 802e484:	f04f 0000 	mov.w	r0, #0
 802e488:	4770      	bx	lr
 802e48a:	bf00      	nop

0802e48c <__aeabi_d2uiz>:
 802e48c:	004a      	lsls	r2, r1, #1
 802e48e:	d211      	bcs.n	802e4b4 <__aeabi_d2uiz+0x28>
 802e490:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 802e494:	d211      	bcs.n	802e4ba <__aeabi_d2uiz+0x2e>
 802e496:	d50d      	bpl.n	802e4b4 <__aeabi_d2uiz+0x28>
 802e498:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 802e49c:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 802e4a0:	d40e      	bmi.n	802e4c0 <__aeabi_d2uiz+0x34>
 802e4a2:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 802e4a6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 802e4aa:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 802e4ae:	fa23 f002 	lsr.w	r0, r3, r2
 802e4b2:	4770      	bx	lr
 802e4b4:	f04f 0000 	mov.w	r0, #0
 802e4b8:	4770      	bx	lr
 802e4ba:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 802e4be:	d102      	bne.n	802e4c6 <__aeabi_d2uiz+0x3a>
 802e4c0:	f04f 30ff 	mov.w	r0, #4294967295
 802e4c4:	4770      	bx	lr
 802e4c6:	f04f 0000 	mov.w	r0, #0
 802e4ca:	4770      	bx	lr

0802e4cc <__aeabi_d2f>:
 802e4cc:	ea4f 0241 	mov.w	r2, r1, lsl #1
 802e4d0:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 802e4d4:	bf24      	itt	cs
 802e4d6:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 802e4da:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 802e4de:	d90d      	bls.n	802e4fc <__aeabi_d2f+0x30>
 802e4e0:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 802e4e4:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 802e4e8:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 802e4ec:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 802e4f0:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 802e4f4:	bf08      	it	eq
 802e4f6:	f020 0001 	biceq.w	r0, r0, #1
 802e4fa:	4770      	bx	lr
 802e4fc:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 802e500:	d121      	bne.n	802e546 <__aeabi_d2f+0x7a>
 802e502:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 802e506:	bfbc      	itt	lt
 802e508:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 802e50c:	4770      	bxlt	lr
 802e50e:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 802e512:	ea4f 5252 	mov.w	r2, r2, lsr #21
 802e516:	f1c2 0218 	rsb	r2, r2, #24
 802e51a:	f1c2 0c20 	rsb	ip, r2, #32
 802e51e:	fa10 f30c 	lsls.w	r3, r0, ip
 802e522:	fa20 f002 	lsr.w	r0, r0, r2
 802e526:	bf18      	it	ne
 802e528:	f040 0001 	orrne.w	r0, r0, #1
 802e52c:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 802e530:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 802e534:	fa03 fc0c 	lsl.w	ip, r3, ip
 802e538:	ea40 000c 	orr.w	r0, r0, ip
 802e53c:	fa23 f302 	lsr.w	r3, r3, r2
 802e540:	ea4f 0343 	mov.w	r3, r3, lsl #1
 802e544:	e7cc      	b.n	802e4e0 <__aeabi_d2f+0x14>
 802e546:	ea7f 5362 	mvns.w	r3, r2, asr #21
 802e54a:	d107      	bne.n	802e55c <__aeabi_d2f+0x90>
 802e54c:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 802e550:	bf1e      	ittt	ne
 802e552:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 802e556:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 802e55a:	4770      	bxne	lr
 802e55c:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 802e560:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 802e564:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 802e568:	4770      	bx	lr
 802e56a:	bf00      	nop

0802e56c <__aeabi_uldivmod>:
 802e56c:	b94b      	cbnz	r3, 802e582 <__aeabi_uldivmod+0x16>
 802e56e:	b942      	cbnz	r2, 802e582 <__aeabi_uldivmod+0x16>
 802e570:	2900      	cmp	r1, #0
 802e572:	bf08      	it	eq
 802e574:	2800      	cmpeq	r0, #0
 802e576:	d002      	beq.n	802e57e <__aeabi_uldivmod+0x12>
 802e578:	f04f 31ff 	mov.w	r1, #4294967295
 802e57c:	4608      	mov	r0, r1
 802e57e:	f000 b877 	b.w	802e670 <__aeabi_idiv0>
 802e582:	b082      	sub	sp, #8
 802e584:	46ec      	mov	ip, sp
 802e586:	e92d 5000 	stmdb	sp!, {ip, lr}
 802e58a:	f000 f859 	bl	802e640 <__gnu_uldivmod_helper>
 802e58e:	f8dd e004 	ldr.w	lr, [sp, #4]
 802e592:	b002      	add	sp, #8
 802e594:	bc0c      	pop	{r2, r3}
 802e596:	4770      	bx	lr

0802e598 <__aeabi_d2lz>:
 802e598:	b538      	push	{r3, r4, r5, lr}
 802e59a:	2200      	movs	r2, #0
 802e59c:	2300      	movs	r3, #0
 802e59e:	4604      	mov	r4, r0
 802e5a0:	460d      	mov	r5, r1
 802e5a2:	f7ff ff23 	bl	802e3ec <__aeabi_dcmplt>
 802e5a6:	b928      	cbnz	r0, 802e5b4 <__aeabi_d2lz+0x1c>
 802e5a8:	4620      	mov	r0, r4
 802e5aa:	4629      	mov	r1, r5
 802e5ac:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 802e5b0:	f000 b80a 	b.w	802e5c8 <__aeabi_d2ulz>
 802e5b4:	4620      	mov	r0, r4
 802e5b6:	f105 4100 	add.w	r1, r5, #2147483648	; 0x80000000
 802e5ba:	f000 f805 	bl	802e5c8 <__aeabi_d2ulz>
 802e5be:	4240      	negs	r0, r0
 802e5c0:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 802e5c4:	bd38      	pop	{r3, r4, r5, pc}
 802e5c6:	bf00      	nop

0802e5c8 <__aeabi_d2ulz>:
 802e5c8:	b5d0      	push	{r4, r6, r7, lr}
 802e5ca:	2200      	movs	r2, #0
 802e5cc:	4b0e      	ldr	r3, [pc, #56]	; (802e608 <__aeabi_d2ulz+0x40>)
 802e5ce:	4606      	mov	r6, r0
 802e5d0:	460f      	mov	r7, r1
 802e5d2:	f7ff fc99 	bl	802df08 <__aeabi_dmul>
 802e5d6:	f7ff ff59 	bl	802e48c <__aeabi_d2uiz>
 802e5da:	4604      	mov	r4, r0
 802e5dc:	f7ff fc1e 	bl	802de1c <__aeabi_ui2d>
 802e5e0:	2200      	movs	r2, #0
 802e5e2:	4b0a      	ldr	r3, [pc, #40]	; (802e60c <__aeabi_d2ulz+0x44>)
 802e5e4:	f7ff fc90 	bl	802df08 <__aeabi_dmul>
 802e5e8:	4602      	mov	r2, r0
 802e5ea:	460b      	mov	r3, r1
 802e5ec:	4630      	mov	r0, r6
 802e5ee:	4639      	mov	r1, r7
 802e5f0:	f7ff fad6 	bl	802dba0 <__aeabi_dsub>
 802e5f4:	f7ff ff4a 	bl	802e48c <__aeabi_d2uiz>
 802e5f8:	4623      	mov	r3, r4
 802e5fa:	2200      	movs	r2, #0
 802e5fc:	ea42 0200 	orr.w	r2, r2, r0
 802e600:	4610      	mov	r0, r2
 802e602:	4619      	mov	r1, r3
 802e604:	bdd0      	pop	{r4, r6, r7, pc}
 802e606:	bf00      	nop
 802e608:	3df00000 	.word	0x3df00000
 802e60c:	41f00000 	.word	0x41f00000

0802e610 <__gnu_ldivmod_helper>:
 802e610:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802e614:	9c06      	ldr	r4, [sp, #24]
 802e616:	4615      	mov	r5, r2
 802e618:	4606      	mov	r6, r0
 802e61a:	460f      	mov	r7, r1
 802e61c:	4698      	mov	r8, r3
 802e61e:	f000 f829 	bl	802e674 <__divdi3>
 802e622:	fb05 f301 	mul.w	r3, r5, r1
 802e626:	fb00 3808 	mla	r8, r0, r8, r3
 802e62a:	fba5 2300 	umull	r2, r3, r5, r0
 802e62e:	1ab2      	subs	r2, r6, r2
 802e630:	4443      	add	r3, r8
 802e632:	eb67 0303 	sbc.w	r3, r7, r3
 802e636:	e9c4 2300 	strd	r2, r3, [r4]
 802e63a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802e63e:	bf00      	nop

0802e640 <__gnu_uldivmod_helper>:
 802e640:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802e644:	9c06      	ldr	r4, [sp, #24]
 802e646:	4690      	mov	r8, r2
 802e648:	4606      	mov	r6, r0
 802e64a:	460f      	mov	r7, r1
 802e64c:	461d      	mov	r5, r3
 802e64e:	f000 f95f 	bl	802e910 <__udivdi3>
 802e652:	fb00 f505 	mul.w	r5, r0, r5
 802e656:	fba0 2308 	umull	r2, r3, r0, r8
 802e65a:	fb08 5501 	mla	r5, r8, r1, r5
 802e65e:	1ab2      	subs	r2, r6, r2
 802e660:	442b      	add	r3, r5
 802e662:	eb67 0303 	sbc.w	r3, r7, r3
 802e666:	e9c4 2300 	strd	r2, r3, [r4]
 802e66a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802e66e:	bf00      	nop

0802e670 <__aeabi_idiv0>:
 802e670:	4770      	bx	lr
 802e672:	bf00      	nop

0802e674 <__divdi3>:
 802e674:	2900      	cmp	r1, #0
 802e676:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 802e67a:	f2c0 80a6 	blt.w	802e7ca <__divdi3+0x156>
 802e67e:	2600      	movs	r6, #0
 802e680:	2b00      	cmp	r3, #0
 802e682:	f2c0 809c 	blt.w	802e7be <__divdi3+0x14a>
 802e686:	4688      	mov	r8, r1
 802e688:	4694      	mov	ip, r2
 802e68a:	469e      	mov	lr, r3
 802e68c:	4615      	mov	r5, r2
 802e68e:	4604      	mov	r4, r0
 802e690:	460f      	mov	r7, r1
 802e692:	2b00      	cmp	r3, #0
 802e694:	d13d      	bne.n	802e712 <__divdi3+0x9e>
 802e696:	428a      	cmp	r2, r1
 802e698:	d959      	bls.n	802e74e <__divdi3+0xda>
 802e69a:	fab2 f382 	clz	r3, r2
 802e69e:	b13b      	cbz	r3, 802e6b0 <__divdi3+0x3c>
 802e6a0:	f1c3 0220 	rsb	r2, r3, #32
 802e6a4:	409f      	lsls	r7, r3
 802e6a6:	fa20 f202 	lsr.w	r2, r0, r2
 802e6aa:	409d      	lsls	r5, r3
 802e6ac:	4317      	orrs	r7, r2
 802e6ae:	409c      	lsls	r4, r3
 802e6b0:	0c29      	lsrs	r1, r5, #16
 802e6b2:	0c22      	lsrs	r2, r4, #16
 802e6b4:	fbb7 fef1 	udiv	lr, r7, r1
 802e6b8:	b2a8      	uxth	r0, r5
 802e6ba:	fb01 771e 	mls	r7, r1, lr, r7
 802e6be:	ea42 4707 	orr.w	r7, r2, r7, lsl #16
 802e6c2:	fb00 f30e 	mul.w	r3, r0, lr
 802e6c6:	42bb      	cmp	r3, r7
 802e6c8:	d90a      	bls.n	802e6e0 <__divdi3+0x6c>
 802e6ca:	197f      	adds	r7, r7, r5
 802e6cc:	f10e 32ff 	add.w	r2, lr, #4294967295
 802e6d0:	f080 8105 	bcs.w	802e8de <__divdi3+0x26a>
 802e6d4:	42bb      	cmp	r3, r7
 802e6d6:	f240 8102 	bls.w	802e8de <__divdi3+0x26a>
 802e6da:	f1ae 0e02 	sub.w	lr, lr, #2
 802e6de:	442f      	add	r7, r5
 802e6e0:	1aff      	subs	r7, r7, r3
 802e6e2:	b2a4      	uxth	r4, r4
 802e6e4:	fbb7 f3f1 	udiv	r3, r7, r1
 802e6e8:	fb01 7713 	mls	r7, r1, r3, r7
 802e6ec:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
 802e6f0:	fb00 f003 	mul.w	r0, r0, r3
 802e6f4:	42b8      	cmp	r0, r7
 802e6f6:	d908      	bls.n	802e70a <__divdi3+0x96>
 802e6f8:	197f      	adds	r7, r7, r5
 802e6fa:	f103 32ff 	add.w	r2, r3, #4294967295
 802e6fe:	f080 80f0 	bcs.w	802e8e2 <__divdi3+0x26e>
 802e702:	42b8      	cmp	r0, r7
 802e704:	f240 80ed 	bls.w	802e8e2 <__divdi3+0x26e>
 802e708:	3b02      	subs	r3, #2
 802e70a:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
 802e70e:	2200      	movs	r2, #0
 802e710:	e003      	b.n	802e71a <__divdi3+0xa6>
 802e712:	428b      	cmp	r3, r1
 802e714:	d90f      	bls.n	802e736 <__divdi3+0xc2>
 802e716:	2200      	movs	r2, #0
 802e718:	4613      	mov	r3, r2
 802e71a:	1c34      	adds	r4, r6, #0
 802e71c:	bf18      	it	ne
 802e71e:	2401      	movne	r4, #1
 802e720:	4260      	negs	r0, r4
 802e722:	f04f 0500 	mov.w	r5, #0
 802e726:	eb65 0145 	sbc.w	r1, r5, r5, lsl #1
 802e72a:	4058      	eors	r0, r3
 802e72c:	4051      	eors	r1, r2
 802e72e:	1900      	adds	r0, r0, r4
 802e730:	4169      	adcs	r1, r5
 802e732:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 802e736:	fab3 f283 	clz	r2, r3
 802e73a:	2a00      	cmp	r2, #0
 802e73c:	f040 8086 	bne.w	802e84c <__divdi3+0x1d8>
 802e740:	428b      	cmp	r3, r1
 802e742:	d302      	bcc.n	802e74a <__divdi3+0xd6>
 802e744:	4584      	cmp	ip, r0
 802e746:	f200 80db 	bhi.w	802e900 <__divdi3+0x28c>
 802e74a:	2301      	movs	r3, #1
 802e74c:	e7e5      	b.n	802e71a <__divdi3+0xa6>
 802e74e:	b912      	cbnz	r2, 802e756 <__divdi3+0xe2>
 802e750:	2301      	movs	r3, #1
 802e752:	fbb3 f5f2 	udiv	r5, r3, r2
 802e756:	fab5 f085 	clz	r0, r5
 802e75a:	2800      	cmp	r0, #0
 802e75c:	d13b      	bne.n	802e7d6 <__divdi3+0x162>
 802e75e:	1b78      	subs	r0, r7, r5
 802e760:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 802e764:	fa1f fc85 	uxth.w	ip, r5
 802e768:	2201      	movs	r2, #1
 802e76a:	fbb0 f8fe 	udiv	r8, r0, lr
 802e76e:	0c21      	lsrs	r1, r4, #16
 802e770:	fb0e 0718 	mls	r7, lr, r8, r0
 802e774:	ea41 4707 	orr.w	r7, r1, r7, lsl #16
 802e778:	fb0c f308 	mul.w	r3, ip, r8
 802e77c:	42bb      	cmp	r3, r7
 802e77e:	d907      	bls.n	802e790 <__divdi3+0x11c>
 802e780:	197f      	adds	r7, r7, r5
 802e782:	f108 31ff 	add.w	r1, r8, #4294967295
 802e786:	d202      	bcs.n	802e78e <__divdi3+0x11a>
 802e788:	42bb      	cmp	r3, r7
 802e78a:	f200 80bd 	bhi.w	802e908 <__divdi3+0x294>
 802e78e:	4688      	mov	r8, r1
 802e790:	1aff      	subs	r7, r7, r3
 802e792:	b2a4      	uxth	r4, r4
 802e794:	fbb7 f3fe 	udiv	r3, r7, lr
 802e798:	fb0e 7713 	mls	r7, lr, r3, r7
 802e79c:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
 802e7a0:	fb0c fc03 	mul.w	ip, ip, r3
 802e7a4:	45bc      	cmp	ip, r7
 802e7a6:	d907      	bls.n	802e7b8 <__divdi3+0x144>
 802e7a8:	197f      	adds	r7, r7, r5
 802e7aa:	f103 31ff 	add.w	r1, r3, #4294967295
 802e7ae:	d202      	bcs.n	802e7b6 <__divdi3+0x142>
 802e7b0:	45bc      	cmp	ip, r7
 802e7b2:	f200 80a7 	bhi.w	802e904 <__divdi3+0x290>
 802e7b6:	460b      	mov	r3, r1
 802e7b8:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 802e7bc:	e7ad      	b.n	802e71a <__divdi3+0xa6>
 802e7be:	4252      	negs	r2, r2
 802e7c0:	ea6f 0606 	mvn.w	r6, r6
 802e7c4:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 802e7c8:	e75d      	b.n	802e686 <__divdi3+0x12>
 802e7ca:	4240      	negs	r0, r0
 802e7cc:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 802e7d0:	f04f 36ff 	mov.w	r6, #4294967295
 802e7d4:	e754      	b.n	802e680 <__divdi3+0xc>
 802e7d6:	f1c0 0220 	rsb	r2, r0, #32
 802e7da:	fa24 f102 	lsr.w	r1, r4, r2
 802e7de:	fa07 f300 	lsl.w	r3, r7, r0
 802e7e2:	4085      	lsls	r5, r0
 802e7e4:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 802e7e8:	40d7      	lsrs	r7, r2
 802e7ea:	4319      	orrs	r1, r3
 802e7ec:	fbb7 f2fe 	udiv	r2, r7, lr
 802e7f0:	0c0b      	lsrs	r3, r1, #16
 802e7f2:	fb0e 7712 	mls	r7, lr, r2, r7
 802e7f6:	fa1f fc85 	uxth.w	ip, r5
 802e7fa:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 802e7fe:	fb0c f702 	mul.w	r7, ip, r2
 802e802:	429f      	cmp	r7, r3
 802e804:	fa04 f400 	lsl.w	r4, r4, r0
 802e808:	d907      	bls.n	802e81a <__divdi3+0x1a6>
 802e80a:	195b      	adds	r3, r3, r5
 802e80c:	f102 30ff 	add.w	r0, r2, #4294967295
 802e810:	d274      	bcs.n	802e8fc <__divdi3+0x288>
 802e812:	429f      	cmp	r7, r3
 802e814:	d972      	bls.n	802e8fc <__divdi3+0x288>
 802e816:	3a02      	subs	r2, #2
 802e818:	442b      	add	r3, r5
 802e81a:	1bdf      	subs	r7, r3, r7
 802e81c:	b289      	uxth	r1, r1
 802e81e:	fbb7 f8fe 	udiv	r8, r7, lr
 802e822:	fb0e 7318 	mls	r3, lr, r8, r7
 802e826:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 802e82a:	fb0c f708 	mul.w	r7, ip, r8
 802e82e:	429f      	cmp	r7, r3
 802e830:	d908      	bls.n	802e844 <__divdi3+0x1d0>
 802e832:	195b      	adds	r3, r3, r5
 802e834:	f108 31ff 	add.w	r1, r8, #4294967295
 802e838:	d25c      	bcs.n	802e8f4 <__divdi3+0x280>
 802e83a:	429f      	cmp	r7, r3
 802e83c:	d95a      	bls.n	802e8f4 <__divdi3+0x280>
 802e83e:	f1a8 0802 	sub.w	r8, r8, #2
 802e842:	442b      	add	r3, r5
 802e844:	1bd8      	subs	r0, r3, r7
 802e846:	ea48 4202 	orr.w	r2, r8, r2, lsl #16
 802e84a:	e78e      	b.n	802e76a <__divdi3+0xf6>
 802e84c:	f1c2 0320 	rsb	r3, r2, #32
 802e850:	fa2c f103 	lsr.w	r1, ip, r3
 802e854:	fa0e fe02 	lsl.w	lr, lr, r2
 802e858:	fa20 f703 	lsr.w	r7, r0, r3
 802e85c:	ea41 0e0e 	orr.w	lr, r1, lr
 802e860:	fa08 f002 	lsl.w	r0, r8, r2
 802e864:	fa28 f103 	lsr.w	r1, r8, r3
 802e868:	ea4f 451e 	mov.w	r5, lr, lsr #16
 802e86c:	4338      	orrs	r0, r7
 802e86e:	fbb1 f8f5 	udiv	r8, r1, r5
 802e872:	0c03      	lsrs	r3, r0, #16
 802e874:	fb05 1118 	mls	r1, r5, r8, r1
 802e878:	fa1f f78e 	uxth.w	r7, lr
 802e87c:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 802e880:	fb07 f308 	mul.w	r3, r7, r8
 802e884:	428b      	cmp	r3, r1
 802e886:	fa0c fc02 	lsl.w	ip, ip, r2
 802e88a:	d909      	bls.n	802e8a0 <__divdi3+0x22c>
 802e88c:	eb11 010e 	adds.w	r1, r1, lr
 802e890:	f108 39ff 	add.w	r9, r8, #4294967295
 802e894:	d230      	bcs.n	802e8f8 <__divdi3+0x284>
 802e896:	428b      	cmp	r3, r1
 802e898:	d92e      	bls.n	802e8f8 <__divdi3+0x284>
 802e89a:	f1a8 0802 	sub.w	r8, r8, #2
 802e89e:	4471      	add	r1, lr
 802e8a0:	1ac9      	subs	r1, r1, r3
 802e8a2:	b280      	uxth	r0, r0
 802e8a4:	fbb1 f3f5 	udiv	r3, r1, r5
 802e8a8:	fb05 1113 	mls	r1, r5, r3, r1
 802e8ac:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 802e8b0:	fb07 f703 	mul.w	r7, r7, r3
 802e8b4:	428f      	cmp	r7, r1
 802e8b6:	d908      	bls.n	802e8ca <__divdi3+0x256>
 802e8b8:	eb11 010e 	adds.w	r1, r1, lr
 802e8bc:	f103 30ff 	add.w	r0, r3, #4294967295
 802e8c0:	d216      	bcs.n	802e8f0 <__divdi3+0x27c>
 802e8c2:	428f      	cmp	r7, r1
 802e8c4:	d914      	bls.n	802e8f0 <__divdi3+0x27c>
 802e8c6:	3b02      	subs	r3, #2
 802e8c8:	4471      	add	r1, lr
 802e8ca:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 802e8ce:	1bc9      	subs	r1, r1, r7
 802e8d0:	fba3 890c 	umull	r8, r9, r3, ip
 802e8d4:	4549      	cmp	r1, r9
 802e8d6:	d309      	bcc.n	802e8ec <__divdi3+0x278>
 802e8d8:	d005      	beq.n	802e8e6 <__divdi3+0x272>
 802e8da:	2200      	movs	r2, #0
 802e8dc:	e71d      	b.n	802e71a <__divdi3+0xa6>
 802e8de:	4696      	mov	lr, r2
 802e8e0:	e6fe      	b.n	802e6e0 <__divdi3+0x6c>
 802e8e2:	4613      	mov	r3, r2
 802e8e4:	e711      	b.n	802e70a <__divdi3+0x96>
 802e8e6:	4094      	lsls	r4, r2
 802e8e8:	4544      	cmp	r4, r8
 802e8ea:	d2f6      	bcs.n	802e8da <__divdi3+0x266>
 802e8ec:	3b01      	subs	r3, #1
 802e8ee:	e7f4      	b.n	802e8da <__divdi3+0x266>
 802e8f0:	4603      	mov	r3, r0
 802e8f2:	e7ea      	b.n	802e8ca <__divdi3+0x256>
 802e8f4:	4688      	mov	r8, r1
 802e8f6:	e7a5      	b.n	802e844 <__divdi3+0x1d0>
 802e8f8:	46c8      	mov	r8, r9
 802e8fa:	e7d1      	b.n	802e8a0 <__divdi3+0x22c>
 802e8fc:	4602      	mov	r2, r0
 802e8fe:	e78c      	b.n	802e81a <__divdi3+0x1a6>
 802e900:	4613      	mov	r3, r2
 802e902:	e70a      	b.n	802e71a <__divdi3+0xa6>
 802e904:	3b02      	subs	r3, #2
 802e906:	e757      	b.n	802e7b8 <__divdi3+0x144>
 802e908:	f1a8 0802 	sub.w	r8, r8, #2
 802e90c:	442f      	add	r7, r5
 802e90e:	e73f      	b.n	802e790 <__divdi3+0x11c>

0802e910 <__udivdi3>:
 802e910:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802e914:	2b00      	cmp	r3, #0
 802e916:	d144      	bne.n	802e9a2 <__udivdi3+0x92>
 802e918:	428a      	cmp	r2, r1
 802e91a:	4615      	mov	r5, r2
 802e91c:	4604      	mov	r4, r0
 802e91e:	d94f      	bls.n	802e9c0 <__udivdi3+0xb0>
 802e920:	fab2 f782 	clz	r7, r2
 802e924:	460e      	mov	r6, r1
 802e926:	b14f      	cbz	r7, 802e93c <__udivdi3+0x2c>
 802e928:	f1c7 0320 	rsb	r3, r7, #32
 802e92c:	40b9      	lsls	r1, r7
 802e92e:	fa20 f603 	lsr.w	r6, r0, r3
 802e932:	fa02 f507 	lsl.w	r5, r2, r7
 802e936:	430e      	orrs	r6, r1
 802e938:	fa00 f407 	lsl.w	r4, r0, r7
 802e93c:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 802e940:	0c23      	lsrs	r3, r4, #16
 802e942:	fbb6 f0fe 	udiv	r0, r6, lr
 802e946:	b2af      	uxth	r7, r5
 802e948:	fb0e 6110 	mls	r1, lr, r0, r6
 802e94c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 802e950:	fb07 f100 	mul.w	r1, r7, r0
 802e954:	4299      	cmp	r1, r3
 802e956:	d909      	bls.n	802e96c <__udivdi3+0x5c>
 802e958:	195b      	adds	r3, r3, r5
 802e95a:	f100 32ff 	add.w	r2, r0, #4294967295
 802e95e:	f080 80ec 	bcs.w	802eb3a <__udivdi3+0x22a>
 802e962:	4299      	cmp	r1, r3
 802e964:	f240 80e9 	bls.w	802eb3a <__udivdi3+0x22a>
 802e968:	3802      	subs	r0, #2
 802e96a:	442b      	add	r3, r5
 802e96c:	1a5a      	subs	r2, r3, r1
 802e96e:	b2a4      	uxth	r4, r4
 802e970:	fbb2 f3fe 	udiv	r3, r2, lr
 802e974:	fb0e 2213 	mls	r2, lr, r3, r2
 802e978:	ea44 4202 	orr.w	r2, r4, r2, lsl #16
 802e97c:	fb07 f703 	mul.w	r7, r7, r3
 802e980:	4297      	cmp	r7, r2
 802e982:	d908      	bls.n	802e996 <__udivdi3+0x86>
 802e984:	1952      	adds	r2, r2, r5
 802e986:	f103 31ff 	add.w	r1, r3, #4294967295
 802e98a:	f080 80d8 	bcs.w	802eb3e <__udivdi3+0x22e>
 802e98e:	4297      	cmp	r7, r2
 802e990:	f240 80d5 	bls.w	802eb3e <__udivdi3+0x22e>
 802e994:	3b02      	subs	r3, #2
 802e996:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 802e99a:	2600      	movs	r6, #0
 802e99c:	4631      	mov	r1, r6
 802e99e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802e9a2:	428b      	cmp	r3, r1
 802e9a4:	d847      	bhi.n	802ea36 <__udivdi3+0x126>
 802e9a6:	fab3 f683 	clz	r6, r3
 802e9aa:	2e00      	cmp	r6, #0
 802e9ac:	d148      	bne.n	802ea40 <__udivdi3+0x130>
 802e9ae:	428b      	cmp	r3, r1
 802e9b0:	d302      	bcc.n	802e9b8 <__udivdi3+0xa8>
 802e9b2:	4282      	cmp	r2, r0
 802e9b4:	f200 80cd 	bhi.w	802eb52 <__udivdi3+0x242>
 802e9b8:	2001      	movs	r0, #1
 802e9ba:	4631      	mov	r1, r6
 802e9bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802e9c0:	b912      	cbnz	r2, 802e9c8 <__udivdi3+0xb8>
 802e9c2:	2501      	movs	r5, #1
 802e9c4:	fbb5 f5f2 	udiv	r5, r5, r2
 802e9c8:	fab5 f885 	clz	r8, r5
 802e9cc:	f1b8 0f00 	cmp.w	r8, #0
 802e9d0:	d177      	bne.n	802eac2 <__udivdi3+0x1b2>
 802e9d2:	1b4a      	subs	r2, r1, r5
 802e9d4:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 802e9d8:	b2af      	uxth	r7, r5
 802e9da:	2601      	movs	r6, #1
 802e9dc:	fbb2 f0fe 	udiv	r0, r2, lr
 802e9e0:	0c23      	lsrs	r3, r4, #16
 802e9e2:	fb0e 2110 	mls	r1, lr, r0, r2
 802e9e6:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 802e9ea:	fb07 f300 	mul.w	r3, r7, r0
 802e9ee:	428b      	cmp	r3, r1
 802e9f0:	d907      	bls.n	802ea02 <__udivdi3+0xf2>
 802e9f2:	1949      	adds	r1, r1, r5
 802e9f4:	f100 32ff 	add.w	r2, r0, #4294967295
 802e9f8:	d202      	bcs.n	802ea00 <__udivdi3+0xf0>
 802e9fa:	428b      	cmp	r3, r1
 802e9fc:	f200 80ba 	bhi.w	802eb74 <__udivdi3+0x264>
 802ea00:	4610      	mov	r0, r2
 802ea02:	1ac9      	subs	r1, r1, r3
 802ea04:	b2a4      	uxth	r4, r4
 802ea06:	fbb1 f3fe 	udiv	r3, r1, lr
 802ea0a:	fb0e 1113 	mls	r1, lr, r3, r1
 802ea0e:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
 802ea12:	fb07 f703 	mul.w	r7, r7, r3
 802ea16:	42a7      	cmp	r7, r4
 802ea18:	d908      	bls.n	802ea2c <__udivdi3+0x11c>
 802ea1a:	1964      	adds	r4, r4, r5
 802ea1c:	f103 32ff 	add.w	r2, r3, #4294967295
 802ea20:	f080 808f 	bcs.w	802eb42 <__udivdi3+0x232>
 802ea24:	42a7      	cmp	r7, r4
 802ea26:	f240 808c 	bls.w	802eb42 <__udivdi3+0x232>
 802ea2a:	3b02      	subs	r3, #2
 802ea2c:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 802ea30:	4631      	mov	r1, r6
 802ea32:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802ea36:	2600      	movs	r6, #0
 802ea38:	4630      	mov	r0, r6
 802ea3a:	4631      	mov	r1, r6
 802ea3c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802ea40:	f1c6 0420 	rsb	r4, r6, #32
 802ea44:	fa22 f504 	lsr.w	r5, r2, r4
 802ea48:	40b3      	lsls	r3, r6
 802ea4a:	432b      	orrs	r3, r5
 802ea4c:	fa20 fc04 	lsr.w	ip, r0, r4
 802ea50:	fa01 f706 	lsl.w	r7, r1, r6
 802ea54:	fa21 f504 	lsr.w	r5, r1, r4
 802ea58:	ea4f 4e13 	mov.w	lr, r3, lsr #16
 802ea5c:	ea4c 0707 	orr.w	r7, ip, r7
 802ea60:	fbb5 f8fe 	udiv	r8, r5, lr
 802ea64:	0c39      	lsrs	r1, r7, #16
 802ea66:	fb0e 5518 	mls	r5, lr, r8, r5
 802ea6a:	fa1f fc83 	uxth.w	ip, r3
 802ea6e:	ea41 4505 	orr.w	r5, r1, r5, lsl #16
 802ea72:	fb0c f108 	mul.w	r1, ip, r8
 802ea76:	42a9      	cmp	r1, r5
 802ea78:	fa02 f206 	lsl.w	r2, r2, r6
 802ea7c:	d904      	bls.n	802ea88 <__udivdi3+0x178>
 802ea7e:	18ed      	adds	r5, r5, r3
 802ea80:	f108 34ff 	add.w	r4, r8, #4294967295
 802ea84:	d367      	bcc.n	802eb56 <__udivdi3+0x246>
 802ea86:	46a0      	mov	r8, r4
 802ea88:	1a6d      	subs	r5, r5, r1
 802ea8a:	b2bf      	uxth	r7, r7
 802ea8c:	fbb5 f4fe 	udiv	r4, r5, lr
 802ea90:	fb0e 5514 	mls	r5, lr, r4, r5
 802ea94:	ea47 4105 	orr.w	r1, r7, r5, lsl #16
 802ea98:	fb0c fc04 	mul.w	ip, ip, r4
 802ea9c:	458c      	cmp	ip, r1
 802ea9e:	d904      	bls.n	802eaaa <__udivdi3+0x19a>
 802eaa0:	18c9      	adds	r1, r1, r3
 802eaa2:	f104 35ff 	add.w	r5, r4, #4294967295
 802eaa6:	d35c      	bcc.n	802eb62 <__udivdi3+0x252>
 802eaa8:	462c      	mov	r4, r5
 802eaaa:	ea44 4408 	orr.w	r4, r4, r8, lsl #16
 802eaae:	ebcc 0101 	rsb	r1, ip, r1
 802eab2:	fba4 2302 	umull	r2, r3, r4, r2
 802eab6:	4299      	cmp	r1, r3
 802eab8:	d348      	bcc.n	802eb4c <__udivdi3+0x23c>
 802eaba:	d044      	beq.n	802eb46 <__udivdi3+0x236>
 802eabc:	4620      	mov	r0, r4
 802eabe:	2600      	movs	r6, #0
 802eac0:	e76c      	b.n	802e99c <__udivdi3+0x8c>
 802eac2:	f1c8 0420 	rsb	r4, r8, #32
 802eac6:	fa01 f308 	lsl.w	r3, r1, r8
 802eaca:	fa05 f508 	lsl.w	r5, r5, r8
 802eace:	fa20 f704 	lsr.w	r7, r0, r4
 802ead2:	40e1      	lsrs	r1, r4
 802ead4:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 802ead8:	431f      	orrs	r7, r3
 802eada:	fbb1 f6fe 	udiv	r6, r1, lr
 802eade:	0c3a      	lsrs	r2, r7, #16
 802eae0:	fb0e 1116 	mls	r1, lr, r6, r1
 802eae4:	fa1f fc85 	uxth.w	ip, r5
 802eae8:	ea42 4301 	orr.w	r3, r2, r1, lsl #16
 802eaec:	fb0c f206 	mul.w	r2, ip, r6
 802eaf0:	429a      	cmp	r2, r3
 802eaf2:	fa00 f408 	lsl.w	r4, r0, r8
 802eaf6:	d907      	bls.n	802eb08 <__udivdi3+0x1f8>
 802eaf8:	195b      	adds	r3, r3, r5
 802eafa:	f106 31ff 	add.w	r1, r6, #4294967295
 802eafe:	d237      	bcs.n	802eb70 <__udivdi3+0x260>
 802eb00:	429a      	cmp	r2, r3
 802eb02:	d935      	bls.n	802eb70 <__udivdi3+0x260>
 802eb04:	3e02      	subs	r6, #2
 802eb06:	442b      	add	r3, r5
 802eb08:	1a9b      	subs	r3, r3, r2
 802eb0a:	b2bf      	uxth	r7, r7
 802eb0c:	fbb3 f0fe 	udiv	r0, r3, lr
 802eb10:	fb0e 3310 	mls	r3, lr, r0, r3
 802eb14:	ea47 4303 	orr.w	r3, r7, r3, lsl #16
 802eb18:	fb0c f100 	mul.w	r1, ip, r0
 802eb1c:	4299      	cmp	r1, r3
 802eb1e:	d907      	bls.n	802eb30 <__udivdi3+0x220>
 802eb20:	195b      	adds	r3, r3, r5
 802eb22:	f100 32ff 	add.w	r2, r0, #4294967295
 802eb26:	d221      	bcs.n	802eb6c <__udivdi3+0x25c>
 802eb28:	4299      	cmp	r1, r3
 802eb2a:	d91f      	bls.n	802eb6c <__udivdi3+0x25c>
 802eb2c:	3802      	subs	r0, #2
 802eb2e:	442b      	add	r3, r5
 802eb30:	1a5a      	subs	r2, r3, r1
 802eb32:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
 802eb36:	4667      	mov	r7, ip
 802eb38:	e750      	b.n	802e9dc <__udivdi3+0xcc>
 802eb3a:	4610      	mov	r0, r2
 802eb3c:	e716      	b.n	802e96c <__udivdi3+0x5c>
 802eb3e:	460b      	mov	r3, r1
 802eb40:	e729      	b.n	802e996 <__udivdi3+0x86>
 802eb42:	4613      	mov	r3, r2
 802eb44:	e772      	b.n	802ea2c <__udivdi3+0x11c>
 802eb46:	40b0      	lsls	r0, r6
 802eb48:	4290      	cmp	r0, r2
 802eb4a:	d2b7      	bcs.n	802eabc <__udivdi3+0x1ac>
 802eb4c:	1e60      	subs	r0, r4, #1
 802eb4e:	2600      	movs	r6, #0
 802eb50:	e724      	b.n	802e99c <__udivdi3+0x8c>
 802eb52:	4630      	mov	r0, r6
 802eb54:	e722      	b.n	802e99c <__udivdi3+0x8c>
 802eb56:	42a9      	cmp	r1, r5
 802eb58:	d995      	bls.n	802ea86 <__udivdi3+0x176>
 802eb5a:	f1a8 0802 	sub.w	r8, r8, #2
 802eb5e:	441d      	add	r5, r3
 802eb60:	e792      	b.n	802ea88 <__udivdi3+0x178>
 802eb62:	458c      	cmp	ip, r1
 802eb64:	d9a0      	bls.n	802eaa8 <__udivdi3+0x198>
 802eb66:	3c02      	subs	r4, #2
 802eb68:	4419      	add	r1, r3
 802eb6a:	e79e      	b.n	802eaaa <__udivdi3+0x19a>
 802eb6c:	4610      	mov	r0, r2
 802eb6e:	e7df      	b.n	802eb30 <__udivdi3+0x220>
 802eb70:	460e      	mov	r6, r1
 802eb72:	e7c9      	b.n	802eb08 <__udivdi3+0x1f8>
 802eb74:	3802      	subs	r0, #2
 802eb76:	4429      	add	r1, r5
 802eb78:	e743      	b.n	802ea02 <__udivdi3+0xf2>
 802eb7a:	bf00      	nop

0802eb7c <__errno>:
 802eb7c:	4b01      	ldr	r3, [pc, #4]	; (802eb84 <__errno+0x8>)
 802eb7e:	6818      	ldr	r0, [r3, #0]
 802eb80:	4770      	bx	lr
 802eb82:	bf00      	nop
 802eb84:	1ffe96a4 	.word	0x1ffe96a4

0802eb88 <memcmp>:
 802eb88:	b510      	push	{r4, lr}
 802eb8a:	440a      	add	r2, r1
 802eb8c:	1e44      	subs	r4, r0, #1
 802eb8e:	4291      	cmp	r1, r2
 802eb90:	d008      	beq.n	802eba4 <memcmp+0x1c>
 802eb92:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 802eb96:	7808      	ldrb	r0, [r1, #0]
 802eb98:	4283      	cmp	r3, r0
 802eb9a:	d001      	beq.n	802eba0 <memcmp+0x18>
 802eb9c:	1a18      	subs	r0, r3, r0
 802eb9e:	bd10      	pop	{r4, pc}
 802eba0:	3101      	adds	r1, #1
 802eba2:	e7f4      	b.n	802eb8e <memcmp+0x6>
 802eba4:	2000      	movs	r0, #0
 802eba6:	bd10      	pop	{r4, pc}

0802eba8 <memcpy>:
 802eba8:	b510      	push	{r4, lr}
 802ebaa:	1e43      	subs	r3, r0, #1
 802ebac:	440a      	add	r2, r1
 802ebae:	4291      	cmp	r1, r2
 802ebb0:	d004      	beq.n	802ebbc <memcpy+0x14>
 802ebb2:	f811 4b01 	ldrb.w	r4, [r1], #1
 802ebb6:	f803 4f01 	strb.w	r4, [r3, #1]!
 802ebba:	e7f8      	b.n	802ebae <memcpy+0x6>
 802ebbc:	bd10      	pop	{r4, pc}

0802ebbe <memset>:
 802ebbe:	4402      	add	r2, r0
 802ebc0:	4603      	mov	r3, r0
 802ebc2:	4293      	cmp	r3, r2
 802ebc4:	d002      	beq.n	802ebcc <memset+0xe>
 802ebc6:	f803 1b01 	strb.w	r1, [r3], #1
 802ebca:	e7fa      	b.n	802ebc2 <memset+0x4>
 802ebcc:	4770      	bx	lr

0802ebce <__cvt>:
 802ebce:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802ebd2:	b088      	sub	sp, #32
 802ebd4:	2b00      	cmp	r3, #0
 802ebd6:	9f14      	ldr	r7, [sp, #80]	; 0x50
 802ebd8:	9912      	ldr	r1, [sp, #72]	; 0x48
 802ebda:	9e10      	ldr	r6, [sp, #64]	; 0x40
 802ebdc:	f8dd a04c 	ldr.w	sl, [sp, #76]	; 0x4c
 802ebe0:	461d      	mov	r5, r3
 802ebe2:	bfb8      	it	lt
 802ebe4:	f105 4300 	addlt.w	r3, r5, #2147483648	; 0x80000000
 802ebe8:	f027 0720 	bic.w	r7, r7, #32
 802ebec:	bfb6      	itet	lt
 802ebee:	461d      	movlt	r5, r3
 802ebf0:	2300      	movge	r3, #0
 802ebf2:	232d      	movlt	r3, #45	; 0x2d
 802ebf4:	4614      	mov	r4, r2
 802ebf6:	bfb8      	it	lt
 802ebf8:	4614      	movlt	r4, r2
 802ebfa:	2f46      	cmp	r7, #70	; 0x46
 802ebfc:	700b      	strb	r3, [r1, #0]
 802ebfe:	d003      	beq.n	802ec08 <__cvt+0x3a>
 802ec00:	2f45      	cmp	r7, #69	; 0x45
 802ec02:	d103      	bne.n	802ec0c <__cvt+0x3e>
 802ec04:	3601      	adds	r6, #1
 802ec06:	e001      	b.n	802ec0c <__cvt+0x3e>
 802ec08:	2303      	movs	r3, #3
 802ec0a:	e000      	b.n	802ec0e <__cvt+0x40>
 802ec0c:	2302      	movs	r3, #2
 802ec0e:	e88d 0448 	stmia.w	sp, {r3, r6, sl}
 802ec12:	ab06      	add	r3, sp, #24
 802ec14:	9303      	str	r3, [sp, #12]
 802ec16:	ab07      	add	r3, sp, #28
 802ec18:	9304      	str	r3, [sp, #16]
 802ec1a:	4622      	mov	r2, r4
 802ec1c:	462b      	mov	r3, r5
 802ec1e:	f000 fd33 	bl	802f688 <_dtoa_r>
 802ec22:	2f47      	cmp	r7, #71	; 0x47
 802ec24:	4680      	mov	r8, r0
 802ec26:	d102      	bne.n	802ec2e <__cvt+0x60>
 802ec28:	9b11      	ldr	r3, [sp, #68]	; 0x44
 802ec2a:	07db      	lsls	r3, r3, #31
 802ec2c:	d526      	bpl.n	802ec7c <__cvt+0xae>
 802ec2e:	2f46      	cmp	r7, #70	; 0x46
 802ec30:	eb08 0906 	add.w	r9, r8, r6
 802ec34:	d111      	bne.n	802ec5a <__cvt+0x8c>
 802ec36:	f898 3000 	ldrb.w	r3, [r8]
 802ec3a:	2b30      	cmp	r3, #48	; 0x30
 802ec3c:	d10a      	bne.n	802ec54 <__cvt+0x86>
 802ec3e:	4620      	mov	r0, r4
 802ec40:	4629      	mov	r1, r5
 802ec42:	2200      	movs	r2, #0
 802ec44:	2300      	movs	r3, #0
 802ec46:	f7ff fbc7 	bl	802e3d8 <__aeabi_dcmpeq>
 802ec4a:	b918      	cbnz	r0, 802ec54 <__cvt+0x86>
 802ec4c:	f1c6 0601 	rsb	r6, r6, #1
 802ec50:	f8ca 6000 	str.w	r6, [sl]
 802ec54:	f8da 3000 	ldr.w	r3, [sl]
 802ec58:	4499      	add	r9, r3
 802ec5a:	4620      	mov	r0, r4
 802ec5c:	4629      	mov	r1, r5
 802ec5e:	2200      	movs	r2, #0
 802ec60:	2300      	movs	r3, #0
 802ec62:	f7ff fbb9 	bl	802e3d8 <__aeabi_dcmpeq>
 802ec66:	b108      	cbz	r0, 802ec6c <__cvt+0x9e>
 802ec68:	f8cd 901c 	str.w	r9, [sp, #28]
 802ec6c:	9b07      	ldr	r3, [sp, #28]
 802ec6e:	454b      	cmp	r3, r9
 802ec70:	d204      	bcs.n	802ec7c <__cvt+0xae>
 802ec72:	1c5a      	adds	r2, r3, #1
 802ec74:	9207      	str	r2, [sp, #28]
 802ec76:	2230      	movs	r2, #48	; 0x30
 802ec78:	701a      	strb	r2, [r3, #0]
 802ec7a:	e7f7      	b.n	802ec6c <__cvt+0x9e>
 802ec7c:	9b07      	ldr	r3, [sp, #28]
 802ec7e:	9a15      	ldr	r2, [sp, #84]	; 0x54
 802ec80:	ebc8 0303 	rsb	r3, r8, r3
 802ec84:	4640      	mov	r0, r8
 802ec86:	6013      	str	r3, [r2, #0]
 802ec88:	b008      	add	sp, #32
 802ec8a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0802ec8e <__exponent>:
 802ec8e:	b573      	push	{r0, r1, r4, r5, r6, lr}
 802ec90:	4603      	mov	r3, r0
 802ec92:	2900      	cmp	r1, #0
 802ec94:	bfb8      	it	lt
 802ec96:	4249      	neglt	r1, r1
 802ec98:	f803 2b02 	strb.w	r2, [r3], #2
 802ec9c:	bfb4      	ite	lt
 802ec9e:	222d      	movlt	r2, #45	; 0x2d
 802eca0:	222b      	movge	r2, #43	; 0x2b
 802eca2:	2909      	cmp	r1, #9
 802eca4:	7042      	strb	r2, [r0, #1]
 802eca6:	dd19      	ble.n	802ecdc <__exponent+0x4e>
 802eca8:	f10d 0407 	add.w	r4, sp, #7
 802ecac:	4626      	mov	r6, r4
 802ecae:	220a      	movs	r2, #10
 802ecb0:	fb91 f5f2 	sdiv	r5, r1, r2
 802ecb4:	fb02 1115 	mls	r1, r2, r5, r1
 802ecb8:	3130      	adds	r1, #48	; 0x30
 802ecba:	2d09      	cmp	r5, #9
 802ecbc:	f804 1d01 	strb.w	r1, [r4, #-1]!
 802ecc0:	4629      	mov	r1, r5
 802ecc2:	dcf4      	bgt.n	802ecae <__exponent+0x20>
 802ecc4:	3130      	adds	r1, #48	; 0x30
 802ecc6:	1e65      	subs	r5, r4, #1
 802ecc8:	f804 1c01 	strb.w	r1, [r4, #-1]
 802eccc:	42b5      	cmp	r5, r6
 802ecce:	461a      	mov	r2, r3
 802ecd0:	d20a      	bcs.n	802ece8 <__exponent+0x5a>
 802ecd2:	f815 2b01 	ldrb.w	r2, [r5], #1
 802ecd6:	f803 2b01 	strb.w	r2, [r3], #1
 802ecda:	e7f7      	b.n	802eccc <__exponent+0x3e>
 802ecdc:	2430      	movs	r4, #48	; 0x30
 802ecde:	461a      	mov	r2, r3
 802ece0:	4421      	add	r1, r4
 802ece2:	f802 4b02 	strb.w	r4, [r2], #2
 802ece6:	7059      	strb	r1, [r3, #1]
 802ece8:	1a10      	subs	r0, r2, r0
 802ecea:	b002      	add	sp, #8
 802ecec:	bd70      	pop	{r4, r5, r6, pc}
	...

0802ecf0 <_printf_float>:
 802ecf0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802ecf4:	b091      	sub	sp, #68	; 0x44
 802ecf6:	468b      	mov	fp, r1
 802ecf8:	4615      	mov	r5, r2
 802ecfa:	461e      	mov	r6, r3
 802ecfc:	9f1a      	ldr	r7, [sp, #104]	; 0x68
 802ecfe:	4604      	mov	r4, r0
 802ed00:	f001 fa86 	bl	8030210 <_localeconv_r>
 802ed04:	f8d0 a000 	ldr.w	sl, [r0]
 802ed08:	4650      	mov	r0, sl
 802ed0a:	f000 fc27 	bl	802f55c <strlen>
 802ed0e:	2300      	movs	r3, #0
 802ed10:	930e      	str	r3, [sp, #56]	; 0x38
 802ed12:	683b      	ldr	r3, [r7, #0]
 802ed14:	9009      	str	r0, [sp, #36]	; 0x24
 802ed16:	3307      	adds	r3, #7
 802ed18:	f023 0307 	bic.w	r3, r3, #7
 802ed1c:	e9d3 0100 	ldrd	r0, r1, [r3]
 802ed20:	f103 0208 	add.w	r2, r3, #8
 802ed24:	f89b 8018 	ldrb.w	r8, [fp, #24]
 802ed28:	603a      	str	r2, [r7, #0]
 802ed2a:	e9cb 0112 	strd	r0, r1, [fp, #72]	; 0x48
 802ed2e:	f7fe fee5 	bl	802dafc <__fpclassifyd>
 802ed32:	2801      	cmp	r0, #1
 802ed34:	e9db 0112 	ldrd	r0, r1, [fp, #72]	; 0x48
 802ed38:	d119      	bne.n	802ed6e <_printf_float+0x7e>
 802ed3a:	2200      	movs	r2, #0
 802ed3c:	2300      	movs	r3, #0
 802ed3e:	f7ff fb55 	bl	802e3ec <__aeabi_dcmplt>
 802ed42:	b110      	cbz	r0, 802ed4a <_printf_float+0x5a>
 802ed44:	232d      	movs	r3, #45	; 0x2d
 802ed46:	f88b 3043 	strb.w	r3, [fp, #67]	; 0x43
 802ed4a:	4ba0      	ldr	r3, [pc, #640]	; (802efcc <_printf_float+0x2dc>)
 802ed4c:	4fa0      	ldr	r7, [pc, #640]	; (802efd0 <_printf_float+0x2e0>)
 802ed4e:	f1b8 0f47 	cmp.w	r8, #71	; 0x47
 802ed52:	bf88      	it	hi
 802ed54:	461f      	movhi	r7, r3
 802ed56:	2303      	movs	r3, #3
 802ed58:	f8cb 3010 	str.w	r3, [fp, #16]
 802ed5c:	f8db 3000 	ldr.w	r3, [fp]
 802ed60:	f023 0304 	bic.w	r3, r3, #4
 802ed64:	f8cb 3000 	str.w	r3, [fp]
 802ed68:	f04f 0900 	mov.w	r9, #0
 802ed6c:	e0a1      	b.n	802eeb2 <_printf_float+0x1c2>
 802ed6e:	f7fe fec5 	bl	802dafc <__fpclassifyd>
 802ed72:	f8db 3000 	ldr.w	r3, [fp]
 802ed76:	b948      	cbnz	r0, 802ed8c <_printf_float+0x9c>
 802ed78:	4a96      	ldr	r2, [pc, #600]	; (802efd4 <_printf_float+0x2e4>)
 802ed7a:	4f97      	ldr	r7, [pc, #604]	; (802efd8 <_printf_float+0x2e8>)
 802ed7c:	f1b8 0f47 	cmp.w	r8, #71	; 0x47
 802ed80:	bf88      	it	hi
 802ed82:	4617      	movhi	r7, r2
 802ed84:	2203      	movs	r2, #3
 802ed86:	f8cb 2010 	str.w	r2, [fp, #16]
 802ed8a:	e7e9      	b.n	802ed60 <_printf_float+0x70>
 802ed8c:	f8db 2004 	ldr.w	r2, [fp, #4]
 802ed90:	ed9b 7b12 	vldr	d7, [fp, #72]	; 0x48
 802ed94:	1c57      	adds	r7, r2, #1
 802ed96:	ed8d 7b0a 	vstr	d7, [sp, #40]	; 0x28
 802ed9a:	d101      	bne.n	802eda0 <_printf_float+0xb0>
 802ed9c:	2206      	movs	r2, #6
 802ed9e:	e009      	b.n	802edb4 <_printf_float+0xc4>
 802eda0:	f1b8 0f67 	cmp.w	r8, #103	; 0x67
 802eda4:	d002      	beq.n	802edac <_printf_float+0xbc>
 802eda6:	f1b8 0f47 	cmp.w	r8, #71	; 0x47
 802edaa:	d105      	bne.n	802edb8 <_printf_float+0xc8>
 802edac:	2a00      	cmp	r2, #0
 802edae:	f040 81c7 	bne.w	802f140 <_printf_float+0x450>
 802edb2:	2201      	movs	r2, #1
 802edb4:	f8cb 2004 	str.w	r2, [fp, #4]
 802edb8:	f8db 2004 	ldr.w	r2, [fp, #4]
 802edbc:	f8cd 8010 	str.w	r8, [sp, #16]
 802edc0:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 802edc4:	e88d 000c 	stmia.w	sp, {r2, r3}
 802edc8:	f8cb 3000 	str.w	r3, [fp]
 802edcc:	f10d 0333 	add.w	r3, sp, #51	; 0x33
 802edd0:	9302      	str	r3, [sp, #8]
 802edd2:	ab0d      	add	r3, sp, #52	; 0x34
 802edd4:	9303      	str	r3, [sp, #12]
 802edd6:	ab0e      	add	r3, sp, #56	; 0x38
 802edd8:	9305      	str	r3, [sp, #20]
 802edda:	2300      	movs	r3, #0
 802eddc:	9306      	str	r3, [sp, #24]
 802edde:	4620      	mov	r0, r4
 802ede0:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 802ede4:	f7ff fef3 	bl	802ebce <__cvt>
 802ede8:	f008 03df 	and.w	r3, r8, #223	; 0xdf
 802edec:	2b47      	cmp	r3, #71	; 0x47
 802edee:	4607      	mov	r7, r0
 802edf0:	d10a      	bne.n	802ee08 <_printf_float+0x118>
 802edf2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802edf4:	1cd8      	adds	r0, r3, #3
 802edf6:	db03      	blt.n	802ee00 <_printf_float+0x110>
 802edf8:	f8db 2004 	ldr.w	r2, [fp, #4]
 802edfc:	4293      	cmp	r3, r2
 802edfe:	dd37      	ble.n	802ee70 <_printf_float+0x180>
 802ee00:	f1a8 0802 	sub.w	r8, r8, #2
 802ee04:	fa5f f888 	uxtb.w	r8, r8
 802ee08:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
 802ee0c:	990d      	ldr	r1, [sp, #52]	; 0x34
 802ee0e:	d815      	bhi.n	802ee3c <_printf_float+0x14c>
 802ee10:	3901      	subs	r1, #1
 802ee12:	4642      	mov	r2, r8
 802ee14:	f10b 0050 	add.w	r0, fp, #80	; 0x50
 802ee18:	910d      	str	r1, [sp, #52]	; 0x34
 802ee1a:	f7ff ff38 	bl	802ec8e <__exponent>
 802ee1e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 802ee20:	1883      	adds	r3, r0, r2
 802ee22:	2a01      	cmp	r2, #1
 802ee24:	4681      	mov	r9, r0
 802ee26:	f8cb 3010 	str.w	r3, [fp, #16]
 802ee2a:	dc03      	bgt.n	802ee34 <_printf_float+0x144>
 802ee2c:	f8db 2000 	ldr.w	r2, [fp]
 802ee30:	07d1      	lsls	r1, r2, #31
 802ee32:	d538      	bpl.n	802eea6 <_printf_float+0x1b6>
 802ee34:	3301      	adds	r3, #1
 802ee36:	f8cb 3010 	str.w	r3, [fp, #16]
 802ee3a:	e034      	b.n	802eea6 <_printf_float+0x1b6>
 802ee3c:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
 802ee40:	d118      	bne.n	802ee74 <_printf_float+0x184>
 802ee42:	2900      	cmp	r1, #0
 802ee44:	f8db 3004 	ldr.w	r3, [fp, #4]
 802ee48:	dd09      	ble.n	802ee5e <_printf_float+0x16e>
 802ee4a:	f8cb 1010 	str.w	r1, [fp, #16]
 802ee4e:	b91b      	cbnz	r3, 802ee58 <_printf_float+0x168>
 802ee50:	f8db 2000 	ldr.w	r2, [fp]
 802ee54:	07d2      	lsls	r2, r2, #31
 802ee56:	d521      	bpl.n	802ee9c <_printf_float+0x1ac>
 802ee58:	3301      	adds	r3, #1
 802ee5a:	440b      	add	r3, r1
 802ee5c:	e01c      	b.n	802ee98 <_printf_float+0x1a8>
 802ee5e:	b91b      	cbnz	r3, 802ee68 <_printf_float+0x178>
 802ee60:	f8db 2000 	ldr.w	r2, [fp]
 802ee64:	07d0      	lsls	r0, r2, #31
 802ee66:	d501      	bpl.n	802ee6c <_printf_float+0x17c>
 802ee68:	3302      	adds	r3, #2
 802ee6a:	e015      	b.n	802ee98 <_printf_float+0x1a8>
 802ee6c:	2301      	movs	r3, #1
 802ee6e:	e013      	b.n	802ee98 <_printf_float+0x1a8>
 802ee70:	f04f 0867 	mov.w	r8, #103	; 0x67
 802ee74:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802ee76:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 802ee78:	4293      	cmp	r3, r2
 802ee7a:	db07      	blt.n	802ee8c <_printf_float+0x19c>
 802ee7c:	f8db 2000 	ldr.w	r2, [fp]
 802ee80:	f8cb 3010 	str.w	r3, [fp, #16]
 802ee84:	07d1      	lsls	r1, r2, #31
 802ee86:	d509      	bpl.n	802ee9c <_printf_float+0x1ac>
 802ee88:	3301      	adds	r3, #1
 802ee8a:	e005      	b.n	802ee98 <_printf_float+0x1a8>
 802ee8c:	2b00      	cmp	r3, #0
 802ee8e:	bfd4      	ite	le
 802ee90:	f1c3 0302 	rsble	r3, r3, #2
 802ee94:	2301      	movgt	r3, #1
 802ee96:	4413      	add	r3, r2
 802ee98:	f8cb 3010 	str.w	r3, [fp, #16]
 802ee9c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802ee9e:	f8cb 3058 	str.w	r3, [fp, #88]	; 0x58
 802eea2:	f04f 0900 	mov.w	r9, #0
 802eea6:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
 802eeaa:	b113      	cbz	r3, 802eeb2 <_printf_float+0x1c2>
 802eeac:	232d      	movs	r3, #45	; 0x2d
 802eeae:	f88b 3043 	strb.w	r3, [fp, #67]	; 0x43
 802eeb2:	9600      	str	r6, [sp, #0]
 802eeb4:	4620      	mov	r0, r4
 802eeb6:	4659      	mov	r1, fp
 802eeb8:	aa0f      	add	r2, sp, #60	; 0x3c
 802eeba:	462b      	mov	r3, r5
 802eebc:	f000 f95c 	bl	802f178 <_printf_common>
 802eec0:	3001      	adds	r0, #1
 802eec2:	d102      	bne.n	802eeca <_printf_float+0x1da>
 802eec4:	f04f 30ff 	mov.w	r0, #4294967295
 802eec8:	e152      	b.n	802f170 <_printf_float+0x480>
 802eeca:	f8db 3000 	ldr.w	r3, [fp]
 802eece:	055a      	lsls	r2, r3, #21
 802eed0:	d405      	bmi.n	802eede <_printf_float+0x1ee>
 802eed2:	4620      	mov	r0, r4
 802eed4:	4629      	mov	r1, r5
 802eed6:	463a      	mov	r2, r7
 802eed8:	f8db 3010 	ldr.w	r3, [fp, #16]
 802eedc:	e108      	b.n	802f0f0 <_printf_float+0x400>
 802eede:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
 802eee2:	f240 80d0 	bls.w	802f086 <_printf_float+0x396>
 802eee6:	e9db 0112 	ldrd	r0, r1, [fp, #72]	; 0x48
 802eeea:	2200      	movs	r2, #0
 802eeec:	2300      	movs	r3, #0
 802eeee:	f7ff fa73 	bl	802e3d8 <__aeabi_dcmpeq>
 802eef2:	b350      	cbz	r0, 802ef4a <_printf_float+0x25a>
 802eef4:	4620      	mov	r0, r4
 802eef6:	4629      	mov	r1, r5
 802eef8:	4a38      	ldr	r2, [pc, #224]	; (802efdc <_printf_float+0x2ec>)
 802eefa:	2301      	movs	r3, #1
 802eefc:	47b0      	blx	r6
 802eefe:	3001      	adds	r0, #1
 802ef00:	d0e0      	beq.n	802eec4 <_printf_float+0x1d4>
 802ef02:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802ef04:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 802ef06:	429a      	cmp	r2, r3
 802ef08:	db09      	blt.n	802ef1e <_printf_float+0x22e>
 802ef0a:	f8db 3000 	ldr.w	r3, [fp]
 802ef0e:	07d8      	lsls	r0, r3, #31
 802ef10:	d405      	bmi.n	802ef1e <_printf_float+0x22e>
 802ef12:	f8db 3000 	ldr.w	r3, [fp]
 802ef16:	079f      	lsls	r7, r3, #30
 802ef18:	f100 8110 	bmi.w	802f13c <_printf_float+0x44c>
 802ef1c:	e107      	b.n	802f12e <_printf_float+0x43e>
 802ef1e:	4620      	mov	r0, r4
 802ef20:	4629      	mov	r1, r5
 802ef22:	4652      	mov	r2, sl
 802ef24:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802ef26:	47b0      	blx	r6
 802ef28:	3001      	adds	r0, #1
 802ef2a:	d0cb      	beq.n	802eec4 <_printf_float+0x1d4>
 802ef2c:	2700      	movs	r7, #0
 802ef2e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802ef30:	3b01      	subs	r3, #1
 802ef32:	429f      	cmp	r7, r3
 802ef34:	daed      	bge.n	802ef12 <_printf_float+0x222>
 802ef36:	4620      	mov	r0, r4
 802ef38:	4629      	mov	r1, r5
 802ef3a:	f10b 021a 	add.w	r2, fp, #26
 802ef3e:	2301      	movs	r3, #1
 802ef40:	47b0      	blx	r6
 802ef42:	3001      	adds	r0, #1
 802ef44:	d0be      	beq.n	802eec4 <_printf_float+0x1d4>
 802ef46:	3701      	adds	r7, #1
 802ef48:	e7f1      	b.n	802ef2e <_printf_float+0x23e>
 802ef4a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802ef4c:	2b00      	cmp	r3, #0
 802ef4e:	dc29      	bgt.n	802efa4 <_printf_float+0x2b4>
 802ef50:	4620      	mov	r0, r4
 802ef52:	4629      	mov	r1, r5
 802ef54:	4a21      	ldr	r2, [pc, #132]	; (802efdc <_printf_float+0x2ec>)
 802ef56:	2301      	movs	r3, #1
 802ef58:	47b0      	blx	r6
 802ef5a:	3001      	adds	r0, #1
 802ef5c:	d0b2      	beq.n	802eec4 <_printf_float+0x1d4>
 802ef5e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802ef60:	b92b      	cbnz	r3, 802ef6e <_printf_float+0x27e>
 802ef62:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802ef64:	b91b      	cbnz	r3, 802ef6e <_printf_float+0x27e>
 802ef66:	f8db 3000 	ldr.w	r3, [fp]
 802ef6a:	07d9      	lsls	r1, r3, #31
 802ef6c:	d5d1      	bpl.n	802ef12 <_printf_float+0x222>
 802ef6e:	4620      	mov	r0, r4
 802ef70:	4629      	mov	r1, r5
 802ef72:	4652      	mov	r2, sl
 802ef74:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802ef76:	47b0      	blx	r6
 802ef78:	3001      	adds	r0, #1
 802ef7a:	d0a3      	beq.n	802eec4 <_printf_float+0x1d4>
 802ef7c:	f04f 0800 	mov.w	r8, #0
 802ef80:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802ef82:	425b      	negs	r3, r3
 802ef84:	4598      	cmp	r8, r3
 802ef86:	4620      	mov	r0, r4
 802ef88:	4629      	mov	r1, r5
 802ef8a:	da08      	bge.n	802ef9e <_printf_float+0x2ae>
 802ef8c:	f10b 021a 	add.w	r2, fp, #26
 802ef90:	2301      	movs	r3, #1
 802ef92:	47b0      	blx	r6
 802ef94:	3001      	adds	r0, #1
 802ef96:	d095      	beq.n	802eec4 <_printf_float+0x1d4>
 802ef98:	f108 0801 	add.w	r8, r8, #1
 802ef9c:	e7f0      	b.n	802ef80 <_printf_float+0x290>
 802ef9e:	463a      	mov	r2, r7
 802efa0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802efa2:	e0a5      	b.n	802f0f0 <_printf_float+0x400>
 802efa4:	f8db 2058 	ldr.w	r2, [fp, #88]	; 0x58
 802efa8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802efaa:	429a      	cmp	r2, r3
 802efac:	bfa8      	it	ge
 802efae:	461a      	movge	r2, r3
 802efb0:	2a00      	cmp	r2, #0
 802efb2:	4691      	mov	r9, r2
 802efb4:	dc02      	bgt.n	802efbc <_printf_float+0x2cc>
 802efb6:	f04f 0800 	mov.w	r8, #0
 802efba:	e01c      	b.n	802eff6 <_printf_float+0x306>
 802efbc:	4620      	mov	r0, r4
 802efbe:	4629      	mov	r1, r5
 802efc0:	463a      	mov	r2, r7
 802efc2:	464b      	mov	r3, r9
 802efc4:	47b0      	blx	r6
 802efc6:	3001      	adds	r0, #1
 802efc8:	d1f5      	bne.n	802efb6 <_printf_float+0x2c6>
 802efca:	e77b      	b.n	802eec4 <_printf_float+0x1d4>
 802efcc:	08031e66 	.word	0x08031e66
 802efd0:	08031e62 	.word	0x08031e62
 802efd4:	08031e6e 	.word	0x08031e6e
 802efd8:	08031e6a 	.word	0x08031e6a
 802efdc:	08031e72 	.word	0x08031e72
 802efe0:	4620      	mov	r0, r4
 802efe2:	4629      	mov	r1, r5
 802efe4:	f10b 021a 	add.w	r2, fp, #26
 802efe8:	2301      	movs	r3, #1
 802efea:	47b0      	blx	r6
 802efec:	3001      	adds	r0, #1
 802efee:	f43f af69 	beq.w	802eec4 <_printf_float+0x1d4>
 802eff2:	f108 0801 	add.w	r8, r8, #1
 802eff6:	f8db 3058 	ldr.w	r3, [fp, #88]	; 0x58
 802effa:	f1b9 0f00 	cmp.w	r9, #0
 802effe:	bfac      	ite	ge
 802f000:	ebc9 0203 	rsbge	r2, r9, r3
 802f004:	461a      	movlt	r2, r3
 802f006:	4590      	cmp	r8, r2
 802f008:	dbea      	blt.n	802efe0 <_printf_float+0x2f0>
 802f00a:	eb07 0803 	add.w	r8, r7, r3
 802f00e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 802f010:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802f012:	429a      	cmp	r2, r3
 802f014:	db10      	blt.n	802f038 <_printf_float+0x348>
 802f016:	f8db 3000 	ldr.w	r3, [fp]
 802f01a:	07da      	lsls	r2, r3, #31
 802f01c:	d40c      	bmi.n	802f038 <_printf_float+0x348>
 802f01e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 802f020:	4417      	add	r7, r2
 802f022:	ebc8 0307 	rsb	r3, r8, r7
 802f026:	9f0d      	ldr	r7, [sp, #52]	; 0x34
 802f028:	1bd2      	subs	r2, r2, r7
 802f02a:	4293      	cmp	r3, r2
 802f02c:	bfa8      	it	ge
 802f02e:	4613      	movge	r3, r2
 802f030:	2b00      	cmp	r3, #0
 802f032:	461f      	mov	r7, r3
 802f034:	dc08      	bgt.n	802f048 <_printf_float+0x358>
 802f036:	e00e      	b.n	802f056 <_printf_float+0x366>
 802f038:	4620      	mov	r0, r4
 802f03a:	4629      	mov	r1, r5
 802f03c:	4652      	mov	r2, sl
 802f03e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802f040:	47b0      	blx	r6
 802f042:	3001      	adds	r0, #1
 802f044:	d1eb      	bne.n	802f01e <_printf_float+0x32e>
 802f046:	e73d      	b.n	802eec4 <_printf_float+0x1d4>
 802f048:	4620      	mov	r0, r4
 802f04a:	4629      	mov	r1, r5
 802f04c:	4642      	mov	r2, r8
 802f04e:	47b0      	blx	r6
 802f050:	3001      	adds	r0, #1
 802f052:	f43f af37 	beq.w	802eec4 <_printf_float+0x1d4>
 802f056:	f04f 0800 	mov.w	r8, #0
 802f05a:	e00a      	b.n	802f072 <_printf_float+0x382>
 802f05c:	4620      	mov	r0, r4
 802f05e:	4629      	mov	r1, r5
 802f060:	f10b 021a 	add.w	r2, fp, #26
 802f064:	2301      	movs	r3, #1
 802f066:	47b0      	blx	r6
 802f068:	3001      	adds	r0, #1
 802f06a:	f43f af2b 	beq.w	802eec4 <_printf_float+0x1d4>
 802f06e:	f108 0801 	add.w	r8, r8, #1
 802f072:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 802f074:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802f076:	2f00      	cmp	r7, #0
 802f078:	eba3 0302 	sub.w	r3, r3, r2
 802f07c:	bfa8      	it	ge
 802f07e:	1bdb      	subge	r3, r3, r7
 802f080:	4598      	cmp	r8, r3
 802f082:	dbeb      	blt.n	802f05c <_printf_float+0x36c>
 802f084:	e745      	b.n	802ef12 <_printf_float+0x222>
 802f086:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 802f088:	2a01      	cmp	r2, #1
 802f08a:	dc01      	bgt.n	802f090 <_printf_float+0x3a0>
 802f08c:	07db      	lsls	r3, r3, #31
 802f08e:	d536      	bpl.n	802f0fe <_printf_float+0x40e>
 802f090:	4620      	mov	r0, r4
 802f092:	4629      	mov	r1, r5
 802f094:	463a      	mov	r2, r7
 802f096:	2301      	movs	r3, #1
 802f098:	47b0      	blx	r6
 802f09a:	3001      	adds	r0, #1
 802f09c:	f43f af12 	beq.w	802eec4 <_printf_float+0x1d4>
 802f0a0:	4620      	mov	r0, r4
 802f0a2:	4629      	mov	r1, r5
 802f0a4:	4652      	mov	r2, sl
 802f0a6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802f0a8:	47b0      	blx	r6
 802f0aa:	3001      	adds	r0, #1
 802f0ac:	f43f af0a 	beq.w	802eec4 <_printf_float+0x1d4>
 802f0b0:	e9db 0112 	ldrd	r0, r1, [fp, #72]	; 0x48
 802f0b4:	2200      	movs	r2, #0
 802f0b6:	2300      	movs	r3, #0
 802f0b8:	f7ff f98e 	bl	802e3d8 <__aeabi_dcmpeq>
 802f0bc:	b9e8      	cbnz	r0, 802f0fa <_printf_float+0x40a>
 802f0be:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802f0c0:	4620      	mov	r0, r4
 802f0c2:	4629      	mov	r1, r5
 802f0c4:	1c7a      	adds	r2, r7, #1
 802f0c6:	3b01      	subs	r3, #1
 802f0c8:	e01d      	b.n	802f106 <_printf_float+0x416>
 802f0ca:	4620      	mov	r0, r4
 802f0cc:	4629      	mov	r1, r5
 802f0ce:	f10b 021a 	add.w	r2, fp, #26
 802f0d2:	2301      	movs	r3, #1
 802f0d4:	47b0      	blx	r6
 802f0d6:	3001      	adds	r0, #1
 802f0d8:	f43f aef4 	beq.w	802eec4 <_printf_float+0x1d4>
 802f0dc:	3701      	adds	r7, #1
 802f0de:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802f0e0:	3b01      	subs	r3, #1
 802f0e2:	429f      	cmp	r7, r3
 802f0e4:	dbf1      	blt.n	802f0ca <_printf_float+0x3da>
 802f0e6:	4620      	mov	r0, r4
 802f0e8:	4629      	mov	r1, r5
 802f0ea:	f10b 0250 	add.w	r2, fp, #80	; 0x50
 802f0ee:	464b      	mov	r3, r9
 802f0f0:	47b0      	blx	r6
 802f0f2:	3001      	adds	r0, #1
 802f0f4:	f47f af0d 	bne.w	802ef12 <_printf_float+0x222>
 802f0f8:	e6e4      	b.n	802eec4 <_printf_float+0x1d4>
 802f0fa:	2700      	movs	r7, #0
 802f0fc:	e7ef      	b.n	802f0de <_printf_float+0x3ee>
 802f0fe:	4620      	mov	r0, r4
 802f100:	4629      	mov	r1, r5
 802f102:	463a      	mov	r2, r7
 802f104:	2301      	movs	r3, #1
 802f106:	47b0      	blx	r6
 802f108:	3001      	adds	r0, #1
 802f10a:	d1ec      	bne.n	802f0e6 <_printf_float+0x3f6>
 802f10c:	e6da      	b.n	802eec4 <_printf_float+0x1d4>
 802f10e:	4620      	mov	r0, r4
 802f110:	4629      	mov	r1, r5
 802f112:	f10b 0219 	add.w	r2, fp, #25
 802f116:	2301      	movs	r3, #1
 802f118:	47b0      	blx	r6
 802f11a:	3001      	adds	r0, #1
 802f11c:	f43f aed2 	beq.w	802eec4 <_printf_float+0x1d4>
 802f120:	3701      	adds	r7, #1
 802f122:	f8db 300c 	ldr.w	r3, [fp, #12]
 802f126:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 802f128:	1a9b      	subs	r3, r3, r2
 802f12a:	429f      	cmp	r7, r3
 802f12c:	dbef      	blt.n	802f10e <_printf_float+0x41e>
 802f12e:	f8db 000c 	ldr.w	r0, [fp, #12]
 802f132:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 802f134:	4298      	cmp	r0, r3
 802f136:	bfb8      	it	lt
 802f138:	4618      	movlt	r0, r3
 802f13a:	e019      	b.n	802f170 <_printf_float+0x480>
 802f13c:	2700      	movs	r7, #0
 802f13e:	e7f0      	b.n	802f122 <_printf_float+0x432>
 802f140:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 802f144:	e88d 000c 	stmia.w	sp, {r2, r3}
 802f148:	f8cb 3000 	str.w	r3, [fp]
 802f14c:	f10d 0333 	add.w	r3, sp, #51	; 0x33
 802f150:	9302      	str	r3, [sp, #8]
 802f152:	ab0d      	add	r3, sp, #52	; 0x34
 802f154:	9303      	str	r3, [sp, #12]
 802f156:	ab0e      	add	r3, sp, #56	; 0x38
 802f158:	9305      	str	r3, [sp, #20]
 802f15a:	2300      	movs	r3, #0
 802f15c:	9306      	str	r3, [sp, #24]
 802f15e:	f8cd 8010 	str.w	r8, [sp, #16]
 802f162:	4620      	mov	r0, r4
 802f164:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 802f168:	f7ff fd31 	bl	802ebce <__cvt>
 802f16c:	4607      	mov	r7, r0
 802f16e:	e640      	b.n	802edf2 <_printf_float+0x102>
 802f170:	b011      	add	sp, #68	; 0x44
 802f172:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802f176:	bf00      	nop

0802f178 <_printf_common>:
 802f178:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 802f17c:	4691      	mov	r9, r2
 802f17e:	461f      	mov	r7, r3
 802f180:	688a      	ldr	r2, [r1, #8]
 802f182:	690b      	ldr	r3, [r1, #16]
 802f184:	f8dd 8020 	ldr.w	r8, [sp, #32]
 802f188:	4293      	cmp	r3, r2
 802f18a:	bfb8      	it	lt
 802f18c:	4613      	movlt	r3, r2
 802f18e:	f8c9 3000 	str.w	r3, [r9]
 802f192:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 802f196:	4606      	mov	r6, r0
 802f198:	460c      	mov	r4, r1
 802f19a:	b112      	cbz	r2, 802f1a2 <_printf_common+0x2a>
 802f19c:	3301      	adds	r3, #1
 802f19e:	f8c9 3000 	str.w	r3, [r9]
 802f1a2:	6823      	ldr	r3, [r4, #0]
 802f1a4:	0699      	lsls	r1, r3, #26
 802f1a6:	bf42      	ittt	mi
 802f1a8:	f8d9 3000 	ldrmi.w	r3, [r9]
 802f1ac:	3302      	addmi	r3, #2
 802f1ae:	f8c9 3000 	strmi.w	r3, [r9]
 802f1b2:	6825      	ldr	r5, [r4, #0]
 802f1b4:	f015 0506 	ands.w	r5, r5, #6
 802f1b8:	d01c      	beq.n	802f1f4 <_printf_common+0x7c>
 802f1ba:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 802f1be:	6822      	ldr	r2, [r4, #0]
 802f1c0:	3300      	adds	r3, #0
 802f1c2:	bf18      	it	ne
 802f1c4:	2301      	movne	r3, #1
 802f1c6:	0692      	lsls	r2, r2, #26
 802f1c8:	d51f      	bpl.n	802f20a <_printf_common+0x92>
 802f1ca:	18e1      	adds	r1, r4, r3
 802f1cc:	1c5a      	adds	r2, r3, #1
 802f1ce:	2030      	movs	r0, #48	; 0x30
 802f1d0:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 802f1d4:	4422      	add	r2, r4
 802f1d6:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 802f1da:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 802f1de:	3302      	adds	r3, #2
 802f1e0:	e013      	b.n	802f20a <_printf_common+0x92>
 802f1e2:	4630      	mov	r0, r6
 802f1e4:	4639      	mov	r1, r7
 802f1e6:	f104 0219 	add.w	r2, r4, #25
 802f1ea:	2301      	movs	r3, #1
 802f1ec:	47c0      	blx	r8
 802f1ee:	3001      	adds	r0, #1
 802f1f0:	d007      	beq.n	802f202 <_printf_common+0x8a>
 802f1f2:	3501      	adds	r5, #1
 802f1f4:	68e3      	ldr	r3, [r4, #12]
 802f1f6:	f8d9 2000 	ldr.w	r2, [r9]
 802f1fa:	1a9b      	subs	r3, r3, r2
 802f1fc:	429d      	cmp	r5, r3
 802f1fe:	dbf0      	blt.n	802f1e2 <_printf_common+0x6a>
 802f200:	e7db      	b.n	802f1ba <_printf_common+0x42>
 802f202:	f04f 30ff 	mov.w	r0, #4294967295
 802f206:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 802f20a:	4630      	mov	r0, r6
 802f20c:	4639      	mov	r1, r7
 802f20e:	f104 0243 	add.w	r2, r4, #67	; 0x43
 802f212:	47c0      	blx	r8
 802f214:	3001      	adds	r0, #1
 802f216:	d0f4      	beq.n	802f202 <_printf_common+0x8a>
 802f218:	6822      	ldr	r2, [r4, #0]
 802f21a:	f8d9 5000 	ldr.w	r5, [r9]
 802f21e:	68e3      	ldr	r3, [r4, #12]
 802f220:	f002 0206 	and.w	r2, r2, #6
 802f224:	2a04      	cmp	r2, #4
 802f226:	bf08      	it	eq
 802f228:	1b5d      	subeq	r5, r3, r5
 802f22a:	6922      	ldr	r2, [r4, #16]
 802f22c:	68a3      	ldr	r3, [r4, #8]
 802f22e:	bf0c      	ite	eq
 802f230:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 802f234:	2500      	movne	r5, #0
 802f236:	4293      	cmp	r3, r2
 802f238:	bfc4      	itt	gt
 802f23a:	1a9b      	subgt	r3, r3, r2
 802f23c:	18ed      	addgt	r5, r5, r3
 802f23e:	f04f 0900 	mov.w	r9, #0
 802f242:	45a9      	cmp	r9, r5
 802f244:	da0a      	bge.n	802f25c <_printf_common+0xe4>
 802f246:	4630      	mov	r0, r6
 802f248:	4639      	mov	r1, r7
 802f24a:	f104 021a 	add.w	r2, r4, #26
 802f24e:	2301      	movs	r3, #1
 802f250:	47c0      	blx	r8
 802f252:	3001      	adds	r0, #1
 802f254:	d0d5      	beq.n	802f202 <_printf_common+0x8a>
 802f256:	f109 0901 	add.w	r9, r9, #1
 802f25a:	e7f2      	b.n	802f242 <_printf_common+0xca>
 802f25c:	2000      	movs	r0, #0
 802f25e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0802f262 <swapfunc>:
 802f262:	2b01      	cmp	r3, #1
 802f264:	b530      	push	{r4, r5, lr}
 802f266:	dc0a      	bgt.n	802f27e <swapfunc+0x1c>
 802f268:	0892      	lsrs	r2, r2, #2
 802f26a:	3a01      	subs	r2, #1
 802f26c:	6803      	ldr	r3, [r0, #0]
 802f26e:	680c      	ldr	r4, [r1, #0]
 802f270:	f840 4b04 	str.w	r4, [r0], #4
 802f274:	2a00      	cmp	r2, #0
 802f276:	f841 3b04 	str.w	r3, [r1], #4
 802f27a:	dcf6      	bgt.n	802f26a <swapfunc+0x8>
 802f27c:	bd30      	pop	{r4, r5, pc}
 802f27e:	4603      	mov	r3, r0
 802f280:	780d      	ldrb	r5, [r1, #0]
 802f282:	781c      	ldrb	r4, [r3, #0]
 802f284:	f803 5b01 	strb.w	r5, [r3], #1
 802f288:	f801 4b01 	strb.w	r4, [r1], #1
 802f28c:	1ad4      	subs	r4, r2, r3
 802f28e:	4404      	add	r4, r0
 802f290:	2c00      	cmp	r4, #0
 802f292:	dcf5      	bgt.n	802f280 <swapfunc+0x1e>
 802f294:	bd30      	pop	{r4, r5, pc}

0802f296 <med3>:
 802f296:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802f298:	460c      	mov	r4, r1
 802f29a:	4615      	mov	r5, r2
 802f29c:	4607      	mov	r7, r0
 802f29e:	461e      	mov	r6, r3
 802f2a0:	4798      	blx	r3
 802f2a2:	2800      	cmp	r0, #0
 802f2a4:	4629      	mov	r1, r5
 802f2a6:	4620      	mov	r0, r4
 802f2a8:	da0c      	bge.n	802f2c4 <med3+0x2e>
 802f2aa:	47b0      	blx	r6
 802f2ac:	2800      	cmp	r0, #0
 802f2ae:	da01      	bge.n	802f2b4 <med3+0x1e>
 802f2b0:	4620      	mov	r0, r4
 802f2b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802f2b4:	4638      	mov	r0, r7
 802f2b6:	4629      	mov	r1, r5
 802f2b8:	47b0      	blx	r6
 802f2ba:	ea15 0020 	ands.w	r0, r5, r0, asr #32
 802f2be:	bf38      	it	cc
 802f2c0:	4638      	movcc	r0, r7
 802f2c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802f2c4:	47b0      	blx	r6
 802f2c6:	2800      	cmp	r0, #0
 802f2c8:	dcf2      	bgt.n	802f2b0 <med3+0x1a>
 802f2ca:	4638      	mov	r0, r7
 802f2cc:	4629      	mov	r1, r5
 802f2ce:	47b0      	blx	r6
 802f2d0:	ea17 0020 	ands.w	r0, r7, r0, asr #32
 802f2d4:	bf38      	it	cc
 802f2d6:	4628      	movcc	r0, r5
 802f2d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0802f2da <qsort>:
 802f2da:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802f2de:	b085      	sub	sp, #20
 802f2e0:	4605      	mov	r5, r0
 802f2e2:	460f      	mov	r7, r1
 802f2e4:	4614      	mov	r4, r2
 802f2e6:	9300      	str	r3, [sp, #0]
 802f2e8:	07aa      	lsls	r2, r5, #30
 802f2ea:	d107      	bne.n	802f2fc <qsort+0x22>
 802f2ec:	07a3      	lsls	r3, r4, #30
 802f2ee:	d105      	bne.n	802f2fc <qsort+0x22>
 802f2f0:	f1b4 0904 	subs.w	r9, r4, #4
 802f2f4:	bf18      	it	ne
 802f2f6:	f04f 0901 	movne.w	r9, #1
 802f2fa:	e001      	b.n	802f300 <qsort+0x26>
 802f2fc:	f04f 0902 	mov.w	r9, #2
 802f300:	192b      	adds	r3, r5, r4
 802f302:	2f06      	cmp	r7, #6
 802f304:	9302      	str	r3, [sp, #8]
 802f306:	d826      	bhi.n	802f356 <qsort+0x7c>
 802f308:	4698      	mov	r8, r3
 802f30a:	fb04 5707 	mla	r7, r4, r7, r5
 802f30e:	45b8      	cmp	r8, r7
 802f310:	f080 8121 	bcs.w	802f556 <qsort+0x27c>
 802f314:	46c2      	mov	sl, r8
 802f316:	45aa      	cmp	sl, r5
 802f318:	d91b      	bls.n	802f352 <qsort+0x78>
 802f31a:	ebc4 0b0a 	rsb	fp, r4, sl
 802f31e:	4658      	mov	r0, fp
 802f320:	4651      	mov	r1, sl
 802f322:	9b00      	ldr	r3, [sp, #0]
 802f324:	4798      	blx	r3
 802f326:	2800      	cmp	r0, #0
 802f328:	dd13      	ble.n	802f352 <qsort+0x78>
 802f32a:	f1b9 0f00 	cmp.w	r9, #0
 802f32e:	d108      	bne.n	802f342 <qsort+0x68>
 802f330:	f8da 3000 	ldr.w	r3, [sl]
 802f334:	f8db 2000 	ldr.w	r2, [fp]
 802f338:	f8ca 2000 	str.w	r2, [sl]
 802f33c:	f8cb 3000 	str.w	r3, [fp]
 802f340:	e005      	b.n	802f34e <qsort+0x74>
 802f342:	4650      	mov	r0, sl
 802f344:	4659      	mov	r1, fp
 802f346:	4622      	mov	r2, r4
 802f348:	464b      	mov	r3, r9
 802f34a:	f7ff ff8a 	bl	802f262 <swapfunc>
 802f34e:	46da      	mov	sl, fp
 802f350:	e7e1      	b.n	802f316 <qsort+0x3c>
 802f352:	44a0      	add	r8, r4
 802f354:	e7db      	b.n	802f30e <qsort+0x34>
 802f356:	087e      	lsrs	r6, r7, #1
 802f358:	2f07      	cmp	r7, #7
 802f35a:	fb04 5606 	mla	r6, r4, r6, r5
 802f35e:	d035      	beq.n	802f3cc <qsort+0xf2>
 802f360:	f107 38ff 	add.w	r8, r7, #4294967295
 802f364:	2f28      	cmp	r7, #40	; 0x28
 802f366:	fb04 5808 	mla	r8, r4, r8, r5
 802f36a:	d927      	bls.n	802f3bc <qsort+0xe2>
 802f36c:	ea4f 0ad7 	mov.w	sl, r7, lsr #3
 802f370:	fb04 fa0a 	mul.w	sl, r4, sl
 802f374:	ea4f 0c4a 	mov.w	ip, sl, lsl #1
 802f378:	eb05 020c 	add.w	r2, r5, ip
 802f37c:	eb05 010a 	add.w	r1, r5, sl
 802f380:	9b00      	ldr	r3, [sp, #0]
 802f382:	f8cd c00c 	str.w	ip, [sp, #12]
 802f386:	4628      	mov	r0, r5
 802f388:	f7ff ff85 	bl	802f296 <med3>
 802f38c:	f1ca 0b00 	rsb	fp, sl, #0
 802f390:	4631      	mov	r1, r6
 802f392:	eb06 020a 	add.w	r2, r6, sl
 802f396:	9001      	str	r0, [sp, #4]
 802f398:	9b00      	ldr	r3, [sp, #0]
 802f39a:	eb06 000b 	add.w	r0, r6, fp
 802f39e:	f7ff ff7a 	bl	802f296 <med3>
 802f3a2:	f8dd c00c 	ldr.w	ip, [sp, #12]
 802f3a6:	9b00      	ldr	r3, [sp, #0]
 802f3a8:	eb08 010b 	add.w	r1, r8, fp
 802f3ac:	4642      	mov	r2, r8
 802f3ae:	4606      	mov	r6, r0
 802f3b0:	ebcc 0008 	rsb	r0, ip, r8
 802f3b4:	f7ff ff6f 	bl	802f296 <med3>
 802f3b8:	4680      	mov	r8, r0
 802f3ba:	e000      	b.n	802f3be <qsort+0xe4>
 802f3bc:	9501      	str	r5, [sp, #4]
 802f3be:	4631      	mov	r1, r6
 802f3c0:	9801      	ldr	r0, [sp, #4]
 802f3c2:	9b00      	ldr	r3, [sp, #0]
 802f3c4:	4642      	mov	r2, r8
 802f3c6:	f7ff ff66 	bl	802f296 <med3>
 802f3ca:	4606      	mov	r6, r0
 802f3cc:	f1b9 0f00 	cmp.w	r9, #0
 802f3d0:	d104      	bne.n	802f3dc <qsort+0x102>
 802f3d2:	682b      	ldr	r3, [r5, #0]
 802f3d4:	6832      	ldr	r2, [r6, #0]
 802f3d6:	602a      	str	r2, [r5, #0]
 802f3d8:	6033      	str	r3, [r6, #0]
 802f3da:	e005      	b.n	802f3e8 <qsort+0x10e>
 802f3dc:	4628      	mov	r0, r5
 802f3de:	4631      	mov	r1, r6
 802f3e0:	4622      	mov	r2, r4
 802f3e2:	464b      	mov	r3, r9
 802f3e4:	f7ff ff3d 	bl	802f262 <swapfunc>
 802f3e8:	f8dd 8008 	ldr.w	r8, [sp, #8]
 802f3ec:	f8cd 8004 	str.w	r8, [sp, #4]
 802f3f0:	1e7e      	subs	r6, r7, #1
 802f3f2:	fb04 5606 	mla	r6, r4, r6, r5
 802f3f6:	46b2      	mov	sl, r6
 802f3f8:	46c3      	mov	fp, r8
 802f3fa:	2300      	movs	r3, #0
 802f3fc:	45b3      	cmp	fp, r6
 802f3fe:	d82a      	bhi.n	802f456 <qsort+0x17c>
 802f400:	9302      	str	r3, [sp, #8]
 802f402:	4658      	mov	r0, fp
 802f404:	9b00      	ldr	r3, [sp, #0]
 802f406:	4629      	mov	r1, r5
 802f408:	4798      	blx	r3
 802f40a:	2800      	cmp	r0, #0
 802f40c:	9b02      	ldr	r3, [sp, #8]
 802f40e:	dc22      	bgt.n	802f456 <qsort+0x17c>
 802f410:	d115      	bne.n	802f43e <qsort+0x164>
 802f412:	f1b9 0f00 	cmp.w	r9, #0
 802f416:	d108      	bne.n	802f42a <qsort+0x150>
 802f418:	9b01      	ldr	r3, [sp, #4]
 802f41a:	9901      	ldr	r1, [sp, #4]
 802f41c:	681b      	ldr	r3, [r3, #0]
 802f41e:	f8db 2000 	ldr.w	r2, [fp]
 802f422:	600a      	str	r2, [r1, #0]
 802f424:	f8cb 3000 	str.w	r3, [fp]
 802f428:	e005      	b.n	802f436 <qsort+0x15c>
 802f42a:	9801      	ldr	r0, [sp, #4]
 802f42c:	4659      	mov	r1, fp
 802f42e:	4622      	mov	r2, r4
 802f430:	464b      	mov	r3, r9
 802f432:	f7ff ff16 	bl	802f262 <swapfunc>
 802f436:	9b01      	ldr	r3, [sp, #4]
 802f438:	4423      	add	r3, r4
 802f43a:	9301      	str	r3, [sp, #4]
 802f43c:	2301      	movs	r3, #1
 802f43e:	44a3      	add	fp, r4
 802f440:	e7dc      	b.n	802f3fc <qsort+0x122>
 802f442:	9302      	str	r3, [sp, #8]
 802f444:	4630      	mov	r0, r6
 802f446:	9b00      	ldr	r3, [sp, #0]
 802f448:	4629      	mov	r1, r5
 802f44a:	4798      	blx	r3
 802f44c:	2800      	cmp	r0, #0
 802f44e:	9b02      	ldr	r3, [sp, #8]
 802f450:	db18      	blt.n	802f484 <qsort+0x1aa>
 802f452:	d003      	beq.n	802f45c <qsort+0x182>
 802f454:	1b36      	subs	r6, r6, r4
 802f456:	45b3      	cmp	fp, r6
 802f458:	d9f3      	bls.n	802f442 <qsort+0x168>
 802f45a:	e027      	b.n	802f4ac <qsort+0x1d2>
 802f45c:	f1b9 0f00 	cmp.w	r9, #0
 802f460:	d106      	bne.n	802f470 <qsort+0x196>
 802f462:	6833      	ldr	r3, [r6, #0]
 802f464:	f8da 2000 	ldr.w	r2, [sl]
 802f468:	6032      	str	r2, [r6, #0]
 802f46a:	f8ca 3000 	str.w	r3, [sl]
 802f46e:	e005      	b.n	802f47c <qsort+0x1a2>
 802f470:	4630      	mov	r0, r6
 802f472:	4651      	mov	r1, sl
 802f474:	4622      	mov	r2, r4
 802f476:	464b      	mov	r3, r9
 802f478:	f7ff fef3 	bl	802f262 <swapfunc>
 802f47c:	ebc4 0a0a 	rsb	sl, r4, sl
 802f480:	2301      	movs	r3, #1
 802f482:	e7e7      	b.n	802f454 <qsort+0x17a>
 802f484:	f1b9 0f00 	cmp.w	r9, #0
 802f488:	d106      	bne.n	802f498 <qsort+0x1be>
 802f48a:	f8db 3000 	ldr.w	r3, [fp]
 802f48e:	6832      	ldr	r2, [r6, #0]
 802f490:	f8cb 2000 	str.w	r2, [fp]
 802f494:	6033      	str	r3, [r6, #0]
 802f496:	e005      	b.n	802f4a4 <qsort+0x1ca>
 802f498:	4658      	mov	r0, fp
 802f49a:	4631      	mov	r1, r6
 802f49c:	4622      	mov	r2, r4
 802f49e:	464b      	mov	r3, r9
 802f4a0:	f7ff fedf 	bl	802f262 <swapfunc>
 802f4a4:	44a3      	add	fp, r4
 802f4a6:	1b36      	subs	r6, r6, r4
 802f4a8:	2301      	movs	r3, #1
 802f4aa:	e7a7      	b.n	802f3fc <qsort+0x122>
 802f4ac:	4367      	muls	r7, r4
 802f4ae:	bb0b      	cbnz	r3, 802f4f4 <qsort+0x21a>
 802f4b0:	442f      	add	r7, r5
 802f4b2:	45b8      	cmp	r8, r7
 802f4b4:	d24f      	bcs.n	802f556 <qsort+0x27c>
 802f4b6:	4646      	mov	r6, r8
 802f4b8:	42ae      	cmp	r6, r5
 802f4ba:	d919      	bls.n	802f4f0 <qsort+0x216>
 802f4bc:	ebc4 0a06 	rsb	sl, r4, r6
 802f4c0:	4650      	mov	r0, sl
 802f4c2:	4631      	mov	r1, r6
 802f4c4:	9b00      	ldr	r3, [sp, #0]
 802f4c6:	4798      	blx	r3
 802f4c8:	2800      	cmp	r0, #0
 802f4ca:	dd11      	ble.n	802f4f0 <qsort+0x216>
 802f4cc:	f1b9 0f00 	cmp.w	r9, #0
 802f4d0:	d106      	bne.n	802f4e0 <qsort+0x206>
 802f4d2:	6833      	ldr	r3, [r6, #0]
 802f4d4:	f8da 2000 	ldr.w	r2, [sl]
 802f4d8:	6032      	str	r2, [r6, #0]
 802f4da:	f8ca 3000 	str.w	r3, [sl]
 802f4de:	e005      	b.n	802f4ec <qsort+0x212>
 802f4e0:	4630      	mov	r0, r6
 802f4e2:	4651      	mov	r1, sl
 802f4e4:	4622      	mov	r2, r4
 802f4e6:	464b      	mov	r3, r9
 802f4e8:	f7ff febb 	bl	802f262 <swapfunc>
 802f4ec:	4656      	mov	r6, sl
 802f4ee:	e7e3      	b.n	802f4b8 <qsort+0x1de>
 802f4f0:	44a0      	add	r8, r4
 802f4f2:	e7de      	b.n	802f4b2 <qsort+0x1d8>
 802f4f4:	9b01      	ldr	r3, [sp, #4]
 802f4f6:	eb05 0807 	add.w	r8, r5, r7
 802f4fa:	1b5a      	subs	r2, r3, r5
 802f4fc:	ebc3 070b 	rsb	r7, r3, fp
 802f500:	42ba      	cmp	r2, r7
 802f502:	bfa8      	it	ge
 802f504:	463a      	movge	r2, r7
 802f506:	2a00      	cmp	r2, #0
 802f508:	dd05      	ble.n	802f516 <qsort+0x23c>
 802f50a:	4628      	mov	r0, r5
 802f50c:	ebc2 010b 	rsb	r1, r2, fp
 802f510:	464b      	mov	r3, r9
 802f512:	f7ff fea6 	bl	802f262 <swapfunc>
 802f516:	ebca 0208 	rsb	r2, sl, r8
 802f51a:	1b12      	subs	r2, r2, r4
 802f51c:	ebc6 060a 	rsb	r6, r6, sl
 802f520:	42b2      	cmp	r2, r6
 802f522:	bf28      	it	cs
 802f524:	4632      	movcs	r2, r6
 802f526:	2a00      	cmp	r2, #0
 802f528:	dd05      	ble.n	802f536 <qsort+0x25c>
 802f52a:	4658      	mov	r0, fp
 802f52c:	ebc2 0108 	rsb	r1, r2, r8
 802f530:	464b      	mov	r3, r9
 802f532:	f7ff fe96 	bl	802f262 <swapfunc>
 802f536:	42a7      	cmp	r7, r4
 802f538:	d906      	bls.n	802f548 <qsort+0x26e>
 802f53a:	fbb7 f1f4 	udiv	r1, r7, r4
 802f53e:	4628      	mov	r0, r5
 802f540:	4622      	mov	r2, r4
 802f542:	9b00      	ldr	r3, [sp, #0]
 802f544:	f7ff fec9 	bl	802f2da <qsort>
 802f548:	42a6      	cmp	r6, r4
 802f54a:	d904      	bls.n	802f556 <qsort+0x27c>
 802f54c:	fbb6 f7f4 	udiv	r7, r6, r4
 802f550:	ebc6 0508 	rsb	r5, r6, r8
 802f554:	e6c8      	b.n	802f2e8 <qsort+0xe>
 802f556:	b005      	add	sp, #20
 802f558:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0802f55c <strlen>:
 802f55c:	4603      	mov	r3, r0
 802f55e:	f813 2b01 	ldrb.w	r2, [r3], #1
 802f562:	2a00      	cmp	r2, #0
 802f564:	d1fb      	bne.n	802f55e <strlen+0x2>
 802f566:	1a18      	subs	r0, r3, r0
 802f568:	3801      	subs	r0, #1
 802f56a:	4770      	bx	lr

0802f56c <quorem>:
 802f56c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802f570:	6903      	ldr	r3, [r0, #16]
 802f572:	690c      	ldr	r4, [r1, #16]
 802f574:	42a3      	cmp	r3, r4
 802f576:	4680      	mov	r8, r0
 802f578:	f2c0 8081 	blt.w	802f67e <quorem+0x112>
 802f57c:	3c01      	subs	r4, #1
 802f57e:	f101 0714 	add.w	r7, r1, #20
 802f582:	ea4f 0e84 	mov.w	lr, r4, lsl #2
 802f586:	f100 0614 	add.w	r6, r0, #20
 802f58a:	f857 5024 	ldr.w	r5, [r7, r4, lsl #2]
 802f58e:	eb06 030e 	add.w	r3, r6, lr
 802f592:	9301      	str	r3, [sp, #4]
 802f594:	3501      	adds	r5, #1
 802f596:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
 802f59a:	fbb3 f5f5 	udiv	r5, r3, r5
 802f59e:	eb07 090e 	add.w	r9, r7, lr
 802f5a2:	b3c5      	cbz	r5, 802f616 <quorem+0xaa>
 802f5a4:	f04f 0a00 	mov.w	sl, #0
 802f5a8:	4638      	mov	r0, r7
 802f5aa:	46b4      	mov	ip, r6
 802f5ac:	46d3      	mov	fp, sl
 802f5ae:	f850 3b04 	ldr.w	r3, [r0], #4
 802f5b2:	b29a      	uxth	r2, r3
 802f5b4:	0c1b      	lsrs	r3, r3, #16
 802f5b6:	fb02 a205 	mla	r2, r2, r5, sl
 802f5ba:	436b      	muls	r3, r5
 802f5bc:	eb03 4312 	add.w	r3, r3, r2, lsr #16
 802f5c0:	b292      	uxth	r2, r2
 802f5c2:	ebc2 020b 	rsb	r2, r2, fp
 802f5c6:	f8bc b000 	ldrh.w	fp, [ip]
 802f5ca:	ea4f 4a13 	mov.w	sl, r3, lsr #16
 802f5ce:	fa12 f28b 	uxtah	r2, r2, fp
 802f5d2:	fa1f fb83 	uxth.w	fp, r3
 802f5d6:	f8dc 3000 	ldr.w	r3, [ip]
 802f5da:	ebcb 4313 	rsb	r3, fp, r3, lsr #16
 802f5de:	eb03 4322 	add.w	r3, r3, r2, asr #16
 802f5e2:	b292      	uxth	r2, r2
 802f5e4:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
 802f5e8:	4548      	cmp	r0, r9
 802f5ea:	ea4f 4b23 	mov.w	fp, r3, asr #16
 802f5ee:	f84c 2b04 	str.w	r2, [ip], #4
 802f5f2:	d9dc      	bls.n	802f5ae <quorem+0x42>
 802f5f4:	f856 300e 	ldr.w	r3, [r6, lr]
 802f5f8:	b96b      	cbnz	r3, 802f616 <quorem+0xaa>
 802f5fa:	9b01      	ldr	r3, [sp, #4]
 802f5fc:	3b04      	subs	r3, #4
 802f5fe:	42b3      	cmp	r3, r6
 802f600:	461a      	mov	r2, r3
 802f602:	d802      	bhi.n	802f60a <quorem+0x9e>
 802f604:	f8c8 4010 	str.w	r4, [r8, #16]
 802f608:	e005      	b.n	802f616 <quorem+0xaa>
 802f60a:	6812      	ldr	r2, [r2, #0]
 802f60c:	3b04      	subs	r3, #4
 802f60e:	2a00      	cmp	r2, #0
 802f610:	d1f8      	bne.n	802f604 <quorem+0x98>
 802f612:	3c01      	subs	r4, #1
 802f614:	e7f3      	b.n	802f5fe <quorem+0x92>
 802f616:	4640      	mov	r0, r8
 802f618:	f001 f819 	bl	803064e <__mcmp>
 802f61c:	2800      	cmp	r0, #0
 802f61e:	db2c      	blt.n	802f67a <quorem+0x10e>
 802f620:	3501      	adds	r5, #1
 802f622:	4630      	mov	r0, r6
 802f624:	f04f 0e00 	mov.w	lr, #0
 802f628:	f857 1b04 	ldr.w	r1, [r7], #4
 802f62c:	f8d0 c000 	ldr.w	ip, [r0]
 802f630:	b28a      	uxth	r2, r1
 802f632:	ebc2 030e 	rsb	r3, r2, lr
 802f636:	0c09      	lsrs	r1, r1, #16
 802f638:	fa13 f38c 	uxtah	r3, r3, ip
 802f63c:	ebc1 421c 	rsb	r2, r1, ip, lsr #16
 802f640:	eb02 4223 	add.w	r2, r2, r3, asr #16
 802f644:	b29b      	uxth	r3, r3
 802f646:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 802f64a:	454f      	cmp	r7, r9
 802f64c:	ea4f 4e22 	mov.w	lr, r2, asr #16
 802f650:	f840 3b04 	str.w	r3, [r0], #4
 802f654:	d9e8      	bls.n	802f628 <quorem+0xbc>
 802f656:	f856 2024 	ldr.w	r2, [r6, r4, lsl #2]
 802f65a:	eb06 0384 	add.w	r3, r6, r4, lsl #2
 802f65e:	b962      	cbnz	r2, 802f67a <quorem+0x10e>
 802f660:	3b04      	subs	r3, #4
 802f662:	42b3      	cmp	r3, r6
 802f664:	461a      	mov	r2, r3
 802f666:	d802      	bhi.n	802f66e <quorem+0x102>
 802f668:	f8c8 4010 	str.w	r4, [r8, #16]
 802f66c:	e005      	b.n	802f67a <quorem+0x10e>
 802f66e:	6812      	ldr	r2, [r2, #0]
 802f670:	3b04      	subs	r3, #4
 802f672:	2a00      	cmp	r2, #0
 802f674:	d1f8      	bne.n	802f668 <quorem+0xfc>
 802f676:	3c01      	subs	r4, #1
 802f678:	e7f3      	b.n	802f662 <quorem+0xf6>
 802f67a:	4628      	mov	r0, r5
 802f67c:	e000      	b.n	802f680 <quorem+0x114>
 802f67e:	2000      	movs	r0, #0
 802f680:	b003      	add	sp, #12
 802f682:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

0802f688 <_dtoa_r>:
 802f688:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802f68c:	6a45      	ldr	r5, [r0, #36]	; 0x24
 802f68e:	b097      	sub	sp, #92	; 0x5c
 802f690:	4682      	mov	sl, r0
 802f692:	9c23      	ldr	r4, [sp, #140]	; 0x8c
 802f694:	e9cd 2302 	strd	r2, r3, [sp, #8]
 802f698:	b945      	cbnz	r5, 802f6ac <_dtoa_r+0x24>
 802f69a:	2010      	movs	r0, #16
 802f69c:	f000 fdbc 	bl	8030218 <malloc>
 802f6a0:	f8ca 0024 	str.w	r0, [sl, #36]	; 0x24
 802f6a4:	6045      	str	r5, [r0, #4]
 802f6a6:	6085      	str	r5, [r0, #8]
 802f6a8:	6005      	str	r5, [r0, #0]
 802f6aa:	60c5      	str	r5, [r0, #12]
 802f6ac:	f8da 3024 	ldr.w	r3, [sl, #36]	; 0x24
 802f6b0:	6819      	ldr	r1, [r3, #0]
 802f6b2:	b159      	cbz	r1, 802f6cc <_dtoa_r+0x44>
 802f6b4:	685a      	ldr	r2, [r3, #4]
 802f6b6:	604a      	str	r2, [r1, #4]
 802f6b8:	2301      	movs	r3, #1
 802f6ba:	4093      	lsls	r3, r2
 802f6bc:	608b      	str	r3, [r1, #8]
 802f6be:	4650      	mov	r0, sl
 802f6c0:	f000 fde7 	bl	8030292 <_Bfree>
 802f6c4:	f8da 3024 	ldr.w	r3, [sl, #36]	; 0x24
 802f6c8:	2200      	movs	r2, #0
 802f6ca:	601a      	str	r2, [r3, #0]
 802f6cc:	9b03      	ldr	r3, [sp, #12]
 802f6ce:	4aa2      	ldr	r2, [pc, #648]	; (802f958 <_dtoa_r+0x2d0>)
 802f6d0:	2b00      	cmp	r3, #0
 802f6d2:	bfbf      	itttt	lt
 802f6d4:	2301      	movlt	r3, #1
 802f6d6:	6023      	strlt	r3, [r4, #0]
 802f6d8:	9b03      	ldrlt	r3, [sp, #12]
 802f6da:	f023 4300 	biclt.w	r3, r3, #2147483648	; 0x80000000
 802f6de:	bfb8      	it	lt
 802f6e0:	9303      	strlt	r3, [sp, #12]
 802f6e2:	9f03      	ldr	r7, [sp, #12]
 802f6e4:	bfa4      	itt	ge
 802f6e6:	2300      	movge	r3, #0
 802f6e8:	6023      	strge	r3, [r4, #0]
 802f6ea:	f027 4300 	bic.w	r3, r7, #2147483648	; 0x80000000
 802f6ee:	0d1b      	lsrs	r3, r3, #20
 802f6f0:	051b      	lsls	r3, r3, #20
 802f6f2:	4293      	cmp	r3, r2
 802f6f4:	d11d      	bne.n	802f732 <_dtoa_r+0xaa>
 802f6f6:	9a22      	ldr	r2, [sp, #136]	; 0x88
 802f6f8:	f242 730f 	movw	r3, #9999	; 0x270f
 802f6fc:	6013      	str	r3, [r2, #0]
 802f6fe:	9b02      	ldr	r3, [sp, #8]
 802f700:	b943      	cbnz	r3, 802f714 <_dtoa_r+0x8c>
 802f702:	4a96      	ldr	r2, [pc, #600]	; (802f95c <_dtoa_r+0x2d4>)
 802f704:	4b96      	ldr	r3, [pc, #600]	; (802f960 <_dtoa_r+0x2d8>)
 802f706:	f3c7 0013 	ubfx	r0, r7, #0, #20
 802f70a:	2800      	cmp	r0, #0
 802f70c:	bf14      	ite	ne
 802f70e:	4618      	movne	r0, r3
 802f710:	4610      	moveq	r0, r2
 802f712:	e000      	b.n	802f716 <_dtoa_r+0x8e>
 802f714:	4892      	ldr	r0, [pc, #584]	; (802f960 <_dtoa_r+0x2d8>)
 802f716:	9b24      	ldr	r3, [sp, #144]	; 0x90
 802f718:	2b00      	cmp	r3, #0
 802f71a:	f000 8573 	beq.w	8030204 <_dtoa_r+0xb7c>
 802f71e:	78c3      	ldrb	r3, [r0, #3]
 802f720:	b113      	cbz	r3, 802f728 <_dtoa_r+0xa0>
 802f722:	f100 0308 	add.w	r3, r0, #8
 802f726:	e000      	b.n	802f72a <_dtoa_r+0xa2>
 802f728:	1cc3      	adds	r3, r0, #3
 802f72a:	9a24      	ldr	r2, [sp, #144]	; 0x90
 802f72c:	6013      	str	r3, [r2, #0]
 802f72e:	f000 bd69 	b.w	8030204 <_dtoa_r+0xb7c>
 802f732:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
 802f736:	2200      	movs	r2, #0
 802f738:	4620      	mov	r0, r4
 802f73a:	4629      	mov	r1, r5
 802f73c:	2300      	movs	r3, #0
 802f73e:	f7fe fe4b 	bl	802e3d8 <__aeabi_dcmpeq>
 802f742:	4680      	mov	r8, r0
 802f744:	b158      	cbz	r0, 802f75e <_dtoa_r+0xd6>
 802f746:	9a22      	ldr	r2, [sp, #136]	; 0x88
 802f748:	2301      	movs	r3, #1
 802f74a:	6013      	str	r3, [r2, #0]
 802f74c:	9b24      	ldr	r3, [sp, #144]	; 0x90
 802f74e:	2b00      	cmp	r3, #0
 802f750:	f000 8546 	beq.w	80301e0 <_dtoa_r+0xb58>
 802f754:	4883      	ldr	r0, [pc, #524]	; (802f964 <_dtoa_r+0x2dc>)
 802f756:	6018      	str	r0, [r3, #0]
 802f758:	3801      	subs	r0, #1
 802f75a:	f000 bd53 	b.w	8030204 <_dtoa_r+0xb7c>
 802f75e:	ab15      	add	r3, sp, #84	; 0x54
 802f760:	9300      	str	r3, [sp, #0]
 802f762:	ab14      	add	r3, sp, #80	; 0x50
 802f764:	9301      	str	r3, [sp, #4]
 802f766:	4650      	mov	r0, sl
 802f768:	4622      	mov	r2, r4
 802f76a:	462b      	mov	r3, r5
 802f76c:	f000 ffea 	bl	8030744 <__d2b>
 802f770:	f3c7 560a 	ubfx	r6, r7, #20, #11
 802f774:	9007      	str	r0, [sp, #28]
 802f776:	b15e      	cbz	r6, 802f790 <_dtoa_r+0x108>
 802f778:	f3c5 0313 	ubfx	r3, r5, #0, #20
 802f77c:	f043 517f 	orr.w	r1, r3, #1069547520	; 0x3fc00000
 802f780:	4620      	mov	r0, r4
 802f782:	f441 1140 	orr.w	r1, r1, #3145728	; 0x300000
 802f786:	f2a6 36ff 	subw	r6, r6, #1023	; 0x3ff
 802f78a:	f8cd 804c 	str.w	r8, [sp, #76]	; 0x4c
 802f78e:	e01d      	b.n	802f7cc <_dtoa_r+0x144>
 802f790:	9b15      	ldr	r3, [sp, #84]	; 0x54
 802f792:	9e14      	ldr	r6, [sp, #80]	; 0x50
 802f794:	441e      	add	r6, r3
 802f796:	f46f 6382 	mvn.w	r3, #1040	; 0x410
 802f79a:	429e      	cmp	r6, r3
 802f79c:	bfad      	iteet	ge
 802f79e:	9a02      	ldrge	r2, [sp, #8]
 802f7a0:	4b71      	ldrlt	r3, [pc, #452]	; (802f968 <_dtoa_r+0x2e0>)
 802f7a2:	9a02      	ldrlt	r2, [sp, #8]
 802f7a4:	f206 4312 	addwge	r3, r6, #1042	; 0x412
 802f7a8:	bfa3      	ittte	ge
 802f7aa:	fa22 f003 	lsrge.w	r0, r2, r3
 802f7ae:	4b6f      	ldrge	r3, [pc, #444]	; (802f96c <_dtoa_r+0x2e4>)
 802f7b0:	1b9b      	subge	r3, r3, r6
 802f7b2:	1b9b      	sublt	r3, r3, r6
 802f7b4:	bfaa      	itet	ge
 802f7b6:	409f      	lslge	r7, r3
 802f7b8:	fa02 f003 	lsllt.w	r0, r2, r3
 802f7bc:	4338      	orrge	r0, r7
 802f7be:	f7fe fb2d 	bl	802de1c <__aeabi_ui2d>
 802f7c2:	2301      	movs	r3, #1
 802f7c4:	f1a1 71f8 	sub.w	r1, r1, #32505856	; 0x1f00000
 802f7c8:	3e01      	subs	r6, #1
 802f7ca:	9313      	str	r3, [sp, #76]	; 0x4c
 802f7cc:	2200      	movs	r2, #0
 802f7ce:	4b68      	ldr	r3, [pc, #416]	; (802f970 <_dtoa_r+0x2e8>)
 802f7d0:	f7fe f9e6 	bl	802dba0 <__aeabi_dsub>
 802f7d4:	a35a      	add	r3, pc, #360	; (adr r3, 802f940 <_dtoa_r+0x2b8>)
 802f7d6:	e9d3 2300 	ldrd	r2, r3, [r3]
 802f7da:	f7fe fb95 	bl	802df08 <__aeabi_dmul>
 802f7de:	a35a      	add	r3, pc, #360	; (adr r3, 802f948 <_dtoa_r+0x2c0>)
 802f7e0:	e9d3 2300 	ldrd	r2, r3, [r3]
 802f7e4:	f7fe f9de 	bl	802dba4 <__adddf3>
 802f7e8:	4604      	mov	r4, r0
 802f7ea:	4630      	mov	r0, r6
 802f7ec:	460d      	mov	r5, r1
 802f7ee:	f7fe fb25 	bl	802de3c <__aeabi_i2d>
 802f7f2:	a357      	add	r3, pc, #348	; (adr r3, 802f950 <_dtoa_r+0x2c8>)
 802f7f4:	e9d3 2300 	ldrd	r2, r3, [r3]
 802f7f8:	f7fe fb86 	bl	802df08 <__aeabi_dmul>
 802f7fc:	4602      	mov	r2, r0
 802f7fe:	460b      	mov	r3, r1
 802f800:	4620      	mov	r0, r4
 802f802:	4629      	mov	r1, r5
 802f804:	f7fe f9ce 	bl	802dba4 <__adddf3>
 802f808:	4604      	mov	r4, r0
 802f80a:	460d      	mov	r5, r1
 802f80c:	f7fe fe16 	bl	802e43c <__aeabi_d2iz>
 802f810:	4629      	mov	r1, r5
 802f812:	4683      	mov	fp, r0
 802f814:	2200      	movs	r2, #0
 802f816:	4620      	mov	r0, r4
 802f818:	2300      	movs	r3, #0
 802f81a:	f7fe fde7 	bl	802e3ec <__aeabi_dcmplt>
 802f81e:	b158      	cbz	r0, 802f838 <_dtoa_r+0x1b0>
 802f820:	4658      	mov	r0, fp
 802f822:	f7fe fb0b 	bl	802de3c <__aeabi_i2d>
 802f826:	4602      	mov	r2, r0
 802f828:	460b      	mov	r3, r1
 802f82a:	4620      	mov	r0, r4
 802f82c:	4629      	mov	r1, r5
 802f82e:	f7fe fdd3 	bl	802e3d8 <__aeabi_dcmpeq>
 802f832:	b908      	cbnz	r0, 802f838 <_dtoa_r+0x1b0>
 802f834:	f10b 3bff 	add.w	fp, fp, #4294967295
 802f838:	f1bb 0f16 	cmp.w	fp, #22
 802f83c:	d80d      	bhi.n	802f85a <_dtoa_r+0x1d2>
 802f83e:	4b4d      	ldr	r3, [pc, #308]	; (802f974 <_dtoa_r+0x2ec>)
 802f840:	eb03 03cb 	add.w	r3, r3, fp, lsl #3
 802f844:	e9d3 0100 	ldrd	r0, r1, [r3]
 802f848:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 802f84c:	f7fe fdec 	bl	802e428 <__aeabi_dcmpgt>
 802f850:	b130      	cbz	r0, 802f860 <_dtoa_r+0x1d8>
 802f852:	f10b 3bff 	add.w	fp, fp, #4294967295
 802f856:	2300      	movs	r3, #0
 802f858:	e000      	b.n	802f85c <_dtoa_r+0x1d4>
 802f85a:	2301      	movs	r3, #1
 802f85c:	9312      	str	r3, [sp, #72]	; 0x48
 802f85e:	e000      	b.n	802f862 <_dtoa_r+0x1da>
 802f860:	9012      	str	r0, [sp, #72]	; 0x48
 802f862:	9b14      	ldr	r3, [sp, #80]	; 0x50
 802f864:	1b9e      	subs	r6, r3, r6
 802f866:	1e73      	subs	r3, r6, #1
 802f868:	930a      	str	r3, [sp, #40]	; 0x28
 802f86a:	bf45      	ittet	mi
 802f86c:	425b      	negmi	r3, r3
 802f86e:	9309      	strmi	r3, [sp, #36]	; 0x24
 802f870:	2300      	movpl	r3, #0
 802f872:	2300      	movmi	r3, #0
 802f874:	bf4c      	ite	mi
 802f876:	930a      	strmi	r3, [sp, #40]	; 0x28
 802f878:	9309      	strpl	r3, [sp, #36]	; 0x24
 802f87a:	f1bb 0f00 	cmp.w	fp, #0
 802f87e:	db07      	blt.n	802f890 <_dtoa_r+0x208>
 802f880:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802f882:	f8cd b034 	str.w	fp, [sp, #52]	; 0x34
 802f886:	445b      	add	r3, fp
 802f888:	930a      	str	r3, [sp, #40]	; 0x28
 802f88a:	2300      	movs	r3, #0
 802f88c:	930b      	str	r3, [sp, #44]	; 0x2c
 802f88e:	e008      	b.n	802f8a2 <_dtoa_r+0x21a>
 802f890:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802f892:	ebcb 0303 	rsb	r3, fp, r3
 802f896:	9309      	str	r3, [sp, #36]	; 0x24
 802f898:	f1cb 0300 	rsb	r3, fp, #0
 802f89c:	930b      	str	r3, [sp, #44]	; 0x2c
 802f89e:	2300      	movs	r3, #0
 802f8a0:	930d      	str	r3, [sp, #52]	; 0x34
 802f8a2:	9b20      	ldr	r3, [sp, #128]	; 0x80
 802f8a4:	2b09      	cmp	r3, #9
 802f8a6:	d828      	bhi.n	802f8fa <_dtoa_r+0x272>
 802f8a8:	2b05      	cmp	r3, #5
 802f8aa:	bfc4      	itt	gt
 802f8ac:	3b04      	subgt	r3, #4
 802f8ae:	9320      	strgt	r3, [sp, #128]	; 0x80
 802f8b0:	9b20      	ldr	r3, [sp, #128]	; 0x80
 802f8b2:	f1a3 0302 	sub.w	r3, r3, #2
 802f8b6:	bfcc      	ite	gt
 802f8b8:	2500      	movgt	r5, #0
 802f8ba:	2501      	movle	r5, #1
 802f8bc:	2b03      	cmp	r3, #3
 802f8be:	d821      	bhi.n	802f904 <_dtoa_r+0x27c>
 802f8c0:	e8df f003 	tbb	[pc, r3]
 802f8c4:	10040e02 	.word	0x10040e02
 802f8c8:	2300      	movs	r3, #0
 802f8ca:	e000      	b.n	802f8ce <_dtoa_r+0x246>
 802f8cc:	2301      	movs	r3, #1
 802f8ce:	930c      	str	r3, [sp, #48]	; 0x30
 802f8d0:	9b21      	ldr	r3, [sp, #132]	; 0x84
 802f8d2:	2b00      	cmp	r3, #0
 802f8d4:	dc20      	bgt.n	802f918 <_dtoa_r+0x290>
 802f8d6:	2301      	movs	r3, #1
 802f8d8:	9306      	str	r3, [sp, #24]
 802f8da:	9305      	str	r3, [sp, #20]
 802f8dc:	461a      	mov	r2, r3
 802f8de:	e019      	b.n	802f914 <_dtoa_r+0x28c>
 802f8e0:	2300      	movs	r3, #0
 802f8e2:	e000      	b.n	802f8e6 <_dtoa_r+0x25e>
 802f8e4:	2301      	movs	r3, #1
 802f8e6:	930c      	str	r3, [sp, #48]	; 0x30
 802f8e8:	9b21      	ldr	r3, [sp, #132]	; 0x84
 802f8ea:	445b      	add	r3, fp
 802f8ec:	9306      	str	r3, [sp, #24]
 802f8ee:	3301      	adds	r3, #1
 802f8f0:	2b01      	cmp	r3, #1
 802f8f2:	9305      	str	r3, [sp, #20]
 802f8f4:	bfb8      	it	lt
 802f8f6:	2301      	movlt	r3, #1
 802f8f8:	e011      	b.n	802f91e <_dtoa_r+0x296>
 802f8fa:	2501      	movs	r5, #1
 802f8fc:	2300      	movs	r3, #0
 802f8fe:	9320      	str	r3, [sp, #128]	; 0x80
 802f900:	950c      	str	r5, [sp, #48]	; 0x30
 802f902:	e001      	b.n	802f908 <_dtoa_r+0x280>
 802f904:	2301      	movs	r3, #1
 802f906:	930c      	str	r3, [sp, #48]	; 0x30
 802f908:	f04f 33ff 	mov.w	r3, #4294967295
 802f90c:	9306      	str	r3, [sp, #24]
 802f90e:	9305      	str	r3, [sp, #20]
 802f910:	2200      	movs	r2, #0
 802f912:	2312      	movs	r3, #18
 802f914:	9221      	str	r2, [sp, #132]	; 0x84
 802f916:	e002      	b.n	802f91e <_dtoa_r+0x296>
 802f918:	9b21      	ldr	r3, [sp, #132]	; 0x84
 802f91a:	9306      	str	r3, [sp, #24]
 802f91c:	9305      	str	r3, [sp, #20]
 802f91e:	f8da 4024 	ldr.w	r4, [sl, #36]	; 0x24
 802f922:	2200      	movs	r2, #0
 802f924:	6062      	str	r2, [r4, #4]
 802f926:	2104      	movs	r1, #4
 802f928:	f101 0214 	add.w	r2, r1, #20
 802f92c:	429a      	cmp	r2, r3
 802f92e:	d823      	bhi.n	802f978 <_dtoa_r+0x2f0>
 802f930:	6862      	ldr	r2, [r4, #4]
 802f932:	3201      	adds	r2, #1
 802f934:	6062      	str	r2, [r4, #4]
 802f936:	0049      	lsls	r1, r1, #1
 802f938:	e7f6      	b.n	802f928 <_dtoa_r+0x2a0>
 802f93a:	bf00      	nop
 802f93c:	f3af 8000 	nop.w
 802f940:	636f4361 	.word	0x636f4361
 802f944:	3fd287a7 	.word	0x3fd287a7
 802f948:	8b60c8b3 	.word	0x8b60c8b3
 802f94c:	3fc68a28 	.word	0x3fc68a28
 802f950:	509f79fb 	.word	0x509f79fb
 802f954:	3fd34413 	.word	0x3fd34413
 802f958:	7ff00000 	.word	0x7ff00000
 802f95c:	08031e74 	.word	0x08031e74
 802f960:	08031e7d 	.word	0x08031e7d
 802f964:	08031e73 	.word	0x08031e73
 802f968:	fffffbee 	.word	0xfffffbee
 802f96c:	fffffc0e 	.word	0xfffffc0e
 802f970:	3ff80000 	.word	0x3ff80000
 802f974:	08031e90 	.word	0x08031e90
 802f978:	4650      	mov	r0, sl
 802f97a:	6861      	ldr	r1, [r4, #4]
 802f97c:	f000 fc54 	bl	8030228 <_Balloc>
 802f980:	f8da 3024 	ldr.w	r3, [sl, #36]	; 0x24
 802f984:	6020      	str	r0, [r4, #0]
 802f986:	681b      	ldr	r3, [r3, #0]
 802f988:	9308      	str	r3, [sp, #32]
 802f98a:	9b05      	ldr	r3, [sp, #20]
 802f98c:	2b0e      	cmp	r3, #14
 802f98e:	f200 814b 	bhi.w	802fc28 <_dtoa_r+0x5a0>
 802f992:	2d00      	cmp	r5, #0
 802f994:	f000 8148 	beq.w	802fc28 <_dtoa_r+0x5a0>
 802f998:	ed9d 7b02 	vldr	d7, [sp, #8]
 802f99c:	f1bb 0f00 	cmp.w	fp, #0
 802f9a0:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
 802f9a4:	dd31      	ble.n	802fa0a <_dtoa_r+0x382>
 802f9a6:	4ab3      	ldr	r2, [pc, #716]	; (802fc74 <_dtoa_r+0x5ec>)
 802f9a8:	f00b 030f 	and.w	r3, fp, #15
 802f9ac:	ea4f 172b 	mov.w	r7, fp, asr #4
 802f9b0:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 802f9b4:	06f8      	lsls	r0, r7, #27
 802f9b6:	e9d3 4500 	ldrd	r4, r5, [r3]
 802f9ba:	d50c      	bpl.n	802f9d6 <_dtoa_r+0x34e>
 802f9bc:	4bae      	ldr	r3, [pc, #696]	; (802fc78 <_dtoa_r+0x5f0>)
 802f9be:	ec51 0b17 	vmov	r0, r1, d7
 802f9c2:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 802f9c6:	f7fe fbc9 	bl	802e15c <__aeabi_ddiv>
 802f9ca:	f007 070f 	and.w	r7, r7, #15
 802f9ce:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802f9d2:	2603      	movs	r6, #3
 802f9d4:	e000      	b.n	802f9d8 <_dtoa_r+0x350>
 802f9d6:	2602      	movs	r6, #2
 802f9d8:	f8df 829c 	ldr.w	r8, [pc, #668]	; 802fc78 <_dtoa_r+0x5f0>
 802f9dc:	b177      	cbz	r7, 802f9fc <_dtoa_r+0x374>
 802f9de:	07f9      	lsls	r1, r7, #31
 802f9e0:	d508      	bpl.n	802f9f4 <_dtoa_r+0x36c>
 802f9e2:	4620      	mov	r0, r4
 802f9e4:	4629      	mov	r1, r5
 802f9e6:	e9d8 2300 	ldrd	r2, r3, [r8]
 802f9ea:	f7fe fa8d 	bl	802df08 <__aeabi_dmul>
 802f9ee:	3601      	adds	r6, #1
 802f9f0:	4604      	mov	r4, r0
 802f9f2:	460d      	mov	r5, r1
 802f9f4:	107f      	asrs	r7, r7, #1
 802f9f6:	f108 0808 	add.w	r8, r8, #8
 802f9fa:	e7ef      	b.n	802f9dc <_dtoa_r+0x354>
 802f9fc:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 802fa00:	4622      	mov	r2, r4
 802fa02:	462b      	mov	r3, r5
 802fa04:	f7fe fbaa 	bl	802e15c <__aeabi_ddiv>
 802fa08:	e01b      	b.n	802fa42 <_dtoa_r+0x3ba>
 802fa0a:	f1cb 0400 	rsb	r4, fp, #0
 802fa0e:	b1dc      	cbz	r4, 802fa48 <_dtoa_r+0x3c0>
 802fa10:	4b98      	ldr	r3, [pc, #608]	; (802fc74 <_dtoa_r+0x5ec>)
 802fa12:	4d99      	ldr	r5, [pc, #612]	; (802fc78 <_dtoa_r+0x5f0>)
 802fa14:	f004 020f 	and.w	r2, r4, #15
 802fa18:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 802fa1c:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 802fa20:	e9d3 2300 	ldrd	r2, r3, [r3]
 802fa24:	f7fe fa70 	bl	802df08 <__aeabi_dmul>
 802fa28:	1124      	asrs	r4, r4, #4
 802fa2a:	2602      	movs	r6, #2
 802fa2c:	b14c      	cbz	r4, 802fa42 <_dtoa_r+0x3ba>
 802fa2e:	07e2      	lsls	r2, r4, #31
 802fa30:	d504      	bpl.n	802fa3c <_dtoa_r+0x3b4>
 802fa32:	e9d5 2300 	ldrd	r2, r3, [r5]
 802fa36:	3601      	adds	r6, #1
 802fa38:	f7fe fa66 	bl	802df08 <__aeabi_dmul>
 802fa3c:	1064      	asrs	r4, r4, #1
 802fa3e:	3508      	adds	r5, #8
 802fa40:	e7f4      	b.n	802fa2c <_dtoa_r+0x3a4>
 802fa42:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802fa46:	e000      	b.n	802fa4a <_dtoa_r+0x3c2>
 802fa48:	2602      	movs	r6, #2
 802fa4a:	9b12      	ldr	r3, [sp, #72]	; 0x48
 802fa4c:	b1db      	cbz	r3, 802fa86 <_dtoa_r+0x3fe>
 802fa4e:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
 802fa52:	2200      	movs	r2, #0
 802fa54:	4620      	mov	r0, r4
 802fa56:	4629      	mov	r1, r5
 802fa58:	4b88      	ldr	r3, [pc, #544]	; (802fc7c <_dtoa_r+0x5f4>)
 802fa5a:	f7fe fcc7 	bl	802e3ec <__aeabi_dcmplt>
 802fa5e:	b190      	cbz	r0, 802fa86 <_dtoa_r+0x3fe>
 802fa60:	9b05      	ldr	r3, [sp, #20]
 802fa62:	b183      	cbz	r3, 802fa86 <_dtoa_r+0x3fe>
 802fa64:	9b06      	ldr	r3, [sp, #24]
 802fa66:	2b00      	cmp	r3, #0
 802fa68:	f340 80da 	ble.w	802fc20 <_dtoa_r+0x598>
 802fa6c:	4629      	mov	r1, r5
 802fa6e:	4620      	mov	r0, r4
 802fa70:	2200      	movs	r2, #0
 802fa72:	4b83      	ldr	r3, [pc, #524]	; (802fc80 <_dtoa_r+0x5f8>)
 802fa74:	f7fe fa48 	bl	802df08 <__aeabi_dmul>
 802fa78:	f10b 37ff 	add.w	r7, fp, #4294967295
 802fa7c:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802fa80:	3601      	adds	r6, #1
 802fa82:	9d06      	ldr	r5, [sp, #24]
 802fa84:	e001      	b.n	802fa8a <_dtoa_r+0x402>
 802fa86:	9d05      	ldr	r5, [sp, #20]
 802fa88:	465f      	mov	r7, fp
 802fa8a:	ed9d 7b02 	vldr	d7, [sp, #8]
 802fa8e:	4630      	mov	r0, r6
 802fa90:	ed8d 7b0e 	vstr	d7, [sp, #56]	; 0x38
 802fa94:	f7fe f9d2 	bl	802de3c <__aeabi_i2d>
 802fa98:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
 802fa9c:	f7fe fa34 	bl	802df08 <__aeabi_dmul>
 802faa0:	2200      	movs	r2, #0
 802faa2:	4b78      	ldr	r3, [pc, #480]	; (802fc84 <_dtoa_r+0x5fc>)
 802faa4:	f7fe f87e 	bl	802dba4 <__adddf3>
 802faa8:	4680      	mov	r8, r0
 802faaa:	f1a1 7950 	sub.w	r9, r1, #54525952	; 0x3400000
 802faae:	b9cd      	cbnz	r5, 802fae4 <_dtoa_r+0x45c>
 802fab0:	2200      	movs	r2, #0
 802fab2:	4b75      	ldr	r3, [pc, #468]	; (802fc88 <_dtoa_r+0x600>)
 802fab4:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 802fab8:	f7fe f872 	bl	802dba0 <__aeabi_dsub>
 802fabc:	4642      	mov	r2, r8
 802fabe:	464b      	mov	r3, r9
 802fac0:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802fac4:	f7fe fcb0 	bl	802e428 <__aeabi_dcmpgt>
 802fac8:	2800      	cmp	r0, #0
 802faca:	f040 8246 	bne.w	802ff5a <_dtoa_r+0x8d2>
 802face:	4642      	mov	r2, r8
 802fad0:	f109 4300 	add.w	r3, r9, #2147483648	; 0x80000000
 802fad4:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 802fad8:	f7fe fc88 	bl	802e3ec <__aeabi_dcmplt>
 802fadc:	2800      	cmp	r0, #0
 802fade:	f040 8236 	bne.w	802ff4e <_dtoa_r+0x8c6>
 802fae2:	e09d      	b.n	802fc20 <_dtoa_r+0x598>
 802fae4:	4b63      	ldr	r3, [pc, #396]	; (802fc74 <_dtoa_r+0x5ec>)
 802fae6:	990c      	ldr	r1, [sp, #48]	; 0x30
 802fae8:	1e6a      	subs	r2, r5, #1
 802faea:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 802faee:	2900      	cmp	r1, #0
 802faf0:	d049      	beq.n	802fb86 <_dtoa_r+0x4fe>
 802faf2:	e9d3 2300 	ldrd	r2, r3, [r3]
 802faf6:	2000      	movs	r0, #0
 802faf8:	4964      	ldr	r1, [pc, #400]	; (802fc8c <_dtoa_r+0x604>)
 802fafa:	f7fe fb2f 	bl	802e15c <__aeabi_ddiv>
 802fafe:	4642      	mov	r2, r8
 802fb00:	464b      	mov	r3, r9
 802fb02:	f7fe f84d 	bl	802dba0 <__aeabi_dsub>
 802fb06:	e9dd 890e 	ldrd	r8, r9, [sp, #56]	; 0x38
 802fb0a:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802fb0e:	9c08      	ldr	r4, [sp, #32]
 802fb10:	4649      	mov	r1, r9
 802fb12:	4640      	mov	r0, r8
 802fb14:	f7fe fc92 	bl	802e43c <__aeabi_d2iz>
 802fb18:	4606      	mov	r6, r0
 802fb1a:	f7fe f98f 	bl	802de3c <__aeabi_i2d>
 802fb1e:	4602      	mov	r2, r0
 802fb20:	460b      	mov	r3, r1
 802fb22:	4640      	mov	r0, r8
 802fb24:	4649      	mov	r1, r9
 802fb26:	f7fe f83b 	bl	802dba0 <__aeabi_dsub>
 802fb2a:	3630      	adds	r6, #48	; 0x30
 802fb2c:	f804 6b01 	strb.w	r6, [r4], #1
 802fb30:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 802fb34:	4680      	mov	r8, r0
 802fb36:	4689      	mov	r9, r1
 802fb38:	f7fe fc58 	bl	802e3ec <__aeabi_dcmplt>
 802fb3c:	2800      	cmp	r0, #0
 802fb3e:	f040 8340 	bne.w	80301c2 <_dtoa_r+0xb3a>
 802fb42:	4642      	mov	r2, r8
 802fb44:	464b      	mov	r3, r9
 802fb46:	2000      	movs	r0, #0
 802fb48:	494c      	ldr	r1, [pc, #304]	; (802fc7c <_dtoa_r+0x5f4>)
 802fb4a:	f7fe f829 	bl	802dba0 <__aeabi_dsub>
 802fb4e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 802fb52:	f7fe fc4b 	bl	802e3ec <__aeabi_dcmplt>
 802fb56:	2800      	cmp	r0, #0
 802fb58:	f040 80d3 	bne.w	802fd02 <_dtoa_r+0x67a>
 802fb5c:	9b08      	ldr	r3, [sp, #32]
 802fb5e:	1ae3      	subs	r3, r4, r3
 802fb60:	42ab      	cmp	r3, r5
 802fb62:	da5d      	bge.n	802fc20 <_dtoa_r+0x598>
 802fb64:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 802fb68:	2200      	movs	r2, #0
 802fb6a:	4b45      	ldr	r3, [pc, #276]	; (802fc80 <_dtoa_r+0x5f8>)
 802fb6c:	f7fe f9cc 	bl	802df08 <__aeabi_dmul>
 802fb70:	2200      	movs	r2, #0
 802fb72:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802fb76:	4b42      	ldr	r3, [pc, #264]	; (802fc80 <_dtoa_r+0x5f8>)
 802fb78:	4640      	mov	r0, r8
 802fb7a:	4649      	mov	r1, r9
 802fb7c:	f7fe f9c4 	bl	802df08 <__aeabi_dmul>
 802fb80:	4680      	mov	r8, r0
 802fb82:	4689      	mov	r9, r1
 802fb84:	e7c4      	b.n	802fb10 <_dtoa_r+0x488>
 802fb86:	e9d3 0100 	ldrd	r0, r1, [r3]
 802fb8a:	4642      	mov	r2, r8
 802fb8c:	464b      	mov	r3, r9
 802fb8e:	f7fe f9bb 	bl	802df08 <__aeabi_dmul>
 802fb92:	9b08      	ldr	r3, [sp, #32]
 802fb94:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802fb98:	e9dd 890e 	ldrd	r8, r9, [sp, #56]	; 0x38
 802fb9c:	195c      	adds	r4, r3, r5
 802fb9e:	461d      	mov	r5, r3
 802fba0:	4649      	mov	r1, r9
 802fba2:	4640      	mov	r0, r8
 802fba4:	f7fe fc4a 	bl	802e43c <__aeabi_d2iz>
 802fba8:	4606      	mov	r6, r0
 802fbaa:	f7fe f947 	bl	802de3c <__aeabi_i2d>
 802fbae:	3630      	adds	r6, #48	; 0x30
 802fbb0:	4602      	mov	r2, r0
 802fbb2:	460b      	mov	r3, r1
 802fbb4:	4640      	mov	r0, r8
 802fbb6:	4649      	mov	r1, r9
 802fbb8:	f7fd fff2 	bl	802dba0 <__aeabi_dsub>
 802fbbc:	f805 6b01 	strb.w	r6, [r5], #1
 802fbc0:	42a5      	cmp	r5, r4
 802fbc2:	4680      	mov	r8, r0
 802fbc4:	4689      	mov	r9, r1
 802fbc6:	d124      	bne.n	802fc12 <_dtoa_r+0x58a>
 802fbc8:	2200      	movs	r2, #0
 802fbca:	4b30      	ldr	r3, [pc, #192]	; (802fc8c <_dtoa_r+0x604>)
 802fbcc:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 802fbd0:	f7fd ffe8 	bl	802dba4 <__adddf3>
 802fbd4:	4602      	mov	r2, r0
 802fbd6:	460b      	mov	r3, r1
 802fbd8:	4640      	mov	r0, r8
 802fbda:	4649      	mov	r1, r9
 802fbdc:	f7fe fc24 	bl	802e428 <__aeabi_dcmpgt>
 802fbe0:	2800      	cmp	r0, #0
 802fbe2:	f040 808e 	bne.w	802fd02 <_dtoa_r+0x67a>
 802fbe6:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 802fbea:	2000      	movs	r0, #0
 802fbec:	4927      	ldr	r1, [pc, #156]	; (802fc8c <_dtoa_r+0x604>)
 802fbee:	f7fd ffd7 	bl	802dba0 <__aeabi_dsub>
 802fbf2:	4602      	mov	r2, r0
 802fbf4:	460b      	mov	r3, r1
 802fbf6:	4640      	mov	r0, r8
 802fbf8:	4649      	mov	r1, r9
 802fbfa:	f7fe fbf7 	bl	802e3ec <__aeabi_dcmplt>
 802fbfe:	b178      	cbz	r0, 802fc20 <_dtoa_r+0x598>
 802fc00:	f814 3c01 	ldrb.w	r3, [r4, #-1]
 802fc04:	2b30      	cmp	r3, #48	; 0x30
 802fc06:	f104 32ff 	add.w	r2, r4, #4294967295
 802fc0a:	f040 82da 	bne.w	80301c2 <_dtoa_r+0xb3a>
 802fc0e:	4614      	mov	r4, r2
 802fc10:	e7f6      	b.n	802fc00 <_dtoa_r+0x578>
 802fc12:	2200      	movs	r2, #0
 802fc14:	4b1a      	ldr	r3, [pc, #104]	; (802fc80 <_dtoa_r+0x5f8>)
 802fc16:	f7fe f977 	bl	802df08 <__aeabi_dmul>
 802fc1a:	4680      	mov	r8, r0
 802fc1c:	4689      	mov	r9, r1
 802fc1e:	e7bf      	b.n	802fba0 <_dtoa_r+0x518>
 802fc20:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	; 0x40
 802fc24:	e9cd 2302 	strd	r2, r3, [sp, #8]
 802fc28:	9b15      	ldr	r3, [sp, #84]	; 0x54
 802fc2a:	2b00      	cmp	r3, #0
 802fc2c:	f2c0 808b 	blt.w	802fd46 <_dtoa_r+0x6be>
 802fc30:	f1bb 0f0e 	cmp.w	fp, #14
 802fc34:	f300 8087 	bgt.w	802fd46 <_dtoa_r+0x6be>
 802fc38:	4b0e      	ldr	r3, [pc, #56]	; (802fc74 <_dtoa_r+0x5ec>)
 802fc3a:	eb03 03cb 	add.w	r3, r3, fp, lsl #3
 802fc3e:	e9d3 6700 	ldrd	r6, r7, [r3]
 802fc42:	9b21      	ldr	r3, [sp, #132]	; 0x84
 802fc44:	2b00      	cmp	r3, #0
 802fc46:	da23      	bge.n	802fc90 <_dtoa_r+0x608>
 802fc48:	9b05      	ldr	r3, [sp, #20]
 802fc4a:	2b00      	cmp	r3, #0
 802fc4c:	dc20      	bgt.n	802fc90 <_dtoa_r+0x608>
 802fc4e:	f040 817d 	bne.w	802ff4c <_dtoa_r+0x8c4>
 802fc52:	4630      	mov	r0, r6
 802fc54:	2200      	movs	r2, #0
 802fc56:	4b0c      	ldr	r3, [pc, #48]	; (802fc88 <_dtoa_r+0x600>)
 802fc58:	4639      	mov	r1, r7
 802fc5a:	f7fe f955 	bl	802df08 <__aeabi_dmul>
 802fc5e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 802fc62:	f7fe fbd7 	bl	802e414 <__aeabi_dcmpge>
 802fc66:	9d05      	ldr	r5, [sp, #20]
 802fc68:	462e      	mov	r6, r5
 802fc6a:	2800      	cmp	r0, #0
 802fc6c:	f040 8170 	bne.w	802ff50 <_dtoa_r+0x8c8>
 802fc70:	e175      	b.n	802ff5e <_dtoa_r+0x8d6>
 802fc72:	bf00      	nop
 802fc74:	08031e90 	.word	0x08031e90
 802fc78:	08031f58 	.word	0x08031f58
 802fc7c:	3ff00000 	.word	0x3ff00000
 802fc80:	40240000 	.word	0x40240000
 802fc84:	401c0000 	.word	0x401c0000
 802fc88:	40140000 	.word	0x40140000
 802fc8c:	3fe00000 	.word	0x3fe00000
 802fc90:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
 802fc94:	9c08      	ldr	r4, [sp, #32]
 802fc96:	4632      	mov	r2, r6
 802fc98:	463b      	mov	r3, r7
 802fc9a:	4640      	mov	r0, r8
 802fc9c:	4649      	mov	r1, r9
 802fc9e:	f7fe fa5d 	bl	802e15c <__aeabi_ddiv>
 802fca2:	f7fe fbcb 	bl	802e43c <__aeabi_d2iz>
 802fca6:	4605      	mov	r5, r0
 802fca8:	f7fe f8c8 	bl	802de3c <__aeabi_i2d>
 802fcac:	4632      	mov	r2, r6
 802fcae:	463b      	mov	r3, r7
 802fcb0:	f7fe f92a 	bl	802df08 <__aeabi_dmul>
 802fcb4:	460b      	mov	r3, r1
 802fcb6:	4602      	mov	r2, r0
 802fcb8:	4649      	mov	r1, r9
 802fcba:	4640      	mov	r0, r8
 802fcbc:	f7fd ff70 	bl	802dba0 <__aeabi_dsub>
 802fcc0:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 802fcc4:	9b08      	ldr	r3, [sp, #32]
 802fcc6:	f804 eb01 	strb.w	lr, [r4], #1
 802fcca:	ebc3 0e04 	rsb	lr, r3, r4
 802fcce:	9b05      	ldr	r3, [sp, #20]
 802fcd0:	459e      	cmp	lr, r3
 802fcd2:	d12b      	bne.n	802fd2c <_dtoa_r+0x6a4>
 802fcd4:	4602      	mov	r2, r0
 802fcd6:	460b      	mov	r3, r1
 802fcd8:	f7fd ff64 	bl	802dba4 <__adddf3>
 802fcdc:	4632      	mov	r2, r6
 802fcde:	463b      	mov	r3, r7
 802fce0:	4680      	mov	r8, r0
 802fce2:	4689      	mov	r9, r1
 802fce4:	f7fe fba0 	bl	802e428 <__aeabi_dcmpgt>
 802fce8:	b970      	cbnz	r0, 802fd08 <_dtoa_r+0x680>
 802fcea:	4640      	mov	r0, r8
 802fcec:	4649      	mov	r1, r9
 802fcee:	4632      	mov	r2, r6
 802fcf0:	463b      	mov	r3, r7
 802fcf2:	f7fe fb71 	bl	802e3d8 <__aeabi_dcmpeq>
 802fcf6:	2800      	cmp	r0, #0
 802fcf8:	f000 8264 	beq.w	80301c4 <_dtoa_r+0xb3c>
 802fcfc:	07eb      	lsls	r3, r5, #31
 802fcfe:	d403      	bmi.n	802fd08 <_dtoa_r+0x680>
 802fd00:	e260      	b.n	80301c4 <_dtoa_r+0xb3c>
 802fd02:	46bb      	mov	fp, r7
 802fd04:	e000      	b.n	802fd08 <_dtoa_r+0x680>
 802fd06:	461c      	mov	r4, r3
 802fd08:	f814 2c01 	ldrb.w	r2, [r4, #-1]
 802fd0c:	2a39      	cmp	r2, #57	; 0x39
 802fd0e:	f104 33ff 	add.w	r3, r4, #4294967295
 802fd12:	d107      	bne.n	802fd24 <_dtoa_r+0x69c>
 802fd14:	9a08      	ldr	r2, [sp, #32]
 802fd16:	4293      	cmp	r3, r2
 802fd18:	d1f5      	bne.n	802fd06 <_dtoa_r+0x67e>
 802fd1a:	2330      	movs	r3, #48	; 0x30
 802fd1c:	7013      	strb	r3, [r2, #0]
 802fd1e:	f10b 0b01 	add.w	fp, fp, #1
 802fd22:	4613      	mov	r3, r2
 802fd24:	781a      	ldrb	r2, [r3, #0]
 802fd26:	3201      	adds	r2, #1
 802fd28:	701a      	strb	r2, [r3, #0]
 802fd2a:	e24b      	b.n	80301c4 <_dtoa_r+0xb3c>
 802fd2c:	2200      	movs	r2, #0
 802fd2e:	4ba4      	ldr	r3, [pc, #656]	; (802ffc0 <_dtoa_r+0x938>)
 802fd30:	f7fe f8ea 	bl	802df08 <__aeabi_dmul>
 802fd34:	2200      	movs	r2, #0
 802fd36:	2300      	movs	r3, #0
 802fd38:	4680      	mov	r8, r0
 802fd3a:	4689      	mov	r9, r1
 802fd3c:	f7fe fb4c 	bl	802e3d8 <__aeabi_dcmpeq>
 802fd40:	2800      	cmp	r0, #0
 802fd42:	d0a8      	beq.n	802fc96 <_dtoa_r+0x60e>
 802fd44:	e23e      	b.n	80301c4 <_dtoa_r+0xb3c>
 802fd46:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 802fd48:	2a00      	cmp	r2, #0
 802fd4a:	d032      	beq.n	802fdb2 <_dtoa_r+0x72a>
 802fd4c:	9a20      	ldr	r2, [sp, #128]	; 0x80
 802fd4e:	2a01      	cmp	r2, #1
 802fd50:	dc0a      	bgt.n	802fd68 <_dtoa_r+0x6e0>
 802fd52:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 802fd54:	b112      	cbz	r2, 802fd5c <_dtoa_r+0x6d4>
 802fd56:	f203 4333 	addw	r3, r3, #1075	; 0x433
 802fd5a:	e002      	b.n	802fd62 <_dtoa_r+0x6da>
 802fd5c:	9b14      	ldr	r3, [sp, #80]	; 0x50
 802fd5e:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
 802fd62:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 802fd64:	9c09      	ldr	r4, [sp, #36]	; 0x24
 802fd66:	e018      	b.n	802fd9a <_dtoa_r+0x712>
 802fd68:	9b05      	ldr	r3, [sp, #20]
 802fd6a:	1e5d      	subs	r5, r3, #1
 802fd6c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802fd6e:	42ab      	cmp	r3, r5
 802fd70:	bfbf      	itttt	lt
 802fd72:	9b0b      	ldrlt	r3, [sp, #44]	; 0x2c
 802fd74:	950b      	strlt	r5, [sp, #44]	; 0x2c
 802fd76:	1aea      	sublt	r2, r5, r3
 802fd78:	9b0d      	ldrlt	r3, [sp, #52]	; 0x34
 802fd7a:	bfb6      	itet	lt
 802fd7c:	189b      	addlt	r3, r3, r2
 802fd7e:	1b5d      	subge	r5, r3, r5
 802fd80:	930d      	strlt	r3, [sp, #52]	; 0x34
 802fd82:	9b05      	ldr	r3, [sp, #20]
 802fd84:	bfb8      	it	lt
 802fd86:	2500      	movlt	r5, #0
 802fd88:	2b00      	cmp	r3, #0
 802fd8a:	bfb9      	ittee	lt
 802fd8c:	9b09      	ldrlt	r3, [sp, #36]	; 0x24
 802fd8e:	9a05      	ldrlt	r2, [sp, #20]
 802fd90:	9c09      	ldrge	r4, [sp, #36]	; 0x24
 802fd92:	9b05      	ldrge	r3, [sp, #20]
 802fd94:	bfbc      	itt	lt
 802fd96:	1a9c      	sublt	r4, r3, r2
 802fd98:	2300      	movlt	r3, #0
 802fd9a:	9a09      	ldr	r2, [sp, #36]	; 0x24
 802fd9c:	441a      	add	r2, r3
 802fd9e:	9209      	str	r2, [sp, #36]	; 0x24
 802fda0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 802fda2:	4650      	mov	r0, sl
 802fda4:	441a      	add	r2, r3
 802fda6:	2101      	movs	r1, #1
 802fda8:	920a      	str	r2, [sp, #40]	; 0x28
 802fdaa:	f000 fb14 	bl	80303d6 <__i2b>
 802fdae:	4606      	mov	r6, r0
 802fdb0:	e002      	b.n	802fdb8 <_dtoa_r+0x730>
 802fdb2:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 802fdb4:	9c09      	ldr	r4, [sp, #36]	; 0x24
 802fdb6:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 802fdb8:	b164      	cbz	r4, 802fdd4 <_dtoa_r+0x74c>
 802fdba:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802fdbc:	2b00      	cmp	r3, #0
 802fdbe:	dd09      	ble.n	802fdd4 <_dtoa_r+0x74c>
 802fdc0:	42a3      	cmp	r3, r4
 802fdc2:	9a09      	ldr	r2, [sp, #36]	; 0x24
 802fdc4:	bfa8      	it	ge
 802fdc6:	4623      	movge	r3, r4
 802fdc8:	1ad2      	subs	r2, r2, r3
 802fdca:	9209      	str	r2, [sp, #36]	; 0x24
 802fdcc:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 802fdce:	1ae4      	subs	r4, r4, r3
 802fdd0:	1ad3      	subs	r3, r2, r3
 802fdd2:	930a      	str	r3, [sp, #40]	; 0x28
 802fdd4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802fdd6:	2b00      	cmp	r3, #0
 802fdd8:	dd20      	ble.n	802fe1c <_dtoa_r+0x794>
 802fdda:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802fddc:	b1c3      	cbz	r3, 802fe10 <_dtoa_r+0x788>
 802fdde:	2d00      	cmp	r5, #0
 802fde0:	dd10      	ble.n	802fe04 <_dtoa_r+0x77c>
 802fde2:	4631      	mov	r1, r6
 802fde4:	462a      	mov	r2, r5
 802fde6:	4650      	mov	r0, sl
 802fde8:	f000 fb90 	bl	803050c <__pow5mult>
 802fdec:	4606      	mov	r6, r0
 802fdee:	4631      	mov	r1, r6
 802fdf0:	9a07      	ldr	r2, [sp, #28]
 802fdf2:	4650      	mov	r0, sl
 802fdf4:	f000 faf8 	bl	80303e8 <__multiply>
 802fdf8:	9907      	ldr	r1, [sp, #28]
 802fdfa:	4607      	mov	r7, r0
 802fdfc:	4650      	mov	r0, sl
 802fdfe:	f000 fa48 	bl	8030292 <_Bfree>
 802fe02:	9707      	str	r7, [sp, #28]
 802fe04:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802fe06:	1b5a      	subs	r2, r3, r5
 802fe08:	d008      	beq.n	802fe1c <_dtoa_r+0x794>
 802fe0a:	4650      	mov	r0, sl
 802fe0c:	9907      	ldr	r1, [sp, #28]
 802fe0e:	e002      	b.n	802fe16 <_dtoa_r+0x78e>
 802fe10:	9907      	ldr	r1, [sp, #28]
 802fe12:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 802fe14:	4650      	mov	r0, sl
 802fe16:	f000 fb79 	bl	803050c <__pow5mult>
 802fe1a:	9007      	str	r0, [sp, #28]
 802fe1c:	4650      	mov	r0, sl
 802fe1e:	2101      	movs	r1, #1
 802fe20:	f000 fad9 	bl	80303d6 <__i2b>
 802fe24:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802fe26:	2b00      	cmp	r3, #0
 802fe28:	4605      	mov	r5, r0
 802fe2a:	dd0a      	ble.n	802fe42 <_dtoa_r+0x7ba>
 802fe2c:	4629      	mov	r1, r5
 802fe2e:	461a      	mov	r2, r3
 802fe30:	4650      	mov	r0, sl
 802fe32:	f000 fb6b 	bl	803050c <__pow5mult>
 802fe36:	9b20      	ldr	r3, [sp, #128]	; 0x80
 802fe38:	2b01      	cmp	r3, #1
 802fe3a:	4605      	mov	r5, r0
 802fe3c:	dd04      	ble.n	802fe48 <_dtoa_r+0x7c0>
 802fe3e:	2700      	movs	r7, #0
 802fe40:	e01b      	b.n	802fe7a <_dtoa_r+0x7f2>
 802fe42:	9b20      	ldr	r3, [sp, #128]	; 0x80
 802fe44:	2b01      	cmp	r3, #1
 802fe46:	dc13      	bgt.n	802fe70 <_dtoa_r+0x7e8>
 802fe48:	9b02      	ldr	r3, [sp, #8]
 802fe4a:	b98b      	cbnz	r3, 802fe70 <_dtoa_r+0x7e8>
 802fe4c:	9b03      	ldr	r3, [sp, #12]
 802fe4e:	f3c3 0313 	ubfx	r3, r3, #0, #20
 802fe52:	b97b      	cbnz	r3, 802fe74 <_dtoa_r+0x7ec>
 802fe54:	9b03      	ldr	r3, [sp, #12]
 802fe56:	f023 4700 	bic.w	r7, r3, #2147483648	; 0x80000000
 802fe5a:	0d3f      	lsrs	r7, r7, #20
 802fe5c:	053f      	lsls	r7, r7, #20
 802fe5e:	b157      	cbz	r7, 802fe76 <_dtoa_r+0x7ee>
 802fe60:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802fe62:	3301      	adds	r3, #1
 802fe64:	9309      	str	r3, [sp, #36]	; 0x24
 802fe66:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802fe68:	3301      	adds	r3, #1
 802fe6a:	930a      	str	r3, [sp, #40]	; 0x28
 802fe6c:	2701      	movs	r7, #1
 802fe6e:	e002      	b.n	802fe76 <_dtoa_r+0x7ee>
 802fe70:	2700      	movs	r7, #0
 802fe72:	e000      	b.n	802fe76 <_dtoa_r+0x7ee>
 802fe74:	9f02      	ldr	r7, [sp, #8]
 802fe76:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802fe78:	b143      	cbz	r3, 802fe8c <_dtoa_r+0x804>
 802fe7a:	692b      	ldr	r3, [r5, #16]
 802fe7c:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 802fe80:	6918      	ldr	r0, [r3, #16]
 802fe82:	f000 fa5b 	bl	803033c <__hi0bits>
 802fe86:	f1c0 0020 	rsb	r0, r0, #32
 802fe8a:	e000      	b.n	802fe8e <_dtoa_r+0x806>
 802fe8c:	2001      	movs	r0, #1
 802fe8e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802fe90:	4418      	add	r0, r3
 802fe92:	f010 001f 	ands.w	r0, r0, #31
 802fe96:	d008      	beq.n	802feaa <_dtoa_r+0x822>
 802fe98:	f1c0 0320 	rsb	r3, r0, #32
 802fe9c:	2b04      	cmp	r3, #4
 802fe9e:	dd02      	ble.n	802fea6 <_dtoa_r+0x81e>
 802fea0:	f1c0 001c 	rsb	r0, r0, #28
 802fea4:	e002      	b.n	802feac <_dtoa_r+0x824>
 802fea6:	d008      	beq.n	802feba <_dtoa_r+0x832>
 802fea8:	4618      	mov	r0, r3
 802feaa:	301c      	adds	r0, #28
 802feac:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802feae:	4403      	add	r3, r0
 802feb0:	9309      	str	r3, [sp, #36]	; 0x24
 802feb2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802feb4:	4403      	add	r3, r0
 802feb6:	4404      	add	r4, r0
 802feb8:	930a      	str	r3, [sp, #40]	; 0x28
 802feba:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802febc:	2b00      	cmp	r3, #0
 802febe:	dd05      	ble.n	802fecc <_dtoa_r+0x844>
 802fec0:	4650      	mov	r0, sl
 802fec2:	9907      	ldr	r1, [sp, #28]
 802fec4:	461a      	mov	r2, r3
 802fec6:	f000 fb6f 	bl	80305a8 <__lshift>
 802feca:	9007      	str	r0, [sp, #28]
 802fecc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802fece:	2b00      	cmp	r3, #0
 802fed0:	dd05      	ble.n	802fede <_dtoa_r+0x856>
 802fed2:	4629      	mov	r1, r5
 802fed4:	4650      	mov	r0, sl
 802fed6:	461a      	mov	r2, r3
 802fed8:	f000 fb66 	bl	80305a8 <__lshift>
 802fedc:	4605      	mov	r5, r0
 802fede:	9b12      	ldr	r3, [sp, #72]	; 0x48
 802fee0:	b1eb      	cbz	r3, 802ff1e <_dtoa_r+0x896>
 802fee2:	9807      	ldr	r0, [sp, #28]
 802fee4:	4629      	mov	r1, r5
 802fee6:	f000 fbb2 	bl	803064e <__mcmp>
 802feea:	2800      	cmp	r0, #0
 802feec:	da17      	bge.n	802ff1e <_dtoa_r+0x896>
 802feee:	2300      	movs	r3, #0
 802fef0:	4650      	mov	r0, sl
 802fef2:	9907      	ldr	r1, [sp, #28]
 802fef4:	220a      	movs	r2, #10
 802fef6:	f000 f9e3 	bl	80302c0 <__multadd>
 802fefa:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802fefc:	9007      	str	r0, [sp, #28]
 802fefe:	f10b 3bff 	add.w	fp, fp, #4294967295
 802ff02:	2b00      	cmp	r3, #0
 802ff04:	f000 8170 	beq.w	80301e8 <_dtoa_r+0xb60>
 802ff08:	4631      	mov	r1, r6
 802ff0a:	2300      	movs	r3, #0
 802ff0c:	4650      	mov	r0, sl
 802ff0e:	220a      	movs	r2, #10
 802ff10:	f000 f9d6 	bl	80302c0 <__multadd>
 802ff14:	9b06      	ldr	r3, [sp, #24]
 802ff16:	2b00      	cmp	r3, #0
 802ff18:	4606      	mov	r6, r0
 802ff1a:	dc33      	bgt.n	802ff84 <_dtoa_r+0x8fc>
 802ff1c:	e16d      	b.n	80301fa <_dtoa_r+0xb72>
 802ff1e:	9b05      	ldr	r3, [sp, #20]
 802ff20:	2b00      	cmp	r3, #0
 802ff22:	dc26      	bgt.n	802ff72 <_dtoa_r+0x8ea>
 802ff24:	9b20      	ldr	r3, [sp, #128]	; 0x80
 802ff26:	2b02      	cmp	r3, #2
 802ff28:	dd23      	ble.n	802ff72 <_dtoa_r+0x8ea>
 802ff2a:	9b05      	ldr	r3, [sp, #20]
 802ff2c:	9306      	str	r3, [sp, #24]
 802ff2e:	9b06      	ldr	r3, [sp, #24]
 802ff30:	b973      	cbnz	r3, 802ff50 <_dtoa_r+0x8c8>
 802ff32:	4629      	mov	r1, r5
 802ff34:	2205      	movs	r2, #5
 802ff36:	4650      	mov	r0, sl
 802ff38:	f000 f9c2 	bl	80302c0 <__multadd>
 802ff3c:	4605      	mov	r5, r0
 802ff3e:	4629      	mov	r1, r5
 802ff40:	9807      	ldr	r0, [sp, #28]
 802ff42:	f000 fb84 	bl	803064e <__mcmp>
 802ff46:	2800      	cmp	r0, #0
 802ff48:	dc09      	bgt.n	802ff5e <_dtoa_r+0x8d6>
 802ff4a:	e001      	b.n	802ff50 <_dtoa_r+0x8c8>
 802ff4c:	2500      	movs	r5, #0
 802ff4e:	462e      	mov	r6, r5
 802ff50:	9b21      	ldr	r3, [sp, #132]	; 0x84
 802ff52:	9c08      	ldr	r4, [sp, #32]
 802ff54:	ea6f 0b03 	mvn.w	fp, r3
 802ff58:	e008      	b.n	802ff6c <_dtoa_r+0x8e4>
 802ff5a:	46bb      	mov	fp, r7
 802ff5c:	462e      	mov	r6, r5
 802ff5e:	9b08      	ldr	r3, [sp, #32]
 802ff60:	9a08      	ldr	r2, [sp, #32]
 802ff62:	1c5c      	adds	r4, r3, #1
 802ff64:	2331      	movs	r3, #49	; 0x31
 802ff66:	7013      	strb	r3, [r2, #0]
 802ff68:	f10b 0b01 	add.w	fp, fp, #1
 802ff6c:	46b1      	mov	r9, r6
 802ff6e:	2600      	movs	r6, #0
 802ff70:	e114      	b.n	803019c <_dtoa_r+0xb14>
 802ff72:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802ff74:	b923      	cbnz	r3, 802ff80 <_dtoa_r+0x8f8>
 802ff76:	9b05      	ldr	r3, [sp, #20]
 802ff78:	9306      	str	r3, [sp, #24]
 802ff7a:	9f08      	ldr	r7, [sp, #32]
 802ff7c:	9c07      	ldr	r4, [sp, #28]
 802ff7e:	e0cc      	b.n	803011a <_dtoa_r+0xa92>
 802ff80:	9b05      	ldr	r3, [sp, #20]
 802ff82:	9306      	str	r3, [sp, #24]
 802ff84:	2c00      	cmp	r4, #0
 802ff86:	dd05      	ble.n	802ff94 <_dtoa_r+0x90c>
 802ff88:	4631      	mov	r1, r6
 802ff8a:	4650      	mov	r0, sl
 802ff8c:	4622      	mov	r2, r4
 802ff8e:	f000 fb0b 	bl	80305a8 <__lshift>
 802ff92:	4606      	mov	r6, r0
 802ff94:	b1b7      	cbz	r7, 802ffc4 <_dtoa_r+0x93c>
 802ff96:	6871      	ldr	r1, [r6, #4]
 802ff98:	4650      	mov	r0, sl
 802ff9a:	f000 f945 	bl	8030228 <_Balloc>
 802ff9e:	6932      	ldr	r2, [r6, #16]
 802ffa0:	3202      	adds	r2, #2
 802ffa2:	4604      	mov	r4, r0
 802ffa4:	f106 010c 	add.w	r1, r6, #12
 802ffa8:	0092      	lsls	r2, r2, #2
 802ffaa:	300c      	adds	r0, #12
 802ffac:	f7fe fdfc 	bl	802eba8 <memcpy>
 802ffb0:	4650      	mov	r0, sl
 802ffb2:	4621      	mov	r1, r4
 802ffb4:	2201      	movs	r2, #1
 802ffb6:	f000 faf7 	bl	80305a8 <__lshift>
 802ffba:	4681      	mov	r9, r0
 802ffbc:	e003      	b.n	802ffc6 <_dtoa_r+0x93e>
 802ffbe:	bf00      	nop
 802ffc0:	40240000 	.word	0x40240000
 802ffc4:	46b1      	mov	r9, r6
 802ffc6:	9f08      	ldr	r7, [sp, #32]
 802ffc8:	9c07      	ldr	r4, [sp, #28]
 802ffca:	4629      	mov	r1, r5
 802ffcc:	4620      	mov	r0, r4
 802ffce:	f7ff facd 	bl	802f56c <quorem>
 802ffd2:	4631      	mov	r1, r6
 802ffd4:	9009      	str	r0, [sp, #36]	; 0x24
 802ffd6:	f100 0830 	add.w	r8, r0, #48	; 0x30
 802ffda:	4620      	mov	r0, r4
 802ffdc:	f000 fb37 	bl	803064e <__mcmp>
 802ffe0:	464a      	mov	r2, r9
 802ffe2:	9005      	str	r0, [sp, #20]
 802ffe4:	4629      	mov	r1, r5
 802ffe6:	4650      	mov	r0, sl
 802ffe8:	f000 fb4d 	bl	8030686 <__mdiff>
 802ffec:	68c2      	ldr	r2, [r0, #12]
 802ffee:	4603      	mov	r3, r0
 802fff0:	b93a      	cbnz	r2, 8030002 <_dtoa_r+0x97a>
 802fff2:	4619      	mov	r1, r3
 802fff4:	4620      	mov	r0, r4
 802fff6:	9307      	str	r3, [sp, #28]
 802fff8:	f000 fb29 	bl	803064e <__mcmp>
 802fffc:	9b07      	ldr	r3, [sp, #28]
 802fffe:	4602      	mov	r2, r0
 8030000:	e000      	b.n	8030004 <_dtoa_r+0x97c>
 8030002:	2201      	movs	r2, #1
 8030004:	4650      	mov	r0, sl
 8030006:	4619      	mov	r1, r3
 8030008:	9207      	str	r2, [sp, #28]
 803000a:	f000 f942 	bl	8030292 <_Bfree>
 803000e:	9a07      	ldr	r2, [sp, #28]
 8030010:	b9a2      	cbnz	r2, 803003c <_dtoa_r+0x9b4>
 8030012:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8030014:	b993      	cbnz	r3, 803003c <_dtoa_r+0x9b4>
 8030016:	9b02      	ldr	r3, [sp, #8]
 8030018:	f003 0301 	and.w	r3, r3, #1
 803001c:	b973      	cbnz	r3, 803003c <_dtoa_r+0x9b4>
 803001e:	f1b8 0f39 	cmp.w	r8, #57	; 0x39
 8030022:	463b      	mov	r3, r7
 8030024:	9407      	str	r4, [sp, #28]
 8030026:	d040      	beq.n	80300aa <_dtoa_r+0xa22>
 8030028:	9b05      	ldr	r3, [sp, #20]
 803002a:	2b00      	cmp	r3, #0
 803002c:	bfc8      	it	gt
 803002e:	9b09      	ldrgt	r3, [sp, #36]	; 0x24
 8030030:	f107 0401 	add.w	r4, r7, #1
 8030034:	bfc8      	it	gt
 8030036:	f103 0831 	addgt.w	r8, r3, #49	; 0x31
 803003a:	e03d      	b.n	80300b8 <_dtoa_r+0xa30>
 803003c:	9b05      	ldr	r3, [sp, #20]
 803003e:	2b00      	cmp	r3, #0
 8030040:	da04      	bge.n	803004c <_dtoa_r+0x9c4>
 8030042:	2a00      	cmp	r2, #0
 8030044:	46c4      	mov	ip, r8
 8030046:	9407      	str	r4, [sp, #28]
 8030048:	dc08      	bgt.n	803005c <_dtoa_r+0x9d4>
 803004a:	e021      	b.n	8030090 <_dtoa_r+0xa08>
 803004c:	d124      	bne.n	8030098 <_dtoa_r+0xa10>
 803004e:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8030050:	bb13      	cbnz	r3, 8030098 <_dtoa_r+0xa10>
 8030052:	9b02      	ldr	r3, [sp, #8]
 8030054:	f003 0301 	and.w	r3, r3, #1
 8030058:	b9f3      	cbnz	r3, 8030098 <_dtoa_r+0xa10>
 803005a:	e7f2      	b.n	8030042 <_dtoa_r+0x9ba>
 803005c:	4621      	mov	r1, r4
 803005e:	2201      	movs	r2, #1
 8030060:	4650      	mov	r0, sl
 8030062:	9705      	str	r7, [sp, #20]
 8030064:	f8cd 8008 	str.w	r8, [sp, #8]
 8030068:	f000 fa9e 	bl	80305a8 <__lshift>
 803006c:	4629      	mov	r1, r5
 803006e:	9007      	str	r0, [sp, #28]
 8030070:	f000 faed 	bl	803064e <__mcmp>
 8030074:	2800      	cmp	r0, #0
 8030076:	f8dd c008 	ldr.w	ip, [sp, #8]
 803007a:	9b05      	ldr	r3, [sp, #20]
 803007c:	dc03      	bgt.n	8030086 <_dtoa_r+0x9fe>
 803007e:	d107      	bne.n	8030090 <_dtoa_r+0xa08>
 8030080:	f018 0f01 	tst.w	r8, #1
 8030084:	d004      	beq.n	8030090 <_dtoa_r+0xa08>
 8030086:	f1b8 0f39 	cmp.w	r8, #57	; 0x39
 803008a:	d00e      	beq.n	80300aa <_dtoa_r+0xa22>
 803008c:	f108 0c01 	add.w	ip, r8, #1
 8030090:	1c7c      	adds	r4, r7, #1
 8030092:	f887 c000 	strb.w	ip, [r7]
 8030096:	e081      	b.n	803019c <_dtoa_r+0xb14>
 8030098:	2a00      	cmp	r2, #0
 803009a:	f107 0201 	add.w	r2, r7, #1
 803009e:	dd0e      	ble.n	80300be <_dtoa_r+0xa36>
 80300a0:	f1b8 0f39 	cmp.w	r8, #57	; 0x39
 80300a4:	463b      	mov	r3, r7
 80300a6:	9407      	str	r4, [sp, #28]
 80300a8:	d103      	bne.n	80300b2 <_dtoa_r+0xa2a>
 80300aa:	2239      	movs	r2, #57	; 0x39
 80300ac:	3701      	adds	r7, #1
 80300ae:	701a      	strb	r2, [r3, #0]
 80300b0:	e057      	b.n	8030162 <_dtoa_r+0xada>
 80300b2:	4614      	mov	r4, r2
 80300b4:	f108 0801 	add.w	r8, r8, #1
 80300b8:	f887 8000 	strb.w	r8, [r7]
 80300bc:	e06e      	b.n	803019c <_dtoa_r+0xb14>
 80300be:	9b08      	ldr	r3, [sp, #32]
 80300c0:	f802 8c01 	strb.w	r8, [r2, #-1]
 80300c4:	1ad3      	subs	r3, r2, r3
 80300c6:	4617      	mov	r7, r2
 80300c8:	9a06      	ldr	r2, [sp, #24]
 80300ca:	4293      	cmp	r3, r2
 80300cc:	d03a      	beq.n	8030144 <_dtoa_r+0xabc>
 80300ce:	4621      	mov	r1, r4
 80300d0:	220a      	movs	r2, #10
 80300d2:	2300      	movs	r3, #0
 80300d4:	4650      	mov	r0, sl
 80300d6:	f000 f8f3 	bl	80302c0 <__multadd>
 80300da:	454e      	cmp	r6, r9
 80300dc:	4604      	mov	r4, r0
 80300de:	4631      	mov	r1, r6
 80300e0:	4650      	mov	r0, sl
 80300e2:	f04f 020a 	mov.w	r2, #10
 80300e6:	f04f 0300 	mov.w	r3, #0
 80300ea:	d104      	bne.n	80300f6 <_dtoa_r+0xa6e>
 80300ec:	f000 f8e8 	bl	80302c0 <__multadd>
 80300f0:	4606      	mov	r6, r0
 80300f2:	4681      	mov	r9, r0
 80300f4:	e769      	b.n	802ffca <_dtoa_r+0x942>
 80300f6:	f000 f8e3 	bl	80302c0 <__multadd>
 80300fa:	4649      	mov	r1, r9
 80300fc:	4606      	mov	r6, r0
 80300fe:	220a      	movs	r2, #10
 8030100:	4650      	mov	r0, sl
 8030102:	2300      	movs	r3, #0
 8030104:	f000 f8dc 	bl	80302c0 <__multadd>
 8030108:	4681      	mov	r9, r0
 803010a:	e75e      	b.n	802ffca <_dtoa_r+0x942>
 803010c:	4621      	mov	r1, r4
 803010e:	4650      	mov	r0, sl
 8030110:	220a      	movs	r2, #10
 8030112:	2300      	movs	r3, #0
 8030114:	f000 f8d4 	bl	80302c0 <__multadd>
 8030118:	4604      	mov	r4, r0
 803011a:	4620      	mov	r0, r4
 803011c:	4629      	mov	r1, r5
 803011e:	f7ff fa25 	bl	802f56c <quorem>
 8030122:	f100 0830 	add.w	r8, r0, #48	; 0x30
 8030126:	f807 8b01 	strb.w	r8, [r7], #1
 803012a:	9b08      	ldr	r3, [sp, #32]
 803012c:	9a06      	ldr	r2, [sp, #24]
 803012e:	1afb      	subs	r3, r7, r3
 8030130:	4293      	cmp	r3, r2
 8030132:	dbeb      	blt.n	803010c <_dtoa_r+0xa84>
 8030134:	9b08      	ldr	r3, [sp, #32]
 8030136:	2a01      	cmp	r2, #1
 8030138:	bfac      	ite	ge
 803013a:	189b      	addge	r3, r3, r2
 803013c:	3301      	addlt	r3, #1
 803013e:	46b1      	mov	r9, r6
 8030140:	461f      	mov	r7, r3
 8030142:	2600      	movs	r6, #0
 8030144:	4621      	mov	r1, r4
 8030146:	2201      	movs	r2, #1
 8030148:	4650      	mov	r0, sl
 803014a:	f000 fa2d 	bl	80305a8 <__lshift>
 803014e:	4629      	mov	r1, r5
 8030150:	9007      	str	r0, [sp, #28]
 8030152:	f000 fa7c 	bl	803064e <__mcmp>
 8030156:	2800      	cmp	r0, #0
 8030158:	dc03      	bgt.n	8030162 <_dtoa_r+0xada>
 803015a:	d116      	bne.n	803018a <_dtoa_r+0xb02>
 803015c:	f018 0f01 	tst.w	r8, #1
 8030160:	d013      	beq.n	803018a <_dtoa_r+0xb02>
 8030162:	463c      	mov	r4, r7
 8030164:	f814 3c01 	ldrb.w	r3, [r4, #-1]
 8030168:	2b39      	cmp	r3, #57	; 0x39
 803016a:	f104 32ff 	add.w	r2, r4, #4294967295
 803016e:	d109      	bne.n	8030184 <_dtoa_r+0xafc>
 8030170:	9b08      	ldr	r3, [sp, #32]
 8030172:	429a      	cmp	r2, r3
 8030174:	d104      	bne.n	8030180 <_dtoa_r+0xaf8>
 8030176:	f10b 0b01 	add.w	fp, fp, #1
 803017a:	2331      	movs	r3, #49	; 0x31
 803017c:	9a08      	ldr	r2, [sp, #32]
 803017e:	e002      	b.n	8030186 <_dtoa_r+0xafe>
 8030180:	4614      	mov	r4, r2
 8030182:	e7ef      	b.n	8030164 <_dtoa_r+0xadc>
 8030184:	3301      	adds	r3, #1
 8030186:	7013      	strb	r3, [r2, #0]
 8030188:	e008      	b.n	803019c <_dtoa_r+0xb14>
 803018a:	463c      	mov	r4, r7
 803018c:	f814 3c01 	ldrb.w	r3, [r4, #-1]
 8030190:	2b30      	cmp	r3, #48	; 0x30
 8030192:	f104 32ff 	add.w	r2, r4, #4294967295
 8030196:	d101      	bne.n	803019c <_dtoa_r+0xb14>
 8030198:	4614      	mov	r4, r2
 803019a:	e7f7      	b.n	803018c <_dtoa_r+0xb04>
 803019c:	4650      	mov	r0, sl
 803019e:	4629      	mov	r1, r5
 80301a0:	f000 f877 	bl	8030292 <_Bfree>
 80301a4:	f1b9 0f00 	cmp.w	r9, #0
 80301a8:	d00c      	beq.n	80301c4 <_dtoa_r+0xb3c>
 80301aa:	b12e      	cbz	r6, 80301b8 <_dtoa_r+0xb30>
 80301ac:	454e      	cmp	r6, r9
 80301ae:	d003      	beq.n	80301b8 <_dtoa_r+0xb30>
 80301b0:	4650      	mov	r0, sl
 80301b2:	4631      	mov	r1, r6
 80301b4:	f000 f86d 	bl	8030292 <_Bfree>
 80301b8:	4650      	mov	r0, sl
 80301ba:	4649      	mov	r1, r9
 80301bc:	f000 f869 	bl	8030292 <_Bfree>
 80301c0:	e000      	b.n	80301c4 <_dtoa_r+0xb3c>
 80301c2:	46bb      	mov	fp, r7
 80301c4:	4650      	mov	r0, sl
 80301c6:	9907      	ldr	r1, [sp, #28]
 80301c8:	f000 f863 	bl	8030292 <_Bfree>
 80301cc:	2300      	movs	r3, #0
 80301ce:	9a22      	ldr	r2, [sp, #136]	; 0x88
 80301d0:	7023      	strb	r3, [r4, #0]
 80301d2:	f10b 0301 	add.w	r3, fp, #1
 80301d6:	6013      	str	r3, [r2, #0]
 80301d8:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80301da:	b11b      	cbz	r3, 80301e4 <_dtoa_r+0xb5c>
 80301dc:	601c      	str	r4, [r3, #0]
 80301de:	e001      	b.n	80301e4 <_dtoa_r+0xb5c>
 80301e0:	480a      	ldr	r0, [pc, #40]	; (803020c <_dtoa_r+0xb84>)
 80301e2:	e00f      	b.n	8030204 <_dtoa_r+0xb7c>
 80301e4:	9808      	ldr	r0, [sp, #32]
 80301e6:	e00d      	b.n	8030204 <_dtoa_r+0xb7c>
 80301e8:	9b06      	ldr	r3, [sp, #24]
 80301ea:	2b00      	cmp	r3, #0
 80301ec:	f73f aec5 	bgt.w	802ff7a <_dtoa_r+0x8f2>
 80301f0:	9b20      	ldr	r3, [sp, #128]	; 0x80
 80301f2:	2b02      	cmp	r3, #2
 80301f4:	f73f ae9b 	bgt.w	802ff2e <_dtoa_r+0x8a6>
 80301f8:	e6bf      	b.n	802ff7a <_dtoa_r+0x8f2>
 80301fa:	9b20      	ldr	r3, [sp, #128]	; 0x80
 80301fc:	2b02      	cmp	r3, #2
 80301fe:	f73f ae96 	bgt.w	802ff2e <_dtoa_r+0x8a6>
 8030202:	e6bf      	b.n	802ff84 <_dtoa_r+0x8fc>
 8030204:	b017      	add	sp, #92	; 0x5c
 8030206:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 803020a:	bf00      	nop
 803020c:	08031e72 	.word	0x08031e72

08030210 <_localeconv_r>:
 8030210:	4800      	ldr	r0, [pc, #0]	; (8030214 <_localeconv_r+0x4>)
 8030212:	4770      	bx	lr
 8030214:	1ffe96a8 	.word	0x1ffe96a8

08030218 <malloc>:
 8030218:	4b02      	ldr	r3, [pc, #8]	; (8030224 <malloc+0xc>)
 803021a:	4601      	mov	r1, r0
 803021c:	6818      	ldr	r0, [r3, #0]
 803021e:	f000 baf1 	b.w	8030804 <_malloc_r>
 8030222:	bf00      	nop
 8030224:	1ffe96a4 	.word	0x1ffe96a4

08030228 <_Balloc>:
 8030228:	b570      	push	{r4, r5, r6, lr}
 803022a:	6a45      	ldr	r5, [r0, #36]	; 0x24
 803022c:	4604      	mov	r4, r0
 803022e:	460e      	mov	r6, r1
 8030230:	b93d      	cbnz	r5, 8030242 <_Balloc+0x1a>
 8030232:	2010      	movs	r0, #16
 8030234:	f7ff fff0 	bl	8030218 <malloc>
 8030238:	6260      	str	r0, [r4, #36]	; 0x24
 803023a:	6045      	str	r5, [r0, #4]
 803023c:	6085      	str	r5, [r0, #8]
 803023e:	6005      	str	r5, [r0, #0]
 8030240:	60c5      	str	r5, [r0, #12]
 8030242:	6a65      	ldr	r5, [r4, #36]	; 0x24
 8030244:	68eb      	ldr	r3, [r5, #12]
 8030246:	b143      	cbz	r3, 803025a <_Balloc+0x32>
 8030248:	6a63      	ldr	r3, [r4, #36]	; 0x24
 803024a:	68db      	ldr	r3, [r3, #12]
 803024c:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
 8030250:	b178      	cbz	r0, 8030272 <_Balloc+0x4a>
 8030252:	6802      	ldr	r2, [r0, #0]
 8030254:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
 8030258:	e017      	b.n	803028a <_Balloc+0x62>
 803025a:	4620      	mov	r0, r4
 803025c:	2104      	movs	r1, #4
 803025e:	2221      	movs	r2, #33	; 0x21
 8030260:	f000 fac2 	bl	80307e8 <_calloc_r>
 8030264:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8030266:	60e8      	str	r0, [r5, #12]
 8030268:	68db      	ldr	r3, [r3, #12]
 803026a:	2b00      	cmp	r3, #0
 803026c:	d1ec      	bne.n	8030248 <_Balloc+0x20>
 803026e:	2000      	movs	r0, #0
 8030270:	bd70      	pop	{r4, r5, r6, pc}
 8030272:	2101      	movs	r1, #1
 8030274:	fa01 f506 	lsl.w	r5, r1, r6
 8030278:	1d6a      	adds	r2, r5, #5
 803027a:	4620      	mov	r0, r4
 803027c:	0092      	lsls	r2, r2, #2
 803027e:	f000 fab3 	bl	80307e8 <_calloc_r>
 8030282:	2800      	cmp	r0, #0
 8030284:	d0f3      	beq.n	803026e <_Balloc+0x46>
 8030286:	6046      	str	r6, [r0, #4]
 8030288:	6085      	str	r5, [r0, #8]
 803028a:	2300      	movs	r3, #0
 803028c:	6103      	str	r3, [r0, #16]
 803028e:	60c3      	str	r3, [r0, #12]
 8030290:	bd70      	pop	{r4, r5, r6, pc}

08030292 <_Bfree>:
 8030292:	b570      	push	{r4, r5, r6, lr}
 8030294:	6a44      	ldr	r4, [r0, #36]	; 0x24
 8030296:	4606      	mov	r6, r0
 8030298:	460d      	mov	r5, r1
 803029a:	b93c      	cbnz	r4, 80302ac <_Bfree+0x1a>
 803029c:	2010      	movs	r0, #16
 803029e:	f7ff ffbb 	bl	8030218 <malloc>
 80302a2:	6270      	str	r0, [r6, #36]	; 0x24
 80302a4:	6044      	str	r4, [r0, #4]
 80302a6:	6084      	str	r4, [r0, #8]
 80302a8:	6004      	str	r4, [r0, #0]
 80302aa:	60c4      	str	r4, [r0, #12]
 80302ac:	b13d      	cbz	r5, 80302be <_Bfree+0x2c>
 80302ae:	6a73      	ldr	r3, [r6, #36]	; 0x24
 80302b0:	686a      	ldr	r2, [r5, #4]
 80302b2:	68db      	ldr	r3, [r3, #12]
 80302b4:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 80302b8:	6029      	str	r1, [r5, #0]
 80302ba:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
 80302be:	bd70      	pop	{r4, r5, r6, pc}

080302c0 <__multadd>:
 80302c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80302c4:	690f      	ldr	r7, [r1, #16]
 80302c6:	4698      	mov	r8, r3
 80302c8:	4606      	mov	r6, r0
 80302ca:	460c      	mov	r4, r1
 80302cc:	f101 0e14 	add.w	lr, r1, #20
 80302d0:	2300      	movs	r3, #0
 80302d2:	f8de 0000 	ldr.w	r0, [lr]
 80302d6:	b285      	uxth	r5, r0
 80302d8:	0c01      	lsrs	r1, r0, #16
 80302da:	fb02 8505 	mla	r5, r2, r5, r8
 80302de:	4351      	muls	r1, r2
 80302e0:	eb01 4115 	add.w	r1, r1, r5, lsr #16
 80302e4:	3301      	adds	r3, #1
 80302e6:	b2ad      	uxth	r5, r5
 80302e8:	ea4f 4811 	mov.w	r8, r1, lsr #16
 80302ec:	42bb      	cmp	r3, r7
 80302ee:	eb05 4101 	add.w	r1, r5, r1, lsl #16
 80302f2:	f84e 1b04 	str.w	r1, [lr], #4
 80302f6:	dbec      	blt.n	80302d2 <__multadd+0x12>
 80302f8:	f1b8 0f00 	cmp.w	r8, #0
 80302fc:	d01b      	beq.n	8030336 <__multadd+0x76>
 80302fe:	68a3      	ldr	r3, [r4, #8]
 8030300:	429f      	cmp	r7, r3
 8030302:	db12      	blt.n	803032a <__multadd+0x6a>
 8030304:	6861      	ldr	r1, [r4, #4]
 8030306:	4630      	mov	r0, r6
 8030308:	3101      	adds	r1, #1
 803030a:	f7ff ff8d 	bl	8030228 <_Balloc>
 803030e:	6922      	ldr	r2, [r4, #16]
 8030310:	3202      	adds	r2, #2
 8030312:	f104 010c 	add.w	r1, r4, #12
 8030316:	4605      	mov	r5, r0
 8030318:	0092      	lsls	r2, r2, #2
 803031a:	300c      	adds	r0, #12
 803031c:	f7fe fc44 	bl	802eba8 <memcpy>
 8030320:	4621      	mov	r1, r4
 8030322:	4630      	mov	r0, r6
 8030324:	f7ff ffb5 	bl	8030292 <_Bfree>
 8030328:	462c      	mov	r4, r5
 803032a:	eb04 0387 	add.w	r3, r4, r7, lsl #2
 803032e:	3701      	adds	r7, #1
 8030330:	f8c3 8014 	str.w	r8, [r3, #20]
 8030334:	6127      	str	r7, [r4, #16]
 8030336:	4620      	mov	r0, r4
 8030338:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0803033c <__hi0bits>:
 803033c:	0c03      	lsrs	r3, r0, #16
 803033e:	041b      	lsls	r3, r3, #16
 8030340:	b913      	cbnz	r3, 8030348 <__hi0bits+0xc>
 8030342:	0400      	lsls	r0, r0, #16
 8030344:	2310      	movs	r3, #16
 8030346:	e000      	b.n	803034a <__hi0bits+0xe>
 8030348:	2300      	movs	r3, #0
 803034a:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
 803034e:	bf04      	itt	eq
 8030350:	0200      	lsleq	r0, r0, #8
 8030352:	3308      	addeq	r3, #8
 8030354:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
 8030358:	bf04      	itt	eq
 803035a:	0100      	lsleq	r0, r0, #4
 803035c:	3304      	addeq	r3, #4
 803035e:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
 8030362:	bf04      	itt	eq
 8030364:	0080      	lsleq	r0, r0, #2
 8030366:	3302      	addeq	r3, #2
 8030368:	2800      	cmp	r0, #0
 803036a:	db03      	blt.n	8030374 <__hi0bits+0x38>
 803036c:	0042      	lsls	r2, r0, #1
 803036e:	d503      	bpl.n	8030378 <__hi0bits+0x3c>
 8030370:	1c58      	adds	r0, r3, #1
 8030372:	4770      	bx	lr
 8030374:	4618      	mov	r0, r3
 8030376:	4770      	bx	lr
 8030378:	2020      	movs	r0, #32
 803037a:	4770      	bx	lr

0803037c <__lo0bits>:
 803037c:	6803      	ldr	r3, [r0, #0]
 803037e:	f013 0207 	ands.w	r2, r3, #7
 8030382:	d00b      	beq.n	803039c <__lo0bits+0x20>
 8030384:	07d9      	lsls	r1, r3, #31
 8030386:	d422      	bmi.n	80303ce <__lo0bits+0x52>
 8030388:	079a      	lsls	r2, r3, #30
 803038a:	bf4b      	itete	mi
 803038c:	085b      	lsrmi	r3, r3, #1
 803038e:	089b      	lsrpl	r3, r3, #2
 8030390:	6003      	strmi	r3, [r0, #0]
 8030392:	6003      	strpl	r3, [r0, #0]
 8030394:	bf4c      	ite	mi
 8030396:	2001      	movmi	r0, #1
 8030398:	2002      	movpl	r0, #2
 803039a:	4770      	bx	lr
 803039c:	b299      	uxth	r1, r3
 803039e:	b909      	cbnz	r1, 80303a4 <__lo0bits+0x28>
 80303a0:	0c1b      	lsrs	r3, r3, #16
 80303a2:	2210      	movs	r2, #16
 80303a4:	f013 0fff 	tst.w	r3, #255	; 0xff
 80303a8:	bf04      	itt	eq
 80303aa:	0a1b      	lsreq	r3, r3, #8
 80303ac:	3208      	addeq	r2, #8
 80303ae:	0719      	lsls	r1, r3, #28
 80303b0:	bf04      	itt	eq
 80303b2:	091b      	lsreq	r3, r3, #4
 80303b4:	3204      	addeq	r2, #4
 80303b6:	0799      	lsls	r1, r3, #30
 80303b8:	bf04      	itt	eq
 80303ba:	089b      	lsreq	r3, r3, #2
 80303bc:	3202      	addeq	r2, #2
 80303be:	07d9      	lsls	r1, r3, #31
 80303c0:	d402      	bmi.n	80303c8 <__lo0bits+0x4c>
 80303c2:	085b      	lsrs	r3, r3, #1
 80303c4:	d005      	beq.n	80303d2 <__lo0bits+0x56>
 80303c6:	3201      	adds	r2, #1
 80303c8:	6003      	str	r3, [r0, #0]
 80303ca:	4610      	mov	r0, r2
 80303cc:	4770      	bx	lr
 80303ce:	2000      	movs	r0, #0
 80303d0:	4770      	bx	lr
 80303d2:	2020      	movs	r0, #32
 80303d4:	4770      	bx	lr

080303d6 <__i2b>:
 80303d6:	b510      	push	{r4, lr}
 80303d8:	460c      	mov	r4, r1
 80303da:	2101      	movs	r1, #1
 80303dc:	f7ff ff24 	bl	8030228 <_Balloc>
 80303e0:	2201      	movs	r2, #1
 80303e2:	6144      	str	r4, [r0, #20]
 80303e4:	6102      	str	r2, [r0, #16]
 80303e6:	bd10      	pop	{r4, pc}

080303e8 <__multiply>:
 80303e8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80303ec:	4614      	mov	r4, r2
 80303ee:	690a      	ldr	r2, [r1, #16]
 80303f0:	6923      	ldr	r3, [r4, #16]
 80303f2:	429a      	cmp	r2, r3
 80303f4:	bfb8      	it	lt
 80303f6:	460b      	movlt	r3, r1
 80303f8:	4688      	mov	r8, r1
 80303fa:	bfbc      	itt	lt
 80303fc:	46a0      	movlt	r8, r4
 80303fe:	461c      	movlt	r4, r3
 8030400:	f8d8 7010 	ldr.w	r7, [r8, #16]
 8030404:	f8d4 9010 	ldr.w	r9, [r4, #16]
 8030408:	f8d8 3008 	ldr.w	r3, [r8, #8]
 803040c:	f8d8 1004 	ldr.w	r1, [r8, #4]
 8030410:	eb07 0609 	add.w	r6, r7, r9
 8030414:	429e      	cmp	r6, r3
 8030416:	bfc8      	it	gt
 8030418:	3101      	addgt	r1, #1
 803041a:	f7ff ff05 	bl	8030228 <_Balloc>
 803041e:	f100 0514 	add.w	r5, r0, #20
 8030422:	eb05 0c86 	add.w	ip, r5, r6, lsl #2
 8030426:	462b      	mov	r3, r5
 8030428:	4563      	cmp	r3, ip
 803042a:	d203      	bcs.n	8030434 <__multiply+0x4c>
 803042c:	2200      	movs	r2, #0
 803042e:	f843 2b04 	str.w	r2, [r3], #4
 8030432:	e7f9      	b.n	8030428 <__multiply+0x40>
 8030434:	f104 0214 	add.w	r2, r4, #20
 8030438:	f108 0114 	add.w	r1, r8, #20
 803043c:	eb02 0389 	add.w	r3, r2, r9, lsl #2
 8030440:	eb01 0787 	add.w	r7, r1, r7, lsl #2
 8030444:	9300      	str	r3, [sp, #0]
 8030446:	9b00      	ldr	r3, [sp, #0]
 8030448:	9201      	str	r2, [sp, #4]
 803044a:	429a      	cmp	r2, r3
 803044c:	d257      	bcs.n	80304fe <__multiply+0x116>
 803044e:	f8b2 b000 	ldrh.w	fp, [r2]
 8030452:	f1bb 0f00 	cmp.w	fp, #0
 8030456:	d023      	beq.n	80304a0 <__multiply+0xb8>
 8030458:	4689      	mov	r9, r1
 803045a:	46ae      	mov	lr, r5
 803045c:	f04f 0800 	mov.w	r8, #0
 8030460:	f859 4b04 	ldr.w	r4, [r9], #4
 8030464:	f8be a000 	ldrh.w	sl, [lr]
 8030468:	b2a3      	uxth	r3, r4
 803046a:	fb0b a303 	mla	r3, fp, r3, sl
 803046e:	ea4f 4a14 	mov.w	sl, r4, lsr #16
 8030472:	f8de 4000 	ldr.w	r4, [lr]
 8030476:	4443      	add	r3, r8
 8030478:	ea4f 4814 	mov.w	r8, r4, lsr #16
 803047c:	fb0b 840a 	mla	r4, fp, sl, r8
 8030480:	eb04 4413 	add.w	r4, r4, r3, lsr #16
 8030484:	46f2      	mov	sl, lr
 8030486:	b29b      	uxth	r3, r3
 8030488:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 803048c:	454f      	cmp	r7, r9
 803048e:	ea4f 4814 	mov.w	r8, r4, lsr #16
 8030492:	f84a 3b04 	str.w	r3, [sl], #4
 8030496:	d901      	bls.n	803049c <__multiply+0xb4>
 8030498:	46d6      	mov	lr, sl
 803049a:	e7e1      	b.n	8030460 <__multiply+0x78>
 803049c:	f8ce 8004 	str.w	r8, [lr, #4]
 80304a0:	9b01      	ldr	r3, [sp, #4]
 80304a2:	f8b3 a002 	ldrh.w	sl, [r3, #2]
 80304a6:	3204      	adds	r2, #4
 80304a8:	f1ba 0f00 	cmp.w	sl, #0
 80304ac:	d021      	beq.n	80304f2 <__multiply+0x10a>
 80304ae:	682b      	ldr	r3, [r5, #0]
 80304b0:	462c      	mov	r4, r5
 80304b2:	4689      	mov	r9, r1
 80304b4:	f04f 0800 	mov.w	r8, #0
 80304b8:	f8b9 e000 	ldrh.w	lr, [r9]
 80304bc:	f8b4 b002 	ldrh.w	fp, [r4, #2]
 80304c0:	fb0a be0e 	mla	lr, sl, lr, fp
 80304c4:	44f0      	add	r8, lr
 80304c6:	46a3      	mov	fp, r4
 80304c8:	b29b      	uxth	r3, r3
 80304ca:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 80304ce:	f84b 3b04 	str.w	r3, [fp], #4
 80304d2:	f859 3b04 	ldr.w	r3, [r9], #4
 80304d6:	f8b4 e004 	ldrh.w	lr, [r4, #4]
 80304da:	0c1b      	lsrs	r3, r3, #16
 80304dc:	fb0a e303 	mla	r3, sl, r3, lr
 80304e0:	eb03 4318 	add.w	r3, r3, r8, lsr #16
 80304e4:	45b9      	cmp	r9, r7
 80304e6:	ea4f 4813 	mov.w	r8, r3, lsr #16
 80304ea:	d201      	bcs.n	80304f0 <__multiply+0x108>
 80304ec:	465c      	mov	r4, fp
 80304ee:	e7e3      	b.n	80304b8 <__multiply+0xd0>
 80304f0:	6063      	str	r3, [r4, #4]
 80304f2:	3504      	adds	r5, #4
 80304f4:	e7a7      	b.n	8030446 <__multiply+0x5e>
 80304f6:	f85c 3d04 	ldr.w	r3, [ip, #-4]!
 80304fa:	b913      	cbnz	r3, 8030502 <__multiply+0x11a>
 80304fc:	3e01      	subs	r6, #1
 80304fe:	2e00      	cmp	r6, #0
 8030500:	dcf9      	bgt.n	80304f6 <__multiply+0x10e>
 8030502:	6106      	str	r6, [r0, #16]
 8030504:	b003      	add	sp, #12
 8030506:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

0803050c <__pow5mult>:
 803050c:	f012 0303 	ands.w	r3, r2, #3
 8030510:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8030514:	4606      	mov	r6, r0
 8030516:	460f      	mov	r7, r1
 8030518:	4615      	mov	r5, r2
 803051a:	d007      	beq.n	803052c <__pow5mult+0x20>
 803051c:	3b01      	subs	r3, #1
 803051e:	4a21      	ldr	r2, [pc, #132]	; (80305a4 <__pow5mult+0x98>)
 8030520:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8030524:	2300      	movs	r3, #0
 8030526:	f7ff fecb 	bl	80302c0 <__multadd>
 803052a:	4607      	mov	r7, r0
 803052c:	10ad      	asrs	r5, r5, #2
 803052e:	d035      	beq.n	803059c <__pow5mult+0x90>
 8030530:	6a74      	ldr	r4, [r6, #36]	; 0x24
 8030532:	b93c      	cbnz	r4, 8030544 <__pow5mult+0x38>
 8030534:	2010      	movs	r0, #16
 8030536:	f7ff fe6f 	bl	8030218 <malloc>
 803053a:	6270      	str	r0, [r6, #36]	; 0x24
 803053c:	6044      	str	r4, [r0, #4]
 803053e:	6084      	str	r4, [r0, #8]
 8030540:	6004      	str	r4, [r0, #0]
 8030542:	60c4      	str	r4, [r0, #12]
 8030544:	f8d6 8024 	ldr.w	r8, [r6, #36]	; 0x24
 8030548:	f8d8 4008 	ldr.w	r4, [r8, #8]
 803054c:	b97c      	cbnz	r4, 803056e <__pow5mult+0x62>
 803054e:	4630      	mov	r0, r6
 8030550:	f240 2171 	movw	r1, #625	; 0x271
 8030554:	f7ff ff3f 	bl	80303d6 <__i2b>
 8030558:	2300      	movs	r3, #0
 803055a:	f8c8 0008 	str.w	r0, [r8, #8]
 803055e:	4604      	mov	r4, r0
 8030560:	6003      	str	r3, [r0, #0]
 8030562:	e004      	b.n	803056e <__pow5mult+0x62>
 8030564:	106d      	asrs	r5, r5, #1
 8030566:	d019      	beq.n	803059c <__pow5mult+0x90>
 8030568:	6820      	ldr	r0, [r4, #0]
 803056a:	b170      	cbz	r0, 803058a <__pow5mult+0x7e>
 803056c:	4604      	mov	r4, r0
 803056e:	07eb      	lsls	r3, r5, #31
 8030570:	d5f8      	bpl.n	8030564 <__pow5mult+0x58>
 8030572:	4639      	mov	r1, r7
 8030574:	4622      	mov	r2, r4
 8030576:	4630      	mov	r0, r6
 8030578:	f7ff ff36 	bl	80303e8 <__multiply>
 803057c:	4639      	mov	r1, r7
 803057e:	4680      	mov	r8, r0
 8030580:	4630      	mov	r0, r6
 8030582:	f7ff fe86 	bl	8030292 <_Bfree>
 8030586:	4647      	mov	r7, r8
 8030588:	e7ec      	b.n	8030564 <__pow5mult+0x58>
 803058a:	4630      	mov	r0, r6
 803058c:	4621      	mov	r1, r4
 803058e:	4622      	mov	r2, r4
 8030590:	f7ff ff2a 	bl	80303e8 <__multiply>
 8030594:	2300      	movs	r3, #0
 8030596:	6020      	str	r0, [r4, #0]
 8030598:	6003      	str	r3, [r0, #0]
 803059a:	e7e7      	b.n	803056c <__pow5mult+0x60>
 803059c:	4638      	mov	r0, r7
 803059e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80305a2:	bf00      	nop
 80305a4:	08031f80 	.word	0x08031f80

080305a8 <__lshift>:
 80305a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80305ac:	460c      	mov	r4, r1
 80305ae:	ea4f 1a62 	mov.w	sl, r2, asr #5
 80305b2:	6923      	ldr	r3, [r4, #16]
 80305b4:	6849      	ldr	r1, [r1, #4]
 80305b6:	eb0a 0903 	add.w	r9, sl, r3
 80305ba:	68a3      	ldr	r3, [r4, #8]
 80305bc:	4607      	mov	r7, r0
 80305be:	4616      	mov	r6, r2
 80305c0:	f109 0501 	add.w	r5, r9, #1
 80305c4:	429d      	cmp	r5, r3
 80305c6:	dd02      	ble.n	80305ce <__lshift+0x26>
 80305c8:	3101      	adds	r1, #1
 80305ca:	005b      	lsls	r3, r3, #1
 80305cc:	e7fa      	b.n	80305c4 <__lshift+0x1c>
 80305ce:	4638      	mov	r0, r7
 80305d0:	f7ff fe2a 	bl	8030228 <_Balloc>
 80305d4:	2300      	movs	r3, #0
 80305d6:	4680      	mov	r8, r0
 80305d8:	f100 0114 	add.w	r1, r0, #20
 80305dc:	4553      	cmp	r3, sl
 80305de:	da04      	bge.n	80305ea <__lshift+0x42>
 80305e0:	2200      	movs	r2, #0
 80305e2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 80305e6:	3301      	adds	r3, #1
 80305e8:	e7f8      	b.n	80305dc <__lshift+0x34>
 80305ea:	ea2a 73ea 	bic.w	r3, sl, sl, asr #31
 80305ee:	6920      	ldr	r0, [r4, #16]
 80305f0:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 80305f4:	f016 021f 	ands.w	r2, r6, #31
 80305f8:	f104 0114 	add.w	r1, r4, #20
 80305fc:	eb01 0e80 	add.w	lr, r1, r0, lsl #2
 8030600:	d014      	beq.n	803062c <__lshift+0x84>
 8030602:	f1c2 0c20 	rsb	ip, r2, #32
 8030606:	2000      	movs	r0, #0
 8030608:	680e      	ldr	r6, [r1, #0]
 803060a:	4096      	lsls	r6, r2
 803060c:	4330      	orrs	r0, r6
 803060e:	469a      	mov	sl, r3
 8030610:	f843 0b04 	str.w	r0, [r3], #4
 8030614:	f851 0b04 	ldr.w	r0, [r1], #4
 8030618:	4571      	cmp	r1, lr
 803061a:	fa20 f00c 	lsr.w	r0, r0, ip
 803061e:	d3f3      	bcc.n	8030608 <__lshift+0x60>
 8030620:	f8ca 0004 	str.w	r0, [sl, #4]
 8030624:	b148      	cbz	r0, 803063a <__lshift+0x92>
 8030626:	f109 0502 	add.w	r5, r9, #2
 803062a:	e006      	b.n	803063a <__lshift+0x92>
 803062c:	3b04      	subs	r3, #4
 803062e:	f851 2b04 	ldr.w	r2, [r1], #4
 8030632:	f843 2f04 	str.w	r2, [r3, #4]!
 8030636:	4571      	cmp	r1, lr
 8030638:	d3f9      	bcc.n	803062e <__lshift+0x86>
 803063a:	3d01      	subs	r5, #1
 803063c:	4638      	mov	r0, r7
 803063e:	f8c8 5010 	str.w	r5, [r8, #16]
 8030642:	4621      	mov	r1, r4
 8030644:	f7ff fe25 	bl	8030292 <_Bfree>
 8030648:	4640      	mov	r0, r8
 803064a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0803064e <__mcmp>:
 803064e:	6903      	ldr	r3, [r0, #16]
 8030650:	690a      	ldr	r2, [r1, #16]
 8030652:	1a9b      	subs	r3, r3, r2
 8030654:	b510      	push	{r4, lr}
 8030656:	d111      	bne.n	803067c <__mcmp+0x2e>
 8030658:	0092      	lsls	r2, r2, #2
 803065a:	3014      	adds	r0, #20
 803065c:	3114      	adds	r1, #20
 803065e:	1883      	adds	r3, r0, r2
 8030660:	440a      	add	r2, r1
 8030662:	f853 4d04 	ldr.w	r4, [r3, #-4]!
 8030666:	f852 1d04 	ldr.w	r1, [r2, #-4]!
 803066a:	428c      	cmp	r4, r1
 803066c:	d002      	beq.n	8030674 <__mcmp+0x26>
 803066e:	d307      	bcc.n	8030680 <__mcmp+0x32>
 8030670:	2001      	movs	r0, #1
 8030672:	bd10      	pop	{r4, pc}
 8030674:	4283      	cmp	r3, r0
 8030676:	d8f4      	bhi.n	8030662 <__mcmp+0x14>
 8030678:	2000      	movs	r0, #0
 803067a:	bd10      	pop	{r4, pc}
 803067c:	4618      	mov	r0, r3
 803067e:	bd10      	pop	{r4, pc}
 8030680:	f04f 30ff 	mov.w	r0, #4294967295
 8030684:	bd10      	pop	{r4, pc}

08030686 <__mdiff>:
 8030686:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 803068a:	4607      	mov	r7, r0
 803068c:	460c      	mov	r4, r1
 803068e:	4608      	mov	r0, r1
 8030690:	4611      	mov	r1, r2
 8030692:	4615      	mov	r5, r2
 8030694:	f7ff ffdb 	bl	803064e <__mcmp>
 8030698:	1e06      	subs	r6, r0, #0
 803069a:	d108      	bne.n	80306ae <__mdiff+0x28>
 803069c:	4638      	mov	r0, r7
 803069e:	4631      	mov	r1, r6
 80306a0:	f7ff fdc2 	bl	8030228 <_Balloc>
 80306a4:	2301      	movs	r3, #1
 80306a6:	6103      	str	r3, [r0, #16]
 80306a8:	6146      	str	r6, [r0, #20]
 80306aa:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80306ae:	bfbc      	itt	lt
 80306b0:	4623      	movlt	r3, r4
 80306b2:	462c      	movlt	r4, r5
 80306b4:	4638      	mov	r0, r7
 80306b6:	6861      	ldr	r1, [r4, #4]
 80306b8:	bfba      	itte	lt
 80306ba:	461d      	movlt	r5, r3
 80306bc:	2601      	movlt	r6, #1
 80306be:	2600      	movge	r6, #0
 80306c0:	f7ff fdb2 	bl	8030228 <_Balloc>
 80306c4:	692b      	ldr	r3, [r5, #16]
 80306c6:	60c6      	str	r6, [r0, #12]
 80306c8:	6926      	ldr	r6, [r4, #16]
 80306ca:	f105 0914 	add.w	r9, r5, #20
 80306ce:	3414      	adds	r4, #20
 80306d0:	eb04 0786 	add.w	r7, r4, r6, lsl #2
 80306d4:	eb09 0883 	add.w	r8, r9, r3, lsl #2
 80306d8:	f100 0514 	add.w	r5, r0, #20
 80306dc:	f04f 0c00 	mov.w	ip, #0
 80306e0:	f854 3b04 	ldr.w	r3, [r4], #4
 80306e4:	f859 2b04 	ldr.w	r2, [r9], #4
 80306e8:	fa1c f183 	uxtah	r1, ip, r3
 80306ec:	fa1f fe82 	uxth.w	lr, r2
 80306f0:	0c12      	lsrs	r2, r2, #16
 80306f2:	ebce 0101 	rsb	r1, lr, r1
 80306f6:	ebc2 4313 	rsb	r3, r2, r3, lsr #16
 80306fa:	eb03 4321 	add.w	r3, r3, r1, asr #16
 80306fe:	b289      	uxth	r1, r1
 8030700:	ea4f 4c23 	mov.w	ip, r3, asr #16
 8030704:	45c8      	cmp	r8, r9
 8030706:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 803070a:	46a6      	mov	lr, r4
 803070c:	f845 3b04 	str.w	r3, [r5], #4
 8030710:	d8e6      	bhi.n	80306e0 <__mdiff+0x5a>
 8030712:	45be      	cmp	lr, r7
 8030714:	d20e      	bcs.n	8030734 <__mdiff+0xae>
 8030716:	f85e 2b04 	ldr.w	r2, [lr], #4
 803071a:	fa1c f482 	uxtah	r4, ip, r2
 803071e:	0c12      	lsrs	r2, r2, #16
 8030720:	eb02 4224 	add.w	r2, r2, r4, asr #16
 8030724:	b2a4      	uxth	r4, r4
 8030726:	ea4f 4c22 	mov.w	ip, r2, asr #16
 803072a:	ea44 4202 	orr.w	r2, r4, r2, lsl #16
 803072e:	f845 2b04 	str.w	r2, [r5], #4
 8030732:	e7ee      	b.n	8030712 <__mdiff+0x8c>
 8030734:	f855 3d04 	ldr.w	r3, [r5, #-4]!
 8030738:	b90b      	cbnz	r3, 803073e <__mdiff+0xb8>
 803073a:	3e01      	subs	r6, #1
 803073c:	e7fa      	b.n	8030734 <__mdiff+0xae>
 803073e:	6106      	str	r6, [r0, #16]
 8030740:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08030744 <__d2b>:
 8030744:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8030748:	2101      	movs	r1, #1
 803074a:	461d      	mov	r5, r3
 803074c:	9f08      	ldr	r7, [sp, #32]
 803074e:	9e09      	ldr	r6, [sp, #36]	; 0x24
 8030750:	4614      	mov	r4, r2
 8030752:	f7ff fd69 	bl	8030228 <_Balloc>
 8030756:	f3c5 0313 	ubfx	r3, r5, #0, #20
 803075a:	f3c5 550a 	ubfx	r5, r5, #20, #11
 803075e:	4680      	mov	r8, r0
 8030760:	b10d      	cbz	r5, 8030766 <__d2b+0x22>
 8030762:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8030766:	9301      	str	r3, [sp, #4]
 8030768:	b1ec      	cbz	r4, 80307a6 <__d2b+0x62>
 803076a:	a802      	add	r0, sp, #8
 803076c:	f840 4d08 	str.w	r4, [r0, #-8]!
 8030770:	f7ff fe04 	bl	803037c <__lo0bits>
 8030774:	9b00      	ldr	r3, [sp, #0]
 8030776:	b150      	cbz	r0, 803078e <__d2b+0x4a>
 8030778:	9a01      	ldr	r2, [sp, #4]
 803077a:	f1c0 0120 	rsb	r1, r0, #32
 803077e:	fa02 f101 	lsl.w	r1, r2, r1
 8030782:	430b      	orrs	r3, r1
 8030784:	40c2      	lsrs	r2, r0
 8030786:	f8c8 3014 	str.w	r3, [r8, #20]
 803078a:	9201      	str	r2, [sp, #4]
 803078c:	e001      	b.n	8030792 <__d2b+0x4e>
 803078e:	f8c8 3014 	str.w	r3, [r8, #20]
 8030792:	9b01      	ldr	r3, [sp, #4]
 8030794:	f8c8 3018 	str.w	r3, [r8, #24]
 8030798:	2b00      	cmp	r3, #0
 803079a:	bf14      	ite	ne
 803079c:	2402      	movne	r4, #2
 803079e:	2401      	moveq	r4, #1
 80307a0:	f8c8 4010 	str.w	r4, [r8, #16]
 80307a4:	e009      	b.n	80307ba <__d2b+0x76>
 80307a6:	a801      	add	r0, sp, #4
 80307a8:	f7ff fde8 	bl	803037c <__lo0bits>
 80307ac:	2401      	movs	r4, #1
 80307ae:	9b01      	ldr	r3, [sp, #4]
 80307b0:	f8c8 3014 	str.w	r3, [r8, #20]
 80307b4:	f8c8 4010 	str.w	r4, [r8, #16]
 80307b8:	3020      	adds	r0, #32
 80307ba:	b135      	cbz	r5, 80307ca <__d2b+0x86>
 80307bc:	f2a5 4533 	subw	r5, r5, #1075	; 0x433
 80307c0:	4405      	add	r5, r0
 80307c2:	603d      	str	r5, [r7, #0]
 80307c4:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
 80307c8:	e009      	b.n	80307de <__d2b+0x9a>
 80307ca:	eb08 0384 	add.w	r3, r8, r4, lsl #2
 80307ce:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
 80307d2:	6038      	str	r0, [r7, #0]
 80307d4:	6918      	ldr	r0, [r3, #16]
 80307d6:	f7ff fdb1 	bl	803033c <__hi0bits>
 80307da:	ebc0 1044 	rsb	r0, r0, r4, lsl #5
 80307de:	6030      	str	r0, [r6, #0]
 80307e0:	4640      	mov	r0, r8
 80307e2:	b002      	add	sp, #8
 80307e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080307e8 <_calloc_r>:
 80307e8:	b538      	push	{r3, r4, r5, lr}
 80307ea:	fb02 f401 	mul.w	r4, r2, r1
 80307ee:	4621      	mov	r1, r4
 80307f0:	f000 f808 	bl	8030804 <_malloc_r>
 80307f4:	4605      	mov	r5, r0
 80307f6:	b118      	cbz	r0, 8030800 <_calloc_r+0x18>
 80307f8:	2100      	movs	r1, #0
 80307fa:	4622      	mov	r2, r4
 80307fc:	f7fe f9df 	bl	802ebbe <memset>
 8030800:	4628      	mov	r0, r5
 8030802:	bd38      	pop	{r3, r4, r5, pc}

08030804 <_malloc_r>:
 8030804:	b570      	push	{r4, r5, r6, lr}
 8030806:	1ccc      	adds	r4, r1, #3
 8030808:	f024 0403 	bic.w	r4, r4, #3
 803080c:	3408      	adds	r4, #8
 803080e:	2c0c      	cmp	r4, #12
 8030810:	bf38      	it	cc
 8030812:	240c      	movcc	r4, #12
 8030814:	2c00      	cmp	r4, #0
 8030816:	4606      	mov	r6, r0
 8030818:	da03      	bge.n	8030822 <_malloc_r+0x1e>
 803081a:	230c      	movs	r3, #12
 803081c:	6033      	str	r3, [r6, #0]
 803081e:	2000      	movs	r0, #0
 8030820:	bd70      	pop	{r4, r5, r6, pc}
 8030822:	428c      	cmp	r4, r1
 8030824:	d3f9      	bcc.n	803081a <_malloc_r+0x16>
 8030826:	4a20      	ldr	r2, [pc, #128]	; (80308a8 <_malloc_r+0xa4>)
 8030828:	6813      	ldr	r3, [r2, #0]
 803082a:	4610      	mov	r0, r2
 803082c:	4619      	mov	r1, r3
 803082e:	b1a1      	cbz	r1, 803085a <_malloc_r+0x56>
 8030830:	680a      	ldr	r2, [r1, #0]
 8030832:	1b12      	subs	r2, r2, r4
 8030834:	d40e      	bmi.n	8030854 <_malloc_r+0x50>
 8030836:	2a0b      	cmp	r2, #11
 8030838:	d903      	bls.n	8030842 <_malloc_r+0x3e>
 803083a:	600a      	str	r2, [r1, #0]
 803083c:	188b      	adds	r3, r1, r2
 803083e:	508c      	str	r4, [r1, r2]
 8030840:	e01f      	b.n	8030882 <_malloc_r+0x7e>
 8030842:	428b      	cmp	r3, r1
 8030844:	bf0d      	iteet	eq
 8030846:	685a      	ldreq	r2, [r3, #4]
 8030848:	684a      	ldrne	r2, [r1, #4]
 803084a:	605a      	strne	r2, [r3, #4]
 803084c:	6002      	streq	r2, [r0, #0]
 803084e:	bf18      	it	ne
 8030850:	460b      	movne	r3, r1
 8030852:	e016      	b.n	8030882 <_malloc_r+0x7e>
 8030854:	460b      	mov	r3, r1
 8030856:	6849      	ldr	r1, [r1, #4]
 8030858:	e7e9      	b.n	803082e <_malloc_r+0x2a>
 803085a:	4d14      	ldr	r5, [pc, #80]	; (80308ac <_malloc_r+0xa8>)
 803085c:	682b      	ldr	r3, [r5, #0]
 803085e:	b91b      	cbnz	r3, 8030868 <_malloc_r+0x64>
 8030860:	4630      	mov	r0, r6
 8030862:	f000 f825 	bl	80308b0 <_sbrk_r>
 8030866:	6028      	str	r0, [r5, #0]
 8030868:	4630      	mov	r0, r6
 803086a:	4621      	mov	r1, r4
 803086c:	f000 f820 	bl	80308b0 <_sbrk_r>
 8030870:	1c42      	adds	r2, r0, #1
 8030872:	4603      	mov	r3, r0
 8030874:	d0d1      	beq.n	803081a <_malloc_r+0x16>
 8030876:	1cc5      	adds	r5, r0, #3
 8030878:	f025 0503 	bic.w	r5, r5, #3
 803087c:	4285      	cmp	r5, r0
 803087e:	d10a      	bne.n	8030896 <_malloc_r+0x92>
 8030880:	601c      	str	r4, [r3, #0]
 8030882:	f103 000b 	add.w	r0, r3, #11
 8030886:	1d1a      	adds	r2, r3, #4
 8030888:	f020 0007 	bic.w	r0, r0, #7
 803088c:	1a82      	subs	r2, r0, r2
 803088e:	d00a      	beq.n	80308a6 <_malloc_r+0xa2>
 8030890:	4251      	negs	r1, r2
 8030892:	5099      	str	r1, [r3, r2]
 8030894:	bd70      	pop	{r4, r5, r6, pc}
 8030896:	4630      	mov	r0, r6
 8030898:	1ae9      	subs	r1, r5, r3
 803089a:	f000 f809 	bl	80308b0 <_sbrk_r>
 803089e:	3001      	adds	r0, #1
 80308a0:	d0bb      	beq.n	803081a <_malloc_r+0x16>
 80308a2:	462b      	mov	r3, r5
 80308a4:	e7ec      	b.n	8030880 <_malloc_r+0x7c>
 80308a6:	bd70      	pop	{r4, r5, r6, pc}
 80308a8:	20004b24 	.word	0x20004b24
 80308ac:	20004b20 	.word	0x20004b20

080308b0 <_sbrk_r>:
 80308b0:	b538      	push	{r3, r4, r5, lr}
 80308b2:	4c06      	ldr	r4, [pc, #24]	; (80308cc <_sbrk_r+0x1c>)
 80308b4:	2300      	movs	r3, #0
 80308b6:	4605      	mov	r5, r0
 80308b8:	4608      	mov	r0, r1
 80308ba:	6023      	str	r3, [r4, #0]
 80308bc:	f7f3 f992 	bl	8023be4 <_sbrk>
 80308c0:	1c43      	adds	r3, r0, #1
 80308c2:	d102      	bne.n	80308ca <_sbrk_r+0x1a>
 80308c4:	6823      	ldr	r3, [r4, #0]
 80308c6:	b103      	cbz	r3, 80308ca <_sbrk_r+0x1a>
 80308c8:	602b      	str	r3, [r5, #0]
 80308ca:	bd38      	pop	{r3, r4, r5, pc}
 80308cc:	2000db28 	.word	0x2000db28

080308d0 <ds_default_device_settings>:
 80308d0:	0000012c 4bb80560 4bb74bd4 4bb8d274     ,...`..K.K.Kt..K
 80308e0:	43480000 00000010 00000001 00034155     ..HC........UA..
 80308f0:	0004000c 00010701 000249f0 00000040     .........I..@...
 8030900:	00000003 00000000 00000000 00000000     ................
 8030910:	00000000 69736f50 6e6f6974 206f4732     ....Position2Go 
 8030920:	32544742 52544d34 44203231 206f6d65     BGT24MTR12 Demo 
 8030930:	61646152 6f422072 00647261              Radar Board.

0803093c <cg_device_info_struct>:
 803093c:	08030914 016e97a8 0171a4e8 01070201     ......n...q.....
 803094c:	01000201                                ....

08030950 <driver_version_s>:
 8030950:	00030001                                ....

08030954 <CSWTCH.37>:
	...
 803095c:	00000002 00000002 0000000c 0000000c     ................
 803096c:	0000000c 0000000c 00000008 0000000a     ................

0803097c <CSWTCH.38>:
 803097c:	00000003 00000003 0000000c 0000000c     ................
 803098c:	00003000 00003000 00003000 00003000     .0...0...0...0..
 803099c:	00000300 00000c00                       ........

080309a4 <CSWTCH.43>:
 80309a4:	00000003 00000003 0000000c 0000000c     ................
 80309b4:	00000030 00000030 00003000 00003000     0...0....0...0..
 80309c4:	00000300 00000c00                       ........

080309cc <CSWTCH.44>:
	...
 80309d4:	00000002 00000002 00000004 00000004     ................
 80309e4:	0000000c 0000000c 00000008 0000000a     ................

080309f4 <Driver_USBD0>:
 80309f4:	08022495 08022af5 08022811 080224b1     .$...*...(...$..
 8030a04:	080224c9 080224e1 080225f9 08022835     .$...$...%..5(..
 8030a14:	080226e1 08022611 08022cc1 08022ab5     .&...&...,...*..
 8030a24:	08022da1 0802269d 080227e1 080227f5     .-...&...'...'..

08030a34 <g_xmc_vadc_group_array>:
 8030a34:	40004400 40004800 40004c00 40005000     .D.@.H.@.L.@.P.@

08030a44 <product_string>:
 8030a44:	00490310 00580046 00430020 00430044     ..I.F.X. .C.D.C.
	...

08030aac <device_descriptor>:
 8030aac:	01100112 40000002 0058058b 02010001     .......@..X.....
 8030abc:	00000100                                ....

08030ac0 <language_string>:
 8030ac0:	04090304 00000000 00000000 00000000     ................
	...

08030b28 <manufacturer_string>:
 8030b28:	00490312 0066006e 006e0069 006f0065     ..I.n.f.i.n.e.o.
 8030b38:	0000006e 00000000 00000000 00000000     n...............
	...

08030b90 <CSWTCH.1>:
 8030b90:	08030ac0 08030b28 08030a44              ....(...D...

08030b9c <CSWTCH.2>:
 8030b9c:	00120004 00000010                       ........

08030ba4 <configuration_descriptor>:
 8030ba4:	003e0209 80000102 00040932 02020100     ..>.....2.......
 8030bb4:	24050001 04011000 05060224 01000624     ...$....$...$...
 8030bc4:	03810507 09ff0008 02000104 0000000a     ................
 8030bd4:	02030507 07010040 40028205 00000100     ....@......@....

08030be4 <INTERRUPT_WATCHDOG>:
 8030be4:	01003d39                                9=..

08030be8 <INTERRUPT_FRAME>:
 8030be8:	01003d38                                8=..

08030bec <group_init_handle0>:
	...
 8030bfc:	00000080                                ....

08030c00 <group_init_handle1>:
	...
 8030c10:	00000080                                ....

08030c14 <group_init_handle3>:
	...
 8030c24:	00000080                                ....

08030c28 <global_config>:
 8030c28:	00000000 00000004 00000000 00000000     ................
	...

08030c40 <group_init_handle2>:
	...
 8030c50:	00000080                                ....

08030c54 <e_eeprom_xmc4_fce>:
 8030c54:	50020020 00000700 00000000               ..P........

08030c60 <EVENT_GENERATOR_CCU4_OGU_Config>:
 8030c60:	00004014                                .@..

08030c64 <EVENT_DETECTOR_PLL_TRIG1_ETL_Config>:
 8030c64:	00000000 00000006                       ........

08030c6c <DIGITAL_IO_BGT_LDO_ENABLE>:
 8030c6c:	48028400 00000080 00000001 00000000     ...H............
 8030c7c:	00000003                                ....

08030c80 <DIGITAL_IO_PLL_CE>:
 8030c80:	48028200 00000080 00010000 00000001     ...H............
 8030c90:	00000002                                ....

08030c94 <DIGITAL_IO_SPI_DATA_PGA>:
 8030c94:	48028500 00000080 00010000 00000000     ...H............
 8030ca4:	00000001                                ....

08030ca8 <DIGITAL_IO_SPI_M_CLK>:
 8030ca8:	48028800 00000080 00010000 00000000     ...H............
 8030cb8:	00000005                                ....

08030cbc <DIGITAL_IO_SPI_M_CS_PGA>:
 8030cbc:	48028800 00000080 00000001 00000000     ...H............
 8030ccc:	00000004                                ....

08030cd0 <DIGITAL_IO_PLL_TRIG1>:
 8030cd0:	48028100 00000000 00000000 00000000     ...H............
 8030ce0:	00000003                                ....

08030ce4 <DIGITAL_IO_PLL_TRIG2>:
 8030ce4:	48028100 00000080 00010000 00000000     ...H............
 8030cf4:	00000001                                ....

08030cf8 <DIGITAL_IO_PLL_MOD>:
 8030cf8:	48028100 00000000 00000000 00000000     ...H............
 8030d08:	00000002                                ....

08030d0c <DIGITAL_IO_SPI_M_CS_PLL>:
 8030d0c:	48028100 00000080 00000001 00000000     ...H............
 8030d1c:	00000008                                ....

08030d20 <DIGITAL_IO_PLL_MUXIN>:
 8030d20:	48028100 00000000 00000000 00000000     ...H............
 8030d30:	00000000                                ....

08030d34 <DIGITAL_IO_SPI_M_CS_BGT24>:
 8030d34:	48028800 00000080 00000001 00000000     ...H............
 8030d44:	00000006                                ....

08030d48 <DIGITAL_IO_LED1>:
 8030d48:	48028700 00000080 00010000 00000000     ...H............
 8030d58:	00000008                                ....

08030d5c <DIGITAL_IO_PGA_LDO_ENABLE>:
 8030d5c:	48028700 00000080 00000001 00000000     ...H............
 8030d6c:	0000000b                                ....

08030d70 <DIGITAL_IO_SPI_M_DATA>:
 8030d70:	48028800 00000080 00010000 00000000     ...H............
 8030d80:	00000007                                ....

08030d84 <DIGITAL_IO_BGT_POWER_ENABLE>:
 8030d84:	48028200 00000080 00010000 00000000     ...H............
 8030d94:	00000003                                ....

08030d98 <armBitRevIndexTable64>:
 8030d98:	00400008 00800010 00c00018 01000020     ..@......... ...
 8030da8:	01400028 01800030 01c00038 00880050     (.@.0...8...P...
 8030db8:	00c80058 01080060 01480068 01880070     X...`...h.H.p...
 8030dc8:	01c80078 00d00098 011000a0 015000a8     x.............P.
 8030dd8:	019000b0 01d000b8 011800e0 015800e8     ..............X.
 8030de8:	019800f0 01d800f8 01600128 01a00130     ........(.`.0...
 8030df8:	01e00138 01a80170 01e80178 01f001b8     8...p...x.......

08030e08 <twiddleCoef_256>:
 8030e08:	3f800000 00000000 3f7fec43 3cc90ab0     ...?....C..?...<
 8030e18:	3f7fb10f 3d48fb2f 3f7f4e6d 3d96a905     ...?/.H=mN.?...=
 8030e28:	3f7ec46d 3dc8bd36 3f7e1324 3dfab273     m.~?6..=$.~?s..=
 8030e38:	3f7d3aac 3e164083 3f7c3b28 3e2f10a2     .:}?.@.>(;|?../>
 8030e48:	3f7b14be 3e47c5c2 3f79c79d 3e605c13     ..{?..G>..y?.\`>
 8030e58:	3f7853f8 3e78cfcc 3f76ba07 3e888e93     .Sx?..x>..v?...>
 8030e68:	3f74fa0b 3e94a031 3f731447 3ea09ae5     ..t?1..>G.s?...>
 8030e78:	3f710908 3eac7cd4 3f6ed89e 3eb8442a     ..q?.|.>..n?*D.>
 8030e88:	3f6c835e 3ec3ef15 3f6a09a7 3ecf7bca     ^.l?...>..j?.{.>
 8030e98:	3f676bd8 3edae880 3f64aa59 3ee63375     .kg?...>Y.d?u3.>
 8030ea8:	3f61c598 3ef15aea 3f5ebe05 3efc5d27     ..a?.Z.>..^?'].>
 8030eb8:	3f5b941a 3f039c3d 3f584853 3f08f59b     ..[?=..?SHX?...?
 8030ec8:	3f54db31 3f0e39da 3f514d3d 3f13682a     1.T?.9.?=MQ?*h.?
 8030ed8:	3f4d9f02 3f187fc0 3f49d112 3f1d7fd1     ..M?...?..I?...?
 8030ee8:	3f45e403 3f226799 3f41d870 3f273656     ..E?.g"?p.A?V6'?
 8030ef8:	3f3daef9 3f2beb4a 3f396842 3f3085bb     ..=?J.+?Bh9?..0?
 8030f08:	3f3504f3 3f3504f3 3f3085bb 3f396842     ..5?..5?..0?Bh9?
 8030f18:	3f2beb4a 3f3daef9 3f273656 3f41d870     J.+?..=?V6'?p.A?
 8030f28:	3f226799 3f45e403 3f1d7fd1 3f49d112     .g"?..E?...?..I?
 8030f38:	3f187fc0 3f4d9f02 3f13682a 3f514d3d     ...?..M?*h.?=MQ?
 8030f48:	3f0e39da 3f54db31 3f08f59b 3f584853     .9.?1.T?...?SHX?
 8030f58:	3f039c3d 3f5b941a 3efc5d27 3f5ebe05     =..?..[?'].>..^?
 8030f68:	3ef15aea 3f61c598 3ee63375 3f64aa59     .Z.>..a?u3.>Y.d?
 8030f78:	3edae880 3f676bd8 3ecf7bca 3f6a09a7     ...>.kg?.{.>..j?
 8030f88:	3ec3ef15 3f6c835e 3eb8442a 3f6ed89e     ...>^.l?*D.>..n?
 8030f98:	3eac7cd4 3f710908 3ea09ae5 3f731447     .|.>..q?...>G.s?
 8030fa8:	3e94a031 3f74fa0b 3e888e93 3f76ba07     1..>..t?...>..v?
 8030fb8:	3e78cfcc 3f7853f8 3e605c13 3f79c79d     ..x>.Sx?.\`>..y?
 8030fc8:	3e47c5c2 3f7b14be 3e2f10a2 3f7c3b28     ..G>..{?../>(;|?
 8030fd8:	3e164083 3f7d3aac 3dfab273 3f7e1324     .@.>.:}?s..=$.~?
 8030fe8:	3dc8bd36 3f7ec46d 3d96a905 3f7f4e6d     6..=m.~?...=mN.?
 8030ff8:	3d48fb2f 3f7fb10f 3cc90ab0 3f7fec43     /.H=...?...<C..?
 8031008:	00000000 3f800000 bcc90ab0 3f7fec43     .......?....C..?
 8031018:	bd48fb2f 3f7fb10f bd96a905 3f7f4e6d     /.H....?....mN.?
 8031028:	bdc8bd36 3f7ec46d bdfab273 3f7e1324     6...m.~?s...$.~?
 8031038:	be164083 3f7d3aac be2f10a2 3f7c3b28     .@...:}?../.(;|?
 8031048:	be47c5c2 3f7b14be be605c13 3f79c79d     ..G...{?.\`...y?
 8031058:	be78cfcc 3f7853f8 be888e93 3f76ba07     ..x..Sx?......v?
 8031068:	be94a031 3f74fa0b bea09ae5 3f731447     1.....t?....G.s?
 8031078:	beac7cd4 3f710908 beb8442a 3f6ed89e     .|....q?*D....n?
 8031088:	bec3ef15 3f6c835e becf7bca 3f6a09a7     ....^.l?.{....j?
 8031098:	bedae880 3f676bd8 bee63375 3f64aa59     .....kg?u3..Y.d?
 80310a8:	bef15aea 3f61c598 befc5d27 3f5ebe05     .Z....a?']....^?
 80310b8:	bf039c3d 3f5b941a bf08f59b 3f584853     =.....[?....SHX?
 80310c8:	bf0e39da 3f54db31 bf13682a 3f514d3d     .9..1.T?*h..=MQ?
 80310d8:	bf187fc0 3f4d9f02 bf1d7fd1 3f49d112     ......M?......I?
 80310e8:	bf226799 3f45e403 bf273656 3f41d870     .g"...E?V6'.p.A?
 80310f8:	bf2beb4a 3f3daef9 bf3085bb 3f396842     J.+...=?..0.Bh9?
 8031108:	bf3504f3 3f3504f3 bf396842 3f3085bb     ..5...5?Bh9...0?
 8031118:	bf3daef9 3f2beb4a bf41d870 3f273656     ..=.J.+?p.A.V6'?
 8031128:	bf45e403 3f226799 bf49d112 3f1d7fd1     ..E..g"?..I....?
 8031138:	bf4d9f02 3f187fc0 bf514d3d 3f13682a     ..M....?=MQ.*h.?
 8031148:	bf54db31 3f0e39da bf584853 3f08f59b     1.T..9.?SHX....?
 8031158:	bf5b941a 3f039c3d bf5ebe05 3efc5d27     ..[.=..?..^.'].>
 8031168:	bf61c598 3ef15aea bf64aa59 3ee63375     ..a..Z.>Y.d.u3.>
 8031178:	bf676bd8 3edae880 bf6a09a7 3ecf7bca     .kg....>..j..{.>
 8031188:	bf6c835e 3ec3ef15 bf6ed89e 3eb8442a     ^.l....>..n.*D.>
 8031198:	bf710908 3eac7cd4 bf731447 3ea09ae5     ..q..|.>G.s....>
 80311a8:	bf74fa0b 3e94a031 bf76ba07 3e888e93     ..t.1..>..v....>
 80311b8:	bf7853f8 3e78cfcc bf79c79d 3e605c13     .Sx...x>..y..\`>
 80311c8:	bf7b14be 3e47c5c2 bf7c3b28 3e2f10a2     ..{...G>(;|.../>
 80311d8:	bf7d3aac 3e164083 bf7e1324 3dfab273     .:}..@.>$.~.s..=
 80311e8:	bf7ec46d 3dc8bd36 bf7f4e6d 3d96a905     m.~.6..=mN.....=
 80311f8:	bf7fb10f 3d48fb2f bf7fec43 3cc90ab0     ..../.H=C......<
 8031208:	bf800000 00000000 bf7fec43 bcc90ab0     ........C.......
 8031218:	bf7fb10f bd48fb2f bf7f4e6d bd96a905     ..../.H.mN......
 8031228:	bf7ec46d bdc8bd36 bf7e1324 bdfab273     m.~.6...$.~.s...
 8031238:	bf7d3aac be164083 bf7c3b28 be2f10a2     .:}..@..(;|.../.
 8031248:	bf7b14be be47c5c2 bf79c79d be605c13     ..{...G...y..\`.
 8031258:	bf7853f8 be78cfcc bf76ba07 be888e93     .Sx...x...v.....
 8031268:	bf74fa0b be94a031 bf731447 bea09ae5     ..t.1...G.s.....
 8031278:	bf710908 beac7cd4 bf6ed89e beb8442a     ..q..|....n.*D..
 8031288:	bf6c835e bec3ef15 bf6a09a7 becf7bca     ^.l.......j..{..
 8031298:	bf676bd8 bedae880 bf64aa59 bee63375     .kg.....Y.d.u3..
 80312a8:	bf61c598 bef15aea bf5ebe05 befc5d27     ..a..Z....^.']..
 80312b8:	bf5b941a bf039c3d bf584853 bf08f59b     ..[.=...SHX.....
 80312c8:	bf54db31 bf0e39da bf514d3d bf13682a     1.T..9..=MQ.*h..
 80312d8:	bf4d9f02 bf187fc0 bf49d112 bf1d7fd1     ..M.......I.....
 80312e8:	bf45e403 bf226799 bf41d870 bf273656     ..E..g".p.A.V6'.
 80312f8:	bf3daef9 bf2beb4a bf396842 bf3085bb     ..=.J.+.Bh9...0.
 8031308:	bf3504f3 bf3504f3 bf3085bb bf396842     ..5...5...0.Bh9.
 8031318:	bf2beb4a bf3daef9 bf273656 bf41d870     J.+...=.V6'.p.A.
 8031328:	bf226799 bf45e403 bf1d7fd1 bf49d112     .g"...E.......I.
 8031338:	bf187fc0 bf4d9f02 bf13682a bf514d3d     ......M.*h..=MQ.
 8031348:	bf0e39da bf54db31 bf08f59b bf584853     .9..1.T.....SHX.
 8031358:	bf039c3d bf5b941a befc5d27 bf5ebe05     =.....[.']....^.
 8031368:	bef15aea bf61c598 bee63375 bf64aa59     .Z....a.u3..Y.d.
 8031378:	bedae880 bf676bd8 becf7bca bf6a09a7     .....kg..{....j.
 8031388:	bec3ef15 bf6c835e beb8442a bf6ed89e     ....^.l.*D....n.
 8031398:	beac7cd4 bf710908 bea09ae5 bf731447     .|....q.....G.s.
 80313a8:	be94a031 bf74fa0b be888e93 bf76ba07     1.....t.......v.
 80313b8:	be78cfcc bf7853f8 be605c13 bf79c79d     ..x..Sx..\`...y.
 80313c8:	be47c5c2 bf7b14be be2f10a2 bf7c3b28     ..G...{.../.(;|.
 80313d8:	be164083 bf7d3aac bdfab273 bf7e1324     .@...:}.s...$.~.
 80313e8:	bdc8bd36 bf7ec46d bd96a905 bf7f4e6d     6...m.~.....mN..
 80313f8:	bd48fb2f bf7fb10f bcc90ab0 bf7fec43     /.H.........C...
 8031408:	80000000 bf800000 3cc90ab0 bf7fec43     ...........<C...
 8031418:	3d48fb2f bf7fb10f 3d96a905 bf7f4e6d     /.H=.......=mN..
 8031428:	3dc8bd36 bf7ec46d 3dfab273 bf7e1324     6..=m.~.s..=$.~.
 8031438:	3e164083 bf7d3aac 3e2f10a2 bf7c3b28     .@.>.:}.../>(;|.
 8031448:	3e47c5c2 bf7b14be 3e605c13 bf79c79d     ..G>..{..\`>..y.
 8031458:	3e78cfcc bf7853f8 3e888e93 bf76ba07     ..x>.Sx....>..v.
 8031468:	3e94a031 bf74fa0b 3ea09ae5 bf731447     1..>..t....>G.s.
 8031478:	3eac7cd4 bf710908 3eb8442a bf6ed89e     .|.>..q.*D.>..n.
 8031488:	3ec3ef15 bf6c835e 3ecf7bca bf6a09a7     ...>^.l..{.>..j.
 8031498:	3edae880 bf676bd8 3ee63375 bf64aa59     ...>.kg.u3.>Y.d.
 80314a8:	3ef15aea bf61c598 3efc5d27 bf5ebe05     .Z.>..a.'].>..^.
 80314b8:	3f039c3d bf5b941a 3f08f59b bf584853     =..?..[....?SHX.
 80314c8:	3f0e39da bf54db31 3f13682a bf514d3d     .9.?1.T.*h.?=MQ.
 80314d8:	3f187fc0 bf4d9f02 3f1d7fd1 bf49d112     ...?..M....?..I.
 80314e8:	3f226799 bf45e403 3f273656 bf41d870     .g"?..E.V6'?p.A.
 80314f8:	3f2beb4a bf3daef9 3f3085bb bf396842     J.+?..=...0?Bh9.
 8031508:	3f3504f3 bf3504f3 3f396842 bf3085bb     ..5?..5.Bh9?..0.
 8031518:	3f3daef9 bf2beb4a 3f41d870 bf273656     ..=?J.+.p.A?V6'.
 8031528:	3f45e403 bf226799 3f49d112 bf1d7fd1     ..E?.g"...I?....
 8031538:	3f4d9f02 bf187fc0 3f514d3d bf13682a     ..M?....=MQ?*h..
 8031548:	3f54db31 bf0e39da 3f584853 bf08f59b     1.T?.9..SHX?....
 8031558:	3f5b941a bf039c3d 3f5ebe05 befc5d27     ..[?=.....^?']..
 8031568:	3f61c598 bef15aea 3f64aa59 bee63375     ..a?.Z..Y.d?u3..
 8031578:	3f676bd8 bedae880 3f6a09a7 becf7bca     .kg?......j?.{..
 8031588:	3f6c835e bec3ef15 3f6ed89e beb8442a     ^.l?......n?*D..
 8031598:	3f710908 beac7cd4 3f731447 bea09ae5     ..q?.|..G.s?....
 80315a8:	3f74fa0b be94a031 3f76ba07 be888e93     ..t?1.....v?....
 80315b8:	3f7853f8 be78cfcc 3f79c79d be605c13     .Sx?..x...y?.\`.
 80315c8:	3f7b14be be47c5c2 3f7c3b28 be2f10a2     ..{?..G.(;|?../.
 80315d8:	3f7d3aac be164083 3f7e1324 bdfab273     .:}?.@..$.~?s...
 80315e8:	3f7ec46d bdc8bd36 3f7f4e6d bd96a905     m.~?6...mN.?....
 80315f8:	3f7fb10f bd48fb2f 3f7fec43 bcc90ab0     ...?/.H.C..?....

08031608 <twiddleCoef_64>:
 8031608:	3f800000 00000000 3f7ec46d 3dc8bd36     ...?....m.~?6..=
 8031618:	3f7b14be 3e47c5c2 3f74fa0b 3e94a031     ..{?..G>..t?1..>
 8031628:	3f6c835e 3ec3ef15 3f61c598 3ef15aea     ^.l?...>..a?.Z.>
 8031638:	3f54db31 3f0e39da 3f45e403 3f226799     1.T?.9.?..E?.g"?
 8031648:	3f3504f3 3f3504f3 3f226799 3f45e403     ..5?..5?.g"?..E?
 8031658:	3f0e39da 3f54db31 3ef15aea 3f61c598     .9.?1.T?.Z.>..a?
 8031668:	3ec3ef15 3f6c835e 3e94a031 3f74fa0b     ...>^.l?1..>..t?
 8031678:	3e47c5c2 3f7b14be 3dc8bd36 3f7ec46d     ..G>..{?6..=m.~?
 8031688:	00000000 3f800000 bdc8bd36 3f7ec46d     .......?6...m.~?
 8031698:	be47c5c2 3f7b14be be94a031 3f74fa0b     ..G...{?1.....t?
 80316a8:	bec3ef15 3f6c835e bef15aea 3f61c598     ....^.l?.Z....a?
 80316b8:	bf0e39da 3f54db31 bf226799 3f45e403     .9..1.T?.g"...E?
 80316c8:	bf3504f3 3f3504f3 bf45e403 3f226799     ..5...5?..E..g"?
 80316d8:	bf54db31 3f0e39da bf61c598 3ef15aea     1.T..9.?..a..Z.>
 80316e8:	bf6c835e 3ec3ef15 bf74fa0b 3e94a031     ^.l....>..t.1..>
 80316f8:	bf7b14be 3e47c5c2 bf7ec46d 3dc8bd36     ..{...G>m.~.6..=
 8031708:	bf800000 00000000 bf7ec46d bdc8bd36     ........m.~.6...
 8031718:	bf7b14be be47c5c2 bf74fa0b be94a031     ..{...G...t.1...
 8031728:	bf6c835e bec3ef15 bf61c598 bef15aea     ^.l.......a..Z..
 8031738:	bf54db31 bf0e39da bf45e403 bf226799     1.T..9....E..g".
 8031748:	bf3504f3 bf3504f3 bf226799 bf45e403     ..5...5..g"...E.
 8031758:	bf0e39da bf54db31 bef15aea bf61c598     .9..1.T..Z....a.
 8031768:	bec3ef15 bf6c835e be94a031 bf74fa0b     ....^.l.1.....t.
 8031778:	be47c5c2 bf7b14be bdc8bd36 bf7ec46d     ..G...{.6...m.~.
 8031788:	80000000 bf800000 3dc8bd36 bf7ec46d     ........6..=m.~.
 8031798:	3e47c5c2 bf7b14be 3e94a031 bf74fa0b     ..G>..{.1..>..t.
 80317a8:	3ec3ef15 bf6c835e 3ef15aea bf61c598     ...>^.l..Z.>..a.
 80317b8:	3f0e39da bf54db31 3f226799 bf45e403     .9.?1.T..g"?..E.
 80317c8:	3f3504f3 bf3504f3 3f45e403 bf226799     ..5?..5...E?.g".
 80317d8:	3f54db31 bf0e39da 3f61c598 bef15aea     1.T?.9....a?.Z..
 80317e8:	3f6c835e bec3ef15 3f74fa0b be94a031     ^.l?......t?1...
 80317f8:	3f7b14be be47c5c2 3f7ec46d bdc8bd36     ..{?..G.m.~?6...

08031808 <armBitRevIndexTable256>:
 8031808:	02000008 04000010 06000018 00400020     ............ .@.
 8031818:	02400028 04400030 06400038 00800040     (.@.0.@.8.@.@...
 8031828:	02800048 04800050 06800058 00c00060     H...P...X...`...
 8031838:	02c00068 04c00070 06c00078 01000080     h...p...x.......
 8031848:	03000088 05000090 07000098 014000a0     ..............@.
 8031858:	034000a8 054000b0 074000b8 018000c0     ..@...@...@.....
 8031868:	038000c8 058000d0 078000d8 01c000e0     ................
 8031878:	03c000e8 05c000f0 07c000f8 02000100     ................
 8031888:	02080108 04080110 06080118 02800120     ............ ...
 8031898:	02480128 04480130 06480138 03000140     (.H.0.H.8.H.@...
 80318a8:	02880148 04880150 06880158 03800160     H...P...X...`...
 80318b8:	02c80168 04c80170 06c80178 02080180     h...p...x.......
 80318c8:	03080188 05080190 07080198 028801a0     ................
 80318d8:	034801a8 054801b0 074801b8 030801c0     ..H...H...H.....
 80318e8:	038801c8 058801d0 078801d8 038801e0     ................
 80318f8:	03c801e8 05c801f0 07c801f8 02100208     ................
 8031908:	04000200 04100210 06100218 04800220     ............ ...
 8031918:	02500228 04500230 06500238 05000240     (.P.0.P.8.P.@...
 8031928:	02900248 04900250 06900258 05800260     H...P...X...`...
 8031938:	02d00268 04d00270 06d00278 04080280     h...p...x.......
 8031948:	03100288 05100290 07100298 048802a0     ................
 8031958:	035002a8 055002b0 075002b8 050802c0     ..P...P...P.....
 8031968:	039002c8 059002d0 079002d8 058802e0     ................
 8031978:	03d002e8 05d002f0 07d002f8 06000300     ................
 8031988:	06100308 04180310 06180318 06800320     ............ ...
 8031998:	06900328 04580330 06580338 07000340     (...0.X.8.X.@...
 80319a8:	07100348 04980350 06980358 07800360     H...P...X...`...
 80319b8:	07900368 04d80370 06d80378 06080380     h...p...x.......
 80319c8:	06180388 05180390 07180398 068803a0     ................
 80319d8:	069803a8 055803b0 075803b8 070803c0     ......X...X.....
 80319e8:	071803c8 059803d0 079803d8 078803e0     ................
 80319f8:	079803e8 05d803f0 07d803f8 04800408     ................
 8031a08:	04200410 06200418 05800428 04600430     .. ... .(...0.`.
 8031a18:	06600438 06000440 04880448 04a00450     8.`.@...H...P...
 8031a28:	06a00458 06100460 05880468 04e00470     X...`...h...p...
 8031a38:	06e00478 06800488 05200490 07200498     x......... ... .
 8031a48:	060804a0 078004a8 056004b0 076004b8     ..........`...`.
 8031a58:	062004c0 068804c8 05a004d0 07a004d8     .. .............
 8031a68:	061804e0 078804e8 05e004f0 07e004f8     ................
 8031a78:	05200508 05800510 06280518 05900528     .. .......(.(...
 8031a88:	05880530 06680538 07000540 07200548     0...8.h.@...H. .
 8031a98:	07800550 06a80558 07080560 05980568     P...X...`...h...
 8031aa8:	07880570 06e80578 06900588 07280598     p...x.........(.
 8031ab8:	062805a0 079005a8 072805b0 076805b8     ..(.......(...h.
 8031ac8:	071005c0 069805c8 079005d0 07a805d8     ................
 8031ad8:	071805e0 079805e8 079805f0 07e805f8     ................
 8031ae8:	06300618 06700638 07000640 07800648     ..0.8.p.@...H...
 8031af8:	07080650 06b00658 07100660 07900668     P...X...`...h...
 8031b08:	07180670 06f00678 06a00688 07300698     p...x.........0.
 8031b18:	07a006a8 078806b0 077006b8 072006c0     ..........p... .
 8031b28:	07a006c8 072806d0 07b006d8 073006e0     ......(.......0.
 8031b38:	07a806e8 079806f0 07f006f8 07500748     ............H.P.
 8031b48:	07980738 07600750 07700758 07c00760     8...P.`.X.p.`...
 8031b58:	07d00768 07f00778 07e00770 07f007b8     h...x...p.......
 8031b68:	07b007a8 07f007d8 07e007c8 07f007e8     ................

08031b78 <arm_cfft_sR_f32_len64>:
 8031b78:	00000040 08031608 08030d98 00000038     @...........8...

08031b88 <arm_cfft_sR_f32_len256>:
 8031b88:	00000100 08030e08 08031808 000001b8     ................
 8031b98:	01010315 00010000 00000000 00010000     ................
 8031ba8:	01010102                                ....

08031bac <CCU4_SLICE_CONFIG_ADC_TRIG_event1_config>:
 8031bac:	00010203                                ....

08031bb0 <CCU4_SLICE_CONFIG_ADC_TRIG_event2_config>:
 8031bb0:	00000000                                ....

08031bb4 <CCU4_SLICE_CONFIG_ADC_TRIG>:
 8031bb4:	0802897d 1ffe89dc 48004400 00000003     }........D.H....

08031bc4 <CCU4_SLICE_CONFIG_ADC_TRIG_compare_config>:
 8031bc4:	00000004 000000f0                       ........

08031bcc <CCU4_SLICE_CONFIG_ADC_TRIG_event0_config>:
 8031bcc:	00010103                                ....

08031bd0 <group_ptrs>:
 8031bd0:	40004400 40004800 40004c00 40005000     .D.@.H.@.L.@.P.@

08031be0 <ADC_MEASUREMENT_ADV_G4_queue_handle>:
	...
 8031bf4:	08031d2c 00010001                       ,.......

08031bfc <ADC_MEASUREMENT_ADV_G3_IF2_I_res_config>:
 8031bfc:	80000000                                ....

08031c00 <ADC_MEASUREMENT_ADV_G2_queue_handle>:
	...
 8031c14:	08031c2c 00000001                       ,.......

08031c1c <ADC_MEASUREMENT_ADV_G4_IF2_Q_ch_config>:
 8031c1c:	00240401 00000000 00000000 0000ff01     ..$.............

08031c2c <ADC_MEASUREMENT_ADV_G2_queue_config>:
 8031c2c:	0000000c 00004500 00000004              .....E......

08031c38 <ADC_MEASUREMENT_SCAN_BGT24_ANA_res_config>:
 8031c38:	00000000                                ....

08031c3c <ADC_MEASUREMENT_ADV_G1_IF1_I_ch_config>:
 8031c3c:	002f0000 00000000 00000000 0000ff01     ../.............

08031c4c <ADC_MEASUREMENT_SCAN>:
 8031c4c:	1ffe8b78 00000000 00000000 08031db8     x...............
 8031c5c:	1ffe8b80 01030001 00000101              ............

08031c68 <ADC_MEASUREMENT_ADV_G3_IF2_I_handle>:
 8031c68:	08031d18 08031bfc 00000302              ............

08031c74 <ADC_MEASUREMENT_ADV_G3_IF2_I_queue_entry_0>:
 8031c74:	000000a3                                ....

08031c78 <ADC_MEASUREMENT_SCAN_BGT24_ANA_ch_config>:
 8031c78:	00290000 00000000 00000000 0000ff01     ..).............

08031c88 <ADC_MEASUREMENT_ADV_G2_IF1_Q_queue_entry_0>:
 8031c88:	000000a6                                ....

08031c8c <ADC_MEASUREMENT_ADV_G2_IF1_Q_ch_config>:
 8031c8c:	00230400 00000000 00000000 0000ff01     ..#.............

08031c9c <ADC_MEASUREMENT_ADV_G1_queue_config>:
 8031c9c:	0000000c 00004500 00000004              .....E......

08031ca8 <ADC_MEASUREMENT_ADV_G1_queue_handle>:
	...
 8031cbc:	08031c9c 00000001                       ........

08031cc4 <ADC_MEASUREMENT_SCAN_BGT24_ANA_handle>:
 8031cc4:	08031c78 08031c38 00000503              x...8.......

08031cd0 <ADC_MEASUREMENT_ADV_G1_IF1_I_handle>:
 8031cd0:	08031c3c 08031d28 00000400              <...(.......

08031cdc <ADC_MEASUREMENT_ADV_G3_queue_handle>:
	...
 8031cf0:	08031cf8 00000001                       ........

08031cf8 <ADC_MEASUREMENT_ADV_G3_queue_config>:
 8031cf8:	0000000c 00004500 00000004              .....E......

08031d04 <ADC_MEASUREMENT_ADV_G4_IF2_Q_handle>:
 8031d04:	08031c1c 08031db4 00000003              ............

08031d10 <ADC_MEASUREMENT_ADV_G4_IF2_Q_queue_entry_0>:
 8031d10:	000000a0                                ....

08031d14 <ADC_MEASUREMENT_ADV_G2_IF1_Q_res_config>:
 8031d14:	80000000                                ....

08031d18 <ADC_MEASUREMENT_ADV_G3_IF2_I_ch_config>:
 8031d18:	00200400 00000000 00000000 0000ff01     .. .............

08031d28 <ADC_MEASUREMENT_ADV_G1_IF1_I_res_config>:
 8031d28:	80000000                                ....

08031d2c <ADC_MEASUREMENT_ADV_G4_queue_config>:
 8031d2c:	0000000c 00004500 00000004              .....E......

08031d38 <ADC_MEASUREMENT_ADV_G1>:
 8031d38:	1ffe8b5c 1ffe8b74 08028f09 08031ca8     \...t...........
 8031d48:	1ffe8b64 01000e03 00010101              d...........

08031d54 <ADC_MEASUREMENT_ADV_G2>:
 8031d54:	1ffe8b60 1ffe8b6c 08028f19 08031c00     `...l...........
 8031d64:	1ffe8b65 01010003 00010101              e...........

08031d70 <ADC_MEASUREMENT_ADV_G3>:
 8031d70:	1ffe8b58 1ffe8b70 08028f29 08031cdc     X...p...).......
 8031d80:	1ffe8b66 01020003 00010101              f...........

08031d8c <ADC_MEASUREMENT_ADV_G4>:
 8031d8c:	1ffe8b7c 1ffe8b68 08028f39 08031be0     |...h...9.......
 8031d9c:	1ffe8b67 01030003 00010101              g...........

08031da8 <ADC_MEASUREMENT_ADV_G2_IF1_Q_handle>:
 8031da8:	08031c8c 08031d14 00000601              ............

08031db4 <ADC_MEASUREMENT_ADV_G4_IF2_Q_res_config>:
 8031db4:	80000000                                ....

08031db8 <ADC_MEASUREMENT_SCAN_scan_handle>:
	...
 8031dcc:	08031de0 00000001 00000020 00000000     ........ .......

08031ddc <ADC_MEASUREMENT_ADV_G1_IF1_I_queue_entry_0>:
 8031ddc:	000000a4                                ....

08031de0 <ADC_MEASUREMENT_SCAN_scan_config>:
	...
 8031de8:	00000020                                 ...

08031dec <CSWTCH.9>:
 8031dec:	30201000 70605040 00000000              .. 0@P`p....

08031df8 <atanlo>:
 8031df8:	222f65e2 3c7a2b7f 33145c07 3c81a626     .e/".+z<.\.3&..<
 8031e08:	7af0cbbd 3c700788 33145c07 3c91a626     ...z..p<.\.3&..<

08031e18 <atanhi>:
 8031e18:	0561bb4f 3fddac67 54442d18 3fe921fb     O.a.g..?.-DT.!.?
 8031e28:	d281f69b 3fef730b 54442d18 3ff921fb     .....s.?.-DT.!.?
 8031e38:	6e697361 00000000 646f6d66 00000066     asin....fmodf...
 8031e48:	66676f6c 00000000 74727173 00000066     logf....sqrtf...

08031e58 <Zero>:
 8031e58:	00000000 80000000 4e490043 6e690046     ........C.INF.in
 8031e68:	414e0066 616e004e 0030006e 69666e49     f.NAN.nan.0.Infi
 8031e78:	7974696e 4e614e00 534f5000 2e005849     nity.NaN.POSIX..
	...

08031e90 <__mprec_tens>:
 8031e90:	00000000 3ff00000 00000000 40240000     .......?......$@
 8031ea0:	00000000 40590000 00000000 408f4000     ......Y@.....@.@
 8031eb0:	00000000 40c38800 00000000 40f86a00     .......@.....j.@
 8031ec0:	00000000 412e8480 00000000 416312d0     .......A......cA
 8031ed0:	00000000 4197d784 00000000 41cdcd65     .......A....e..A
 8031ee0:	20000000 4202a05f e8000000 42374876     ... _..B....vH7B
 8031ef0:	a2000000 426d1a94 e5400000 42a2309c     ......mB..@..0.B
 8031f00:	1e900000 42d6bcc4 26340000 430c6bf5     .......B..4&.k.C
 8031f10:	37e08000 4341c379 85d8a000 43763457     ...7y.AC....W4vC
 8031f20:	674ec800 43abc16d 60913d00 43e158e4     ..Ngm..C.=.`.X.C
 8031f30:	78b58c40 4415af1d d6e2ef50 444b1ae4     @..x...DP.....KD
 8031f40:	064dd592 4480f0cf c7e14af6 44b52d02     ..M....D.J...-.D
 8031f50:	79d99db4 44ea7843                       ...yCx.D

08031f58 <__mprec_bigtens>:
 8031f58:	37e08000 4341c379 b5056e17 4693b8b5     ...7y.AC.n.....F
 8031f68:	e93ff9f5 4d384f03 f9301d32 5a827748     ..?..O8M2.0.Hw.Z
 8031f78:	7f73bf3c 75154fdd                       <.s..O.u

08031f80 <p05.5277>:
 8031f80:	00000005 00000019 0000007d              ........}...
