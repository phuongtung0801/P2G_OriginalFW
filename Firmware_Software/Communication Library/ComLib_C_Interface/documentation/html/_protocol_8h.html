<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Radar Host Communication library: include/Protocol.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Radar Host Communication library
   &#160;<span id="projectnumber">1.2.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_protocol_8h.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Protocol.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file defines the basic API to access Infineon sensor devices.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
</div>
<p><a href="_protocol_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_firmware___information__t.html">Firmware_Information_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure contains information about the firmware.  <a href="struct_firmware___information__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_endpoint___info__t.html">Endpoint_Info_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure contains information about an endpoint.  <a href="struct_endpoint___info__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga7a014a8c6adf9dd0a270759b839186ac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___status_codes.html#ga7a014a8c6adf9dd0a270759b839186ac">PROTOCOL_STATUS_OK</a>&#160;&#160;&#160;0x0000</td></tr>
<tr class="separator:ga7a014a8c6adf9dd0a270759b839186ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61ed06cf2e830c6fa5408c44ceb86d23"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___status_codes.html#ga61ed06cf2e830c6fa5408c44ceb86d23">PROTOCOL_STATUS_DEVICE_TIMEOUT</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="separator:ga61ed06cf2e830c6fa5408c44ceb86d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37a3317a0beab189eca46f19470bf6c7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___status_codes.html#ga37a3317a0beab189eca46f19470bf6c7">PROTOCOL_STATUS_DEVICE_BAD_MESSAGE_START</a>&#160;&#160;&#160;0x0002</td></tr>
<tr class="separator:ga37a3317a0beab189eca46f19470bf6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a308b297c2e0d7644bd9b91d9cb76c3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___status_codes.html#ga8a308b297c2e0d7644bd9b91d9cb76c3">PROTOCOL_STATUS_DEVICE_BAD_ENDPOINT_ID</a>&#160;&#160;&#160;0x0003</td></tr>
<tr class="separator:ga8a308b297c2e0d7644bd9b91d9cb76c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7edd7402b860aad74ad5c7e7ea2edaa7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___status_codes.html#ga7edd7402b860aad74ad5c7e7ea2edaa7">PROTOCOL_STATUS_DEVICE_NO_PAYLOAD</a>&#160;&#160;&#160;0x0005</td></tr>
<tr class="separator:ga7edd7402b860aad74ad5c7e7ea2edaa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae5573387162ed7f77ebcba0ff55bf61"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___status_codes.html#gaae5573387162ed7f77ebcba0ff55bf61">PROTOCOL_STATUS_DEVICE_OUT_OF_MEMORY</a>&#160;&#160;&#160;0x0006</td></tr>
<tr class="separator:gaae5573387162ed7f77ebcba0ff55bf61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4d9aa308080f7c6e3a9fda82dcfd234"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___status_codes.html#gab4d9aa308080f7c6e3a9fda82dcfd234">PROTOCOL_STATUS_DEVICE_BAD_PAYLOAD_END</a>&#160;&#160;&#160;0x0007</td></tr>
<tr class="separator:gab4d9aa308080f7c6e3a9fda82dcfd234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a05139d69a35167089a066d7b2aaa8b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___status_codes.html#ga3a05139d69a35167089a066d7b2aaa8b">PROTOCOL_STATUS_DEVICE_BAD_COMMAND</a>&#160;&#160;&#160;0xFFFF</td></tr>
<tr class="separator:ga3a05139d69a35167089a066d7b2aaa8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5fbede7dbbd5fa270e7f3b6c8f55b81"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___error_codes.html#gab5fbede7dbbd5fa270e7f3b6c8f55b81">PROTOCOL_ERROR_INVALID_HANDLE</a>&#160;&#160;&#160;-1</td></tr>
<tr class="separator:gab5fbede7dbbd5fa270e7f3b6c8f55b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66f76f0fbe43c5bf3b3893549c947539"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___error_codes.html#ga66f76f0fbe43c5bf3b3893549c947539">PROTOCOL_ERROR_COULD_NOT_OPEN_COM_PORT</a>&#160;&#160;&#160;-100</td></tr>
<tr class="separator:ga66f76f0fbe43c5bf3b3893549c947539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc7667d073d67ae05ae52679c01388d1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___error_codes.html#gadc7667d073d67ae05ae52679c01388d1">PROTOCOL_ERROR_DEVICE_NOT_COMPATIBLE</a>&#160;&#160;&#160;-101</td></tr>
<tr class="separator:gadc7667d073d67ae05ae52679c01388d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1f03b5f4ec37e6e2b8262d9c2086191"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___error_codes.html#gaa1f03b5f4ec37e6e2b8262d9c2086191">PROTOCOL_ERROR_RECEIVED_NO_MESSAGE</a>&#160;&#160;&#160;-1000</td></tr>
<tr class="separator:gaa1f03b5f4ec37e6e2b8262d9c2086191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad85d6af7bbfa6f612683e2bdbac2004f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___error_codes.html#gad85d6af7bbfa6f612683e2bdbac2004f">PROTOCOL_ERROR_RECEIVED_TIMEOUT</a>&#160;&#160;&#160;-1001</td></tr>
<tr class="separator:gad85d6af7bbfa6f612683e2bdbac2004f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa5a21669cb5bdfcac761d159aca37a8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___error_codes.html#gaaa5a21669cb5bdfcac761d159aca37a8">PROTOCOL_ERROR_RECEIVED_BAD_MESSAGE_START</a>&#160;&#160;&#160;-1002</td></tr>
<tr class="separator:gaaa5a21669cb5bdfcac761d159aca37a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9928b31b5efe77609dff1fe94d41fb1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___error_codes.html#gad9928b31b5efe77609dff1fe94d41fb1">PROTOCOL_ERROR_RECEIVED_BAD_MESSAGE_END</a>&#160;&#160;&#160;-1003</td></tr>
<tr class="separator:gad9928b31b5efe77609dff1fe94d41fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6087bbd1000c4820dee189a9dd5fb826"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___error_codes.html#ga6087bbd1000c4820dee189a9dd5fb826">PROTOCOL_ERROR_ENDPOINT_DOES_NOT_EXIST</a>&#160;&#160;&#160;-2000</td></tr>
<tr class="separator:ga6087bbd1000c4820dee189a9dd5fb826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b6292ac131cd9f68fed8518d838be3f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___error_codes.html#ga3b6292ac131cd9f68fed8518d838be3f">PROTOCOL_ERROR_ENDPOINT_WRONG_TYPE</a>&#160;&#160;&#160;-2001</td></tr>
<tr class="separator:ga3b6292ac131cd9f68fed8518d838be3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65aec3d39a88a2aa98ff0fc58a95daf3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___error_codes.html#ga65aec3d39a88a2aa98ff0fc58a95daf3">PROTOCOL_ERROR_ENDPOINT_VERSION_TOO_OLD</a>&#160;&#160;&#160;-2002</td></tr>
<tr class="separator:ga65aec3d39a88a2aa98ff0fc58a95daf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2a68031910a78b0621d66ef118e961f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___error_codes.html#gaf2a68031910a78b0621d66ef118e961f">PROTOCOL_ERROR_ENDPOINT_VERSION_TOO_NEW</a>&#160;&#160;&#160;-2003</td></tr>
<tr class="separator:gaf2a68031910a78b0621d66ef118e961f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9f43c7e3d4ce0fd097a22574238b2f7f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_protocol_8h.html#a9f43c7e3d4ce0fd097a22574238b2f7f">protocol_connect</a> (const char *port_name)</td></tr>
<tr class="memdesc:a9f43c7e3d4ce0fd097a22574238b2f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function establishes a connection to a device through a COM port.  <a href="#a9f43c7e3d4ce0fd097a22574238b2f7f">More...</a><br /></td></tr>
<tr class="separator:a9f43c7e3d4ce0fd097a22574238b2f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043e4544ef7d3a9ba12d186f7f7e7e60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_protocol_8h.html#a043e4544ef7d3a9ba12d186f7f7e7e60">protocol_disconnect</a> (int32_t protocol_handle)</td></tr>
<tr class="memdesc:a043e4544ef7d3a9ba12d186f7f7e7e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function closes an open connection.  <a href="#a043e4544ef7d3a9ba12d186f7f7e7e60">More...</a><br /></td></tr>
<tr class="separator:a043e4544ef7d3a9ba12d186f7f7e7e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b74eaf568e59087311055790131c1c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_protocol_8h.html#ad0b74eaf568e59087311055790131c1c">protocol_get_num_endpoints</a> (int32_t protocol_handle)</td></tr>
<tr class="memdesc:ad0b74eaf568e59087311055790131c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the number of endpoints in the connected device.  <a href="#ad0b74eaf568e59087311055790131c1c">More...</a><br /></td></tr>
<tr class="separator:ad0b74eaf568e59087311055790131c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99477ad87d28270f1b3c437d2d01e36b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_protocol_8h.html#a99477ad87d28270f1b3c437d2d01e36b">protocol_get_firmware_information</a> (int32_t protocol_handle, <a class="el" href="struct_firmware___information__t.html">Firmware_Information_t</a> *information)</td></tr>
<tr class="memdesc:a99477ad87d28270f1b3c437d2d01e36b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the information about the firmware of the connected device.  <a href="#a99477ad87d28270f1b3c437d2d01e36b">More...</a><br /></td></tr>
<tr class="separator:a99477ad87d28270f1b3c437d2d01e36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfafe66cebdbe072d420765f2882fd88"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_protocol_8h.html#acfafe66cebdbe072d420765f2882fd88">protocol_do_firmware_reset</a> (int32_t protocol_handle)</td></tr>
<tr class="memdesc:acfafe66cebdbe072d420765f2882fd88"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function triggers a firmware reset of the connected device.  <a href="#acfafe66cebdbe072d420765f2882fd88">More...</a><br /></td></tr>
<tr class="separator:acfafe66cebdbe072d420765f2882fd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60bd2bbdb16b2a77bd434ede0fc74a8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_protocol_8h.html#ae60bd2bbdb16b2a77bd434ede0fc74a8">protocol_get_endpoint_info</a> (int32_t protocol_handle, uint8_t endpoint, <a class="el" href="struct_endpoint___info__t.html">Endpoint_Info_t</a> *endpoint_info)</td></tr>
<tr class="memdesc:ae60bd2bbdb16b2a77bd434ede0fc74a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns information about the requested endpoint.  <a href="#ae60bd2bbdb16b2a77bd434ede0fc74a8">More...</a><br /></td></tr>
<tr class="separator:ae60bd2bbdb16b2a77bd434ede0fc74a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac196cc8c51a8d3cbd8da26b24547868d"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_protocol_8h.html#ac196cc8c51a8d3cbd8da26b24547868d">protocol_get_status_code_description</a> (int32_t protocol_handle, int32_t status_code)</td></tr>
<tr class="memdesc:ac196cc8c51a8d3cbd8da26b24547868d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a human readable description of a status or error code.  <a href="#ac196cc8c51a8d3cbd8da26b24547868d">More...</a><br /></td></tr>
<tr class="separator:ac196cc8c51a8d3cbd8da26b24547868d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file defines the basic API to access Infineon sensor devices. </p>
<p>The communication protocol is a generic protocol to exchange messages with microcontroller-based devices over a generic byte stream connection (typically a virtual serial port over USB). The communication is always initiated by the host, while the connected microcontroller device responds to messages received from the host.</p>
<p>The protocol defines two types of messages, payload messages and status messages. A payload message contains a block of data with arbitrary size and meaning. A status message contains a 16 bit status code. Messages from the host to the device are always payload messages. Whenever the device receives a payload message from the host, it responds with one (and only one) status message. The device may also send an arbitrary number of additional payload messages preceding that status message. Once the device has sent the status message, it won't send any more messages until it receives a new message from the host.</p>
<p>Each message from the host to the device is addressed to a certain logical endpoint and each message from the device to the host is sent from a logical endpoint. The number of logical endpoints is defined by the device. Endpoints are continuously enumerated starting with 1. At least one logical endpoint is always present. Endpoints are used to define functional groups in the device.</p>
<p>Each logical endpoint is of a defined type, which defines the meaning of the message payload exchanged with that endpoint. Additionally each endpoint has a version number that allows to distinguish between slight modifications of the endpoints set of known messages. The host can query type and version of the endpoints present in the device.</p>
<p>The API functions defined in this header file just allow basic access to the device, such as connecting, disconnecting and query endpoint information. The module <a class="el" href="_protocol_8c.html">Protocol.c</a> further also implements functions for message exchange, but these functions are not meant to be used directly. Instead each type of endpoint should have a separate module that implements function to exchange messages tailored to the functionality of that endpoint. Those endpoint implementations may use the communication functions implemented in the module <a class="el" href="_protocol_8c.html" title="This file implements the access Infineon sensor devices.">Protocol.c</a> and declared in the header Protocol_internal.h. </p>

<p class="definition">Definition in file <a class="el" href="_protocol_8h_source.html">Protocol.h</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a9f43c7e3d4ce0fd097a22574238b2f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f43c7e3d4ce0fd097a22574238b2f7f">&#9670;&nbsp;</a></span>protocol_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t protocol_connect </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>port_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function establishes a connection to a device through a COM port. </p>
<p>This function tries to open the specified COM port. The COM port name must identify an existing COM port and is platform and machine specific. It is recommended to call <a class="el" href="_c_o_m_port_8h.html#a5f388e36295420d01771c7293800e37b">com_get_port_list</a> to get a list of available COM ports. Port names not in the returned list won't be accepted.</p>
<p>If the specified COM could be opened, information about the endpoints present in the connected device is queried. If endpoint information could not be retrieved properly, the device is considered to not be compatible with the communication protocol and the connection is closed again.</p>
<p>If a connection can be established, the function returns a handle that must be passed to all following function calls to identify the device. When the connection is not needed any more, it should be closed by calling <a class="el" href="_protocol_8c.html#a043e4544ef7d3a9ba12d186f7f7e7e60">protocol_disconnect</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port_name</td><td>A zero-terminated string containing the device name of the COM port to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If a connection could be established the function returns a handle that is positive or 0. If the connection could not be established, a negative error code is returned. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_protocol_8c_source.html#l00476">476</a> of file <a class="el" href="_protocol_8c_source.html">Protocol.c</a>.</p>

</div>
</div>
<a id="a043e4544ef7d3a9ba12d186f7f7e7e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043e4544ef7d3a9ba12d186f7f7e7e60">&#9670;&nbsp;</a></span>protocol_disconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void protocol_disconnect </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>protocol_handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function closes an open connection. </p>
<p>If a valid handle to an open connection is provided, the according connection is closed and the handle is marked as invalid. If the handle is invalid, nothing will happen. Either way the handle must not be used any more after calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">protocol_handle</td><td>A handle to an open connection. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_protocol_8c_source.html#l00626">626</a> of file <a class="el" href="_protocol_8c_source.html">Protocol.c</a>.</p>

</div>
</div>
<a id="acfafe66cebdbe072d420765f2882fd88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfafe66cebdbe072d420765f2882fd88">&#9670;&nbsp;</a></span>protocol_do_firmware_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t protocol_do_firmware_reset </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>protocol_handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function triggers a firmware reset of the connected device. </p>
<p>This function sends a message to the connected device to trigger a firmware ware reset and waits for the answer.</p>
<p>After calling this function, <a class="el" href="_protocol_8c.html#a043e4544ef7d3a9ba12d186f7f7e7e60">protocol_disconnect</a> should be called immediately to ensure a proper reboot of the connected device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">protocol_handle</td><td>A handle to an open connection returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the provided handle is valid and the reset feature is supported by the connected device, 0 will be returned. Otherwise an error code is returned. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_protocol_8c_source.html#l00749">749</a> of file <a class="el" href="_protocol_8c_source.html">Protocol.c</a>.</p>

</div>
</div>
<a id="ae60bd2bbdb16b2a77bd434ede0fc74a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae60bd2bbdb16b2a77bd434ede0fc74a8">&#9670;&nbsp;</a></span>protocol_get_endpoint_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t protocol_get_endpoint_info </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>protocol_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_endpoint___info__t.html">Endpoint_Info_t</a> *&#160;</td>
          <td class="paramname"><em>endpoint_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns information about the requested endpoint. </p>
<p>When the connection is established (see <a class="el" href="_protocol_8c.html#a9f43c7e3d4ce0fd097a22574238b2f7f">protocol_connect</a>), information about the endpoints in the connected device is retrieved. This function returns information about the requested endpoints that was received when the connection was established. The endpoint information is not queried from the device again.</p>
<p>The caller must provide a valid pointer to a structure of type <a class="el" href="struct_endpoint___info__t.html">Endpoint_Info_t</a>. That structure may be uninitialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">protocol_handle</td><td>A handle to an open connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endpoint</td><td>The number of the requested endpoint. (First endpoint is 1, not 0!) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">endpoint_info</td><td>A pointer to the structure, where the endpoint information will be written to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the provided handle is valid, and the requested endpoint exists, 0 will be returned and endpoint information will be written to endpoint_info. Otherwise a negative error code is returned and endpoint_info will not be modified. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_protocol_8c_source.html#l00794">794</a> of file <a class="el" href="_protocol_8c_source.html">Protocol.c</a>.</p>

</div>
</div>
<a id="a99477ad87d28270f1b3c437d2d01e36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99477ad87d28270f1b3c437d2d01e36b">&#9670;&nbsp;</a></span>protocol_get_firmware_information()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t protocol_get_firmware_information </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>protocol_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_firmware___information__t.html">Firmware_Information_t</a> *&#160;</td>
          <td class="paramname"><em>information</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the information about the firmware of the connected device. </p>
<p>This function sends a message to the connected device to query information about the firmware and waits for the answer. The reply message is evaluated and firmware information is written into the provided structure.</p>
<p>Note: This function allocates memory to hold the firmware description string. The caller must take core for freeing that memory when it's no longer needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">protocol_handle</td><td>A handle to an open connection returned. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">information</td><td>A pointer to the structure, where the firmware information will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the provided handle is valid, 0 will be returned and firmware information will be written to information. Otherwise a negative error code is returned and pVersion will not be modified. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_protocol_8c_source.html#l00670">670</a> of file <a class="el" href="_protocol_8c_source.html">Protocol.c</a>.</p>

</div>
</div>
<a id="ad0b74eaf568e59087311055790131c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b74eaf568e59087311055790131c1c">&#9670;&nbsp;</a></span>protocol_get_num_endpoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t protocol_get_num_endpoints </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>protocol_handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the number of endpoints in the connected device. </p>
<p>When the connection is established (see <a class="el" href="_protocol_8c.html#a9f43c7e3d4ce0fd097a22574238b2f7f">protocol_connect</a>), information about the endpoints in the connected device is retrieved. A device compatible with the communication protocol contains at least one endpoint. If a board reports to have no endpoints, the connection won't be established. This function returns the number of endpoints received when the connection was established. The number of endpoints is not queried from the device again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">protocol_handle</td><td>A handle to an open connection returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the provided handle is valid, a positive number of endpoints is returned, otherwise a negative error code is returned. This function won't return 0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_protocol_8c_source.html#l00657">657</a> of file <a class="el" href="_protocol_8c_source.html">Protocol.c</a>.</p>

</div>
</div>
<a id="ac196cc8c51a8d3cbd8da26b24547868d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac196cc8c51a8d3cbd8da26b24547868d">&#9670;&nbsp;</a></span>protocol_get_status_code_description()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* protocol_get_status_code_description </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>protocol_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>status_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a human readable description of a status or error code. </p>
<p>Whenever a protocol or endpoint function returns a negative error code or a positive status code sent by an endpoint in a connected device, this function can be used to get a human readable description of that code.</p>
<p>The protocol handle is needed when retrieving a description for a status code sent by the device. When retrieving the description of a negative error code, the handle is ignored. This allows to retrieve error description in case a connection could not be established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">protocol_handle</td><td>A handle to an open connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status_code</td><td>The status or error code to be described.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns a pointer to a zero-terminated string containing the human readable description. The caller must not free or modify the memory pointed to. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_protocol_8c_source.html#l00928">928</a> of file <a class="el" href="_protocol_8c_source.html">Protocol.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="_protocol_8h.html">Protocol.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
